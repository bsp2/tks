
define exception Anything;// "User defined base exception..";
define exception Something extends Anything;// "Some exception..";

define exception UErr1 : UncriticalError; // "Base" exception type
define exception UErr2 : UErr1;
define exception CErr1 : CriticalError; // "Base" exception type
define exception CErr2 : CErr1;


module MTestTryCatchFinally;

class TestTryCatchFinally : TestCase {

   Test2() {
      throw Something "Test2: test exception message";
      assert(true, false, "Test2: never reached.");
   }

   testCritical() {
      boolean bDeathOk = false;
      boolean bAnythingOk = false;
      boolean bCriticalOk = false;
      boolean bFinallyOk = false;

      try {
         try {
            try  {
               loop(100) {
                  die "test";
                  assert(true, false, "Test::die: never reached");
               }
            }
            catch Death e { // "e" shadows all other variables/members.
               ///trace "DeathException message=\""+e.message+"\" caught.";
               //throw Anything(e); // throw new exception with inner exception
               bDeathOk = true;
               throw Anything;
               assert(true, false, "Test::catch Death: never reached.");
            }
         }
         catch Anything a {
            // Catch "Something" exception
            //trace "caught \""+a.name+"\" message=\""+a.message+"\".";
            bAnythingOk = true;
            String s <= null; // "s" is added to the variable namespace of the "Test" function
            print s.length; // triggers InvalidPointer error
            assert(true, false, "Test::<null>.length: never reached.");
         }
      }
      catch(Error e) {
         // Never reached, CriticalError is a better match
         assert(true, false, "Test::catch Error: never reached.");
      }
      catch CriticalError e {
         // Catch "InvalidPointer" exception
         //trace "caught "+e.name+" message=\""+e.message+"\". Stacktrace:\n"+e.stackTrace;
         bCriticalOk = true;
      }
      finally bFinallyOk = true;

      assert(true, bDeathOk, "bDeathOk");
      assert(true, bAnythingOk, "bAnythingOk");
      assert(true, bCriticalOk, "bCriticalOk");
      assert(true, bFinallyOk, "bFinallyOk");
   }


   throwUncritical():String {
      // Set pascal-style return value so this function can return something and throw an (uncritical)
      // exception at the same time
      return = "hello, world.";
      // Throw new "UErr2" exception, if it is not caught, it will just be absorbed by the caller
      throw UErr2 "test uerr2";
      assert(true, false, "throwUncritical(): never reached");
   }

   testAbsorb() {
      String s = throwUncritical();
      // Simply "absorb"/discard uncritical error "UErr1" (thrown in ThrowUncritical())
      // since there is no try/catch in this frame that can handle the exception
      assertObject("hello, world.", s, "s==hello, world.");
   }

   testUncritical() {

      boolean bUncriticalOk = false;
      boolean bCriticalOk = false;
      boolean bFinallyOk = false;

      try {
         try {
            trace throwUncritical(); // The returned String is never printed (return value is discarded)
            assert(true, false, " thrownever reached");
         }
         catch(UErr1 e) {
            // Catch uncritical error "UErr2"
            bUncriticalOk = true;
            assertObject("test uerr2", e.message, "check exception message");
            // Throw new "CErr2" exception; this one *must* be caught! (otherwise the program terminates)
            throw CErr2 "here we go";
         }
         finally {
            assert(true, false, "finally: never reached.");
         }
      }
      catch(CErr1 e) {
         // Catch the critical error "CErr2" (thrown in Test_Catch())
         bCriticalOk = true;
         assertObject("here we go", e.message, "check exception message (critical)");
      }
      finally {
         bFinallyOk = true;
      }

      assert(true, bUncriticalOk, "bUncriticalOk");
      assert(true, bCriticalOk, "bCriticalOk");
      assert(true, bFinallyOk, "bFinallyOk");
   }


}
