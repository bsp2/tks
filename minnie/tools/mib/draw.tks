// ----
// ---- file   : draw.tks
// ---- author : bsp
// ---- legal  : Distributed under terms of the MIT LICENSE.
// ----
// ---- info   : "minnie" binary loader + viewer
// ---- note   :
// ----
// ---- created: 27May2024
// ---- changed: 28May2024, 29May2024, 30May2024, 31May2024, 01Jun2024, 02Jun2024, 03Jun2024
// ----          04Jun2024, 05Jun2024, 07Jun2024, 08Jun2024, 09Jun2024, 10Jun2024, 11Jun2024
// ----          05Jul2025, 06Jul2025, 12Jul2025, 01Aug2025, 02Aug2025, 03Aug2025, 04Aug2025
// ----          05Aug2025, 08Aug2025, 09Aug2025, 10Aug2025, 11Aug2025, 16Aug2025, 17Aug2025
// ----          24Aug2025, 01Sep2025, 07Sep2025
// ----
// ----
// ----

module Main;

use tksdl;
use tkopengl;
use tkmath;
use tktriangulate;

boolean b_force_convert_pt_to_ph = 1;

float vp_scale     = 2;
float fb_scale     = 1.0f;
float geo_scale    = 1.0f;//fb_scale;
float stroke_scale = geo_scale;

int debug_tri_idx = -1;


StringArray tests = [
   "mib/test000_rect.mib",
   "mib/test001_lines.mib",
   "mib/test002_fill.mib",
   "mib/test003_concave.mib",
   "mib/test004_fill.mib",
   "mib/test005_concave.mib",
   "mib/test006_cubic.mib",
   "mib/test007_svg.mib",
   "mib/test008_ellipse.mib",
   "mib/test009_cake.mib",
   "mib/test010_d2d.mib",
   "mib/test011_cursor.mib",
   "mib/test012_stars.mib",
   "mib/test013_reverse.mib",
   "mib/test014_mask.mib",
   "mib/test015_minnie.mib",
   "mib/test016_aa.mib",
   "mib/test017_minnie_aa.mib",
   "mib/test018_cake_aa.mib",
   "mib/test019_3d_aa.mib",
   "mib/test020_clip2d.mib",    // clip pre-tesselate polyline
   "mib/test021_clip2d.mib",    // clip post-tesselate polyline
   "mib/test022_clip2d.mib",    // clip thin line
   "mib/test023_clip2d.mib",    // clip concave pre-tesselate
   "mib/test024_clip2d.mib",    // clip concave post-tesselate
   "mib/test025_clip2d.mib",    // clip concave post-tesselate ("minnie")
   "mib/test026_clip2d.mib",    // transform2d + clip concave post-tesselate
   "mib/test027_clip2dfb.mib",  // clip against fb
   "mib/test028_3d.mib",        // fill convex transform3d clip3d
   "mib/test029_3d.mib",        // extrude polyline transform3d clip3d
   "mib/test030_minnie_3d.mib", // concave transform3d clip3d
   "mib/test031_tf2dclip.mib",
   "mib/test032_subpath.mib",
   "mib/test033_valentines.mib",
   "mib/test034_ducky.mib",
   "mib/test035_bicycle.mib",
   "mib/test036_crab.mib",
   "mib/test037_logo.mib",
   "mib/test038_logo_noaa.mib",
   "mib/test039_wildboar.mib",
   "mib/test040_tiger.mib",
   "mib/test041_rabbit.mib",
   "mib/test042_oil_lamp.mib",
   "mib/test043_elefant.mib",
   "mib/test044_linejoin_miterlimit.mib",
   "mib/test045_linejoin.mib",
   "mib/test046_evenodd.mib",
   "mib/test047_shapes.mib",
   "mib/test048_nano.mib",
   "mib/test049_debug.mib",
   "mib/test050_world.mib",
   "mib/test051_rect.mib",
   "mib/test052_ellipse.mib",
   "mib/test053_elephant.mib",
   "mib/test054_365845.mib",
   "mib/test055_dragon_986054.mib",
   "mib/test056_satellite.mib",
   "mib/test057_lightbulb.mib",
   "mib/test058_motorbike.mib",
   "mib/test059_abstractbike.mib",
   "mib/test060_watermelon.mib",
   "mib/test061_man.mib",
   "mib/test062_gorilla.mib",
   "mib/test063_quill.mib",
   "mib/test064_fairy.mib",
   "mib/test065_fish.mib",
   "mib/test066_cat.mib",
   "mib/test067_reaper.mib",
   "mib/test068_pidgeon.mib",
   "mib/test069_bluejay.mib",
   "mib/test070_fox1.mib",
   "mib/test071_fox2.mib",
   "mib/test072_fox3.mib",
   "mib/test073_cookie.mib",
   "mib/test074_roundrect.mib",
   "mib/test075_roundrect_svg.mib",
   "mib/test076_hamster.mib",
   "mib/test077_giraffe.mib",
   "mib/test078_butterfly.mib",
   "mib/test079_minimal.mib",
   "mib/test080_debug_l1.mib",
   "mib/test081_debug_l2.mib",
   "mib/test082_circle.mib",
   "mib/test083_ellipse_fill.mib",           // see tkminnie/test.tks. not handled by this test script
   "mib/test084_ellipse_stroke.mib",         // see tkminnie/test.tks. not handled by this test script
   "mib/test085_ellipse_fill_stroke.mib",    // see tkminnie/test.tks. not handled by this test script
   "mib/test086_rect_fill.mib",              // see tkminnie/test.tks. not handled by this test script
   "mib/test087_rect_fill_stroke.mib",       // see tkminnie/test.tks. not handled by this test script
   "mib/test088_rect_stroke.mib",            // see tkminnie/test.tks. not handled by this test script
   "mib/test089_roundrect_fill_stroke.mib",  // see tkminnie/test.tks. not handled by this test script
   "mib/test090_roundrect_fill.mib",         // see tkminnie/test.tks. not handled by this test script
   "mib/test091_roundrect_stroke.mib",       // see tkminnie/test.tks. not handled by this test script
                     ];

int test_idx = -1;

String pathNameIn;
Buffer fileBuf;
boolean bParse = true;

function LoadFileBuf() {
   fileBuf.free();
   local File f;
   if(f.openLocal(pathNameIn, IOS_IN))
   {
      f.readBuffer(fileBuf, 0, f.size, true/*bResize*/);
      f.close();
      trace "[dbg] LoadFileBuf: read "+fileBuf.size+" bytes from \""+pathNameIn+"\"";
      Viewport.caption = pathNameIn;
      bParse = true;
   }
   else
   {
      trace "[---] LoadFileBuf: failed to open \""+pathNameIn+"\" for reading";
      bParse = false;
   }
}


// ----------------------------------------------------------------------------
boolean b_queued_screenshot;

function SaveScreenShotPNG(String _pathName) : boolean {
   local Texture tex;
   boolean ret = false;
   if(tex.alloc(Viewport.width, Viewport.height, 4))
   {
      glReadBuffer(GL_BACK);
      int off = 0;
      int y = Viewport.height - 1;
      loop(Viewport.height)
      {
         zglReadColorPixelsX(tex, off, 0/*x*/, y, Viewport.width);
         y--;
         off += Viewport.width;
      }
      ret = tex.saveImage(_pathName);
   }
   return ret;
}


// ----------------------------------------------------------------------------
namespace minniebin;

use namespace ui;

// int MAX_FB_H = 240;

boolean b_allow_aa      = true;
byte    triaa_samples   = 16;
boolean b_draw_tri      = 1;
boolean b_draw_line     = 1;
boolean b_profile       = 1;

boolean b_debug_op       = 3;  // echo parsed ops  2=echo curve/line/blit   3=echo color/stroke
boolean b_debug_pal      = 0;
boolean b_debug_fb       = 0;
boolean b_debug_mat      = 0;
boolean b_debug_clip2d   = 0;
boolean b_debug_clip3d   = 0;
boolean b_debug_paths    = 0;  // 1=show #points  2=verbose
boolean b_debug_line     = 0;  // 2=show draw calls  3=also show untransformed vertices
boolean b_debug_extrude  = 0;  // 2=verbose
boolean b_debug_fill     = 0;  // 1=show batch draw calls  2=also show individual tri draw calls   3=debug 3d transform
boolean b_debug_cubic    = 1;
boolean b_debug_arc      = 2;  // 2=verbose
boolean b_debug_tess     = 0;  // 2=verbose 3=very verbose(per tri)
boolean b_debug_prims    = 1;  // show #points, #lines and #tris at end of file

boolean b_filter = false;  // texture filter
float FILTER_W = 16.0f*2;
float FILTER_H = 12.0f*2;

int total_num_points = 0;
int total_num_lines  = 0;
int total_num_tris   = 0;

int debug_line_idx = 0;


// <class.png>
class StreamReader4 {
   Stream *ifs;
   byte cur_byte;
   int  bit_off;

   public method begin(Stream _ifs) {
      ifs <= _ifs;
      cur_byte = 0;
      bit_off = 8;
   }

   public method read4() {
      if(8 == bit_off)
      {
         cur_byte = ifs.u8;
         bit_off = 0;
      }
      byte r = (cur_byte >> bit_off) & 15;
      bit_off += 4;
      return r;
   }

   public method read12u() : short {
      // unsigned
      short r = read4();
      r |= (read4() << 4);
      r |= (read4() << 8);
      return r;
   }

   public method read12s() : int {
      // sign-extend
      int r = read4();
      r |= (read4() << 4);
      r |= (read4() << 8);
      if(r & 2048)
         r |= 0xFFFFF000;
      return r;
   }

   public method end() {
      bit_off = 0;
   }
}


// <class.png>
class Framebuffer {
   int fb_idx;
   int w;
   int h;
   Texture *tex;

   public method init(int _fbIdx, int _w, int _h) {
      w = _w;
      h = _h;
      tex <= new Texture;
      if(b_filter)
      {
         tex.alloc(w + FILTER_W, h + FILTER_H, 4);
         tex.flags = TEX_MINFILTERLINEAR | TEX_MAGFILTERLINEAR;
      }
      else
      {
         tex.alloc(w, h, 4);
      }
   }
}


// <class.png>
class Path {
   define int TYPE_DRAW      = 0;  // 0x84: no points / no tesselator (main draw list)
   define int TYPE_CONVEX    = 1;  // 0x84: no tesselator
   define int TYPE_CONCAVE   = 2;  // 0x85: (simple) ear-clipping tesselator
   define int TYPE_EVENODD   = 3;  // 0x87: SGI/VG tesselator (can add holes with sub-paths)
   define int TYPE_IMMEDIATE = 4;  // 0x8D: specialized render functions (rect, roundrect, ellipse, circle, ..)  (todo) render (only implemented in tkminnie for now)

   // https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty
   define int LINECAP_NONE   = 0;
   define int LINECAP_BUTT   = 1;
   define int LINECAP_ROUND  = 2;
   define int LINECAP_SQUARE = 3;

   define int LINEJOIN_NONE  = 0;
   define int LINEJOIN_MITER = 1;
   define int LINEJOIN_ROUND = 2;
   define int LINEJOIN_BEVEL = 3;

   int        path_idx;
   FloatArray points;
   boolean    b_closed;
   byte       type;     // see TYPE_xxx (>1: tesselate when (closed) path is filled)

   IntArray   *ia_fill;   // cached tesselated triangle indices

   static IntArray *left;   // temporary tesselator array (used by tesselateConvex())
   static IntArray *right;  // temporary tesselator array

   FloatArray     va_extrude;   // cached extruded polyline vertices
   IntArray       ia_extrude;   // (todo)
   ShapePolyline *shape_extrude;
   float          extrude_stroke_w;  // stroke_w for which the cache is valid
   byte           extrude_join_cap;  // join+cap for which the cache is valid
   int            extrude_num_seg;   // num_seg (round joints) for which the cache is valid

   Path *parent_path;  // !=null: is sub path
   Path *[] sub_paths;

   public method init(int _pathIdx, byte _type) {
      path_idx         = _pathIdx;
      extrude_stroke_w = 0;
      type             = _type;
   }

   public method initFromFbRect(int _w, int _h) {
      points.empty();
      points.add2( 0,  0);
      points.add2(_w,  0);
      points.add2(_w, _h);
      points.add2( 0, _h);
      b_closed = true;
   }

   public method lazyBegin(float _lx, float _ly) {
      if(points.isEmpty())
         points.add2(_lx, _ly);
   }

   public method lineTo(float _px, float _py) {
      // trace "xxx lineTo("+_px+";"+_py+")";
      points.add2(_px, _py);
   }

   public method rect(float _x, float _y, float _w, float _h) {
      points.add2(_x,      _y);
      points.add2(_x + _w, _y);
      points.add2(_x + _w, _y + _h);
      points.add2(_x,      _y + _h);
   }

   public method roundRect(float _x, float _y,
                           float _w, float _h,
                           float _rx, float _ry,
                           int _numSeg,
                           float _minDistSqr
                           ) {
      if(_rx < 0.001f && _ry < 0.001f)
      {
         rect(_x, _y, _w, _h);
      }
      else
      {
         // top
         points.add2(_x + _rx,      _y);
         points.add2(_x + _w - _rx, _y);

         // right-top
         cubicTo(_x + _w - _rx,     _y,            // p
                 _x + _w - _rx*0.5, _y,            // c1
                 _x + _w,           _y + _ry*0.5,  // c2
                 _x + _w,           _y + _ry,      // q
                 _numSeg,
                 _minDistSqr
                 );

         // right
         points.add2(_x + _w, _y + _h - _ry);

         // right-bottom
         cubicTo(_x + _w,           _y + _h - _ry,      // p
                 _x + _w,           _y + _h - _ry*0.5,  // c1
                 _x + _w - _rx*0.5, _y + _h,            // c2
                 _x + _w - _rx,     _y + _h,            // q
                 _numSeg,
                 _minDistSqr
                 );

         // bottom
         points.add2(_x + _rx, _y + _h);

         // left-bottom
         cubicTo(_x + _rx,     _y + _h,            // p
                 _x + _rx*0.5, _y + _h,            // c1
                 _x,           _y + _h - _ry*0.5,  // c2
                 _x,           _y + _h - _ry,      // q
                 _numSeg,
                 _minDistSqr
                 );

         // left
         points.add2(_x, _y + _ry);

         // left-top
         cubicTo(_x,           _y + _ry,      // p
                 _x,           _y + _ry*0.5,  // c1
                 _x + _rx*0.5, _y,            // c2
                 _x + _rx,     _y,            // q
                 _numSeg,
                 _minDistSqr
                 );
      }
   }

   public method ellipse(float _cx, float _cy, float _rx, float _ry, int _numSeg) {
      float step = 2PI / _numSeg;
      float a = 0;
      loop(_numSeg)
      {
         float x = _cx + cos(a) * _rx;
         float y = _cy + sin(a) * _ry;
         points.add2(x, y);
         a += step;
      }
      b_closed = true;
   }

   public method circle(float _cx, float _cy, float _r, int _numSeg) {
      ellipse(_cx, _cy, _r, _r, _numSeg);
   }

   public method cubicTo(float _px, float _py,
                         float _c1x, float _c1y,
                         float _c2x, float _c2y,
                         float _qx, float _qy,
                         int _numSeg,
                         float _minDistSqr
                         ) {
      // lineTo(_qx, _qy); // xxxxxxxxxxxxxxxxxxxxxxxx
      // return;

      if(b_debug_cubic) trace "[trc] Path::cubicTo: p=("+_px+";"+_py+") c1=("+_c1x+";"+_c1y+") c2=("+_c2x+";"+_c2y+") q=("+_qx+";"+_qy+") #seg="+_numSeg;

      float dsqr = (_qx-_px)*(_qx-_px) + (_qy-_py)*(_qy-_py);
      // float dist = sqrt(dsqr);
      if(dsqr >= _minDistSqr)  // workaround / fix for test066_cat
      {
         float step = 1.0 / _numSeg;
         float t = step;
         loop(_numSeg - 1)
         {
            float pc1x = _px + (_c1x - _px) * t;
            float pc1y = _py + (_c1y - _py) * t;

            float c2qx = _c2x + (_qx - _c2x) * t;
            float c2qy = _c2y + (_qy - _c2y) * t;

            float c12x = _c1x + (_c2x - _c1x) * t;
            float c12y = _c1y + (_c2y - _c1y) * t;

            float m1x = pc1x + (c12x - pc1x) * t;
            float m1y = pc1y + (c12y - pc1y) * t;

            float m2x = c12x + (c2qx - c12x) * t;
            float m2y = c12y + (c2qy - c12y) * t;

            float x = m1x + (m2x - m1x) * t;
            float y = m1y + (m2y - m1y) * t;

            points.add2(x, y);

            t += step;
         }
      }
      points.add2(_qx, _qy);
      // trace "xxx cubicTo points="+points;
      // trace "xxx cubicTo dist="+dist+" #points="+points.numElements;
   }

   public method arcTo(float _px, float _py,
                       float _rx, float _ry,
                       float _rot,
                       boolean _bLargeArcFlag,
                       boolean _bSweepFlag,
                       float _qx, float _qy,
                       int _numSeg
                       ) {
      if(b_debug_arc) trace "[trc] arcTo p=("+_px+";"+_py+") r=("+_rx+";"+_ry+") rot="+(_rot*(360.0f/2PI))+" bLargeArc="+_bLargeArcFlag+" bArcSweep="+_bSweepFlag+" q=("+_qx+";"+_qy+") #seg="+_numSeg;

      // lineTo(_qx, _qy); // xxxxx
      // return;

      if(_rx > 0.0f && _ry > 0.0f)
      {
         // correct out of range radii
         float bx = (_px - _qx) * 0.5f;
         float by = (_py - _qy) * 0.5f;

         float lambda = (bx*bx) / (_rx*_rx) + (by*by) / (_ry*_ry);
         if(b_debug_arc >= 2) trace "[trc] arcTo: lambda="+lambda+" r=("+_rx+";"+_ry+") bLargeArc="+_bLargeArcFlag+" bSweep="+_bSweepFlag;
         float pxd;
         float pyd;
         float cxd;
         float cyd;
         float cx;
         float cy;
         float prx;  // relative to center
         float pry;
         float qrx;
         float qry;
         float angP;
         float angQ;

         if(lambda > 1.0f)
         {
            // radii are smaller than distance between start/end points => start/end angles are opposite from eachother
            //  - largeArcFlag has no effect
            //  - ellipse center is halfway between start/end
            lambda = sqrt(lambda);
            _rx *= lambda;
            _ry *= lambda;
            if(b_debug_arc >= 2) trace "[trc] arcTo: => fixed lambda="+lambda+" new r=("+_rx+";"+_ry+")";
         }

         // x' = x*cos(a) - y*sin(a)
         // y' = x*sin(a) + y*cos(a)
         float cr = cos(_rot);
         float sr = sin(_rot);

         // compute (x1',y1')
         float pxd1 = (_px - _qx) * 0.5f;  // x1'  == bx
         float pyd1 = (_py - _qy) * 0.5f;  // y1'

         pxd = pxd1*cr - pyd1*sr;
         pyd = pxd1*sr + pyd1*cr;

         // compute (cx',cy')
         float rxs = _rx * _rx;
         float rys = _ry * _ry;
         float pxds = pxd * pxd;
         float pyds = pyd * pyd;
         float cfac = sqrt( (rxs*rys - rxs*pyds - rys*pxds) / (rxs*pyds + rys*pxds) );  // +-
         if( (_bLargeArcFlag == _bSweepFlag) ^ 0 )
         {
            cfac = -cfac;
            // if(cfac == 0.0)
            //    cfac = -0.09;
         }
         else
         {
            // if(cfac == 0.0)
            //    cfac = 0.09;
         }
         float cxd1 = (cfac *  (_rx * pyd)) / _ry;
         float cyd1 = (cfac * -(_ry * pxd)) / _rx;

         // compute (cx,cy)
         cxd = cxd1*cr + cyd1*sr;
         cyd = -cxd1*sr + cyd1*cr;

         cx = cxd + (_px + _qx)*0.5;
         cy = cyd + (_py + _qy)*0.5;

         if(1)
         {
            if(b_debug_arc >= 2) trace "[trc] arcTo: dist p=("+_px+";"+_py+") c=("+cx+";"+cy+") r=("+_rx+";"+_ry+") cfac="+cfac+"  p-c="+sqrt( (_px-cx)*(_px-cx) + (_py-cy)*(_py-cy) );
         }

         // calc start / end angles
         prx = (_px - cx) / _rx;  // relative to center + normalize
         pry = (_py - cy) / _ry;
         // trace "xxx prx="+prx;
         angP = (prx > 1.0f) ? 0.0f : (prx < -1.0f) ? PI : acos(prx);  // >1 workaround for micro-overflows (which would result in NaN)
         if(pry < 0.0f)
            angP = 2PI - angP;

         qrx = (_qx - cx) / _rx;
         qry = (_qy - cy) / _ry;
         angQ = (qrx > 1.0f) ? 0.0f : acos(qrx);  // >1 workaround for micro-overflows (which would result in NaN)
         if(qry < 0.0f)
            angQ = 2PI - angQ;

         if(b_debug_arc >= 2) trace "[trc] arcTo: p=("+_px+";"+_py+") q=("+_qx+";"+_qy+")  => c=("+cx+";"+cy+")  pr=("+prx+";"+pry+")  qr=("+qrx+";"+qry+")  angP="+(angP*(360/2PI))+"  angQ="+(angQ*(360/2PI));

         float w;
         float aDelta;

         if(angP > angQ)
         {
            if(b_debug_arc >= 2) trace "[trc] arcTo: angP > angQ";
            if(lambda < 1.0f)
            {
               if( (angP - angQ) >= PI )
               {
                  if(_bLargeArcFlag)
                     aDelta = angQ - angP;
                  else
                  {
                     angP -= 2PI;
                     aDelta = angQ - angP;
                  }
               }
               else
               {
                  if(_bLargeArcFlag)
                     aDelta = angQ + 2PI - angP;
                  else
                     aDelta = angQ - angP;
               }
            }
            else
            {
               if(_bLargeArcFlag)
                  aDelta = angP - angQ;
               else
                  aDelta = angQ - angP;
               if(_bSweepFlag != _bLargeArcFlag)
                  aDelta = -aDelta;
            }
         }
         else
         {
            if(b_debug_arc >= 2) trace "[trc] arcTo: angP <= angQ";
            if(lambda < 1.0f)
            {
               if( (angQ - angP) >= PI)
               {
                  if(_bLargeArcFlag)
                     aDelta = angQ - angP;
                  else
                  {
                     angQ -= 2PI;
                     aDelta = angQ - angP;
                  }
               }
               else
               {
                  if(_bLargeArcFlag)
                     aDelta = angQ - angP - 2PI;
                  else
                     aDelta = angQ - angP;
               }
            }
            else
            {
               if(_bLargeArcFlag)
                  aDelta = angQ - angP;
               else
                  aDelta = angP - angQ;
               if(_bSweepFlag != _bLargeArcFlag)
                  aDelta = -aDelta;
            }
         }

         w = aDelta / _numSeg;

         if(b_debug_arc >= 2) trace "[trc] arcTo: interp  angP="+(angP*(360/2PI))+"  angQ="+(angQ*(360/2PI))+"  aDelta="+(aDelta*(360/2PI))+"  w="+(w*(360/2PI));

         float a = angP + w;
         loop(_numSeg - 1)
         {
            float x = cos(a) * _rx + cx;
            float y = sin(a) * _ry + cy;

            // trace "xxx add arc point ("+x+";"+y+")";
            points.add2(x, y);
            a += w;
         }

         points.add2(_qx, _qy);
      }
      else
      {
         // invalid radius => straight line
         //  (note) should not be reachable when .mib has been generated with 'minnie'
         points.add2(_qx, _qy);
      }
   }

   public method end(boolean _bClosed) {
      if(b_debug_paths && path_idx > 0) trace "[dbg] Minnie::Path::end: path idx="+path_idx+" has "+(points.numElements/2)+" points";
      total_num_points += (points.numElements/2);
      b_closed = _bClosed;
   }

   public method addSubPath(Path _p) {
      _p.parent_path <= this;
      sub_paths.add(#(deref _p));
      if(b_debug_paths >= 2) trace "[dbg] Minnie::Path::addSubPath: this="+#(this)+"(idx="+path_idx+") sub_paths="+#(sub_paths);
   }

   public method extrudeShape(FloatArray _points, float _strokeW, byte _joinCapMode, int _roundNumSeg, float _miterLimit) {
      shape_extrude <= new ShapePolyline;
      shape_extrude.initShapePolyline();

      if(_points.get(0) == _points.getRev(1) &&  // first equals last point ?
         _points.get(1) == _points.getRev(0))
         _points.numElements -= 2;

      shape_extrude.setLineVerticesRef(_points);

      shape_extrude.setLineWidth(_strokeW);  // radius
      byte lineJoin = (_joinCapMode & 15);
      shape_extrude.setLineJointType( (lineJoin == LINEJOIN_BEVEL)   ? ShapePolyline.LINE_JOINT_BEVEL
                                      : (lineJoin == LINEJOIN_MITER) ? ShapePolyline.LINE_JOINT_MITER
                                      : (lineJoin == LINEJOIN_ROUND) ? ShapePolyline.LINE_JOINT_ROUND
                                      : ShapePolyline.LINE_JOINT_NONE
                                      );
      byte lineCap = (_joinCapMode>>4) & 15;
      shape_extrude.setLineCapType( (lineCap == LINECAP_BUTT)     ? ShapePolyline.LINE_CAP_BUTT
                                    : (lineCap == LINECAP_ROUND)  ? ShapePolyline.LINE_CAP_ROUND
                                    : (lineCap == LINECAP_SQUARE) ? ShapePolyline.LINE_CAP_SQUARE
                                    : ShapePolyline.LINE_CAP_NONE
                                    );
      shape_extrude.setEnableClosed(b_closed);
      if(b_debug_extrude >= 2) trace "[trc] shape_extrude: b_closed="+b_closed;
      shape_extrude.setMiterLimit(_miterLimit);
      shape_extrude.setNumDivRoundLineJoint(_roundNumSeg);

      // (todo) emit indices
      shape_extrude.tesselate();

      va_extrude <= shape_extrude.getTriVertices();
      ia_extrude <= new IntArray;
      ia_extrude.identity(va_extrude.numElements / 2);

      extrude_stroke_w = _strokeW;
      extrude_join_cap = _joinCapMode;
      extrude_num_seg  = _roundNumSeg;
   }

   public method tesselateConvex() : boolean {
      // originally written by Nils Pipenbrinck for VG_tesselator
      //  "The topology is much better than using simple fans/strips."
      //
      //  (note) unused
      //
      if(null == left)
      {
         left <= new IntArray;
         left.allocAndFill(32, 0);  // enough for 2^32 vertices

         right <= new IntArray;
         right.allocAndFill(32, 0);  // enough for 2^32 vertices
      }

      int SignFlag = 0;
      int stacktop;
      int l,r,m;

      left[0]  = 0;
      right[0] = (points.numElements/2)-1;  // src->m_NumVertices-1;
      stacktop = 1;

      while(stacktop)
      {
         stacktop--;
         l = left[stacktop];
         r = right[stacktop];
         m = (l+r)>>1;

         if ((m != l) && (m != r))
         {
            float Area;
            // const VGES_Vector2 * a = &src->m_Vertices[l];
            // const VGES_Vector2 * b = &src->m_Vertices[m];
            // const VGES_Vector2 * c = &src->m_Vertices[r];

            // Area =
            //    (a->x - c->x) * (b->y - c->y) -
            //    (a->y - c->y) * (b->x - c->x);

            Area =
               (points.get(l*2+0) - points.get(r*2+0)) * (points.get(m*2+1) - points.get(r*2+1)) -
               (points.get(l*2+1) - points.get(r*2+1)) * (points.get(m*2+0) - points.get(r*2+0)) ;

            if(b_debug_tess >= 3) trace "[trc] Path::tesselateConvex: area="+Area+" l="+l+" m="+m+" r="+r;

            // do not touch degeneracies
            if(0.0f != Area)  // !VGES_NEARZERO (Area))
            {
               // if we don't yet have a valid sign-flag:
               if(0 == SignFlag)
               {
                  // Get area-sign of first triangle.
                  SignFlag = (Area < 0) ? -1 : 1;
               }
               else
               {
                  // Check triangle against first Area-Sign.
                  // return if we have a sign-flip.
                  if(SignFlag != ((Area < 0) ? -1 : 1))
                  {
                     trace "[---] Path::tesselateConvex: sign flip (area="+Area+")";
                     return false;
                  }
               }
            }

            // recursive subdivide:
            if (m-l > 1) { left[stacktop] = l; right[stacktop] = m; stacktop++; }
            if (r-m > 1) { left[stacktop] = m; right[stacktop] = r; stacktop++; }
         }
      }

      // everything went well?
      if(SignFlag)
      {
         int FaceCnt = (points.numElements/2) - 2; // src->m_NumVertices-2;

         // Tesselate once more, this time write the index and edge data:
         left[0]  = 0;
         right[0] = (points.numElements/2)-1;
         stacktop = 1;
         // // int n = 0;

         ia_fill <= new IntArray;
         ia_fill.alloc(FaceCnt * 3);

         while(stacktop)
         {
            stacktop--;
            l = left[stacktop];
            r = right[stacktop];
            m = (l+r)>>1;

            if((m != l) && (m != r))
            {
               ia_fill.add(l);  // out->m_IndexBuffer[n++] = (VGushort)l;
               ia_fill.add(m);  // out->m_IndexBuffer[n++] = (VGushort)m;
               ia_fill.add(r);  // out->m_IndexBuffer[n++] = (VGushort)r;
               if (m-l > 1) { left[stacktop] = l; right[stacktop] = m; stacktop++; }
               if (r-m > 1) { left[stacktop] = m; right[stacktop] = r; stacktop++;  }
            }
         }

         // Succeeded
         return true;
      }

      // Failed
      return false;
   }

/*
https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle

               bool intpoint_inside_trigon(intPoint s, intPoint a, intPoint b, intPoint c) {
                  int as_x = s.x - a.x;
                  int as_y = s.y - a.y;

                  bool s_ab = (b.x - a.x) * as_y - (b.y - a.y) * as_x > 0;

                  if ((c.x - a.x) * as_y - (c.y - a.y) * as_x > 0 == s_ab)
                     return false;
                  if ((c.x - b.x) * (s.y - b.y) - (c.y - b.y)*(s.x - b.x) > 0 != s_ab)
                     return false;
                  return true;
               }
*/

   // <method.png>
   public method tesselateConcave(FloatArray _va) : boolean {
      // ear clipping
      //  - expects clock-wise vertices

      if(b_debug_tess >= 2)
         trace "[trc] tesselateConcave: va="+_va.string2;

      int numVerts = _va.numElements / 2;
      ia_fill <= new IntArray;
      if(numVerts < 3)
         return;
      IntArray indices <= MinnieBin.tmpia_tesselate_concave;
      indices.identity(numVerts);

      ia_fill.alloc( (numVerts-2) * 3);

      int firstIndex = 0;
      int lastIndex = indices.numElements - 1;
      int numIndices = indices.numElements;
      int numIndicesLeft = numIndices;

      int idxCI;

      for(;;)
      {
         if(b_debug_tess >= 3) trace "[trc] Path::tesselateConcave: remove START ---------------------------";
         if(b_debug_tess >= 3) trace "[trc] ~~~~~~~~~~~ numIndicesLeft="+numIndicesLeft+" indices="+indices+" first="+firstIndex+" last="+lastIndex;

         int idxAI = lastIndex;
         while(-1 == indices[lastIndex])
            lastIndex--;
         int idxBI = firstIndex;
         if(-1 == indices[firstIndex])
            firstIndex++;
         // trace "xxx tesselateConcave numIndicesLeft="+numIndicesLeft+" numIndices="+numIndices+" first="+firstIndex+" last="+lastIndex;
         int idxA;
         int idxB;
         int idxC;
         boolean bRemoved;
         loop(numIndicesLeft)
         {
            bRemoved = false;

            idxCI = idxBI + 1;
            if(idxCI > lastIndex)
               idxCI = firstIndex;

            while(-1 == indices[idxCI])
            {
               if(++ idxCI > lastIndex)
                  idxCI = firstIndex;
            }

            idxA = indices.get(idxAI);
            idxB = indices.get(idxBI);
            idxC = indices.get(idxCI);

            if(b_debug_tess >= 3)
               trace "xxx try I("+idxAI+";"+idxBI+";"+idxCI+") = ("+idxA+","+idxB+","+idxC+")";


            if(b_debug_tess >= 3)
            {
               trace "xxx CW check:";
               trace "    vA=("+_va.get(idxA*2+0)+";"+_va.get(idxA*2+1)+")";
               trace "    vB=("+_va.get(idxB*2+0)+";"+_va.get(idxB*2+1)+")";
               trace "    vC=("+_va.get(idxC*2+0)+";"+_va.get(idxC*2+1)+")";
            }

            // (note) sorting by y and checking x-dir of top-edge might be faster when muls are slow
            float vABx = (_va.get(idxB*2+0) - _va.get(idxA*2+0));
            float vABy = (_va.get(idxB*2+1) - _va.get(idxA*2+1));
            float vACx = (_va.get(idxC*2+0) - _va.get(idxA*2+0));
            float vACy = (_va.get(idxC*2+1) - _va.get(idxA*2+1));
            float crossZ = vABx * vACy - vABy * vACx;
            if(b_debug_tess >= 3) trace "[trc] Path::tesselateConcave: crossZ="+crossZ;

            if(crossZ >= 0.0f)
            {
               // clock-wise triangle (idxA, idxB, idxC)
               if(b_debug_tess >= 3) trace "[trc] Path::tesselateConcave: candidate triI=("+idxAI+","+idxBI+","+idxCI+") tri=("+idxA+","+idxB+","+idxC+")";

               // Check if any other vertex lies inside of triangle
               //  (todo) cache results ? (numVerts * ( (numVerts)*3 - 2 )) (lots of bits for e.g. 1000 vertices)

               float ax = _va.get(idxA*2+0);
               float ay = _va.get(idxA*2+1);

               float bx = _va.get(idxB*2+0);
               float by = _va.get(idxB*2+1);

               float cx = _va.get(idxC*2+0);
               float cy = _va.get(idxC*2+1);

               float bxmax = bx - ax;
               float bymay = by - ay;

               float cxmax = cx - ax;
               float cymay = cy - ay;

               float cxmbx = cx - bx;
               float cymby = cy - by;

               int otherIdx = 0;
               loop(numVerts)
               {
                  if( (otherIdx != idxA) && (otherIdx != idxB) && (otherIdx != idxC) )
                  {
                     float sx = _va.get(otherIdx*2+0);
                     float sy = _va.get(otherIdx*2+1);

                     float as_x = sx - ax;
                     float as_y = sy - ay;

                     boolean s_ab = bxmax * as_y - bymay * as_x > 0;

                     if( (cxmax * as_y - cymay * as_x > 0) != s_ab )
                     {
                        if( (cxmbx * (sy - by) - cymby * (sx - bx) > 0) == s_ab )
                        {
                           // within tri
                           if(b_debug_tess >= 3) trace "[trc] Path::tesselateConcave: otherIdx="+otherIdx+" within tri ("+idxA+","+idxB+","+idxC+")";
                           break;
                        }
                     }
                  }

                  otherIdx++;
               }

               if(otherIdx == numVerts)
               {
                  // no other vertex inside of tri => add triangle and remove center vertex
                  // if(9 == idxA && 1 == idxB && 2 == idxC)
                  // {
                  ia_fill.add3(idxA, idxB, idxC);
                  //    trace "xxx remove points="+points.string2;
                  //    trace "    remove addTri vA=("+points.get(idxA*2+0)+";"+points.get(idxA*2+1)+")";
                  //    trace "    remove addTri vB=("+points.get(idxB*2+0)+";"+points.get(idxB*2+1)+")";
                  //    trace "    remove addTri vC=("+points.get(idxC*2+0)+";"+points.get(idxC*2+1)+")";
                  // }
                  if(idxBI == firstIndex)
                  {
                     while(-1 == indices.get(++firstIndex))
                        ;
                  }
                  else if(idxBI == lastIndex)
                  {
                     while(-1 == indices.get(--lastIndex))
                        ;
                  }
                  indices[idxBI] = -1;
                  // // indices.delete(idxBI);
                  if(b_debug_tess >= 2) trace "[trc] Path::tesselateConcave: addTri ("+idxA+","+idxB+","+idxC+")  new indices="+indices+" first="+firstIndex+" last="+lastIndex;
                  bRemoved = true;
                  numIndicesLeft--;

                  // Restart from first index
                  break;
               }
            } // if is CW

            // else: skip and try next vertex
            idxAI = idxBI;
            idxBI = idxCI;
            // // numIndicesLeft--;

         } // loop numIndicesLeft

         if(!bRemoved)
         {
            if(b_debug_tess) trace "[!!!] Path::tesselateConcave: failed (no removable triangles left)";
            break;
         }

         if(b_debug_tess >= 3) trace "[trc] Path::tesselateConcave: numIndicesLeft="+numIndicesLeft;
         if(numIndicesLeft <= 3)
            break;

      } // for(;;)

      // Add remaining triangle
      if(indices.numElements >= 3)
      {
         if(b_debug_tess >= 2)
         {
            trace "[trc] remaining tri: indices="+#(indices);
            trace "[trc] remaining tri: firstIndex="+firstIndex+" ("+indices.get(firstIndex)+")";
            trace "[trc] remaining tri: lastIndex="+lastIndex+" ("+indices.get(lastIndex)+")";
         }
         if(1)
         {
            ia_fill.add(indices.get(lastIndex));
            ia_fill.add(indices.get(firstIndex));
            idxCI = firstIndex + 1;
            if(idxCI > lastIndex)
               idxCI = firstIndex;
            while(-1 == indices[idxCI])
            {
               idxCI++;
               if(idxCI > lastIndex)
                  idxCI = firstIndex;
            }
            if(b_debug_tess >= 3) trace "[trc] remaining tri: CIndex="+idxCI+" ("+indices.get(idxCI)+")";
            ia_fill.add(indices.get(idxCI));

            if(b_debug_tess >= 2)
               trace "[trc] Path::tesselateConcave: add remaining tri=("+indices.get(lastIndex)+","+indices.get(firstIndex)+","+indices.get(idxCI)+")";
         }
      }

      if(b_debug_tess) trace "[trc] Path::tesselateConcave: #ia_fill="+ia_fill.numElements+" numVerts="+numVerts;
      return true;
   }

   // <method.png>
   public method tesselateHoles(FloatArray _vaIn, FloatArray _vaOut) : boolean {

      int numElem = _vaIn.numElements;
      if(numElem > 0)
      {
         local Triangulate tri;
         tri.engine = TRIANGULATE_VGTESSELATE_DEFAULT;
         if(1)
         {
            if(_vaIn.get(0) == _vaIn.getRev(1) &&  // first equals last point ?
               _vaIn.get(1) == _vaIn.getRev(0))
               numElem -= 2;
            if(numElem >= (2*3))
            {
               if(b_debug_tess >= 2) trace "xxx tesselateHoles: add numVert="+(numElem/2)+" origNumVert="+(_vaIn.numElements/2);
               tri.addPolygonRegion(_vaIn, 0, numElem);
            }
         }
         if(@(_vaIn) == @(points))
         {
            Path *sp;
            foreach sp in sub_paths
            {
               numElem = sp.points.numElements;
               if(numElem > 0)
               {
                  if(sp.points.get(0) == sp.points.getRev(1) &&  // first equals last point ?
                     sp.points.get(1) == sp.points.getRev(0))
                     numElem -= 2;
                  if(numElem >= (2*3))
                  {
                     if(b_debug_tess >= 2) trace "xxx tesselateHoles: add sp numVert="+(numElem/2)+" origNumVert="+(sp.points.numElements/2);
                     tri.addPolygonRegion(sp.points, 0, numElem);
                  }
               }
            }
         }
         else if(sub_paths.numElements > 0)
         {
            trace "[~~~] :Path::tesselateHoles: skipping 2d/3d transformed sub-paths (missing implementation)";
         }

         tri.triangulate();

         ia_fill <= new IntArray;
         if(tri.storeResultIndexed(_vaOut, ia_fill))
         {
            if(b_debug_tess) trace "[trc] Path::tesselateHoles: #vertices="+(_vaOut.numElements/2)+" #indices="+ia_fill.numElements;
            if(b_debug_tess >= 2) trace "[trc] Path::tesselateHoles: vaOut="+#(_vaOut)+" ia="+#(ia_fill);
            return true;
         }
      }
      return false;
   }

}


// <class.png>
class MinnieBin {
   int geo_w;
   int geo_h;
   IntArray palette;  // c32 initialized from RGB444
   Framebuffer *[] framebuffers;
   float aa_bias;
   Matrix2x3f *[] matrices_2d;
   Matrix4f   *[] matrices_3d;  // read from 3x3 matrix
   Path *[] paths;  // in reverse order
   Path *cur_path;
   Path *last_parent_path;
   int   sub_path_rel_idx;  // (todo) REMOVE    from 1..n (increases with each sub path, resets when new main path is defined)
   Path *path_fb;
   float last_x;
   float last_y;

   byte         cur_pal_idx;
   int          cur_c32;
   Matrix2x3f   cur_mat_2d;
   Matrix4f     cur_mat_3d;
   boolean      b_aa;
   Framebuffer *cur_fb;
   Framebuffer *cur_src_fb;
   float        cur_x;
   float        cur_y;
   short        cur_mask_idx;  // -1=none
   float        cur_stroke_w;
   byte         cur_join_cap;
   int          cur_num_seg;
   float        cur_miter_limit;
   Path        *cur_clip2d_path;
   boolean      b_cur_clip2d_pre;
   // // boolean      b_cur_clip_fb;
   boolean      b_cur_clip_3d;
   // // int          cur_clip_3d_vpx;
   // // int          cur_clip_3d_vpy;
   // // int          cur_clip_3d_vpw;
   // // int          cur_clip_3d_vph;
   float        cubic_min_dist_sqr;

   static FloatArray tmpfa_points2;
   static IntArray   tmpia_tesselate_concave;
   static FloatArray tmpfa_clip2;
   static FloatArray tmpfa_clip2d_tmp1;
   static FloatArray tmpfa_va3;
   static FloatArray tmpfa_clip3;
   static IntArray   tmpia_clip3;
   static IntArray   tmpia_clip2;
   static FloatArray tmpfa_proj2;


   // <method.png>
   public method reset() {
      framebuffers.free();
      matrices_2d.free();
      matrices_3d.free();
      paths.free();
      palette.free();

      last_x       = 0;
      last_y       = 0;

      cur_mat_2d.initIdentity();
      cur_mat_3d.initIdentity();

      b_aa         = false;

      cur_x              = 0;
      cur_y              = 0;
      cur_mask_idx       = -1;
      cur_stroke_w       = 0;
      cur_num_seg        = 6;
      cur_miter_limit    = 32.0;
      cur_pal_idx        = 1;
      cur_c32            = #FFffffff;
      cur_join_cap       = Path.LINEJOIN_BEVEL | (Path.LINECAP_ROUND << 4);
      cur_clip2d_path   <= null;
      b_cur_clip2d_pre   = false;
      // b_cur_clip_fb      = false;
      b_cur_clip_3d      = false;
      cubic_min_dist_sqr = 4.0;

      total_num_points = 0;
      total_num_lines  = 0;
      total_num_tris   = 0;
   }

   // <method.png>
   protected method translateAndScalePoints(FloatArray _vaPoints, FloatArray _vaOut) {
      _vaOut.empty();
      int vaOff = 0;
      loop(_vaPoints.numElements / 2)
      {
         _vaOut.add2((_vaPoints.get(vaOff+0) + cur_x) * geo_scale,
                     (_vaPoints.get(vaOff+1) + cur_y) * geo_scale
                     );
         vaOff += 2;
      }
   }

   // <method.png>
   protected method updateAndGetPathFb() : Path {
      if(null == path_fb)
         path_fb <= new Path;
      path_fb.initFromFbRect(cur_fb.w, cur_fb.h);
      return path_fb;
   }

   // <method.png>
   public static Clip2D(FloatArray _vaIn, FloatArray _clipPath, FloatArray _vaOut) {
      // <https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm>
      if(b_debug_clip2d) trace "[dbg] Clip2D ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";

      _vaOut.empty();

      FloatArray vaIn <= tmpfa_clip2d_tmp1;
      vaIn = _vaIn;

      Vector2f e1; e1.init(_clipPath.get(0) * geo_scale, _clipPath.get(1) * fb_scale);
      int clipOff = 2;

      if(b_debug_clip2d) trace "[dbg] Clip2D: loop "+(_clipPath.numElements/2)+" clip path vertices";
      loop( (_clipPath.numElements / 2) )
      {
         _vaOut.empty();

         Vector2f e2; e2.init(_clipPath.get(clipOff+0) * geo_scale, _clipPath.get(clipOff+1) * fb_scale);

         Vector2f vN; vN.init( (e2.y - e1.y),
                               -(e2.x - e1.x)
                               );

         Vector2f vPrev; vPrev.init(vaIn.get(0), vaIn.get(1));
         if(b_debug_clip2d) trace "[dbg] Clip2D: loop "+(vaIn.numElements/2)+" input path vertices  ------- e1="+e1+" e2="+e2+" vN="+vN;
         // trace "#vaIn="+vaIn.numElements;
         int inOff = 2;
         loop( (vaIn.numElements / 2) )
         {
            Vector2f vCur; vCur.init(vaIn.get(inOff+0), vaIn.get(inOff+1));
            Vector2f vIS;
            float dPrev = vPrev.distanceToPlane(e1, vN);
            float dCur  = vCur.distanceToPlane(e1, vN);
            if(b_debug_clip2d) trace "[dbg] Clip2D: inOff="+inOff+" v1="+vPrev+" v2="+vCur+" e1="+e1+" e2="+e2+" vN="+vN+" dPrev="+dPrev+" dCur="+dCur;

            if(dCur < 0.0f)
            {
               if(dPrev >= 0.0f)
               {
                  vIS.intersect(vPrev, vCur, e1, e2, true/*bExtrapolate*/);
                  _vaOut.add2(vIS.x, vIS.y);
               }
               _vaOut.add2(vCur.x, vCur.y);
            }
            else
            {
               if(dPrev < 0.0f)
               {
                  vIS.intersect(vPrev, vCur, e1, e2, true/*bExtrapolate*/);
                  _vaOut.add2(vIS.x, vIS.y);
               }
            }

            // Next vertex
            vPrev = vCur;
            inOff += 2;
            if(inOff >= vaIn.numElements)
               inOff = 0;
         }

         // trace "xxx Clip2D e1="+e1+" e2="+e2;

         // Next clip edge
         e1 = e2;
         clipOff += 2;
         if(clipOff >= _clipPath.numElements)
            clipOff = 0;

         vaIn = _vaOut;
      }

      if(b_debug_clip2d) trace "[dbg] Clip2D: vaOut="+_vaOut.string2;
   }

   // <method.png>
   public static Clip3DZNear(FloatArray _vaIn3, float _zNear, FloatArray _vaOut3) {
      // <https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm>
      if(b_debug_clip3d) trace "[dbg] Clip3DZNear ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";

      _vaOut3.empty();
      Vector3f vQ; vQ.init(0, 0, _zNear);
      Vector3f vN; vN.init(0, 0, 1);

      Vector3f vPrev; vPrev.init(_vaIn3.get(0), _vaIn3.get(1), _vaIn3.get(2));
      if(b_debug_clip3d) trace "[dbg] Clip3DZNear: loop "+(_vaIn3.numElements/2)+" input path vertices  ------- vN="+vN;
      int inOff = 3;
      loop( (_vaIn3.numElements / 3) )
      {
         Vector3f vCur; vCur.init(_vaIn3.get(inOff+0), _vaIn3.get(inOff+1), _vaIn3.get(inOff+2));
         Vector3f vIS;
         float dPrev = vPrev.distanceToPlane(vQ, vN);
         float dCur  = vCur .distanceToPlane(vQ, vN);
         if(b_debug_clip3d) trace "[trc] Clip3DZNear: inOff="+inOff+" v1="+vPrev+" v2="+vCur+" dPrev="+dPrev+" dCur="+dCur;

         if(dCur >= 0.0f)
         {
            if(dPrev < 0.0f)
            {
               vIS.intersectPlane(vQ, vN, vPrev, vCur);
               if(b_debug_clip3d) trace "[trc] Clip3DZNear: dCur>=0 dPrev<0 vPrev="+vPrev+" vCur="+vCur+" => vIS="+vIS;
               _vaOut3.add3(vIS.x, vIS.y, vIS.z);
            }
            if(b_debug_clip3d) trace "[trc] Clip3DZNear: add vCur="+vCur;
            _vaOut3.add3(vCur.x, vCur.y, vCur.z);
         }
         else
         {
            if(dPrev >= 0.0f)
            {
               vIS.intersectPlane(vQ, vN, vPrev, vCur);
               if(b_debug_clip3d) trace "[trc] Clip3DZNear: dCur<0 dPrev>=0 vPrev="+vPrev+" vCur="+vCur+" => vIS="+vIS;
               _vaOut3.add3(vIS.x, vIS.y, vIS.z);
            }
         }

         // Next vertex
         vPrev = vCur;
         inOff += 3;
         if(inOff >= _vaIn3.numElements)
            inOff = 0;
      }

      // trace "xxx Clip3D e1="+e1+" e2="+e2;

      if(b_debug_clip3d) trace "[dbg] Clip3DZNear: vaOut3="+_vaOut3.string3;
   }

   public static ClipIndexedTris2D(FloatArray _va, IntArray _iaIn, FloatArray _clipPath, IntArray _iaOut) {
      // <https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm>
      if(b_debug_clip2d) trace "[dbg] ClipIndexedTris2D ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
      if(b_debug_clip2d) trace "[dbg]   #vert="+(_va.numElements/2)+" #ind="+_iaIn.numElements+" #tris="+(_iaIn.numElements/3);

      _iaOut.empty();

      int triOff = 0;
      loop(_iaIn.numElements / 3)
      {
         IntArray iaTriIn;
         iaTriIn.empty();
         iaTriIn.add(_iaIn.get(triOff + 0));
         iaTriIn.add(_iaIn.get(triOff + 1));
         iaTriIn.add(_iaIn.get(triOff + 2));

         Vector2f e1; e1.init(_clipPath.get(0) * geo_scale, _clipPath.get(1) * fb_scale);

         if(b_debug_clip2d >= 2) trace "[trc] ClipIndexedTris2D: loop "+(_clipPath.numElements/2)+" clip path vertices";
         IntArray iaTriOut;
         int clipOff = 2;
         int iaOff;
         loop( (_clipPath.numElements / 2) )
         {
            iaTriOut.empty();

            Vector2f e2; e2.init(_clipPath.get(clipOff+0) * geo_scale, _clipPath.get(clipOff+1) * fb_scale);
            Vector2f vN; vN.init( (e2.y - e1.y),
                                  -(e2.x - e1.x)
                                  );

            if(b_debug_clip2d >= 2) trace "[trc] ClipIndexedTris2D: loop "+(iaTriIn.numElements)+" tri indices   ------- e1="+e1+" e2="+e2+" vN="+vN;

            Vector2f vPrev; vPrev.init(_va.get(iaTriIn.get(0)*2+0), _va.get(iaTriIn.get(0)*2+1));
            // trace "xxx vPrev="+vPrev;

            iaOff = 1;
            loop(iaTriIn.numElements)
            {
               Vector2f vCur; vCur.init(_va.get(iaTriIn.get(iaOff)*2+0), _va.get(iaTriIn.get(iaOff)*2+1));
               // trace "xxx vCur="+vCur;
               Vector2f vIS;
               float dPrev = vPrev.distanceToPlane(e1, vN);
               float dCur  = vCur.distanceToPlane(e1, vN);
               if(b_debug_clip2d >= 2) trace "[trc] ClipIndexedTris2D: iaOff="+iaOff+" v1="+vPrev+" v2="+vCur+" e1="+e1+" e2="+e2+" vN="+vN+" dPrev="+dPrev+" dCur="+dCur;

               if(dCur < 0.0f)
               {
                  if(dPrev >= 0.0f)
                  {
                     vIS.intersect(vPrev, vCur, e1, e2, true/*bExtrapolate*/);
                     // trace "xxx add vIS idx="+(_va.numElements/2);
                     iaTriOut.add(_va.numElements/2);
                     _va.add2(vIS.x, vIS.y);
                  }
                  iaTriOut.add(iaTriIn.get(iaOff));
               }
               else
               {
                  if(dPrev < 0.0f)
                  {
                     vIS.intersect(vPrev, vCur, e1, e2, true/*bExtrapolate*/);
                     if(b_debug_clip2d >= 2) trace "[dbg] add vIS idx="+(_va.numElements/2);
                     iaTriOut.add(_va.numElements/2);
                     _va.add2(vIS.x, vIS.y);
                  }
               }

               // Next vertex
               vPrev = vCur;
               iaOff++;
               if(iaOff >= iaTriIn.numElements)
                  iaOff = 0;
            } // loop tri indices

            // trace "xxx Clip2D e1="+e1+" e2="+e2;

            // Next clip edge
            e1 = e2;
            clipOff += 2;
            if(clipOff >= _clipPath.numElements)
               clipOff = 0;

            iaTriIn = iaTriOut;
         } // loop clip path

         if(b_debug_clip2d) trace "[trc] triIdx="+(triOff/3)+" iaTriOut="+iaTriOut;
         if(iaTriOut.numElements >= 3)
         {
            iaOff = 2;
            loop(iaTriOut.numElements - 2)
            {
               _iaOut.add(iaTriOut.get(0));
               _iaOut.add(iaTriOut.get(iaOff - 1));
               _iaOut.add(iaTriOut.get(iaOff));
               iaOff++;
            }
         }

         triOff += 3;
      } // loop triangles

      if(b_debug_clip2d) trace "[dbg] ClipIndexedTris2D: iaOut="+_iaOut;
   }

   public static ClipIndexedTris3DZNear(FloatArray _va3, IntArray _iaIn, float _zNear, IntArray _iaOut) {
      // <https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm>
      if(b_debug_clip3d) trace "[dbg] ClipIndexedTris3DZNear ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
      if(b_debug_clip3d) trace "[dbg]   #vert="+(_va3.numElements/2)+" #ind="+_iaIn.numElements+" #tris="+(_iaIn.numElements/3);

      _iaOut.empty();

      Vector3f vQ; vQ.init(0, 0, _zNear);
      Vector3f vN; vN.init(0, 0, 1);

      int triOff = 0;
      loop(_iaIn.numElements / 3)
      {
         IntArray iaTriIn;
         iaTriIn.empty();
         iaTriIn.add(_iaIn.get(triOff + 0));
         iaTriIn.add(_iaIn.get(triOff + 1));
         iaTriIn.add(_iaIn.get(triOff + 2));

         IntArray iaTriOut;
         iaTriOut.empty();

         if(b_debug_clip3d) trace "[trc] ClipIndexedTris3DZNear: loop "+(iaTriIn.numElements)+" tri indices   ------- znear="+_zNear+" vN="+vN;

         Vector3f vPrev; vPrev.init(_va3.get(iaTriIn.get(0)*3+0),
                                    _va3.get(iaTriIn.get(0)*3+1),
                                    _va3.get(iaTriIn.get(0)*3+2)
                                    );
         // trace "xxx vPrev="+vPrev;

         int iaOff = 1;
         loop(iaTriIn.numElements)
         {
            Vector3f vCur; vCur.init(_va3.get(iaTriIn.get(iaOff)*3+0),
                                     _va3.get(iaTriIn.get(iaOff)*3+1),
                                     _va3.get(iaTriIn.get(iaOff)*3+2)
                                     );
            // trace "xxx vCur="+vCur;
            Vector3f vIS;
            float dPrev = vPrev.distanceToPlane(vQ, vN);
            float dCur  = vCur .distanceToPlane(vQ, vN);
            if(b_debug_clip3d >= 2) trace "[trc] ClipIndexedTris3DZNear: iaOff="+iaOff+" v1="+vPrev+" v2="+vCur+" dPrev="+dPrev+" dCur="+dCur;

            if(dCur >= 0.0f)
            {
               if(dPrev < 0.0f)
               {
                  vIS.intersectPlane(vQ, vN, vPrev, vCur);
                  if(b_debug_clip3d) trace "[trc] ClipIndexedTris3DZNear: dCur>=0 dPrev<0 vPrev="+vPrev+" vCur="+vCur+" => vIS="+vIS;
                  // trace "xxx add vIS idx="+(_va3.numElements/2);
                  iaTriOut.add(_va3.numElements/2);
                  _va3.add3(vIS.x, vIS.y, vIS.z);
               }
               iaTriOut.add(iaTriIn.get(iaOff));
            }
            else
            {
               if(dPrev >= 0.0f)
               {
                  vIS.intersectPlane(vQ, vN, vPrev, vCur);
                  if(b_debug_clip3d) trace "[trc] ClipIndexedTris3DZNear: dCur<0 dPrev>=0 vPrev="+vPrev+" vCur="+vCur+" => vIS="+vIS;
                  iaTriOut.add(_va3.numElements/2);
                  _va3.add3(vIS.x, vIS.y, vIS.z);
               }
            }

            // Next vertex
            vPrev = vCur;
            iaOff++;
            if(iaOff >= iaTriIn.numElements)
               iaOff = 0;
         } // loop tri indices

         // trace "xxx Clip2D e1="+e1+" e2="+e2;

         if(b_debug_clip3d) trace "[trc] triIdx="+(triOff/3)+" iaTriOut="+iaTriOut;
         if(iaTriOut.numElements >= 3)
         {
            iaOff = 2;
            loop(iaTriOut.numElements - 2)
            {
               _iaOut.add(iaTriOut.get(0));
               _iaOut.add(iaTriOut.get(iaOff - 1));
               _iaOut.add(iaTriOut.get(iaOff));
               iaOff++;
            }
         }

         triOff += 3;
      } // loop triangles

      if(b_debug_clip3d) trace "[dbg] ClipIndexedTris3DZNear: iaOut="+_iaOut;
   }

   // <method.png>
   protected method transform2DAndTranslateAndScale(FloatArray _vaPoints, FloatArray _vaOut) {
      _vaOut.empty();
      int vaOff = 0;
      loop(_vaPoints.numElements / 2)
      {
         Vector2f v;
         v.init(_vaPoints.get(vaOff+0),
                _vaPoints.get(vaOff+1)
                );
         cur_mat_2d.mulv(v) => v;

         _vaOut.add2( (v.x + cur_x) * geo_scale,
                      (v.y + cur_y) * geo_scale
                     );
         vaOff += 2;
      }
   }

   // <method.png>
   protected method opFillCoverageAA() {
      Texture tex <= cur_fb.tex;
      // trace "xxx opFillCoverageAA";
      tex.clear(0);
   }

   // <method.png>
   protected method opFill(byte _palIdx) {
      Texture tex <= cur_fb.tex;
      Integer c32 = palette.get(_palIdx);
      // trace "xxx opFill(palIdx="+_palIdx+" c32=#"+c32.printf("%08x")+")";
      if(b_aa)
      {
         if(b_debug_fill)
            trace "[trc] opFill: applyClearColorAfterDrawTriAA(c32=#"+c32.printf("%08x")+")";
         tex.applyClearColorAfterDrawTriAA(c32);
      }
      else
         tex.clear(c32);
   }

   // <method.png>
   protected method opLine(float _lx, float _ly, float _x, float _y) {
      Texture tex <= cur_fb.tex;
      // trace "xxx opLine(palIdx="+cur_pal_idx+" c32=#"+cur_c32.printf("%08x")+" l=("+_lx+";"+_ly+") c=("+_x+";"+_y+"))";
      int c32 = cur_c32;
      if(b_debug_line)
         c32 = ((debug_line_idx++&7)<<13) + #ff008080;
      if(b_draw_line)
         tex.drawLine(_lx, _ly, _x, _y, c32);
      total_num_lines++;
   }

   // <method.png>
   protected method drawTri(String _fxn, Vector2f v1, Vector2f v2, Vector2f v3, int c32, int c32Mask) {
      if(b_draw_tri)
      {
         if(b_debug_fill >= 2)
         {
            Integer io32 = c32;
            Integer io32Mask = c32Mask;
            trace "[trc] drawTri<"+_fxn+">: v1="+v1+" v2="+v2+" v3="+v3+" c32=#"+io32.printf("%08x")+" c32Mask=#"+io32Mask.printf("%08x")+" b_aa="+b_aa;
         }

         Texture tex <= cur_fb.tex;
         int numSamples = b_allow_aa ? triaa_samples : 0;
         if(b_aa)
            tex.drawTriAA(v1, v2, v3, c32, numSamples, (numSamples>0)?2:0/*aaFixMode*/, aa_bias);
         else
            tex.drawTri_fx(v1, v2, v3, c32, c32Mask);
      }
      total_num_tris++;
   }

   // <method.png>
   protected method drawPathFillConvex(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillConvex: path_idx="+p.path_idx+" #points="+(p.points.numElements/2)+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      if(b_debug_fill) trace "[trc] drawPathFillConvex: vertices:";
      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.points;
      if(va.numElements >= (3*2))
      {
         v1.init(va.get(0) + cur_x, va.get(1) + cur_y);
         v2.init(va.get(2) + cur_x, va.get(3) + cur_y);
         v1.mulf(geo_scale);
         v2.mulf(geo_scale);

         int vaOff = 4;
         while(vaOff < va.numElements)
         {
            v3.init(va.get(vaOff+0) + cur_x, va.get(vaOff+1) + cur_y);
            // trace "xxx va["+(vaOff/2)+"] = "+v3;
            v3.mulf(geo_scale);

            drawTri("drawPathFillConvex", v1, v2, v3, cur_c32, c32Mask);

            v2 = v3;
            vaOff += 2;
         }
      }
   }

   // <method.png>
   protected method drawPathFillConvexClip(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillConvexClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      FloatArray vaPoints <= tmpfa_points2;
      translateAndScalePoints(p.points, vaPoints/*out*/);

      FloatArray vaClip <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, vaClip/*out*/);

      if(b_debug_fill) trace "[trc] drawPathFillConvexClip: vertices:";
      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      if(vaClip.numElements >= (3*2))
      {
         Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

         v1.init(vaClip.get(0), vaClip.get(1));
         v2.init(vaClip.get(2), vaClip.get(3));

         int vaOff = 4;
         while(vaOff < vaClip.numElements)
         {
            v3.init(vaClip.get(vaOff+0),
                    vaClip.get(vaOff+1)
                    );

            drawTri("drawPathFillConvexClip", v1, v2, v3, cur_c32, c32Mask);

            v2 = v3;
            vaOff += 2;
         }
      }

   }

   // <method.png>
   protected method drawPathFillConvexTransform2d(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillConvexTransform2d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      if(b_debug_fill) trace "[trc] drawPathFillConvexTransform2d: vertices:";
      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.points;
      if(va.numElements >= (3*2))
      {
         v1.init(va.get(0), va.get(1));
         cur_mat_2d.mulv(v1) => v1;
         v1.x = v1.x + cur_x;
         v1.y = v1.y + cur_y;
         v1.mulf(geo_scale);

         v2.init(va.get(2), va.get(3));
         cur_mat_2d.mulv(v2) => v2;
         v2.x = v2.x + cur_x;
         v2.y = v2.y + cur_y;
         v2.mulf(geo_scale);

         int vaOff = 4;
         while(vaOff < va.numElements)
         {
            v3.init(va.get(vaOff+0), va.get(vaOff+1));
            // trace "xxx va["+(vaOff/2)+"] = "+v3;
            cur_mat_2d.mulv(v3) => v3;
            // trace "xxx va["+(vaOff/2)+"] = "+v3+" (xform) mat_2d="+cur_mat_2d;
            v3.x = v3.x + cur_x;
            v3.y = v3.y + cur_y;
            v3.mulf(geo_scale);

            drawTri("drawPathFillConvexTransform2d", v1, v2, v3, cur_c32, c32Mask);

            v2 = v3;
            vaOff += 2;
         }
      }

   }

   // <method.png>
   protected method drawPathFillConvexTransform2dClip(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillConvexTransform2dClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      FloatArray vaPoints <= tmpfa_points2;
      transform2DAndTranslateAndScale(p.points, vaPoints);

      FloatArray vaClip <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, vaClip/*out*/);

      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      if(b_debug_fill) trace "[trc] drawPathFillConvexTransform2d: vertices:";
      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      if(vaClip.numElements >= (3*2))
      {
         v1.init(vaClip.get(0), vaClip.get(1));
         v2.init(vaClip.get(2), vaClip.get(3));

         int vaClipOff = 4;
         while(vaClipOff < vaClip.numElements)
         {
            v3.init(vaClip.get(vaClipOff+0), vaClip.get(vaClipOff+1));

            drawTri("drawPathFillConvexTransform2dClip", v1, v2, v3, cur_c32, c32Mask);

            v2 = v3;
            vaClipOff += 2;
         }
      }
   }

   // <method.png>
   protected method drawPathFillConvexTransform3d(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillConvexTransform3d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      if(b_debug_fill) trace "[trc] drawPathFillConvexTransform3d: vertices:";
      Vector4f v1;
      Vector4f v2;
      Vector4f v3;
      Vector2f v1s;
      Vector2f v2s;
      Vector2f v3s;
      FloatArray va <= p.points;
      if(va.numElements >= (3*2))
      {
         v1.init(va.get(0), va.get(1), 0, 1);
         if(b_debug_fill >= 3) trace "xxx drawPathFillConvexTransform3d: v1="+v1+" cur_mat_3d="+cur_mat_3d;
         cur_mat_3d.mulv(v1) => v1;
         if(b_debug_fill >= 3) trace "xxx drawPathFillConvexTransform3d: v1_3d="+v1;
         v1.divz() => v1s;
         if(b_debug_fill >= 3) trace "xxx drawPathFillConvexTransform3d: v1s_proj="+v1s;
         v1s.x = v1s.x + cur_x;
         v1s.y = v1s.y + cur_y;
         if(b_debug_fill >= 3) trace "xxx drawPathFillConvexTransform3d: v1s_tcur="+v1s;
         v1s.mulf(geo_scale);
         if(b_debug_fill >= 3) trace "xxx drawPathFillConvexTransform3d: v1s_final="+v1s;

         v2.init(va.get(2), va.get(3), 0, 1);
         cur_mat_3d.mulv(v2) => v2;
         v2.divz() => v2s;
         v2s.x = v2s.x + cur_x;
         v2s.y = v2s.y + cur_y;
         v2s.mulf(geo_scale);

         int vaOff = 4;
         while(vaOff < va.numElements)
         {
            v3.init(va.get(vaOff+0), va.get(vaOff+1), 0, 1);
            // trace "xxx va["+(vaOff/2)+"] = "+v3;
            cur_mat_3d.mulv(v3) => v3;
            // trace "xxx va["+(vaOff/2)+"] = "+v3+" (xform) mat_2d="+cur_mat_2d;
            v3.divz() => v3s;
            v3s.x = v3s.x + cur_x;
            v3s.y = v3s.y + cur_y;
            v3s.mulf(geo_scale);

            drawTri("drawPathFillConvexTransform3d", v1s, v2s, v3s, cur_c32, c32Mask);

            v2s = v3s;
            vaOff += 2;
         }
      }

   }

   // <method.png>
   protected method drawPathFillConvexTransform3dClip(Path p) {
      // (todo) clip against fov/2 angled frustum planes ?
      if(b_debug_fill) trace "[dbg] drawPathFillConvexTransform3dClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // Transform points from 2D to 3D
      FloatArray vaPoints <= p.points;
      FloatArray va3 <= tmpfa_va3;
      va3.empty();
      if(vaPoints.numElements >= (3*2))
      {
         Vector4f v1;
         Vector4f v2;
         Vector4f v3;

         v1.init(vaPoints.get(0), vaPoints.get(1), 0, 1);
         v2.init(vaPoints.get(2), vaPoints.get(3), 0, 1);

         cur_mat_3d.mulv(v1) => v1;
         cur_mat_3d.mulv(v2) => v2;

         va3.add3(v1.x, v1.y, v1.z);
         va3.add3(v2.x, v2.y, v2.z);

         if(b_debug_fill >= 3) trace "xxx drawPathFillConvexTransform3dClip: v1="+v1+" cur_mat_3d="+cur_mat_3d;
         if(b_debug_fill >= 3) trace "xxx drawPathFillConvexTransform3dClip: v1_3d="+v1;

         int vaOff = 4;
         while(vaOff < vaPoints.numElements)
         {
            v3.init(vaPoints.get(vaOff+0), vaPoints.get(vaOff+1), 0, 1);
            // trace "xxx va["+(vaOff/2)+"] = "+v3;
            cur_mat_3d.mulv(v3) => v3;
            va3.add3(v3.x, v3.y, v3.z);

            // Next 2D point
            vaOff += 2;
         }

         // Clip 3D points against near plane
         FloatArray vaClip3 <= tmpfa_clip3;
         Clip3DZNear(va3, 0.01f/*znear*/, vaClip3);

         // Project to 2D
         FloatArray vaProj <= tmpfa_proj2;
         vaProj.empty();
         vaOff = 0;
         loop(vaClip3.numElements / 3)
         {
            Vector3f vProj;
            vProj.init(vaClip3.get(vaOff+0),
                       vaClip3.get(vaOff+1),
                       vaClip3.get(vaOff+2)
                       );

            vProj.divz();
            // // trace "xxx va["+(vaOff/2)+"] = "+v3+" (xform) mat_2d="+cur_mat_2d;

            vaProj.add2( (vProj.x + cur_x) * geo_scale,
                         (vProj.y + cur_y) * geo_scale
                         );

            // Next clipped 3D vertex
            vaOff += 3;
         }

         // Clip 2D
         Path pFB <= updateAndGetPathFb();
         FloatArray va <= tmpfa_clip2;
         va.empty();
         // trace "xxx vaProj="+vaProj+" pFB.points="+(pFB.points.getString2());
         Clip2D(vaProj, pFB.points, va);

         if(va.numElements >= (3*2))
         {
            int c32 = cur_c32;
            Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

            Vector2f v1s;
            Vector2f v2s;
            v1s.init(va.get(0), va.get(1));
            v2s.init(va.get(2), va.get(3));

            // trace "xxx v1s="+v1s+" v2s="+v2s;

            // v1s.x = v1s.x * 0.5 + 160;
            // v1s.y = v1s.y * 0.5 + 120;

            // v2s.x = v2s.x * 0.5 + 160;
            // v2s.y = v2s.y * 0.5 + 120;

            vaOff = 4;
            int triIdx = 0;
            while(vaOff < va.numElements)
            {
               Vector2f v3s;
               v3s.init(va.get(vaOff+0), va.get(vaOff+1));

               // v3s.x = v3s.x * 0.5 + 160;  // debug
               // v3s.y = v3s.y * 0.5 + 120;

               if(b_debug_fill >= 2)
                  c32 = palette.get( 1 + (triIdx & 3) );

               drawTri("drawPathFillConvexTransform3dClip", v1s, v2s, v3s, c32, c32Mask);

               v2s = v3s;
               vaOff += 2;
               triIdx++;
            }
         } // if #va >= 3

      } // if #points >= 3

   }

   // <method.png>
   protected method drawPathFillConvexTesselate(Path p) {
      // (todo) unused, remove
      if(b_debug_fill) trace "[dbg] drawPathFillConvexTesselate: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // if(null == p.ia_fill)
      {
         if(!p.tesselateConvex())
         {
            trace "[---] drawPathFillConvexTesselate: tesselateConvex() failed";
            return;
         }
      }

      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.points;
      IntArray ia <= p.ia_fill;
      int idxOff = 0;
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0) + cur_x, va.get(vaOff1+1) + cur_y);
         v2.init(va.get(vaOff2+0) + cur_x, va.get(vaOff2+1) + cur_y);
         v3.init(va.get(vaOff3+0) + cur_x, va.get(vaOff3+1) + cur_y);
         v1.mulf(geo_scale);
         v2.mulf(geo_scale);
         v3.mulf(geo_scale);

         drawTri("drawPathFillConvexTesselate", v1, v2, v3, cur_c32, c32Mask);

         idxOff += 3;
      }

   }

   // <method.png>
   protected method drawPathFillConcave(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillConcave: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // if(null == p.ia_fill)
      {
         // (note) vertices remain unchanged, generates p.ia_fill
         if(!p.tesselateConcave(p.points))
         {
            trace "[---] drawPathFillConcave: tesselateConcave() failed";
            return;
         }
      }

      FloatArray va <= p.points;
      IntArray ia <= p.ia_fill;

      Integer c32 = palette.get(cur_pal_idx);
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         if(-1 == debug_tri_idx || debug_tri_idx == triIdx)
         {
            int vaOff1 = ia.get(idxOff+0)*2;
            int vaOff2 = ia.get(idxOff+1)*2;
            int vaOff3 = ia.get(idxOff+2)*2;
            v1.init(va.get(vaOff1+0) + cur_x, va.get(vaOff1+1) + cur_y);
            v2.init(va.get(vaOff2+0) + cur_x, va.get(vaOff2+1) + cur_y);
            v3.init(va.get(vaOff3+0) + cur_x, va.get(vaOff3+1) + cur_y);
            v1.mulf(geo_scale);
            v2.mulf(geo_scale);
            v3.mulf(geo_scale);

            if(b_debug_fill >= 2)
               c32 = palette.get( 1 + (triIdx & 3) );

            drawTri("drawPathFillConcave", v1, v2, v3, cur_c32, c32Mask);
         }
         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillHoles(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillHoles: path_idx="+p.path_idx+" #points="+(p.points.numElements/2)+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // (note) iterates parent+sub paths, generate vaPoints and p.ia_fill
      FloatArray vaPoints <= tmpfa_points2;
      if(!p.tesselateHoles(p.points/*in*/, vaPoints/*out*/))
      {
         if(b_debug_tess) trace "[---] drawPathFillHoles: tesselateHoles() failed";
         return;
      }

      FloatArray va <= vaPoints;
      IntArray   ia <= p.ia_fill;

      Integer c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         if(-1 == debug_tri_idx || debug_tri_idx == triIdx)
         {
            int vaOff1 = ia.get(idxOff+0)*2;
            int vaOff2 = ia.get(idxOff+1)*2;
            int vaOff3 = ia.get(idxOff+2)*2;
            v1.init(va.get(vaOff1+0) + cur_x, va.get(vaOff1+1) + cur_y);
            v2.init(va.get(vaOff2+0) + cur_x, va.get(vaOff2+1) + cur_y);
            v3.init(va.get(vaOff3+0) + cur_x, va.get(vaOff3+1) + cur_y);
            v1.mulf(geo_scale);
            v2.mulf(geo_scale);
            v3.mulf(geo_scale);

            if(b_debug_fill >= 2)
               c32 = palette.get( 1 + (triIdx & 3) );

            drawTri("drawPathFillHoles", v1, v2, v3, c32, c32Mask);
         }
         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillConcaveClipPre(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillConcaveClipPre: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )
      FloatArray vaPoints <= tmpfa_points2;
      translateAndScalePoints(p.points, vaPoints/*out*/);

      FloatArray va <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, va);

      // (note) vertices remain unchanged, generates p.ia_fill
      if(!p.tesselateConcave(va))
      {
         trace "[---] drawPathFillConcaveClipPre: tesselateConcave() failed";
         return;
      }

      IntArray ia <= p.ia_fill;

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         if(-1 == debug_tri_idx || debug_tri_idx == triIdx)
         {
            int vaOff1 = ia.get(idxOff+0)*2;
            int vaOff2 = ia.get(idxOff+1)*2;
            int vaOff3 = ia.get(idxOff+2)*2;
            v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
            v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
            v3.init(va.get(vaOff3+0), va.get(vaOff3+1));

            if(b_debug_fill >= 2)
               c32 = palette.get( 1 + (triIdx & 3) );

            drawTri("drawPathFillConcaveClipPre", v1, v2, v3, c32, c32Mask);
         }
         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillHolesClipPre(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillHolesClipPre: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )
      FloatArray vaPoints <= tmpfa_points2;
      translateAndScalePoints(p.points, vaPoints/*out*/);

      FloatArray va <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, va);

      // (note) vertices remain unchanged, generates p.ia_fill
      if(!p.tesselateHoles(va/*in*/, vaPoints/*out*/))
      {
         trace "[---] drawPathFillHolesClipPre: tesselateConcave() failed";
         return;
      }

      IntArray ia <= p.ia_fill;

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         if(-1 == debug_tri_idx || debug_tri_idx == triIdx)
         {
            int vaOff1 = ia.get(idxOff+0)*2;
            int vaOff2 = ia.get(idxOff+1)*2;
            int vaOff3 = ia.get(idxOff+2)*2;
            v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
            v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
            v3.init(va.get(vaOff3+0), va.get(vaOff3+1));

            if(b_debug_fill >= 2)
               c32 = palette.get( 1 + (triIdx & 3) );

            drawTri("drawPathFillHolesClipPre", v1, v2, v3, c32, c32Mask);
         }
         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillConcaveClip(Path p, FloatArray _vaClip) {
      if(b_debug_extrude) trace "[dbg] drawPathConcaveClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx;

      FloatArray vaPoints <= tmpfa_points2;
      translateAndScalePoints(p.points, vaPoints/*out*/);

      // (note) vertices remain unchanged, generates p.ia_fill
      if(!p.tesselateConcave(vaPoints))
      {
         trace "[---] drawPathFillConcaveClip: tesselateConcave() failed";
         return;
      }

      // (note) appends helper vertices to vaPoints
      IntArray ia; ia.empty();
      ClipIndexedTris2D(vaPoints, p.ia_fill, _vaClip, ia/*out*/);

      drawPathIndexedTris2D("drawPathFillConcaveClip", vaPoints, ia);
   }

   // <method.png>
   protected method drawPathFillHolesClip(Path p, FloatArray _vaClip) {
      if(b_debug_extrude) trace "[dbg] drawPathHolesClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx;

      FloatArray vaPoints <= tmpfa_points2;
      translateAndScalePoints(p.points, vaPoints/*out*/);

      // (note) vertices remain unchanged, generates p.ia_fill
      if(!p.tesselateHoles(vaPoints/*in*/, vaPoints/*out*/))
      {
         if(b_debug_tess) trace "[---] drawPathFillHolesClip: tesselateHoles() failed";
         return;
      }

      // (note) appends helper vertices to vaPoints
      IntArray ia; ia.empty();
      ClipIndexedTris2D(vaPoints, p.ia_fill, _vaClip, ia/*out*/);

      drawPathIndexedTris2D("drawPathFillHolesClip", vaPoints, ia);
   }

   // <method.png>
   protected method drawPathFillConcaveTransform2d(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillConcaveTransform2d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // if(null == p.ia_fill)
      {
         // (note) vertices remain unchanged, generates p.ia_fill
         if(!p.tesselateConcave(p.points))
         {
            trace "[---] drawPathFillConcaveTransform2d: tesselateConcave() failed";
            return;
         }
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.points;
      IntArray ia <= p.ia_fill;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));
         cur_mat_2d.mulv(v1) => v1;
         cur_mat_2d.mulv(v2) => v2;
         cur_mat_2d.mulv(v3) => v3;
         v1.x = v1.x + cur_x;
         v1.y = v1.y + cur_y;
         v2.x = v2.x + cur_x;
         v2.y = v2.y + cur_y;
         v3.x = v3.x + cur_x;
         v3.y = v3.y + cur_y;
         v1.mulf(geo_scale);
         v2.mulf(geo_scale);
         v3.mulf(geo_scale);

         if(b_debug_fill >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathFillConcaveTransform2d", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillHolesTransform2d(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillHolesTransform2d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;
      // (note) iterates parent+sub paths, generate vaPoints and p.ia_fill
      FloatArray vaPoints <= tmpfa_points2;
      if(!p.tesselateHoles(p.points/*in*/, vaPoints/*out*/))
      {
         if(b_debug_tess) trace "[---] drawPathFillHolesTransform2d: tesselateHoles() failed";
         return;
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= vaPoints;
      IntArray ia <= p.ia_fill;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));
         cur_mat_2d.mulv(v1) => v1;
         cur_mat_2d.mulv(v2) => v2;
         cur_mat_2d.mulv(v3) => v3;
         v1.x = v1.x + cur_x;
         v1.y = v1.y + cur_y;
         v2.x = v2.x + cur_x;
         v2.y = v2.y + cur_y;
         v3.x = v3.x + cur_x;
         v3.y = v3.y + cur_y;
         v1.mulf(geo_scale);
         v2.mulf(geo_scale);
         v3.mulf(geo_scale);

         if(b_debug_fill >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathFillHolesTransform2d", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillConcaveTransform2dClipPre(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillConcaveTransform2dClipPre: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      FloatArray vaPoints <= tmpfa_points2;
      transform2DAndTranslateAndScale(p.points, vaPoints);

      FloatArray vaClip <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, vaClip/*out*/);
      // if(null == p.ia_fill)
      {
         // (note) vertices remain unchanged, generates p.ia_fill
         if(!p.tesselateConcave(vaClip))
         {
            trace "[---] drawPathFillConcaveTransform2dClipPre: tesselateConcave() failed";
            return;
         }
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= vaClip;
      IntArray ia <= p.ia_fill;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));

         if(b_debug_fill >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathFillConcaveTransform2dClipPre", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillHolesTransform2dClipPre(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillHolesTransform2dClipPre: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      FloatArray vaPoints <= tmpfa_points2;
      transform2DAndTranslateAndScale(p.points, vaPoints);

      FloatArray vaClip <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, vaClip/*out*/);

      // (note) iterates parent+sub paths, generate vaPoints and p.ia_fill
      if(!p.tesselateHoles(vaClip/*in*/, vaPoints/*out*/))
      {
         if(b_debug_tess) trace "[---] drawPathFillHolesTransform2dClipPre: tesselateHoles() failed";
         return;
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= vaPoints;
      IntArray   ia <= p.ia_fill;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));

         if(b_debug_fill >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathFillHolesTransform2dClipPre", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillConcaveTransform2dClip(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillConcaveTransform2dClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      FloatArray vaPoints <= tmpfa_points2;
      transform2DAndTranslateAndScale(p.points, vaPoints/*out*/);

      // (note) vertices remain unchanged, generates p.ia_fill
      if(!p.tesselateConcave(vaPoints))
      {
         trace "[---] drawPathFillConcaveTransform2dClip: tesselateConcave() failed";
         return;
      }

      // (note) appends helper vertices to vaPoints
      IntArray ia; ia.empty();
      ClipIndexedTris2D(vaPoints, p.ia_fill, _vaClip, ia/*out*/);

      drawPathIndexedTris2D("drawPathFillConcaveTransform2dClip", vaPoints, ia);
   }

   // <method.png>
   protected method drawPathFillHolesTransform2dClip(Path p, FloatArray _vaClip) {
      if(b_debug_fill) trace "[dbg] drawPathFillHolesTransform2dClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      FloatArray vaPoints <= tmpfa_points2;
      transform2DAndTranslateAndScale(p.points, vaPoints/*out*/);

      // (note) vertices remain unchanged, generates p.ia_fill
      if(!p.tesselateHoles(vaPoints/*in*/, vaPoints/*out*/))
      {
         if(b_debug_tess) trace "[---] drawPathFillHolesTransform2dClip: tesselateHoles() failed";
         return;
      }

      // (note) appends helper vertices to vaPoints
      IntArray ia; ia.empty();
      ClipIndexedTris2D(vaPoints, p.ia_fill, _vaClip, ia/*out*/);

      drawPathIndexedTris2D("drawPathFillHolesTransform2dClip", vaPoints, ia);
   }

   // <method.png>
   protected method drawPathFillConcaveTransform3d(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillConcaveTransform3d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // if(null == p.ia_fill)
      {
         // (note) vertices remain unchanged, generates p.ia_fill
         if(!p.tesselateConcave(p.points))
         {
            trace "[---] drawPathFillConcaveTransform3d: tesselateConcave() failed";
            return;
         }
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector4f v1;
      Vector4f v2;
      Vector4f v3;
      Vector2f v1s;
      Vector2f v2s;
      Vector2f v3s;
      FloatArray va <= p.points;
      IntArray ia <= p.ia_fill;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1), 0, 1);
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1), 0, 1);
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1), 0, 1);
         cur_mat_3d.mulv(v1) => v1;
         cur_mat_3d.mulv(v2) => v2;
         cur_mat_3d.mulv(v3) => v3;

         v1.divz() => v1s;
         v1s.x = v1s.x + cur_x;
         v1s.y = v1s.y + cur_y;
         v1s.mulf(geo_scale);

         v2.divz() => v2s;
         v2s.x = v2s.x + cur_x;
         v2s.y = v2s.y + cur_y;
         v2s.mulf(geo_scale);

         v3.divz() => v3s;
         v3s.x = v3s.x + cur_x;
         v3s.y = v3s.y + cur_y;
         v3s.mulf(geo_scale);

         if(b_debug_fill >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathFillConcaveTransform3d", v1s, v2s, v3s, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillHolesTransform3d(Path p) {
      if(b_debug_fill) trace "[dbg] drawPathFillHolesTransform3d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // (note) iterates parent+sub paths, generate vaPoints and p.ia_fill
      FloatArray vaPoints <= tmpfa_points2;
      if(!p.tesselateHoles(p.points/*in*/, vaPoints/*out*/))
      {
         if(b_debug_tess) trace "[---] drawPathFillHolesTranform3d: tesselateHoles() failed";
         return;
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector4f v1;
      Vector4f v2;
      Vector4f v3;
      Vector2f v1s;
      Vector2f v2s;
      Vector2f v3s;
      FloatArray va <= vaPoints;
      IntArray   ia <= p.ia_fill;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1), 0, 1);
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1), 0, 1);
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1), 0, 1);
         cur_mat_3d.mulv(v1) => v1;
         cur_mat_3d.mulv(v2) => v2;
         cur_mat_3d.mulv(v3) => v3;

         v1.divz() => v1s;
         v1s.x = v1s.x + cur_x;
         v1s.y = v1s.y + cur_y;
         v1s.mulf(geo_scale);

         v2.divz() => v2s;
         v2s.x = v2s.x + cur_x;
         v2s.y = v2s.y + cur_y;
         v2s.mulf(geo_scale);

         v3.divz() => v3s;
         v3s.x = v3s.x + cur_x;
         v3s.y = v3s.y + cur_y;
         v3s.mulf(geo_scale);

         if(b_debug_fill >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathFillHolesTransform3d", v1s, v2s, v3s, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathFillConcaveTransform3dClip(Path p) {
      // (todo) clip against fov/2 angled frustum planes ?
      if(b_debug_fill) trace "[dbg] drawPathFillConcaveTransform3dClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // Transform points from 2D to 3D
      FloatArray vaPoints <= p.points;
      FloatArray va3 <= tmpfa_va3;
      va3.empty();
      if(vaPoints.numElements >= (3*2))
      {
         Vector4f v1;
         Vector4f v2;
         Vector4f v3;

         v1.init(vaPoints.get(0), vaPoints.get(1), 0, 1);
         v2.init(vaPoints.get(2), vaPoints.get(3), 0, 1);

         cur_mat_3d.mulv(v1) => v1;
         cur_mat_3d.mulv(v2) => v2;

         va3.add3(v1.x, v1.y, v1.z);
         va3.add3(v2.x, v2.y, v2.z);

         if(b_debug_fill >= 3) trace "xxx drawPathFillConcaveTransform3dClip: v1="+v1+" cur_mat_3d="+cur_mat_3d;
         if(b_debug_fill >= 3) trace "xxx drawPathFillConcaveTransform3dClip: v1_3d="+v1;

         int vaOff = 4;
         while(vaOff < vaPoints.numElements)
         {
            v3.init(vaPoints.get(vaOff+0), vaPoints.get(vaOff+1), 0, 1);
            // trace "xxx va["+(vaOff/2)+"] = "+v3;
            cur_mat_3d.mulv(v3) => v3;
            va3.add3(v3.x, v3.y, v3.z);

            // Next 2D point
            vaOff += 2;
         }

         // Clip 3D points against near plane
         FloatArray vaClip3 <= tmpfa_clip3;
         vaClip3.empty();
         if(b_debug_clip3d >= 3) trace "xxx drawPathFillConcaveTransform3dClip: va3="+va3.string3;
         Clip3DZNear(va3, 0.01f/*znear*/, vaClip3);
         if(b_debug_clip3d >= 3) trace "xxx drawPathFillConcaveTransform3dClip: vaClip3="+vaClip3.string3;

         // Project to 2D
         FloatArray vaProj <= tmpfa_proj2;
         vaProj.empty();
         vaOff = 0;
         loop(vaClip3.numElements / 3)
         {
            Vector3f vProj;
            vProj.init(vaClip3.get(vaOff+0),
                       vaClip3.get(vaOff+1),
                       vaClip3.get(vaOff+2)
                       );

            vProj.divz();
            // // trace "xxx va["+(vaOff/2)+"] = "+v3+" (xform) mat_2d="+cur_mat_2d;

            vaProj.add2( (vProj.x + cur_x) * geo_scale,
                         (vProj.y + cur_y) * geo_scale
                         );

            // Next clipped 3D vertex
            vaOff += 3;
         }

         if(b_debug_clip3d >= 3) trace "xxx drawPathFillConcaveTransform3dClip: cur=("+cur_x+";"+cur_y+") geo_scale="+geo_scale+" vaProj="+vaProj.string2;

         // Clip 2D
         Path pFB <= updateAndGetPathFb();
         FloatArray va <= tmpfa_clip2;
         va.empty();
         // trace "xxx vaProj="+vaProj+" pFB.points="+(pFB.points.getString2());
         Clip2D(vaProj, pFB.points, va);

         if(b_debug_clip3d >= 2) trace "xxx drawPathFillConcaveTransform3dClip: va="+va;

         // (note) vertices remain unchanged, generates p.ia_fill
         if(!p.tesselateConcave(va))
         {
            trace "[---] drawPathFillConcaveTransform3dClip: tesselateConcave() failed";
            return;
         }

         if(va.numElements >= (3*2))
         {
            IntArray ia <= p.ia_fill;
            int c32 = cur_c32;
            Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

            int iaOff = 0;
            int triIdx = 0;
            loop(ia.numElements / 3)
            {
               Vector2f v1s;
               Vector2f v2s;
               Vector2f v3s;
               v1s.init(va.get(ia.get(iaOff+0)*2+0),
                        va.get(ia.get(iaOff+0)*2+1)
                        );
               v2s.init(va.get(ia.get(iaOff+1)*2+0),
                        va.get(ia.get(iaOff+1)*2+1)
                        );
               v3s.init(va.get(ia.get(iaOff+2)*2+0),
                        va.get(ia.get(iaOff+2)*2+1)
                        );

               if(b_debug_fill >= 2)
                  c32 = palette.get( 1 + (triIdx & 3) );

               drawTri("drawPathFillConcaveTransform3dClip", v1s, v2s, v3s, c32, c32Mask);

               // Next triangle
               iaOff += 3;
               triIdx++;
            }

         } // if #va >= 3

      } // if #points >= 3

   }

   // <method.png>
   protected method drawPathFillHolesTransform3dClip(Path p) {
      // (todo) clip against fov/2 angled frustum planes ?
      if(b_debug_fill) trace "[dbg] drawPathFillHolesTransform3dClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur_mask_idx="+cur_mask_idx;

      // Transform points from 2D to 3D
      FloatArray vaPoints <= p.points;
      FloatArray va3 <= tmpfa_va3;
      va3.empty();
      if(vaPoints.numElements >= (3*2))
      {
         Vector4f v1;
         Vector4f v2;
         Vector4f v3;

         v1.init(vaPoints.get(0), vaPoints.get(1), 0, 1);
         v2.init(vaPoints.get(2), vaPoints.get(3), 0, 1);

         cur_mat_3d.mulv(v1) => v1;
         cur_mat_3d.mulv(v2) => v2;

         va3.add3(v1.x, v1.y, v1.z);
         va3.add3(v2.x, v2.y, v2.z);

         if(b_debug_fill >= 3) trace "xxx drawPathFillHolesTransform3dClip: v1="+v1+" cur_mat_3d="+cur_mat_3d;
         if(b_debug_fill >= 3) trace "xxx drawPathFillHolesTransform3dClip: v1_3d="+v1;

         int vaOff = 4;
         while(vaOff < vaPoints.numElements)
         {
            v3.init(vaPoints.get(vaOff+0), vaPoints.get(vaOff+1), 0, 1);
            // trace "xxx va["+(vaOff/2)+"] = "+v3;
            cur_mat_3d.mulv(v3) => v3;
            va3.add3(v3.x, v3.y, v3.z);

            // Next 2D point
            vaOff += 2;
         }

         // Clip 3D points against near plane
         FloatArray vaClip3 <= tmpfa_clip3;
         vaClip3.empty();
         if(b_debug_clip3d >= 3) trace "xxx drawPathFillHolesTransform3dClip: va3="+va3.string3;
         Clip3DZNear(va3, 0.01f/*znear*/, vaClip3);
         if(b_debug_clip3d >= 3) trace "xxx drawPathFillHolesTransform3dClip: vaClip3="+vaClip3.string3;

         // Project to 2D
         FloatArray vaProj <= tmpfa_proj2;
         vaProj.empty();
         vaOff = 0;
         loop(vaClip3.numElements / 3)
         {
            Vector3f vProj;
            vProj.init(vaClip3.get(vaOff+0),
                       vaClip3.get(vaOff+1),
                       vaClip3.get(vaOff+2)
                       );

            vProj.divz();
            // // trace "xxx va["+(vaOff/2)+"] = "+v3+" (xform) mat_2d="+cur_mat_2d;

            vaProj.add2( (vProj.x + cur_x) * geo_scale,
                         (vProj.y + cur_y) * geo_scale
                         );

            // Next clipped 3D vertex
            vaOff += 3;
         }

         if(b_debug_clip3d >= 3) trace "xxx drawPathFillHolesTransform3dClip: cur=("+cur_x+";"+cur_y+") geo_scale="+geo_scale+" vaProj="+vaProj.string2;

         // Clip 2D
         Path pFB <= updateAndGetPathFb();
         FloatArray va <= tmpfa_clip2;
         va.empty();
         // trace "xxx vaProj="+vaProj+" pFB.points="+(pFB.points.getString2());
         Clip2D(vaProj, pFB.points, va);

         if(b_debug_clip3d >= 2) trace "xxx drawPathFillHolesTransform3dClip: va="+va;

         // (note) iterates parent+sub paths, generate vaPoints and p.ia_fill
         if(!p.tesselateHoles(va/*in*/, va/*out*/))
         {
            if(b_debug_tess) trace "[---] drawPathFillHolesTransform3dClip: tesselateHoles() failed";
            return;
         }

         if(va.numElements >= (3*2))
         {
            IntArray ia <= p.ia_fill;
            int c32 = cur_c32;
            Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

            int iaOff = 0;
            int triIdx = 0;
            loop(ia.numElements / 3)
            {
               Vector2f v1s;
               Vector2f v2s;
               Vector2f v3s;
               v1s.init(va.get(ia.get(iaOff+0)*2+0),
                        va.get(ia.get(iaOff+0)*2+1)
                        );
               v2s.init(va.get(ia.get(iaOff+1)*2+0),
                        va.get(ia.get(iaOff+1)*2+1)
                        );
               v3s.init(va.get(ia.get(iaOff+2)*2+0),
                        va.get(ia.get(iaOff+2)*2+1)
                        );

               if(b_debug_fill >= 2)
                  c32 = palette.get( 1 + (triIdx & 3) );

               drawTri("drawPathFillHolesTransform3dClip", v1s, v2s, v3s, c32, c32Mask);

               // Next triangle
               iaOff += 3;
               triIdx++;
            }

         } // if #va >= 3

      } // if #points >= 3

   }

   // <method.png>
   protected method drawPathLine(Path p) {
      if(b_debug_line) trace "[dbg] drawPathLine: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur=("+cur_x+";"+cur_y+")";
      FloatArray va <= p.points;
      if(b_debug_line >= 2)
         trace "[trc] drawPathLine: points="+va.string2;
      float lx = va.get(0) + cur_x;
      float ly = va.get(1) + cur_y;
      lx *= geo_scale;
      ly *= geo_scale;
      float firstX = lx;
      float firstY = ly;
      int vaOff = 2;
      debug_line_idx = 0;
      loop((va.numElements / 2) - 1)
      {
         float cx = va.get(vaOff+0) + cur_x;
         float cy = va.get(vaOff+1) + cur_y;
         cx *= geo_scale;
         cy *= geo_scale;
         if(b_debug_line >= 2)
            trace "[trc] drawPathLine: l=("+lx+";"+ly+") c=("+cx+";"+cy+")";
         opLine(lx, ly, cx, cy);
         lx = cx;
         ly = cy;
         vaOff += 2;
      }

      if(p.b_closed)
      {
         if(b_debug_line)
            trace "[trc] drawPathLine: l=("+lx+";"+ly+") first=("+firstX+";"+firstY+")";
         opLine(lx, ly, firstX, firstY);
      }
   }

   // <method.png>
   protected method drawPathLineClip(Path p, FloatArray _vaClip) {
      if(b_debug_line) trace "[dbg] drawPathLineClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur=("+cur_x+";"+cur_y+")";

      FloatArray vaPoints <= tmpfa_points2;
      translateAndScalePoints(p.points, vaPoints/*out*/);

      FloatArray vaClip <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, vaClip);

      if(b_debug_line >= 2) trace "[trc] drawPathLineClip: points="+vaClip.string2;
      float lx = vaClip.get(0);
      float ly = vaClip.get(1);
      float firstX = lx;
      float firstY = ly;
      int vaOff = 2;
      debug_line_idx = 0;
      loop((vaClip.numElements / 2) - 1)
      {
         float cx = vaClip.get(vaOff+0);
         float cy = vaClip.get(vaOff+1);
         if(b_debug_line >= 2)
            trace "[trc] drawPathLineClip: l=("+lx+";"+ly+") c=("+cx+";"+cy+")";
         opLine(lx, ly, cx, cy);
         lx = cx;
         ly = cy;
         vaOff += 2;
      }
      if(p.b_closed)
         opLine(lx, ly, firstX, firstY);
   }

   // <method.png>
   protected method drawPathLineTransform2d(Path p) {
      if(b_debug_line) trace "[dbg] drawPathLineTransform2d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur=("+cur_x+";"+cur_y+")";
      FloatArray va <= p.points;
      if(b_debug_line >= 2) trace "[trc] drawPathLineTransform2d: points="+va.string2;
      Vector2f vl;
      Vector2f vFirst;
      vl.init(va.get(0) + cur_x, va.get(1) + cur_y);
      if(b_debug_line >= 3)
         trace "[trc] drawPathLineTransform2d: vfirst raw="+vl;
      cur_mat_2d.mulv(vl) => vl;
      vl.mulf(geo_scale);
      vFirst = vl;
      int vaOff = 2;
      debug_line_idx = 0;
      loop((va.numElements / 2) - 1)
      {
         Vector2f vc; vc.init(va.get(vaOff+0), va.get(vaOff+1));
         if(b_debug_line >= 3)
            trace "[trc] drawPathLineTransform2d: vc raw="+vc;
         cur_mat_2d.mulv(vc) => vc;
         vc.x = vc.x + cur_x;
         vc.y = vc.y + cur_y;
         vc.mulf(geo_scale);
         if(b_debug_line >= 2)
            trace "[trc] drawPathLineTransform2d: l="+vl+" c="+vc;
         opLine(vl.x, vl.y, vc.x, vc.y);
         vl = vc;
         vaOff += 2;
      }
      if(p.b_closed)
      {
         if(b_debug_line >= 2)
            trace "[trc] drawPathLineTransform2d: close l="+vl+" first="+vFirst;
         opLine(vl.x, vl.y, vFirst.x, vFirst.y);
      }
   }

   // <method.png>
   protected method drawPathLineTransform2dClip(Path p, FloatArray _vaClip) {
      if(b_debug_line) trace "[dbg] drawPathLineTransform2dClip: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur=("+cur_x+";"+cur_y+")";

      FloatArray vaPoints <= tmpfa_points2;
      transform2DAndTranslateAndScale(p.points, vaPoints);

      FloatArray vaClip <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, vaClip/*out*/);

      if(b_debug_line >= 2) trace "[trc] drawPathLineTransform2dClip: vaClip="+vaClip.string2;
      Vector2f vl;
      Vector2f vFirst;
      vl.init(vaClip.get(0), vaClip.get(1));
      if(b_debug_line >= 3)
         trace "[trc] drawPathLineTransform2dClip: vfirst raw="+vl;
      vFirst = vl;
      int vaOff = 2;
      debug_line_idx = 0;
      loop((vaClip.numElements / 2) - 1)
      {
         Vector2f vc; vc.init(vaClip.get(vaOff+0), vaClip.get(vaOff+1));
         if(b_debug_line >= 3)
            trace "[trc] drawPathLineTransform2dClip: vc raw="+vc;
         if(b_debug_line >= 2)
            trace "[trc] drawPathLineTransform2dClip: l="+vl+" c="+vc;
         opLine(vl.x, vl.y, vc.x, vc.y);
         vl = vc;
         vaOff += 2;
      }
      if(p.b_closed)
      {
         if(b_debug_line >= 2)
            trace "[trc] drawPathLineTransform2dClip: close l="+vl+" first="+vFirst;
         opLine(vl.x, vl.y, vFirst.x, vFirst.y);
      }
   }

   // <method.png>
   protected method drawPathLineTransform3d(Path p) {
      if(b_debug_line) trace "[dbg] drawPathLineTransform3d: path_idx="+p.path_idx+" pal_idx="+cur_pal_idx+" cur=("+cur_x+";"+cur_y+")";
      FloatArray va <= p.points;
      if(b_debug_line >= 2) trace "[trc] drawPathLineTransform3d: points="+va.string2;
      Vector4f vFirst;
      Vector2f vFirsts;
      Vector2f vls;
      vFirst.init(va.get(0) + cur_x, va.get(1) + cur_y, 0, 1);
      if(b_debug_line >= 3)
         trace "[trc] drawPathLineTransform3d: vfirst raw="+vFirst;
      cur_mat_3d.mulv(vFirst) => vFirst;
      vFirst.divz() => vFirsts;
      vFirsts.x = vFirsts.x + cur_x;
      vFirsts.y = vFirsts.y + cur_y;
      vFirsts.mulf(geo_scale);
      vls = vFirsts;
      int vaOff = 2;
      debug_line_idx = 0;
      loop((va.numElements / 2) - 1)
      {
         Vector4f vc; vc.init(va.get(vaOff+0), va.get(vaOff+1), 0, 1);
         if(b_debug_line >= 3)
            trace "[trc] drawPathLineTransform3d: vc raw="+vc;
         cur_mat_3d.mulv(vc) => vc;
         Vector2f vcs;
         vc.divz() => vcs;
         vcs.x = vcs.x + cur_x;
         vcs.y = vcs.y + cur_y;
         vcs.mulf(geo_scale);
         if(b_debug_line >= 2)
            trace "[trc] drawPathLineTransform3d: l="+vls+" c="+vcs;
         opLine(vls.x, vls.y, vcs.x, vcs.y);
         vls = vcs;
         vaOff += 2;
      }
      if(p.b_closed)
      {
         if(b_debug_line >= 2)
            trace "[trc] drawPathLineTransform3d: close l="+vls+" first="+vFirsts;
         opLine(vls.x, vls.y, vFirsts.x, vFirsts.y);
      }
   }

   // <method.png>
   protected method drawPathExtrudeShape(Path p) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShape path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;

      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )
      {
         p.extrudeShape(p.points, cur_stroke_w, cur_join_cap, cur_num_seg, cur_miter_limit);
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.va_extrude;
      IntArray ia <= p.ia_extrude;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0) + cur_x, va.get(vaOff1+1) + cur_y);
         v2.init(va.get(vaOff2+0) + cur_x, va.get(vaOff2+1) + cur_y);
         v3.init(va.get(vaOff3+0) + cur_x, va.get(vaOff3+1) + cur_y);
         v1.mulf(geo_scale);
         v2.mulf(geo_scale);
         v3.mulf(geo_scale);
         if(b_debug_extrude >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathExtrudeShape", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathExtrudeShapeClipPre(Path p, FloatArray _vaClip) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShapeClipPre: path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;
      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )
      {
         FloatArray vaPoints <= tmpfa_points2;
         translateAndScalePoints(p.points, vaPoints/*out*/);

         FloatArray vaOut <= tmpfa_clip2;
         Clip2D(vaPoints, _vaClip, vaOut);

         p.extrudeShape(vaOut, cur_stroke_w, cur_join_cap, cur_num_seg, cur_miter_limit);
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.va_extrude;
      IntArray ia <= p.ia_extrude;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));
         if(b_debug_extrude >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathExtrudeShapeClipPre", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathIndexedTris2D(String _fxn, FloatArray va, IntArray ia) {
      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));
         if(b_debug_extrude >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri(_fxn, v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathExtrudeShapeClip(Path p, FloatArray _vaClip) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShapeClip: path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;

      IntArray ia; ia.empty();

      FloatArray vaPoints <= tmpfa_points2;
      translateAndScalePoints(p.points, vaPoints/*out*/);

      p.extrudeShape(vaPoints, cur_stroke_w * geo_scale, cur_join_cap, cur_num_seg, cur_miter_limit);

      // (note) appends helper vertices to p.va_extrude
      ClipIndexedTris2D(p.va_extrude, p.ia_extrude, _vaClip, ia/*out*/);

      drawPathIndexedTris2D("drawPathExtrudeShapeClip", p.va_extrude, ia);
   }

   // <method.png>
   protected method drawPathExtrudeShapeTransform2d(Path p) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShapeTransform2d path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;
      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )
      {
         p.extrudeShape(p.points, cur_stroke_w, cur_join_cap, cur_num_seg, cur_miter_limit);
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.va_extrude;
      IntArray ia <= p.ia_extrude;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));
         cur_mat_2d.mulv(v1) => v1;
         cur_mat_2d.mulv(v2) => v2;
         cur_mat_2d.mulv(v3) => v3;
         v1.x = v1.x + cur_x;
         v1.y = v1.y + cur_y;
         v2.x = v2.x + cur_x;
         v2.y = v2.y + cur_y;
         v3.x = v3.x + cur_x;
         v3.y = v3.y + cur_y;
         v1.mulf(geo_scale);
         v2.mulf(geo_scale);
         v3.mulf(geo_scale);

         if(b_debug_extrude >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathExtrudeShapeTransform2d", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathExtrudeShapeTransform2dClipPre(Path p, FloatArray _vaClip) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShapeTransform2dClipPre: path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;

      FloatArray vaPoints <= tmpfa_points2;
      transform2DAndTranslateAndScale(p.points, vaPoints);

      FloatArray vaClip <= tmpfa_clip2;
      Clip2D(vaPoints, _vaClip, vaClip/*out*/);


      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )
      {
         p.extrudeShape(vaClip, cur_stroke_w * geo_scale, cur_join_cap, cur_num_seg, cur_miter_limit);
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1;
      Vector2f v2;
      Vector2f v3;
      FloatArray va <= p.va_extrude;
      IntArray ia <= p.ia_extrude;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1));

         if(b_debug_extrude >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathExtrudeShapeTransform2dClipPre", v1, v2, v3, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathExtrudeShapeTransform2dClip(Path p, FloatArray _vaClip) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShapeTransform2dClip: path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;

      // Create va_extrude / ia_extrude
      p.extrudeShape(p.points, cur_stroke_w, cur_join_cap, cur_num_seg, cur_miter_limit);

      // Transform points from 2D to 3D
      FloatArray va <= p.va_extrude;
      IntArray iaIn <= p.ia_extrude;

      // (note) appends helper vertices to 'va'
      IntArray ia; ia.empty();
      ClipIndexedTris2D(va, iaIn, _vaClip, ia/*out*/);

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector2f v1s;
      Vector2f v2s;
      Vector2f v3s;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1s.init(va.get(vaOff1+0), va.get(vaOff1+1));
         v2s.init(va.get(vaOff2+0), va.get(vaOff2+1));
         v3s.init(va.get(vaOff3+0), va.get(vaOff3+1));

         if(b_debug_extrude >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathExtrudeShapeTransform2dClip", v1s, v2s, v3s, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathExtrudeShapeTransform3d(Path p) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShapeTransform3d: path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;
      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )
      {
         p.extrudeShape(p.points, cur_stroke_w, cur_join_cap, cur_num_seg, cur_miter_limit);
      }

      int c32 = cur_c32;
      Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

      Vector4f v1;
      Vector4f v2;
      Vector4f v3;
      Vector2f v1s;
      Vector2f v2s;
      Vector2f v3s;
      FloatArray va <= p.va_extrude;
      IntArray ia <= p.ia_extrude;
      int idxOff = 0;
      int triIdx = 0;  // debug color
      while(idxOff < ia.numElements)
      {
         int vaOff1 = ia.get(idxOff+0)*2;
         int vaOff2 = ia.get(idxOff+1)*2;
         int vaOff3 = ia.get(idxOff+2)*2;
         v1.init(va.get(vaOff1+0), va.get(vaOff1+1), 0, 1);
         v2.init(va.get(vaOff2+0), va.get(vaOff2+1), 0, 1);
         v3.init(va.get(vaOff3+0), va.get(vaOff3+1), 0, 1);
         cur_mat_3d.mulv(v1) => v1;
         cur_mat_3d.mulv(v2) => v2;
         cur_mat_3d.mulv(v3) => v3;

         v1.divz() => v1s;
         v2.divz() => v2s;
         v3.divz() => v3s;

         v1s.x = v1s.x + cur_x;
         v2s.x = v2s.x + cur_x;
         v3s.x = v3s.x + cur_x;

         v1s.y = v1s.y + cur_y;
         v2s.y = v2s.y + cur_y;
         v3s.y = v3s.y + cur_y;

         v1s.mulf(geo_scale);
         v2s.mulf(geo_scale);
         v3s.mulf(geo_scale);

         if(b_debug_extrude >= 2)
            c32 = palette.get( (1 + triIdx) & 7 );

         drawTri("drawPathExtrudeShapeTransform3d", v1s, v2s, v3s, c32, c32Mask);

         idxOff += 3;
         triIdx++;  // debugColor
      }
   }

   // <method.png>
   protected method drawPathExtrudeShapeTransform3dClip(Path p) {
      if(b_debug_extrude) trace "[dbg] drawPathExtrudeShapeTransform3dClip: path_idx="+p.path_idx+" stroke_w="+cur_stroke_w+" #seg="+cur_num_seg+" pal_idx="+cur_pal_idx;
      // if(null == p.shape_extrude ||
      //    p.extrude_stroke_w != cur_stroke_w ||
      //    p.extrude_join_cap != cur_join_cap ||
      //    p.extrude_num_seg  != cur_num_seg
      //    )

      // Create va_extrude / ia_extrude
      p.extrudeShape(p.points, cur_stroke_w, cur_join_cap, cur_num_seg, cur_miter_limit);

      // Transform points from 2D to 3D
      FloatArray vaPoints <= p.va_extrude;
      IntArray iaPoints <= p.ia_extrude;
      FloatArray va3 <= tmpfa_va3;
      va3.empty();
      int vaOff;
      Vector4f v;
      if(vaPoints.numElements >= (3*2))
      {
         vaOff = 0;
         while(vaOff < vaPoints.numElements)
         {
            v.init(vaPoints.get(vaOff+0),
                   vaPoints.get(vaOff+1),
                   0,
                   1
                   );

            // v2.init(vaPoints.get(iaPoints.get(1)*2+0),
            //         vaPoints.get(iaPoints.get(1)*2+1),
            //         0,
            //         1
            //         );

            cur_mat_3d.mulv(v) => v;
            va3.add3(v.x, v.y, v.z);

            if(b_debug_fill >= 3) trace "xxx drawPathExtrudeShapeTransform3dClip: v="+v+" cur_mat_3d="+cur_mat_3d;
            if(b_debug_fill >= 3) trace "xxx drawPathExtrudeShapeTransform3dClip: v_3d="+v;

            // Next 2D point
            vaOff += 2;
         }

         // Clip 3D points against near plane
         //  (note) appends intersection vertices to 'va3'
         IntArray iaClip3 <= tmpia_clip3;
         iaClip3.empty();
         ClipIndexedTris3DZNear(va3, iaPoints, 0.01f/*znear*/, iaClip3);

         // Project to 2D
         FloatArray vaProj <= tmpfa_proj2;
         vaProj.empty();
         vaOff = 0;
         loop(va3.numElements / 3)
         {
            Vector3f vProj;
            vProj.init(va3.get(vaOff+0),
                       va3.get(vaOff+1),
                       va3.get(vaOff+2)
                       );

            vProj.divz();
            // // trace "xxx va["+(vaOff/2)+"] = "+v3+" (xform) mat_2d="+cur_mat_2d;

            vaProj.add2( (vProj.x + cur_x) * geo_scale,
                         (vProj.y + cur_y) * geo_scale
                         );

            // Next clipped 3D vertex
            vaOff += 3;
         }

         // (note) appends helper vertices to 'vaProj'
         IntArray ia <= tmpia_clip2;
         ia.empty();
         Path pFB <= updateAndGetPathFb();
         ClipIndexedTris2D(vaProj, iaClip3, pFB.points, ia/*out*/);

         int c32 = cur_c32;
         Integer c32Mask = (cur_mask_idx >= 0) ? palette.get(cur_mask_idx) : 0;

         Vector2f v1s;
         Vector2f v2s;
         Vector2f v3s;
         int idxOff = 0;
         int triIdx = 0;  // debug color
         while(idxOff < ia.numElements)
         {
            int vaOff1 = ia.get(idxOff+0)*2;
            int vaOff2 = ia.get(idxOff+1)*2;
            int vaOff3 = ia.get(idxOff+2)*2;
            v1s.init(vaProj.get(vaOff1+0), vaProj.get(vaOff1+1));
            v2s.init(vaProj.get(vaOff2+0), vaProj.get(vaOff2+1));
            v3s.init(vaProj.get(vaOff3+0), vaProj.get(vaOff3+1));

            if(b_debug_extrude >= 2)
               c32 = palette.get( (1 + triIdx) & 7 );

            drawTri("drawPathExtrudeShapeTransform3dClip", v1s, v2s, v3s, c32, c32Mask);

            idxOff += 3;
            triIdx++;  // debugColor
         }
      }
   }

   // <method.png>
   public method drawPath(Path p, int mode) {
      if(b_debug_fill >= 2) trace "[trc] drawPath mode="+mode;
      switch(mode)
      {
         case 0:
            // no transform
            // trace "xxx cur_stroke_w="+cur_stroke_w;
            if(0.0f == cur_stroke_w)
            {
               if(Path.TYPE_EVENODD == p.type)
               {
                  if(null != cur_clip2d_path)
                  {
                     if(b_cur_clip2d_pre)
                        drawPathFillHolesClipPre(p, cur_clip2d_path.points);
                     else
                        drawPathFillHolesClip(p, cur_clip2d_path.points);
                  }
                  else
                  {
                     drawPathFillHoles(p);
                  }
               }
               else if(Path.TYPE_CONCAVE == p.type)
               {
                  if(null != cur_clip2d_path)
                  {
                     if(b_cur_clip2d_pre)
                        drawPathFillConcaveClipPre(p, cur_clip2d_path.points);
                     else
                        drawPathFillConcaveClip(p, cur_clip2d_path.points);
                  }
                  else
                  {
                     drawPathFillConcave(p);
                  }
               }
               else
               {
                  if(null != cur_clip2d_path)
                     drawPathFillConvexClip(p, cur_clip2d_path.points);  // (note) same for pre/post clip
                  else
                     drawPathFillConvex(p);
               }
            }
            else if(cur_stroke_w <= 0.25f)
            {
               if(null != cur_clip2d_path)
                  drawPathLineClip(p, cur_clip2d_path.points);
               else
                  drawPathLine(p);
            }
            else
            {
               if(null != cur_clip2d_path)
               {
                  if(b_cur_clip2d_pre)
                     drawPathExtrudeShapeClipPre(p, cur_clip2d_path.points);
                  else
                     drawPathExtrudeShapeClip(p, cur_clip2d_path.points);
               }
               else
                  drawPathExtrudeShape(p);
            }
            break;

         case 1:
            // transform 2d
            if(0.0f == cur_stroke_w)
            {
               if(Path.TYPE_EVENODD == p.type)
               {
                  if(null != cur_clip2d_path)
                  {
                     if(b_cur_clip2d_pre)
                        drawPathFillHolesTransform2dClipPre(p, cur_clip2d_path.points);
                     else
                        drawPathFillHolesTransform2dClip(p, cur_clip2d_path.points);
                  }
                  else
                     drawPathFillHolesTransform2d(p);
               }
               else if(Path.TYPE_CONCAVE == p.type)
               {
                  if(null != cur_clip2d_path)
                  {
                     if(b_cur_clip2d_pre)
                        drawPathFillConcaveTransform2dClipPre(p, cur_clip2d_path.points);
                     else
                        drawPathFillConcaveTransform2dClip(p, cur_clip2d_path.points);
                  }
                  else
                     drawPathFillConcaveTransform2d(p);
               }
               else
               {
                  if(null != cur_clip2d_path)
                  {
                     drawPathFillConvexTransform2dClip(p, cur_clip2d_path.points);  // (note) same for pre/post
                  }
                  else
                     drawPathFillConvexTransform2d(p);
               }
            }
            else if(cur_stroke_w <= 0.25f)
            {
               if(null != cur_clip2d_path)
               {
                  drawPathLineTransform2dClip(p, cur_clip2d_path.points);
               }
               else
                  drawPathLineTransform2d(p);
            }
            else
            {
               if(null != cur_clip2d_path)
               {
                  if(b_cur_clip2d_pre)
                     drawPathExtrudeShapeTransform2dClipPre(p, cur_clip2d_path.points);
                  else
                     drawPathExtrudeShapeTransform2dClip(p, cur_clip2d_path.points);
               }
               else
                  drawPathExtrudeShapeTransform2d(p);
            }
            break;

         case 2:
            // transform 3d
            if(0.0f == cur_stroke_w)
            {
               if(Path.TYPE_EVENODD == p.type)
               {
                  if(b_cur_clip_3d)
                  {
                     drawPathFillHolesTransform3dClip(p);
                  }
                  else
                  {
                     drawPathFillHolesTransform3d(p);
                  }
               }
               else if(Path.TYPE_CONCAVE == p.type)
               {
                  if(b_cur_clip_3d)
                  {
                     drawPathFillConcaveTransform3dClip(p);
                  }
                  else
                  {
                     drawPathFillConcaveTransform3d(p);
                  }
               }
               else
               {
                  if(b_cur_clip_3d)
                  {
                     drawPathFillConvexTransform3dClip(p);
                  }
                  else
                  {
                     drawPathFillConvexTransform3d(p);
                  }
               }
            }
            else if(cur_stroke_w <= 0.25f)
            {
               if(b_cur_clip_3d)
               {
                  // (todo) drawPathLineTransform3dClip(p);
               }
               else
               {
                  drawPathLineTransform3d(p);
               }
            }
            else
            {
               if(b_cur_clip_3d)
               {
                  drawPathExtrudeShapeTransform3dClip(p);
               }
               else
               {
                  drawPathExtrudeShapeTransform3d(p);
               }
            }
            break;
      }
   }

   // <method.png>
   public method drawMultiPath(Path p, int mode) {
      drawPath(p, mode);

      // trace "xxx drawMultiPath: mode="+mode+" p.type="+p.type;

      if(Path.TYPE_EVENODD != p.type || cur_stroke_w > 0.0f)
      {
         if(b_debug_paths && !(p.sub_paths.isEmpty()))
            trace "[trc] drawMultiPath: p="+#(p)+" p.sub_paths="+#(p.sub_paths)+" mode="+mode;

         Path *sp;
         foreach sp in p.sub_paths
            drawPath(sp, mode);
      }
   }

   // <method.png>
   public method readPalette12(Stream ifs) {
      int numColors = ifs.u8 + 1;
      if(b_debug_pal) trace "[dbg] MinnieBin::readPalette12: numColors="+numColors;
      local StreamReader4 ifs4; ifs4.begin(ifs);
      palette.empty();
      loop(numColors)
      {
         byte r = ifs4.read4();
         byte g = ifs4.read4();
         byte b = ifs4.read4();
         if(b_debug_pal) trace "[dbg] readPalette12: ["+palette.numElements+"]=("+r+","+g+","+b+")";
         r |= (r << 4);
         g |= (g << 4);
         b |= (b << 4);
         palette.add( #ff000000 | ((r << 16) | (g << 8) | b) );
      }
      ifs4.end();
      cur_c32 = palette.get(cur_pal_idx);
   }

   // <method.png>
   public method readPalette24(Stream ifs) {
      int numColors = ifs.u8 + 1;
      if(b_debug_pal) trace "[dbg] MinnieBin::readPalette24: numColors="+numColors;
      palette.empty();
      loop(numColors)
      {
         byte r = ifs.u8;
         byte g = ifs.u8;
         byte b = ifs.u8;
         if(b_debug_pal) trace "[dbg] readPalette24: ["+palette.numElements+"]=("+r+","+g+","+b+")";
         palette.add( #ff000000 | ((r << 16) | (g << 8) | b) );
      }
      cur_c32 = palette.get(cur_pal_idx);
   }

   // <method.png>
   public method readFramebuffers(Stream ifs) {
      int numFb = ifs.u8;
      loop(numFb)
      {
         Framebuffer fb <= new Framebuffer;
         int w = (ifs.u8 * 8) * fb_scale + 0.5f;
         int h = (ifs.u8 * 8) * fb_scale + 0.5f;
         if(b_debug_fb) trace "[dbg] add framebuffer "+w+"x"+h+" (fb_scale="+fb_scale+")";
         fb.init(framebuffers.numElements, w, h);
         framebuffers.add(#(deref fb));
      }
   }

   // <method.png>
   public method readMatrices2D(Stream ifs) {
      int numMat = ifs.u16 + 1;
      int matIdx = 0;
      loop(numMat)
      {
         Matrix2x3f mat <= new Matrix2x3f;
         matrices_2d.add(#(deref mat));
         int i = 0;
         loop(2*3)
            mat[i++] = f32_from_f16(ifs.u16);

         if(b_debug_fb) trace "[dbg] add mat_2d idx="+matIdx+" mat="+mat;
         matIdx++;
      }
   }

   // <method.png>
   public method readMatrices3D(Stream ifs) {
      int numMat = ifs.u16 + 1;
      int matIdx = 0;
      loop(numMat)
      {
         Matrix4f mat <= new Matrix4f;
         matrices_3d.add(#(deref mat));
         int i = 0;
         loop(4*4)
            mat[i++] = f32_from_f16(ifs.u16);

         if(b_debug_fb) trace "[dbg] add mat_3d idx="+matIdx+" mat="+mat;
         matIdx++;
      }
   }

   // <method.png>
   protected method beginGeo() {
      // Add default framebuffer
      cur_fb <= new Framebuffer;
      cur_fb.init(0, geo_w, geo_h);
      framebuffers.add(#(deref cur_fb));
      cur_src_fb <= cur_fb;
      aa_bias = -0.01f * (160.0f / cur_fb.tex.sx);
      zglInit2D(geo_w, geo_h);

      // (note) workaround for test059_abstractbike / test066_cat
      float whMax = mathMaxf(geo_w, geo_h);
      if(whMax > 0.0f)
      {
         cubic_min_dist_sqr = 4.0f * (640.0f / whMax);
         // trace "xxx cubic_min_dist_sqr="+cubic_min_dist_sqr;
      }
   }

   // <method_parse.png>
   public method parseStream(Stream ifs) : boolean {
      try
      {
         reset();

         byte ver = 0;
         byte palIdx;
         float dstX;
         float dstY;
         float w;
         float h;
         short srcX;
         short srcY;
         float mirrorX = 0;
         float mirrorY = 0;
         float c1x;
         float c1y;
         float c2x;
         float c2y;
         float rx;
         float ry;
         float r;
         float xrot;
         boolean bLargeArc;
         boolean bArcSweep;
         Path *oPath;  // tmp insert / draw path
         float sx;
         float sy;
         float ang;
         Framebuffer *fb;
         int pathIdx;
         StreamReader4 ifs4;
         int i;
         int matIdx;
         short rotAndFlags;

         cur_path <= new Path;
         cur_path.init(0, Path.TYPE_DRAW);
         paths.add(#(deref cur_path));
         last_parent_path <= null;

         // Read header (flags)
         byte flags = ifs.u8;  // ver MSB6, endianness bit7, AA bit6
         ver          = (flags & 0x3F);
         boolean bBE  = (flags & 0x80) ? true : false;
         b_aa         = (flags & 0x40) ? true : false;

         ifs.byteOrder = bBE ? YAC_BIG_ENDIAN : YAC_LITTLE_ENDIAN;

         for(;;)
         {
            byte op = ifs.u8;
            Integer ioOp = op;
            // trace "xxx op="+ioOp.printf("0x%02x");

            switch(op)
            {
               default:
                  trace "[---] MinnieBin::parseStream: unhandled op "+ioOp.printf("0x%02x")+" at offset "+(ifs.offset-1);
                  return false;

               case 0xE0:  // end
                  if(b_debug_op) trace "[dbg] end";

                  if(b_debug_prims) trace "[dbg] #points="+total_num_points+" #lines="+total_num_lines+" #tris="+total_num_tris;

                  trace "[+++] MinnieBin::parseStream: parsed "+ifs.offset+" bytes";

                  // Succeeded
                  return true;

               // case 0xE1:  // RESVD
               //    break;

               case 0xE1:  // geo (u16)
                  geo_w = ifs.u16 * fb_scale + 0.5f;
                  geo_h = ifs.u16 * fb_scale + 0.5f;
                  beginGeo();
                  if(b_debug_op) trace "\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[dbg] geo=("+geo_w+","+geo_h+") (u16)";
                  break;

               case 0xE2:  // geo (u8)
                  geo_w = (ifs.u8 * 8) * fb_scale + 0.5f;
                  geo_h = (ifs.u8 * 8) * fb_scale + 0.5f;
                  beginGeo();
                  if(b_debug_op) trace "\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[dbg] geo=("+geo_w+","+geo_h+") (u8)";
                  break;

               case 0xE3:  // pal12
                  readPalette12(ifs);
                  break;

               case 0xE4:  // pal16
                  die "(todo) implement pal16";
                  break;

               case 0xE5:  // pal24
                  readPalette24(ifs);
                  break;

               case 0xE7:  // additional draw buffers
                  readFramebuffers(ifs);
                  break;

               case 0xE8:
                  readMatrices2D(ifs);
                  break;

               case 0xE9:
                  readMatrices3D(ifs);
                  break;

               case 0xEA:
                  die "(todo) implement num_consts";
                  break;

               case 0xEB:
                  die "(todo) implement num_vars";
                  break;

               case 0xEC:
                  die "(todo) implement stack";
                  break;

               case 0xED:
                  die "(todo) implement call_stack";
                  break;

               case 0xEE:
                  die "(todo) implement max_ops";
                  break;

               case 0x01:
                  die "(todo) implement x";
                  break;

               case 0x02:  // n <mat2x3>
                  matIdx = ifs.u8;
                  cur_mat_2d = matrices_2d.get(matIdx);
                  if(b_debug_op) trace "[dbg] n "+matIdx+" m="+cur_mat_2d+"  (u8)";
                  break;

               case 0x03:  // q <mat4x4>
                  matIdx = ifs.u8;
                  cur_mat_3d = matrices_3d.get(matIdx);
                  if(b_debug_op) trace "[dbg] q "+matIdx+" m="+cur_mat_3d+"  (u8)";
                  break;

               case 0x04:  // n <mat2x3>
                  matIdx = ifs.u16;
                  cur_mat_2d = matrices_2d.get(matIdx);
                  if(b_debug_op) trace "[dbg] n "+matIdx+" m="+cur_mat_2d+"  (u16)";
                  break;

               case 0x05:  // q <mat4x4>
                  matIdx = ifs.u16;
                  cur_mat_3d = matrices_3d.get(matIdx);
                  if(b_debug_op) trace "[dbg] q "+matIdx+" m="+cur_mat_3d+"  (u16)";
                  break;

               case 0x0E:  // h <join> <cap>
                  cur_join_cap = ifs.u8;
                  String *sJoin;
                  switch(cur_join_cap&15)
                  {
                     case Path.LINEJOIN_NONE:  sJoin <= "none";  break;
                     case Path.LINEJOIN_MITER: sJoin <= "miter"; break;
                     case Path.LINEJOIN_ROUND: sJoin <= "round"; break;
                     case Path.LINEJOIN_BEVEL: sJoin <= "bevel"; break;
                     default:                  sJoin <= "?";     break;
                  }
                  String *sCap;
                  switch((cur_join_cap>>4)&15)
                  {
                     case Path.LINECAP_NONE:   sCap <= "none";   break;
                     case Path.LINECAP_BUTT:   sCap <= "butt";   break;
                     case Path.LINECAP_ROUND:  sCap <= "round";  break;
                     case Path.LINECAP_SQUARE: sCap <= "square"; break;
                     default:                  sCap <= "?";      break;
                  }
                  if(b_debug_op) trace "[dbg] h "+sJoin+" "+sCap;
                  break;

               case 0x10:
               case 0x11:
               case 0x12:
               case 0x13:
               case 0x14:
               case 0x15:
               case 0x16:
               case 0x17:
               case 0x18:
               case 0x19:
               case 0x1A:
               case 0x1B:
               case 0x1C:
               case 0x1D:
               case 0x1E:
               case 0x1F:
                  cur_pal_idx = (op & 15);
                  cur_c32 = palette.get(cur_pal_idx);
                  if(b_debug_op >= 3) trace "[dbg] i "+cur_pal_idx;
                  break;

               case 0x20:
                  cur_pal_idx = ifs.u8;
                  cur_c32 = palette.get(cur_pal_idx);
                  if(b_debug_op >= 3) trace "[dbg] i "+cur_pal_idx;
                  break;

               case 0x21:  // m float32
                  cur_x += ifs.f32;
                  cur_y += ifs.f32;
                  if(b_debug_op) trace "[dbg] m "+cur_x+";"+cur_y+" (f32)";
                  break;

               case 0x22:  // M float32
                  cur_x = ifs.f32;
                  cur_y = ifs.f32;
                  if(b_debug_op) trace "[dbg] M "+cur_x+";"+cur_y+" (f32)";
                  break;

               case 0x23:  // cubic spline (f32)
                  c1x     = cur_x + ifs.f32;
                  c1y     = cur_y + ifs.f32;
                  mirrorX = ifs.f32;
                  mirrorY = ifs.f32;
                  dstX    = cur_x + ifs.f32;
                  dstY    = cur_y + ifs.f32;
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op >= 2) trace "[dbg] c "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+" (f32)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x24:
                  byte logicOp = ifs.u8;
                  if(b_debug_op) trace "[dbg] g "+logicOp;
                  break;

               case 0x25:  // cubic spline mirror (f32)
                  c1x     = cur_x + mirrorX;
                  c1y     = cur_y + mirrorY;
                  mirrorX = ifs.f32;
                  mirrorY = ifs.f32;
                  dstX    = cur_x + ifs.f32;
                  dstY    = cur_y + ifs.f32;
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op) trace "[dbg] s "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+" (f32)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x26:  // l dx dy (f32)
                  last_x = cur_x;
                  last_y = cur_y;
                  cur_x += ifs.f32;
                  cur_y += ifs.f32;
                  if(b_debug_op >= 2) trace "[dbg] l "+cur_x+" "+cur_y+" (f32)";
                  // // opLine(last_x, last_y, cur_x, cur_y);
                  cur_path.lazyBegin(last_x, last_y);
                  cur_path.lineTo(cur_x, cur_y);
                  mirrorX = 0;
                  mirrorY = 0;
                  break;

               case 0x27:  // miter_limit (u8)
                  cur_miter_limit = ifs.u8;
                  if(b_debug_op) trace "[dbg] ml "+cur_miter_limit;
                  break;

               case 0x28:  // m signed 6.2
                  cur_x += (ifs.s8 / 4.0f);
                  cur_y += (ifs.s8 / 4.0f);
                  if(b_debug_op) trace "[dbg] m "+cur_x+";"+cur_y+" (s6.2)";
                  break;

               case 0x29:  // m signed 14.2
                  cur_x += (ifs.s16 / 4.0f);
                  cur_y += (ifs.s16 / 4.0f);
                  if(b_debug_op) trace "[dbg] m "+cur_x+" "+cur_y+" (s14.2)";
                  break;

               case 0x2A:  // m signed 8.0
                  cur_x += ifs.s8;
                  cur_y += ifs.s8;
                  if(b_debug_op) trace "[dbg] m "+cur_x+" "+cur_y+" (s8.0)";
                  break;

               case 0x2B:  // m unsigned 8.0
                  cur_x += ifs.u8;
                  cur_y += ifs.u8;
                  if(b_debug_op) trace "[dbg] m "+cur_x+" "+cur_y+" (u8.0)";
                  break;

               case 0x2C:  // M unsigned 8.0
                  cur_x = ifs.u8;
                  cur_y = ifs.u8;
                  if(b_debug_op) trace "[dbg] M "+cur_x+" "+cur_y+" (u8.0)";
                  break;

               case 0x2D:  // M unsigned 8.0 even
                  cur_x = (ifs.u8 << 1);
                  cur_y = (ifs.u8 << 1);
                  if(b_debug_op) trace "[dbg] M "+cur_x+" "+cur_y+" (u8.0*2)";
                  break;

               case 0x2E:  // M unsigned 8.0 mul4
                  cur_x = (ifs.u8 << 2);
                  cur_y = (ifs.u8 << 2);
                  if(b_debug_op) trace "[dbg] M "+cur_x+" "+cur_y+" (u8.0*4)";
                  break;

               case 0x2F:  // M signed 14.2
                  cur_x = (ifs.s16 / 4.0f);
                  cur_y = (ifs.s16 / 4.0f);
                  if(b_debug_op) trace "[dbg] M "+cur_x+" "+cur_y+" (s14.2)";
                  break;

               case 0x30:  // t 0
               case 0x31:  // t 1
               case 0x32:  // t 2
               case 0x33:  // t 3
               case 0x34:  // t 4
               case 0x35:  // t 5
               case 0x36:  // t 6
                  cur_fb <= framebuffers.get(op - 0x30);
                  aa_bias = -0.01f * (160.0f / cur_fb.tex.sx);
                  if(b_debug_op) trace "[dbg] t "+cur_fb.fb_idx+"  (IMM)";
                  break;

               case 0x37:  // t ubyte
                  cur_fb <= framebuffers.get(ifs.u8);
                  aa_bias = -0.01f * (160.0f / cur_fb.tex.sx);
                  if(b_debug_op) trace "[dbg] t "+cur_fb.fb_idx+"  (u8)";
                  break;

               case 0x38:  // u 0
               case 0x39:  // u 1
               case 0x3A:  // u 2
               case 0x3B:  // u 3
               case 0x3C:  // u 4
               case 0x3D:  // u 5
               case 0x3E:  // u 6
                  cur_src_fb <= framebuffers.get(op - 0x38);
                  if(b_debug_op) trace "[dbg] u "+cur_fb.fb_idx+"  (IMM)";
                  break;

               case 0x3F:  // u ubyte
                  cur_src_fb <= framebuffers.get(ifs.u8);
                  if(b_debug_op) trace "[dbg] u "+cur_fb.fb_idx+"  (u8)";
                  break;

               case 0x40:  // f 0
               case 0x41:  // f 1
               case 0x42:  // f 2
               case 0x43:  // f 3
               case 0x44:  // f 4
               case 0x45:  // f 5
               case 0x46:  // f 6
               case 0x47:  // f 7
               case 0x48:  // f 8
               case 0x49:  // f 9
               case 0x4A:  // f 10
               case 0x4B:  // f 11
               case 0x4C:  // f 12
               case 0x4D:  // f 13
                  palIdx = (op-0x40);
                  if(b_debug_op) trace "[dbg] f "+palIdx+"  (IMM)";
                  opFill(palIdx);
                  break;

               case 0x4E:  // f ubyte
                  palIdx = ifs.u8;
                  if(b_debug_op) trace "[dbg] f "+palIdx+"  (u8)";
                  opFill(palIdx);
                  break;

               case 0x4F:  // clear coverage alpha (AA)
                  if(b_debug_op) trace "[dbg] f aa";
                  opFillCoverageAA();
                  break;

               case 0x50:  // w2off
                  cur_clip2d_path <= null;
                  b_cur_clip2d_pre = false;
                  // b_cur_clip_fb    = false;
                  b_cur_clip_3d    = false;
                  if(b_debug_op) trace "[dbg] w2off";
                  break;

               case 0x51:  // w2fb
                  cur_clip2d_path <= updateAndGetPathFb();
                  b_cur_clip2d_pre = false;
                  // b_cur_clip_fb    = true;
                  b_cur_clip_3d    = false;
                  if(b_debug_op) trace "[dbg] w2fb";
                  break;

               case 0x52:  // w2p <pathIdx.u8>
                  cur_clip2d_path <= paths.getRev(ifs.u8 + 1);
                  b_cur_clip2d_pre = true;
                  // b_cur_clip_fb    = false;
                  b_cur_clip_3d    = false;
                  if(b_debug_op) trace "[dbg] w2p "+cur_clip2d_path.path_idx;
                  break;

               case 0x53:  // w2p <pathIdx.u16>
                  cur_clip2d_path  <= paths.getRev(ifs.u16 + 1);
                  b_cur_clip2d_pre  = true;
                  // b_cur_clip_fb     = false;
                  b_cur_clip_3d     = false;
                  if(b_debug_op) trace "[dbg] w2p "+cur_clip2d_path.path_idx;
                  break;

               case 0x54:  // w2 <pathIdx.u8>
                  cur_clip2d_path  <= paths.getRev(ifs.u8 + 1);
                  b_cur_clip2d_pre  = false;
                  // b_cur_clip_fb     = false;
                  b_cur_clip_3d     = false;
                  if(b_debug_op) trace "[dbg] w2 "+cur_clip2d_path.path_idx;
                  break;

               case 0x55:  // w2 <pathIdx.u16>
                  cur_clip2d_path  <= paths.getRev(ifs.u16 + 1);
                  b_cur_clip2d_pre  = false;
                  // b_cur_clip_fb     = false;
                  b_cur_clip_3d     = false;
                  if(b_debug_op) trace "[dbg] w2 "+cur_clip2d_path.path_idx;
                  break;

               case 0x56:  // w3fb
                  cur_clip2d_path <= null;
                  b_cur_clip2d_pre = false;
                  b_cur_clip_3d    = true;
                  if(b_debug_op) trace "[dbg] w3fb";
                  break;

               case 0x5F:  // fp
                  // free last path (only implemented in C++ minnie.h)
                  if(b_debug_op) trace "[dbg] fp";
                  break;

               case 0x60:  // b dstX dstY
                  dstX = (ifs.s16 / 4.0f) * geo_scale;
                  dstY = (ifs.s16 / 4.0f) * geo_scale;
                  if(b_debug_op >= 2) trace "[dbg] b "+dstX+" "+dstY+" ["+cur_src_fb.w+" "+cur_src_fb.h+" 0 0]";
                  break;

               case 0x61:  // b dstX dstY w h srcX srcY (u8)
                  dstX = (ifs.s16 / 4.0f) * geo_scale;
                  dstY = (ifs.s16 / 4.0f) * geo_scale;
                  w = ifs.u8 * geo_scale;
                  h = ifs.u8 * geo_scale;
                  srcX = ifs.u8 * geo_scale;
                  srcY = ifs.u8 * geo_scale;
                  if(b_debug_op >= 2) trace "[dbg] b "+dstX+" "+dstY+" "+w+" "+h+" "+srcX+" "+srcY+"  (u8)";
                  break;

               case 0x62:  // b dstX dstY w h srcX srcY (u16)
                  dstX = (ifs.s16 / 4.0f) * geo_scale;
                  dstY = (ifs.s16 / 4.0f) * geo_scale;
                  w = ifs.u16 * geo_scale;
                  h = ifs.u16 * geo_scale;
                  srcX = ifs.u16 * geo_scale;
                  srcY = ifs.u16 * geo_scale;
                  if(b_debug_op >= 2) trace "[dbg] b "+dstX+" "+dstY+" "+w+" "+h+" "+srcX+" "+srcY+"  (u16)";
                  break;

               case 0x70:  // mask 0
               case 0x71:  // mask 1
               case 0x72:  // mask 2
               case 0x73:  // mask 3
               case 0x74:  // mask 4
               case 0x75:  // mask 5
               case 0x76:  // mask 6
               case 0x77:  // mask 7
               case 0x78:  // mask 8
               case 0x79:  // mask 9
               case 0x7A:  // mask 10
               case 0x7B:  // mask 11
               case 0x7C:  // mask 12
               case 0x7D:  // mask 13
               case 0x7E:  // mask 14
               case 0x7F:  // mask 15
                  cur_mask_idx = (op - 0x70);
                  if(b_debug_op) trace "[dbg] a "+cur_mask_idx;
                  break;

               case 0x80:  // mask <u8>
                  cur_mask_idx = ifs.u8;
                  if(b_debug_op) trace "[dbg] a "+cur_mask_idx;
                  break;

               case 0x81:  // mask off
                  cur_mask_idx = -1;
                  if(b_debug_op) trace "[dbg] a off";
                  break;

               case 0x82:  // k / stroke_w
                  cur_stroke_w = (ifs.u8 / 4.0f) * stroke_scale;
                  if(b_debug_op >= 3)
                  {
                     if(cur_stroke_w <= 0.001f)
                        trace "[dbg] k fill";
                     else if(cur_stroke_w <= 0.25f)
                        trace "[dbg] k line";
                     else
                        trace "[dbg] k "+cur_stroke_w;
                  }
                  break;

               case 0x83:  // k 0    /    k fill
                  cur_stroke_w = 0;
                  if(b_debug_op >= 3) trace "[dbg] k fill";
                  break;

               case 0x84:  // p <idx>  (convex)
                  cur_path <= new Path;
                  cur_path.init(paths.numElements/*pathId*/, Path.TYPE_CONVEX);
                  paths.add(#(deref cur_path));
                  last_parent_path <= cur_path;
                  sub_path_rel_idx = 0;  // (todo) REMOVE
                  cur_x = 0;
                  cur_y = 0;
                  mirrorX = 0;
                  mirrorY = 0;
                  if(b_debug_op) trace "[dbg] p "+cur_path.path_idx;
                  // trace "xxx   => paths="+#(paths);
                  break;

               case 0x85:  // pt <idx>  (concave)
                  cur_path <= new Path;
                  cur_path.init(paths.numElements/*pathIdx*/, b_force_convert_pt_to_ph ? Path.TYPE_EVENODD : Path.TYPE_CONCAVE);
                  paths.add(#(deref cur_path));
                  last_parent_path <= cur_path;
                  sub_path_rel_idx = 0;  // (todo) REMOVE
                  cur_x = 0;
                  cur_y = 0;
                  mirrorX = 0;
                  mirrorY = 0;
                  if(b_debug_op) trace "[dbg] pt "+cur_path.path_idx+"  (concave)";
                  // trace "xxx   => paths="+#(paths);
                  break;

               case 0x86:  // sub path
                  cur_path <= new Path;
                  cur_path.init(last_parent_path.path_idx + ++sub_path_rel_idx, last_parent_path.type);
                  last_parent_path.addSubPath(deref cur_path);
                  cur_x = 0;
                  cur_y = 0;
                  mirrorX = 0;
                  mirrorY = 0;
                  if(b_debug_op) trace "[dbg] psub "+cur_path.path_idx+"("+last_parent_path.path_idx+"."+sub_path_rel_idx+")";
                  // trace "xxx   => paths="+#(paths);
                  break;

               case 0x87:  // ph <idx>  (holes)
                  cur_path <= new Path;
                  cur_path.init(paths.numElements/*pathIdx*/, Path.TYPE_EVENODD);
                  paths.add(#(deref cur_path));
                  last_parent_path <= cur_path;
                  sub_path_rel_idx = 0;  // (todo) REMOVE
                  cur_x = 0;
                  cur_y = 0;
                  mirrorX = 0;
                  mirrorY = 0;
                  if(b_debug_op) trace "[dbg] ph "+cur_path.path_idx+"  (holes)";
                  // trace "xxx   => paths="+#(paths);
                  break;

               case 0x88:  // l dx dy (unsigned 6.2)
                  last_x = cur_x;
                  last_y = cur_y;
                  cur_x += (ifs.u8 / 4.0f);
                  cur_y += (ifs.u8 / 4.0f);
                  if(b_debug_op >= 2) trace "[dbg] l "+cur_x+" "+cur_y+" (u6.2)";
                  // opLine(last_x, last_y, cur_x, cur_y);
                  cur_path.lazyBegin(last_x, last_y);
                  cur_path.lineTo(cur_x, cur_y);
                  mirrorX = 0;
                  mirrorY = 0;
                  break;

               case 0x89:  // l dx dy (signed 14.2 shorts)
                  last_x = cur_x;
                  last_y = cur_y;
                  cur_x += (ifs.s16 / 4.0f);
                  cur_y += (ifs.s16 / 4.0f);
                  if(b_debug_op >= 2) trace "[dbg] l "+cur_x+" "+cur_y+" (s14.2)";
                  // opLine(last_x, last_y, cur_x, cur_y);
                  cur_path.lazyBegin(last_x, last_y);
                  cur_path.lineTo(cur_x, cur_y);
                  mirrorX = 0;
                  mirrorY = 0;
                  break;

               case 0x8A:  // l dx dy (u8)
                  last_x = cur_x;
                  last_y = cur_y;
                  cur_x += ifs.u8;
                  cur_y += ifs.u8;
                  if(b_debug_op >= 2) trace "[dbg] l "+cur_x+" "+cur_y+" (u8)";
                  // opLine(last_x, last_y, cur_x, cur_y);
                  cur_path.lazyBegin(last_x, last_y);
                  cur_path.lineTo(cur_x, cur_y);
                  mirrorX = 0;
                  mirrorY = 0;
                  break;

               case 0x8B:  // l dx dy (s6.2)
                  last_x = cur_x;
                  last_y = cur_y;
                  cur_x += (ifs.s8 / 4.0f);
                  cur_y += (ifs.s8 / 4.0f);
                  if(b_debug_op >= 2) trace "[dbg] l "+cur_x+" "+cur_y+" (s6.2)";
                  // opLine(last_x, last_y, cur_x, cur_y);
                  cur_path.lazyBegin(last_x, last_y);
                  cur_path.lineTo(cur_x, cur_y);
                  mirrorX = 0;
                  mirrorY = 0;
                  break;

               case 0x8C:  // l dx dy (s10.2)
                  ifs4.begin(ifs);
                  last_x = cur_x;
                  last_y = cur_y;
                  // trace "xxx read l cur=("+cur_x+";"+cur_y+")";
                  cur_x += (ifs4.read12s() / 4.0f);
                  cur_y += (ifs4.read12s() / 4.0f);
                  // trace "xxx read l d=("+(cur_x - last_x)+";"+(cur_y - last_y)+") lineDty="+lineDtY;
                  ifs4.end();
                  if(b_debug_op >= 2) trace "[dbg] l "+cur_x+" "+cur_y+" (s10.2)";
                  // opLine(last_x, last_y, cur_x, cur_y);
                  cur_path.lazyBegin(last_x, last_y);
                  cur_path.lineTo(cur_x, cur_y);
                  break;

               case 0x8D:  // pi  (immediate)
                  cur_path <= new Path;
                  cur_path.init(paths.numElements/*pathIdx*/, Path.TYPE_IMMEDIATE);
                  paths.add(#(deref cur_path));
                  last_parent_path <= cur_path;
                  sub_path_rel_idx = 0;  // (todo) REMOVE
                  cur_x = 0;
                  cur_y = 0;
                  mirrorX = 0;
                  mirrorY = 0;
                  if(b_debug_op) trace "[dbg] pi "+cur_path.path_idx+"  (immediate)";
                  // trace "xxx   => paths="+#(paths);
                  break;

               case 0x8E:  // num_seg (u8)
                  cur_num_seg = ifs.u8;
                  if(b_debug_op) trace "[dbg] j "+cur_num_seg;
                  break;

               case 0x8F:  // num_seg (u16)
                  cur_num_seg = ifs.u16;
                  if(b_debug_op) trace "[dbg] j "+cur_num_seg;
                  break;

               case 0x90:  // cubic spline (s6.2)
                  c1x     = cur_x + (ifs.s8 / 4.0f);
                  c1y     = cur_y + (ifs.s8 / 4.0f);
                  mirrorX = (ifs.s8 / 4.0f);
                  mirrorY = (ifs.s8 / 4.0f);
                  dstX    = cur_x + (ifs.s8 / 4.0f);
                  dstY    = cur_y + (ifs.s8 / 4.0f);
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op >= 2) trace "[dbg] c "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+" (s6.2)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x91:  // cubic spline (s8.0)
                  c1x     = cur_x + ifs.s8;
                  c1y     = cur_y + ifs.s8;
                  mirrorX = ifs.s8;
                  mirrorY = ifs.s8;
                  dstX    = cur_x + ifs.s8;
                  dstY    = cur_y + ifs.s8;
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op >= 2) trace "[dbg] c "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+" (s8.0)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x92:  // cubic spline (u8.0)
                  c1x     = cur_x + ifs.u8;
                  c1y     = cur_y + ifs.u8;
                  mirrorX = ifs.u8;
                  mirrorY = ifs.u8;
                  dstX    = cur_x + ifs.u8;
                  dstY    = cur_y + ifs.u8;
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op >= 2) trace "[dbg] c "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY;
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x93:  // cubic spline (s14.2)
                  c1x     = cur_x + (ifs.s16 / 4.0f);
                  c1y     = cur_y + (ifs.s16 / 4.0f);
                  mirrorX = (ifs.s16 / 4.0f);
                  mirrorY = (ifs.s16 / 4.0f);
                  if(b_debug_cubic) trace "[trc] cur=("+cur_x+";"+cur_y+") mirror=("+mirrorX+";"+mirrorY+")";
                  dstX    = cur_x + (ifs.s16 / 4.0f);
                  dstY    = cur_y + (ifs.s16 / 4.0f);
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op >= 2) trace "[dbg] c "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+"  (s14.2)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x94:  // cubic spline (s10.2)
                  ifs4.begin(ifs);
                  c1x     = cur_x + (ifs4.read12s() / 4.0f);
                  c1y     = cur_y + (ifs4.read12s() / 4.0f);
                  mirrorX = (ifs4.read12s() / 4.0f);
                  mirrorY = (ifs4.read12s() / 4.0f);
                  if(b_debug_cubic) trace "[trc] cur=("+cur_x+";"+cur_y+") mirror=("+mirrorX+";"+mirrorY+")";
                  dstX    = cur_x + (ifs4.read12s() / 4.0f);
                  dstY    = cur_y + (ifs4.read12s() / 4.0f);
                  ifs4.end();
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op >= 2) trace "[dbg] c "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+"  (s10.2)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x95:  // m -(unsigned 8.0)
                  cur_x -= ifs.u8;
                  cur_y -= ifs.u8;
                  if(b_debug_op) { trace "[dbg] m "+cur_x+" "+cur_y+"  (-u8.0)\n"; }
                  break;

               case 0x96:  // m (unsigned 8.0 * 2)
                  cur_x += (ifs.u8 + 1) * 2.0f;
                  cur_y += (ifs.u8 + 1) * 2.0f;
                  if(b_debug_op) { trace "[dbg] m "+cur_x+" "+cur_y+"  (u8.0*2)\n"; }
                  break;

               case 0x98:  // cubic spline mirror (s6.2)
                  c1x     = cur_x + mirrorX;
                  c1y     = cur_y + mirrorY;
                  mirrorX = (ifs.s8 / 4.0f);
                  mirrorY = (ifs.s8 / 4.0f);
                  dstX    = cur_x + (ifs.s8 / 4.0f);
                  dstY    = cur_y + (ifs.s8 / 4.0f);
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op) trace "[dbg] s "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+" (s6.2)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x99:  // cubic spline mirror (s8.0)
                  c1x     = cur_x + mirrorX;
                  c1y     = cur_y + mirrorY;
                  mirrorX = ifs.s8;
                  mirrorY = ifs.s8;
                  dstX    = cur_x + ifs.s8;
                  dstY    = cur_y + ifs.s8;
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op) trace "[dbg] s "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+" (s8.0)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x9A:  // cubic spline mirror (u8.0)
                  c1x     = cur_x + mirrorX;
                  c1y     = cur_y + mirrorY;
                  mirrorX = ifs.u8;
                  mirrorY = ifs.u8;
                  dstX    = cur_x + ifs.u8;
                  dstY    = cur_y + ifs.u8;
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op) trace "[dbg] s "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY;
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x9B:  // cubic spline mirror (s14.2)
                  c1x     = cur_x + mirrorX;
                  c1y     = cur_y + mirrorY;
                  mirrorX = (ifs.s16 / 4.0f);
                  mirrorY = (ifs.s16 / 4.0f);
                  dstX    = cur_x + (ifs.s16 / 4.0f);
                  dstY    = cur_y + (ifs.s16 / 4.0f);
                  c2x     = dstX - mirrorX;
                  c2y     = dstY - mirrorY;
                  if(b_debug_op) trace "[dbg] s "+c1x+" "+c1y+" "+c2x+" "+c2y+" "+dstX+" "+dstY+" (s14.2)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.cubicTo(cur_x, cur_y,
                                   c1x,   c1y,
                                   c2x,   c2y,
                                   dstX,  dstY,
                                   cur_num_seg,
                                   cubic_min_dist_sqr
                                   );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x9E:  // arc (s14.2)
                  rx = ifs.s16 / 4.0f;
                  ry = ifs.s16 / 4.0f;
                  rotAndFlags = ifs.u16;
                  xrot = ((rotAndFlags >> 2)&16383) * (2PI / (512.0f*32));
                  if(b_debug_arc >= 2 && (xrot != 0.0f))
                     trace "[trc] arc rotAndFlags="+rotAndFlags+" xrot="+(xrot*(360.0f/2PI));
                  bLargeArc = rotAndFlags & (1 << 0);
                  bArcSweep = (rotAndFlags & (1 << 1)) >> 1;
                  dstX    = cur_x + (ifs.s16 / 4.0f);
                  dstY    = cur_y + (ifs.s16 / 4.0f);
                  if(b_debug_op) trace "[dbg] arc "+rx+" "+ry+" "+xrot+" "+bLargeArc+" "+bArcSweep+" "+dstX+" "+dstY+"  (#seg="+cur_num_seg+") (s14.2)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.arcTo(cur_x, cur_y,
                                 rx, ry,
                                 xrot,
                                 bLargeArc,
                                 bArcSweep,
                                 dstX,  dstY,
                                 cur_num_seg
                                 );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0x9F:  // arc (f32)
                  rx = ifs.f32;
                  ry = ifs.f32;
                  rotAndFlags = ifs.u16;
                  xrot = ((rotAndFlags >> 2)&16383) * (2PI / (512.0f*32));
                  if(b_debug_arc >= 2 && (xrot != 0.0f))
                     trace "[trc] arc rotAndFlags="+rotAndFlags+" xrot="+(xrot*(360.0f/2PI));
                  bLargeArc = rotAndFlags & (1 << 0);
                  bArcSweep = (rotAndFlags & (1 << 1)) >> 1;
                  dstX    = cur_x + ifs.f32;
                  dstY    = cur_y + ifs.f32;
                  if(b_debug_op) trace "[dbg] arc "+rx+" "+ry+" "+xrot+" "+bLargeArc+" "+bArcSweep+" "+dstX+" "+dstY+"  (#seg="+cur_num_seg+") (f32)";
                  cur_path.lazyBegin(cur_x, cur_y);
                  cur_path.arcTo(cur_x, cur_y,
                                 rx, ry,
                                 xrot,
                                 bLargeArc,
                                 bArcSweep,
                                 dstX,  dstY,
                                 cur_num_seg
                                 );
                  cur_x   = dstX;
                  cur_y   = dstY;
                  break;

               case 0xA0:  // r (u6.2)
                  w = (ifs.u8 / 4.0f);
                  h = (ifs.u8 / 4.0f);
                  if(b_debug_op) trace "[dbg] r "+w+" "+h+" (u6.2)";
                  cur_path.rect(cur_x, cur_y, w, h);
                  break;

               case 0xA1:  // r (u14.2)
                  w = (ifs.u16 / 4.0f);
                  h = (ifs.u16 / 4.0f);
                  if(b_debug_op) trace "[dbg] r "+w+" "+h+" (u14.2)";
                  cur_path.rect(cur_x, cur_y, w, h);
                  break;

               case 0xA2:  // r (u8.0)
                  w = ifs.u8;
                  h = ifs.u8;
                  if(b_debug_op) trace "[dbg] r "+w+" "+h+" (u8.0)";
                  cur_path.rect(cur_x, cur_y, w, h);
                  break;

               case 0xA3:  // r (u8.0 even)
                  w = (ifs.u8 << 1);
                  h = (ifs.u8 << 1);
                  if(b_debug_op) trace "[dbg] r "+w+" "+h+" (u8.0*2)";
                  cur_path.rect(cur_x, cur_y, w, h);
                  break;

               case 0xA4:  // r (f32)
                  w = ifs.f32;
                  h = ifs.f32;
                  rx = ifs.f32;
                  ry = ifs.f32;
                  if(b_debug_op) trace "[dbg] r "+w+" "+h+" "+rx+" "+ry+" (f32)";
                  cur_path.roundRect(cur_x, cur_y, w, h, rx, ry, cur_num_seg, cubic_min_dist_sqr);
                  break;

               case 0xA5:  // r (u14.2)
                  w = ifs.u16 / 4.0;
                  h = ifs.u16 / 4.0;
                  rx = ifs.u16 / 4.0;
                  ry = ifs.u16 / 4.0;
                  if(b_debug_op) trace "[dbg] r "+w+" "+h+" "+rx+" "+ry+" (u14.2)";
                  cur_path.roundRect(cur_x, cur_y, w, h, rx, ry, cur_num_seg, cubic_min_dist_sqr);
                  break;

               case 0xA6:  // r (u8*2)
                  w = ifs.u8 * 2.0f;
                  h = ifs.u8 * 2.0f;
                  rx = ifs.u8 * 2.0f;
                  ry = ifs.u8 * 2.0f;
                  if(b_debug_op) trace "[dbg] r "+w+" "+h+" "+rx+" "+ry+" (u8*2)";
                  cur_path.roundRect(cur_x, cur_y, w, h, rx, ry, cur_num_seg, cubic_min_dist_sqr);
                  break;

               case 0xB0:  // e (u6.2)
                  rx = (ifs.u8 / 4.0f);
                  ry = (ifs.u8 / 4.0f);
                  if(b_debug_op) trace "[dbg] e "+rx+" "+ry+" (u6.2)";
                  cur_path.ellipse(cur_x, cur_y, rx, ry, cur_num_seg);
                  break;

               case 0xB1:  // e (u14.2)
                  rx = (ifs.u16 / 4.0f);
                  ry = (ifs.u16 / 4.0f);
                  if(b_debug_op) trace "[dbg] e "+rx+" "+ry+" (u14.2)";
                  cur_path.ellipse(cur_x, cur_y, rx, ry, cur_num_seg);
                  break;

               case 0xB2:  // e (u8.0)
                  rx = ifs.u8;
                  ry = ifs.u8;
                  if(b_debug_op) trace "[dbg] e "+rx+" "+ry+" (u8.0)";
                  cur_path.ellipse(cur_x, cur_y, rx, ry, cur_num_seg);
                  break;

               case 0xB3:  // e (u8.0 even)
                  rx = (ifs.u8 << 1);
                  ry = (ifs.u8 << 1);
                  if(b_debug_op) trace "[dbg] e "+rx+" "+ry+" (u8.0*2)";
                  cur_path.ellipse(cur_x, cur_y, rx, ry, cur_num_seg);
                  break;

               case 0xB4:  // circle (u14.2)
                  r = (ifs.u16 / 4.0f);
                  if(b_debug_op) trace "[dbg] circle "+r+" (u14.2)";
                  cur_path.circle(cur_x, cur_y, r, cur_num_seg);
                  break;

               case 0xC0: // v <pathIdx> <sx> <sy> <ang> (scale+rotate)
                  // (todo) REMOVE
                  oPath <= paths.get(ifs.u8);
                  sx  =  ifs.s16 / 4096.0f;
                  sy  =  ifs.s16 / 4096.0f;
                  ang = (ifs.u16 & 16383) * (360.0f / 16384.0f);
                  if(b_debug_op) trace "[dbg] v "+oPath.path_idx+" "+sx+" "+sy+" "+ang+"  (u8)";
                  break;

               case 0xC1: // v <pathIdx> <sx> <sy> <ang> (scale+rotate)
                  // (todo) REMOVE
                  oPath <= paths.get(ifs.u16);
                  sx  =  ifs.s16 / 4096.0f;
                  sy  =  ifs.s16 / 4096.0f;
                  ang = (ifs.u16 & 16383) * (360.0f / 16384.0f);
                  if(b_debug_op) trace "[dbg] v "+oPath.path_idx+" "+sx+" "+sy+" "+ang+"  (u16)";
                  break;

               case 0xC2: // v <pathIdx>
                  // (todo) REMOVE
                  oPath <= paths.get(ifs.u8);
                  if(b_debug_op) trace "[dbg] v "+oPath.path_idx+" "+sx+" "+sy+" "+ang+"  (u8)";
                  break;

               case 0xC3: // v <pathIdx>
                  // (todo) REMOVE
                  oPath <= paths.get(ifs.u16);
                  if(b_debug_op) trace "[dbg] v "+oPath.path_idx+" "+sx+" "+sy+" "+ang+"  (u16)";
                  break;

               case 0xD0: // d <pathIdx>
                  pathIdx = ifs.u8;
                  oPath <= paths.getRev(pathIdx);
                  if(null == oPath)
                     trace "[---] 0xD0: pathIdx="+pathIdx+" oPath="+#(oPath)+" paths="+#(paths);
                  else
                  {
                     if(b_debug_op) trace "[dbg] d "+pathIdx+"  (u8)";
                     drawMultiPath(oPath, 0/*mode=notransform*/);
                  }
                  break;

               case 0xD1: // d <pathIdx>
                  pathIdx = ifs.u16;
                  oPath <= paths.getRev(pathIdx);
                  if(null == oPath)
                     trace "[---] 0xD1: pathIdx="+pathIdx+" oPath="+#(oPath)+" paths="+#(paths);
                  else
                  {
                     if(b_debug_op) trace "[dbg] d "+pathIdx+"  (u16)";
                     drawMultiPath(oPath, 0/*mode=no transform*/);
                  }
                  break;

               case 0xD2: // d2 <pathIdx>
                  pathIdx = ifs.u8;
                  oPath <= paths.getRev(pathIdx);
                  if(null == oPath)
                     trace "[---] 0xD2: pathIdx="+pathIdx+" oPath="+#(oPath)+" paths="+#(paths);
                  else
                  {
                     if(b_debug_op) trace "[dbg] d2 "+pathIdx+"  (u8)";
                     drawMultiPath(oPath, 1/*mode=transform2d*/);
                  }
                  break;

               case 0xD3: // d3 <pathIdx>
                  pathIdx = ifs.u8;
                  oPath <= paths.getRev(pathIdx);
                  if(null == oPath)
                     trace "[---] 0xD3: pathIdx="+pathIdx+" oPath="+#(oPath)+" paths="+#(paths);
                  else
                  {
                     if(b_debug_op) trace "[dbg] d3 "+pathIdx+"  (u8)";
                     drawMultiPath(oPath, 2/*mode=transform3d*/);
                  }
                  break;

               case 0xD4: // d2 <pathIdx>
                  pathIdx = ifs.u16;
                  oPath <= paths.getRev(pathIdx);
                  if(null == oPath)
                     trace "[---] 0xD4: pathIdx="+pathIdx+" oPath="+#(oPath)+" paths="+#(paths);
                  else
                  {
                     if(b_debug_op) trace "[dbg] d2 "+pathIdx+"  (u16)";
                     drawMultiPath(oPath, 1/*mode=transform2d*/);
                  }
                  break;

               case 0xD5: // d3 <pathIdx>
                  pathIdx = ifs.u16;
                  oPath <= paths.getRev(pathIdx);
                  if(null == oPath)
                     trace "[---] 0xD5: pathIdx="+pathIdx+" oPath="+#(oPath)+" paths="+#(paths);
                  else
                  {
                     if(b_debug_op) trace "[dbg] d3 "+pathIdx+"  (u16)";
                     drawMultiPath(oPath, 2/*mode=transform3d*/);
                  }
                  break;

               case 0xFE: // y
                  if(b_debug_op) trace "[dbg] y";
                  cur_path.end(false/*bClosed*/);
                  cur_path <= paths.getRev(0);
                  cur_x = 0;
                  cur_y = 0;
                  break;

               case 0xFF: // z
                  if(b_debug_op) trace "[dbg] z";
                  cur_path.end(true/*bClosed*/);
                  cur_path <= paths.getRev(0);
                  cur_x = 0;
                  cur_y = 0;
                  break;

            }
         }

      }
      catch(Error e)
      {
         trace "[---] MinnieBin::parseStream: caught exception e.name=\""+e.name+"\" e.msg=\""+e.message+"\"";
         trace e.stackTrace;
      }
      return false;
   }

   // <method.png>
   public method drawMainFbTexture() {
      Framebuffer fb <= framebuffers.get(0);
      Texture tex <= fb.tex;
      tex.bind();
      tex.enable();
      zglColorARGB(#ffffffff);

      float uMax = b_filter ? (tex.sx - FILTER_W) / tex.sx : 1;
      float vMax = b_filter ? (tex.sy - FILTER_H) / tex.sy : 1;

      glBegin(GL_QUADS);

      glTexCoord2f(0,0);
      glVertex2f(0, 0);

      glTexCoord2f(uMax, 0);
      glVertex2f(geo_w, 0);

      glTexCoord2f(uMax, vMax);
      glVertex2f(geo_w, geo_h);

      glTexCoord2f(0, vMax);
      glVertex2f(0, geo_h);

      glEnd();

      tex.unbind();
      tex.disable();
   }

   // <method_parse.png>
   public method parseFile(String _pathname) : boolean {
      local File f;
      if(f.openLocal(_pathname, IOS_IN))
      {
         if(parseStream(f))
         {
            trace "[+++] parsed file \""+_pathname+"\" (sz="+f.offset+")";
            return true;
         }
         else
         {
            trace "[---] failed to parse file \""+_pathname+"\" (stopped at off="+f.offset+")";
            return false;
         }
      }
      else
      {
         trace "[---] MinnieBin::parseFile: failed to open \""+_pathname+"\" for reading";
      }
      return false;
   }

}


namespace default;

minniebin::MinnieBin minnieBin;

function onDraw() {
   zglClearColorARGB(#00333333);
   glClear(GL_COLOR_BUFFER_BIT);
   glDisable(GL_DEPTH_TEST);
   glDisable(GL_STENCIL_TEST);
   glDisable(GL_BLEND);

   if(bParse)
   {
      int tStart = milliSeconds();
      fileBuf.offset = 0;
      if(minnieBin.parseStream(fileBuf))
      {
         int tDelta = milliSeconds() - tStart;
         if(minniebin::b_profile) trace "[...] MIB stream processed in "+tDelta+" ms";

         minnieBin.drawMainFbTexture();
         // bParse = false;
         // exit(10);//xxxxxxxxxxxxxxx
      }
      else
      {
         bParse = false;
      }
   }

   if(b_queued_screenshot)
   {
      b_queued_screenshot = false;
      Integer ioTestIdx = test_idx;
      SaveScreenShotPNG("screenshots/minnie_"+ioTestIdx.printf("%03d")+".png");
   }
}

// ---------------------------------------------------------------------------- onKeyboard
function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case 'f':
         minniebin::b_filter = !minniebin::b_filter;
         trace "[...] b_filter is "+minniebin::b_filter;
         break;

      case 'a':
         minniebin::b_allow_aa = !minniebin::b_allow_aa;
         trace "[...] b_allow_aa is "+minniebin::b_allow_aa;
         break;

      case 'p':
         b_queued_screenshot = true;
         trace "[...] queue screenshot";
         break;

      case VKEY_PAGEUP:
         debug_tri_idx++;
         break;

      case VKEY_PAGEDOWN:
         debug_tri_idx = mathMaxi(-1, debug_tri_idx - 1);
         break;

      case VKEY_UP:
         test_idx = mathWrapi(test_idx + 1, 0, tests.numElements);
         pathNameIn = tests.get(test_idx);
         LoadFileBuf();
         trace "[...] test_idx is "+test_idx+" (\""+pathNameIn+"\")";
         break;

      case VKEY_DOWN:
         test_idx = mathWrapi(test_idx - 1, 0, tests.numElements);
         pathNameIn = tests.get(test_idx);
         LoadFileBuf();
         trace "[...] test_idx is "+test_idx+" (\""+pathNameIn+"\")";
         break;
   }

}

// ---------------------------------------------------------------------------- main

if(Arguments.numElements >= 1)
{
   pathNameIn = Arguments[0];
   if(pathNameIn.numChars <= 3)
   {
      test_idx = mathClampi(pathNameIn, 0, tests.numElements);
      pathNameIn = tests.get(test_idx);
   }
   else
   {
      test_idx = tests.indexOfObject(pathNameIn, 0);
   }
}
else
{
   pathNameIn = tests.get(0);
   test_idx = 0;
}

if(!pathNameIn.isBlank())
{
   LoadFileBuf();

   Viewport.openWindow(640*vp_scale, 480*vp_scale);
   use callbacks;
   SDL.eventLoop();
}
