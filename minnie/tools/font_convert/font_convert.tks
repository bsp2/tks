// ----
// ---- file   : font_convert.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : Copyright 2020-2025 by Bastian Spiegel.
// ----
// ----           This program is free software; you can redistribute it and/or modify
// ----           it under the terms of the GNU General Public License as published by
// ----           the Free Software Foundation; either version 2 of the License, or
// ----           (at your option) any later version.
// ----
// ----           This program is distributed in the hope that it will be useful,
// ----           but WITHOUT ANY WARRANTY; without even the implied warranty of
// ----           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// ----           GNU General Public License for more details.
// ----
// ----           You should have received a copy of the GNU General Public License
// ----           along with this program; if not, write to the Free Software
// ----           Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// ----
// ---- info   : TTF to pixelfont (.cpp/.png) converter
// ---- note   : glyphs start at index 32 (' ')
// ----
// ----
// ----

use tkui;
use namespace ui;

boolean b_debug = 0;

int firstGlyph = 32;
int numGlyphs  = 128 - firstGlyph;

String outPrefix = "out/";

String ttfPathName;
int styleFlags;
int fontSize;
boolean bSDF;
int scale = 1;

String fontName = "default_30";

/*
struct sdvg_font_t {
   sS16 height;
   sS16 ascender;
   sS16 descender;
   sS16 underline_position;   // *64
   sS16 underline_thickness;  // *64
   sU16 first_glyph;
   sU16 num_glyphs;
   sU16 sdf_radius;
   sF32 us;  // 1/orig_tex_w
   sF32 vs;  // 1/orig_tex_h
};

struct sdvg_glyph_t {
   sS16 x;
   sS16 y;
   sS16 w;
   sS16 h;
   sS16 offset_x;
   sS16 offset_y;
   sS16 advance_x;
};
*/

function Usage() {
   trace "Usage: trks font_convert <font.ttf> <fontName> <normal|bold> <size> [[sdf] [<scale>]]";
   exit(10);
}

if(Arguments.numElements >= 1)
{
   ttfPathName = Arguments[0];
   if(ttfPathName >= ".ttf")
   {
      if(Arguments.numElements >= 2)
      {
         fontName = Arguments[1];

         if(1)
         {
            if(Arguments.numElements >= 3)
            {
               switch(Arguments[2])
               {
                  default:
                     trace "[---] invalid style flag \""+Arguments[1]+"\" (expect normal | bold | italic | bold_italic)";
                     Usage();
                     break;

                  case "normal":
                     styleFlags = Font.STYLE_NORMAL;
                     break;

                  case "bold":
                     styleFlags = Font.STYLE_BOLD;
                     break;

                  case "italic":
                     styleFlags = Font.STYLE_ITALIC;
                     break;

                  case "bold_italic":
                     styleFlags = Font.STYLE_BOLD_ITALIC;
                     break;
               }

               if(Arguments.numElements >= 4)
               {
                  fontSize = Arguments[3];
                  if(4 <= fontSize <= 1000)
                  {
                     // ok

                     if(Arguments.numElements >= 5)
                     {
                        bSDF = ("sdf" == Arguments[4]);

                        if(Arguments.numElements >= 6)
                        {
                           scale = int(Arguments[5]);
                           if(scale < 1)
                              scale = 1;
                        }
                     }
                  }
                  else
                  {
                     trace "[---] font size out of range (expect=4..1000, have="+fontSize+")";
                     Usage();
                  }
               }
               else
               {
                  trace "[---] missing font size";
                  Usage();
               }
            }
            else
            {
               trace "[---] missing style flags (normal | bold | italic | bold_italic)";
               Usage();
            }
         } // if 1 (fontName)
      }
      else
      {
         trace "[---] missing font name";
         Usage();
      }
   }
   else
   {
      trace "[---] TTF pathname does not have .ttf suffix";
      Usage();
   }
}
else
{
   trace "[---] missing TTF pathname";
   Usage();
}

int sdfRadius = 12;
float sdfMaxDist = sdfRadius - 1;

if(bSDF)
{
   sdfRadius *= scale;
   sdfMaxDist = sdfRadius - 1;

   trace "[...] sdfRadius="+sdfRadius+" sdfMaxDist="+sdfMaxDist;
}

UI.SetEnableFontSmoothing(!bSDF);
UI.Initialize(Arguments);
FT2Face.SetDefaultTextureSize2f(scale * 2048, scale * 2048);

String styleName = Font.GetStyleFlagsStringFor(styleFlags);
if("normal" == styleName) styleName="";
String fullFontName <= fontName+" "+styleName+" "+(fontSize*scale);
fullFontName.replace("  ", " ");
String cFontName <= fontName+"_"+styleName+"_"+(fontSize*scale);
cFontName.replace("__", "_");
if(bSDF)
   cFontName.append("_sdf");

String pngOut = outPrefix+cFontName+".png";
String cppOut = outPrefix+cFontName+".cpp";  // glyph c structs
String binOut = outPrefix+cFontName+".bin";  // font_info followed by glyph binary array (c struct formats)

if(b_debug) trace "[dbg] fullFontName=\""+fullFontName+"\"";
if(b_debug) trace "[dbg] cFontName=\""+cFontName+"\"";

Font font <= UI.GetFontByNameEx(fullFontName, true/*bExactSizeMatch*/);
if(null == font)
{
   trace "[...] adding font resource \""+fullFontName+"\" (fontName=\""+fontName+"\" ttfPathName=\""+ttfPathName+"\" styleFlags="+styleFlags+" fontSize*scale="+(fontSize*scale)+")";
   if(UI.AddFontResource(FT2LocalFileFontResource.New(ttfPathName, fontName, styleFlags, fontSize*scale)))
   {
      font <= UI.GetFontByNameEx(fullFontName, true/*bExactSizeMatch*/);
      if(null == font)
      {
         die "failed to resolve font \""+fullFontName+"\"";
      }
   }
   else
   {
      die "UI.AddFontResource() failed";
   }
}

FT2FontResource fontRes <= font.getFontResource();
if(null == fontRes)
   die "failed to resolve fontRes";

FT2Face face <= fontRes.getFT2Face();
FT2Glyph *g;
int glyphIdx;

if(b_debug) trace "[dbg] fontRes="+#(fontRes);
if(b_debug) trace "[dbg] face="+#(face);

Texture texFace <= face.getTexture(0);
Texture tex8;
tex8.alloc(texFace.sx, texFace.sy, 1);
tex8.clear(0);

int curX = pad;
int curY = pad;
int pad = 4*scale;
int texH = 0;
int rowH = 0;
glyphIdx = firstGlyph;
loop(numGlyphs)
{
   g <= face.getGlyph(glyphIdx);

   if(curX + g.width + pad > tex8.sx)
   {
      curX = pad;
      curY += rowH;
      rowH = 0;
   }

   // (todo) add TKSTexture::scaleFromAlpha()
   int texY = 0;
   loop(g.height)
   {
      int texX = 0;
      loop(g.width)
      {
         int c32 = texFace.getXY32(g.bitmapx + texX, g.bitmapy + texY);
         int c8 = bSDF ? (c32 & 255) : ((c32 >> 24) & 255);
         c8 = argb(c8, c8, c8, c8);
         tex8.setXY32(curX + texX, curY + texY, c8);
         texX++;
      }
      texY++;
   }

   g.bitmapx = curX;
   g.bitmapy = curY;

   rowH = mathMaxi(rowH, g.height + pad*2);
   texH = mathMaxi(texH, curY + g.height + pad);

   curX += g.width + pad*2;

   glyphIdx++;
}

Texture tex;
tex.alloc(tex8.sx, texH, 1);
tex.copyRegion(tex8, 0, 0, tex8.sx, texH, 0, 0);

Texture texSDF;
if(bSDF)
{
   texSDF.alloc(texFace.sx, texFace.sy, 1);
   texSDF.clear(0);
}

if(b_debug) trace "[dbg] tex="+#(tex);

float height      = face.getHeight();
float ascender    = face.getAscender();
float descender   = face.getDescender();
float ulPosition  = face.getUnderlinePosition();
float ulThickness = face.getUnderlineThickness();

String bufGlyph;
bufGlyph.append("static const sdvg_glyph_t glyphs_"+cFontName+"["+numGlyphs+"] = {\n");  // 14 bytes

int sdfCurX = sdfRadius;
int sdfCurY = sdfRadius;
int sdfH = 0;
int sdfRowH = 0;

Buffer bufGlyphBin; bufGlyphBin.size = 1024*1024;

glyphIdx = firstGlyph;
loop(numGlyphs)
{
   g <= face.getGlyph(glyphIdx);

   if(bSDF)
   {
      // trace "xxx glyphIdx="+glyphIdx+"('"+tcchar(glyphIdx)+"') sdfCurX="+sdfCurX+" sdfCurY="+sdfCurY;
      stdout ".";
      if( (sdfCurX + g.width + sdfRadius) > texSDF.sx )
      {
         sdfCurY += sdfRowH;
         sdfCurX = sdfRadius;
         sdfRowH = 0;
      }
      texSDF.copyRegion(tex, g.bitmapx, g.bitmapy, g.width, g.height, sdfCurX, sdfCurY);
      g.bitmapx = sdfCurX;
      g.bitmapy = sdfCurY;
      texSDF.calcAlphaSDF(texSDF, g.bitmapx, g.bitmapy, g.width, g.height, sdfRadius, sdfMaxDist);
      sdfCurX += g.width + sdfRadius*2;
      sdfRowH = mathMaxi(sdfRowH, g.height+sdfRadius*2);
      sdfH = mathMaxi(sdfH, g.bitmapy + g.height + sdfRadius);
   }

   bufGlyph.append(" /* glyph "+glyphIdx+" (\'"+tcchar(glyphIdx)+"\') */\n");
   bufGlyph.append(" {\n");
   bufGlyph.append("    "+int(g.bitmapx)+"/*x*/,\n");
   bufGlyph.append("    "+int(g.bitmapy)+"/*y*/,\n");
   bufGlyph.append("    "+int(g.width)+"/*width*/,\n");
   bufGlyph.append("    "+int(g.height)+"/*height*/,\n");
   bufGlyph.append("    "+int(g.offsetx)+"/*offset_x*/,\n");
   bufGlyph.append("    "+int(g.offsety)+"/*offset_y*/,\n");
   bufGlyph.append("    "+int(g.advancex)+"/*advance_x*/\n");
   bufGlyph.append(" },\n");

   bufGlyphBin.i16 = int(g.bitmapx);   // +0
   bufGlyphBin.i16 = int(g.bitmapy);   // +2
   bufGlyphBin.i16 = int(g.width);     // +4
   bufGlyphBin.i16 = int(g.height);    // +6
   bufGlyphBin.i16 = int(g.offsetx);   // +8
   bufGlyphBin.i16 = int(g.offsety);   // +10
   bufGlyphBin.i16 = int(g.advancex);  // +12

   glyphIdx++;
}
bufGlyph.append("};\n");

if(bSDF)
   stdout "\n";

String bufFontInfo;
bufFontInfo.append("static const sdvg_font_info_t font_info_"+cFontName+" = {\n");  // 18 bytes
bufFontInfo.append("  "+int(height)+"/*height*/,\n");
bufFontInfo.append("  "+int(ascender)+"/*ascender*/,\n");
bufFontInfo.append("  "+int(descender)+"/*descender*/\n");
bufFontInfo.append("  "+int(ulPosition * 64)+"/*underline_position*64*/,\n");
bufFontInfo.append("  "+int(ulThickness * 64)+"/*underline_thickness*64*/,\n");
bufFontInfo.append("  "+int(firstGlyph)+"u/*first_glyph*/,\n");
bufFontInfo.append("  "+int(numGlyphs)+"u/*num_glyphs*/,\n");
bufFontInfo.append("  "+int(bSDF ? (sdfRadius) : 0)+"u/*sdf_radius*/,\n");
if(bSDF)
{
   bufFontInfo.append("  (1.0f / "+(texSDF.sx)+")/*us*/,\n");
   bufFontInfo.append("  (1.0f / "+(sdfH)+")/*vs*/\n");
}
else
{
   bufFontInfo.append("  (1.0f / "+(tex.sx)+")/*us*/,\n");
   bufFontInfo.append("  (1.0f / "+(tex.sy)+")/*vs*/\n");
}
bufFontInfo.append("};\n");

File fBin;
if(!fBin.openLocal(binOut, IOS_OUT))
   die "failed to open \""+binOut+"\" for writing";

fBin.i16 = int(height);
fBin.i16 = int(ascender);
fBin.i16 = int(descender);
fBin.i16 = int(ulPosition * 64);
fBin.i16 = int(ulThickness * 64);
fBin.i16 = int(firstGlyph);
fBin.i16 = int(numGlyphs);
fBin.i16 = int(bSDF ? (sdfRadius) : 0);
if(bSDF)
{
   fBin.f32 = (1.0f / (texSDF.sx));
   fBin.f32 = (1.0f / (sdfH));
}
else
{
   fBin.f32 = (1.0f / (tex.sx));
   fBin.f32 = (1.0f / (tex.sy));
}
fBin.writeBuffer(bufGlyphBin, 0, bufGlyphBin.offset);

String bufFont;
bufFont.append("sdvg_font_t font_"+cFontName+" = {\n");
bufFont.append("  &font_info_"+cFontName+";\n");
bufFont.append("  &glyphs_"+cFontName+";\n");
bufFont.append("  sUI tex_id;\n");
bufFont.append("};\n");

if(b_debug) trace "[dbg] bufFontInfo="+bufFontInfo;
if(b_debug) trace "[dbg] bufGlyph="+bufGlyph;
if(b_debug) trace "[dbg] bufFont="+bufFont;

if(bSDF)
{
   Texture texSDFClipY;
   texSDFClipY.alloc(texSDF.sx, sdfH, 1);
   texSDFClipY.copyRegion(texSDF, 0, 0, texSDF.sx, sdfH, 0, 0);
   if(1)
   {
      Texture texSDFTmp; texSDFTmp.alloc(texSDFClipY.sx, texSDFClipY.sy, 1);
      texSDFTmp.simpleBlur(texSDFClipY);
      texSDFTmp.saveImage(pngOut);
   }
   else
   {
      texSDFClipY.saveImage(pngOut);
   }
}
else
{
   tex.saveImage(pngOut);
}
trace "[...] wrote \""+pngOut+"\" (w="+tex.sx+" h="+tex.sy+" bpp="+tex.z+" => "+(int((tex.sx*tex.sy*tex.z*100)/1024.0)/100.0)+"k)";

String buf;
buf.append(bufFontInfo);
buf.append("\n");
buf.append(bufGlyph);
buf.append("\n");
buf.append(bufFont);
buf.saveLocal(cppOut);
trace "[...] wrote \""+cppOut+"\"";

int fBinSz = fBin.offset;
fBin.close();
trace "[...] wrote "+binOut+"\" (sz="+(int((fBinSz*100)/1024.0)/100.0)+"k)";

UI.Exit();
