// ----
// ---- file   : test_shadervg.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : Distributed under terms of the MIT license (https://opensource.org/licenses/MIT)
// ----          Copyright 2025 by bsp
// ----
// ----          Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
// ----          associated documentation files (the "Software"), to deal in the Software without restriction, including
// ----          without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// ----          copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to
// ----          the following conditions:
// ----
// ----          The above copyright notice and this permission notice shall be included in all copies or substantial
// ----          portions of the Software.
// ----
// ----          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// ----          NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// ----          IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// ----          WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// ----          SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----
// ---- info   : ShaderVG render utilities test case
// ----
// ----
// ----

use tksdl;
use tkopengl;
use tkmath;

namespace sdvgcapi;
namespace default;
use namespace sdvgcapi;

boolean b_glcore = 1;
if(b_glcore) putenv("TKSDL_GLCORE=1");   // select 4.1 core profile on macOS

putenv("TKSDL_GLERROR=1");

float VP_W = 640.0;
float VP_H = 480.0;

float vp_scale = 2.0;

boolean b_anim      = 0;    // SPACE
boolean b_slomo     = 0;    // lctrl-SPACE
boolean b_aa        = 1;    // 'a'
float   aa_range    = 2.5 / vp_scale;  // m/lshift-m
float   aa_exp      = 1.0;  // 'k', lshift-k
float   stroke_w    = 1.5;  // LEFT/RIGHT   half width
float   fill_alpha  = 1.0;  // 'r', 't'
float   decal_alpha = 1.0;  // lshift-'r', lshift-'t'
float   radius_sclx = 1.0;  // 'f', 'g'
float   radius_scly = 1.0;  // 'h', 'j'
float   size_sclx   = 1.0;  // 'q', 'w'
float   size_scly   = 1.0;  // 'z', 'x'
boolean b_vsync     = 1;    // 'v'
boolean b_msaa      = 0;    // 'm'

boolean b_sym_radius = 0;   // 'l'

int test_idx = 0;  // '1', '2', '3'

float ang_x = 0;
float ang_y = 0;

float ang_w = 0;
float ang_h = 0;

float ang_c = 0;

stroke_w = 4.0;
ang_x = 3.50704;
ang_y = 3.07918;
ang_w = 0.632583;
ang_h = 0.366048;
ang_c = 0;

int num_frames_rendered = 0;
boolean b_reopen;

// (note) UP/DOWN
int RENDER_RECT_FILL_AA                                =  0;
int RENDER_RECT_FILL_STROKE_AA                         =  1;
int RENDER_RECT_STROKE_AA                              =  2;
int RENDER_ELLIPSE_FILL_AA                             =  3;
int RENDER_ELLIPSE_FILL_STROKE_AA                      =  4;
int RENDER_ELLIPSE_STROKE_AA                           =  5;
int RENDER_ROUNDRECT_FILL_AA                           =  6;
int RENDER_ROUNDRECT_FILL_STROKE_AA                    =  7;
int RENDER_ROUNDRECT_STROKE_AA                         =  8;
int RENDER_TRIANGLES_TEX_UV_FLAT                       =  9;
int RENDER_TRIANGLES_TEX_UV_GOURAUD                    = 10;
int RENDER_TRIANGLES_TEX_UV_FLAT_DECAL                 = 11;
int RENDER_TRIANGLES_TEX_UV_GOURAUD_DECAL              = 12;
int RENDER_LINE_STRIP_FLAT_1                           = 13;
int RENDER_LINE_STRIP_FLAT_2                           = 14;
int RENDER_LINE_STRIP_FLAT_AA_1                        = 15;
int RENDER_LINE_STRIP_FLAT_AA_2                        = 16;
int RENDER_LINE_STRIP_FLAT_BEVEL                       = 17;
int RENDER_LINE_STRIP_FLAT_BEVEL_AA                    = 18;
int RENDER_CUSTOM_SHADER_1                             = 19;
int RENDER_CUSTOM_SHADER_2                             = 20;
int RENDER_CUSTOM_SHADER_3_VBO                         = 21;
int RENDER_LINES                                       = 22;
int RENDER_LINES_AA                                    = 23;
int RENDER_BEGIN_LINE_STRIP                            = 24;
int RENDER_BEGIN_LINE_STRIP_AA                         = 25;
int RENDER_BEGIN_LINE_STRIP_BEVEL                      = 26;
int RENDER_BEGIN_LINE_STRIP_BEVEL_AA                   = 27;
int RENDER_BEGIN_LINES                                 = 28;
int RENDER_BEGIN_LINES_AA                              = 29;
int RENDER_FILLED_RECTANGLE                            = 30;
int RENDER_BEGIN_POINTS_SQUARE                         = 31;
int RENDER_BEGIN_POINTS_SQUARE_AA                      = 32;
int RENDER_BEGIN_POINTS_ROUND                          = 33;
int RENDER_BEGIN_POINTS_ROUND_AA                       = 34;
int RENDER_BEGIN_FILLED_TRIANGLES                      = 35;
int RENDER_BEGIN_FILLED_TRIANGLE_FAN                   = 36;
int RENDER_BEGIN_FILLED_TRIANGLE_STRIP                 = 37;
int RENDER_BEGIN_FILLED_GOURAUD_TRIANGLES              = 38;
int RENDER_BEGIN_FILLED_GOURAUD_TRIANGLE_FAN           = 39;
int RENDER_BEGIN_FILLED_GOURAUD_TRIANGLE_STRIP         = 40;
int RENDER_BEGIN_TEXTURED_TRIANGLES                    = 41;
int RENDER_BEGIN_TEXTURED_TRIANGLES_ALPHA              = 42;
int RENDER_BEGIN_TEXTURED_TRIANGLE_FAN                 = 43;
int RENDER_BEGIN_TEXTURED_TRIANGLE_FAN_ALPHA           = 44;
int RENDER_BEGIN_TEXTURED_TRIANGLE_STRIP               = 45;
int RENDER_BEGIN_TEXTURED_TRIANGLE_STRIP_ALPHA         = 46;
int RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLES            = 47;
int RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLES_ALPHA      = 48;
int RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_FAN         = 49;
int RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_FAN_ALPHA   = 50;
int RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_STRIP       = 51;
int RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_STRIP_ALPHA = 52;
int RENDER_TEXT_1                                      = 53;
int RENDER_TEXT_2_CLIP                                 = 54;
int RENDER_TEXT_3_SWIRL                                = 55;
int RENDER_TEXT_4_UL                                   = 56;
int RENDER_TEXT_5_UL_CLIP                              = 57;
int RENDER_TEXT_6_ACCEL                                = 58;
int RENDER_TEXT_7_ACCEL_CLIP                           = 59;
int NUM_RENDER_MODES                                   = 60;  // UP/DOWN

int render_mode = RENDER_RECT_FILL_AA;
// int render_mode = RENDER_ELLIPSE_FILL_AA;
// int render_mode = RENDER_ELLIPSE_FILL_STROKE_AA;
// int render_mode = RENDER_ELLIPSE_STROKE_AA;
// int render_mode = RENDER_ROUNDRECT_FILL_STROKE_AA;
// int render_mode = RENDER_ROUNDRECT_FILL_AA;
// int render_mode = RENDER_ROUNDRECT_STROKE_AA;
// int render_mode = RENDER_TRIANGLES_TEX_UV_FLAT;
// int render_mode = RENDER_TRIANGLES_TEX_UV_GOURAUD_DECAL;
// int render_mode = RENDER_LINE_STRIP_FLAT_1;
// int render_mode = RENDER_LINE_STRIP_FLAT_AA_2;
// int render_mode = RENDER_CUSTOM_SHADER_1;
// int render_mode = RENDER_CUSTOM_SHADER_2;
// int render_mode = RENDER_CUSTOM_SHADER_3_VBO;
// int render_mode = RENDER_LINES;
// int render_mode = RENDER_BEGIN_LINE_STRIP;
// int render_mode = RENDER_BEGIN_LINES_AA;
// int render_mode = RENDER_BEGIN_POINTS_SQUARE_AA;
// int render_mode = RENDER_BEGIN_POINTS_ROUND_AA;
// int render_mode = RENDER_BEGIN_FILLED_TRIANGLES;
// int render_mode = RENDER_BEGIN_FILLED_TRIANGLE_FAN;
// int render_mode = RENDER_BEGIN_FILLED_TRIANGLE_STRIP;
// int render_mode = RENDER_BEGIN_FILLED_GOURAUD_TRIANGLES;
// int render_mode = RENDER_BEGIN_FILLED_GOURAUD_TRIANGLE_FAN;
// int render_mode = RENDER_BEGIN_FILLED_GOURAUD_TRIANGLE_STRIP;
// int render_mode = RENDER_BEGIN_TEXTURED_TRIANGLES;
// int render_mode = RENDER_BEGIN_TEXTURED_TRIANGLES_ALPHA;
// int render_mode = RENDER_BEGIN_TEXTURED_TRIANGLE_FAN;
// int render_mode = RENDER_BEGIN_TEXTURED_TRIANGLE_STRIP;
// int render_mode = RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLES;
// int render_mode = RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_FAN;
// int render_mode = RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_STRIP;

StringArray mode_names = [/*  0 */ "rect_fill_aa",
                          /*  1 */ "rect_fill_stroke_aa",
                          /*  2 */ "rect_stroke_aa",
                          /*  3 */ "ellipse_fill_aa",
                          /*  4 */ "ellipse_fill_stroke_aa",
                          /*  5 */ "ellipse_stroke_aa",
                          /*  6 */ "roundrect_fill_aa",
                          /*  7 */ "roundrect_fill_stroke_aa",
                          /*  8 */ "roundrect_stroke_aa",
                          /*  9 */ "triangles_tex_uv_flat",
                          /* 10 */ "triangles_tex_uv_gouraud",
                          /* 11 */ "triangles_tex_uv_flat_decal",
                          /* 12 */ "triangles_tex_uv_gouraud_decal",
                          /* 13 */ "line_strip_flat_1",
                          /* 14 */ "line_strip_flat_2",
                          /* 15 */ "line_strip_flat_aa_1",
                          /* 16 */ "line_strip_flat_aa_2",
                          /* 17 */ "line_strip_flat_bevel",
                          /* 18 */ "line_strip_flat_bevel_aa",
                          /* 19 */ "custom_shader_1",
                          /* 20 */ "custom_shader_2",
                          /* 21 */ "custom_shader_3(vbo)",
                          /* 22 */ "lines",
                          /* 23 */ "lines_aa",
                          /* 24 */ "begin_line_strip",
                          /* 25 */ "begin_line_strip_aa",
                          /* 26 */ "begin_line_strip_bevel",
                          /* 27 */ "begin_line_strip_bevel_aa",
                          /* 28 */ "begin_lines",
                          /* 29 */ "begin_lines_aa",
                          /* 30 */ "draw_filled_rectangle",
                          /* 31 */ "begin_points_square",
                          /* 32 */ "begin_points_square_aa",
                          /* 33 */ "begin_points_round",
                          /* 34 */ "begin_points_round_aa",
                          /* 35 */ "begin_filled_triangles",
                          /* 36 */ "begin_filled_triangle_fan",
                          /* 37 */ "begin_filled_triangle_strip",
                          /* 38 */ "begin_filled_gouraud_triangles",
                          /* 39 */ "begin_filled_gouraud_triangle_fan",
                          /* 40 */ "begin_filled_gouraud_triangle_strip",
                          /* 41 */ "begin_textured_triangles",
                          /* 42 */ "begin_textured_triangles_alpha",
                          /* 43 */ "begin_textured_triangle_fan",
                          /* 44 */ "begin_textured_triangle_fan_alpha",
                          /* 45 */ "begin_textured_triangle_strip",
                          /* 46 */ "begin_textured_triangle_strip_alpha",
                          /* 47 */ "begin_textured_gouraud_triangles",
                          /* 48 */ "begin_textured_gouraud_triangles_alpha",
                          /* 49 */ "begin_textured_gouraud_triangle_fan",
                          /* 50 */ "begin_textured_gouraud_triangle_fan_alpha",
                          /* 51 */ "begin_textured_gouraud_triangle_strip",
                          /* 52 */ "begin_textured_gouraud_triangle_strip_alpha",
                          /* 53 */ "text_1",
                          /* 54 */ "text_2_clip",
                          /* 55 */ "text_3_swirl",
                          /* 56 */ "text_4_ul",
                          /* 57 */ "text_5_ul_clip",
                          /* 58 */ "text_6_accel",
                          /* 59 */ "text_7_accel_clip",
                          ];

int tex_id;
Texture tex_data;

int tex_alpha_id;
Texture tex_alpha_data;

Texture       font_tex;
Buffer        font_bin;
ShaderVG_Font font;

Buffer buf_vbo; buf_vbo.size = 16384;
int    buf_vbo_id;

boolean b_queued_screenshot;


// ---------------------------------------------------------------------------- SaveScreenShotPNG
function SaveScreenShotPNG(String _pathName) {
   boolean ret = false;
   if(_pathName >= ".png")
   {
      // (note) must be called in onDraw()
      local Texture tex;
      if(tex.alloc(Viewport.width, Viewport.height, 4))
      {
         glReadBuffer(GL_BACK);
         int off = 0;
         int y = Viewport.height - 1;
         loop(Viewport.height)
         {
            zglReadColorPixelsX(tex, off, 0/*x*/, y, Viewport.width);
            y--;
            off += Viewport.width;
         }
         tex.clearAlpha(255);
         ret = tex.saveImage(_pathName);
      }
   }
   return ret;
}

// ---------------------------------------------------------------------------- TestLineStripFlat_1
function TestLineStripFlat_1(boolean _bAA) {
   buf_vbo.offset = 0;
   sdvg_BufferAddLinePointFlat14_2(buf_vbo, 100.0, 360.0);
   sdvg_BufferAddLinePointFlat14_2(buf_vbo, 540.0, 120.0);
   sdvg_UpdateVBO(buf_vbo_id, 0, buf_vbo.offset, buf_vbo);
   if(_bAA)
      sdvg_DrawLineStripFlatAAVBO14_2(buf_vbo_id, 0/*offset*/, 2/*numPoints*/);
   else
      sdvg_DrawLineStripFlatVBO14_2(buf_vbo_id, 0/*offset*/, 2/*numPoints*/);
   // trace "xxx TestLineStripFlat"+(_bAA?"EdgeAA":"")+"_1: buf_vbo.offset="+buf_vbo.offset;
}

// ---------------------------------------------------------------------------- TestLineStripFlat_2
function TestLineStripFlat_2(boolean _bAA) {
   int numSeg = 64;
   int numPoints = numSeg + 1;
   float w = (2PI / numSeg);
   float a = ang_x;
   float x = 100.0;
   float xStep = 440.0 / numSeg;
   buf_vbo.offset = 0;
   loop(numPoints)
   {
      float y = sin(a) * 120.0 + 240.0;
      sdvg_BufferAddLinePointFlat14_2(buf_vbo, x, y);
      a += w;
      x += xStep;
   }
   sdvg_UpdateVBO(buf_vbo_id, 0, buf_vbo.offset, buf_vbo);
   if(_bAA)
      sdvg_DrawLineStripFlatAAVBO14_2(buf_vbo_id, 0, numPoints);
   else
      sdvg_DrawLineStripFlatVBO14_2(buf_vbo_id, 0, numPoints);
   // trace "xxx TestLineStripFlat_2: buf_vbo.offset="+buf_vbo.offset;
}

// ---------------------------------------------------------------------------- TestLineStripFlatBevel
function TestLineStripFlatBevel(boolean _bAA) {
   int numSeg = 64;
   int numPoints = numSeg + 1;
   float w = (2PI / numSeg);
   float a = ang_x;
   float x = 100.0;
   float xStep = 440.0 / numSeg;
   buf_vbo.offset = 0;
   loop(numPoints)
   {
      float y = sin(a) * 120.0 + 240.0;
      sdvg_BufferAddLinePointFlatBevel14_2(buf_vbo, x, y);
      a += w;
      x += xStep;
   }
   sdvg_UpdateVBO(buf_vbo_id, 0, buf_vbo.offset, buf_vbo);
   if(_bAA)
      sdvg_DrawLineStripFlatBevelAAVBO14_2(buf_vbo_id, 0, numPoints);
   else
      sdvg_DrawLineStripFlatBevelVBO14_2(buf_vbo_id, 0, numPoints);
}

// ---------------------------------------------------------------------------- TestCustomShader_1
int custom_shader_idx_1;
function TestCustomShader_1(float sizeX, float sizeY) {
   if(0 == custom_shader_idx_1)
   {
      String vs =
         "uniform mat4 u_transform; \n"
         " \n"
         "ATTRIBUTE vec2 a_vertex; \n"
         " \n"
         "void main(void) { \n"
         "  gl_Position = u_transform * vec4(a_vertex,0,1); \n"
         "} \n"
         ;
      String fs =
         "uniform vec4 u_color_fill; \n"
         " \n"
         "void main(void) { \n"
         "   FRAGCOLOR = u_color_fill; \n"
         "} \n"
         ;
      custom_shader_idx_1 = sdvg_CreateShader(vs, fs);
   }
   if(custom_shader_idx_1 >= 0)
   {
      sdvg_BindShader(custom_shader_idx_1);
      sdvg_SetFillColorARGB(#ff7fafcf);
      sdvg_SetFillAlpha( (sin(ang_w) * 0.5 + 0.5) );

      if(sdvg_BeginTriangles(6, 2*4))
      {
         float x = sin(ang_x*0.5) * 170 + 320 - sizeX*0.5;
         float y = sin(ang_y*0.5) * 170 + 240 - sizeY*0.5;

         sdvg_VertexOffset2f();

         // tri 1
         sdvg_Vertex2f(x,       y);
         sdvg_Vertex2f(x+sizeX, y);
         sdvg_Vertex2f(x+sizeX, y+sizeY);

         // tri 2
         sdvg_Vertex2f(x,       y      );
         sdvg_Vertex2f(x+sizeX, y+sizeY);
         sdvg_Vertex2f(x,       y+sizeY);

         sdvg_End();
      }
   }
}

// ---------------------------------------------------------------------------- TestCustomShader_2
int custom_shader_idx_2;
function TestCustomShader_2(float sizeX, float sizeY) {
   if(0 == custom_shader_idx_2)
   {
      String vs =
         "uniform mat4 u_transform; \n"
         " \n"
         "ATTRIBUTE vec2 a_vertex; \n"
         "ATTRIBUTE vec4 a_color; \n"
         " \n"
         "VARYING_OUT vec4 v_color; \n"
         " \n"
         "void main(void) { \n"
         "  gl_Position = u_transform * vec4(a_vertex,0,1); \n"
         "  v_color = a_color; \n"
         "} \n"
         ;
      String fs =
         "uniform float u_global_alpha; \n"
         " \n"
         "VARYING_IN vec4 v_color; \n"
         " \n"
         "void main(void) { \n"
         "   FRAGCOLOR = vec4(v_color.rgb, v_color.a * u_global_alpha); \n"
         "} \n"
         ;
      custom_shader_idx_2 = sdvg_CreateShader(vs, fs);
   }
   if(custom_shader_idx_2 >= 0)
   {
      sdvg_BindShader(custom_shader_idx_2);
      sdvg_SetGlobalAlpha( (sin(ang_w) * 0.5 + 0.5) * fill_alpha );

      if(sdvg_BeginTriangleFan(4, 4*1 + 2*4))
      {
         float x = sin(ang_x*0.5) * 170 + 320 - sizeX*0.5;
         float y = sin(ang_y*0.5) * 170 + 240 - sizeY*0.5;

         sdvg_AttribOffsetARGB("a_color");
         sdvg_VertexOffset2f();

         sdvg_ColorARGB(#ffff0000);
         sdvg_Vertex2f(x, y);

         sdvg_ColorARGB(#ffffFF00);
         sdvg_Vertex2f(x+sizeX, y);

         sdvg_ColorARGB(#ff00FFFF);
         sdvg_Vertex2f(x+sizeX, y+sizeY);

         sdvg_ColorARGB(#ff5FaFFF);
         sdvg_Vertex2f(x, y+sizeY);

         sdvg_End();
      }
   }
}

// ---------------------------------------------------------------------------- TestCustomShader_3_VBO
int custom_shader_idx_3;
int custom_vbo_id_3 = 0;
function TestCustomShader_3_VBO(Matrix4f mProj, float sizeX, float sizeY) {
   if(0 == custom_shader_idx_3)
   {
      String vs =
         "uniform mat4 u_transform; \n"
         " \n"
         "ATTRIBUTE vec2 a_vertex; \n"
         "ATTRIBUTE vec4 a_color; \n"
         " \n"
         "VARYING_OUT vec4 v_color; \n"
         " \n"
         "void main(void) { \n"
         "  gl_Position = u_transform * vec4(a_vertex,0,1); \n"
         "  v_color = a_color; \n"
         "} \n"
         ;
      String fs =
         "uniform float u_global_alpha; \n"
         " \n"
         "VARYING_IN vec4 v_color; \n"
         " \n"
         "void main(void) { \n"
         "   FRAGCOLOR = vec4(v_color.rgb, v_color.a * u_global_alpha); \n"
         "} \n"
         ;
      custom_shader_idx_3 = sdvg_CreateShader(vs, fs);

      // Create + initialize VBO
      custom_vbo_id_3 = sdvg_CreateVBO(256);
      sdvg_MapVBO(custom_vbo_id_3);
      if(sdvg_BeginVBO(4, 4*1 + 2*4))
      {
         sdvg_AttribOffsetARGB("a_color");  // ignored
         sdvg_VertexOffset2f();             // ignored

         sdvg_ColorARGB(#ffff0000);
         sdvg_Vertex2f(0, 0);

         sdvg_ColorARGB(#ffffFF00);
         sdvg_Vertex2f(1, 0);

         sdvg_ColorARGB(#ff00FFFF);
         sdvg_Vertex2f(1, 1);

         sdvg_ColorARGB(#ff5FaFFF);
         sdvg_Vertex2f(0, 1);

         sdvg_End();
      }
      trace "[dbg] TestCustomShader_3_VBO: sdvg_GetMappedVBOOffset()="+sdvg_GetMappedVBOOffset();  // => 48
      sdvg_UnmapVBO();
      trace "[dbg] TestCustomShader_3_VBO: sdvg_GetVBOSize()="+sdvg_GetVBOSize();  // => 256
   }
   if(custom_shader_idx_3 >= 0)
   {
      sdvg_BindShader(custom_shader_idx_3);
      sdvg_SetGlobalAlpha( (sin(ang_w) * 0.5 + 0.5) * fill_alpha );

      float x = sin(ang_x*0.5) * 170 + 320 - sizeX*0.5;
      float y = sin(ang_y*0.5) * 170 + 240 - sizeY*0.5;

      Matrix4f mModel;
      mModel.initIdentity();
      mModel.translatef(x, y, 0.0);
      mModel.scalef(sizeX, sizeY, 1.0);

      Matrix4f mvp;
      mProj.mul(mModel) => mvp;
      sdvg_SetTransform(mvp);

      // Draw pre-initialized VBO
      sdvg_BindVBO(custom_vbo_id_3);
      if(sdvg_BeginTriangleFan(4, 4*1 + 2*4))
      {
         sdvg_AttribOffsetARGB("a_color");
         sdvg_VertexOffset2f();

         sdvg_End();
      }
      sdvg_BindVBO(0);
   }
}

// ---------------------------------------------------------------------------- TestLinesFlat
function TestLinesFlat(boolean _bAA) {
   int numSeg = 64;
   int numPoints = numSeg * 2;
   float w = (2PI / numSeg);
   float a = ang_x * 0.5;
   buf_vbo.offset = 0;
   loop(numPoints / 2)
   {
      float x1 = sin(a) * 200.0 + (VP_W/2);
      float y1 = cos(a) * 200.0 + (VP_H/2);
      float x2 = sin(a) * 120.0 + (VP_W/2);
      float y2 = cos(a) * 120.0 + (VP_H/2);
      sdvg_BufferAddLinesPointsFlat14_2(buf_vbo, x1, y1, x2, y2);
      a += w;
   }
   sdvg_UpdateVBO(buf_vbo_id, 0, buf_vbo.offset, buf_vbo);
   if(_bAA)
      sdvg_DrawLinesFlatAAVBO14_2(buf_vbo_id, 0, numPoints);
   else
      sdvg_DrawLinesFlatVBO14_2(buf_vbo_id, 0, numPoints);
   // trace "xxx TestLinesFlatAA: buf_vbo.offset="+buf_vbo.offset;
}

// ---------------------------------------------------------------------------- TestBeginLineStripFlat
function TestBeginLineStripFlat(boolean _bAA) {
   int numSeg = 64;
   int numPoints = numSeg + 1;
   float w = (2PI / numSeg);
   float a = ang_x;
   float x = 100.0;
   float xStep = 440.0 / numSeg;
   if(_bAA
      ? sdvg_BeginLineStripAA(numPoints)
      : sdvg_BeginLineStrip(numPoints)
      )
   {
      loop(numPoints)
      {
         float y = sin(a) * 120.0 + 240.0;
         sdvg_Vertex2f(x, y);
         a += w;
         x += xStep;
      }
      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginLineStripFlatBevel
function TestBeginLineStripFlatBevel(boolean _bAA) {
   int numSeg = 64;
   int numPoints = numSeg + 1;
   float w = (2PI / numSeg);
   float a = ang_x;
   float x = 100.0;
   float xStep = 440.0 / numSeg;
   if(_bAA
      ? sdvg_BeginLineStripBevelAA(numPoints)
      : sdvg_BeginLineStripBevel(numPoints)
      )
   {
      loop(numPoints)
      {
         float y = sin(a) * 120.0 + 240.0;
         sdvg_Vertex2f(x, y);
         a += w;
         x += xStep;
      }
      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginLinesFlat
function TestBeginLinesFlat(boolean _bAA) {
   sdvg_SetStrokeWidth(stroke_w * 0.25);
   int numSeg = 96;
   int numPoints = numSeg * 2;
   float w = (2PI / numSeg);
   float a = ang_x * 0.5;
   int t = milliSeconds();
   float x1, y1;
   float x2, y2;
   if(1)
   {
      int maxPoints = 4096;
      int pointIdx = 0;
      if(_bAA
         ? sdvg_BeginLinesAA(maxPoints)
         : sdvg_BeginLines(maxPoints)
         )
      {
         loop(numPoints / 2)
         {
            if(pointIdx == maxPoints)
            {
               sdvg_End();

               if(_bAA)
                  sdvg_BeginLinesAA(maxPoints);
               else
                  sdvg_BeginLines(maxPoints);
               pointIdx = 0;
            }

            x1 = sin(a) * 200.0 + (VP_W/2);
            y1 = cos(a) * 200.0 + (VP_H/2);
            sdvg_Vertex2f(x1, y1);

            x2 = sin(a) * 120.0 + (VP_W/2);
            y2 = cos(a) * 120.0 + (VP_H/2);
            sdvg_Vertex2f(x2, y2);

            a += w;
            pointIdx += 2;
         }
         // trace "xxx t="+(milliSeconds()-t);
         sdvg_End();
      }
   }
   else
   {
      if(_bAA
         ? sdvg_BeginLinesAA(numPoints)
         : sdvg_BeginLines(numPoints)
         )
      {
         loop(numPoints / 2)
         {
            x1 = sin(a) * 200.0 + (VP_W/2);
            y1 = cos(a) * 200.0 + (VP_H/2);
            sdvg_Vertex2f(x1, y1);

            x2 = sin(a) * 120.0 + (VP_W/2);
            y2 = cos(a) * 120.0 + (VP_H/2);
            sdvg_Vertex2f(x2, y2);

            a += w;
         }
         // trace "xxx t="+(milliSeconds()-t);
         sdvg_End();
      }
   }
}

// ---------------------------------------------------------------------------- TestBeginPointsSquare
function TestBeginPointsSquare(boolean _bAA) {
   sdvg_SetPointRadius(stroke_w * 2.0);
   int numPoints = 32;
   float w = (2PI / numPoints);
   float a = ang_x * 0.5;
   if(_bAA
      ? sdvg_BeginPointsSquareAA(numPoints)
      : sdvg_BeginPointsSquare(numPoints)
      )
   {
      loop(numPoints)
      {
         float x = sin(a) * 200.0 + (VP_W/2);
         float y = cos(a) * 200.0 + (VP_H/2);
         sdvg_Vertex2f(x, y);

         a += w;
      }
      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginPointsRound
function TestBeginPointsRound(boolean _bAA) {
   sdvg_SetPointRadius(stroke_w * 2.0);
   int numPoints = 32;
   float w = (2PI / numPoints);
   float a = ang_x * 0.5;
   if(_bAA
      ? sdvg_BeginPointsRoundAA(numPoints)
      : sdvg_BeginPointsRound(numPoints)
      )
   {
      loop(numPoints)
      {
         float x = sin(a) * 200.0 + (VP_W/2);
         float y = cos(a) * 200.0 + (VP_H/2);
         sdvg_Vertex2f(x, y);

         a += w;
      }
      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginFilledTriangles
function TestBeginFilledTriangles() {
   sdvg_SetFillColor4f(1.0f, 0.5f, 0.5f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(sdvg_BeginFilledTriangles(2*3))
   {
      // 1
      sdvg_Vertex2f(x, y);
      sdvg_Vertex2f(x+w, y);
      sdvg_Vertex2f(x+w, y+h);

      // 2
      sdvg_Vertex2f(x, y);
      sdvg_Vertex2f(x+w, y+h);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginFilledTriangleFan
function TestBeginFilledTriangleFan() {
   sdvg_SetFillColor4f(0.5f, 0.5f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(sdvg_BeginFilledTriangleFan(4))
   {
      sdvg_Vertex2f(x, y);
      sdvg_Vertex2f(x+w, y);
      sdvg_Vertex2f(x+w, y+h);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginFilledTriangleStrip
function TestBeginFilledTriangleStrip() {
   sdvg_SetFillColor4f(0.5f, 1.0f, 0.5f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(sdvg_BeginFilledTriangleStrip(4))
   {
      sdvg_Vertex2f(x+w, y);
      sdvg_Vertex2f(x+w, y+h);
      sdvg_Vertex2f(x,   y);
      sdvg_Vertex2f(x,   y+h);  // caution: CCW

      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginFilledGouraudTriangles
function TestBeginFilledGouraudTriangles() {
   sdvg_SetFillColor4f(1.0f, 0.5f, 0.5f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(sdvg_BeginFilledGouraudTriangles(2*3))
   {
      // 1
      sdvg_ColorARGB(#ffff0000);
      sdvg_Vertex2f(x, y);

      sdvg_ColorARGB(#ffffFF00);
      sdvg_Vertex2f(x+w, y);

      sdvg_ColorARGB(#ff00FFFF);
      sdvg_Vertex2f(x+w, y+h);

      // 2
      sdvg_ColorARGB(#ffff0000);
      sdvg_Vertex2f(x, y);

      sdvg_ColorARGB(#ff00FFFF);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_ColorARGB(#ff5FaFFF);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginFilledGouraudTriangleFan
function TestBeginFilledGouraudTriangleFan() {
   sdvg_SetFillColor4f(0.5f, 0.5f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(sdvg_BeginFilledGouraudTriangleFan(4))
   {
      sdvg_ColorARGB(#ffff0000);
      sdvg_Vertex2f(x, y);

      sdvg_ColorARGB(#ffffFF00);
      sdvg_Vertex2f(x+w, y);

      sdvg_ColorARGB(#ff00FFFF);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_ColorARGB(#ff5FaFFF);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginFilledGouraudTriangleStrip
function TestBeginFilledGouraudTriangleStrip() {
   sdvg_SetFillColor4f(0.5f, 1.0f, 0.5f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(sdvg_BeginFilledGouraudTriangleStrip(4))
   {
      sdvg_ColorARGB(#ffffFF00);
      sdvg_Vertex2f(x+w, y);

      sdvg_ColorARGB(#ff00FFFF);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_ColorARGB(#ffff0000);
      sdvg_Vertex2f(x, y);

      sdvg_ColorARGB(#ff5FaFFF);
      sdvg_Vertex2f(x, y+h);  // caution: CCW

      sdvg_End();
   }
}

// ---------------------------------------------------------------------------- TestBeginTexturedTriangles
function TestBeginTexturedTriangles(boolean _bAlpha) {
   sdvg_BindTexture2D(_bAlpha ? tex_alpha_id : tex_id, false/*bRepeat*/, true/*bFilter*/);
   sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(_bAlpha
      ? sdvg_BeginTexturedTrianglesAlpha(2*3)
      : sdvg_BeginTexturedTriangles(2*3)
      )
   {
      // 1
      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(1.0f, 0.0f);
      sdvg_Vertex2f(x+w, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_Vertex2f(x+w, y+h);

      // 2
      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_TexCoord2f(0.0f, 1.0f);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
   sdvg_UnbindTexture2D();
}

// ---------------------------------------------------------------------------- TestBeginTexturedTriangleFan
function TestBeginTexturedTriangleFan(boolean _bAlpha) {
   sdvg_BindTexture2D(_bAlpha ? tex_alpha_id : tex_id, false/*bRepeat*/, true/*bFilter*/);
   sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(_bAlpha
      ? sdvg_BeginTexturedTriangleFanAlpha(4)
      : sdvg_BeginTexturedTriangleFan(4)
      )
   {
      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(1.0f, 0.0f);
      sdvg_Vertex2f(x+w, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_TexCoord2f(0.0f, 1.0f);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
   sdvg_UnbindTexture2D();
}

// ---------------------------------------------------------------------------- TestBeginTexturedTriangleStrip
function TestBeginTexturedTriangleStrip(boolean _bAlpha) {
   sdvg_BindTexture2D(_bAlpha ? tex_alpha_id : tex_id, false/*bRepeat*/, true/*bFilter*/);
   sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(_bAlpha
      ? sdvg_BeginTexturedTriangleStripAlpha(4)
      : sdvg_BeginTexturedTriangleStrip(4)
      )
   {
      sdvg_TexCoord2f(1.0f, 0.0f);
      sdvg_Vertex2f(x+w, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(0.0f, 1.0f);
      sdvg_Vertex2f(x, y+h);  // caution: CCW

      sdvg_End();
   }
   sdvg_UnbindTexture2D();
}

// ---------------------------------------------------------------------------- TestBeginTexturedGouraudTriangles
function TestBeginTexturedGouraudTriangles(boolean _bAlpha) {
   sdvg_BindTexture2D(_bAlpha ? tex_alpha_id : tex_id, false/*bRepeat*/, true/*bFilter*/);
   sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(_bAlpha
      ? sdvg_BeginTexturedGouraudTrianglesAlpha(2*3)
      : sdvg_BeginTexturedGouraudTriangles(2*3)
      )
   {
      // 1
      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_ColorARGB(#FFFF4040);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(1.0f, 0.0f);
      sdvg_ColorARGB(#FFFFFF40);
      sdvg_Vertex2f(x+w, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_ColorARGB(#FF4040FF);
      sdvg_Vertex2f(x+w, y+h);

      // 2
      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_ColorARGB(#FFFF4040);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_ColorARGB(#FF4040FF);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_TexCoord2f(0.0f, 1.0f);
      sdvg_ColorARGB(#FF40FFFF);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
   sdvg_UnbindTexture2D();
}

// ---------------------------------------------------------------------------- TestBeginTexturedGouraudTriangleFan
function TestBeginTexturedGouraudTriangleFan(boolean _bAlpha) {
   sdvg_BindTexture2D(_bAlpha ? tex_alpha_id : tex_id, false/*bRepeat*/, true/*bFilter*/);
   sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(_bAlpha
      ? sdvg_BeginTexturedGouraudTriangleFanAlpha(4)
      : sdvg_BeginTexturedGouraudTriangleFan(4)
      )
   {
      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_ColorARGB(#FFFF4040);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(1.0f, 0.0f);
      sdvg_ColorARGB(#FFFFFF40);
      sdvg_Vertex2f(x+w, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_ColorARGB(#FF4040FF);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_TexCoord2f(0.0f, 1.0f);
      sdvg_ColorARGB(#FF40FFFF);
      sdvg_Vertex2f(x, y+h);

      sdvg_End();
   }
   sdvg_UnbindTexture2D();
}

// ---------------------------------------------------------------------------- TestBeginTexturedGouraudTriangleStrip
function TestBeginTexturedGouraudTriangleStrip(boolean _bAlpha) {
   sdvg_BindTexture2D(_bAlpha ? tex_alpha_id : tex_id, false/*bRepeat*/, true/*bFilter*/);
   sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
   float a = ang_x * 0.5;
   float w = 240;
   float h = 180;
   float x = sin(a) * 200.0 + (VP_W/2) - w*0.5;
   float y = cos(a) * 200.0 + (VP_H/2) - h*0.5;
   sdvg_BindShader(0);  // use built-in shader
   if(_bAlpha
      ? sdvg_BeginTexturedGouraudTriangleStripAlpha(4)
      : sdvg_BeginTexturedGouraudTriangleStrip(4)
      )
   {
      sdvg_TexCoord2f(1.0f, 0.0f);
      sdvg_ColorARGB(#FFFFFF40);
      sdvg_Vertex2f(x+w, y);

      sdvg_TexCoord2f(1.0f, 1.0f);
      sdvg_ColorARGB(#FF4040FF);
      sdvg_Vertex2f(x+w, y+h);

      sdvg_TexCoord2f(0.0f, 0.0f);
      sdvg_ColorARGB(#FFFF4040);
      sdvg_Vertex2f(x, y);

      sdvg_TexCoord2f(0.0f, 1.0f);
      sdvg_ColorARGB(#FF40FFFF);
      sdvg_Vertex2f(x, y+h);  // caution: CCW

      sdvg_End();
   }
   sdvg_UnbindTexture2D();
}

// ---------------------------------------------------------------------------- TestText_1
function TestText_1() {
   sdvg_BindFont(font, false/*bFilter*/);
   sdvg_EnableBlending();
   sdvg_SetColorARGB(#ffffffff);

   String s <= "hello, world.\nmulti\nline\ntext.";

   Integer minX, maxX, minY, maxY;
   sdvg_TextBBox(font, s, minX, maxX, minY, maxY);
   int w = (maxX - minX);
   int h = (maxY - minY);
   // trace "xxx min=("+minX+","+minY+") max=("+maxX+","+maxY+")";

   float x = sin(ang_x*0.5) * (640-w)*0.5 + 320 - w*0.5;
   float y = sin(ang_y*0.5) * (480-h)*0.5 + 240 - h*0.5;

   // trace "xxx TestText_1: p=("+x+";"+y+") s=("+w+","+h+") minX="+minX+" minY="+minY;

   sdvg_DrawText(s, x - minX, y - minY);

   sdvg_UnbindFont();
}

// ---------------------------------------------------------------------------- TestText_2_Clip
function TestText_2_Clip() {
   sdvg_BindFont(font, false/*bFilter*/);
   sdvg_EnableBlending();
   sdvg_SetColorARGB(#ffffffff);

   String s <= "############\ntext*text*text*text\nclip*clip*clip*clip*\ntest*test*test*test.\n############";

   Integer minX, maxX, minY, maxY;
   sdvg_TextBBox(font, s, minX, maxX, minY, maxY);
   int w = (maxX - minX);
   int h = (maxY - minY);
   // trace "xxx min=("+minX+","+minY+") max=("+maxX+","+maxY+")";

   float x = sin(ang_x*0.5) * (640-w)*0.5 + 320 - w*0.5 - minX;
   float y = sin(ang_y*0.5) * (480-h)*0.5 + 240 - h*0.5 - minY;
   w += minX;
   h += minY;

   float clipW = sin(ang_w*8) * w*0.5 + w*0.5;
   float clipH = sin(ang_h*8) * h*0.5 + h*0.5;

   float clipLeft  = x + w*0.5 - clipW*0.5;
   float clipRight = clipLeft + clipW;

   float clipTop    = y + h*0.5 - clipH*0.5;
   float clipBottom = clipTop + clipH;

   // clipLeft = x;
   // clipTop = y;
   // clipRight = x + clipW;
   // clipBottom = y + clipH;

   // trace "xxx p=("+x+";"+y+") s=("+w+";"+h+") clipLeft="+clipLeft+" clipTop="+clipTop+" clipRight="+clipRight+" clipBottom="+clipBottom+" clipS=("+clipW+";"+clipH+")";

   // trace "xxx TestText_2_Clip: p=("+x+";"+y+") s=("+w+","+h+") minX="+minX+" minY="+minY;

   sdvg_DrawTextClipped(s, x, y, clipLeft, clipTop, clipRight, clipBottom);

   sdvg_UnbindFont();
}

// ---------------------------------------------------------------------------- TestText_3_Swirl
int test_text_3_shader_idx;
function TestText_3_draw(String _s, float _scl, float _ang, float _deltaC, byte _a, float _hue) {
   String sFloor = _s;
   String sCeil = _s;
   int i = 0;
   float deltaCF = 0;
   if(_deltaC >= 0.5f)
      deltaCF = (_deltaC-0.5f) * 2.0f * 26.0f;
   else if(_deltaC <= -0.5f)
      deltaCF = -(_deltaC+0.5f) * 2.0f * -26.0f;
   float deltaCFrac = frac(deltaCF);
   if(deltaCFrac < 0.0f)
      deltaCFrac += 1.0f;
   int deltaCFloor = floor(deltaCF);
   int deltaCCeil = ceil(deltaCF);
   loop(_s.numChars)
   {
      if(' ' != _s.getc(i))
      {
         char c = sFloor[i] + deltaCFloor;
         if(c < 33)
            c = (c - 33) + 'z';
         else if(c > 'z')
            c = (c - 'z') + 33;
         sFloor[i] = c;

         c = sCeil[i] + deltaCCeil;
         if(c < 33)
            c = (c - 33) + 'z';
         else if(c > 'z')
            c = (c - 'z') + 33;
         sCeil[i] = c;
      }
      i++;
   }

   sdvg_Uniform2f("u_scale", _scl, _scl);
   sdvg_Uniform1f("u_ang", _ang);
   byte a;

   if(_hue < 0.0f)
      _hue += 360.0f;
   int c24 = sdvg_HSVAToARGB(_hue, 0.3/*s*/, 1.0/*v*/, 0/*a*/);

   deltaCFrac = deltaCFrac + ((deltaCFrac * deltaCFrac * (3.0f - 2.0f * deltaCFrac))-deltaCFrac) * 0.5f;

   // if(255 == _a) trace "xxx deltaCFloor="+deltaCFloor+" deltaCCeil="+deltaCCeil+" deltaCFrac="+deltaCFrac;
   a = _a * (1.0f - deltaCFrac);
   if(a > 0)
   {
      sdvg_Uniform1f("u_scale_to_ang", 2PI/sdvg_TextWidth(font, sFloor));
      sdvg_SetColorARGB( (a << 24) | c24 );
      sdvg_DrawText(sFloor, 0, 0);
   }

   a = _a * deltaCFrac;
   if(a > 0)
   {
      sdvg_Uniform1f("u_scale_to_ang", 2PI/sdvg_TextWidth(font, sCeil));
      sdvg_SetColorARGB( (a << 24) | c24 );
      sdvg_DrawText(sCeil, 0, 0);
   }
}
function TestText_3_Swirl() {
   if(0 == test_text_3_shader_idx)
   {
      String vs =
         "uniform mat4 u_transform; \n"
         "uniform float u_ang; \n"
         "uniform float u_scale_to_ang; \n"
         "uniform float u_scale_to_dist; \n"
         "uniform vec2  u_scale; \n"
         "uniform vec2 u_center; \n"
         " \n"
         "ATTRIBUTE vec2 a_vertex; \n"
         "ATTRIBUTE vec2 a_uv; \n"
         " \n"
         "VARYING_OUT vec2 v_uv; \n"
         " \n"
         "void main(void) { \n"
         "  float a = a_vertex.x * u_scale_to_ang; \n"
         "  vec2 n = vec2(sin(u_ang + a), cos(u_ang + a)); \n"
         "  vec2 v = vec2(n.x * u_scale.x, n.y * u_scale.y); \n"
         "  v += n * a_vertex.y * u_scale_to_dist; \n"
         "  v += u_center; \n"
         "  gl_Position = u_transform * vec4(v,0,1); \n"
         "  v_uv = a_uv; \n"
         "} \n"
         ;
      String fs =
         "uniform sampler2D u_sampler; \n"
         "uniform vec4      u_color_fill; \n"
         " \n"
         "VARYING_IN vec2 v_uv; \n"
         " \n"
         "void main(void) { \n"
         "  FRAGCOLOR = vec4(u_color_fill.rgb, TEXTURE2D(u_sampler, v_uv).TEX_ALPHA * u_color_fill.a); \n"
         "} \n"
         ;
      test_text_3_shader_idx = sdvg_CreateShader(vs, fs);
      if(0 == test_text_3_shader_idx)
         die "failed to created test_text_3_shader_idx";
   }
   if(test_text_3_shader_idx >= 0)
   {
      sdvg_BindFont(font, true/*bFilter*/);
      sdvg_EnableBlending();
      // sdvg_SetFillAlpha( (sin(ang_w) * 0.5 + 0.5) );

      sdvg_BindShader(test_text_3_shader_idx);
      sdvg_Uniform2f("u_center", 320.0f, 240.0f);
      sdvg_Uniform1f("u_scale_to_dist", 1.3f);

      String s <= "hello, world. round and round.";  // 26 glyphs =>  (26*2*7*2 = 728 triangles)

      float rotBaseA = ang_h * 2.0f;
      float rotStepA = 2PI / 16.0f;
      float rotA;

      float rotBaseB = ang_w * 4.0f;
      float rotStepB = 2PI / 24.0f;

      float rotBaseC = ang_c;
      float rotStepC = 2PI / 43.0f;

      float baseScale = 240.0f;
      float scaleStep = 40.0f;
      float scaleMod = 25.0f;

      float rotBaseHue = ang_x * (360.0f / 2PI);
      float hueStep = 360.0 / 5.0;

      rotA = sin(rotBaseA + rotStepA*0.0f) * PI;
      TestText_3_draw(s,
                      baseScale - scaleStep*0.0f + sin(rotBaseB + rotStepB*0.0f)*scaleMod+scaleMod,
                      rotA,
                      sin(rotBaseC + rotStepC*0.0f),
                      #ff,
                      rotBaseHue + sin(rotBaseB + rotStepB*0.0f)*hueStep
                      );

      rotA = sin(rotBaseA + rotStepA*1.0f) * PI;
      TestText_3_draw(s,
                      baseScale - scaleStep*1.0f + sin(rotBaseB + rotStepB*1.0f)*scaleMod+scaleMod,
                      rotA,
                      sin(rotBaseC + rotStepC*1.0f),
                      #af,
                      rotBaseHue + sin(rotBaseB + rotStepB*1.0f)*hueStep
                      );

      rotA = sin(rotBaseA + rotStepA*2.0f) * PI;
      TestText_3_draw(s,
                      baseScale - scaleStep*2.0f + sin(rotBaseB + rotStepB*2.0f)*scaleMod+scaleMod,
                      rotA,
                      sin(rotBaseC + rotStepC*2.0f),
                      #7f,
                      rotBaseHue + sin(rotBaseB + rotStepB*2.0f)*hueStep
                      );

      rotA = sin(rotBaseA + rotStepA*3.0f) * PI;
      TestText_3_draw(s,
                      baseScale - scaleStep*3.0f + sin(rotBaseB + rotStepB*3.0f)*scaleMod+scaleMod,
                      rotA,
                      sin(rotBaseC + rotStepC*3.0f),
                      #4f,
                      rotBaseHue + sin(rotBaseB + rotStepB*3.0f)*hueStep
                      );

      rotA = sin(rotBaseA + rotStepA*4.0f) * PI;
      TestText_3_draw(s,
                      baseScale - scaleStep*4.0f + sin(rotBaseB + rotStepB*4.0f)*scaleMod+scaleMod,
                      rotA,
                      sin(rotBaseC + rotStepC*4.0f),
                      #1f,
                      rotBaseHue + sin(rotBaseB + rotStepB*4.0f)*45.0f
                      );

      rotA = sin(rotBaseA + rotStepA*5.0f) * PI;
      TestText_3_draw(s,
                      baseScale - scaleStep*5.0f + sin(rotBaseB + rotStepB*4.0f)*scaleMod+scaleMod,
                      rotA,
                      sin(rotBaseC + rotStepC*5.0f),
                      #12,
                      rotBaseHue + sin(rotBaseB + rotStepB*5.0f)*45.0f
                      );

      rotA = sin(rotBaseA + rotStepA*6.0f) * PI;
      TestText_3_draw(s,
                      baseScale - scaleStep*6.0f + sin(rotBaseB + rotStepB*4.0f)*scaleMod+scaleMod,
                      rotA,
                      sin(rotBaseC + rotStepC*6.0f),
                      #a,
                      rotBaseHue + sin(rotBaseB + rotStepB*6.0f)*45.0f
                      );

      sdvg_UnbindFont();
      sdvg_UnbindShader();
   }
}

// ---------------------------------------------------------------------------- TestText_4_Ul
function TestText_4_Ul() {
   sdvg_BindFont(font, false/*bFilter*/);
   sdvg_EnableBlending();

   String s <= "hell\ao, wo\arld.\n\amulti\nlin\ae\nte\axt.";

   Integer minX, maxX, minY, maxY;
   sdvg_TextBBox(font, s, minX, maxX, minY, maxY);
   int w = (maxX - minX);
   int h = (maxY - minY);
   // trace "xxx min=("+minX+","+minY+") max=("+maxX+","+maxY+")";

   float x = sin(ang_x*0.5) * (640-w)*0.5 + 320 - w*0.5;
   float y = sin(ang_y*0.5) * (480-h)*0.5 + 240 - h*0.5;

   x -= minX;
   y -= minY;

   // trace "xxx TestText_4_Ul: p=("+x+";"+y+") s=("+w+","+h+") minX="+minX+" minY="+minY;

   sdvg_SetColorARGB(#3fffffff);
   sdvg_DrawTextUnderline(s, x, y);

   sdvg_SetColorARGB(#ffffffff);
   sdvg_DrawText(s, x, y);

   sdvg_UnbindFont();
}

// ---------------------------------------------------------------------------- TestText_5_Ul_Clip
function TestText_5_Ul_Clip() {
   sdvg_BindFont(font, false/*bFilter*/);
   sdvg_EnableBlending();

   String s <= "############\ntext*text*text*text\nclip*clip*clip*clip*\ntest*test*test*test.\n############";

   Integer minX, maxX, minY, maxY;
   sdvg_TextBBox(font, s, minX, maxX, minY, maxY);
   int w = (maxX - minX);
   int h = (maxY - minY);
   // trace "xxx min=("+minX+","+minY+") max=("+maxX+","+maxY+")";

   float x = sin(ang_x*0.5) * (640-w)*0.5 + 320 - w*0.5 - minX;
   float y = sin(ang_y*0.5) * (480-h)*0.5 + 240 - h*0.5 - minY;
   w += minX;
   h += minY;

   float clipW = sin(ang_w*8) * w*0.5 + w*0.5;
   float clipH = sin(ang_h*8) * h*0.5 + h*0.5;

   float clipLeft  = x + w*0.5 - clipW*0.5;
   float clipRight = clipLeft + clipW;

   float clipTop    = y + h*0.5 - clipH*0.5;
   float clipBottom = clipTop + clipH;

   sdvg_SetColorARGB(#3fffffff);
   sdvg_DrawTextUnderlineClipped(s, x, y, clipLeft, clipTop, clipRight, clipBottom);

   sdvg_SetColorARGB(#ffffffff);
   sdvg_DrawTextClipped(s, x, y, clipLeft, clipTop, clipRight, clipBottom);

   sdvg_UnbindFont();
}

// ---------------------------------------------------------------------------- TestText_6_Accel
function TestText_6_Accel() {
   sdvg_BindFont(font, false/*bFilter*/);
   sdvg_EnableBlending();

   String s <= "hell\ao, wo\arld.\n\amulti\nlin\ae\nte\axt.";

   Integer minX, maxX, minY, maxY;
   sdvg_TextBBox(font, s, minX, maxX, minY, maxY);
   int w = (maxX - minX);
   int h = (maxY - minY);
   // trace "xxx min=("+minX+","+minY+") max=("+maxX+","+maxY+")";

   float x = sin(ang_x*0.5) * (640-w)*0.5 + 320 - w*0.5;
   float y = sin(ang_y*0.5) * (480-h)*0.5 + 240 - h*0.5;

   x -= minX;
   y -= minY;

   // trace "xxx TestText_6_Accel: p=("+x+";"+y+") s=("+w+","+h+") minX="+minX+" minY="+minY;

   sdvg_SetColorARGB(#7fffffff);
   sdvg_DrawTextAccel(s, x, y);

   sdvg_SetColorARGB(#ffffffff);
   sdvg_DrawText(s, x, y);

   sdvg_UnbindFont();
}

// ---------------------------------------------------------------------------- TestText_7_Accel_Clip
function TestText_7_Accel_Clip() {
   sdvg_BindFont(font, false/*bFilter*/);
   sdvg_EnableBlending();

   String s <= "############\n\atext*t\aext*te\axt*tex\at\n\aclip*c\alip*cl\aip*cli\ap*\n\atest*t\aest*te\ast*tes\at.\n############";

   Integer minX, maxX, minY, maxY;
   sdvg_TextBBox(font, s, minX, maxX, minY, maxY);
   int w = (maxX - minX);
   int h = (maxY - minY);
   // trace "xxx min=("+minX+","+minY+") max=("+maxX+","+maxY+")";

   float x = sin(ang_x*0.5) * (640-w)*0.5 + 320 - w*0.5 - minX;
   float y = sin(ang_y*0.5) * (480-h)*0.5 + 240 - h*0.5 - minY;
   w += minX;
   h += minY;

   float clipW = sin(ang_w*8) * w*0.5 + w*0.5;
   float clipH = sin(ang_h*8) * h*0.5 + h*0.5;

   float clipLeft  = x + w*0.5 - clipW*0.5;
   float clipRight = clipLeft + clipW;

   float clipTop    = y + h*0.5 - clipH*0.5;
   float clipBottom = clipTop + clipH;

   sdvg_SetColorARGB(#7fffffff);
   sdvg_DrawTextAccelClipped(s, x, y, clipLeft, clipTop, clipRight, clipBottom);

   sdvg_SetColorARGB(#ffffffff);
   sdvg_DrawTextClipped(s, x, y, clipLeft, clipTop, clipRight, clipBottom);

   sdvg_UnbindFont();
}

// ---------------------------------------------------------------------------- onDraw
function onDraw() {

   float dt = FPS.precision;

   if( !(++num_frames_rendered&127) )
      trace "FPS.real="+FPS.real;

   float centerX;
   float centerY;
   float sizeX;
   float sizeY;
   float cornerX;
   float cornerY;
   float radiusX;
   float radiusY;

   sdvg_SetFramebufferSize(Viewport.width, Viewport.height);

   sdvg_BeginFrame();

   sdvg_SetViewport(0, 0, Viewport.width, Viewport.height);
   sdvg_SetScissor(0, 0, Viewport.width, Viewport.height);

   sdvg_Clear4f(0.1,0.15,0.3,1.0);

   Matrix4f mProj;
   float aspect = (float(Viewport.width) / Viewport.height) / 1.333;
   float extra = ((VP_W*aspect) - VP_W) * 0.5f;
   mProj.initOrtho(0.0f-extra/*left*/,    VP_W+extra/*right*/,
                   VP_H/*bottom*/,  0.0f/*top*/,
                   0.0f/*znear*/,  10.0f/*zfar*/
                   );
   sdvg_SetTransform(mProj);

   sdvg_SetEnableAA(b_aa);
   sdvg_SetAARange(b_aa ? aa_range : 0.01f);
   sdvg_SetAAExp(aa_exp);
   sdvg_SetStrokeWidth(stroke_w);
   sdvg_SetFillColor4f(0.1f, 0.4f, 0.25f, fill_alpha);
   sdvg_SetStrokeColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
   sdvg_SetGlobalAlpha(1.0f);

   switch(test_idx)
   {
      case 0:
      default:
         centerX = VP_W * 0.5;
         centerY = VP_H * 0.5;
         if(0)
         {
            sizeX = VP_W*0.25;
            sizeY = VP_H*0.25;
            // radiusX = VP_W*0.0625;  radiusY = VP_H*0.0625;
            // radiusX = 40.0f;  radiusY = 40.0f;
            radiusX = 40.0f;  radiusY = 30.0f;
            // radiusX = 30.0f;  radiusY = 40.0f;
            // radiusX = 50.0f;  radiusY = 20.0f;
            // radiusX = 20.0f;  radiusY = 50.0f;
         }
         else
         {
            sizeX = VP_W*0.25 + 70*sin(ang_w);
            sizeY = VP_H*0.25 + 70*sin(ang_h);
            cornerX = 80.0f + sin(ang_x)*40.0;
            cornerY = 80.0f + sin(ang_y)*40.0;
            // radiusX = 120.0f + sin(ang_x)*80.0;
            // radiusY = 120.0f + sin(ang_y)*80.0;
         }
         break;

      case 1:
         centerX = VP_W*0.5;
         centerY = VP_H*0.5;
         cornerX = 8.0;
         cornerY = 6.0;
         sizeX = 240.0;
         sizeY = 200.0;
         break;

      case 2:
         centerX = VP_W*0.5;
         centerY = VP_H*0.5;
         cornerX = 3.0;
         cornerY = 3.0;
         sizeX = 60.0;
         sizeY =  7.5;
         break;

   } // switch test_idx

   if(b_sym_radius)
   {
      cornerX = mathMinf(cornerX, cornerY);
      cornerY = cornerX;
   }

   switch(render_mode)
   {
      default:
      case RENDER_RECT_FILL_AA:
         sdvg_DrawRectFillAA(centerX, centerY,
                             sizeX * size_sclx, sizeY * size_scly
                             );
         break;

      case RENDER_RECT_FILL_STROKE_AA:
         sdvg_DrawRectFillStrokeAA(centerX, centerY,
                                   sizeX * size_sclx, sizeY * size_scly
                                   );
         break;

      case RENDER_RECT_STROKE_AA:
         sdvg_DrawRectStrokeAA(centerX, centerY,
                               sizeX * size_sclx, sizeY * size_scly
                               );
         break;

      case RENDER_ELLIPSE_FILL_AA:
         sdvg_DrawEllipseFillAA(centerX, centerY,
                                sizeX * size_sclx, sizeY * size_scly
                                );
         break;

      case RENDER_ELLIPSE_FILL_STROKE_AA:
         sdvg_DrawEllipseFillStrokeAA(centerX, centerY,
                                      sizeX * size_sclx, sizeY * size_scly
                                      );
         break;

      case RENDER_ELLIPSE_STROKE_AA:
         sdvg_DrawEllipseStrokeAA(centerX, centerY,
                                  sizeX * size_sclx, sizeY * size_scly
                                  );
         break;

      case RENDER_ROUNDRECT_FILL_AA:
         sdvg_DrawRoundRectFillAA(centerX, centerY,
                                  sizeX * size_sclx, sizeY * size_scly,
                                  cornerX * radius_sclx, cornerY * radius_scly
                                  );
         break;

      case RENDER_ROUNDRECT_FILL_STROKE_AA:
         sdvg_DrawRoundRectFillStrokeAA(centerX, centerY,
                                        sizeX * size_sclx, sizeY * size_scly,
                                        cornerX * radius_sclx, cornerY * radius_scly
                                        );
         break;

      case RENDER_ROUNDRECT_STROKE_AA:
         sdvg_DrawRoundRectStrokeAA(centerX, centerY,
                                    sizeX * size_sclx, sizeY * size_scly,
                                    cornerX * radius_sclx, cornerY * radius_scly
                                    );
         break;

      case RENDER_TRIANGLES_TEX_UV_FLAT:
         buf_vbo.offset = 0;
         sdvg_BufferAddRectTexUVFlat32(buf_vbo,
                                       centerX - sizeX * size_sclx, centerY - sizeY * size_scly,
                                       sizeX * size_sclx * 2,       sizeY * size_scly * 2,
                                       0.0f, 0.0f,
                                       1.0f, 1.0f
                                       );
         sdvg_UpdateVBO(buf_vbo_id, 0, buf_vbo.offset, buf_vbo);
         sdvg_BindTexture2D(tex_id, false/*bRepeat*/, true/*bFilter*/);
         sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
         sdvg_DrawTrianglesTexUVFlatVBO32(buf_vbo_id, 0, 2);
         sdvg_UnbindTexture2D();
         break;

      case RENDER_TRIANGLES_TEX_UV_GOURAUD:
         buf_vbo.offset = 0;
         sdvg_BufferAddRectTexUVGouraud32(buf_vbo,
                                         centerX - sizeX * size_sclx, centerY - sizeY * size_scly,
                                         sizeX * size_sclx * 2,       sizeY * size_scly * 2,
                                         0.0f, 0.0f,
                                         1.0f, 1.0f,
                                         #ffffffff, #Ffff0000,
                                         #3f00ff00, #3f0000ff
                                         );
         sdvg_UpdateVBO(buf_vbo_id, 0, 0, buf_vbo);
         sdvg_BindTexture2D(tex_id, false/*bRepeat*/, true/*bFilter*/);
         sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
         sdvg_DrawTrianglesTexUVGouraudVBO32(buf_vbo_id, 0, 2);
         sdvg_UnbindTexture2D();
         break;

      case RENDER_TRIANGLES_TEX_UV_FLAT_DECAL:
         buf_vbo.offset = 0;
         sdvg_BufferAddRectTexUVFlat32(buf_vbo,
                                      centerX - sizeX * size_sclx, centerY - sizeY * size_scly,
                                      sizeX * size_sclx * 2,       sizeY * size_scly * 2,
                                      0.0f, 0.0f,
                                      1.0f, 1.0f
                                      );
         sdvg_UpdateVBO(buf_vbo_id, 0, 0, buf_vbo);
         sdvg_BindTexture2D(tex_id, false/*bRepeat*/, true/*bFilter*/);
         sdvg_SetTextureDecalAlpha(decal_alpha);
         sdvg_DrawTrianglesTexUVFlatDecalVBO32(buf_vbo_id, 0, 2);
         sdvg_UnbindTexture2D();
         break;

      case RENDER_TRIANGLES_TEX_UV_GOURAUD_DECAL:
         buf_vbo.offset = 0;
         sdvg_BufferAddRectTexUVGouraud32(buf_vbo,
                                         centerX - sizeX * size_sclx, centerY - sizeY * size_scly,
                                         sizeX * size_sclx * 2,       sizeY * size_scly * 2,
                                         0.0f, 0.0f,
                                         1.0f, 1.0f,
                                         #ffffffff, #Ffff0000,
                                         #3f00ff00, #3f0000ff
                                         );
         sdvg_UpdateVBO(buf_vbo_id, 0, 0, buf_vbo);
         sdvg_BindTexture2D(tex_id, false/*bRepeat*/, true/*bFilter*/);
         sdvg_SetTextureDecalAlpha(decal_alpha);
         sdvg_DrawTrianglesTexUVGouraudDecalVBO32(buf_vbo_id, 0, 2);
         sdvg_UnbindTexture2D();
         break;

      case RENDER_LINE_STRIP_FLAT_1:
         TestLineStripFlat_1(false/*bAA*/);
         break;

      case RENDER_LINE_STRIP_FLAT_2:
         TestLineStripFlat_2(false/*bAA*/);
         break;

      case RENDER_LINE_STRIP_FLAT_AA_1:
         TestLineStripFlat_1(true/*bAA*/);
         break;

      case RENDER_LINE_STRIP_FLAT_AA_2:
         TestLineStripFlat_2(true/*bAA*/);
         break;

      case RENDER_LINE_STRIP_FLAT_BEVEL:
         TestLineStripFlatBevel(false/*bAA*/);
         break;

      case RENDER_LINE_STRIP_FLAT_BEVEL_AA:
         TestLineStripFlatBevel(true/*bAA*/);
         break;

      case RENDER_CUSTOM_SHADER_1:
         TestCustomShader_1(sizeX, sizeY);
         break;

      case RENDER_CUSTOM_SHADER_2:
         TestCustomShader_2(sizeX, sizeY);
         break;

      case RENDER_CUSTOM_SHADER_3_VBO:
         TestCustomShader_3_VBO(mProj, sizeX, sizeY);
         break;

      case RENDER_LINES:
         TestLinesFlat(false/*bAA*/);
         break;

      case RENDER_LINES_AA:
         TestLinesFlat(true/*bAA*/);
         break;

      case RENDER_BEGIN_LINE_STRIP:
         TestBeginLineStripFlat(false/*bAA*/);
         break;

      case RENDER_BEGIN_LINE_STRIP_AA:
         TestBeginLineStripFlat(true/*bAA*/);
         break;

      case RENDER_BEGIN_LINE_STRIP_BEVEL:
         TestBeginLineStripFlatBevel(false/*bAA*/);
         break;

      case RENDER_BEGIN_LINE_STRIP_BEVEL_AA:
         TestBeginLineStripFlatBevel(true/*bAA*/);
         break;

      case RENDER_BEGIN_LINES:
         TestBeginLinesFlat(false/*bAA*/);
         break;

      case RENDER_BEGIN_LINES_AA:
         TestBeginLinesFlat(true/*bAA*/);
         break;

      case RENDER_FILLED_RECTANGLE:
         sdvg_SetFillColor4f(1.0f, 1.0f, 1.0f, fill_alpha);
         sdvg_DrawFilledRectangle(centerX - sizeX * size_sclx * 0.5f,
                                  centerY - sizeY * size_scly * 0.5f,
                                  sizeX * size_sclx,
                                  sizeY * size_scly
                                  );
         break;

      case RENDER_BEGIN_POINTS_SQUARE:
         TestBeginPointsSquare(false/*bAA*/);
         break;

      case RENDER_BEGIN_POINTS_SQUARE_AA:
         TestBeginPointsSquare(true/*bAA*/);
         break;

      case RENDER_BEGIN_POINTS_ROUND:
         TestBeginPointsRound(false/*bAA*/);
         break;

      case RENDER_BEGIN_POINTS_ROUND_AA:
         TestBeginPointsRound(true/*bAA*/);
         break;

      case RENDER_BEGIN_FILLED_TRIANGLES:
         TestBeginFilledTriangles();
         break;

      case RENDER_BEGIN_FILLED_TRIANGLE_FAN:
         TestBeginFilledTriangleFan();
         break;

      case RENDER_BEGIN_FILLED_TRIANGLE_STRIP:
         TestBeginFilledTriangleStrip();
         break;

      case RENDER_BEGIN_FILLED_GOURAUD_TRIANGLES:
         TestBeginFilledGouraudTriangles();
         break;

      case RENDER_BEGIN_FILLED_GOURAUD_TRIANGLE_FAN:
         TestBeginFilledGouraudTriangleFan();
         break;

      case RENDER_BEGIN_FILLED_GOURAUD_TRIANGLE_STRIP:
         TestBeginFilledGouraudTriangleStrip();
         break;

      case RENDER_BEGIN_TEXTURED_TRIANGLES:
         TestBeginTexturedTriangles(false/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_TRIANGLES_ALPHA:
         TestBeginTexturedTriangles(true/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_TRIANGLE_FAN:
         TestBeginTexturedTriangleFan(false/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_TRIANGLE_FAN_ALPHA:
         TestBeginTexturedTriangleFan(true/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_TRIANGLE_STRIP:
         TestBeginTexturedTriangleStrip(false/*bAlpha*/);
         break;
      case RENDER_BEGIN_TEXTURED_TRIANGLE_STRIP_ALPHA:
         TestBeginTexturedTriangleStrip(true/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLES:
         TestBeginTexturedGouraudTriangles(false/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLES_ALPHA:
         TestBeginTexturedGouraudTriangles(true/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_FAN:
         TestBeginTexturedGouraudTriangleFan(false/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_FAN_ALPHA:
         TestBeginTexturedGouraudTriangleFan(true/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_STRIP:
         TestBeginTexturedGouraudTriangleStrip(false/*bAlpha*/);
         break;

      case RENDER_BEGIN_TEXTURED_GOURAUD_TRIANGLE_STRIP_ALPHA:
         TestBeginTexturedGouraudTriangleStrip(true/*bAlpha*/);
         break;

      case RENDER_TEXT_1:
         TestText_1();
         break;

      case RENDER_TEXT_2_CLIP:
         TestText_2_Clip();
         break;

      case RENDER_TEXT_3_SWIRL:
         TestText_3_Swirl();
         break;

      case RENDER_TEXT_4_UL:
         TestText_4_Ul();
         break;

      case RENDER_TEXT_5_UL_CLIP:
         TestText_5_Ul_Clip();
         break;

      case RENDER_TEXT_6_ACCEL:
         TestText_6_Accel();
         break;

      case RENDER_TEXT_7_ACCEL_CLIP:
         TestText_7_Accel_Clip();
         break;
   }

   sdvg_EndFrame();

   float spd = b_anim ? b_slomo ? 0.1 : 1.0 : 0.0;
   ang_x += dt * spd * 0.03;
   ang_y += dt * spd * 0.02634;
   ang_w += dt * spd * 0.0054112634;
   ang_h += dt * spd * 0.0031312634;
   ang_c += dt * spd * 0.0014132354;
   if(ang_x >= 2*2PI)
      ang_x -= 2*2PI;
   if(ang_y >= 2*2PI)
      ang_y -= 2*2PI;
   if(ang_w >= 2*2PI)
      ang_w -= 2*2PI;
   if(ang_h >= 2*2PI)
      ang_h -= 2*2PI;
   if(ang_c >= 2PI)
      ang_c -= 2PI;

   if(b_queued_screenshot)
   {
      b_queued_screenshot = false;
      Integer io = render_mode;
      SaveScreenShotPNG("screenshots/test_"+io.printf("%03d")+"_"+mode_names.get(render_mode)+".png");
   }
}

// ---------------------------------------------------------------------------- ResetParams
function ResetParams() {
   aa_range    = 2.5 / vp_scale;
   aa_exp      = 1.0;
   stroke_w    = 1.5;
   fill_alpha  = 1.0;
   decal_alpha = 1.0;
   radius_sclx = 1.0;
   radius_scly = 1.0;
   trace "[...] reset";
   if(2 == test_idx)
   {
      stroke_w = 0.375;
      aa_range = 0.75;
   }
}

// ---------------------------------------------------------------------------- SelectRenderMode
function SelectRenderMode(int _mode) {
   render_mode = _mode;
   Viewport.caption = render_mode+":"+mode_names.get(render_mode);
   trace "[...] render_mode is "+render_mode+" (\""+mode_names.get(render_mode)+"\")";
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   if(_cbs & (MOUSE_WHEELDOWN | MOUSE_WHEELUP))
   {
      if(_nbs & MOUSE_WHEELDOWN)
      {
         SelectRenderMode(mathWrapi(render_mode - 1, 0, NUM_RENDER_MODES));
      }
      else
      {
         SelectRenderMode(mathWrapi(render_mode + 1, 0, NUM_RENDER_MODES));
      }
   }
}

// ---------------------------------------------------------------------------- onKeyboard
function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_RETURN:
         ResetParams();
         break;

      case VKEY_SPACE:
         if(_k.mod)
         {
            b_slomo = !b_slomo;
            trace "[...] b_slomo is "+b_slomo;
         }
         else
         {
            b_anim = !b_anim;
            trace "[...] b_anim is "+b_anim;
            if(!b_anim)
            {
               trace "ang_x = "+ang_x+";\n";
               trace "ang_y = "+ang_y+";\n";
               trace "ang_w = "+ang_w+";\n";
               trace "ang_h = "+ang_h+";\n";
            }
         }
         break;

      case VKEY_UP:
         SelectRenderMode(mathWrapi(render_mode + 1, 0, NUM_RENDER_MODES));
         break;

      case VKEY_DOWN:
         SelectRenderMode(mathWrapi(render_mode - 1, 0, NUM_RENDER_MODES));
         break;

      case VKEY_RIGHT:
         stroke_w = mathMinf(stroke_w + 0.125f, 16.0f);
         trace "[...] stroke_w is "+stroke_w;
         break;

      case VKEY_LEFT:
         stroke_w = mathMaxf(stroke_w - 0.125f, 0.125f);
         trace "[...] stroke_w is "+stroke_w;
         break;

      case '1':
         test_idx = 0;
         trace "[...] test_idx is "+test_idx;
         break;

      case '2':
         test_idx = 1;
         trace "[...] test_idx is "+test_idx;
         break;

      case '3':
         test_idx = 2;
         stroke_w = 0.375;
         aa_range = 0.75;
         trace "[...] test_idx is "+test_idx;
         break;

      case 'a':
         b_aa = !b_aa;
         trace "[...] b_aa is "+b_aa;
         break;

      case 'd':
         sdvg_SetEnableDebug(!sdvg_GetEnableDebug());
         trace "[...] sdvg_SetEnableDebug("+sdvg_GetEnableDebug()+")";
         break;

      case 'f':
         radius_sclx = mathMaxf(radius_sclx - 0.03125f, 0.03125f);
         if(_k.mod)
            radius_scly = radius_sclx;
         trace "[...] radius_sclx is "+radius_sclx;
         break;

      case 'g':
         radius_sclx = mathMinf(radius_sclx + 0.03125f, 8.0f);
         if(_k.mod)
            radius_scly = radius_sclx;
         trace "[...] radius_scl is "+radius_sclx;
         break;

      case 'h':
         radius_scly = mathMaxf(radius_scly - 0.03125f, 0.03125f);
         if(_k.mod)
            radius_sclx = radius_scly;
         trace "[...] radius_scly is "+radius_scly;
         break;

      case 'i':
         sdvg_SetEnableDrawInner(!sdvg_GetEnableDrawInner());
         trace "[...] sdvg_SetEnableDrawInner("+sdvg_GetEnableDrawInner()+")";
         break;

      case 'j':
         radius_scly = mathMinf(radius_scly + 0.03125f, 8.0f);
         if(_k.mod)
            radius_sclx = radius_scly;
         trace "[...] radius_scly is "+radius_scly;
         break;

      case 'k':
         aa_exp = mathMaxf(aa_exp - 0.03125f, 0.03125f);
         if(_k.mod)
            radius_sclx = aa_exp;
         trace "[...] aa_exp is "+aa_exp;
         break;

      case 'l':
         b_sym_radius = !b_sym_radius;
         trace "[...] b_sym_radius is "+b_sym_radius;
         break;

      case 'm':
         b_msaa = !b_msaa;
         trace "[...] b_msaa is "+b_msaa;
         b_reopen = true;
         SDL.exitEventLoop();
         break;

      case 'n':
         if(_k.mod)
         {
            aa_range = mathMaxf(aa_range - 0.125f, 0.125f);
            trace "[...] aa_range is "+aa_range;
         }
         else
         {
            aa_range = mathMinf(aa_range + 0.125f, 4.0f);
            trace "[...] aa_range is "+aa_range;
         }
         break;

      case 'o':
         sdvg_SetEnableDrawBorder(!sdvg_GetEnableDrawBorder());
         trace "[...] sdvg_SetEnableDrawBorder("+sdvg_GetEnableDrawBorder()+")";
         break;

      case 'p':
         b_queued_screenshot = true;
         trace "[...] queue screenshot";
         break;

      case 'q':
         size_sclx = mathMaxf(size_sclx - 0.03125f, 0.03125f);
         if(_k.mod)
            size_scly = size_sclx;
         trace "[...] size_sclx is "+size_sclx;
         break;

      case 'r':
         if(_k.mod)
         {
            decal_alpha = mathMaxf(decal_alpha - 0.0625f, 0.0f);
            trace "[...] decal_alpha is "+decal_alpha;
         }
         else
         {
            fill_alpha = mathMaxf(fill_alpha - 0.0625f, 0.0f);
            trace "[...] fill_alpha is "+fill_alpha;
         }
         break;

      case 't':
         if(_k.mod)
         {
            decal_alpha = mathMinf(decal_alpha + 0.0625f, 1.0f);
            trace "[...] decal_alpha is "+decal_alpha;
         }
         else
         {
            fill_alpha = mathMinf(fill_alpha + 0.0625f, 1.0f);
            trace "[...] fill_alpha is "+fill_alpha;
         }
         break;

      case 'v':
         b_vsync = !b_vsync;
         trace "[...] b_vsync is "+b_vsync;
         Viewport.swapInterval(b_vsync);
         break;

      case 'w':
         size_sclx = mathMinf(size_sclx + 0.03125f, 8.0f);
         if(_k.mod)
            size_scly = size_sclx;
         trace "[...] size_sclx is "+size_sclx;
         break;

      case 'x':
         size_scly = mathMinf(size_scly + 0.03125f, 8.0f);
         if(_k.mod)
            size_sclx = size_scly;
         trace "[...] size_scly is "+size_scly;
         break;

      case 'z':
         size_scly = mathMaxf(size_scly - 0.03125f, 0.03125f);
         if(_k.mod)
            size_sclx = size_scly;
         trace "[...] size_scly is "+size_scly;
         break;
   }
}

// ---------------------------------------------------------------------------- onOpen
function onOpen() {
   trace "[dbg] onOpen";

   zglEnableGLCore(b_glcore);

   SelectRenderMode(render_mode);

   if(!sdvg_OnOpen())
   {
      die "sdvg_OnOpen() failed";
   }

   buf_vbo_id = sdvg_CreateVBO(buf_vbo.size);

   tex_id = sdvg_CreateTexture2D(SDVG_TEXFMT_BGRA8888, tex_data.sx, tex_data.sy, tex_data);
   tex_alpha_id = sdvg_CreateTexture2D(SDVG_TEXFMT_ALPHA8, tex_alpha_data.sx, tex_alpha_data.sy, tex_alpha_data);
   trace "[dbg] onOpen: tex_id="+tex_id+" tex_alpha_id="+tex_alpha_id;

   custom_shader_idx_1 = 0;
   custom_shader_idx_2 = 0;
   custom_shader_idx_3 = 0;
   test_text_3_shader_idx = 0;
   custom_vbo_id_3 = 0;

   sdvg_FontOnOpen(font);
}

// ---------------------------------------------------------------------------- onClose
function onClose() {
   trace "[dbg] onClose";

   // (note) it would suffice to set the ids to 0 since
   //         the objects will all be deleted by the GL when the context is destroyed

   if(0 != buf_vbo_id)
   {
      sdvg_DestroyVBO(buf_vbo_id);
      buf_vbo_id = 0;
   }

   if(0 != custom_shader_idx_1)
   {
      sdvg_DestroyShader(custom_shader_idx_1);
      custom_shader_idx_1 = 0;
   }

   if(0 != custom_shader_idx_2)
   {
      sdvg_DestroyShader(custom_shader_idx_2);
      custom_shader_idx_2 = 0;
   }

   if(0 != custom_shader_idx_3)
   {
      sdvg_DestroyShader(custom_shader_idx_3);
      custom_shader_idx_3 = 0;
   }

   if(0 != test_text_3_shader_idx)
   {
      sdvg_DestroyShader(test_text_3_shader_idx);
      test_text_3_shader_idx = 0;
   }


   if(0 != custom_vbo_id_3)
   {
      sdvg_DestroyVBO(custom_vbo_id_3);
      custom_vbo_id_3 = 0;
   }

   sdvg_DestroyTexture2D(tex_id);
   sdvg_DestroyTexture2D(tex_alpha_id);
}

// ---------------------------------------------------------------------------- LoadFont
function LoadFont(String _pathPrefix) {
   File fBin;
   if(fBin.openLocal(_pathPrefix+".bin", IOS_IN))
   {
      fBin.readBuffer(font_bin, 0, fBin.size, true/*bResize*/);
      fBin.close();
      font_bin.offset = font_bin.size;

      if(font_tex.loadLocalImage(_pathPrefix+".png", 0,0,1))
      {
         if(sdvg_InitFont(font, font_bin, font_tex.sx, font_tex.sy, font_tex))
         {
            trace "[...] LoadFont: OK, font \""+_pathPrefix+"\" loaded";
            if(0)
            {
               trace "[trc]   StringWidth()="+sdvg_TextWidth(font, "hello, world.");
               trace "[trc]   StringHeight()="+sdvg_TextHeight(font, "hello, world.");
            }
         }
         else
         {
            die "[---] LoadFont: sdvg_InitFont() failed\n";
         }
      }
      else
      {
         die "[---] LoadFont: failed to load font-texture from \""+_pathPrefix+".png\"";
      }
   }
   else
   {
      die "[---] LoadFont: failed to load font-data from \""+_pathPrefix+".bin\"";
   }
}

// ---------------------------------------------------------------------------- main
function main() {

   if(Arguments.numElements > 0)
      render_mode = mathClampi(Arguments[0], 0, NUM_RENDER_MODES);

   // Load texture(s)
   if(!tex_data.loadLocalImage("res/escher.png", 0,0,4))
      die "failed to load \"res/escher.png\"";
   tex_data.flags = TEX_MINFILTERLINEAR | TEX_MAGFILTERLINEAR | TEX_ALPHA;   // (todo) remove (ignored)

   tex_alpha_data.flags = TEX_MINFILTERLINEAR | TEX_MAGFILTERLINEAR | TEX_ALPHA;   // (todo) remove (ignored)
   tex_alpha_data.alloc(tex_data.sx, tex_data.sy, 1);
   tex_alpha_data.scaleFrom(tex_data);

   // Load font
   LoadFont("../../tools/font_convert/out/default_30");

   use callbacks;

   FPS.tickInterval = 1000.0/60;
   FPS.limit = 60;

   SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   SDL.timerInterval = 1;

   SDL.dpiAwareness = true;  // no OS scaling

   SDL.enableUNICODE(true);
   SDL.enableKeyRepeat(100/*delay*/, 20/*rate*/);

   sdvg_SetScratchBufferSize(4096*1024);
   sdvg_SetGLSLVersion(b_glcore/*bV3*/, false/*bGLES*/, null/*sVersionStringOrNull*/);
   sdvg_Init(b_glcore);

   if(b_msaa)
   {
      Viewport.multisampleSamples = 4;
      Viewport.multisampleBuffers = 1;
   }

   Viewport.openWindow(640*vp_scale, 480*vp_scale);
   Viewport.swapInterval(b_vsync);

   trace "[...] entering eventloop";

   for(;;)
   {
      SDL.eventLoop();

      if(b_reopen)
      {
         Viewport.close();
         b_reopen = false;
         Viewport.multisampleSamples = b_msaa ? 4 : 0;
         Viewport.multisampleBuffers = b_msaa ? 1 : 0;
         Viewport.openWindow(640*vp_scale, 480*vp_scale);
      }
      else
         break;
   }

   sdvg_Exit();
}

tex_data.free();
tex_alpha_data.free();
