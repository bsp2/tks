// ----
// ---- file   : SampleViewUndo.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2013-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 01Jun2013
// ---- changed: 02Jun2013, 15Dec2018, 02Nov2019, 10Aug2023, 23Sep2024
// ----
// ----
// ----

module MSampleViewUndo;

use namespace ui;


class SampleViewUndoAction {
   // undo transaction entry

   StWaveform *waveform;    // reference to parent waveform

   define int ACTION_NONE          = 0;
   define int ACTION_REMOVE        = 1;
   define int ACTION_MODIFY        = 2;
   define int ACTION_ADD           = 3;
   define int ACTION_PHASEINVERT   = 4;
   define int ACTION_REVERSE       = 5;
   define int ACTION_DELETECHANNEL = 6;
   define int ACTION_CREATECHANNEL = 7;

   int action;

   int frame_offset;
   int num_frames;
   int channel_mask;

   FloatArray data;
   int        data_num_channels;


   public method init(StWaveform _waveform, int _action, int _frameOffset, int _numFrames, int _chMask) {
      action       = _action;
      waveform    <= _waveform;
      frame_offset = _frameOffset;
      num_frames   = _numFrames;
      channel_mask = _chMask;
   }

   public method actionRemove() {
      // Create backup of removed sampledata
      int srcNumCh = waveform.numChannels;
      FloatArray samples <= waveform.sampleData;

      if(2 == srcNumCh)
      {
         switch(channel_mask)
         {
            default:
            case SampleView.CHANNEL_MASK_LR:
               data_num_channels = 2;
               data.alloc(num_frames * 2);
               data.useAll();

               tksampleedit_ringbuf_copy_samples(data,      2/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                                 num_frames, 2/*numCh*/,
                                                 samples,   2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_L:
               data_num_channels = 1;
               data.alloc(num_frames);
               data.useAll();

               tksampleedit_ringbuf_copy_samples(data,      1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 samples,   2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_R:
               data_num_channels = 1;
               data.alloc(num_frames);
               data.useAll();

               tksampleedit_ringbuf_copy_samples(data,      1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 samples,   2/*srcNumCh*/, 1/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;
         }

      }
      else
      {
         data_num_channels = 1;
         data.alloc(num_frames);
         data.useAll();

         tksampleedit_ringbuf_copy_samples(data,      1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                           num_frames, 1/*numCh*/,
                                           samples,   1/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                           );
      }
   }

   public method actionModify() {
      // Create backup of sampledata to be modified

      int srcNumCh = waveform.numChannels;
      FloatArray samples <= waveform.sampleData;

      if(2 == srcNumCh)
      {
         switch(channel_mask)
         {
            default:
            case SampleView.CHANNEL_MASK_LR:
               data_num_channels = 2;
               data.alloc(num_frames * 2);
               data.useAll();

               tksampleedit_ringbuf_copy_samples(data,      2/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                                 num_frames, 2/*numCh*/,
                                                 samples,   2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_L:
               data_num_channels = 1;
               data.alloc(num_frames);
               data.useAll();

               tksampleedit_ringbuf_copy_samples(data,      1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 samples,   2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_R:
               data_num_channels = 1;
               data.alloc(num_frames);
               data.useAll();

               tksampleedit_ringbuf_copy_samples(data,      1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 samples,   2/*srcNumCh*/, 1/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;
         }

      }
      else
      {
         data_num_channels = 1;
         data.alloc(num_frames);
         data.useAll();

         tksampleedit_ringbuf_copy_samples(data,      1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                           num_frames, 1/*numCh*/,
                                           samples,   1/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                           );
      }
   }

   public method actionAdd() {
      // Just remember which area to remove during undo
   }

   public method actionPhaseInvert() {
      // Just remember which area to invert during undo
   }

   public method actionReverse() {
      // Just remember which area to reverse during undo
   }

   public method actionDeleteChannel() {
      // Just remember which channel to recreate during undo
   }

   public method actionCreateChannel() {
      // Just remember which channel to delete during undo
   }

   public method calcMemUsage() : int {
      return (data.numElements * 4);
   }

   protected method undoRemove(SampleViewPlugin _plugin) {
      // area was removed, re-add it

      if(null != _plugin)
      {
         _plugin.svBeginReallocSamples();
      }
      else
      {
         // Stop all voices
         // // Global.Panic();
      }

      int numCh = waveform.numChannels;
      FloatArray samples <= waveform.sampleData;
      int oldNumFrames = samples.numElements / numCh;

      int newNumFrames;
      if( (2 == numCh) && (channel_mask != SampleView.CHANNEL_MASK_LR) )
      {
         newNumFrames = oldNumFrames;
      }
      else
      {
         newNumFrames = oldNumFrames + num_frames;
      }

      local FloatArray newSamples;
      newSamples.alloc(newNumFrames * numCh);
      newSamples.useAll();

      if(frame_offset > 0)
      {
         // Copy until start of cut
         newSamples.copyFrom(samples, 0, frame_offset*numCh, 0);
      }

      // Re-insert original samples
      if(2 == numCh)
      {
         switch(channel_mask)
         {
            default:
            case SampleView.CHANNEL_MASK_LR:
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 2/*numCh*/,
                                                 data,       2/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               // Add remaining samples
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset), 2/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_L:
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 data,       1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               // Add remaining samples (left)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );

               // Add remaining samples (right)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 1/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_R:
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 data,       1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               // Add remaining samples (left)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );

               // Add remaining samples (right)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 1/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;
         }
      }
      else
      {
         tksampleedit_ringbuf_copy_samples(newSamples, 1/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                           num_frames, 1/*numCh*/,
                                           data,       1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                           );

         // Add remaining samples
         tksampleedit_ringbuf_copy_samples(newSamples, 1/*dstNumCh*/, 0/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                           (oldNumFrames - frame_offset), 1/*numCh*/,
                                           samples,    1/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                           );
      }


      // // samples = newSamples;
      samples.unlinkFrom(newSamples);

      if(null != _plugin)
      {
         _plugin.svHandleInsertRegion(frame_offset, num_frames);
         _plugin.svEndReallocSamples();
      }

      Global.SuccessShort("SampleView::undo: re-added "+Utils.GetNumString(num_frames, "sample frame"));
   }

   protected method undoModify(SampleViewPlugin _plugin) {
      // area was modified, restore it
      //   check if num_channels changed

      if(null != _plugin)
      {
         _plugin.svBeginReallocSamples();
      }
      else
      {
         // Stop all voices
         // // Global.Panic();
      }

      int numCh = waveform.numChannels;
      FloatArray samples <= waveform.sampleData;
      int oldNumFrames = samples.numElements / numCh;

      local FloatArray newSamples;
      newSamples.alloc(oldNumFrames * numCh);
      newSamples.useAll();

      if(frame_offset > 0)
      {
         // Copy until start of modification
         newSamples.copyFrom(samples, 0, frame_offset*numCh, 0);
      }

      // trace "xxx undoModify: numCh="+numCh;

      // Restore original samples
      if(2 == numCh)
      {
         switch(channel_mask)
         {
            default:
            case SampleView.CHANNEL_MASK_LR:
               // Restore stereo
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 2/*numCh*/,
                                                 data,       2/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               // Add remaining samples
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 2/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_L:
               // Restore left
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 data,       1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               // Keep right
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 1/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );

               // Add remaining samples (stereo)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 2/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                                 );

               break;

            case SampleView.CHANNEL_MASK_R:
               // Keep left
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );

               // Restore right
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 num_frames, 1/*numCh*/,
                                                 data,       1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               // Add remaining samples (stereo)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 2/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                                 );
               break;
         }
      }
      else
      {
         // Restore mono
         tksampleedit_ringbuf_copy_samples(newSamples, 1/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                           num_frames, 1/*numCh*/,
                                           data,       1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                           );

         // Add remaining samples (mono)
         tksampleedit_ringbuf_copy_samples(newSamples, 1/*dstNumCh*/, 0/*dstChOff*/, frame_offset+num_frames/*dstFrameOff*/,
                                           (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                           samples,    1/*srcNumCh*/, 0/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                           );
      }

      // // samples = newSamples;
      samples.unlinkFrom(newSamples);

      if(null != _plugin)
      {
         _plugin.svEndReallocSamples();
      }

      Global.SuccessShort("SampleView::undo: restored "+Utils.GetNumString(num_frames, "sample frame"));
   }

   protected method undoAdd(SampleViewPlugin _plugin) {
      // area was added, remove it

      if(null != _plugin)
      {
         _plugin.svBeginReallocSamples();
      }
      else
      {
         // Stop all voices
         // // Global.Panic();
      }

      int numCh = waveform.numChannels;
      FloatArray samples <= waveform.sampleData;
      int oldNumFrames = samples.numElements / numCh;

      local FloatArray newSamples;
      newSamples.alloc((oldNumFrames - num_frames) * numCh);
      newSamples.useAll();
      newSamples.fill(0);

      if(frame_offset > 0)
      {
         // Copy until start of added area
         newSamples.copyFrom(samples, 0, frame_offset*numCh, 0);
      }

      if(2 == numCh)
      {
         switch(channel_mask)
         {
            default:
            case SampleView.CHANNEL_MASK_LR:
               // Add remaining samples (stereo)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 2/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_L:
               // Add remaining samples (left)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                                 );

               // Add remaining samples (right)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 1/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );
               break;

            case SampleView.CHANNEL_MASK_R:
               // Add remaining samples (left)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 0/*srcChOff*/, frame_offset/*srcFrameOff*/
                                                 );

               // Add remaining samples (right)
               tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                                 (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, 1/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                                 );
               break;
         }
      }
      else
      {
         // Add remaining samples (mono)
         tksampleedit_ringbuf_copy_samples(newSamples, 1/*dstNumCh*/, 0/*dstChOff*/, frame_offset/*dstFrameOff*/,
                                           (oldNumFrames - frame_offset - num_frames), 1/*numCh*/,
                                           samples,    1/*srcNumCh*/, 0/*srcChOff*/, frame_offset+num_frames/*srcFrameOff*/
                                           );
      }

      // // samples = newSamples;
      samples.unlinkFrom(newSamples);

      if(null != _plugin)
      {
         _plugin.svHandleDeleteRegion(frame_offset, num_frames);
         _plugin.svEndReallocSamples();
      }

      Global.SuccessShort("SampleView::undo: removed "+Utils.GetNumString(num_frames, "sample frame"));
   }

   protected method undoPhaseInvert(SampleViewPlugin _plugin) {
      // area was phase-inverted, re-invert it

      if(null != _plugin)
      {
         _plugin.svBeginReallocSamples();
      }
      else
      {
         // Stop all voices
         // // Global.Panic();
      }

      FloatArray samples <= waveform.sampleData;
      int numCh = waveform.numChannels;
      int smpStartOff = frame_offset * numCh;
      int smpEndOff   = (frame_offset + num_frames) * numCh;
      int numFrames = num_frames;
      int i = smpStartOff;

      int smpAdv = numCh;

      if(2 == numCh)
      {
         if(SampleView.CHANNEL_MASK_R == channel_mask)
         {
            i++;
         }
         else if(SampleView.CHANNEL_MASK_LR == channel_mask)
         {
            numFrames *= 2;
            smpAdv = 1;
         }
      }

      compile loop(numFrames)
      {
         samples[i] = -samples[i];
         i = i + smpAdv;
      }

      if(null != _plugin)
      {
         _plugin.svEndReallocSamples();
      }

      Global.SuccessShort("SampleView::undo: phase-inverted "+Utils.GetNumString(num_frames, "sample frame"));
   }

   protected method undoReverse(SampleViewPlugin _plugin) {
      // area was reverse, re-reverse it

      if(null != _plugin)
      {
         _plugin.svBeginReallocSamples();
      }
      else
      {
         // Stop all voices
         // // Global.Panic();
      }

      FloatArray samples <= waveform.sampleData;
      int numCh = waveform.numChannels;
      int smpStartOff = frame_offset * numCh;
      int smpEndOff   = (frame_offset + num_frames) * numCh;
      int numFrames = num_frames;
      int i;
      int j;

      int smpAdv = numCh;

      if(2 == numCh)
      {
         if(SampleView.CHANNEL_MASK_R == channel_mask)
         {
            smpStartOff++;
            smpEndOff++;
            i++;
         }
         else if(SampleView.CHANNEL_MASK_LR == channel_mask)
         {
            numFrames *= 2;
            smpAdv = 1;
         }
      }

      i = smpStartOff;
      j = smpEndOff;
      loop(numFrames / 2)
      {
         j = j - smpAdv;

         float t = samples[i];
         samples[i] = samples[j];
         samples[j] = t;

         i = i + smpAdv;
      }

      if(null != _plugin)
      {
         _plugin.svEndReallocSamples();
      }

      Global.SuccessShort("SampleView::undo: reversed "+Utils.GetNumString(num_frames, "sample frame"));
   }

   protected method undoDeleteChannel(SampleViewPlugin _plugin) {
      // channel was deleted, recreate it

      if(null != _plugin)
      {
         _plugin.svBeginReallocSamples();
      }
      else
      {
         // Stop all voices
         // // Global.Panic();
      }

      FloatArray samples <= waveform.sampleData;
      int dstChNr = (SampleView.CHANNEL_MASK_L == channel_mask) ? 1 : 0;

      local FloatArray newSamples;
      newSamples.alloc(samples.numElements * 2);
      newSamples.useAll();
      newSamples.fill(0);

      tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, dstChNr/*dstChOff*/, 0/*dstFrameOff*/,
                                        samples.numElements, 1/*numCh*/,
                                        samples,    1/*srcNumCh*/, 0/*srcChOff*/,       0/*srcFrameOff*/
                                        );

      // // samples = newSamples;
      samples.unlinkFrom(newSamples);
      waveform.numChannels = 2;

      if(null != _plugin)
      {
         _plugin.svEndReallocSamples();
      }

      Global.SuccessShort("SampleView::undo: recreated "+((SampleView.CHANNEL_MASK_L == channel_mask) ? "left" : "right")+ "channel");
   }

   protected method undoCreateChannel(SampleViewPlugin _plugin) {
      // channel was created, delete it
      // trace "xxx undoCreateChannel";

      if(null != _plugin)
      {
         _plugin.svBeginReallocSamples();
      }
      else
      {
         // Stop all voices
         // // Global.Panic();
      }

      FloatArray samples <= waveform.sampleData;
      int srcChNr = (SampleView.CHANNEL_MASK_R == channel_mask) ? 0 : 1; // actually mask is always R

      // trace "xxx undoCreateChannel: channel_mask="+channel_mask+" keep srcChNr="+srcChNr;

      local FloatArray newSamples;
      newSamples.alloc(samples.numElements / 2);
      newSamples.useAll();

      tksampleedit_ringbuf_copy_samples(newSamples, 1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                        samples.numElements, 1/*numCh*/,
                                        samples,    2/*srcNumCh*/, srcChNr/*srcChOff*/, 0/*srcFrameOff*/
                                        );

      // // samples = newSamples;
      samples.unlinkFrom(newSamples);
      waveform.numChannels = 1;

      if(null != _plugin)
      {
         _plugin.svEndReallocSamples();
      }

      Global.SuccessShort("SampleView::undo: deleted "+((SampleView.CHANNEL_MASK_L == channel_mask) ? "left" : "right")+ "channel");
   }

   public method undo(SampleViewPlugin _plugin, SampleViewUndoEntry _redo) {

      // if(null != _redo)
      // {
      //    trace "xxx undo action="+action+" channel_mask="+channel_mask;
      // }
      // else
      // {
      //    trace "xxx redo action="+action+" channel_mask="+channel_mask;
      // }

      switch(action)
      {
         case ACTION_REMOVE:
            // area was removed, re-add it
            if(null != _redo)
            {
               _redo.actionAdd(frame_offset, num_frames, channel_mask);
            }
            undoRemove(_plugin);
            break;

         case ACTION_MODIFY:
            // area was modified, restore it
            if(null != _redo)
            {
               // (note) as an optimization, at least some of the MODIFY actions can be
               //         undone programmatically (e.g. fade in/out, ..) but it gets a bit
               //         trickier for things like freedraw (could still be done, though)
               _redo.actionModify(frame_offset, num_frames, channel_mask);
            }
            else
            {
               // trace "xxx redo modify channel_mask="+channel_mask;
            }
            undoModify(_plugin);
            break;

         case ACTION_ADD:
            // area was added, remove it
            if(null != _redo)
            {
               _redo.actionRemove(frame_offset, num_frames, channel_mask);
            }
            undoAdd(_plugin);
            break;

         case ACTION_PHASEINVERT:
            // area was phase inverted, re-invert it
            if(null != _redo)
            {
               _redo.actionPhaseInvert(frame_offset, num_frames, channel_mask);
            }
            undoPhaseInvert(_plugin);
            break;

         case ACTION_REVERSE:
            // area was reversed, re-reverse it
            if(null != _redo)
            {
               _redo.actionReverse(frame_offset, num_frames, channel_mask);
            }
            undoReverse(_plugin);
            break;

         case ACTION_DELETECHANNEL:
            // channel was deleted, recreate it
            if(null != _redo)
            {
               // _redo.actionCreateChannel((SampleView.CHANNEL_MASK_L == channel_mask) ? SampleView.CHANNEL_MASK_R : SampleView.CHANNEL_MASK_L);
               _redo.actionCreateChannel(channel_mask);
            }
            else
            {
               // trace "xxx redo deletechannel channel_mask="+channel_mask;
            }
            undoDeleteChannel(_plugin);
            break;

         case ACTION_CREATECHANNEL:
            // channel was created, delete it
            if(null != _redo)
            {
               // _redo.actionDeleteChannel((SampleView.CHANNEL_MASK_L == channel_mask) ? SampleView.CHANNEL_MASK_R : SampleView.CHANNEL_MASK_L);
               _redo.actionDeleteChannel(channel_mask);
            }
            else
            {
               // trace "xxx redo createchannel channel_mask="+channel_mask;
            }
            undoCreateChannel(_plugin);
            break;
      }

   }

}


class SampleViewUndoEntry {
   // undo transaction

   String name;
   StWaveform *waveform;    // reference to parent waveform
   SampleView *sample_view; // reference to parent SampleView

   int sel_startoff;
   int sel_endoff;       // startoff == endoff => no selection
   int sel_channel_mask; // 1=l, 2=r, 3=both

   PointerArray actions; // SampleViewUndAction instances

   int time_stamp;

   SampleViewUndoEntry *old_undo; // pushed onto undo stack when entry is redone


   public method init(SampleView _sv, StWaveform _waveform, String _name) {
      waveform    <= _waveform;
      sample_view <= _sv;
      name         = _name;

      // Save selection
      // trace "xxx undo: save selection=("+_sv.sel_startoff+";"+_sv.sel_endoff+")";
      sel_startoff     = _sv.sel_startoff;
      sel_endoff       = _sv.sel_endoff;
      sel_channel_mask = _sv.sel_channel_mask;

      time_stamp = milliSeconds();
   }

   public method free() {
      actions.free();
   }

   public method end() : boolean {
      // returns true if transaction is not empty
      // trace "[dbg] SampleViewUndoEntry::end: actions="+#(actions);
      return (actions.numElements > 0);
   }

   protected method allocAction(int _action, int _frameOffset, int _numFrames, int _chMask) : SampleViewUndoAction {

      // trace "xxx SampleViewUndo::allocAction("+_action+") frameOff="+_frameOffset+" numFrames="+_numFrames+" chMask="+_chMask;

      local SampleViewUndoAction ac;

      if(sel_channel_mask != _chMask)
      {
         trace "[dbg] SampleViewUndoEntry::allocAction: (sel_channel_mask != _chMask) ("+sel_channel_mask+" != "+_chMask+") name=\""+name+"\"";
      }

      ac.init(waveform, _action, _frameOffset, _numFrames, _chMask);

      actions.add(#(deref ac));

      return ac;
   }

   public method actionRemove(int _frameOffset, int _numFrames, int _chMask) {
      // called before given area is removed
      //  (redo=add)

      SampleViewUndoAction ac <= allocAction(SampleViewUndoAction.ACTION_REMOVE, _frameOffset, _numFrames, _chMask);

      ac.actionRemove();
   }

   public method actionModify(int _frameOffset, int _numFrames, int _chMask) {
      // called before given area is modified
      //  (redo=restore backup)

      SampleViewUndoAction ac <= allocAction(SampleViewUndoAction.ACTION_MODIFY, _frameOffset, _numFrames, _chMask);

      ac.actionModify();
   }

   public method actionAdd(int _frameOffset, int _numFrames, int _chMask) {
      // called after given area was added
      //  (redo=remove)

      SampleViewUndoAction ac <= allocAction(SampleViewUndoAction.ACTION_ADD, _frameOffset, _numFrames, _chMask);

      ac.actionAdd();
   }

   public method actionPhaseInvert(int _frameOffset, int _numFrames, int _chMask) {
      // called before given area is phase-inverted
      //  (redo=phase invert)

      SampleViewUndoAction ac <= allocAction(SampleViewUndoAction.ACTION_PHASEINVERT, _frameOffset, _numFrames, _chMask);

      ac.actionPhaseInvert();
   }

   public method actionReverse(int _frameOffset, int _numFrames, int _chMask) {
      // called before given area is reversed
      //  (redo=reverse)

      SampleViewUndoAction ac <= allocAction(SampleViewUndoAction.ACTION_REVERSE, _frameOffset, _numFrames, _chMask);

      ac.actionReverse();
   }

   public method actionDeleteChannel(int _chMask) {
      // called before channel is deleted
      //  (redo=add channel)

      SampleViewUndoAction ac <= allocAction(SampleViewUndoAction.ACTION_DELETECHANNEL, 0, 0, _chMask);

      ac.actionDeleteChannel();
   }

   public method actionCreateChannel(int _chMask) {
      // called before channel is created
      //  (redo=delete right channel)

      SampleViewUndoAction ac <= allocAction(SampleViewUndoAction.ACTION_CREATECHANNEL, 0, 0, _chMask);

      ac.actionCreateChannel();
   }

   public method calcMemUsage() : int {
      local SampleViewUndoAction *ac;
      local int r = 0;
      foreach ac in actions
      {
         r += ac.calcMemUsage();
      }

      if(null != old_undo)
      {
         r += old_undo.calcMemUsage();
      }

      return r;
   }

   public method undo(SampleViewPlugin _plugin, SampleViewUndoEntry _redoEntry) {
      // undo and init redo entry

      Global.Debug2("SampleViewUndoEntry::undo: transaction \""+name+"\" has "+(actions.numElements)+" actions");

      // Undo actions last to first
      SampleViewUndoAction *ac;
      int acIdx = (actions.numElements - 1);
      while(acIdx >= 0)
      {
         ac <= actions.get(acIdx);
         // trace "xxx undo ac.action="+ac.action;

         ac.undo(_plugin, _redoEntry);

         acIdx--;
      }

      // Restore selection
      sample_view.sel_startoff     = sel_startoff;
      sample_view.sel_endoff       = sel_endoff;
      sample_view.sel_channel_mask = sel_channel_mask;
   }

   public method redo(SampleViewPlugin _plugin) : SampleViewUndoEntry {
      // redo and return old undo entry

      // Redo actions last to first
      SampleViewUndoAction *ac;
      int acIdx = (actions.numElements - 1);
      while(acIdx >= 0)
      {
         ac <= actions.get(acIdx);

         ac.undo(_plugin, null);

         acIdx--;
      }

      // // // Redo actions first to last
      // SampleViewUndoAction *ac;
      // int acIdx = 0;
      // loop(actions.numElements)
      // {
      //    ac <= actions.get(acIdx);

      //    ac.undo(_plugin, null);

      //    acIdx++;
      // }


      // // actions.free();

      // Restore selection
      // trace "xxx undo: restore selection=("+sel_startoff+";"+sel_endoff+")";
      sample_view.sel_startoff     = sel_startoff;
      sample_view.sel_endoff       = sel_endoff;
      sample_view.sel_channel_mask = sel_channel_mask;

      SampleViewUndoEntry retOldUndo <= deref old_undo;
      old_undo <= null;
      return deref retOldUndo;
   }

}


class SampleViewUndo {

   StWaveform *waveform; // reference to parent waveform
   SampleView *sample_view;

   PointerArray entries; // SampleViewUndoEntry instances (newest entry is last)

   PointerArray redo_entries;

   int total_mem_usage_undo;
   int total_mem_usage_redo; // resets to 0 when new undo entry is created

   SampleViewUndoEntry redo_entry;


   public method init(SampleView _sv, StWaveform _waveform) {
      sample_view <= _sv;
      waveform <= _waveform;
      entries.alloc(STConfig.sampleview_undo_stack_size);
   }

   public method freeRedo() {
      redo_entries.free();
      total_mem_usage_redo = 0;
   }

   public method free() {
      entries.alloc(STConfig.sampleview_undo_stack_size);
      total_mem_usage_undo = 0;
   }

   public method getOldestUndoTimeStamp() : int {
      if(entries.numElements > 0)
      {
         SampleViewUndoEntry e <= entries[0];
         return e.time_stamp;
      }
      return -1;
   }

   public method getOldestRedoTimeStamp() : int {
      if(redo_entries.numElements > 0)
      {
         SampleViewUndoEntry e <= redo_entries[0];
         return e.time_stamp;
      }
      return -1;
   }

   public method freeOldestUndo() : boolean {
      if(entries.numElements > 0)
      {
         SampleViewUndoEntry e <= entries[0];
         total_mem_usage_undo -= e.calcMemUsage();
         entries.delete(0);
         return true;
      }
      return false;
   }

   public method freeOldestRedo() : boolean {
      if(redo_entries.numElements > 0)
      {
         SampleViewUndoEntry e <= redo_entries[0];
         total_mem_usage_redo -= e.calcMemUsage();
         redo_entries.delete(0);
         return true;
      }
      return false;
   }

   public method beginEntry(String _name) : SampleViewUndoEntry {
      // Discard oldest entry if stack is about to overflow
      if(entries.numElements == entries.maxElements)
      {
         SampleViewUndoEntry e <= entries[0];
         total_mem_usage_undo -= e.calcMemUsage();
         entries.delete(0);
      }

      local SampleViewUndoEntry r;
      r.init(sample_view, waveform, _name);
      entries.add(#(deref r));

      redo_entries.alloc(STConfig.sampleview_undo_stack_size);
      total_mem_usage_redo = 0;

      return r;
   }

   public method addRedoEntry(String _name) : SampleViewUndoEntry {
      // Discard oldest entry if stack is about to overflow
      if(redo_entries.numElements == redo_entries.maxElements)
      {
         SampleViewUndoEntry redoEntry <= redo_entries[0];
         total_mem_usage_redo -= redoEntry.calcMemUsage();
         redo_entries.delete(0);
      }

      local SampleViewUndoEntry r;
      r.init(sample_view, waveform, _name);
      redo_entries.add(#(deref r));

      return r;
   }

   public method endEntry() {

      SampleViewUndoEntry e <= entries.getLast();
      if(null != e)
      {
         if(!e.end())
         {
            // Discard last entry (e) if nothing was actually modified
            entries.numElements = entries.numElements - 1;
            trace "[dbg] SampleViewUndo::endEntry: no modification, discarding entry";
         }
         else
         {
            total_mem_usage_undo += e.calcMemUsage();
            // trace "xxx total_mem_usage="+total_mem_usage;
         }
      }
      else
      {
         trace "[---] SampleViewUndo::endEntry: internal error: no current entry";
      }

   }

   public method undo(SampleViewPlugin _plugin) {

      if(entries.numElements > 0)
      {
         SampleViewUndoEntry e <= entries.getDeref(entries.numElements - 1);

         total_mem_usage_undo -= e.calcMemUsage();

         Global.Debug("SampleViewUndo::undo: undoing \""+e.name+"\"");

         SampleViewUndoEntry redoEntry <= addRedoEntry("redo "+e.name);

         e.undo(_plugin, redoEntry);

         redoEntry.old_undo <= deref e;
         total_mem_usage_redo += redoEntry.calcMemUsage();

         entries.numElements = entries.numElements - 1;
      }
      else
      {
         Global.Print("SampleView: nothing to undo.");
      }
   }

   public method redo(SampleViewPlugin _plugin) {
      // trace "xxx ---------- REDO -------------";
      if(redo_entries.numElements > 0)
      {
         SampleViewUndoEntry redoEntry <= redo_entries.getDeref(redo_entries.numElements - 1);

         total_mem_usage_redo -= redoEntry.calcMemUsage();

         SampleViewUndoEntry oldUndo <= redoEntry.redo(_plugin);

         entries.add(#(deref oldUndo));

         total_mem_usage_undo += oldUndo.calcMemUsage();

         redoEntry.free();

         redo_entries.numElements = redo_entries.numElements - 1;
      }
   }

   public method getUndoMemUsageString() : String {
      Float f = total_mem_usage_undo / (1024.0f*1024);
      return f.printf("%.2f");
   }

   public method getRedoMemUsageString() : String {
      Float f = total_mem_usage_redo / (1024.0f*1024);
      return f.printf("%.2f");
   }

   public method getNumUndoEntries() : int {
      return entries.numElements;
   }

   public method getNumRedoEntries() : int {
      return redo_entries.numElements;
   }

}
