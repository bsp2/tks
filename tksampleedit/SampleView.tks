// ----
// ---- file   : SampleView.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2009-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 25Oct2009
// ---- changed: 31Jan2010, 06Feb2010, 03Mar2010, 29Apr2010, 11May2010, 14May2010, 24Jun2010
// ----          05Sep2010, 09Sep2010, 06Feb2011, 25Feb2011, 26Feb2011, 14Mar2011, 17Mar2011
// ----          18Mar2011, 20Mar2011, 02Feb2012, 26Jun2012, 23Dec2012, 04May2013, 08May2013
// ----          31May2013, 01Jun2013, 02Jun2013, 03Jun2013, 12Aug2014, 06Sep2015, 07Sep2015
// ----          12Sep2015, 27Nov2018, 13Dec2018, 15Dec2018, 16Dec2018, 17Dec2018, 18Dec2018
// ----          21Dec2018, 22Dec2018, 30Dec2018, 31Dec2018, 03Jan2019, 04Jan2019, 11Feb2019
// ----          09May2019, 18Jun2019, 19Jun2019, 19Jul2019, 21Jul2019, 28Jul2019, 07Aug2019
// ----          10Sep2019, 02Nov2019, 09Feb2020, 14Feb2020, 20Feb2020, 02Mar2020, 05May2020
// ----          14May2020, 09Jun2020, 10Jun2020, 21Aug2020, 12Sep2020, 14Sep2020, 15Oct2020
// ----          17Oct2020, 06Feb2021, 07Feb2021, 27Apr2021, 05May2021, 26Aug2021, 12Dec2021
// ----          22Dec2021, 05Feb2022, 09Apr2022, 13May2022, 14May2022, 09Jul2022, 13Aug2022
// ----          31Dec2022, 04Jan2023, 24Mar2023, 01Apr2023, 10Aug2023, 11Aug2023, 13Aug2023
// ----          18Aug2023, 20Aug2023, 14Sep2023, 04Oct2023, 11Oct2023, 31Oct2023, 10Nov2023
// ----          11Nov2023, 16Nov2023, 22Nov2023, 07Dec2023, 14Dec2023, 16Dec2023, 24Mar2024
// ----          10Aug2024, 01Nov2024, 10Jan2025, 06Apr2025, 06May2025, 20May2025, 21Jun2025
// ----          02Sep2025, 11Sep2025, 13Sep2025, 16Sep2025
// ----
// ----
// ----

module MSampleView;

use namespace ui;

// (note) keyboard shortcut docs moved to Eureka doc (index.md)

/*
    lctrl-lshift-SPACE : Show all
           lctrl-SPACE : Fit selection to window or show all
        lctrl-lshift-a : Select none
          LMB dblclick : Set selection to highlighted area or Select none
               lctrl-a : Select all / show all
               lctrl-b : Declick selection end (512 sample frames fade out)
        lctrl-lshift-b : Declick selection start (512 sample frames fade in)
               lctrl-c : Copy selection to clipboard
        lctrl-lshift-c : Append selection to clipboard
                RETURN : Append selection to clipboard
               lctrl-d : Silence selection
        lctrl-lshift-d : Surround selection with silence (for transient detection tools)
                     e : Select and zoom to highlighted area
               lctrl-e : (partially handled by SampleView) Export selection to WAV (send event)
        lctrl-lshift-e : (partially handled by SampleView) Multi-Export regions to WAV (send event)
               lctrl-f : Fade-out selection
        lctrl-lshift-f : Fade-in selection
               lctrl-g : Toggle show highlight
               lctrl-h : Copy selection to highlight (modifies either sampleoff/len or current loop off/len)
               lctrl-i : Toggle show RMS
               lctrl-j : Toggle show regions
              lshift-j : Toggle RMS autoshop mode
        lctrl-lshift-j : Toggle autochop dialog
        lctrl-lshift-i : Toggle show samples
               lctrl-k : Delete left channel
        lctrl-lshift-k : Delete right channel
        lctrl-lshift-l : Clear undo/redo history
               lctrl-m : Convert to mono
        lctrl-lshift-m : Convert to stereo
               lctrl-n : Normalize selection
        lctrl-lshift-n : Normalize regions
               lctrl-o : Amplify selection (show dialog)
               lctrl-p : Phase-invert selection
               lctrl-q : Select next region, or select next cycle (in cycle-edit mode) (same as cursor RIGHT)
        lctrl-lshift-q : Select previous region, or select previous cycle (in cycle-edit mode) (same as cursor LEFT)
               lctrl-r : Reverse selection
        lctrl-lshift-r : Crossfade selection
              lshift-r : Loop-xfade selection. Needs 128 frames before selection start.
               lctrl-s : Tighten selection (via transient detection)
                     s : Toggle BPM snap / Marker snap (off (zero-crossing if enabled) => marker => bpm)
             MMB click : Toggle BPM snap / Marker snap (off (zero-crossing if enabled) => marker => bpm)
              lshift-s : Cycle BPM snap grid (1/16, 1/8, 1/4, 1/1)
        lctrl-lshift-s : Show SoX processing dialog
               lctrl-t : Truncate to selection
        lctrl-lshift-t : Auto-trim (select all, tighten selection, trim)
               lctrl-v : Paste clipboard at end of selection
        lctrl-lshift-v : Replace selection by clipboard
              lshift-v : Add clipboard to selection (mix)
               lctrl-w : Cut selection to clipboard
               lctrl-y : Undo
        lctrl-lshift-y : Redo
               lctrl-z : Toggle snap-to-zero-crossing mode ('y' on german kbd)
              MMB hold : Toggle snap-to-zero-crossing mode ('y' on german kbd)
              lshift-z : Toggle cycle edit mode ('y' on german kbd)
                    UP : Zoom in
                  DOWN : Zoom out
                  LEFT : Select previous region, or select previous cycle (in cycle-edit mode)
            lctrl-LEFT : Scroll left
     lctrl-lshift-LEFT : Move region left (+add silence around region)
                 RIGHT : Select next region, or select next cycle (in cycle-edit mode)
           lctrl-RIGHT : Scroll right
                     ` : Toggle freedraw mode (^ on german kbd)
    lctrl-lshift-RIGHT : Move region right (+add silence around region)
                DELETE : Delete selection
                  HOME : Move selection start to 0
                   END : Set selection start to end of selection or end of wave
            lshift-END : Expand selection end to end of waveform
                          Press twice to move selection start to end of wave
         WHEEL UP/DOWN : Zoom in/out
                          Select previous/next cycle (in cycle-edit mode)
                          Select previous/next region (when selection exceeds max cycle length)
         lctrl + WHEEL : Zoom vertically
                          Zoom in/out (in cycle-edit mode)
         lctrl + WHEEL : Zoom vertically in cycle mode
       RMB + MOUSEMOVE : Scroll left/right
       LMB + MOUSEMOVE : Mark region / autoscroll
              RMB hold : Show popup menu
                   MMB : Cycle bpm/marker snap modes  (old: Toggle cycle-edit mode)
       lctrl-LMB click : Toggle marker

 */


class SampleViewPlugin {

   public abstract svBeginReallocSamples () { }
   public abstract svHandleDeleteRegion  (int offset, int len) { }
   public abstract svHandleInsertRegion  (int offset, int len) { }
   public abstract svHandleMoveRegion    (int oldOffset, int len, int newOffset) { }
   public abstract svEndReallocSamples   () { }

   public method svHandleRenderHighlightChanged(boolean _bEnabled) { }
   public method svHandleViewChanged() { }
   public method svHandleMarkerChanged(int _markerIdx, int _start, int _end) { }
}


class SampleViewAutochopConfig {

   // RMS default:
   float startThreshold;
   float startMinThreshold;
   int   startMinNumFramesBack;
   float endThreshold;
   int   endNumFramesThreshold;
   int   restartNumFramesThreshold;
   float restartRMSRatioShort;
   float restartRMSRatioLong;
   int   restartRMSRatioLongNumFrames;
   float restartRMSRatioImm;
   float rmsPeakRatio;
   float restartThresholdImm;
   int   restartRewindNumFrames;
   float rmsAvgSlew;

   // slewed
   float slewed_hpf;
   float slewed_rmsWindowSize;  // ms
   float slewed_timeout;  // ms
   float slewed_rmsSlew;
   float slewed_avgPeakRatioSlew;
   float slewed_avgPeakRatioThreshold;


   public method init() {
      // init1();
      init2();
      // init3();
      // init4();
      // init5();
   }

   public method debugPrint() {
      trace "     startThreshold               = "+startThreshold+";";
      trace "     startMinThreshold            = "+startMinThreshold+";";
      trace "     startMinNumFramesBack        = "+startMinNumFramesBack+";";
      trace "     endThreshold                 = "+endThreshold+";";
      trace "     endNumFramesThreshold        = "+endNumFramesThreshold+";";
      trace "     restartNumFramesThreshold    = "+restartNumFramesThreshold+";";
      trace "     restartRMSRatioShort         = "+restartRMSRatioShort+";";
      trace "     restartRMSRatioLong          = "+restartRMSRatioLong+";";
      trace "     restartRMSRatioLongNumFrames = "+restartRMSRatioLongNumFrames+";";
      trace "     restartRMSRatioImm           = "+restartRMSRatioImm+";";
      trace "     rmsPeakRatio                 = "+rmsPeakRatio+";";
      trace "     restartThresholdImm          = "+restartThresholdImm+";";
      trace "     restartRewindNumFrames       = "+restartRewindNumFrames+";";
      trace "     rmsAvgSlew                   = "+rmsAvgSlew+";";

      trace "     slewed_hpf                   = "+slewed_hpf+";";
      trace "     slewed_rmsWindowSize         = "+slewed_rmsWindowSize+";";
      trace "     slewed_timeout               = "+slewed_timeout+";";
      trace "     slewed_rmsSlew               = "+slewed_rmsSlew+";";
      trace "     slewed_avgPeakRatioSlew      = "+slewed_avgPeakRatioSlew+";";
      trace "     slewed_avgPeakRatioThreshold = "+slewed_avgPeakRatioThreshold+";";
   }

   public method lerp(SampleViewAutochopConfig a, SampleViewAutochopConfig b, float amt) {
      startThreshold               = mathLerpf(a.startThreshold,               b.startThreshold,               amt);
      startMinThreshold            = mathLerpf(a.startMinThreshold,            b.startMinThreshold,            amt);
      startMinNumFramesBack        = mathLerpf(a.startMinNumFramesBack,        b.startMinNumFramesBack,        amt);
      endThreshold                 = mathLerpf(a.endThreshold,                 b.endThreshold,                 amt);
      endNumFramesThreshold        = mathLerpf(a.endNumFramesThreshold,        b.endNumFramesThreshold,        amt);
      restartNumFramesThreshold    = mathLerpf(a.restartNumFramesThreshold,    b.restartNumFramesThreshold,    amt);
      restartRMSRatioShort         = mathLerpf(a.restartRMSRatioShort,         b.restartRMSRatioShort,         amt);
      restartRMSRatioLong          = mathLerpf(a.restartRMSRatioLong,          b.restartRMSRatioLong,          amt);
      restartRMSRatioLongNumFrames = mathLerpf(a.restartRMSRatioLongNumFrames, b.restartRMSRatioLongNumFrames, amt);
      restartRMSRatioImm           = mathLerpf(a.restartRMSRatioImm,           b.restartRMSRatioImm,           amt);
      rmsPeakRatio                 = mathLerpf(a.rmsPeakRatio,                 b.rmsPeakRatio,                 amt);
      restartThresholdImm          = mathLerpf(a.restartThresholdImm,          b.restartThresholdImm,          amt);
      restartRewindNumFrames       = mathLerpf(a.restartRewindNumFrames,       b.restartRewindNumFrames,       amt);
      rmsAvgSlew                   = mathLerpf(a.rmsAvgSlew,                   b.rmsAvgSlew,                   amt);

      slewed_hpf                    = mathLerpf(a.slewed_hpf,                   b.slewed_hpf,                   amt);
      slewed_rmsWindowSize          = mathLerpf(a.slewed_rmsWindowSize,         b.slewed_rmsWindowSize,         amt);
      slewed_timeout                = mathLerpf(a.slewed_timeout,               b.slewed_timeout,               amt);
      slewed_rmsSlew                = mathLerpf(a.slewed_rmsSlew,               b.slewed_rmsSlew,               amt);
      slewed_avgPeakRatioSlew       = mathLerpf(a.slewed_avgPeakRatioSlew,      b.slewed_avgPeakRatioSlew,      amt);
      slewed_avgPeakRatioThreshold  = mathLerpf(a.slewed_avgPeakRatioThreshold, b.slewed_avgPeakRatioThreshold, amt);
   }

   public method newConfigByIdx(int _idx) : SampleViewAutochopConfig {
      local SampleViewAutochopConfig r;
      switch(_idx)
      {
         case 0:
            r.init1();
            break;

         case 1:
            r.init2();
            break;

         case 2:
            r.init3();
            break;

         case 3:
            r.init4();
            break;

         case 4:
            r.init5();
            break;

         case 5:
            r.init6();
            break;

         case 6:
            r.init7();
            break;

         case 7:
            r.init8();
            break;
      }
      return deref r;
   }

   public method initFromSensitivity(float _f) {
      int aIdx = int(_f) % 8;
      int bIdx = (int(_f)+1) % 8;
      local SampleViewAutochopConfig a <= newConfigByIdx(aIdx);
      local SampleViewAutochopConfig b <= newConfigByIdx(bIdx);
      lerp(a, b, frac(_f));
   }

   // public method init1() {
   //    // first config (creatd in source)
   //    startThreshold            = 0.107;
   //    startMinThreshold         = 0.02;  // for catching entire transient
   //    startMinNumFramesBack     = 512;
   //    endThreshold              = 0.001;
   //    endNumFramesThreshold     = 1984;
   //    restartNumFramesThreshold = 2500;

   //    // (note) 1.5 is low enough for funkydrummer hihat after snare
   //    // (note) 2.0 is high enough for tambourine+tabla loop
   //    restartRMSRatioShort      = 1.8;//1.6;//1.2;   // RMS must be <n> times higher than past average RMS before allowing restart
   //    restartRMSRatioLong       = 1.4;
   //    restartRMSRatioLongNumFrames = 12000;
   //    restartRMSRatioImm        = 9.0;   // immediately start new region when squared level exceeds RMS by this factor
   //    rmsPeakRatio              = 2.3f;
   //    restartThresholdImm       = 0.2;   //  ^^ + level exceeds this value
   //    restartRewindNumFrames    = 100;
   //    rmsAvgSlew                = 0.0035;//0.01;//0.008f;
   // }

   // public method init2() {
   //    // improved config (created via UI editor)
   //    startThreshold            = 0.005;
   //    startMinThreshold         = 0.02;
   //    startMinNumFramesBack     = 512;
   //    endThreshold              = 0.001;
   //    endNumFramesThreshold     = 1984;
   //    restartNumFramesThreshold = 2500;
   //    restartRMSRatioShort      = 2.34901;
   //    restartRMSRatioLong       = 1.4;
   //    restartRMSRatioLongNumFrames = 5878;
   //    restartRMSRatioImm        = 9.0;   // immediately start new region when squared level exceeds RMS by this factor
   //    rmsPeakRatio              = 1.2f;
   //    restartThresholdImm       = 0.2;   //  ^^ + level exceeds this value
   //    restartRewindNumFrames    = 100;
   //    rmsAvgSlew                = 0.00208;//0.01;//0.008f;
   // }

   // public method init3() {
   //    // improved config (created via UI editor)
   //    startThreshold            = 0.14863;
   //    startMinThreshold         = 0.02;
   //    startMinNumFramesBack     = 512;
   //    endThreshold              = 0.001;
   //    endNumFramesThreshold     = 1984;
   //    restartNumFramesThreshold = 2500;
   //    restartRMSRatioShort      = 2.34901;
   //    restartRMSRatioLong       = 1.4;
   //    restartRMSRatioLongNumFrames = 5878;
   //    restartRMSRatioImm        = 2.9327;   // immediately start new region when squared level exceeds RMS by this factor
   //    rmsPeakRatio              = 1.2f;
   //    restartThresholdImm       = 0.1;   //  ^^ + level exceeds this value
   //    restartRewindNumFrames    = 100;
   //    rmsAvgSlew                = 0.00059;//0.01;//0.008f;
   // }

   // public method init4() {
   //   startThreshold               = 0.26703;
   //   startMinThreshold            = 0.02;
   //   startMinNumFramesBack        = 512;
   //   endThreshold                 = 0.001;
   //   endNumFramesThreshold        = 1984;
   //   restartNumFramesThreshold    = 2500;
   //   restartRMSRatioShort         = 2.34901;
   //   restartRMSRatioLong          = 1.4;
   //   restartRMSRatioLongNumFrames = 5878;
   //   restartRMSRatioImm           = 2.9327;
   //   rmsPeakRatio                 = 1.2;
   //   restartThresholdImm          = 0.1;
   //   restartRewindNumFrames       = 100;
   //   rmsAvgSlew                   = 0.00059;
   // }

   public method init1() {
      // general purpose, low sensitivity (funkydrummer)
     startThreshold               = 0.10639;
     startMinThreshold            = 0.02;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 1984;
     restartNumFramesThreshold    = 2775;
     restartRMSRatioShort         = 2.34901;
     restartRMSRatioLong          = 1.4;
     restartRMSRatioLongNumFrames = 5878;
     restartRMSRatioImm           = 1.83667;
     rmsPeakRatio                 = 1.2;
     restartThresholdImm          = 0.65667;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.00059;

     slewed_hpf                   = 0.0032;
     slewed_rmsWindowSize         = 2.77384;
     slewed_timeout               = 42.0;
     slewed_rmsSlew               = 1.66778;
     slewed_avgPeakRatioSlew      = 0.08691;
     slewed_avgPeakRatioThreshold = 2.46528;
   }

   public method init2() {
      // general purpose, medium sensitivity
     startThreshold               = 0.15639;
     startMinThreshold            = 0.02;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 1984;
     restartNumFramesThreshold    = 2775;
     restartRMSRatioShort         = 2.34901;
     restartRMSRatioLong          = 1.4;
     restartRMSRatioLongNumFrames = 5878;
     restartRMSRatioImm           = 1.83667;
     rmsPeakRatio                 = 1.2;
     restartThresholdImm          = 0.65667;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.00059;

     slewed_hpf                   = 0.00293;
     slewed_rmsWindowSize         = 1.0001;
     slewed_timeout               = 42.0;
     slewed_rmsSlew               = 0.27033;
     slewed_avgPeakRatioSlew      = 0.15239;
     slewed_avgPeakRatioThreshold = 3.55565;
   }

   public method init3() {
      // general purpose, high threshold
     startThreshold               = 0.25041;
     startMinThreshold            = 0.02;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 1984;
     restartNumFramesThreshold    = 2775;
     restartRMSRatioShort         = 2.34901;
     restartRMSRatioLong          = 1.4;
     restartRMSRatioLongNumFrames = 5878;
     restartRMSRatioImm           = 1.83667;
     rmsPeakRatio                 = 1.2;
     restartThresholdImm          = 0.65667;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.00059;

     slewed_hpf                   = 0.00293;
     slewed_rmsWindowSize         = 0.93501;
     slewed_timeout               = 42.0;
     slewed_rmsSlew               = 0.51349;
     slewed_avgPeakRatioSlew      = 0.16704;
     slewed_avgPeakRatioThreshold = 2.0789;
   }

   public method init4() {
      // high sensitivity, e.g. DJS101561.wav
     startThreshold               = 0.01048;
     startMinThreshold            = 0.01512;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 885;
     restartNumFramesThreshold    = 2402;
     restartRMSRatioShort         = 1.18581;
     restartRMSRatioLong          = 1.1;
     restartRMSRatioLongNumFrames = 6674;
     restartRMSRatioImm           = 1.85366;
     rmsPeakRatio                 = 2.14282;
     restartThresholdImm          = 0.20003;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.06496;

     slewed_hpf                   = 0.00293;
     slewed_rmsWindowSize         = 1.0001;
     slewed_timeout               = 42.0;
     slewed_rmsSlew               = 0.6131;
     slewed_avgPeakRatioSlew      = 0.252;
     slewed_avgPeakRatioThreshold = 2.72952;
   }

   public method init5() {
      // high sensitivity
     startThreshold               = 0.01048;
     startMinThreshold            = 0.001;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 885;
     restartNumFramesThreshold    = 1287;
     restartRMSRatioShort         = 1.18581;
     restartRMSRatioLong          = 1.1;
     restartRMSRatioLongNumFrames = 6674;
     restartRMSRatioImm           = 1.85366;
     rmsPeakRatio                 = 2.14282;
     restartThresholdImm          = 0.20003;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.04177;

     //**
     slewed_hpf                   = 0.0032;
     slewed_rmsWindowSize         = 2.77384;
     slewed_timeout               = 42.0;
     slewed_rmsSlew               = 1.66778;
     slewed_avgPeakRatioSlew      = 0.08691;
     slewed_avgPeakRatioThreshold = 2.46528;
   }

   public method init6() {
      // high sensitivity
     startThreshold               = 0.01048;
     startMinThreshold            = 0.01512;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 885;
     restartNumFramesThreshold    = 2402;
     restartRMSRatioShort         = 1.18581;
     restartRMSRatioLong          = 1.1;
     restartRMSRatioLongNumFrames = 6674;
     restartRMSRatioImm           = 1.85366;
     rmsPeakRatio                 = 2.14282;
     restartThresholdImm          = 0.20003;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.01;

     slewed_hpf                   = 0.18299;
     slewed_rmsWindowSize         = 2.05631;
     slewed_timeout               = 104.456;
     slewed_rmsSlew               = 4.28857;
     slewed_avgPeakRatioSlew      = 0.03141;
     slewed_avgPeakRatioThreshold = 2.79253;
   }

   public method init7() {
     startThreshold               = 0.11085;
     startMinThreshold            = 0.0175742;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 1437;
     restartNumFramesThreshold    = 4096;
     restartRMSRatioShort         = 1.77078;
     restartRMSRatioLong          = 1.25087;
     restartRMSRatioLongNumFrames = 6273;
     restartRMSRatioImm           = 2.325;
     rmsPeakRatio                 = 1.66868;
     restartThresholdImm          = 0.429674;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.0325883;

     slewed_hpf                   = 0.00487;
     slewed_rmsWindowSize         = 4.44028;
     slewed_timeout               = 20.4772;
     slewed_rmsSlew               = 1.84082;
     slewed_avgPeakRatioSlew      = 0.45296;
     slewed_avgPeakRatioThreshold = 1.5273;
   }

   public method init8() {
     startThreshold               = 0.10639;
     startMinThreshold            = 0.02;
     startMinNumFramesBack        = 512;
     endThreshold                 = 0.001;
     endNumFramesThreshold        = 1984;
     restartNumFramesThreshold    = 2775;
     restartRMSRatioShort         = 2.34901;
     restartRMSRatioLong          = 5.22856;
     restartRMSRatioLongNumFrames = 5878;
     restartRMSRatioImm           = 1.1;
     rmsPeakRatio                 = 1.1;
     restartThresholdImm          = 0.48942;
     restartRewindNumFrames       = 54;
     rmsAvgSlew                   = 0.00059;

     slewed_hpf                   = 0.04975;
     slewed_rmsWindowSize         = 1.45218;
     slewed_timeout               = 116.661;
     slewed_rmsSlew               = 0.20624;
     slewed_avgPeakRatioSlew      = 0.0391;
     slewed_avgPeakRatioThreshold = 2.13888;

   }
}

class SampleView : Control {

   define int   DECLICK_NUM_FRAMES         = 512;
   define int   NUM_BORDER_SILENCE_FRAMES  = 2048;
   define float AUTOCHOP_MIN_THRESHOLD_LOW = 0.0001;
   define float AUTOCHOP_MIN_THRESHOLD_DEF = 0.005;
   define int   CYCLEMODE_MAX_NUM_FRAMES   = 2048;

   define float AUTOTRIM_MIN_THRESHOLD_BEG = 0.001f;
   define float AUTOTRIM_MIN_THRESHOLD_END = 0.0005f;

   define String TA_PLAY_MARKER;
   define String TA_MOUSE_AUTOSCROLL;
   define String TA_KEY_SCROLL;

   define float MIN_SIZE_Y = 64;

   define float MARKER_PY = 14;
   define float MARKER_SY = 4;

   define int SELECTION_AUTOSCROLL_SX = 24;

   define int SELINFO_SY = 20;  // upper and lower areas
   // // define int SELINFO_SX = 300;
   define int AREAINFO_VALUE_SX = 60;

   define String ACTION_WAVEFORM_CHANGED     = "onWaveformChanged"; // when wf length changes
   define String ACTION_SELECTION_CHANGED    = "onSelectionChanged";
   define String ACTION_HIGHLIGHT_CHANGED    = "onHighlightChanged";
   define String ACTION_REGION_SELECTED      = "onRegionSelected";  // autochop region selected
   define String ACTION_EXPORT_SELECTION     = "onExportSelection";
   define String ACTION_MULTI_EXPORT_REGIONS = "onMultiExportRegions";
   define String ACTION_DROP_FILES           = "onDropFiles";
   define String ACTION_AUTOCHOP_MODE        = "onAutoChopModeChanged";

   define int CHANNEL_MASK_L  = 1;
   define int CHANNEL_MASK_R  = 2;
   define int CHANNEL_MASK_LR = 3;

   protected StWaveform *waveform;
   protected FloatArray *samples;
   protected int         num_channels;
   protected float       sample_rate;
   protected Double      zoom; // 0..1, 1=fit sample to widget, 0.25=show 1/4 of sample
   protected float       offset; // relative offset

   protected float min_sample; // displayed value range (usually (-1; 1))
   protected float max_sample;
   protected float zoom_y;
   protected int zoom_y_idx;
   protected static FloatArray zoom_y_tbl = [
      1.0,
      0.75,
      0.5,
      0.375,
      0.25,
      0.175,
      0.1
                                             ];

   protected int color_bg;
   protected int color_samples;
   protected int color_samples_lines_fallback;
   protected int color_samples_lines_skip;
   protected int color_samples_lines_outer_skip;
   protected int color_samples_lines_outer;
   protected int color_gradient_sharpen;
   protected int color_samples_freedraw;
   protected int color_samples_drawing;
   protected int color_rms_zoom_out;
   protected int color_rms;
   protected int color_rms_zoom;     // #vis >= size_x
   protected int color_rms_zoom_in;  // #vis < size_x
   protected int color_rms_drawing;
   protected int color_centerline;
   protected int color_slider_bg;
   protected int color_slider_knob;
   protected int color_slider_outline;
   protected int color_highlight;
   protected int color_highlight_border;
   protected int color_selection;
   protected int color_selection_border;
   protected int color_areainfo_bg;
   protected int color_areainfo_label;
   protected int color_areainfo_value;
   protected int color_areainfo_valuesdw;  // text shadow
   protected int color_playoff_bg;
   protected int color_playoff;
   protected int color_regions;
   protected int color_regions_handle;

   static FloatArray clipboard_samples;
   static int        clipboard_num_channels;
   static int        clipboard_modification_time;

   define int RS_DOTS               = 0;  // see render_sample.cpp
   define int RS_LINES              = 1;  // see render_sample.cpp
   define int RS_DELTA              = 2;  // see render_sample.cpp
   define int RS_GRADIENT           = 3;  // see render_sample.cpp
   define int RS_LINES_OUTER        = 4;
   define int RS_GRADIENT_AND_LINES = 5;  // RS_GRADIENT + RS_LINES_OUTER
   define int RS_NUM                = 6;
   protected int render_style;
   protected int render_style_normal;
   protected int render_style_freedraw;
   static StringArray render_style_names = ["DOTS", "LINES", "DELTA", "GRADIENT", "GRADIENT+LINES"];


   define int IS_SH         = 0;
   define int IS_LINEAR     = 1;
   define int IS_SMOOTHSTEP = 2;
   define int IS_AVG8       = 3;
   define int IS_NUM        = 4;
   protected int interpol_style;
   protected int interpol_style_normal;
   protected int interpol_style_freedraw;
   static StringArray interpol_style_names = ["SH", "LINEAR", "SMOOTHSTEP", "AVG8"];

   define float SCROLLBAR_POSY   =  1.0;
   define float SCROLLBAR_HEIGHT = 17.0;

   protected boolean b_render_samples;
   protected boolean b_render_rms;
   protected boolean b_render_highlight;
   protected boolean b_render_regions;

   protected float last_rel_x;
   protected float grab_lmb_relknoboff;
   protected boolean b_grab_lmb_scrollbar;
   protected boolean b_grab_lmb_selection;
   protected boolean b_grab_rmb;  // true while scrolling with RMB drag
   protected boolean b_rmb_dragged; // true if mouse was actually dragged while RMB was pressed

   define int GRAB_NONE           = 0;
   define int GRAB_NEWSELECTION   = 1;
   define int GRAB_HLSTART        = 2;
   define int GRAB_HLEND          = 3;
   define int GRAB_SELSTART       = 4;
   define int GRAB_SELEND         = 5;
   protected int grab_mode;

   protected int grab_initial_startoff;  // for RMB mini-undo (hl/sel start or end offset when LMB drag begins)
   protected int grab_initial_endoff;    // (note) start/end might have been swapped during LMB drag
   protected int grab_initial_sel_channel_mask;

   protected int hl_startoff;
   protected int hl_endoff;   // if <= startoff, do not highlight

   public int sel_startoff;
   public int sel_endoff; // startoff == endoff => no selection
   public int sel_channel_mask; // 1=l, 2=r, 3=both

   protected PopupMenu *context_menu;

   protected Font *font;
   protected int stringh;
   protected int stringw_hl_start;
   protected int stringw_hl_end;
   protected int stringw_hl_len;
   protected int stringw_sel_start;
   protected int stringw_sel_end;
   protected int stringw_sel_len;
   protected int stringw_vis;

   protected FloatParamEditor *fp_area;
   protected int fp_area_mode;
   define int FPAREAMODE_NONE  = 0;
   define int FPAREAMODE_SELSTART = 1;
   define int FPAREAMODE_SELEND   = 2;
   define int FPAREAMODE_SELLEN   = 3;
   define int FPAREAMODE_HLSTART  = 4;
   define int FPAREAMODE_HLEND    = 5;
   define int FPAREAMODE_HLLEN    = 6;

   protected int play_offset; // used if waveform reference is null
   protected int last_play_offset;
   protected TimerAction playTimerAction;

   protected TimerAction autoscrollTimerAction; // used to scroll song offset when mouse is in lower/upper region
   protected boolean b_autoscroll_timer_scheduled = false;
   protected int        autoscroll_dir;
   protected MouseEvent autoscroll_ev;

   protected boolean b_freedraw; // true= replace samples by painting over them with the mouse, false=use LMB drag to move markers
   protected boolean b_drawing;
   protected boolean b_restart_freedraw_undo;
   protected int     freedraw_last_offset;
   protected float   freedraw_last_value;

   protected boolean b_cycle_mode; // see beginCycleMode()
   protected boolean b_zerox_mode; // 1=snap selection to nearest zero-crossing

   protected SampleViewPlugin *plugin;

   protected int key_scroll_dir;
   protected TimerAction ta_key_scroll;

   public boolean b_readonly;
   public boolean b_may_realloc;

   protected SampleViewUndoEntry *ue; // current undo transaction

   SampleViewAutochopConfig autochop_config;
   protected static SampleViewAutochopDialog *dlg_autochop;

   public boolean b_autorecalc_autochop;  // true=chop samples when new waveform is set
   boolean b_autochop;  // false=disable autochop (e.g. override by PageSample sample zone start markers)
   IntArray autochop_start_offsets;
   IntArray autochop_end_offsets;
   boolean b_autochop_rms;  // true=splits are based on RMS ratio, false=use level thresholds, maybe=alternative RMS mode
   protected int drag_region_idx;
   protected IntArray drag_undo_autochop_start_offsets;
   protected IntArray drag_undo_autochop_end_offsets;
   boolean b_marker_create;  // true=allow LMB-click
   boolean b_marker_delete;  // true=allow RMB-click

   boolean b_allow_channel_conversion;
   boolean b_autoadd_stereo_channel;  // true=convert to stereo when pasting stereo clipboard (def=false)

   protected int ondropfiles_frame_off;

   protected boolean b_lnf_dark;

   protected boolean b_draw_bevel_border;
   protected boolean b_draw_tabfocus_border;

   public boolean b_region_auto_cyclemode;  // true=start cycle-edit mode when region is selected with dblclick

   public int wavetable_cycle_len;  // hint for cycle edit mode
   public int wavetable_cycle_off;  //

   public int last_loop_crossfade_num_frames;
   protected TextInputDialog *dlg_num_frames;

   protected FloatParamDialog    *dlg_scale;
   protected SampleViewSoXDialog *dlg_sox;

   public boolean b_no_export;  // 1=hide export options in context menu

   protected static float bpm;
   protected int bpm_snap_grid = 4;  // 1=whole note, 4=quarter note, 8=half note, 16=1/16th
   protected int cur_snap_num;
   protected int last_snap_num;
   protected boolean b_bpm_snap;
   protected int bpm_snap_ref_frame;  // selection start when snap mode was enabled

   protected boolean b_marker_snap;

   protected static Texture *tex_gradient;

   static int     render_style_normal_default   = RS_GRADIENT_AND_LINES;
   static int     render_style_freedraw_default = RS_LINES;
   static boolean b_render_rms_default          = true;


   public method initSampleView() {
      initControl();

      b_may_realloc = true;

      b_render_samples   = true;
      b_render_rms       = true;
      b_render_highlight = true;

      b_freedraw       = false;
      b_drawing        = false;
      freedraw_last_offset = -1;

      render_style_normal   = render_style_normal_default;
      b_render_rms          = b_render_rms_default;
      // interpol_style_normal = IS_SMOOTHSTEP;
      interpol_style_normal = IS_LINEAR;

      render_style_freedraw   = render_style_freedraw_default;
      interpol_style_freedraw = IS_SH;

      render_style   = render_style_normal;
      interpol_style = interpol_style_normal;

      setSampleRange(-1.0f, 1.0f);

      highlightNone();
      selectNone();

      fp_area <= new FloatParamEditor;
      fp_area.initEditor();
      fp_area.addActionConsumer(this);

      playTimerAction.setActionName(TA_PLAY_MARKER);
      playTimerAction.setActionConsumer(this);
      play_offset = -1;
      last_play_offset = -1;

      ta_key_scroll.init(TA_KEY_SCROLL, this, 30);

      b_editable = true;

      zoom_y = 1.0;
      zoom_y_idx = 0;

      b_allow_channel_conversion = true;

      autochop_config.init();
      b_region_auto_cyclemode = true;
      b_autochop_rms = false;
      b_autochop = true;
      b_render_regions = true;
      b_marker_create = true;
      b_marker_delete = true;

      last_loop_crossfade_num_frames = 128;

      b_zerox_mode = true;

      drag_region_idx = -1;
   }

   protected method loadColorsLight() {
      color_bg                       = #f0a8a39f;  // COLOR_CUSTOM_EDITOR_BG_LIGHT
      color_samples                  = #80111111;  // #80111111  #a0777777
      color_samples_lines_fallback   = #80111111;  // #80111111  #a0777777
      color_samples_lines_skip       = #af001145;  // #00004477
      color_samples_lines_outer_skip = #af001145;  // #00004477  (gradient lines)
      color_samples_lines_outer      = #af001125;  // #00004477  (gradient lines)
      color_samples_freedraw         = #B0701111;
      color_samples_drawing          = #D0B01111;
      color_gradient_sharpen         = #ff000000;
      color_rms_zoom_out             = #10003375;
      color_rms                      = #40003375;
      color_rms_zoom                 = #0a003375;
      color_rms_zoom_in              = #00003375;
      color_rms_drawing              = #30003375;
      color_centerline               = #707f6500;
      color_slider_bg                = #dfd4d0c8; // COLOR_WINDOW_BG   #a0000000;
      color_slider_knob              = #dfd4d0c8;
      color_slider_outline           = #a000aa00;
      color_highlight                = #0f00ff00;
      color_highlight_border         = #3f003f00;
      color_selection                = #113f3f95;
      color_selection_border         = #3fffffff;
      color_areainfo_bg              = #2f003f00;
      color_areainfo_label           = #4f000000;
      color_areainfo_value           = #ffffffff;
      color_areainfo_valuesdw        = #7f000000;
      color_playoff_bg               = #0fff0000;
      color_playoff                  = #3fff0000;
      color_regions                  = #9f00ff00;
      color_regions_handle           = #6f00ff00;

      b_draw_bevel_border = true;
      b_draw_tabfocus_border = true;
   }

   protected method loadColorsDark() {
      color_bg                       = #df2a2a2d;

      // color_samples                  = #90dfdfdf;  // #80bfbfbf
      // color_samples_lines_skip       = #a0787878;  // #00888888
      // color_samples_lines_outer_skip = #90585858;  // #00888888  (gradient lines)
      // color_samples_lines_outer      = #90bfbfbf;  // #00888888  (gradient lines)

      color_samples                  = #b0dfdfdf;  // #b0dfdfdf #80bfbfbf
      color_samples_lines_fallback   = #90636363;  // #b0dfdfdf #80bfbfbf
      color_samples_lines_skip       = #d0a4a4a4;  // #f0888888 #00888888
      color_samples_lines_outer_skip = #a0979797;  // #b0c7c7c7 #00888888  (gradient lines)
      color_samples_lines_outer      = #b0dfdfdf;  // #b0bfbfbf #00888888  (gradient lines)

      color_samples_freedraw         = #B0ff4444;
      color_samples_drawing          = #D0ff4444;
      color_gradient_sharpen         = #a0cfcfcf;  // #ffffffff
      color_rms_zoom_out             = #10ffffff;
      color_rms                      = #30ffffff;
      color_rms_zoom                 = #20ffffff;
      color_rms_zoom_in              = #00ffffff;
      color_rms_drawing              = #207f7f7f;
      color_centerline               = #707f655c;
      color_slider_bg                = #df242426;
      color_slider_knob              = #df3a3a3d;
      color_slider_outline           = #a000aa00;
      color_highlight                = #0f7fff7f;
      color_highlight_border         = #3f1f3f1f;
      color_selection                = #21fffff0;
      color_selection_border         = #3fffffff;
      color_areainfo_bg              = #2f003f00;
      color_areainfo_label           = #4f999999;
      color_areainfo_value           = #ffffffff;
      color_areainfo_valuesdw        = #7f000000;
      color_playoff_bg               = #0fffff00;
      color_playoff                  = #3fffff00;
      color_regions                  = #9fffff7f;
      color_regions_handle           = #6fffff7f;

      b_draw_bevel_border = false;
      b_draw_tabfocus_border = false;
   }

   public virtual setLookAndFeel(String _name) {
      // trace "\n\n\nSampleView::setLookAndFeel: name=\""+_name+"\"";
      switch(_name.toLower())
      {
         case "def":
         case "default":
            // (todo) remove ?
            break;

         case "light":
            b_lnf_dark = false;
            loadColorsLight();
            Layer::setLookAndFeel(_name);
            break;

         case "dark":
            b_lnf_dark = true;
            loadColorsDark();
            Layer::setLookAndFeel(_name);
            break;
      }
   }

   public virtual onLookAndFeelChanged() {
      // trace "\n\nSampleView::onLookAndFeelChanged b_lnf_dark="+b_lnf_dark;
      Layer::onLookAndFeelChanged();

      if(b_lnf_dark)
         loadColorsDark();
      else
         loadColorsLight();
   }

   public static GetAreaInfoValueSx() : float {
      if(2.0 == UI.font_scaling)
         return AREAINFO_VALUE_SX * 1.7;
      return AREAINFO_VALUE_SX * UI.font_scaling;
   }

   public method installPlugin(SampleViewPlugin _plugin) {
      plugin <= _plugin;
   }

   public method undoBegin(String _name) {

      // trace "xxx undoBegin(\""+_name+"\")";
      if(null != waveform)
      {
         Waveforms.UndoAutoPurge(waveform);

         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null == undo)
         {
            undo <= new SampleViewUndo;

            // Init undo entry, save current selection
            undo.init(this, waveform);

            waveform.uiSetUndo(#(deref undo));
            Global.Debug2("SampleView::undoBegin: created undo="+#(waveform.uiGetUndo()));
         }

         if(b_drawing)
         {
            // trace "xxx undoBegin while drawing";
            undoEnd();
            b_restart_freedraw_undo = true;
            // trace "xxx ue after undoEnd="+#(ue);
         }

         if(null != ue)
         {
            trace "[~~~] SampleView::undoBegin: internal error: undo entry is not null";
         }

         ue <= undo.beginEntry(_name);

      }
      else
      {
         trace "[~~~] SampleView::undoBegin: cannot start undo transaction (no waveform object)";
      }

      // trace "xxx leave undoBegin(\""+_name+"\")";
   }

   public method undoActionRemove(int _off, int _numFrames, int _chMask) {
      if(null != ue)
      {
         ue.actionRemove(_off, _numFrames, _chMask);
      }
   }

   public method undoActionAdd(int _off, int _numFrames, int _chMask) {
      if(null != ue)
      {
         ue.actionAdd(_off, _numFrames, _chMask);
      }
   }

   public method undoActionModify(int _off, int _numFrames, int _chMask) {
      if(null != ue)
      {
         ue.actionModify(_off, _numFrames, _chMask);
      }
   }

   protected method undoActionPhaseInvert(int _off, int _numFrames, int _chMask) {
      if(null != ue)
      {
         ue.actionPhaseInvert(_off, _numFrames, _chMask);
      }
   }

   protected method undoActionReverse(int _off, int _numFrames, int _chMask) {
      if(null != ue)
      {
         ue.actionReverse(_off, _numFrames, _chMask);
      }
   }

   protected method undoActionDeleteChannel(int _chMask) {
      if(null != ue)
      {
         ue.actionDeleteChannel(_chMask);
      }
   }

   protected method undoActionCreateChannel(int _chMask) {
      if(null != ue)
      {
         ue.actionCreateChannel(_chMask);
      }
   }

   public method undoEnd() {
      if(null != waveform)
      {
         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null != undo)
         {
            if(null != ue)
            {
               undo.endEntry();

               ue <= null;

               Waveforms.RedoAutoPurge(waveform);

               Global.Debug2("SampleView::undoEnd: undo mem usage is "+undo.getUndoMemUsageString()+" MBytes (total="+Waveforms.UndoGetMemUsageString()+")");
               Global.Debug2("SampleView::undoEnd: redo mem usage is "+undo.getRedoMemUsageString()+" MBytes (total="+Waveforms.RedoGetMemUsageString()+")");

               if(b_restart_freedraw_undo)
               {
                  b_restart_freedraw_undo = false;
                  b_drawing = false;
                  undoBegin("freedraw_cont");
                  b_drawing = true;
               }
            }
            else
            {
               trace "[---] SampleView::undoEnd: internal error: undo entry is null";
            }
         }
         else
         {
            trace "[---] SampleView::undoEnd: internal error: no undo object";
         }
      }

      // trace "xxx leave undoEnd";
   }

   protected method undoCanUndo() : boolean {
      if(null != waveform)
      {
         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null != undo)
         {
            return (undo.getNumUndoEntries() > 0);
         }
      }
      return false;
   }

   protected method undoCanRedo() : boolean {
      if(null != waveform)
      {
         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null != undo)
         {
            return (undo.getNumRedoEntries() > 0);
         }
      }
      return false;
   }

   public =replay= method undo() {
      if(null != waveform)
      {
         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null != undo)
         {
            if(null == ue)
            {
               undo.undo(plugin);

               Waveforms.RedoAutoPurge(waveform);

               Global.Debug2("SampleView::undo: undo mem usage is "+undo.getUndoMemUsageString()+" MBytes (total="+Waveforms.UndoGetMemUsageString()+")");
               Global.Debug2("SampleView::undo: redo mem usage is "+undo.getRedoMemUsageString()+" MBytes (total="+Waveforms.RedoGetMemUsageString()+")");

               redraw();

               num_channels = waveform.numChannels;

               handleWaveformChanged();
               handleSelectionChanged();
            }
            else
            {
               Global.Warning("SampleView::undo: please finish current transaction first (freedraw?)");
            }
         }
         else
         {
            Global.Print("SampleView::undo: nothing to undo (no undo object)");
         }
      }
      else
      {
         Global.Print("SampleView::undo: nothing to undo (no waveform object)");
      }
   }

   public =replay= method redo() {
      if(null != waveform)
      {
         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null != undo)
         {
            if(null == ue)
            {
               undo.redo(plugin);

               Global.Debug2("SampleView::redo: undo mem usage is "+undo.getUndoMemUsageString()+" MBytes (total="+Waveforms.UndoGetMemUsageString()+")");
               Global.Debug2("SampleView::redo: redo mem usage is "+undo.getRedoMemUsageString()+" MBytes (total="+Waveforms.RedoGetMemUsageString()+")");

               redraw();

               num_channels = waveform.numChannels;

               handleWaveformChanged();
               handleSelectionChanged();
            }
            else
            {
               Global.Warning("SampleView::redo: please finish current transaction first (freedraw?)");
            }
         }
         else
         {
            Global.Print("SampleView::redo: nothing to redo (no undo object)");
         }
      }
      else
      {
         Global.Print("SampleView::redo: nothing to redo (no waveform object)");
      }
   }

   public method undoClear() {
      if(null != waveform)
      {
         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null != undo)
         {
            if(null == ue)
            {
               undo.free();
               undo.freeRedo();

               Global.Debug2("SampleView::undoClear: undo mem usage is "+undo.getUndoMemUsageString()+" MBytes (total="+Waveforms.UndoGetMemUsageString()+")");
               Global.Debug2("SampleView::undoClear: redo mem usage is "+undo.getRedoMemUsageString()+" MBytes (total="+Waveforms.RedoGetMemUsageString()+")");

            }
            else
            {
               Global.Warning("SampleView::undoClear: please finish current transaction first (freedraw?)");
            }
         }
         else
         {
            Global.Warning("SampleView::undoClear: no undo object");
         }
      }
      else
      {
         Global.Warning("SampleView::undoClear: no waveform object");
      }
   }

   public method setPlayOffset(int _offset) {
      // Used for macros (not regular waveform replay)
      play_offset = _offset;
   }

   public method setRenderStyle(int _rs) {
      render_style = _rs;
      if(b_freedraw)
      {
         render_style_freedraw = _rs;
      }
      else
      {
         render_style_normal = _rs;
      }
   }

   public method setInterpolation(int _is) {
      interpol_style = _is;
      if(b_freedraw)
      {
         interpol_style_freedraw = _is;
      }
      else
      {
         interpol_style_normal = _is;
      }
   }

   public method setFreedrawMode(boolean _bEnabled) {
      b_freedraw = _bEnabled;
      if(b_freedraw)
      {
         render_style   = render_style_freedraw;
         interpol_style = interpol_style_freedraw;
      }
      else
      {
         render_style   = render_style_normal;
         interpol_style = interpol_style_normal;
      }
      redraw();
   }

   public method setEnableDrawHighlight(boolean _bEnabled) {
      b_render_highlight = _bEnabled;
   }

   public method getEnableDrawHighlight() : boolean {
      return b_render_highlight;
   }

   public method setEnableRenderRMS(boolean _bEnabled) {
      b_render_rms = _bEnabled;
   }

   public method toggleShowSamples() {
      b_render_samples = ! b_render_samples;
      redraw();
   }

   public method toggleShowRMS() {
      setEnableRenderRMS(! b_render_rms);
      redraw();
   }

   public method toggleShowHighlight() {
      b_render_highlight = ! b_render_highlight;
      if(null != plugin)
      {
         plugin.svHandleRenderHighlightChanged(b_render_highlight);
      }
      redraw();
   }

   public method toggleShowRegions() {
      b_render_regions = !b_render_regions;
      redraw();
   }

   public method setAutoChopRegionsFromCuePoints(IntArray _cuePoints, int _cueOffset) {

      if( (null != _cuePoints) && (_cuePoints.numElements > 0) )
      {
         autochop_start_offsets.empty();
         autochop_end_offsets.empty();

         int frame;
         int lastFrame = 0;
         autochop_start_offsets.add(0);
         foreach frame in _cuePoints
         {
            frame += _cueOffset;
            autochop_end_offsets.add(frame);
            autochop_start_offsets.add(frame);
            lastFrame = frame;
         }
         autochop_end_offsets.add(getNumFrames());
         trace "[trc] setAutoChopRegionsFromCuePoints: start_offsets="+autochop_start_offsets+" end_offsets="+autochop_end_offsets;
      }
      else
      {
      }
   }

   public method setEnableAutochopRMS(boolean _bEnable, boolean _bAction) {
      b_autochop_rms = _bEnable;
      selectNone();
      recalcAutoChopRegions();
      redraw();

      if(_bAction)
         handleAutoChopModeChanged();
   }

   public method toggleAutochopRMS() {
      if(b_autochop_rms)
         b_autochop_rms = maybe;
      else if(maybe == b_autochop_rms)
         b_autochop_rms = false;
      else
         b_autochop_rms = true;
      setEnableAutochopRMS(b_autochop_rms, true/*bAction*/);
   }

   protected method handleAutoChopModeChanged() {
      provideAction(Action.New(getProvidedActionAlias(ACTION_AUTOCHOP_MODE), this));
   }

   // <ui_show.png>
   public method showAutochopDialog() {
      if(0 == UI.GetNumModalFloatingLayers())
      {
         // if(null == dlg_autochop)
         {
            dlg_autochop <= new SampleViewAutochopDialog;
            dlg_autochop.init( (maybe == b_autochop_rms) );
         }
         dlg_autochop.showAutochopDialog(this, autochop_config);
      }
   }

   // <ui_hide.png>
   public method lazyCloseAutochopDialog() {
      if(null != dlg_autochop)
      {
         if(dlg_autochop.isFloatingLayerVisible())
            dlg_autochop.hide();
      }
   }

   public virtual isTabCycleMember() : boolean {
      return true;
   }

   public virtual getProvidedActionNames() returns StringArray {
      return [
         ACTION_WAVEFORM_CHANGED,
         ACTION_SELECTION_CHANGED,
         ACTION_HIGHLIGHT_CHANGED,
         ACTION_REGION_SELECTED,
         ACTION_EXPORT_SELECTION,
         ACTION_MULTI_EXPORT_REGIONS,
         ACTION_DROP_FILES,
         ACTION_AUTOCHOP_MODE
      ];
   }

   public method setSampleRange(float _min, _max) {
      min_sample = _min;
      max_sample = _max;
   }

   protected method endDrag() {
      if(b_grab_rmb)
      {
         UI.RevertCursor();
      }
      b_grab_lmb_scrollbar = false;
      b_grab_lmb_selection = false;
      b_grab_rmb           = false;
   }

   protected method calcSampleSizeY() : int {
      return (zoom < 1.0) ? (size_y - SCROLLBAR_POSY - SCROLLBAR_HEIGHT) : size_y;
   }

   public static CalcOffsetAndZoomForRegion(int _wfNumFrames, int _off, int _len, Double _retZoom, Float _retOffset) {
      _retZoom   = Double.Newf(_len) / float(_wfNumFrames);
      _retOffset = float(_off) / (_wfNumFrames - _len + 1);
      _retOffset = (_retOffset * 2) - 1;
   }

   public static UpdateOffsetAndZoomAfterInsertDelete(int _offset, int _len,
                                                      int _newWfNumFrames,
                                                      Double _oldZoom, float _oldOffset,
                                                      Double _retZoom, Float _retOffset
                                                      ) {
      // called by PageSample.svHandleDeleteRegion()/svHandleInsertRegion()
      //  (note) negative _len = delete

      int oldWfNumFrames = _newWfNumFrames - _len;
      int oldNumVis = _oldZoom * oldWfNumFrames;
      int oldOffset = ((_oldOffset + 1) * 0.5) * (oldWfNumFrames - oldNumVis + 1);

      int newNumVis = oldNumVis;
      int newOffset = oldOffset;

      int ao = _offset;
      int al = -_len;
      int to = newOffset;
      int tl = newNumVis;

      // trace "xxx UpdateOffsetAndZoomForRegionAfterInsertDelete: oldOff="+oldOffset+" oldNumVis="+oldNumVis+" modOff="+_offset+" modLen="+_len;

      if(newOffset >= _offset)
      {
         if(_len < 0)
         {
            if((ao+al) >= to)
            {
               if((ao+al) >= (to+tl))
               {
                  // Cut entire visible area
                  // trace "xxx cut entire visible area";
                  newOffset = 0;
                  newNumVis = 0;
               }
               else
               {
                  // Cut region at start of visible area
                  // trace "xxx cut region at start of visible area";
                  newOffset -= (to - ao);
                  if(newOffset < 0)
                     newOffset = 0;
                  newNumVis -= ((ao+al)-to);
               }
            }
            else
            {
               // Cut before visible area
               // trace "xxx cut before visible area";
               newOffset += _len;
               if(newOffset < 0)
                  newOffset = 0;
            }
         }
         else
         {
            // Paste before visible area
            // trace "xxx paste before visible area";
            newOffset += _len;
            if(newOffset < 0)
               newOffset = 0;
         }
      }
      else if(_len < 0)
      {
         if( (ao+al) <= (to+tl) )
         {
            // Cut within visible area
            // trace "xxx cut within visible area";
            newNumVis -= al;
         }
         else if( ao <= (to+tl) )
         {
            // Cut crosses end of visible area
            // trace "xxx cut crosses end of visible area";
            newNumVis -= ((to+tl) - ao);
         }
      }
      else
      {
         if( (ao) < (to+tl) )
         {
            // Paste within visible area
            // trace "xxx paste within visible area";
            newNumVis += _len;
         }
         else
         {
            // Paste after start of visible area
            // trace "xxx paste after start of visible area";
         }
      }

      // Global.Debug2("SampleView::UpdateOffsetAndZoomForRegionAfterInsertDelete: oldOff="+oldOffset+" oldNumVis="+oldNumVis+" => newOffset="+newOffset+" newNumVis="+newNumVis+" modOff="+_offset+" modLen="+_len);

      if(newNumVis < 0)
         newNumVis = 0; // should not be reachable

      _retZoom   = Double.Newf(newNumVis) / float(_newWfNumFrames);
      _retOffset = float(newOffset) / (_newWfNumFrames - newNumVis + 1);
      _retOffset = (_retOffset * 2) - 1;
   }

   public method fitSelectionToWindow() {
      if(null != samples)
      {
         // (todo) selection start/end is already sorted
         int selstartoff = sel_startoff;
         int selendoff   = sel_endoff;
         if(selendoff < selstartoff)
         {
            int t = selstartoff;
            selstartoff = selendoff;
            selendoff   = t;
         }

         if(selendoff > selstartoff)
         {
            int numFrames = (samples.numElements / num_channels);
            int selLen = (selendoff - selstartoff);
            zoom = Double.Newf(selLen) / float(numFrames);
            offset = float(selstartoff) / (numFrames-selLen+1);
            offset = (offset * 2) - 1;
            setZoom(zoom);
            // trace "[dbg] SampleView::fitSelectionToWindow: zoom="+zoom+" offset="+offset;
            redraw();
         }
      }
   }

   public method toggleFitSelectionToWindow() {
      local Double oldZoom = zoom;
      float oldOffset = offset;

      fitSelectionToWindow();

      if((zoom == oldZoom) && (oldOffset == offset))
      {
         showAll();
      }
   }

   protected method isSelectionFullyVisible() : boolean {
      int visStartOff = calcSampleOffsetAtMouseX(0);
      int visEndOff = calcSampleOffsetAtMouseX(size_x);
      // trace "xxx isSelectionFullyVisible: sel_startoff="+sel_startoff+" visStartOff="+visStartOff+" sel_endoff="+sel_endoff+" visEndOff="+visEndOff;
      if( (sel_endoff > visEndOff) || (sel_startoff < visStartOff) )
      {
         return false;
      }
      return true;
   }

   protected method makeAreaVisible(int _startOff, int _endOff) {
      if(null != samples)
      {
         int numFrames = samples.numElements / num_channels;

         int oldSelOff = sel_startoff;
         int oldSelEnd = sel_endoff;
         if(_startOff < 0)
            _startOff = 0;
         if(_endOff > numFrames)
            _endOff = numFrames;
         setSelection(_startOff, _endOff);
         fitSelectionToWindow();
         setSelection(oldSelOff, oldSelEnd);
      }
   }

   public method makeSelectionVisible() {
      if(null != samples)
      {
         int numFrames = samples.numElements / num_channels;

         // Adjust view so that selection becomes fully visible
         //  Tries to scroll when only start or end are not visible
         int oldSelOff;
         int oldSelEnd;
         int visDelta;
         int clipOff;
         int clipEnd;
         if(sel_endoff > sel_startoff) // have selection ?
         {
            int visStartOff = calcSampleOffsetAtMouseX(0);
            int visEndOff = calcSampleOffsetAtMouseX(size_x);
            int numVis = visEndOff - visStartOff;
            int selLen = sel_endoff - sel_startoff;

            // trace "xxx sel_startoff="+sel_startoff+" visStartOff="+visStartOff+" sel_endoff="+sel_endoff+" visEndOff="+visEndOff+" numVis="+numVis+" selLen="+selLen;

            if( (sel_endoff > visEndOff) && (sel_startoff < visStartOff) )
            {
               fitSelectionToWindow();
            }
            else if( (sel_endoff > visEndOff) )
            {
               // Only selection end is not visible, try to scroll
               oldSelOff = sel_startoff;
               oldSelEnd = sel_endoff;
               visDelta = visEndOff - (oldSelEnd - (oldSelEnd-oldSelOff));

               clipOff = oldSelEnd - numVis + visDelta;
               clipEnd = oldSelEnd + visDelta;
               if(clipEnd > numFrames)
               {
                  clipEnd = numFrames - (clipEnd - clipOff);
                  clipOff = numFrames - numVis;
               }
               // trace "xxx clipOff="+clipOff+" clipEnd="+clipEnd+" num="+(clipEnd - clipOff);
               setSelection(clipOff, clipEnd);
               Double oldZoom = zoom;
               fitSelectionToWindow();
               zoom = oldZoom;

               setSelection(oldSelOff, oldSelEnd);

               // trace "xxx isSelectionFullyVisible()="+isSelectionFullyVisible();

               if(!isSelectionFullyVisible())
               {
                  // make cycle visible
                  makeAreaVisible(sel_startoff - selLen, sel_endoff + selLen);
                  if(!isSelectionFullyVisible())
                  {
                     fitSelectionToWindow();
                  }
               }
            }
            else if( (sel_startoff < visStartOff) )
            {
               // Only selection start is not visible, try to scroll
               oldSelOff = sel_startoff;
               oldSelEnd = sel_endoff;
               visDelta = (oldSelOff + (oldSelEnd-oldSelOff)) - visStartOff;

               clipOff = oldSelOff - visDelta;
               clipEnd = oldSelOff + numVis - visDelta;
               if(clipOff < 0)
               {
                  clipOff = 0;
                  clipEnd = numVis;
               }
               setSelection(clipOff, clipEnd);
               oldZoom = zoom;
               fitSelectionToWindow();
               zoom = oldZoom;

               setSelection(oldSelOff, oldSelEnd);

               if(!isSelectionFullyVisible())
               {
                  // make cycle visible
                  makeAreaVisible(sel_startoff - selLen, sel_endoff + selLen);
                  if(!isSelectionFullyVisible())
                  {
                     fitSelectionToWindow();
                  }
               }
            }

         }
      }
   }

   public method selectNextCycle() {
      if(null != samples)
      {
         if(samples.numElements > 0)
         {
            int numFrames = samples.numElements / num_channels;

            if(sel_endoff > sel_startoff)
            {
               int visStartOff = calcSampleOffsetAtMouseX(0);
               int visEndOff = calcSampleOffsetAtMouseX(size_x);
               int numVis = visEndOff - visStartOff;

               int curEndOff = sel_endoff;
               int curStartOff = sel_startoff;
               int selLen = (sel_endoff - sel_startoff);

               boolean bCycleZoom = abs(numVis - selLen) < 16;

               ////trace "xxx sel_endoff="+sel_endoff+" selLen="+selLen+" numFrames="+numFrames;

               if((sel_endoff + selLen) <= numFrames)
               {
                  setSelection(sel_startoff + selLen, sel_endoff + selLen);

                  if(bCycleZoom)
                  {
                     // keep cycle fully zoomed
                     fitSelectionToWindow();
                  }
                  else
                  {
                     if(sel_endoff == numFrames)
                     {
                        makeAreaVisible(numFrames - numVis, numFrames);
                     }
                     else
                     {
                        makeSelectionVisible();
                        b_cycle_mode = true; // makeSelectionVisible can reset this

                        if(!isSelectionFullyVisible())
                        {
                           // No next cycle, restore selection
                           makeAreaVisible(numFrames - numVis, numFrames);
                           setSelection(curStartOff, curEndOff);
                        }
                     }
                  }
               }
            }
         }
      }
   }

   public method selectPreviousCycle() {
      if(null != samples)
      {
         if(samples.numElements > 0)
         {
            int numFrames = samples.numElements / num_channels;
            if(sel_endoff > sel_startoff)
            {
               int visStartOff = calcSampleOffsetAtMouseX(0);
               int visEndOff = calcSampleOffsetAtMouseX(size_x);
               int numVis = visEndOff - visStartOff;

               int curEndOff = sel_endoff;
               int curStartOff = sel_startoff;
               int selLen = (sel_endoff - sel_startoff);

               boolean bCycleZoom = abs(numVis - selLen) < 16;

               if((sel_startoff - selLen) >= 0)
               {
                  setSelection(sel_startoff - selLen, sel_endoff - selLen);

                  if(bCycleZoom)
                  {
                     // keep cycle fully zoomed
                     fitSelectionToWindow();
                  }
                  else
                  {
                     makeSelectionVisible();

                     if(!isSelectionFullyVisible())
                     {
                        // No next cycle, restore selection
                        makeAreaVisible(0, numVis);
                        setSelection(curStartOff, curEndOff);
                     }
                  }
               }
            }
         }
      }
   }

   public method showAll() {
      offset = -1;
      zoom   = 1.0;
      setZoom(zoom);
      redraw();
   }

   public static HaveClipboard() : boolean {
      return (clipboard_samples.numElements > 0);
   }

   protected method showContextMenu() {
      PopupMenuButton *pmb;

      boolean bHaveSel = (sel_endoff > sel_startoff);
      boolean bHaveCB = HaveClipboard();
      boolean bHaveRegions = (getNumRegions() > 0);

      context_menu <= PopupMenu.New(this);

      pmb <= context_menu.addCheckButton("Freedraw mode", b_freedraw, "togglefreedraw");
      pmb.setAccelerators(null, "`");
      pmb.setToolTipCaption("If checked, use LMB-drag to paint samples\n\n (note) only works when samples-per-pixel is <1\n (note) if a selection exists, drawing is limited to that area");

      if(0 == wavetable_cycle_len)
      {
         pmb <= context_menu.addCheckButton("Zone select mode", b_cycle_mode, "togglecyclemode");
         pmb.setToolTipCaption("When checked, use mouse WHEEL UP/DOWN to select previous / next zone (region)\n (note) use lctrl-WHEEL UP/DOWN for regular zoom");
      }
      else
      {
         pmb <= context_menu.addCheckButton("Cycle select mode", b_cycle_mode, "togglecyclemode");
         pmb.setToolTipCaption("When checked, use mouse WHEEL UP/DOWN to select previous / next wavetable cycle\n (note) use lctrl-WHEEL UP/DOWN for regular zoom");
      }
      pmb.setAccelerators("lshift-z", null);

      pmb <= context_menu.addCheckButton("RMS autochop mode", b_autochop_rms, "toggleautochoprms");
      pmb.setToolTipCaption("When checked, enable RMS based autochop / region split mode (may work better with drum loops)\n\nWhen unchecked, use silence detection focused split mode (may work better with synth multisamples)\n\n (note) autochop settings can be finetuned via lctrl-lshift-j (dev tool)");
      pmb.setAccelerators("lshift-j", null);

      pmb <= context_menu.addCheckButton("Snap to zero crossing", b_zerox_mode, "togglezeroxmode");
      pmb.setToolTipCaption("When checked, snap selection start/end to nearest zero-crossing");
      pmb.setAccelerators("lctrl-z", "hold-MMB");

      pmb <= context_menu.addCheckButton("BPM Snap (1/"+bpm_snap_grid+")", b_bpm_snap, "togglebpmsnap");
      pmb.setToolTipCaption("When checked, snap selection start/end to 1/16..1/1 notes.\n\n (note) selection start determines reference offset (updated when snap is enabled)\n\n (note) lshift-s cycles through snap grid size");
      pmb.setAccelerators("s", "MMB");

      pmb <= context_menu.addCheckButton("Marker Snap", b_marker_snap, "togglemarkersnap");
      pmb.setToolTipCaption("When checked, snap selection start/end to nearest marker or start/end");
      pmb.setAccelerators("s", "MMB");

      context_menu.addSeparator();

      pmb <= context_menu.addDefaultButton("Show all", "showall");
      pmb.setAccelerators("lctrl-lshift-SPACE", null);

      pmb <= context_menu.addDefaultButton("Fit selection to window", "fitseltowindow");
      pmb.setAccelerators(null, "lctrl-SPACE");
      pmb.setActive(bHaveSel);
      pmb <= context_menu.addDefaultButton("Copy selection to highlight", "copyseltohl");
      pmb.setAccelerators("lctrl-h", null);
      pmb.setToolTipCaption("The \'highlighted\' area is often used to select a sample area in the current context.\n\n The audio instrument editor uses it to set the current sample offset/length or the current loop offset/length (if a loop is selected)\n\n The subsongs dialog uses it to set the render-target area");
      pmb.setActive(bHaveSel);

      context_menu.addSeparator();
      PopupMenu pmClipboard <= PopupMenu.New(context_menu);

      pmb <= pmClipboard.addDefaultButton("Cut selection to clipboard", "cutseltoclipboard");
      pmb.setAccelerators("lctrl-w", null);
      pmb.setActive(bHaveSel && b_may_realloc);

      pmb <= pmClipboard.addDefaultButton("Copy selection to clipboard", "copyseltoclipboard");
      pmb.setAccelerators("lctrl-c", null);
      pmb.setActive(bHaveSel);

      pmb <= pmClipboard.addDefaultButton("Append selection to clipboard", "appendseltoclipboard");
      pmb.setAccelerators("RETURN", null);
      pmb.setActive(bHaveSel);

      pmb <= pmClipboard.addDefaultButton("Paste at selection start", "pasteclipboard_start");
      pmb.setActive(bHaveCB && b_may_realloc);

      pmb <= pmClipboard.addDefaultButton("Paste at selection end", "pasteclipboard_end");
      pmb.setAccelerators("lctrl-v", null);
      pmb.setActive(bHaveCB && b_may_realloc);

      pmb <= pmClipboard.addDefaultButton("Replace selection by clipboard", "pasteclipboard_replace");
      pmb.setAccelerators("lctrl-lshift-v", null);
      pmb.setActive(bHaveCB && b_may_realloc);

      pmb <= pmClipboard.addDefaultButton("Add clipboard to selection (mix)", "tools_add");
      pmb.setActive(bHaveCB && bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lshift-v");

      context_menu.addMenu("Clipboard", deref pmClipboard);

      if(!b_no_export)
      {
         context_menu.addSeparator();

         pmb <= context_menu.addDefaultButton("Export selection..", "exportselection");
         pmb.setAccelerators("lctrl-e", null);
         pmb.setActive(bHaveSel);

         pmb <= context_menu.addDefaultButton("Multi-Export regions..", "multiexportregions");
         pmb.setAccelerators("lctrl-lshift-e", null);
         pmb.setActive(bHaveRegions);
      }

      context_menu.addSeparator();

      pmb <= context_menu.addDefaultButton("Select and show all", "selectall");
      pmb.setToolTipCaption("Select and show all");
      pmb.setAccelerators("lctrl-a", null);

      pmb <= context_menu.addDefaultButton("Select none", "selectnone");
      pmb.setActive(bHaveSel);
      pmb.setAccelerators("lshift-lctrl-a", null);

      pmb <= context_menu.addDefaultButton("Tighten selection", "tightensel");
      pmb.setAccelerators(null, "lctrl-s");
      pmb.setActive(bHaveSel);
      pmb.setToolTipCaption("Detect transient and adjust selection\n\n (note) hold lshift to lower min threshold");

      context_menu.addSeparator();

      PopupMenu pmChannels <= PopupMenu.New(context_menu);

      pmb <= pmChannels.addDefaultButton("Convert to stereo", "channels_tostereo");
      pmb.setAccelerators("lctrl-lshift-m", null);
      pmb.setActive(b_may_realloc && (1 == num_channels) && b_allow_channel_conversion);

      pmb <= pmChannels.addDefaultButton("Convert to mono", "channels_tomono");
      pmb.setAccelerators("lctrl-m", null);
      pmb.setActive(b_may_realloc && (2 == num_channels) && b_allow_channel_conversion);

      pmb <= pmChannels.addDefaultButton("Delete left", "channels_deleteleft");
      pmb.setAccelerators("lctrl-k", null);
      pmb.setActive(b_may_realloc && (2 == num_channels) && b_allow_channel_conversion);

      pmb <= pmChannels.addDefaultButton("Delete right", "channels_deleteright");
      pmb.setAccelerators("lctrl-lshift-k", null);
      pmb.setActive(b_may_realloc && (2 == num_channels) && b_allow_channel_conversion);

      context_menu.addMenu("Channels", deref pmChannels);

      PopupMenu pmTools <= PopupMenu.New(context_menu);

      pmb <= pmTools.addDefaultButton("Crossfade selection", "tools_crossfade");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-lshift-r");

      pmb <= pmTools.addDefaultButton("Loop-Crossfade selection..", "tools_loopcrossfade");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lshift-r");

      pmb <= pmTools.addDefaultButton("Fade-in selection", "tools_fadein");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-lshift-f");

      pmb <= pmTools.addDefaultButton("Fade-out selection", "tools_fadeout");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-f");

      pmb <= pmTools.addDefaultButton("Declick selection end", "tools_declick_end");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-b");

      pmb <= pmTools.addDefaultButton("Declick selection start", "tools_declick_start");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-lshift-b");

      pmb <= pmTools.addDefaultButton("Normalize selection", "tools_normalize");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-n");

      pmb <= pmTools.addDefaultButton("Normalize regions", "tools_normalize_regions");
      pmb.setActive(true/*bHaveRegions*/ && !b_readonly);  // (note) auto-finds regions when executed
      pmb.setAccelerators(null, "lctrl-lshift-n");

      pmb <= pmTools.addDefaultButton("Amplify selection..", "tools_amp");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-o");

      pmb <= pmTools.addDefaultButton("Phase-invert selection", "tools_phaseinvert");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-p");

      pmb <= pmTools.addDefaultButton("Show SoX dialog..", "tools_sox");
      pmb.setActive(bHaveSel && !b_readonly && b_may_realloc);
      pmb.setAccelerators(null, "lctrl-lshift-s");

      pmb <= pmTools.addDefaultButton("Reverse selection", "tools_reverse");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-r");

      pmb <= pmTools.addDefaultButton("Silence selection", "tools_silence");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-d");

      pmb <= pmTools.addDefaultButton("Surround selection with silence", "tools_surroundsilence");
      pmb.setActive(bHaveSel && !b_readonly);
      pmb.setAccelerators(null, "lctrl-lshift-d");

      pmb <= pmTools.addDefaultButton("Truncate to selection", "tools_truncate");
      pmb.setActive(bHaveSel && b_may_realloc);
      pmb.setAccelerators(null, "lctrl-t");

      pmb <= pmTools.addDefaultButton("Auto-Trim", "tools_autotrim");
      pmb.setActive(bHaveSel && b_may_realloc);
      pmb.setAccelerators(null, "lctrl-lshift-t");

      context_menu.addMenu("Tools", deref pmTools);

      context_menu.addSeparator();
      PopupMenu pmUndo <= PopupMenu.New(context_menu);

      pmb <= pmUndo.addDefaultButton("Undo", "undo");
      pmb.setActive(undoCanUndo());
      pmb.setAccelerators("lctrl-y", null);
      pmb <= pmUndo.addDefaultButton("Redo", "redo");
      pmb.setAccelerators("lctrl-lshift-y", null);
      pmb.setActive(undoCanRedo());

      boolean bClear = false;
      if(null != waveform)
      {
         SampleViewUndo undo <= waveform.uiGetUndo();
         if(null != undo)
         {
            Float undoTotalSize = (undo.total_mem_usage_undo + undo.total_mem_usage_redo) / (1024.0f*1024);
            String sclear = "Clear history ("+undoTotalSize.printf("%.2f MBytes")+")";
            pmb <= context_menu.addDefaultButton(sclear, "undo_clear");
            Float undoUndoSize = (undo.total_mem_usage_undo) / (1024.0f*1024);
            Float undoRedoSize = (undo.total_mem_usage_redo) / (1024.0f*1024);
            sclear = "Clear undo and redo history\n\n Undo history size: "+
               undoUndoSize.printf("%.3f MBytes")+
               " ("+Utils.GetNumString2(undo.getNumUndoEntries(), "entry", "entries")+")"+
               "\n\n Redo history size: "+undoRedoSize.printf("%.3f MBytes")+" ("+
               Utils.GetNumString2(undo.getNumRedoEntries(), "entry", "entries")+")";
            pmb.setToolTipCaption(sclear);
            pmb.setAccelerators("lctrl-lshift-l", null);
            pmb.setActive(undoTotalSize > 0);
            bClear=true;
         }
      }
      if(!bClear)
      {
         pmb <= pmUndo.addDefaultButton("Clear", "redo");
         pmb.setAccelerators("lctrl-lshift-y", null);
         pmb.setActive(false);
      }

      context_menu.addMenu("Undo", deref pmUndo);

      context_menu.addSeparator();
      PopupMenu pmShow <= PopupMenu.New(context_menu);
      pmb <= pmShow.addCheckButton("Show Samples", b_render_samples, "toggleshowsamples");
      pmb.setAccelerators("lctrl-lshift-i", null);
      pmb <= pmShow.addCheckButton("Show RMS", b_render_rms, "toggleshowrms");
      pmb.setAccelerators("lctrl-i", null);
      pmb <= pmShow.addCheckButton("Show highlighted area", b_render_highlight, "toggleshowhighlight");
      pmb.setAccelerators("lctrl-g", null);
      pmb <= pmShow.addCheckButton("Show regions", b_render_regions, "toggleshowregions");
      pmb.setAccelerators("lctrl-j", null);
      context_menu.addMenu("Show", deref pmShow);

      PopupMenu pmRender <= PopupMenu.New(context_menu);
      pmb <= pmRender.addRadioButton("Dots",                 (RS_DOTS               == render_style), "render_dots");
      pmb <= pmRender.addRadioButton("Lines",                (RS_LINES              == render_style), "render_lines");
      pmb <= pmRender.addRadioButton("Sample deltas",        (RS_DELTA              == render_style), "render_delta");
      pmb <= pmRender.addRadioButton("Gradient",             (RS_GRADIENT           == render_style), "render_gradient");
      pmb <= pmRender.addRadioButton("Gradient+Lines",       (RS_GRADIENT_AND_LINES == render_style), "render_gradient_and_lines");
      context_menu.addMenu("Render style", deref pmRender);

      PopupMenu pmInterpol <= PopupMenu.New(context_menu);
      pmb <= pmInterpol.addRadioButton("None (Sample & Hold)", (IS_SH         == interpol_style), "interpol_sh");
      pmb <= pmInterpol.addRadioButton("Linear",               (IS_LINEAR     == interpol_style), "interpol_linear");
      pmb <= pmInterpol.addRadioButton("Smoothstep",           (IS_SMOOTHSTEP == interpol_style), "interpol_smoothstep");
      context_menu.addMenu("View interpolation", deref pmInterpol);

      context_menu.showNearMouse(6*UI.font_scaling, -130*UI.font_scaling);

      endDrag();

      hideToolTip();
      cancelToolTipTimer();
   }

   protected method showFloatParamForMouseX(int _mx, boolean _bLower) {
      // trace "xxx showFloatParamForMouseX(mx="+_mx+")";
      if(null != samples)
      {
         int numFrames = samples.numElements / num_channels;

         lazyCalcAreaInfoStringWidths(); // also initializes font

         float minVal;
         float maxVal;
         float curVal;
         float stepFine = 1;
         float stepCoarse = 1.0;
         int precision = 0;
         float areaInfoW = GetAreaInfoValueSx();

         if(_bLower)
         {
            if(_mx >= (stringw_sel_start + areaInfoW + stringw_sel_end + areaInfoW))
            {
               fp_area_mode = FPAREAMODE_SELLEN;
               minVal = 0;
               maxVal = (numFrames - sel_startoff);
               curVal = sel_endoff - sel_startoff;
            }
            else if(_mx >= (stringw_sel_start + areaInfoW))
            {
               fp_area_mode = FPAREAMODE_SELEND;
               minVal = 0;
               maxVal = numFrames;
               curVal = sel_endoff;
            }
            else
            {
               fp_area_mode = FPAREAMODE_SELSTART;
               minVal = 0;
               maxVal = numFrames - (sel_endoff - sel_startoff);
               if(maxVal < 0)
                  maxVal = 0;
               curVal = sel_startoff;
            }
         }
         else if(hl_endoff > hl_startoff) // have highlighted area ?
         {
            if(_mx >= (stringw_hl_start + areaInfoW + stringw_hl_end + areaInfoW))
            {
               fp_area_mode = FPAREAMODE_HLLEN;
               minVal = 0;
               maxVal = (numFrames - hl_startoff);
               curVal = hl_endoff - hl_startoff;
            }
            else if(_mx >= (stringw_hl_start + areaInfoW))
            {
               fp_area_mode = FPAREAMODE_HLEND;
               minVal = 0;
               maxVal = numFrames;
               curVal = hl_endoff;
            }
            else
            {
               fp_area_mode = FPAREAMODE_HLSTART;
               minVal = 0;
               maxVal = numFrames - (hl_endoff - hl_startoff);
               if(maxVal < 0)
                  maxVal = 0;
               curVal = hl_startoff;
            }
         }

         if(FPAREAMODE_NONE != fp_area_mode)
         {
            fp_area.showEditor(minVal, maxVal, curVal,
                               stepFine, stepCoarse,
                               precision,
                               false,
                               false
                               );
         }
      }
   }

   protected method getFont() : Font {
      if(null == font)
      {
         // // font <= UI.GetFontByName(UI.IsHiDPI()
         // //                          ? UIConstants.DEFAULT_FONT_NAME_LABEL_SMALL_HIDPI
         // //                          : UIConstants.DEFAULT_FONT_NAME_LABEL////UIConstants.DEFAULT_FONT_NAME_LABEL_SMALL_LODPI
         // //                          );
         font <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);
      }
   }

   public method highlightNone() {
      setHighlight(0, 0);
   }

   public method getSortedHighlightStart() {
      if(hl_endoff > hl_startoff)
      {
         return hl_startoff;
      }
      else
      {
         return hl_endoff;
      }
   }

   public method getSortedHighlightLength() {
      if(hl_endoff > hl_startoff)
      {
         return (hl_endoff - hl_startoff);
      }
      else
      {
         return (hl_startoff - hl_endoff);
      }
   }

   public method setHighlight(int _start, int _end) {
      // trace "xxx SampleView::setHighlight("+_start+", "+_end+")";
      hl_startoff = _start;
      hl_endoff   = _end;
      UI.CompositeAll();
   }

   public method selectNone() {
      setSelection(0, 0);
      endCycleMode();
   }

   public method selectAll(boolean _bAction) {
      if(null != samples)
      {
         int numFrames = (samples.numElements / num_channels);
         sel_startoff = 0;
         sel_endoff   = numFrames;
         sel_channel_mask = CHANNEL_MASK_LR;
         fitSelectionToWindow();
         if(_bAction)
            handleSelectionChanged();
      }
   }

   public method gotoEndOfSelection() {
      if(haveSelection())
      {
         sel_startoff = sel_endoff;
         // // sel_endoff++;
      }
   }

   public method gotoEndOfSelectionOrWaveform() {
      if(null != samples)
      {
         if(sel_startoff < sel_endoff)
            sel_startoff = sel_endoff;
         else
         {
            int numFrames = (samples.numElements / num_channels);
            sel_startoff = numFrames;
            sel_endoff = sel_startoff;
         }
      }
   }

   public method haveSelection() : boolean {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            int numFrames = (samples.numElements / num_channels);
            if(sel_startoff < numFrames)
               if(sel_endoff <= numFrames)
                  return true;
         }
      }
      return false;
   }

   protected method handleHighlightChanged() {
      provideAction(Action.New(getProvidedActionAlias(ACTION_HIGHLIGHT_CHANGED), this));
   }

   protected method handleSelectionChanged() {

      if(b_bpm_snap)
      {
         int selLen = sel_endoff - sel_startoff;
         if(selLen >= 0)
         {
            float snapFrames = getBPMSnapFrames();
            int num = int(0.5 + (selLen / snapFrames));
            if(last_snap_num != num)
            {
               Global.Print("Select "+num+" 1/"+bpm_snap_grid+" note"+Utils.GetPluralString(num)+" (@bpm="+bpm+")");
               last_snap_num = num;
            }
            cur_snap_num = num;
         }
      }

      provideAction(Action.New(getProvidedActionAlias(ACTION_SELECTION_CHANGED), this));
   }

   protected method handleRegionSelected() {
      provideAction(Action.New(getProvidedActionAlias(ACTION_REGION_SELECTED), this));
   }

   protected method handleWaveformChanged() {
      if(b_autorecalc_autochop)
         recalcAutoChopRegions();
      else
         invalidateAutoChop();

      invalidatePlayOffsets();
      provideAction(Action.New(getProvidedActionAlias(ACTION_WAVEFORM_CHANGED), this));
   }

   public method handleExportSelection() {
      provideAction(Action.New(getProvidedActionAlias(ACTION_EXPORT_SELECTION), this));
   }

   public method handleMultiExportRegions() {
      lazyAutoChopRegions();
      provideAction(Action.New(getProvidedActionAlias(ACTION_MULTI_EXPORT_REGIONS), this));
   }

   public method setEnableRegionAutoCycleMode(boolean _bEnable) {
      b_region_auto_cyclemode = _bEnable;
   }

   public method setWavetableCycleHints(int _len, int _off) {
      wavetable_cycle_len = _len;
      wavetable_cycle_off = _off;
   }

   public method beginCycleMode() {
      // Temporary enable cycle-editing mode until selectNone() is called
      //   - the cyclelen is determined by the current selection length
      //   - mouse-wheel selects prev/next cycle
      if(!b_cycle_mode)
      {
         b_cycle_mode = true;

         if(sel_endoff > sel_startoff)
         {
            int selLen = sel_endoff - sel_startoff;
            int numVis = getNumVisibleSamples();

            if(selLen > CYCLEMODE_MAX_NUM_FRAMES)
            {
               makeSelectionVisible();  // just make visible, don't zoom to selection
            }
            else
            {
               if( (selLen*11) < numVis )
               {
                  // make cycle visible
                  makeAreaVisible(sel_startoff - selLen, sel_endoff + selLen);
                  if(!isSelectionFullyVisible())
                  {
                     fitSelectionToWindow();
                  }
               }
            }
         }

      }
   }

   public method endCycleMode() {
      if(b_cycle_mode)
         Global.Print("SampleView: cycle edit mode is now disabled.");
      b_cycle_mode = false;
   }

   protected method toggleCycleMode(MouseEvent _evOrNull) {
      if(b_cycle_mode)
      {
         endCycleMode();

         showAll();
      }
      else
      {
         if(null != _evOrNull)
         {
            if(0 == wavetable_cycle_len)
            {
               // When toggled via MMB
               if(!trySelectHighlightedAreaUnderMouse(_evOrNull))
               {
                  trySelectRegionUnderMouse(_evOrNull);
               }
            }
         }

         if(!haveSelection())
         {
            // Lazy set selection to highlighted area
            sel_startoff = hl_startoff;
            sel_endoff   = hl_endoff;
         }

         if(sel_endoff > sel_startoff) // have selection ?
         {
            beginCycleMode();

            if(-1 != getSelectedRegionIdx())
            {
               Global.SuccessShort("SampleView: cycle edit mode is now enabled ("+getNumRegions()+" region"+Utils.GetPluralString(getNumRegions())+")");
            }
            else
            {
               Global.SuccessShort("SampleView: cycle edit mode is now enabled.");
            }
         }
         else
         {
            Global.Warning("SampleView: cannot enable cycle mode since there is no selection");
         }
      }
      redraw();
   }

   public method toggleZeroCrossingMode() {
      b_zerox_mode = !b_zerox_mode;
      Global.Print("Snap-to-zero-crossing mode is "+Utils.GetEnableString(b_zerox_mode));
   }

   public method setEnableZeroCrossingMode(boolean _bEnable) {
      b_zerox_mode = _bEnable;
   }

   protected method snapFrameOffset(int _off, int _mouseX, boolean _bAllowMarker) : int {
      if(b_bpm_snap)
      {
         int relOff = _off - bpm_snap_ref_frame;
         float snapFrames = getBPMSnapFrames();
         if(relOff >= 0)
            relOff = int(0.5 + (relOff / snapFrames)) * snapFrames;
         else
         {
            relOff = -relOff;
            relOff = int(0.5 + (relOff / snapFrames)) * snapFrames;
            relOff = -relOff;
         }
         _off = bpm_snap_ref_frame + relOff;
      }
      else if(b_marker_snap && _bAllowMarker)
      {
         _off = findMarkerOffsetNearFrame(_off);
      }
      else if(b_zerox_mode)
      {
         if((_mouseX > 0) && (_mouseX < (getSizeX()-1)))  // disable snap at widget border
         {
            if(null != samples)
            {
               if(samples.numElements > 0)
               {
                  if(!tksampleedit_is_zerocrossing(samples, 0/*chOff*/, num_channels, _off))
                  {
                     // trace "xxx snapFrameOffset: off="+_off+" find_zerocrossing";
                     _off = tksampleedit_find_zerocrossing_near(samples, 0/*chOff*/, num_channels, _off, 0.0001f/*distThreshold*/);
                     // trace "xxx snapFrameOffset:   => off="+_off;
                  }
                  else
                  {
                     float fCur = abs(samples.get(_off*num_channels+0/*chOff*/));
                     float fPrev = (_off > 0) ? abs(samples.get((_off-1)*num_channels+0/*chOff*/)) : fCur;
                     float fNext = (_off + 1 < (samples.numElements / num_channels)) ? abs(samples.get((_off+1)*num_channels+0/*chOff*/)) : fCur;
                     // trace "xxx snapFrameOffset: off="+_off+" is_zerocrossing, fPrev="+fPrev+" fCur="+fCur+" fNext="+fNext;
                     if(fPrev < fCur)
                     {
                        if(fNext < fCur)
                           _off++;
                        else
                           _off--;
                     }
                     else if(fNext < fCur)
                        _off++;
                     // trace "xxx snapFrameOffset:   => off="+_off;
                  }
               }
            }
         }
      }
      return _off;
   }

   public method setSelectionMS(float _startMS, float _lenMS) {
      if(samples.numElements > 0)
      {
         int startOff = (_startMS * sample_rate) / 1000.0;
         int endOff = startOff + (_lenMS * sample_rate) / 1000.0;
         setSelection(startOff, endOff);
      }
   }

   public method setSelection(int _start, _end) {
      // trace "[dbg] SampleView::setSelection("+_start+", "+_end+")";
      if(_start == _end)
      {
         endCycleMode();
      }

      if(null != samples)
      {
         sel_startoff = _start;
         sel_endoff   = _end;
         if(sel_endoff < sel_startoff)
         {
            int t = sel_startoff;
            sel_startoff = sel_endoff;
            sel_endoff   = t;
         }

         // trace "xxx samples.numElements="+samples.numElements+" num_channels="+num_channels;

         if(sel_startoff >= (samples.numElements / num_channels))
         {
            sel_startoff = 0;
            sel_endoff = 0;
         }

         if(sel_endoff >= (samples.numElements / num_channels))
         {
            sel_endoff = (samples.numElements / num_channels);
         }

         int selLen = (sel_endoff - sel_startoff);

         int numFrames = samples.numElements / num_channels;

         // Clip end
         if(sel_endoff > numFrames)
         {
            sel_startoff = numFrames - selLen;
            sel_endoff = numFrames;
         }
         else if(sel_endoff < 0)
         {
            sel_endoff = 0;
         }

         // Clip start
         if(sel_startoff > numFrames)
         {
            sel_startoff = numFrames - selLen;
         }
         else if(sel_startoff < 0)
         {
            sel_startoff = 0;
         }

         // Select both channels (if stereo)
         if((0 == sel_channel_mask) || (1 == num_channels))
         {
            sel_channel_mask = CHANNEL_MASK_LR;
         }

         // trace "[dbg] SampleView::setSelection("+sel_startoff+", "+sel_endoff+") numFrames="+numFrames;
      }
      else
      {
         sel_startoff = 0;
         sel_endoff   = 0;
      }
      UI.CompositeAll();
   }

   public method setSelectionToStart() {
      int oldSelLen = getNumSelectedSamples();
      if(0 == oldSelLen)
         oldSelLen = getNumVisibleSamples();

      setSelection(0, oldSelLen);
      makeSelectionVisible();
   }

   public method expandSelectionToEnd() {
      if(haveSamples())
      {
         int oldSelStart = sel_startoff;
         int oldSelEnd = sel_endoff;
         int oldSelLen = getNumSelectedSamples();
         if(0 == oldSelLen)
            oldSelLen = getNumVisibleSamples();

         if(b_cycle_mode)
         {
            setSelection(getNumFrames()-oldSelLen, getNumFrames());
         }
         else
         {
            setSelection(oldSelStart, getNumFrames());
         }

         makeSelectionVisible();

         if((sel_startoff == oldSelStart) && (sel_endoff == oldSelEnd))
         {
            sel_startoff = getNumFrames();
            sel_endoff = getNumFrames();
         }
      }
   }

   public method getSelectionStartOffset() : int {
      if(haveSelection())
      {
         return sel_startoff;
      }
      return 0;
   }

   public method getSelectionEndOffset() : int {
      if(haveSelection())
      {
         return sel_endoff;
      }
      return 0;
   }

   public method getSelectionLen() : int {
      if(haveSelection())
      {
         return sel_endoff - sel_startoff;
      }
      return 0;
   }

   public virtual calcMinimumSizeY() {
      minimum_size_y = MIN_SIZE_Y;
   }

   protected method calcMinZoom() : float {
      if(null != samples)
      {
         float numFrames = samples.numElements / num_channels;
         float minZoom = (getSizeX() / numFrames); // req.zoom to get 1:1 sample-to-pixel mapping
         return minZoom * (1.0/48); // minimum zoom = ~20 samples visible
      }
   }

   protected method calcScrollSpd() : float {
      if(null != samples)
      {
         float numFrames = samples.numElements / num_channels;
         float numVisSamples = numFrames * zoom;
         float offPerScreen = (numVisSamples / numFrames);
         return offPerScreen * 0.25;
      }
   }

   protected method getNumVisibleSamples() : int {
      if(null != samples)
      {
         float numFrames = samples.numElements / num_channels;
         float numVisSamples = numFrames * zoom;
         return numVisSamples;
      }
      return 0;
   }

   protected method scrollOffset2(float dx, float _accel) {
      float scrSpd = calcScrollSpd() * dx * -0.125;
      scrSpd *= _accel;
      setOffset(offset + scrSpd);
      redraw();
   }

   protected method scrollOffset(MouseEvent _ev, float _accel) {
      float dx = _ev.mouse_rel_x - last_rel_x;
      scrollOffset2(dx, _accel);
   }

   public method setEnableAllowChannelConversion(boolean _bEnable) {
      b_allow_channel_conversion = _bEnable;
   }

   public method setEnableAutoAddStereoChannel(boolean _bEnable) {
      b_autoadd_stereo_channel = _bEnable;
   }

   public method setEnableExport(boolean _bEnable) {
      b_no_export = !_bEnable;
   }

   public static SetBPM(float _bpm) {
      bpm = _bpm;
   }

   protected method updateBPMSnapRefFrame() {
      boolean bHaveSel = (sel_endoff > sel_startoff);
      if(bHaveSel)
      {
         bpm_snap_ref_frame = sel_startoff;
      }
      else
      {
         bpm_snap_ref_frame = 0;
      }
   }

   public method setEnableBPMSnap(boolean _bEnable, boolean _bQuiet) {
      b_bpm_snap = _bEnable;

      if(!_bQuiet)
      {
         float ms = getBPMSnapMS();
         int numFrames = 0.5 + ((ms * sample_rate) / 1000.0);
         Global.Print("BPM snap is "+Utils.GetEnableString(b_bpm_snap)+" (1/"+bpm_snap_grid+" => "+ms+" ms / "+numFrames+" frames)");
      }

      cur_snap_num = 0;
      last_snap_num = 0;

      if(_bEnable)
         updateBPMSnapRefFrame();
   }

   public method getBPMSnapMS() : float {
      float numQ = (4.0 / bpm_snap_grid);
      float ms = (1000 * 60.0 * numQ) / bpm;
      return ms;
   }

   public method getBPMSnapFrames() : float {
      float numQ = (4.0 / bpm_snap_grid);
      float ms = (1000 * 60.0 * numQ) / bpm;
      return (sample_rate * ms) / 1000.0;
   }

   public method cycleBPMSnapGrid() {
      switch(bpm_snap_grid)
      {
         default:
         case 1:
            bpm_snap_grid = 2;
            break;

         case 2:
            bpm_snap_grid = 4;
            break;

         case 4:
            bpm_snap_grid = 8;
            break;

         case 8:
            bpm_snap_grid = 16;
            break;

         case 16:
            bpm_snap_grid = 1;
            break;
      }

      float ms = getBPMSnapMS();
      int numFrames = 0.5 + ((ms * sample_rate) / 1000.0);
      Global.Print("BPM snap grid is 1/"+bpm_snap_grid+" ("+ms+" ms, "+numFrames+" frames)");
   }

   public method setBPMSnapGrid(int _grid) {
      bpm_snap_grid = _grid;
   }

   public method setEnableMarkerSnap(boolean _bEnable, boolean _bQuiet) {
      b_marker_snap = _bEnable;

      if(!_bQuiet)
         Global.Print("Marker snap is "+Utils.GetEnableString(b_marker_snap));
   }

   public method cycleBPMMarkerSnapModes() {
      // off => marker => bpm
      if(b_bpm_snap)
      {
         setEnableBPMSnap(false, true/*bQuiet*/);
         setEnableMarkerSnap(false, true/*bQuiet*/);
         Global.Print("Disable bpm+marker snap");
      }
      else if(b_marker_snap)
      {
         setEnableBPMSnap(true, false/*bQuiet*/);
         setEnableMarkerSnap(false, true/*bQuiet*/);
      }
      else
      {
         setEnableBPMSnap(false, true/*bQuiet*/);
         setEnableMarkerSnap(true, false/*bQuiet*/);
      }
   }

   public method setSample(StWaveform _waveform, FloatArray _samples, int _numCh, float _sampleRate) {
      // trace "xxx SampleView::setSample: wf="+#(_waveform)+" samples="+#(_samples);

      bpm_snap_ref_frame = 0;

      if(null != _waveform)
      {
         waveform <= _waveform;
         offset    = _waveform.uiGetOffset();
         zoom      = _waveform.uiGetZoom();
      }
      else
      {
         waveform <= null;
         offset    = 0;
         zoom      = 1.0f;
      }

      num_channels = _numCh;
      sample_rate  = _sampleRate;
      samples     <= _samples;

      invalidateAutoChop();

      if(b_autorecalc_autochop)
         recalcAutoChopRegions();

      setSelection(sel_startoff, sel_endoff);

      highlightNone();

      b_freedraw = false;

      ta_key_scroll.cancel();
      key_scroll_dir = 0;

      autoscrollTimerAction.cancel();

      wavetable_cycle_len = 0;
      wavetable_cycle_off = 0;
   }

   public method getWaveform() : StWaveform {
      return waveform;
   }

   public method getSamples() : FloatArray {
      return samples;
   }

   public method haveSamples() : boolean {
      if(null != samples)
         if(samples.numElements > 0)
            return true;
      return false;
   }

   public method getNumFrames() : int {
      if(null != samples)
      {
         return samples.numElements / num_channels;
      }
      return 0;
   }

   public method getNumChannels() : int {
      return num_channels;
   }

   public method getSampleRate() : float {
      return sample_rate;
   }

   public method getNumSelectedSamples() : int {
      if(haveSelection())
      {
         return (sel_endoff - sel_startoff);
      }
      return 0;
   }

   public method getSelectedSamples() : FloatArray {
      if(haveSelection())
      {
         local FloatArray ret;
         ret.visit(samples, sel_startoff*num_channels, (sel_endoff - sel_startoff)*num_channels);
         return deref ret;
      }
      return null;
   }

   public method getSelectionChannelOffset() : int {
      int r = 0;

      switch(num_channels)
      {
         case 1:
            break;

         case 2:
            switch(sel_channel_mask)
            {
               case CHANNEL_MASK_L:
                  break;

               case CHANNEL_MASK_R:
                  r = 1;
                  break;

               case CHANNEL_MASK_LR:
                  break;
            }
      }

      return r;
   }

   public method getSelectionNumChannels() : int {
      int r = 1;

      switch(num_channels)
      {
         case 1:
            break;

         case 2:
            switch(sel_channel_mask)
            {
               case CHANNEL_MASK_L:
                  break;

               case CHANNEL_MASK_R:
                  break;

               case CHANNEL_MASK_LR:
                  r = 2;
                  break;
            }
      }

      return r;
   }

   public method getRegionSamplesByIdx(int _idx) : FloatArray {
      if(_idx < autochop_start_offsets.numElements)
      {
         local FloatArray ret;
         ret.visit(samples,
                   autochop_start_offsets[_idx] * num_channels,
                   (autochop_end_offsets[_idx] - autochop_start_offsets[_idx]) * num_channels
                   );
         return deref ret;
      }
      return null;
   }

   public method getSelectedRegionIdx() : int {
      if(autochop_start_offsets.numElements > 0)
      {
         int startOff;
         int regionIdx = 0;
         foreach startOff in autochop_start_offsets
         {
            if(sel_startoff == startOff)
               return regionIdx;
            regionIdx++;
         }
      }
      return -1;
   }

   public method isRegionSelected() : boolean {
      if(autochop_start_offsets.numElements > 0)
      {
         int startOff;
         int regionIdx = 0;
         foreach startOff in autochop_start_offsets
         {
            if(sel_startoff == startOff)
            {
               // trace "xxx isRegionSelected: sel_endoff="+sel_endoff+" regionEndOff="+autochop_end_offsets.get(regionIdx);
               return (sel_endoff == autochop_end_offsets.get(regionIdx));
            }
            regionIdx++;
         }
      }
      return false;
   }

   public method selectRegionByIdx(int _idx) {
      lazyAutoChopRegions();
      if(0 <= _idx < autochop_start_offsets.numElements)
      {
         setSelection(autochop_start_offsets.get(_idx),
                      autochop_end_offsets.get(_idx)
                      );
         makeSelectionVisible();
         return true;
      }
      return false;
   }

   public method findMarkerOffsetNearFrame(int _frame) : int {
      int bestDelta = 9999999999;
      int bestRes = _frame;

      if(autochop_start_offsets.numElements > 0)
      {
         int off;
         int regionIdx = 0;
         int dt;
         foreach off in autochop_start_offsets
         {
            dt = abs(off - _frame);
            if(dt < bestDelta)
            {
               bestDelta = dt;
               bestRes = off;
            }
         }

         foreach off in autochop_end_offsets
         {
            dt = abs(off - _frame);
            if(dt < bestDelta)
            {
               bestDelta = dt;
               bestRes = off;
            }
         }
      }

      return bestRes;
   }

   protected method getChannelMaskByMouseY(float _y) : int {

      if(2 == num_channels)
      {
         float sy = calcSampleSizeY();

         if(_y < (sy*0.25))
         {
            // Left
            return 1;
         }
         else if(_y >= (sy*0.75))
         {
            // Right
            return 2;
         }
         else
         {
            // Both
            return 3;
         }
      }

      return 3;
   }

   protected method determineGrabMode(MouseEvent _ev) : int {
      int smpOffL = calcSampleOffsetAtMouseX(_ev.mouse_rel_x - 4);
      int smpOffR = calcSampleOffsetAtMouseX(_ev.mouse_rel_x + 4);

      if(smpOffL <= sel_startoff <= smpOffR)
      {
         if(sel_endoff <= sel_startoff &&
            hl_endoff > hl_startoff
            )
         {
            // prefer highlight if there's no selection
            //  (note) e.g. when adjusting highlight at start of sample
            if(b_render_highlight && (smpOffL <= hl_startoff <= smpOffR) && (hl_endoff > hl_startoff))
            {
               grab_initial_startoff = hl_startoff;
               grab_initial_endoff   = hl_endoff;
               return GRAB_HLSTART;
            }
         }

         grab_initial_startoff = sel_startoff;
         grab_initial_endoff   = sel_endoff;
         grab_initial_sel_channel_mask = sel_channel_mask;
         return GRAB_SELSTART;
      }
      else if(smpOffL <= sel_endoff <= smpOffR)
      {
         grab_initial_startoff = sel_startoff;
         grab_initial_endoff   = sel_endoff;
         grab_initial_sel_channel_mask = sel_channel_mask;
         return GRAB_SELEND;
      }
      else if(b_render_highlight && (smpOffL <= hl_startoff <= smpOffR) && (hl_endoff > hl_startoff))
      {
         grab_initial_startoff = hl_startoff;
         grab_initial_endoff   = hl_endoff;
         return GRAB_HLSTART;
      }
      else if(b_render_highlight && (smpOffL <= hl_endoff <= smpOffR) && (hl_endoff > hl_startoff))
      {
         grab_initial_startoff = hl_startoff;
         grab_initial_endoff   = hl_endoff;
         return GRAB_HLEND;
      }
      else
      {
         return GRAB_NEWSELECTION;
      }
   }

   protected method calcSampleValueAtMouseY(float _y, Integer _retChannelIdx) : float {
      float sampleSizeY = calcSampleSizeY() - 4;
      if(2 == num_channels)
      {
         sampleSizeY *= 0.5;
         _retChannelIdx = (_y >= sampleSizeY);
         if(_retChannelIdx > 0)
            _y -= sampleSizeY;
      }
      else
      {
         _retChannelIdx = 0;
      }
      // cy = _h - ( (val - min) * scly)
      //
      // cy - h = - ( (val - min) * scly)
      // cy - h = (val - min) * -scly
      // (cy - h)/-scly = val - min
      // (cy - h)/-scly + min = val

      // // float scly = (sampleSizeY / ( max_sample - min_sample));

      // (cy - sampleSizeY) * -((( max_sample - min_sample)/sampleSizeY)) + min = val

      float val = (_y - sampleSizeY - 4) * -((max_sample-min_sample)/sampleSizeY) + min_sample;
      val *= zoom_y;
      return mathClampf(val, min_sample, max_sample);
   }

   protected =replay= method handleFreeDraw(MouseEvent _ev) {
      if(null != samples)
      {
         boolean bAllowFreeDraw = (getNumVisibleSamples() < (size_x - 4));

         if(!bAllowFreeDraw || b_readonly)
            return;

         int smpOff = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
         if(0 <= smpOff < samples.numElements)
         {
            // // if(1 == num_channels)
            // // {
               Integer retChannelIdx;
               float smpVal = calcSampleValueAtMouseY(_ev.mouse_rel_y, retChannelIdx);

               ////trace "xxx handleFreeDraw: smpoff="+smpOff+" smpVal="+smpVal+" sel_startoff="+sel_startoff+" sel_endoff="+sel_endoff;
               Global.Print("Freedraw: offset="+smpOff+" ch="+retChannelIdx+" value="+smpVal);

               boolean bHaveSel = (sel_endoff > sel_startoff);

               int realOff;
               int ringOff;
               int numSampleFrames = samples.numElements / num_channels;

               if(null != waveform)
               {
                  ringOff = waveform.ringOffset;
               }
               else
               {
                  ringOff = 0;
               }

               if(-1 != freedraw_last_offset)
               {
                  // Interpolate
                  float a;
                  float d;
                  float t = 0.0f;
                  int cOff;

                  if(smpOff < freedraw_last_offset)
                  {
                     d = (freedraw_last_value - smpVal);
                     a = 1.0 / (freedraw_last_offset - smpOff);
                     cOff = smpOff;

                     undoActionModify(cOff, (freedraw_last_offset - cOff), CHANNEL_MASK_LR);

                     while(cOff < freedraw_last_offset)
                     {
                        realOff = cOff + ringOff;
                        if(realOff >= numSampleFrames)
                           realOff -= numSampleFrames;

                        if(bHaveSel)
                        {
                           if(sel_startoff <= cOff < sel_endoff)
                           {
                              samples[realOff*num_channels + retChannelIdx] = smpVal + d * t;
                           }
                        }
                        else
                        {
                           samples[realOff*num_channels + retChannelIdx] = smpVal + d * t;
                        }
                        cOff++;
                        t += a;
                     }
                  }
                  else if(smpOff > freedraw_last_offset)
                  {
                     d = (freedraw_last_value - smpVal);
                     a = 1.0f / (freedraw_last_offset - smpOff);
                     cOff = freedraw_last_offset;

                     undoActionModify(cOff, (smpOff + 1 - cOff), CHANNEL_MASK_LR);

                     while(cOff <= smpOff)
                     {
                        realOff = cOff + ringOff;
                        if(realOff >= numSampleFrames)
                           realOff -= numSampleFrames;

                        if(bHaveSel)
                        {
                           if(sel_startoff <= cOff < sel_endoff)
                           {
                              samples[realOff*num_channels + retChannelIdx] = freedraw_last_value + d * t;
                           }
                        }
                        else
                        {
                           samples[realOff*num_channels + retChannelIdx] = freedraw_last_value + d * t;
                        }
                        cOff++;
                        t += a;
                     }
                  }
                  else
                  {
                     undoActionModify(smpOff, 1, CHANNEL_MASK_LR);

                     realOff = smpOff + ringOff;
                     if(realOff >= numSampleFrames)
                        realOff -= numSampleFrames;

                     if(bHaveSel)
                     {
                        if(sel_startoff <= smpOff < sel_endoff)
                        {
                           samples[smpOff*num_channels + retChannelIdx] = smpVal;
                        }
                     }
                     else
                     {
                        samples[smpOff*num_channels + retChannelIdx] = smpVal;
                     }
                  }
               } // if -1 != freedraw_offset
               else
               {
                  realOff = smpOff + ringOff;
                  if(realOff >= numSampleFrames)
                     realOff -= numSampleFrames;

                  undoActionModify(smpOff, 1, CHANNEL_MASK_LR);

                  if(bHaveSel)
                  {
                     if(sel_startoff <= smpOff < sel_endoff)
                     {
                        samples[smpOff*num_channels + retChannelIdx] = smpVal;
                     }
                  }
                  else
                  {
                     samples[smpOff*num_channels + retChannelIdx] = smpVal;
                  }
               }
               freedraw_last_offset = smpOff;
               freedraw_last_value  = smpVal;
               redraw();
            // // } // if 1==num_channels
         }
      }
   }

   protected method findRegionIdxNearMouseX(float _mouseX) : int {
      int smpOffL = calcSampleOffsetAtMouseX(_mouseX - 4*UI.font_scaling);
      int smpOffR = calcSampleOffsetAtMouseX(_mouseX + 4*UI.font_scaling);
      int regionIdx = 0;
      loop(autochop_start_offsets.numElements)
      {
         int startOff = autochop_start_offsets.get(regionIdx);
         if(smpOffL <= startOff <= smpOffR)
         {
            return regionIdx;
         }
         regionIdx++;
      }
      return -1;
   }

   protected method tryCreateMarkerNearMouseX(float _mouseX, boolean _bQuiet) : int {
      // returns new regionIdx
      int numFrames = getNumFrames();
      if(numFrames > 0)
      {
         int smpOff = calcSampleOffsetAtMouseX(_mouseX);
         smpOff = snapFrameOffset(smpOff, _mouseX, false/*bAllowMarker*/);
         int regionIdx = 0;
         loop(autochop_start_offsets.numElements)
         {
            int startOff = autochop_start_offsets.get(regionIdx);
            if(startOff > smpOff)
            {
               // Create before existing marker
               if(!_bQuiet)
                  Global.Print("Create region "+(regionIdx+1)+"/"+(autochop_start_offsets.numElements+1)+" at offset "+smpOff);
               // Shorten previous region
               if(regionIdx > 0)
                  autochop_end_offsets[regionIdx-1] = smpOff;
               autochop_start_offsets.insert(regionIdx, smpOff);
               autochop_end_offsets.insert(regionIdx, autochop_start_offsets.get(regionIdx+1));
               redraw();
               return regionIdx;
            }
            regionIdx++;
         }
         // Create after last marker
         // Shorten previous region
         if(autochop_end_offsets.numElements > 0)
            autochop_end_offsets[autochop_end_offsets.numElements-1] = smpOff;
         autochop_start_offsets.add(smpOff);
         autochop_end_offsets.add(numFrames);
         if(!_bQuiet)
            Global.Print("Create region "+(autochop_start_offsets.numElements)+"/"+(autochop_start_offsets.numElements)+" at offset "+smpOff);
         redraw();
         return autochop_start_offsets.numElements - 1;
      }
      return -1;
   }

   protected method tryDeleteMarkerNearMouseX(float _mouseX) : boolean {
      int numFrames = getNumFrames();
      if(numFrames > 0)
      {
         int smpOffL = calcSampleOffsetAtMouseX(_mouseX - 4);
         int smpOffR = calcSampleOffsetAtMouseX(_mouseX + 4);
         int regionIdx = 0;
         loop(autochop_start_offsets.numElements)
         {
            int startOff = autochop_start_offsets.get(regionIdx);
            if(smpOffL <= startOff <= smpOffR)
            {
               Global.Print("Delete region "+(regionIdx+1)+"/"+autochop_start_offsets.numElements);
               if(regionIdx > 0)
               {
                  // extend previous region
                  if((regionIdx+1) < autochop_start_offsets.numElements)
                  {
                     // until next region
                     autochop_end_offsets[regionIdx-1] = autochop_start_offsets[regionIdx+1];
                  }
                  else
                  {
                     // until end of sample
                     autochop_end_offsets[regionIdx-1] = numFrames;
                  }
               }
               autochop_start_offsets.delete(regionIdx);
               autochop_end_offsets.delete(regionIdx);
               redraw();
               return true;
            }
            regionIdx++;
         }
      }
      return false;
   }

   public virtual isMouseFocusLocked() : boolean {
      return ((b_freedraw && b_drawing) || b_grab_lmb_scrollbar || b_grab_lmb_selection || b_grab_rmb);
   }

   public virtual onMouseLeave(MouseEvent _ev) returns boolean {
      UI.ShowCursor(UIConstants.CURSOR_NORMAL);
      return Control::onMouseLeave(_ev);
   }

   public virtual onMouseDoubleClick(MouseEvent _ev) : boolean {
      // trace "xxx SampleView::onMouseDoubleClick: mouse_rel_y="+_ev.mouse_rel_y+" wavetable_cycle_len="+wavetable_cycle_len;
      if(_ev.isLeftButton())
      {
         if(sel_startoff == sel_endoff)
         {
            // "Hide" selection marker
            sel_startoff = 0;
            sel_endoff = 0;
            redraw();
         }

         if(0 != wavetable_cycle_len)
         {
            int selStart = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
            selStart -= wavetable_cycle_off;
            if(selStart < 0)
               selStart = 0;
            else
               selStart = int(selStart / wavetable_cycle_len) * wavetable_cycle_len;
            setSelection(selStart, selStart + wavetable_cycle_len);
            fitSelectionToWindow();

            int selLen = sel_endoff - sel_startoff;
            // int numVis = getNumVisibleSamples();
            // if( (selLen*11) < numVis )
            {
               // make cycle visible
               makeAreaVisible(sel_startoff - selLen*4, sel_endoff + selLen*4);
               // // makeAreaVisible(sel_startoff - selLen, sel_endoff + selLen);
               if(!isSelectionFullyVisible())
               {
                  fitSelectionToWindow();
               }
            }

            b_cycle_mode = true;
         }
         else if(trySelectHighlightedAreaUnderMouse(_ev))
         {
            // Is also autochop region ?
            lazyAutoChopRegions();
            if(-1 != getSelectedRegionIdx())
            {
               if(0 == wavetable_cycle_len)
               {
                  if(b_region_auto_cyclemode && !b_cycle_mode)
                  {
                     toggleCycleMode(null);
                  }
               }
            }
         }
         else
         {
            if(trySelectRegionUnderMouse(_ev))
            {
               if(b_region_auto_cyclemode && !b_cycle_mode)
               {
                  toggleCycleMode(null);
               }
            }
         }
      }
      return true;
   }

   public virtual onMouseClick(MouseEvent _ev) : boolean {
      // trace "xxx SampleView::onMouseClick: mouse_rel_y="+_ev.mouse_rel_y;
      if(b_drawing)
         return false;

      if(_ev.isRightButton())
      {
         if(((MARKER_PY*UI.icon_scaling)-1) <= _ev.mouse_rel_y <= ((MARKER_PY*UI.icon_scaling)+(MARKER_SY*UI.icon_scaling)+1))
         {
            if(b_marker_delete)
               tryDeleteMarkerNearMouseX(_ev.mouse_rel_x);
         }
         else if((_ev.mouse_rel_y < SELINFO_SY) || (_ev.mouse_rel_y >= (size_y - SELINFO_SY)))
         {
            showFloatParamForMouseX(_ev.mouse_rel_x, (_ev.mouse_rel_y >= (size_y - SELINFO_SY))/*bLower*/);
         }
         else
         {
            showContextMenu();
         }
         return true;
      }
      else if(_ev.isLeftButton())
      {
         if(VMOD_LCTRL == UI.GetKeyMod())
         {
            if(b_marker_delete)
            {
               if(!tryDeleteMarkerNearMouseX(_ev.mouse_rel_x))
                  if(b_marker_create)
                     tryCreateMarkerNearMouseX(_ev.mouse_rel_x, false/*bQuiet*/);
            }
            else if(b_marker_create)
               tryCreateMarkerNearMouseX(_ev.mouse_rel_x, false/*bQuiet*/);
            return true;
         }
         if(((MARKER_PY*UI.icon_scaling)-1) <= _ev.mouse_rel_y <= ((MARKER_PY*UI.icon_scaling)+(MARKER_SY*UI.icon_scaling)+1))
         {
            if(b_marker_create)
               tryCreateMarkerNearMouseX(_ev.mouse_rel_x, false/*bQuiet*/);
            return true;
         }
      // //    int grabMode = determineGrabMode(_ev);
      // //    trace "xxx SampleView::onMouseClick: grabMode="+grab_mode;
      // //    if(GRAB_NEWSELECTION == grabMode) // not near start/end marker ?
      // //    {
      // //       // abcdef
      // //       selectNone();
      // //    }
      }
      else if(_ev.isMiddleButton())
      {
         if(0 != (UI.GetKeyMod() & (VMOD_LSHIFT | VMOD_LCTRL | VMOD_RSHIFT | VMOD_RCTRL)))
         {
            toggleZeroCrossingMode();
            return true;
         }
         else
         {
            cycleBPMMarkerSnapModes();
            return true;
         }
      }
      return false;
   }

   public virtual onMouseHold(MouseEvent _ev) : boolean {
      if(_ev.isRightButton())
      {
         showContextMenu();
         return true;
      }
      else if(_ev.isMiddleButton())
      {
         toggleZeroCrossingMode();
         return true;
      }
   }

   public virtual onMouseBeginDrag(MouseEvent _dragStart, MouseEvent _ev) : boolean {
      // (note) LMB-drag handling is still done in onMouse() (code should be updated)
      // trace "xxx SampleView::onMouseBeginDrag";
      if(_ev.isRightButtonDown() &&
         !b_grab_lmb_scrollbar   &&
         !b_grab_lmb_selection
         )
      {
         last_rel_x = _ev.mouse_rel_x;
         b_grab_rmb = true;
         b_rmb_dragged = false;
         UI.ShowCursor(UIConstants.CURSOR_GRABBED);
         return true;
      }
      else if(_ev.isLeftButtonDown())
      {
         if(((MARKER_PY*UI.icon_scaling)-1) <= _ev.mouse_rel_y <= ((MARKER_PY*UI.icon_scaling)+(MARKER_SY*UI.icon_scaling)+1))
         {
            drag_region_idx = findRegionIdxNearMouseX(_dragStart.mouse_rel_x);
            if(-1 != drag_region_idx)
            {
               // trace "xxx drag_region_idx="+drag_region_idx;
               drag_undo_autochop_start_offsets = autochop_start_offsets;
               drag_undo_autochop_end_offsets   = autochop_end_offsets;
               return true;
            }
         }
      }
      return false;
   }

   public virtual onMouseDrag(MouseEvent _lastEv, MouseEvent _currentEv) : boolean {
      if(-1 != drag_region_idx)
      {
         // trace "xxx onMouseDrag: drag_region_idx="+drag_region_idx;
         autochop_start_offsets = drag_undo_autochop_start_offsets;
         autochop_end_offsets   = drag_undo_autochop_end_offsets;
         autochop_start_offsets.delete(drag_region_idx);
         autochop_end_offsets.delete(drag_region_idx);
         int newRegionIdx = tryCreateMarkerNearMouseX(_currentEv.mouse_rel_x, true/*bQuiet*/);
         if(-1 != newRegionIdx)  // shouldn't be -1
         {
            if(null != plugin)
            {
               plugin.svHandleMarkerChanged(drag_region_idx,  // use original region idx (see PageSample)
                                            autochop_start_offsets.get(newRegionIdx),
                                            autochop_end_offsets.get(newRegionIdx)
                                            );
            }
            Global.PrintFast("Drag "+(drag_region_idx+1)+"/"+autochop_start_offsets.numElements+" to offset "+autochop_start_offsets.get(newRegionIdx));
         }
         return true;
      }
      else if(b_grab_rmb)
      {
         // RMB Scroll
         scrollOffset(_currentEv, 1.0);
         if(last_rel_x != _currentEv.mouse_rel_x)  // (todo) use _lastEv
         {
            // Mouse was actually dragged, do not allow context menu until next RMB click
            b_rmb_dragged = true;
         }
         last_rel_x = _currentEv.mouse_rel_x;
         return true;
      }
      return false;
   }

   public virtual onMouseEndDrag(MouseEvent _ev) {
      // trace "xxx SampleView::onMouseEndDrag: b_grab_rmb="+b_grab_rmb+" drag_region_idx="+drag_region_idx;
      if(-1 != drag_region_idx)
      {
         drag_region_idx = -1;
         redraw();
      }
      else if(b_grab_rmb)
      {
         b_grab_rmb = false;
         UI.RevertCursor();

         if(!b_rmb_dragged)
         {
            return true;
         }

         redraw();
      }
   }

   public virtual onMouseCancelDrag(MouseEvent _ev) {
      if(-1 != drag_region_idx)
      {
         // undo
         Global.Print("Cancel marker drag and revert to offset "+drag_undo_autochop_start_offsets.get(drag_region_idx));
         if(null != plugin)
         {
            plugin.svHandleMarkerChanged(drag_region_idx,
                                         drag_undo_autochop_start_offsets.get(drag_region_idx),
                                         drag_undo_autochop_end_offsets.get(drag_region_idx)
                                         );
         }
         drag_region_idx = -1;
         autochop_start_offsets = drag_undo_autochop_start_offsets;
         autochop_end_offsets   = drag_undo_autochop_end_offsets;
         redraw();
      }
      else
      {
         // "other" mouse button was pressed
         // trace "xxx SampleView::onMouseCancelDrag";
         onMouseEndDrag(_ev);
      }
   }

   public virtual onMouse(MouseEvent _ev) : boolean {
      int smpOff;

      // trace "xxx SampleView::onMouse: rel_x="+_ev.mouse_rel_x;
      // trace "xxx SampleView::onMouse: cbs="+_ev.current_state+" nbs="+_ev.changed_state;

      if(_ev.isLeftButton())
      {
         grabKeyboardFocus();
      }

      if(_ev.wheelUp())
      {
         if(UI.KeyModShift() && UI.KeyModCtrl())
         {
            moveSelectedRegionLeft();
         }
         else
         {
            if(b_cycle_mode)
            {
               if(VMOD_LCTRL == UI.GetKeyMod())
               {
                  uiZoomIn(_ev);
               }
               else
               {
                  if( (0 == wavetable_cycle_len) && (autochop_start_offsets.numElements > 1) && (-1 != getSelectedRegionIdx()) )////getNumSelectedSamples() > CYCLEMODE_MAX_NUM_FRAMES)
                     selectPreviousAutoChopRegion();
                  else
                     selectPreviousCycle();
               }
            }
            else if(VMOD_LCTRL == UI.GetKeyMod())
            {
               uiZoomInY();
            }
            else if(VMOD_LSHIFT == UI.GetKeyMod())
            {
               selectPreviousAutoChopRegion();
            }
            else
            {
               uiZoomIn(_ev);
            }
         }
         return true;
      }
      else if(_ev.wheelDown())
      {
         if(UI.KeyModShift() && UI.KeyModCtrl())
         {
            moveSelectedRegionRight();
         }
         else
         {
            if(b_cycle_mode)
            {
               if(VMOD_LCTRL == UI.GetKeyMod())
               {
                  uiZoomOut(_ev);
               }
               else
               {
                  // trace "xxx getSelectedRegionIdx()="+getSelectedRegionIdx()+" autochop_start_offsets="+autochop_start_offsets;
                  if( (0 == wavetable_cycle_len) && (autochop_start_offsets.numElements > 1) && (-1 != getSelectedRegionIdx()) )////getNumSelectedSamples() > CYCLEMODE_MAX_NUM_FRAMES)
                     selectNextAutoChopRegion();
                  else
                     selectNextCycle();
               }
            }
            else if(VMOD_LCTRL == UI.GetKeyMod())
            {
               uiZoomOutY();
            }
            else if(VMOD_LSHIFT == UI.GetKeyMod())
            {
               selectNextAutoChopRegion();
            }
            else
            {
               uiZoomOut(_ev);
            }
         }
         return true;
      }

      // Toggle RMB mousescroll grab or cancel LMB hl/sel start/end drag
      if!(b_freedraw && b_drawing)
      {
         if(_ev.changed_state & MOUSE_RBUTTON)
         {
            if(_ev.current_state & MOUSE_RBUTTON)
            {
               if(b_grab_lmb_selection)
               {
                  // Undo
                  switch(grab_mode)
                  {
                     case GRAB_HLSTART:
                        hl_startoff = grab_initial_startoff;
                        hl_endoff   = grab_initial_endoff;
                        b_grab_lmb_selection = false;
                        grab_mode = GRAB_NONE;
                        UI.RevertCursor();
                        handleHighlightChanged();
                        redraw();
                        return true;

                     case GRAB_HLEND:
                        hl_startoff = grab_initial_startoff;
                        hl_endoff   = grab_initial_endoff;
                        b_grab_lmb_selection = false;
                        grab_mode = GRAB_NONE;
                        UI.RevertCursor();
                        handleHighlightChanged();
                        redraw();
                        return true;

                     case GRAB_SELSTART:
                        sel_startoff = grab_initial_startoff;
                        sel_endoff   = grab_initial_endoff;
                        sel_channel_mask = grab_initial_sel_channel_mask;
                        b_grab_lmb_selection = false;
                        grab_mode = GRAB_NONE;
                        UI.RevertCursor();
                        handleSelectionChanged();
                        redraw();
                        return true;

                     case GRAB_SELEND:
                        sel_startoff = grab_initial_startoff;
                        sel_endoff   = grab_initial_endoff;
                        sel_channel_mask = grab_initial_sel_channel_mask;
                        b_grab_lmb_selection = false;
                        grab_mode = GRAB_NONE;
                        UI.RevertCursor();
                        handleSelectionChanged();
                        redraw();
                        return true;
                  }
               }
               else if(!b_grab_lmb_scrollbar)
               {
                  if(UI.GetKeyMod() == VMOD_LCTRL)
                  {
                     showContextMenu();
                     return true;
                  }
                  else
                  {
                     if((_ev.mouse_rel_y < SELINFO_SY) || (_ev.mouse_rel_y >= (size_y - SELINFO_SY)))
                     {
                        // See onMouseClick() (showFloatParamForMouseX())
                        return false;
                     }
                  }
               }
               return false;
            }
            else
            {
               // Release RMB
               return false;
            }
         } // if RBUTTON changed
      }

      float knobWidth = zoom * (size_x-4*1);
      if(knobWidth < 4) knobWidth=4;
      float mousex, mouserel;

      if((VMOD_LCTRL == UI.GetKeyMod()) && (GRAB_NONE == grab_mode))
         return false;  // handled in onMouseClick()

      // Toggle LMB mousepositioning grab
      if(_ev.changed_state & MOUSE_LBUTTON)
      {
         if(_ev.current_state & MOUSE_LBUTTON)
         {
            if(!b_grab_rmb)
            {
               if(_ev.mouse_rel_y > calcSampleSizeY())
               {
                  // Start scrollbar scrolling
                  last_rel_x = _ev.mouse_rel_x;
                  mousex = _ev.mouse_rel_x - 2;
                  float knobx = ((size_x-4*1-knobWidth)*0.5) + ((size_x-4*1-knobWidth)*0.5) * offset;

                  grab_lmb_relknoboff = mathClampf((mousex-knobx) / knobWidth, 0, 1);

                  b_grab_lmb_scrollbar = true;
                  UI.ShowCursor(UIConstants.CURSOR_GRAB);
                  return true;
               }
               else
               {
                  if(b_freedraw)
                  {
                     // Start drawing
                     undoBegin("freedraw");
                     b_drawing = true;
                     freedraw_last_offset = -1;
                     freedraw_last_value  = 0.0f;
                     ///trace "xxx start drawing";
                     handleFreeDraw(_ev);
                     return true;
                  }
                  else if(_ev.mouse_rel_y <= ((MARKER_PY*UI.icon_scaling)+(MARKER_SY*UI.icon_scaling)+1))
                  {
                     // marker area (handled in onMouseBeginDrag() / onMouseClick())
                     return false;
                  }
                  else
                  {
                     // Start grab marker
                     b_grab_lmb_selection = true;

                     grab_mode = determineGrabMode(_ev);

                     if(GRAB_NEWSELECTION == grab_mode)
                     {
                        // trace "xxx GRAB_NEWSELECTION";
                        smpOff = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
                        smpOff = snapFrameOffset(smpOff, _ev.mouse_rel_x, true/*bAllowMarker*/);
                        sel_startoff = smpOff;
                        sel_endoff = smpOff;
                        grab_mode = GRAB_SELEND;
                        endCycleMode();
                        sel_channel_mask = getChannelMaskByMouseY(_ev.mouse_rel_y);

                        handleSelectionChanged();
                        last_rel_x = _ev.mouse_rel_x;
                        redraw();
                        return false; // false so that onMouseDoubleClick() will still be called
                     }

                  }
                  last_rel_x = _ev.mouse_rel_x;
               }
               redraw();
            }
         }
         else
         {
            // LMB released
            if(b_freedraw)
            {
               // end freedraw
               b_drawing = false;
               undoEnd();
               redraw();
               // // handleWaveformChanged();  // calls handleSelectZone(bStopAudio=1) => DON'T
            }
            if(b_grab_lmb_scrollbar)
            {
               b_grab_lmb_scrollbar = false;
               UI.RevertCursor();
            }
            else if(b_grab_lmb_selection)
            {
               b_grab_lmb_selection = false;
               grab_mode = GRAB_NONE;
            }
            cancelAutoscrollTimer();
         }
      }

      if(_ev.changed_state & MOUSE_RBUTTON)
      {
         if(_ev.current_state & MOUSE_RBUTTON)
         {
            if(b_freedraw && b_drawing)
            {
               // end freedraw + undo
               b_drawing = false;
               undoEnd();
               redraw();
               undo();
               return true;
            }
         }
      }


      if(b_freedraw && b_drawing)
      {
         handleFreeDraw(_ev);
      }

      // LMB positioning (for lower scrollbar)
      if(b_grab_lmb_scrollbar)
      {
         // Jump to sampleposition (center of screen = selected sample)
         mousex = _ev.mouse_rel_x - 2 - knobWidth*grab_lmb_relknoboff;
         if(mousex < 0) mousex = 0;
         float mouseRel = mousex / ((size_x-4)-knobWidth);
         float newOff = (mouseRel*2 - 1);
         setOffset(newOff);
         return true;
      }

      // Handle mouse grab
      if(b_grab_lmb_selection)
      {
         int t;
         smpOff = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
         // trace "xxx SampleView::onMouse: smpoff="+smpOff+" grab_mode="+grab_mode;

         if(GRAB_NEWSELECTION == grab_mode)
         {
            sel_endoff = snapFrameOffset(smpOff, _ev.mouse_rel_x, true/*bAllowMarker*/);
            if(sel_startoff > sel_endoff)
            {
               t = sel_endoff;
               sel_endoff = sel_startoff;
               sel_startoff = t;
               grab_mode = GRAB_SELSTART;
            }
            sel_channel_mask = getChannelMaskByMouseY(_ev.mouse_rel_y);
            handleSelectionChanged();
         }
         else if(GRAB_SELSTART == grab_mode)
         {
            sel_startoff = snapFrameOffset(smpOff, _ev.mouse_rel_x, true/*bAllowMarker*/);
            if(sel_startoff > sel_endoff)
            {
               t = sel_endoff;
               sel_endoff = sel_startoff;
               sel_startoff = t;
               grab_mode = GRAB_SELEND;
            }
            sel_channel_mask = getChannelMaskByMouseY(_ev.mouse_rel_y);
            handleSelectionChanged();
         }
         else if(GRAB_SELEND == grab_mode)
         {
            sel_endoff = snapFrameOffset(smpOff, _ev.mouse_rel_x, true/*bAllowMarker*/);
            if(sel_endoff < sel_startoff)
            {
               t = sel_endoff;
               sel_endoff = sel_startoff;
               sel_startoff = t;
               grab_mode = GRAB_SELSTART;
            }
            sel_channel_mask = getChannelMaskByMouseY(_ev.mouse_rel_y);
            handleSelectionChanged();
         }
         else if(GRAB_HLSTART == grab_mode)
         {
            hl_startoff = snapFrameOffset(smpOff, _ev.mouse_rel_x, true/*bAllowMarker*/);
            if(hl_startoff > hl_endoff)
            {
               t = hl_endoff;
               hl_endoff = hl_startoff;
               hl_startoff = t;
               grab_mode = GRAB_HLEND;
            }
            handleHighlightChanged();
         }
         else if(GRAB_HLEND == grab_mode)
         {
            hl_endoff = snapFrameOffset(smpOff, _ev.mouse_rel_x, true/*bAllowMarker*/);
            if(hl_endoff < hl_startoff)
            {
               t = hl_endoff;
               hl_endoff = hl_startoff;
               hl_startoff = t;
               grab_mode = GRAB_HLSTART;
            }
            handleHighlightChanged();
         }

         // Autoscroll if mouse is near left/right border
         if(_ev.mouse_rel_x < SELECTION_AUTOSCROLL_SX)
         {
            autoscroll_dir = -1;
            autoscroll_ev = _ev;
            scheduleAutoscrollTimer();
         }
         else if(_ev.mouse_rel_x > (size_x - SELECTION_AUTOSCROLL_SX))
         {
            autoscroll_dir = 1;
            autoscroll_ev = _ev;
            scheduleAutoscrollTimer();
         }
         else
         {
            // Track last mouse x for scrollOffset()
            last_rel_x = _ev.mouse_rel_x;
            cancelAutoscrollTimer();
         }

         redraw();
      }
      else
      {
         if(!b_freedraw)
         {
            if(((MARKER_PY*UI.icon_scaling)-1) <= _ev.mouse_rel_y <= ((MARKER_PY*UI.icon_scaling)+(MARKER_SY*UI.icon_scaling)+1))
            {
               if(-1 != findRegionIdxNearMouseX(_ev.mouse_rel_x))
                  UI.ShowCursor(UIConstants.CURSOR_MOVEX);
               else
                  UI.ShowCursor(UIConstants.CURSOR_TYPE);
            }
            else
            {
               // No grab active. Update mouse cursor to indicate grab region
               int grabMode = determineGrabMode(_ev);
               if(GRAB_NEWSELECTION != grabMode)
               {
                  UI.ShowCursor(UIConstants.CURSOR_MOVEX);
               }
               else
               {
                  UI.ShowCursor(UIConstants.CURSOR_NORMAL);
               }
            }
         }
         else
         {
            boolean bAllowFreeDraw = (getNumVisibleSamples() < (size_x - 4));
            if(bAllowFreeDraw)
            {
               UI.ShowCursor(UIConstants.CURSOR_PENCIL);
            }
            else
            {
               UI.ShowCursor(UIConstants.CURSOR_NOPENCIL);
            }
         }
      }

      if(_ev.middleButtonDown())
      {
         // (note) see onMouseClick() / onMouseHold()
         // // toggleCycleMode(_ev);  // lazy-select region under mouse if there's no selection
         // // if(0 != (UI.GetKeyMod() & (VMOD_LSHIFT | VMOD_LCTRL | VMOD_RSHIFT | VMOD_RCTRL)))
         // //    toggleZeroCrossingMode();
         // // else
         // //    cycleBPMMarkerSnapModes();
         // // return true;
         return false;
      }

      return false;
   }

   public method copyHighlightToSelection(boolean _bZoom) : boolean {
      boolean bChanged = false;
      if(hl_endoff > hl_startoff)
      {
         boolean bWasSelected = (sel_startoff == hl_startoff) && (sel_endoff == hl_endoff);
         sel_startoff = hl_startoff;
         sel_endoff   = hl_endoff;

         int oldNumVis = getNumVisibleSamples();
         float oldOffset = offset;

         if(_bZoom)
         {
            if(bWasSelected)
               uiZoomOut(null);
            else
               fitSelectionToWindow();
         }

         bChanged = !bWasSelected || (getNumVisibleSamples() != oldNumVis) || (offset != oldOffset);

         redraw();
      }
      return bChanged;
   }

   public method copySelectionToHighlight(boolean _bProvide) {
      if(sel_endoff > sel_startoff)
      {
         hl_startoff = sel_startoff;
         hl_endoff   = sel_endoff;
         if(_bProvide)
         {
            handleHighlightChanged();
         }
         redraw();
      }
   }

   public method setZoom(float _z) {
      float minZoom = calcMinZoom();
      if(_z < minZoom)
         _z = minZoom;
      else if(_z >= 1.0)
         _z = 1;

      zoom = _z;

      if(null != waveform)
      {
         waveform.uiSetZoom(zoom);
      }

      setOffset(offset);

      if(null != plugin)
      {
         plugin.svHandleViewChanged();
      }

      //trace "[dbg] SampleView::setZoom: zoom is now "+zoom;
      redraw();
   }

   public method getZoom() : Double {
      return zoom;
   }

   public method setOffset(float _off) {
      if(zoom >= 0.999999)
      {
         offset = 0;
      }
      else
      {
         if(_off < -1)
            _off = -1;
         else if(_off > 1)
            _off = 1;

         offset = _off;
      }

      if(null != waveform)
      {
         waveform.uiSetOffset(offset);
      }

      if(null != plugin)
      {
         plugin.svHandleViewChanged();
      }

      // // trace "[dbg] SampleView::setOffset: offset="+offset+" zoom="+zoom;
      redraw();
   }

   public method getOffset() : float {
      return offset;
   }

   protected method uiZoomIn(MouseEvent _ev) {

      if(null == samples)
         return;

      int oldSmpOffAtMouseX;
      if(null != _ev)
      {
         oldSmpOffAtMouseX = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
      }
      else
      {
         oldSmpOffAtMouseX = -1;
      }

      if(sel_endoff > sel_startoff) // have selection ?
      {
         int numFrames = (samples.numElements / num_channels);
         if(numFrames < 1)
            return;

         int visStartOff = calcSampleOffsetAtMouseX(2);
         int visEndOff = calcSampleOffsetAtMouseX(size_x-2);
         int numVis = (numFrames * zoom) +0.5;
         ////trace "\n\nxxx uiZoomIn: orig numVis="+numVis+" (endoff-startoff)="+(visEndOff-visStartOff);
         int selLen = sel_endoff - sel_startoff;

         ////trace "xxx uiZoomIn: selStart="+sel_startoff+" selEnd="+sel_endoff+" visStart="+visStartOff+" visEnd="+visEndOff;

         boolean bWasFullyVisible = (numVis >= selLen);

         float oldRelOff = float(sel_startoff - visStartOff) / numVis;
         float oldRelEndOff = float(visEndOff - sel_endoff) / numVis;

         int origVisStartOff = visStartOff;
         int origVisEndOff = visEndOff;
         int origNumVis = (numFrames * zoom) +0.5;

         setZoom(zoom *0.75);

         // Calc new view range
         visStartOff = calcSampleOffsetAtMouseX(2);
         visEndOff = calcSampleOffsetAtMouseX(size_x-2);
         numVis = (visEndOff-visStartOff);
         //// (todo) this should not differ from (endoff-startoff)
         //// numVis = (numFrames * zoom) +0.5;

         ////trace "xxx try zoom: selStart="+sel_startoff+" selEnd="+sel_endoff+" visStart="+visStartOff+" visEnd="+visEndOff;

         ////trace "xxx origNumVis="+origNumVis+" selLen="+selLen+" numVis="+numVis;

         if(bWasFullyVisible)
         {
            if(numVis <= selLen)
            {
               // Selection is not fully visible any more
               if( (origNumVis != selLen) ) // not already zoomed to selection ?
               {
                  fitSelectionToWindow();
                  return;
               }
            }
         }

         // Maintain relative pixel offset
         ////if(bWasVisible)
         {
            if( (sel_startoff > visStartOff) && (sel_endoff < visEndOff) )
            {
               // Still fully visible, try to maintain pixel offset
               float oldOff = offset;

               ////trace "xxx oldRelOff="+oldRelOff+" oldRelEndOff="+oldRelEndOff;

               boolean bAlignRight = abs(oldRelEndOff) < abs(oldRelOff);
               // // trace "xxx oldRelOff="+oldRelOff+" oldRelEndOff="+oldRelEndOff;

               if((oldRelOff > 0.5) || bAlignRight)
               {
                  offset = float(sel_endoff + (oldRelEndOff*numVis) - numVis) / (numFrames-numVis+1);
                  offset = (offset * 2) - 1;
               }
               else
               {
                  offset = float(sel_startoff - oldRelOff*numVis) / (numFrames-numVis+1);
                  offset = (offset * 2) - 1;
               }

               visStartOff = calcSampleOffsetAtMouseX(2);
               visEndOff = calcSampleOffsetAtMouseX(size_x-2);

               if( (sel_startoff < visStartOff) || (sel_endoff > visEndOff) )
               {
                  // Part of selection is now invisible, revert and let clip-code below do its magic
                  offset = oldOff;
               }

               visStartOff = calcSampleOffsetAtMouseX(2);
               visEndOff = calcSampleOffsetAtMouseX(size_x-2);
               numVis = (visEndOff - visStartOff);
               ////numVis = (numFrames * zoom) +0.5;
            }

            // Clip view offset if selected area can still be fully visible
            if(numVis >= selLen)
            {
               if(sel_startoff < visStartOff)
               {
                  // Selection can still fit, clip view offset to selection start
                  offset = float(sel_startoff) / (numFrames-numVis+1);
                  offset = (offset * 2) - 1;
               }
               else if(sel_endoff > visEndOff)
               {
                  // Selection can still fit, clip view end offset to selection end
                  offset = float(visStartOff + (sel_endoff - visEndOff)) / (numFrames-numVis+1);
                  offset = (offset * 2) - 1;
               }
            }
            else
            {
               if(-1 != oldSmpOffAtMouseX)
               {
                  // Maintain sample offset at mousex
                  tryMaintainSampleOffsetAtMouseX(oldSmpOffAtMouseX, _ev.mouse_rel_x);
               }
            }
         }

         if(null != plugin)
         {
            plugin.svHandleViewChanged();
         }
      }
      else
      {
         // No selection, just zoom
         setZoom(zoom *0.75);

         if(-1 != oldSmpOffAtMouseX)
         {
            // Maintain sample offset at mousex
            tryMaintainSampleOffsetAtMouseX(oldSmpOffAtMouseX, _ev.mouse_rel_x);
         }
      }
   }

   protected method uiZoomOut(MouseEvent _ev) {

      if(null == samples)
         return;

      int oldSmpOffAtMouseX;
      if(null != _ev)
      {
         oldSmpOffAtMouseX = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
      }
      else
      {
         oldSmpOffAtMouseX = -1;
      }

      setZoom(zoom * 1.25);

      if(-1 != oldSmpOffAtMouseX)
      {
         // Maintain sample offset at mousex
         tryMaintainSampleOffsetAtMouseX(oldSmpOffAtMouseX, _ev.mouse_rel_x);
      }

      if(null != plugin)
      {
         plugin.svHandleViewChanged();
      }
   }

   public method uiZoomInY() {
      int numZoomLevels = zoom_y_tbl.numElements;
      if( (zoom_y_idx + 1) < numZoomLevels )
      {
         zoom_y_idx++;
         zoom_y = zoom_y_tbl[zoom_y_idx];
         redraw();

         if(null != plugin)
         {
            plugin.svHandleViewChanged();
         }
      }
   }

   public method uiZoomOutY() {
      if( (zoom_y_idx - 1) >= 0 )
      {
         zoom_y_idx--;
         zoom_y = zoom_y_tbl[zoom_y_idx];
         redraw();

         if(null != plugin)
         {
            plugin.svHandleViewChanged();
         }
      }
   }

   public method setZoomYIdx(int _zoomYIdx) {
      zoom_y_idx = _zoomYIdx;
      zoom_y = zoom_y_tbl[zoom_y_idx];
      redraw();
   }

   public method getZoomYIdx() : int {
      return zoom_y_idx;
   }

   public method restoreView(float _offset, Double _zoom, int _zoomYIdx) {
      setOffset(_offset);
      setZoom(_zoom);
      setOffset(_offset);
      setZoom(_zoom);
      setZoomYIdx(_zoomYIdx);
   }

   public method uiNextRenderStyle() {
      render_style = (render_style+1) % RS_NUM;
      trace "[...] SampleView: render style set to "+render_style_names[render_style];
      redraw();
   }

   public method uiNextInterpolStyle() {
      interpol_style = (interpol_style+1) % IS_NUM;
      trace "[...] SampleView: interpol style set to "+interpol_style_names[interpol_style];
      redraw();
   }

   // // public method setInterpolStyle(int _style) {
   // //    interpol_style = _style;
   // // }

   protected =replay= method deleteSelectionNoUndo(boolean _bReselectRegion) {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly && b_may_realloc)
            {
               int oldSelRegionIdx = _bReselectRegion ? getSelectedRegionIdx() : -1;

               undoActionRemove(sel_startoff, (sel_endoff - sel_startoff), sel_channel_mask);

               local FloatArray newSamples;
               int frameStartOff = sel_startoff;
               int frameEndOff   = sel_endoff;
               int oldNumFrames = (samples.numElements / num_channels);
               int numFrames = (frameEndOff - frameStartOff);
               int newNumFrames;

               // trace "xxx deleteSelectionNoUndo: plugin="+#(plugin);
               if(null != plugin)
               {
                  // trace "xxx deleteSelectionNoUndo: call svBeginReallocSamples";
                  plugin.svBeginReallocSamples();
                  // trace "xxx deleteSelectionNoUndo: end call svBeginReallocSamples";
               }
               else
               {
                  // Stop all voices
                  // // Global.Panic();
               }

               if( (2 == num_channels) && (sel_channel_mask != CHANNEL_MASK_LR) )
               {
                  newNumFrames = oldNumFrames;
               }
               else
               {
                  newNumFrames = oldNumFrames - numFrames;
               }

               newSamples.alloc(newNumFrames * num_channels);
               newSamples.useAll();
               newSamples.fill(0);

               if(frameStartOff > 0)
               {
                  // Copy until start of selection
                  newSamples.copyFrom(samples, 0, (frameStartOff * num_channels), 0);
               }

               if(2 == num_channels)
               {
                  switch(sel_channel_mask)
                  {
                     default:
                     case CHANNEL_MASK_LR:
                     // Copy until end of sample
                     newSamples.copyFrom(samples,
                                         frameEndOff*num_channels,
                                         (oldNumFrames - frameEndOff)*num_channels,
                                         frameStartOff*num_channels
                                         );
                     break;

                     case CHANNEL_MASK_L:
                     tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                       (oldNumFrames - frameEndOff),  1/*numCh*/,
                                                       samples,    2/*srcNumCh*/, 0/*srcChOff*/, (frameStartOff + numFrames)/*srcFrameOff*/
                                                       );

                     tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frameStartOff,
                                                       (oldNumFrames - frameStartOff),  1/*numCh*/,
                                                       samples,    2/*srcNumCh*/, 1/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                       );
                     break;

                     case CHANNEL_MASK_R:
                     tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                       (oldNumFrames - frameStartOff),  1/*numCh*/,
                                                       samples,    2/*srcNumCh*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                       );

                     tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frameStartOff,
                                                       (oldNumFrames - frameEndOff),  1/*numCh*/,
                                                       samples,    2/*srcNumCh*/, 1/*srcChOff*/, (frameStartOff + numFrames)/*srcFrameOff*/
                                                       );
                     break;
                  }
               }
               else
               {
                  // Copy until end of sample
                  newSamples.copyFrom(samples,
                                      frameEndOff*num_channels,
                                      (oldNumFrames - frameEndOff)*num_channels,
                                      frameStartOff*num_channels
                                      );
               }

               samples.unlinkFrom(newSamples);

               if(null != plugin)
               {
                  plugin.svHandleDeleteRegion(frameStartOff, numFrames);
                  plugin.svEndReallocSamples();
               }

               selectNone();
               redraw();

               handleWaveformChanged();
               handleSelectionChanged();

               if(-1 != oldSelRegionIdx)
               {
                  selectRegionByIdx(oldSelRegionIdx);
               }
            }
            else
            {
               Global.Error("SampleView::deleteSelection: read-only sample data");
            }
         }
      }
   }

   public =replay= method deleteSelection(boolean _bUndoBegin) {

      if(_bUndoBegin)
         undoBegin("deleteSelection");

      deleteSelectionNoUndo(true/*bReselectRegion*/);

      if(_bUndoBegin)
         undoEnd();
   }

   public method copySelection() {
      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
            selectAll(true/*bAction*/);

         if(sel_endoff > sel_startoff)
         {
            int frameStartOff = sel_startoff;
            int frameEndOff   = sel_endoff;
            int numFrames = frameEndOff - frameStartOff;

            if(null != waveform)
            {
               frameStartOff += waveform.ringOffset;
            }

            int srcChOff;
            int dstNumChannels;

            switch(sel_channel_mask)
            {
               default:
               case CHANNEL_MASK_LR:
                  srcChOff   = 0;
                  dstNumChannels = num_channels;
                  break;

               case CHANNEL_MASK_L:
                  srcChOff   = 0;
                  dstNumChannels = 1;
                  break;

               case CHANNEL_MASK_R:
                  srcChOff   = 1;
                  dstNumChannels = 1;
                  break;
            }

            clipboard_samples.alloc(numFrames * dstNumChannels);
            clipboard_samples.useAll();
            // // clipboard_samples.copyFrom(samples, smpStartOff, smpLen, 0);

            tksampleedit_ringbuf_copy_samples(clipboard_samples, dstNumChannels, 0/*choff*/, 0/*dstoff*/,
                                              numFrames, dstNumChannels,
                                              samples, num_channels, srcChOff, frameStartOff
                                              );

            clipboard_num_channels = dstNumChannels;

            clipboard_modification_time = milliSeconds();

            Global.Print("Copy "+
                         Utils.GetNumString(numFrames, "sample frame")+
                         " ("+Utils.GetNumString(dstNumChannels, "channel")+
                         ") to clipboard"
                         );
         }
      }
   }

   public static SetClipboardFromArray(FloatArray _fa, int _numCh) {
      clipboard_samples.visit(_fa, 0, _fa.numElements);
      clipboard_num_channels = _numCh;
   }

   public static AllocClipboard(int _numFrames, int _numCh) : FloatArray {
      clipboard_samples.free();
      clipboard_samples.alloc(_numFrames * _numCh);
      clipboard_samples.useAll();
      clipboard_num_channels = _numCh;
      return clipboard_samples;
   }

   public static FreeClipboard() {
      clipboard_samples.free();
      clipboard_num_channels = 0;
   }

   public static GetClipboardNumFrames() : int {
      return clipboard_samples.numElements / clipboard_num_channels;
   }

   public static LazyClipboardToStereo() {
      local FloatArray smp <= clipboard_samples;
      if(null != smp)
      {
         if(2 != clipboard_num_channels)
         {
            local FloatArray tmp;
            tmp.alloc(clipboard_samples.numElements * 2);
            tmp.useAll();
            tksampleedit_copy_mono_adv_to_mono_adv(tmp, 0, 2,
                                                   smp, 0, 1,
                                                   smp.numElements
                                                   );
            tksampleedit_copy_mono_adv_to_mono_adv(tmp, 1, 2,
                                                   smp, 0, 1,
                                                   smp.numElements
                                                   );
            smp.unlinkFrom(tmp);
            clipboard_num_channels = 2;
            clipboard_modification_time = milliSeconds();
         }
      }
   }

   public static AppendSamplesToClipboard(FloatArray smpSrc, int _srcNumCh, int _srcChMask) {
      // trace "xxx appendSamplesToClipboard: smpSrc.numElements="+smpSrc.numElements;
      if(smpSrc.numElements > 0)
      {
         if(0 == clipboard_num_channels)
            clipboard_num_channels = _srcNumCh;

         local FloatArray smpDst <= clipboard_samples;
         int numSrcFrames = smpSrc.numElements / _srcNumCh;

         switch(_srcChMask)
         {
            default:
            case CHANNEL_MASK_L:
               switch(clipboard_num_channels)
               {
                  default:
                  case 1:
                     // Left to mono
                     smpDst.realloc(smpDst.numElements + numSrcFrames);
                     tksampleedit_copy_mono_adv_to_mono_adv(smpDst, smpDst.numElements, 1,
                                                            smpSrc, 0, _srcNumCh,
                                                            numSrcFrames
                                                            );
                     smpDst.useAll();
                     break;

                  case 2:
                     // Left to stereo
                     smpDst.realloc(smpDst.numElements + numSrcFrames*2);
                     tksampleedit_copy_mono_adv_to_mono_adv(smpDst, smpDst.numElements+0, 2,
                                                            smpSrc, 0, _srcNumCh,
                                                            numSrcFrames
                                                            );
                     tksampleedit_copy_mono_adv_to_mono_adv(smpDst, smpDst.numElements+1, 2,
                                                            smpSrc, 0, _srcNumCh,
                                                            numSrcFrames
                                                            );
                     smpDst.useAll();
                     break;
               }
               break;

            case CHANNEL_MASK_R:
               switch(clipboard_num_channels)
               {
                  default:
                  case 1:
                     // Right to mono
                     smpDst.realloc(smpDst.numElements + numSrcFrames);
                     tksampleedit_copy_mono_adv_to_mono_adv(smpDst, smpDst.numElements, 1,
                                                            smpSrc, 1, _srcNumCh,
                                                            numSrcFrames
                                                            );
                     smpDst.useAll();
                     break;

                  case 2:
                     // Right to stereo
                     smpDst.realloc(smpDst.numElements + numSrcFrames*2);
                     tksampleedit_copy_mono_adv_to_mono_adv(smpDst, smpDst.numElements+0, 2,
                                                            smpSrc, 1, _srcNumCh,
                                                            numSrcFrames
                                                            );
                     tksampleedit_copy_mono_adv_to_mono_adv(smpDst, smpDst.numElements+1, 2,
                                                            smpSrc, 1, _srcNumCh,
                                                            numSrcFrames
                                                            );
                     smpDst.useAll();
                     break;
               }
               break;

            case CHANNEL_MASK_LR:
               LazyClipboardToStereo();
               smpDst.realloc(smpDst.numElements + numSrcFrames*2);
               tksampleedit_copy_stereo_to_stereo(smpDst, smpDst.numElements,
                                                  smpSrc, 0,
                                                  numSrcFrames
                                                  );
               smpDst.useAll();
               break;
         }

         clipboard_modification_time = milliSeconds();

         Global.Print("Append "+numSrcFrames+" frames to clipboard ("+clipboard_num_channels+" ch, "+(clipboard_samples.numElements / clipboard_num_channels)+" frames)");
      }
   }

   public static AppendSamplesToClipboardBorderSilence(FloatArray smpSrc, int _srcNumCh, int _srcChMask) {
      boolean bHaveCB = HaveClipboard();
      if(bHaveCB)
      {
         // Append silence
         if(0 == clipboard_num_channels)
            clipboard_num_channels = _srcNumCh;

         local FloatArray tmp;
         tmp.alloc(NUM_BORDER_SILENCE_FRAMES * clipboard_num_channels);
         tmp.useAll();
         tmp.fill(0);

         clipboard_samples.addArray(tmp, 0, tmp.numElements);
      }

      AppendSamplesToClipboard(smpSrc, _srcNumCh, _srcChMask);
   }

   public method appendSelectionToClipboard() {
      if(haveSelection())
      {
         local FloatArray smpSrc <= getSelectedSamples();
         AppendSamplesToClipboard(deref smpSrc, num_channels, (2 == num_channels) ? sel_channel_mask : CHANNEL_MASK_L);
      }
   }

   public method appendSelectionToClipboardBorderSilence() {
      if(haveSelection())
      {
         // trace "xxx appendSelectionToClipboardBorderSilence: clipboard_num_channels="+clipboard_num_channels;

         if(0 == clipboard_num_channels)
            clipboard_num_channels = num_channels;

         local FloatArray tmp;
         tmp.alloc(NUM_BORDER_SILENCE_FRAMES * clipboard_num_channels);
         tmp.useAll();
         tmp.fill(0);

         clipboard_samples.addArray(tmp, 0, tmp.numElements);

         appendSelectionToClipboard();
      }
   }

   public method cutSelection() {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            copySelection();

            if(!b_readonly && b_may_realloc)
            {
               undoBegin("cutSelection");

               deleteSelectionNoUndo(false/*bReselectRegion*/);

               if(b_autorecalc_autochop)
                  recalcAutoChopRegions();

               undoEnd();
            }
            else
            {
               Global.Error("SampleView::cutSelection: read-only sample data");
            }
         }
      }
   }

   public =replay= method pasteSelectionEx(boolean _bUndoBegin, int _undoRestoreSelStart, int _undoRestoreSelEnd) {
      if(null != samples)
      {
         // trace "xxx pasteSelectionEx: bUndoBegin="+_bUndoBegin+" b_readonly="+b_readonly+" b_may_realloc="+b_may_realloc;
         if(!b_readonly && b_may_realloc)
         {
            if(clipboard_samples.numElements)
            {
               int frameStartOff = sel_startoff;
               Global.Debug("SampleView::pasteSelection: samples.numElements="+samples.numElements+" clipboard.numElements="+clipboard_samples.numElements);
               if(0 <= (frameStartOff*num_channels) <= samples.numElements)
               {
                  if(_bUndoBegin)
                  {
                     int origSelStartOff = sel_startoff;
                     int origSelEndOff = sel_endoff;
                     sel_startoff = _undoRestoreSelStart;
                     sel_endoff   = _undoRestoreSelEnd;
                     undoBegin("pasteSelection");
                     sel_startoff = origSelStartOff;
                     sel_endoff   = origSelEndOff;
                  }

                  if(b_autoadd_stereo_channel && (1 == num_channels) && (2 == clipboard_num_channels))
                  {
                     convertToStereo(true/*bForceAndDontStartUndo*/);
                  }

                  // // boolean bWasRegionSelected = _bUndoBegin && isRegionSelected();
                  boolean bHadRegions = _bUndoBegin && (autochop_start_offsets.numElements > 0);
                  // trace "xxx pasteSelection: bHadRegions="+bHadRegions;

                  int numFrames = clipboard_samples.numElements / clipboard_num_channels;
                  int oldNumFrames = samples.numElements / num_channels;

                  undoActionAdd(sel_startoff, numFrames, sel_channel_mask);

                  FloatArray newSamples;
                  newSamples.alloc( (oldNumFrames + numFrames) * num_channels );
                  newSamples.useAll();
                  newSamples.fill(0);

                  // Copy old samples until start of cursor
                  newSamples.copyFrom(samples, 0, frameStartOff*num_channels, 0);

                  // trace "xxx pasteSelection: numCh="+num_channels+" clipboardNumCh="+clipboard_num_channels;

                  // Insert clipboard

                  if(2 == num_channels)
                  {
                     // Stereo destination
                     if(2 == clipboard_num_channels)
                     {
                        // Stereo source
                        switch(sel_channel_mask)
                        {
                           default:
                           case CHANNEL_MASK_LR:
                              // Insert clipboard samples (copy stereo to stereo)
                              tksampleedit_ringbuf_copy_samples(newSamples,        2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                                numFrames, 2/*numCh*/,
                                                                clipboard_samples, 2/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, (frameStartOff + numFrames),
                                                                (oldNumFrames - frameStartOff), 2/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );
                              break;

                           case CHANNEL_MASK_L:
                              // Insert clipboard samples (copy left channel)
                              tksampleedit_ringbuf_copy_samples(newSamples,        2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                                numFrames, 1/*numCh*/,
                                                                clipboard_samples, 2/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (left channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, (frameStartOff + numFrames),
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (right channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*numChannels*/, 1/*dstChOff*/, frameStartOff,
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*numChannels*/, 1/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );
                              break;

                           case CHANNEL_MASK_R:
                              // Insert clipboard samples (copy right channel)
                              tksampleedit_ringbuf_copy_samples(newSamples,        2/*dstNumCh*/, 1/*dstChOff*/, frameStartOff,
                                                                numFrames, 1/*numCh*/,
                                                                clipboard_samples, 2/*srcNumCh*/, 1/*srcChOff*/, 0/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (left channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (right channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, (frameStartOff + numFrames),
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 1/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );
                              break;
                        }

                     }
                     else
                     {
                        // Mono source
                        switch(sel_channel_mask)
                        {
                           default:
                           case CHANNEL_MASK_LR:
                              // Insert clipboard samples (copy mono to left channel)
                              tksampleedit_ringbuf_copy_samples(newSamples,        2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                                numFrames, 1/*numCh*/,
                                                                clipboard_samples, 1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                                );

                              // Insert clipboard samples (copy mono to right channel)
                              tksampleedit_ringbuf_copy_samples(newSamples,        2/*dstNumCh*/, 1/*dstChOff*/, frameStartOff,
                                                                numFrames, 1/*numCh*/,
                                                                clipboard_samples, 1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (both channels)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, (frameStartOff + numFrames),
                                                                (oldNumFrames - frameStartOff), 2/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );
                              break;

                           case CHANNEL_MASK_L:
                              // Insert clipboard samples (copy mono to left channel)
                              tksampleedit_ringbuf_copy_samples(newSamples,        2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                                numFrames, 1/*numCh*/,
                                                                clipboard_samples, 1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (left channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, (frameStartOff + numFrames),
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (right channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, frameStartOff,
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 1/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );
                              break;

                           case CHANNEL_MASK_R:
                              // Insert clipboard samples (copy mono to right channel)
                              tksampleedit_ringbuf_copy_samples(newSamples,        2/*dstNumCh*/, 1/*dstChOff*/, frameStartOff,
                                                                numFrames, 1/*numCh*/,
                                                                clipboard_samples, 1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (left channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );

                              // Copy remaining old samples after start of selection (right channel)
                              tksampleedit_ringbuf_copy_samples(newSamples, 2/*dstNumCh*/, 1/*dstChOff*/, (frameStartOff + numFrames),
                                                                (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                                samples,    2/*srcNumCh*/, 1/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                                );
                              break;
                        }

                     }

                  }
                  else
                  {
                     // Mono dest.
                     if(2 == clipboard_num_channels)
                     {
                        Global.Warning("pasting stereo clipboard to mono waveform (discarding right channel)");

                        // Insert clipboard samples (copy left to mono)
                        tksampleedit_ringbuf_copy_samples(newSamples,        1/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                          numFrames, 1/*numCh*/,
                                                          clipboard_samples, 2/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                          );

                        // Copy remaining old samples after start of selection (mono)
                        tksampleedit_ringbuf_copy_samples(newSamples, 1/*numChannels*/, 0/*dstChOff*/, (frameStartOff + numFrames),
                                                          (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                          samples,    1/*numChannels*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                          );
                     }
                     else
                     {
                        // Insert clipboard samples (copy mono to mono)
                        tksampleedit_ringbuf_copy_samples(newSamples,        1/*dstNumCh*/, 0/*dstChOff*/, frameStartOff,
                                                          numFrames, 1/*numCh*/,
                                                          clipboard_samples, 1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                          );

                        // Copy remaining old samples after start of selection (mono)
                        tksampleedit_ringbuf_copy_samples(newSamples, 1/*numChannels*/, 0/*dstChOff*/, (frameStartOff + numFrames),
                                                          (oldNumFrames - frameStartOff), 1/*numCh*/,
                                                          samples,    1/*numChannels*/, 0/*srcChOff*/, frameStartOff/*srcFrameOff*/
                                                          );
                     }
                  }

                  if(null != plugin)
                  {
                     plugin.svBeginReallocSamples();
                  }
                  else
                  {
                     // Stop all voices
                     // // Global.Panic();
                  }

                  samples.unlinkFrom(newSamples);
                  // // newSamples.free();

                  if(null != plugin)
                  {
                     // trace "xxx call plugin.svHandleInsertRegion(frameStartOff="+frameStartOff+", numFrames="+numFrames+")";
                     plugin.svHandleInsertRegion(frameStartOff, numFrames);
                     plugin.svEndReallocSamples();
                  }

                  redraw();

                  if(_bUndoBegin)
                  {
                     undoEnd();
                     handleWaveformChanged();
                  }

                  // Select pasted area
                  if(_bUndoBegin)
                  {
                     // When called via lctrl-v
                     setSelection(frameStartOff, frameStartOff + numFrames);

                     invalidateAutoChop();

                     // trace "xxx bWasRegionSelected="+bWasRegionSelected;

                     // if(bWasRegionSelected)
                     if(bHadRegions || b_autorecalc_autochop)
                        recalcAutoChopRegions();
                  }
                  else
                  {
                     // Old code (when called internally)
                     sel_startoff += numFrames;
                     sel_endoff = sel_startoff;
                  }

                  clipboard_modification_time = milliSeconds();

                  Global.Print(Utils.GetNumString(numFrames, "sample frame")+" pasted from clipboard at offset "+frameStartOff+".");
               } // if 0 <= frameStartOff ..
            }
         }
         else
         {
            Global.Error("SampleView::pasteSelection: read-only sample data");
         }
      }
   }

   public method pasteSelection(boolean _bUndoBegin) {
      pasteSelectionEx(_bUndoBegin, sel_startoff, sel_endoff - sel_startoff);
   }

   public method pasteSelectionAtEnd(boolean _bUndoBegin) {
      int undoRestoreSelStartOff = sel_startoff;
      int undoRestoreSelEndOff   = sel_endoff;
      gotoEndOfSelection();
      pasteSelectionEx(true/*bUndoBegin*/, undoRestoreSelStartOff, undoRestoreSelEndOff);
   }

   public =replay= replaceSelectionByClipboard(boolean _bUndoBegin) {
      if(null != samples)
      {
         if(!b_readonly && b_may_realloc)
         {
            if(HaveClipboard())
            {
               if(haveSelection())
               {
                  int selNumFrames = sel_endoff - sel_startoff;
                  int cbNumFrames = clipboard_samples.numElements / clipboard_num_channels;
                  int frameStartOff = sel_startoff;
                  // // int selChannelMask = (1 == clipboard_num_channels) ? CHANNEL_MASK_L : CHANNEL_MASK_LR;
                  int selChannelMask = CHANNEL_MASK_LR;
                  sel_channel_mask = selChannelMask;

                  if(_bUndoBegin)
                     undoBegin("replaceSelectionByClipboard");

                  boolean bHadRegions = _bUndoBegin && (autochop_start_offsets.numElements > 0);

                  int modOff;
                  int modLen;

                  if(cbNumFrames > selNumFrames)
                  {
                     // Clipboard region is larger than selection
                     insertSilenceAt_NoUndo(frameStartOff + selNumFrames,
                                            (cbNumFrames - selNumFrames)
                                            ); // calls undoActionAdd() / plugin.svHandle*()

                     modOff = frameStartOff;
                     modLen = cbNumFrames;
                  }
                  else if(cbNumFrames < selNumFrames)
                  {
                     // Clipboard region is smaller or same size as selection
                     sel_startoff = frameStartOff + cbNumFrames;
                     deleteSelectionNoUndo(false/*bReselectRegion*/);  // calls undoActionRemove() and plugin.svHandle*()
                     modOff = frameStartOff;
                     modLen = cbNumFrames;
                  }
                  else
                  {
                     // Clipboard region has same size as selection
                     modOff = frameStartOff;
                     modLen = cbNumFrames;
                  }

                  // Replace area
                  setSelection(frameStartOff, frameStartOff + cbNumFrames);
                  undoActionModify(modOff, modLen, selChannelMask);
                  replaceSelection(clipboard_samples, clipboard_num_channels, false/*bUndo*/, true/*bAllowChannelConversion*/);

                  // Select pasted area
                  if(_bUndoBegin)
                  {
                     undoEnd();
                     handleWaveformChanged();

                     invalidateAutoChop();

                     if(bHadRegions || b_autorecalc_autochop)
                        recalcAutoChopRegions();
                  }

                  redraw();

                  Global.Print("Replace "+Utils.GetNumString(selNumFrames, "selection frame")+" by "+Utils.GetNumString(cbNumFrames, "clipboard frame")+" at offset "+frameStartOff+".");
               }
            }
         }
         else
         {
            Global.Error("SampleView::replaceSelectionByClipboard: read-only sample data");
         }
      }
   }

   public =replay= method truncateSelection() {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly && b_may_realloc)
            {
               undoBegin("truncateSelection");

               int origStartOff = sel_startoff;
               int origEndOff = sel_endoff;

               sel_startoff = 0;
               sel_endoff   = origStartOff;
               deleteSelectionNoUndo(false/*bReselectRegion*/);

               sel_startoff = origEndOff - origStartOff;
               sel_endoff   = samples.numElements / num_channels;
               ////trace "xxx soff="+sel_startoff+" eoff="+sel_endoff+" #samples="+samples.numElements;
               deleteSelectionNoUndo(false/*bReselectRegion*/);

               selectNone();

               undoEnd();
            }
            else
            {
               Global.Error("SampleView::truncateSelection: read-only sample data");
            }
         }
      }
   }

   public method autotrim() {
      if(null != samples)
      {
         int idxS = tksampleedit_find_min_threshold_fwd(samples, 0/*chOff*/, num_channels, AUTOTRIM_MIN_THRESHOLD_BEG);
         if(num_channels > 1)
         {
            int idxSR = tksampleedit_find_min_threshold_fwd(samples, 1/*chOff*/, num_channels, AUTOTRIM_MIN_THRESHOLD_BEG);
            if(-1 == idxS)
               idxS = idxSR;
            else
               idxS = (-1 != idxSR) ? mathMini(idxS, idxSR) : idxS;
         }

         int idxE = tksampleedit_find_min_threshold_bwd(samples, 0/*chOff*/, num_channels, AUTOTRIM_MIN_THRESHOLD_END);
         if(num_channels > 1)
         {
            int idxER = tksampleedit_find_min_threshold_bwd(samples, 1/*chOff*/, num_channels, AUTOTRIM_MIN_THRESHOLD_END);
            if(-1 == idxE)
               idxE = idxER;
            else
               idxE = (-1 != idxER) ? mathMini(idxE, idxER) : idxE;
         }

         if(-1 != idxS)
         {
            if(-1 == idxE)
               idxE = samples.numElements / num_channels;
            Global.Debug("SampleView::autotrim: idxS="+idxS+" idxE="+idxE);
            setSelection(idxS, idxE);
            // // tightenSelection(true/*bLowMinThreshold*/);
            truncateSelection();
         }
         else
         {
            // Empty sample
            selectAll(false/*bAction*/);
            deleteSelection(true/*bUndoBegin*/);
         }
      }
   }

   public method reverseSelection() {
      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
            selectAll(true/*bAction*/);

         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int numFrames = sel_endoff - sel_startoff;
               int i;
               int j;

               undoBegin("reverseSelection");

               undoActionReverse(sel_startoff, numFrames, sel_channel_mask);

               int smpAdv = num_channels;

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     smpStartOff++;
                     smpEndOff++;
                  }
                  else if(CHANNEL_MASK_LR == sel_channel_mask)
                  {
                     numFrames *= 2;
                     smpAdv = 1;
                  }
               }

               i = smpStartOff;
               j = smpEndOff;
               loop(numFrames / 2)
               {
                  j = j - smpAdv;

                  float t = samples[i];
                  samples[i] = samples[j];
                  samples[j] = t;

                  i = i + smpAdv;
               }

               undoEnd();

               handleWaveformChanged();

               redraw();
            }
            else
            {
               Global.Error("SampleView::reverseSelection: read-only sample data");
            }
         }
      }
   }

   public method deleteAreas(boolean _bBeforeFirstArea, IntArray _starts, IntArray _ends, boolean _bInsertSilence) : int {
      // Returns total number of deleted sample frames
      local IntArray sortedIndices;
      _starts.sortByValue(sortedIndices);
      _starts.rearrange(sortedIndices);
      _ends.rearrange(sortedIndices);

      int totalNumFramesDeleted = 0;

      if(_starts.numElements > 0)
      {
         int off;

         undoBegin("deleteAreas");

         sel_channel_mask = 0;

         int curAreaIdx = 0;
         int areaIdx;
         int shift;

         off = _starts.get(0);
         if(_bBeforeFirstArea && (off > 0))
         {
            // Delete until first area start
            setSelection(0, off);
            deleteSelectionNoUndo(false/*bReselectRegion*/);

            // Shift areas
            shift = off;
            totalNumFramesDeleted += shift;

            for(areaIdx = 0; areaIdx < _starts.numElements; areaIdx++)
            {
               _starts[areaIdx] = _starts[areaIdx] - shift;
               _ends[areaIdx] = _ends[areaIdx] - shift;
            }

         }

         int lastEndOff = _ends[0];

         while(curAreaIdx < _starts.numElements)
         {
            // Find end of all areas that started within last area
            int maxEndOff = _ends[curAreaIdx];
            for(areaIdx = curAreaIdx; areaIdx < _starts.numElements; areaIdx++)
            {
               if(_starts[areaIdx] < lastEndOff)
               {
                  if(_ends[areaIdx] > maxEndOff)
                     maxEndOff = _ends[areaIdx];
               }
               else
                  break;
            }

            int nextAreaIdx = 999999;

            // Find first area that starts after maxEndOff
            for(areaIdx = curAreaIdx; areaIdx < _starts.numElements; areaIdx++)
            {
               if(_starts[areaIdx] >= maxEndOff)
               {
                  nextAreaIdx = areaIdx;
                  break;
               }
            }

            if(nextAreaIdx < _starts.numElements)
            {
               if(_starts[nextAreaIdx] > maxEndOff)
               {
                  // Delete between end of last area and start of next one
                  if(_bInsertSilence)
                  {
                     insertSilenceAt_NoUndo(maxEndOff, NUM_BORDER_SILENCE_FRAMES);

                     for(areaIdx = nextAreaIdx; areaIdx < _starts.numElements; areaIdx++)
                     {
                        _starts[areaIdx] = _starts[areaIdx] + NUM_BORDER_SILENCE_FRAMES;
                        _ends[areaIdx] = _ends[areaIdx] + NUM_BORDER_SILENCE_FRAMES;
                     }

                     maxEndOff += NUM_BORDER_SILENCE_FRAMES;
                     totalNumFramesDeleted -= NUM_BORDER_SILENCE_FRAMES;
                  }

                  shift = _starts[nextAreaIdx] - maxEndOff;

                  setSelection(maxEndOff, _starts[nextAreaIdx]);

                  totalNumFramesDeleted += shift;
                  deleteSelectionNoUndo(false/*bReselectRegion*/);

                  // Shift areas
                  for(areaIdx = nextAreaIdx; areaIdx < _starts.numElements; areaIdx++)
                  {
                     _starts[areaIdx] = _starts[areaIdx] - shift;
                     _ends[areaIdx] = _ends[areaIdx] - shift;
                  }

               }

               lastEndOff = _ends[nextAreaIdx];

               // Next area
               curAreaIdx = nextAreaIdx;
            }
            else
            {
               // No more areas
               if(maxEndOff < getNumFrames())
               {
                  // Delete until end of waveform
                  totalNumFramesDeleted += getNumFrames() - maxEndOff;
                  setSelection(maxEndOff, getNumFrames());
                  deleteSelectionNoUndo(false/*bReselectRegion*/);
               }
               break;
            }

         } // loop areas

         selectNone();
         undoEnd();
      } // if num areas

      return totalNumFramesDeleted;
   }

   public method crossfadeSelection() {
      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
            selectAll(true/*bAction*/);

         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int numFrames = sel_endoff - sel_startoff;
               int i;
               int j;

               undoBegin("crossfadeSelection");

               undoActionModify(sel_startoff, numFrames, sel_channel_mask);

               int smpAdv = num_channels;

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     smpStartOff++;
                     smpEndOff++;
                  }
                  else if(CHANNEL_MASK_LR == sel_channel_mask)
                  {
                     numFrames *= 2;
                     smpAdv = 1;
                  }
               }

               // (todo) move to native code
               i = smpStartOff;
               j = smpEndOff;
               loop(numFrames / 2)
               {
                  j = j - smpAdv;

                  float t = samples[i] * 0.5 + samples[j] * 0.5;
                  samples[i] = t;
                  samples[j] = t;

                  i = i + smpAdv;
               }

               undoEnd();

               handleWaveformChanged();

               redraw();

               Global.Print("Crossfade ("+(sel_endoff - sel_startoff)+" frames)");
            }
            else
            {
               Global.Error("SampleView::crossfadeSelection: read-only sample data");
            }
         }
      }
   }

   public method loopCrossfadeSelection1(boolean _bNearMouse) {
      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
         {
            sel_startoff = getSortedHighlightStart();
            sel_endoff = sel_startoff + getSortedHighlightLength();
         }

         if(sel_endoff > sel_startoff)  // haveSelection ?
         {
            if(!b_readonly)
            {
               dlg_num_frames <= TextInputDialog.New("Loop Crossfade",
                                                     "Please enter number of frames:",
                                                     "\aCrossfade",
                                                     "Cancel",
                                                     String(last_loop_crossfade_num_frames),
                                                     32, 24,
                                                     this
                                                     );
               if(_bNearMouse)
               {
                  dlg_num_frames.showNearMouse(-50*UI.font_scaling, -80*UI.font_scaling);
               }
               else
               {
                  dlg_num_frames.showCentered();
               }
            }
            else
            {
               Global.Error("loopCrossfadeSelection: read-only sample data");
            }
         }
      }
   }

   public method loopCrossfadeSelection2(int _numFrames) {
      last_loop_crossfade_num_frames = _numFrames;

      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
         {
            sel_startoff = getSortedHighlightStart();
            sel_endoff = sel_startoff + getSortedHighlightLength();
         }

         if(sel_endoff > sel_startoff)  // haveSelection ?
         {
            if(!b_readonly)
            {
               if((_numFrames > 0) && (_numFrames <= (sel_endoff - sel_startoff)))
               {
                  if(sel_startoff >= _numFrames)
                  {
                     int srcOff = sel_startoff - _numFrames;
                     int dstOff = sel_endoff - _numFrames;

                     if(dstOff >= sel_startoff)
                     {
                        int numFrames = _numFrames;

                        undoBegin("loopCrossfadeSelection");

                        undoActionModify(dstOff, numFrames, sel_channel_mask);

                        int numCh = 1;
                        int chSkip = 0;

                        if(2 == num_channels)
                        {
                           srcOff *= 2;
                           dstOff *= 2;

                           if(CHANNEL_MASK_L == sel_channel_mask)
                           {
                              chSkip = 1;
                           }
                           else if(CHANNEL_MASK_R == sel_channel_mask)
                           {
                              srcOff++;
                              dstOff++;
                              chSkip = 1;
                           }
                           else if(CHANNEL_MASK_LR == sel_channel_mask)
                           {
                              numCh = 2;
                           }
                        }

                        float cVal = 0.0;
                        float cStep = 1.0 / numFrames;

                        loop(numFrames)
                        {
                           loop(numCh)
                           {
                              float t = samples[srcOff++] * cVal + samples[dstOff] * (1 - cVal);
                              samples[dstOff++] = t;
                           }
                           srcOff += chSkip;
                           dstOff += chSkip;
                           cVal += cStep;
                        }

                        undoEnd();

                        handleWaveformChanged();

                        redraw();

                        Global.Print("Loop crossfade ("+numFrames+" frames)");
                     }
                     else
                     {
                        Global.Error("loopCrossfadeSelection: selection is shorter than "+_numFrames+" frames");
                     }
                  }
                  else
                  {
                     Global.Error("loopCrossfadeSelection: need "+_numFrames+" frames before selection start");
                  }
               }
               else
               {
                  Global.Error("loopCrossfadeSelection: invalid number of frames ("+_numFrames+")");
               }
            }
            else
            {
               Global.Error("loopCrossfadeSelection: read-only sample data");
            }
         }
      }
   }

   public method addClipboardToSelection() {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly && b_may_realloc)
            {
               if(clipboard_samples.numElements)
               {
                  undoBegin("addClipboardToSelection");

                  if(b_autoadd_stereo_channel && (1 == num_channels) && (2 == clipboard_num_channels))
                  {
                     convertToStereo(true/*bForceAndDontStartUndo*/);
                  }

                  int numFrames = mathMini(clipboard_samples.numElements / clipboard_num_channels, sel_endoff - sel_startoff);
                  undoActionModify(sel_startoff, numFrames, sel_channel_mask);

                  int smpStartOffDst = sel_startoff * num_channels;
                  int smpStartOffSrc = 0;
                  int smpAdvDst = num_channels;
                  int smpAdvSrc = clipboard_num_channels;
                  int numCh = 1;

                  if(2 == num_channels)
                  {
                     if(CHANNEL_MASK_L == sel_channel_mask)
                     {
                        numCh = 1;
                     }
                     if(CHANNEL_MASK_R == sel_channel_mask)
                     {
                        smpStartOffDst++;
                        if(clipboard_num_channels >= 2)
                           smpStartOffSrc++;
                        numCh = 1;
                     }
                     else if(CHANNEL_MASK_LR == sel_channel_mask)
                     {
                        numCh = 2;
                     }
                  }
                  else
                  {
                     numCh = 1;
                  }

                  float lvl = 1.0;

                  tksampleedit_add_amp_mono_adv_to_mono_adv(samples, smpStartOffDst, smpAdvDst, clipboard_samples, smpStartOffSrc, smpAdvSrc, lvl, numFrames);

                  if(numCh >= 2)
                  {
                     if(clipboard_num_channels >= 2)
                        tksampleedit_add_amp_mono_adv_to_mono_adv(samples, smpStartOffDst+1, smpAdvDst, clipboard_samples, smpStartOffSrc+1, smpAdvSrc, lvl, numFrames);
                     else
                        tksampleedit_add_amp_mono_adv_to_mono_adv(samples, smpStartOffDst+1, smpAdvDst, clipboard_samples, smpStartOffSrc, smpAdvSrc, lvl, numFrames);
                  }

                  Global.Debug("SampleView::addClipboardToSelection: samples.numElements="+samples.numElements+" clipboard.numElements="+clipboard_samples.numElements+" #frames="+numFrames+" lvl="+lvl);

                  undoEnd();
                  handleWaveformChanged();

                  Global.Print(Utils.GetNumString(numFrames, "sample frame")+" mixed(+) with clipboard at offset "+sel_startoff+".");
               }
            }
         }
      }
   }

   public method replaceSelection(FloatArray _smp, int _numCh, boolean _bUndo, boolean _bAllowChannelConversion) {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly && b_may_realloc)
            {
               if(_smp.numElements > 0)
               {
                  if(_bUndo)
                     undoBegin("replaceSelection");

                  if(b_autoadd_stereo_channel && (1 == num_channels) && (2 == _numCh) && _bAllowChannelConversion)
                  {
                     convertToStereo(true/*bForceAndDontStartUndo*/);
                  }

                  int smpNumFrames = _smp.numElements / _numCh;
                  int selNumFrames = sel_endoff - sel_startoff;
                  int numFrames = mathMini(smpNumFrames, selNumFrames);

                  if(_bUndo)
                     undoActionModify(sel_startoff, selNumFrames, sel_channel_mask);

                  int smpStartOffDst = sel_startoff * num_channels;
                  int smpStartOffSrc = 0;
                  int smpAdvDst = num_channels;
                  int smpAdvSrc = _numCh;
                  int numCh = 1;

                  if(2 == num_channels)
                  {
                     if(CHANNEL_MASK_L == sel_channel_mask)
                     {
                        numCh = 1;
                     }
                     if(CHANNEL_MASK_R == sel_channel_mask)
                     {
                        smpStartOffDst++;
                        if(_numCh >= 2)
                           smpStartOffSrc++;
                        numCh = 1;
                     }
                     else if(CHANNEL_MASK_LR == sel_channel_mask)
                     {
                        numCh = 2;
                     }
                  }
                  else
                  {
                     numCh = 1;
                  }

                  tksampleedit_copy_mono_adv_to_mono_adv(samples, smpStartOffDst, smpAdvDst,
                                                         _smp, smpStartOffSrc, smpAdvSrc,
                                                         numFrames
                                                         );

                  if(numCh >= 2)
                  {
                     if(clipboard_num_channels >= 2)
                        tksampleedit_copy_mono_adv_to_mono_adv(samples, smpStartOffDst+1, smpAdvDst,
                                                               _smp, smpStartOffSrc+1, smpAdvSrc,
                                                               numFrames
                                                               );
                     else
                        tksampleedit_copy_mono_adv_to_mono_adv(samples, smpStartOffDst+1, smpAdvDst,
                                                               _smp, smpStartOffSrc, smpAdvSrc,
                                                               numFrames
                                                               );
                  }

                  // Fill remaining area with zeros
                  if(selNumFrames > smpNumFrames)
                  {
                     tksampleedit_fill_mono(samples, smpStartOffDst + smpNumFrames*num_channels,
                                            0.0f,
                                            (selNumFrames - smpNumFrames) * num_channels
                                            );
                  }

                  Global.Debug("SampleView::replaceSelection: samples.numElements="+samples.numElements+" o.numElements="+_smp.numElements+" #frames="+numFrames);

                  if(_bUndo)
                     undoEnd();

                  handleWaveformChanged();

                  Global.Print(Utils.GetNumString(numFrames, "sample frame")+" replaced at offset "+sel_startoff+".");
               }
            }
         }
      }
   }

   public method silenceSelection(boolean _bUndoBegin) {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               if(_bUndoBegin)
                  undoBegin("silenceSelection");

               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int numFrames = sel_endoff - sel_startoff;
               int i = smpStartOff;

               int smpAdv = num_channels;

               undoActionModify(sel_startoff, numFrames, sel_channel_mask);

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     i++;
                  }
                  else if(CHANNEL_MASK_LR == sel_channel_mask)
                  {
                     numFrames *= 2;
                     smpAdv = 1;
                  }
               }

               compile loop(numFrames)
               {
                  samples[i] = 0.0f;
                  i = i + smpAdv;
               }

               redraw();

               handleWaveformChanged();

               if(_bUndoBegin)
                  undoEnd();
            }
            else
            {
               Global.Error("SampleView::silenceSelection: read-only sample data");
            }
         }
      }
   }

   public method surroundSelectionWithSilence(boolean _bUndoBegin) {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            Global.Debug("SampleView::surroundSelectionWithSilence: bUndoBegin="+_bUndoBegin);

            if(_bUndoBegin)
               undoBegin("surroundSelectionWithSilence");

            int origSelStart = sel_startoff;
            int origSelEnd = sel_endoff;
            FloatArray origClipboardSamples <= deref clipboard_samples;
            int origClipboardNumCh = clipboard_num_channels;

            clipboard_samples.alloc(NUM_BORDER_SILENCE_FRAMES * num_channels);
            clipboard_samples.useAll();
            clipboard_samples.fill(0);
            clipboard_num_channels = num_channels;
            // // // sel_channel_mask = (2 == num_channels) ? CHANNEL_MASK_LR : CHANNEL_MASK_L;
            sel_channel_mask = CHANNEL_MASK_LR;  // LR applies to both mono and stereo

            pasteSelection(false/*bUndoBegin*/);

            sel_startoff = origSelEnd + NUM_BORDER_SILENCE_FRAMES;
            pasteSelection(false/*bUndoBegin*/);

            // Restore clipboard
            clipboard_samples <= deref origClipboardSamples;
            clipboard_num_channels = origClipboardNumCh;

            sel_startoff = origSelStart + NUM_BORDER_SILENCE_FRAMES;
            sel_endoff = origSelEnd + NUM_BORDER_SILENCE_FRAMES;

            if(_bUndoBegin)
            {
               handleWaveformChanged();
               handleSelectionChanged();

               undoEnd();
            }
         }
      }
   }

   public method insertSilenceAt_NoUndo(int _frameOff, int _numFrames) {
      // no undo, no events

      int origSelStart = sel_startoff;
      sel_startoff = _frameOff;
      FloatArray origClipboardSamples <= deref clipboard_samples;
      int origClipboardNumCh = clipboard_num_channels;
      clipboard_num_channels = num_channels;
      // (todo) optimize
      // (todo) support sel_channel_mask (or add arg)
      local FloatArray tmp;
      tmp.alloc(_numFrames * num_channels);
      tmp.useAll();
      tmp.fill(0);
      clipboard_samples <= tmp;
      pasteSelection(false/*bUndoBegin*/);
      clipboard_samples <= deref origClipboardSamples;
      clipboard_num_channels = origClipboardNumCh;
      sel_startoff = origSelStart;
   }

   public method insertSamplesAt_NoUndo(int _frameOff, FloatArray _smp, int _numCh, float _sampleRate) {
      if(null != samples)
      {
         FloatArray origClipboardSamples <= deref clipboard_samples;
         int origClipboardNumCh = clipboard_num_channels;
         int origSelStart = sel_startoff;
         local FloatArray tmp;
         sel_startoff = _frameOff;
         sel_channel_mask = CHANNEL_MASK_LR;

         // (todo) convert sample rate before insert
         if(_sampleRate != sample_rate)
            trace "[~~~] SampleView::insertSamplesAt_NoUndo: sample rate mismatch (ignoring) (dst="+sample_rate+" src="+sample_rate+")";

         if(_numCh != num_channels)
         {
            if((1 == num_channels) && (2 == _numCh))
            {
               // Stereo to mono
               //   (todo) optimize (avoid stereo-to-mono copy
               tmp.alloc(_smp.numElements / 2);
               tmp.useAll();
               tksampleedit_copy_mono_adv_to_mono( tmp, 0,
                                                  _smp, 0, 2,
                                                  tmp.numElements
                                                  );
               clipboard_samples <= tmp;
               clipboard_num_channels = 1;
               pasteSelection(false/*bUndoBegin*/);
            }
            else if((2 == num_channels) && (1 == _numCh))
            {
               // Mono to Stereo
               //   (todo) optimize (avoid temporary array and mono-to-stereo copy)
               tmp.alloc(_smp.numElements * 2);
               tmp.useAll();
               tksampleedit_copy_mono_adv_to_mono_adv( tmp, 0, 2,
                                                      _smp, 0, 1,
                                                      _smp.numElements
                                                      );
               tksampleedit_copy_mono_adv_to_mono_adv( tmp, 1, 2,
                                                      _smp, 0, 1,
                                                      _smp.numElements
                                                      );
               clipboard_samples <= tmp;
               clipboard_num_channels = 2;
               pasteSelection(false/*bUndoBegin*/);
            }
         }
         else
         {
            clipboard_samples <= _smp;
            clipboard_num_channels = num_channels;
            pasteSelection(false/*bUndoBegin*/);
         }

         clipboard_samples <= deref origClipboardSamples;
         clipboard_num_channels = origClipboardNumCh;
         sel_startoff = origSelStart;
      }
   }

   public method phaseInvertSelection() {
      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
            selectAll(true/*bAction*/);

         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int numFrames = sel_endoff - sel_startoff;
               int i = smpStartOff;

               undoBegin("phaseInvert");

               undoActionPhaseInvert(sel_startoff, numFrames, sel_channel_mask);

               int smpAdv = num_channels;

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     i++;
                  }
                  else if(CHANNEL_MASK_LR == sel_channel_mask)
                  {
                     numFrames *= 2;
                     smpAdv = 1;
                  }
               }

               compile loop(numFrames)
               {
                  samples[i] = -samples[i];
                  i = i + smpAdv;
               }

               undoEnd();

               handleWaveformChanged();

               redraw();
            }
            else
            {
               Global.Error("SampleView::phaseInvertSelection: read-only sample data");
            }
         }
      }
   }

   public method normalizeSelection(boolean _bUndoBegin) {
      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
            selectAll(true/*bAction*/);

         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               if(_bUndoBegin)
                  undoBegin("normalizeSelection");

               int numFrames = sel_endoff - sel_startoff;

               undoActionModify(sel_startoff, numFrames, sel_channel_mask);

               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int i;

               int smpAdv = num_channels;

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     smpStartOff++;
                  }
                  else if(CHANNEL_MASK_LR == sel_channel_mask)
                  {
                     numFrames *= 2;
                     smpAdv = 1;
                  }
               }

               float max = -99999;
               i = smpStartOff;
               compile loop(numFrames)
               {
                  float f = abs(samples[i]);
                  if(f > max)
                  {
                     max = f;
                  }

                  i = i + smpAdv;
               }

               max = 1.0 / max;
               i = smpStartOff;
               compile loop(numFrames)
               {
                  f = samples[i];
                  samples[i] = f * max;

                  i = i + smpAdv;
               }

               if(_bUndoBegin)
               {
                  undoEnd();
                  handleWaveformChanged();
               }

               redraw();
            }
            else
            {
               Global.Error("SampleView::normalizeSelection: read-only sample data");
            }
         }
      }
   }

   public method fadeRegions(int _fadeInNumFrames, int _fadeOutNumFrames) {

      int origSelStartOff    = sel_startoff;
      int origSelEndOff      = sel_endoff;
      int origSelChannelMask = sel_channel_mask;

      sel_channel_mask = CHANNEL_MASK_LR;

      undoBegin("fadeRegions");

      // // selectAll(false/*bAction*/);
      // // recalcAutoChopRegions();

      int numRegions = autochop_start_offsets.numElements;
      if(numRegions > 0)
      {
         int regionIdx = 0;
         loop(numRegions)
         {
            int offS = autochop_start_offsets.get(regionIdx);
            int offE = autochop_end_offsets.get(regionIdx);

            sel_startoff = offS;
            sel_endoff = offE;

            if((_fadeInNumFrames > 0) && ((offE - offS) >= _fadeInNumFrames))
            {
               sel_endoff = offS + _fadeInNumFrames;
               fadeInSelection(false/*bUndoBegin*/);
            }

            if((_fadeOutNumFrames > 0) && ((offE - offS) >= _fadeOutNumFrames))
            {
               sel_startoff = offE - _fadeOutNumFrames;
               sel_endoff = offE;
               fadeOutSelection(false/*bUndoBegin*/);
            }

            // Next region
            regionIdx++;
         }

      }

      sel_startoff     = origSelStartOff;
      sel_endoff       = origSelEndOff;
      sel_channel_mask = origSelChannelMask;

      undoEnd();
      handleWaveformChanged();
   }

   public method normalizeRegions(int _fadeNumFrames) {

      int origSelStartOff    = sel_startoff;
      int origSelEndOff      = sel_endoff;
      int origSelChannelMask = sel_channel_mask;

      sel_channel_mask = CHANNEL_MASK_LR;

      undoBegin("normalizeRegions");

      selectAll(false/*bAction*/);
      normalizeSelection(false/*bUndoBegin*/);
      recalcAutoChopRegions();

      int numRegions = autochop_start_offsets.numElements;
      if(numRegions > 0)
      {

         int regionIdx = 0;
         loop(numRegions)
         {
            int offS = autochop_start_offsets.get(regionIdx);
            int offE = autochop_end_offsets.get(regionIdx);

            sel_startoff = offS;
            sel_endoff = offE;
            normalizeSelection(false/*bUndoBegin*/);

            if((_fadeNumFrames > 0) && ((offE - offS) >= _fadeNumFrames))
            {
               sel_startoff = offE - _fadeNumFrames;
               fadeOutSelection(false/*bUndoBegin*/);
            }

            // Next region
            regionIdx++;
         }

      }

      sel_startoff     = origSelStartOff;
      sel_endoff       = origSelEndOff;
      sel_channel_mask = origSelChannelMask;

      undoEnd();
      handleWaveformChanged();
   }

   public method amplifySelection1(boolean _bNearMouse) {
      if(null == dlg_scale)
      {
         dlg_scale <= FloatParamDialog.New("Amplify",
                                           "Enter amplificator factor",
                                           "textinput"/*iconName*/,
                                           "Amplify", // ok
                                           "Cancel",
                                           1.0,
                                           0.0, 100.0,
                                           5,     // cols
                                           3,     // precision
                                           0.1,   // step
                                           this   // recipient
                                           );
      }

      if(_bNearMouse)
         dlg_scale.showNearMouse(-50*UI.font_scaling, -100*UI.font_scaling);
      else
         dlg_scale.showCentered();
   }

   public method amplifySelection2(float _factor) {
      if(null != samples)
      {
         if(sel_endoff <= sel_startoff)
            selectAll(true/*bAction*/);

         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               undoBegin("levelSelection");

               int numFrames = sel_endoff - sel_startoff;

               undoActionModify(sel_startoff, numFrames, sel_channel_mask);

               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int i;

               int smpAdv = num_channels;

               int numCh = num_channels;

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_L == sel_channel_mask)
                  {
                     numCh = 1;
                  }
                  else if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     numCh = 1;
                     smpStartOff++;
                  }
                  else if(CHANNEL_MASK_LR == sel_channel_mask)
                  {
                     smpAdv = 1;
                  }
               }

               if(2 == numCh)
               {
                  tksampleedit_copy_pan_stereo_to_stereo(samples, smpStartOff,
                                                         samples, smpStartOff,
                                                         _factor, _factor,
                                                         numFrames
                                                         );
               }
               else
               {
                  tksampleedit_scale_mono_adv_to_mono_adv(samples, smpStartOff, 1/*outAdv*/,
                                                          samples, smpStartOff, 1/*inAdv*/,
                                                          _factor,
                                                          numFrames
                                                          );
               }

               undoEnd();

               handleWaveformChanged();

               redraw();
            }
            else
            {
               Global.Error("SampleView::levelSelection: read-only sample data");
            }
         }
      }
   }

   protected method processSelectionWithSoX_Int(String _cmdArgs, boolean _bCmdAfterOutPathName, boolean _bNoiseRed) : boolean {
      boolean bNoiseProf = _bNoiseRed && (_cmdArgs <= "noiseprof");
      local String pathNameIn  <= Utils.ToNativePathName(STConfig.temp+"/sampleview_sox_in.wav");
      local String pathNameNoiseProf <= Utils.ToNativePathName(STConfig.temp+"/sampleview_sox_noiseprof.bin");
      local String pathNameOut <= Utils.ToNativePathName(STConfig.temp+"/sampleview_sox_out.wav");

      local String pathNameBat <= Utils.ToNativePathName(STConfig.temp+"/sampleview_sox.bat");
      local FloatArray smpDat;
      smpDat.visit(samples, sel_startoff * num_channels, (sel_endoff - sel_startoff) * num_channels);
      WavIO.SaveLocal(pathNameIn, smpDat, sample_rate, num_channels,
                      (5*12)/*Audio.KEY_MIDDLE_C == C-5*/, 0/*loopStart*/, 0/*loopEnd*/,
                      null/*bwfHint*/
                      );

      local String soxPath <= Utils.ToNativePathName(STConfig.audiotool_sox_pathname);

      if(!bNoiseProf && _bNoiseRed)
         _cmdArgs.replace("$(PROF)", "\""+pathNameNoiseProf+"\"");

      local String cmdLine =
         bNoiseProf
         ? ( "\""+soxPath+"\" \""+pathNameIn+"\" -n noiseprof \""+pathNameNoiseProf+"\"" )
         : _bNoiseRed
         ? ( "\""+soxPath+"\" \""+pathNameIn+"\" \""+pathNameOut+"\" "+_cmdArgs )
         : _bCmdAfterOutPathName
         ? ( "\""+soxPath+"\" \""+pathNameIn+"\" \""+pathNameOut+"\" "+_cmdArgs )
         : ( "\""+soxPath+"\" \""+pathNameIn+"\" "+_cmdArgs+" \""+pathNameOut+"\"" )
         ;

      if(Utils.IsWindows())
      {
         cmdLine.insert(0, "@echo off");
         cmdLine.saveLocal(pathNameBat);
         cmdLine <= Utils.FixPathname_psystem_exe(pathNameBat);
      }
      local String log; log.alloc(65535);
      psystem(cmdLine, 'r', log);
      Global.Debug("exec SOX: cmdLine=>>"+cmdLine+"<< log=\n"+log+"\n");

      if(!bNoiseProf)
      {
         local FloatArray smpNew;
         local Integer retSampleRate;
         local Integer retNumCh;

         local WavIO_BWF retBWF;

         try
         {
            if(WavIO.LoadLocal(pathNameOut,
                               smpNew,
                               retSampleRate,
                               retNumCh,
                               null/*retFileInfoStr*/,
                               null/*sampleHint*/,
                               retBWF/*bwfHint*/
                               ))
            {
               if(retNumCh == num_channels)
               {
                  Global.Debug("SampleView::processSelectionWithSoX: smpOld.numElements="+smpDat.numElements+" smpNew.numElements="+smpNew.numElements);
                  FloatArray oldClipboardSamples <= deref clipboard_samples;
                  int oldClipboardNumChannels = clipboard_num_channels;
                  clipboard_samples.visit(smpNew, 0, smpNew.numElements);
                  clipboard_num_channels = retNumCh;
                  replaceSelectionByClipboard(true/*bUndoBegin*/);
                  clipboard_samples <= deref oldClipboardSamples;
                  clipboard_num_channels = oldClipboardNumChannels;
               }
               return true;
            }
         }
         catch(Error e)
         {
            trace "[---] SampleView::processSelectionWithSoX: caught WavIO load error e.message="+e.message;
         }
         return false;
      }
      else
         return true;  // noiseprof
   }

   protected method processSelectionWithSoX(String _cmdArgs, boolean _bCmdAfterOutPathName) : boolean {
      return processSelectionWithSoX_Int(_cmdArgs, _bCmdAfterOutPathName, false/*bNoiseProf*/);
   }

   public method processSelectionWithSoXPostCmd(String _cmdArgs) : boolean {
      return processSelectionWithSoX_Int(_cmdArgs, true/*bCmdAfterOutPathName*/, false/*bNoiseProf*/);
   }

   public method showSoXDialog(boolean _bNearMouse) {
      if(haveSelection())
      {
         if(!b_readonly && b_may_realloc)
         {
            if(null == dlg_sox)
            {
               dlg_sox <= new SampleViewSoXDialog;
               dlg_sox.initSampleViewSoXDialog();
            }

            dlg_sox.showSampleViewSoXDialog(this, _bNearMouse);
            Global.Print("Show SoX dialog");
         }
         else
            Global.Warning("Show SoX dialog: read-only sample");
      }
      else
         Global.Warning("Show SoX dialog: no selection");
   }

   public method soxContrastSelection2(float _amount) : boolean {
      return processSelectionWithSoX("contrast "+_amount, true/*bCmdAfterOutPathName*/);
   }

   public method soxOverdriveSelection2(float _gain, float _colour) : boolean {
      return processSelectionWithSoX("overdrive "+_gain+" "+_colour, true/*bCmdAfterOutPathName*/);
   }

   public method soxNoiseProf() : boolean {
      return processSelectionWithSoX_Int("noiseprof", false/*bCmdAfterOutPathName*/, true/*bNoiseRed*/);
   }

   public method soxNoiseRedSelection2(float _amount) : boolean {
      return processSelectionWithSoX_Int("noisered $(PROF) "+_amount, true/*bCmdAfterOutPathName*/, true/*bNoiseRed*/);
   }

   public method soxEffect(String _cmd) : boolean {
      return processSelectionWithSoX(_cmd, true/*bCmdAfterOutPathName*/);
   }

   public method processSelectionWithRubberband(String _cmdArgs) : boolean {
      local String pathNameIn  <= Utils.ToNativePathName(STConfig.temp+"/sampleview_rubberband_in.wav");
      local String pathNameOut <= Utils.ToNativePathName(STConfig.temp+"/sampleview_rubberband_out.wav");

      local String pathNameBat <= Utils.ToNativePathName(STConfig.temp+"/sampleview_rubberband.bat");
      local FloatArray smpDat;
      smpDat.visit(samples, sel_startoff * num_channels, (sel_endoff - sel_startoff) * num_channels);
      WavIO.SaveLocal(pathNameIn, smpDat, sample_rate, num_channels,
                      (5*12)/*Audio.KEY_MIDDLE_C == C-5*/, 0/*loopStart*/, 0/*loopEnd*/,
                      null/*bwfHint*/
                      );

      local String rbPath <= Utils.ToNativePathName(STConfig.audiotool_rubberband_pathname);

      local String cmdLine = "\""+rbPath+"\" "+_cmdArgs+" \""+pathNameIn+"\" \""+pathNameOut+"\"";

      if(Utils.IsWindows())
      {
         cmdLine.insert(0, "@echo off\n");
         cmdLine.saveLocal(pathNameBat);
         cmdLine <= Utils.FixPathname_psystem_exe(pathNameBat);
      }
      local String log; log.alloc(65535);
      psystem(cmdLine, 'r', log);
      Global.Debug("exec Rubberband: cmdLine=>>"+cmdLine+"<< log=\n"+log+"\n");

      local FloatArray smpNew;
      local Integer retSampleRate;
      local Integer retNumCh;

      local WavIO_BWF retBWF;

      try
      {
         if(WavIO.LoadLocal(pathNameOut,
                            smpNew,
                            retSampleRate,
                            retNumCh,
                            null/*retFileInfoStr*/,
                            null/*sampleHint*/,
                            retBWF/*bwfHint*/
                            ))
         {
            if(retNumCh == num_channels)
            {
               Global.Debug("SampleView::processSelectionWithRubberband: smpOld.numElements="+smpDat.numElements+" smpNew.numElements="+smpNew.numElements);
               FloatArray oldClipboardSamples <= deref clipboard_samples;
               int oldClipboardNumChannels = clipboard_num_channels;

               clipboard_samples <= smpNew;
               clipboard_num_channels = retNumCh;
               replaceSelectionByClipboard(true/*bUndoBegin*/);

               clipboard_samples <= deref oldClipboardSamples;
               clipboard_num_channels = oldClipboardNumChannels;
            }
            return true;
         }
      }
      catch(Error e)
      {
         trace "[---] SampleView::processSelectionWithRubberband: caught WavIO load error e.message="+e.message;
      }
      return false;
   }

   public method fadeInSelection(boolean _bUndoBegin) {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int numFrames = sel_endoff - sel_startoff;

               if(_bUndoBegin)
                  undoBegin("fadeInSelection");

               undoActionModify(sel_startoff, numFrames, sel_channel_mask);

               int numCh = num_channels;
               int skipCh = 0;

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_L == sel_channel_mask)
                  {
                     numCh = 1;
                     skipCh = 1;
                  }
                  else if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     smpStartOff++;
                     numCh = 1;
                     skipCh = 1;
                  }
               }

               float a = 0.0;
               float w = 1.0 / numFrames;
               int i = smpStartOff;
               compile loop(numFrames)
               {
                  loop(numCh)
                  {
                     samples[i] = samples[i] * a;
                     i++;
                  }
                  i += skipCh;
                  a += w;
               }

               if(_bUndoBegin)
               {
                  undoEnd();

                  handleWaveformChanged();
               }

               redraw();
            }
            else
            {
               Global.Error("SampleView::fadeInSelection: read-only sample data");
            }
         }
      }
   }

   public method fadeOutSelection(boolean _bUndoBegin) {
      if(null != samples)
      {
         if(sel_endoff > sel_startoff)
         {
            if(!b_readonly)
            {
               int smpStartOff = sel_startoff * num_channels;
               int smpEndOff   = sel_endoff   * num_channels;
               int numFrames = sel_endoff - sel_startoff;

               if(_bUndoBegin)
                  undoBegin("fadeOutSelection");

               undoActionModify(sel_startoff, numFrames, sel_channel_mask);

               int numCh = num_channels;
               int skipCh = 0;

               if(2 == num_channels)
               {
                  if(CHANNEL_MASK_L == sel_channel_mask)
                  {
                     numCh = 1;
                     skipCh = 1;
                  }
                  else if(CHANNEL_MASK_R == sel_channel_mask)
                  {
                     smpStartOff++;
                     numCh = 1;
                     skipCh = 1;
                  }
               }

               float a = 1.0;
               float w = 1.0 / numFrames;
               int i = smpStartOff;
               compile loop(numFrames)
               {
                  loop(numCh)
                  {
                     samples[i] = samples[i] * a;
                     i++;
                  }
                  i += skipCh;
                  a -= w;
               }

               if(_bUndoBegin)
               {
                  undoEnd();

                  handleWaveformChanged();
               }

               redraw();
            }
            else
            {
               Global.Error("SampleView::fadeOutSelection: read-only sample data");
            }
         }
      }
   }

   public method declickSelectionEnd() {
      if(sel_endoff <= sel_startoff)
         selectAll(true/*bAction*/);

      if(sel_endoff > sel_startoff) // haveSelection ?
      {
         if(sel_endoff >= (sel_startoff + DECLICK_NUM_FRAMES))
         {
            int origStartOff = sel_startoff;
            sel_startoff = sel_endoff - DECLICK_NUM_FRAMES;
            fadeOutSelection(true/*bUndoBegin*/);
            sel_startoff = origStartOff;
            trace "[...] SampleView::declickSelectionEnd";
         }
      }
   }

   public method declickSelectionStart() {
      if(sel_endoff <= sel_startoff)
         selectAll(true/*bAction*/);

      if(sel_endoff > sel_startoff) // haveSelection ?
      {
         if(sel_endoff >= (sel_startoff + DECLICK_NUM_FRAMES))
         {
            int origEndOff = sel_endoff;
            sel_endoff = sel_startoff + DECLICK_NUM_FRAMES;
            fadeInSelection(true/*bUndoBegin*/);
            sel_endoff = origEndOff;
            trace "[...] SampleView::declickSelectionStart";
         }
      }
   }

   public =replay= method convertToMono() {
      if(!b_allow_channel_conversion)
         return;

      if(b_may_realloc)
      {
         if(2 == num_channels)
         {
            boolean bUndo = (null != samples);

            if(null != samples)
            {
               undoBegin("convertToMono");

               // Backup all samples
               undoActionModify(0, samples.numElements / 2, CHANNEL_MASK_LR);

               undoActionDeleteChannel(CHANNEL_MASK_R);

               FloatArray newSamples;
               newSamples.alloc(samples.numElements / 2);
               newSamples.useAll();

               if(null != plugin)
               {
                  plugin.svBeginReallocSamples();
               }
               else
               {
                  // Stop all voices
                  // // Global.Panic();
               }

               int dstOff = 0;
               int srcOff = 0;
               compile loop(newSamples.numElements)
               {
                  float l = samples.get(srcOff);
                  float r = samples.get(srcOff + 1);

                  newSamples[dstOff] = (l + r) * 0.5f;

                  // Next frame
                  dstOff += 1;
                  srcOff += 2;
               }

               samples.unlinkFrom(newSamples);
               // // newSamples.free();
            }

            num_channels = 1;
            if(null != waveform)
            {
               waveform.numChannels = 1;
            }

            if(null != samples)
            {
               if(null != plugin)
               {
                  plugin.svEndReallocSamples();
               }

            }

            handleWaveformChanged();


            sel_channel_mask = CHANNEL_MASK_LR;

            if(bUndo)
               undoEnd();

            redraw();

            Global.Success("Waveform converted to mono ("+samples.numElements+" sample frames)");

         } // if 2==num_channels
      } // if b_may_realloc
   }

   public =replay= method convertToStereo(boolean _bForceAndDontStartUndo) {
      if(!b_allow_channel_conversion && !_bForceAndDontStartUndo)
         return;

      if(b_may_realloc)
      {
         boolean bUndo = (null != samples);

         if(1 == num_channels)
         {
            if(null != samples)
            {
               if(!_bForceAndDontStartUndo)
               {
                  undoBegin("convertToStereo");
               }
               undoActionCreateChannel(CHANNEL_MASK_R);

               FloatArray newSamples;
               newSamples.alloc(samples.numElements * 2);
               newSamples.useAll();

               if(!_bForceAndDontStartUndo)
               {
                  if(null != plugin)
                  {
                     plugin.svBeginReallocSamples();
                  }
                  else
                  {
                     // Stop all voices
                     // // Global.Panic();
                  }
               }

               int dstOff = 0;
               int srcOff = 0;
               compile loop(samples.numElements)
               {
                  float m = samples.get(srcOff);

                  newSamples[dstOff + 0] = m;
                  newSamples[dstOff + 1] = m;

                  // Next frame
                  dstOff += 2;
                  srcOff += 1;
               }

               samples.unlinkFrom(newSamples);
               // // newSamples.free();
            }

            num_channels = 2;
            if(null != waveform)
            {
               waveform.numChannels = 2;
            }

            if(!_bForceAndDontStartUndo && bUndo)
            {
               if(null != plugin)
               {
                  plugin.svEndReallocSamples();
               }

               handleWaveformChanged();

               undoEnd();
            }

            redraw();

            Global.Success("Waveform converted to stereo ("+(samples.numElements/2)+" frames)");
         } // if 2==num_channels
      } // if b_may_realloc
   }

   public =replay= method deleteChannel(int _chMask) {
      if(!b_allow_channel_conversion)
         return;

      if(b_may_realloc)
      {
         if(2 == num_channels)
         {
            boolean bUndo = (null != samples);

            if(null != samples)
            {
               undoBegin("deleteChannel");

               int numFrames = samples.numElements / 2;

               // Backup channel samples
               undoActionModify(0, numFrames, _chMask);

               undoActionDeleteChannel(_chMask);

               FloatArray newSamples;
               newSamples.alloc(numFrames);
               newSamples.useAll();

               if(null != plugin)
               {
                  plugin.svBeginReallocSamples();
               }
               else
               {
                  // Stop all voices
                  // // Global.Panic();
               }

               int srcCh = (CHANNEL_MASK_L == _chMask) ? 1 : 0;

               tksampleedit_ringbuf_copy_samples(newSamples, 1/*dstNumCh*/, 0/*dstChOff*/, 0,
                                                 numFrames, 1/*numCh*/,
                                                 samples,    2/*srcNumCh*/, srcCh/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               samples.unlinkFrom(newSamples);
               // // newSamples.free();
            }

            num_channels = 1;
            if(null != waveform)
            {
               waveform.numChannels = 1;
            }

            if(bUndo)
            {
               if(null != plugin)
               {
                  plugin.svEndReallocSamples();
               }
            }

            handleWaveformChanged();

            sel_channel_mask = CHANNEL_MASK_LR;

            if(bUndo)
               undoEnd();

            redraw();

            Global.Success("Waveform converted to mono ("+samples.numElements+" sample frames)");

         } // if 2==num_channels
      } // if b_may_realloc
   }

   public virtual wantTriadKeyMode() : boolean {
      return true;
   }

   public virtual onKeyboardFocusLost(boolean _bQuiet) {
      ta_key_scroll.cancel();
      key_scroll_dir = 0;
   }

   public virtual wantKeyRepeat(Key _k) : boolean {
      if(!b_cycle_mode || (VMOD_LCTRL == _k.mod))
      {
         return !([VKEY_LEFT, VKEY_RIGHT].contains(_k.code));
      }
      else
      {
         return true;
      }
   }

   public virtual onKey(Key _key) : boolean {
      // trace "xxx SampleView onKey k.name="+_key.name+" _key.code="+_key.code+" rel="+_key.released+" pressd="+_key.pressed;

      switch(_key.released)
      {
         case 96: // '^'
            if(0 == _key.mod)
            {
               // Key-release after freedraw-mode toggle. Prevent RootForm from processing it as "ref-tone-off"
               return true;
            }
            break;

         case VKEY_LEFT:
            stopKeyScroll(1);
            return true;

         case VKEY_RIGHT:
            stopKeyScroll(-1);
            return true;
      }

      switch(_key.pressed)
      {
         case 319: // windows menu button
            showContextMenu();
            return true;

         case VKEY_HOME:
            setSelectionToStart();
            return true;

         case VKEY_END:
            if(_key.modShift())
               expandSelectionToEnd();
            else
               gotoEndOfSelectionOrWaveform();
            return true;

         case VKEY_RETURN:
            appendSelectionToClipboardBorderSilence();
            return true;

         case VKEY_SPACE:
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  showAll();
               }
               else
               {
                  toggleFitSelectionToWindow();
               }
               return true;
            }
            return false;

         case VKEY_UP:
            uiZoomIn(null);
            return true;

         case VKEY_DOWN:
            uiZoomOut(null);
            return true;

         case VKEY_LEFT:
            if(_key.modShift() && _key.modCtrl())
            {
               moveSelectedRegionLeft();
            }
            else
            {
               if(b_cycle_mode)
               {
                  if(VMOD_LCTRL == _key.mod)
                  {
                     startKeyScroll(1);
                  }
                  else
                  {
                     if( (0 == wavetable_cycle_len) && (autochop_start_offsets.numElements > 1) && (-1 != getSelectedRegionIdx()) )////getNumSelectedSamples() > CYCLEMODE_MAX_NUM_FRAMES)
                        selectPreviousAutoChopRegion();
                     else
                        selectPreviousCycle();
                  }
               }
               else if(VMOD_LCTRL == _key.mod)
               {
                  startKeyScroll(1);
               }
               else
               {
                  selectPreviousAutoChopRegion();
               }
            }
            return true;

         case VKEY_RIGHT:
            if(_key.modShift() && _key.modCtrl())
            {
               moveSelectedRegionRight();
            }
            else
            {
               if(b_cycle_mode)
               {
                  if(VMOD_LCTRL == _key.mod)
                  {
                     startKeyScroll(-1);
                  }
                  else
                  {
                     if( (0 == wavetable_cycle_len) && (autochop_start_offsets.numElements > 1) && (-1 != getSelectedRegionIdx()) )////getNumSelectedSamples() > CYCLEMODE_MAX_NUM_FRAMES)
                        selectNextAutoChopRegion();
                     else
                        selectNextCycle();
                  }
               }
               else if(VMOD_LCTRL == _key.mod)
               {
                  startKeyScroll(-1);
               }
               else
               {
                  selectNextAutoChopRegion();
               }
            }
            return true;

         case 96: // '^'
            if(0 == _key.mod)
            {
               setFreedrawMode(!b_freedraw);
               return true;
            }
            break;

         case 'a':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  selectNone();
               }
               else
               {
                  selectAll(true/*bAction*/);
               }
               return true;
            }
            else
            {
               showContextMenu();
               return true;
            }
            break;

         case 'c':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  appendSelectionToClipboardBorderSilence();
               }
               else
               {
                  copySelection();
               }
               return true;
            }
            break;

         case 'i':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  toggleShowSamples();
               }
               else
               {
                  toggleShowRMS();
               }
               return true;
            }
            break;

         case 'j':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  showAutochopDialog();
               }
               else
               {
                  toggleShowRegions();
               }
               return true;
            }
            else if(_key.modShift())
            {
               toggleAutochopRMS();
               return true;
            }
            break;

         case 'e':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  handleMultiExportRegions();
               }
               else
               {
                  handleExportSelection();
               }
               return true;
            }
            break;

         case 'f':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  fadeInSelection(true/*bUndoBegin*/);
               }
               else
               {
                  fadeOutSelection(true/*bUndoBegin*/);
               }
               return true;
            }
            break;

         case 'b':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  declickSelectionStart();
               }
               else
               {
                  declickSelectionEnd();
               }
               return true;
            }
            break;

         case 'e':
            if(_key.modNone())
            {
               copyHighlightToSelection(true/*bZoom*/);
               return true;
            }
            break;

         case 'g':
            if(_key.modCtrl())
            {
               toggleShowHighlight();
               return true;
            }
            break;

         case 'h':
            if(_key.modCtrl())
            {
               copySelectionToHighlight(true/*bProvide*/);
               return true;
            }
            break;

         case 'k':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  deleteChannel(CHANNEL_MASK_R);
               }
               else
               {
                  deleteChannel(CHANNEL_MASK_L);
               }
               return true;
            }
            break;

         case 'l':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  undoClear();
                  return true;
               }
            }
            break;

         case 'm':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  convertToStereo(false/*bForceAndDontStartUndo*/);
               }
               else
               {
                  convertToMono();
               }
               return true;
            }
            break;

         case 'n':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  normalizeRegions(256/*fadeNumFrames*/);
               }
               else
               {
                  normalizeSelection(true/*bUndoBegin*/);
               }
               return true;
            }
            break;

         case 'o':
            if(_key.modCtrl())
            {
               amplifySelection1(false/*bNearMouse*/);
               return true;
            }
            break;

         case 'p':
            if(_key.modCtrl())
            {
               phaseInvertSelection();
               return true;
            }
            break;

         case 'q':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  if(b_cycle_mode)
                  {
                     selectPreviousCycle();
                  }
                  else
                  {
                     selectPreviousAutoChopRegion();
                  }
               }
               else
               {
                  if(b_cycle_mode)
                  {
                     selectNextCycle();
                  }
                  else
                  {
                     selectNextAutoChopRegion();
                  }
               }
               return true;
            }
            break;

         case 'r':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  crossfadeSelection();
               }
               else
               {
                  reverseSelection();
               }
               return true;
            }
            else if(_key.modShift())
            {
               loopCrossfadeSelection1(false/*bNearMouse*/);
               return true;
            }
            break;

         case 's':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  showSoXDialog(false/*bNearMouse*/);
               }
               else
               {
                  tightenSelection(_key.modShift());
               }
               return true;
            }
            else if(_key.modShift())
            {
               cycleBPMSnapGrid();
               return true;
            }
            else if(0 == _key.mod)
            {
               cycleBPMMarkerSnapModes();
               return true;
            }
            break;

         case 'd':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  surroundSelectionWithSilence(true/*bUndoBegin*/);
               }
               else
               {
                  silenceSelection(true/*bUndoBegin*/);
               }
               return true;
            }
            break;

         case 't':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  autotrim();
               }
               else
               {
                  truncateSelection();
               }
               return true;
            }
            break;

         case 'v':
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  replaceSelectionByClipboard(true/*bUndoBegin*/);
               }
               else
               {
                  pasteSelectionAtEnd(true/*bUndoBegin*/);
               }
               return true;
            }
            else if(_key.modShift())
            {
               addClipboardToSelection();
               return true;
            }
            break;

         case 'w':
            if(_key.modCtrl())
            {
               cutSelection();
               return true;
            }
            break;

         case 'y': // 'z' on german kbd
            if(_key.modCtrl())
            {
               if(_key.modShift())
               {
                  redo();
               }
               else
               {
                  undo();
               }
               return true;
            }
            break;

         case 'z': // 'y' on german kbd
            if(_key.modCtrl())
            {
               toggleZeroCrossingMode();
               return true;
            }
            else if(_key.modShift())
            {
               toggleCycleMode(null/*evOrNull*/);
               return true;
            }
            break;

         case VKEY_DELETE:
            deleteSelection(true/*bUndoBegin*/);
            return true;
      }

      startPlayTimer();

      return false;
   }

   protected method tryMaintainSampleOffsetAtMouseX(int _smpOff, float _mx) {

      int numFrames = (samples.numElements / num_channels);
      int numVisFrames = (numFrames * zoom) + 0.5;

      // // int sampleOff = (numFrames - numVisFrames) * 0.5;
      // // int invisFrame = numFrames - (sampleOff + numVisFrames);

      // // int invisFrame = numFrames - ((numFrames - numVisFrames) * 0.5 + numVisFrames);
      // // int invisFrame = numFrames - (numFrames/2 - numVisFrames/2  + numVisFrames);
      // // int invisFrame = numFrames - numFrames/2 + numVisFrames/2  - numVisFrames;
      int invisFrame = numFrames*0.5 - numVisFrames*0.5;

      float smpPerPix = numVisFrames / (size_x-4); // -4 for 2*2 border width

      // // sampleOff = (numFrames - numVisFrames) * 0.5 + int((invisFrame * offset)+0.5) + ( (_mx-2) * smpPerPix);
      offset = ( (numFrames - numVisFrames) * 0.5 + ( (_mx-2) * smpPerPix) - _smpOff ) / -invisFrame;

      offset = mathClampf(offset, -1, 1);

      // // sampleOff += int((invisFrame * offset)+0.5);
      // // sampleOff += ( (_mx-2) * smpPerPix); // -2 for left border
   }

   protected method calcSampleOffsetAtMouseX(int _mx) : int {
      if(null != samples)
      {
         ////trace "xxx ~~~~~~~~~~~~~~~~~~~~~~~ calcSampleOffsetAtMouseX: mx="+_mx;

         int numFrames = (samples.numElements / num_channels);
         int numVisFrames = (numFrames * zoom) + 0.5;
         int sampleOff = (numFrames - numVisFrames) * 0.5;// + 0.5;
         int invisFrame = numFrames - (sampleOff + numVisFrames);

         sampleOff += int((invisFrame * offset)+0.5);

         if(sampleOff < 0)
            sampleOff = 0;
         else if(sampleOff >= (numFrames - numVisFrames))
            sampleOff = numFrames - numVisFrames;

         // // // float pixPerSmp = (size_x-4) / numVisFrames;

         ////trace "xxx calcSampleOffsetAtX("+_mx+") numVis="+numVisFrames+" sampleOff="+sampleOff;
         ////trace "xxx base sampleOff="+sampleOff;

         float smpPerPix = numVisFrames / (size_x-4); // -4 for 2*2 border width
         sampleOff += ( (_mx-2) * smpPerPix); // -2 for left border

         if(sampleOff < 0)
            sampleOff = 0;
         else if(sampleOff > numFrames)
            sampleOff = numFrames;

         ////trace "xxx mouse sampleOff="+sampleOff;

         //return (sampleOff+0.5);
         return sampleOff;
      }
      else
      {
         return 0;
      }
   }

   protected method trySelectHighlightedAreaUnderMouse(MouseEvent _ev) : boolean {
      if(b_render_highlight)
      {
         if(null != samples)
         {
            int off = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
            if(hl_startoff <= off <= hl_endoff)
            {
               sel_startoff = hl_startoff;
               sel_endoff   = hl_endoff;
               sel_channel_mask = CHANNEL_MASK_LR;

               handleSelectionChanged();
               handleRegionSelected();

               UI.CompositeAll();
               return true;
            }
         }
      }
      return false;
   }

   protected method lazyCalcAreaInfoStringWidths() {
      if(0 == stringw_hl_start)
      {
         getFont();
         stringh = font.stringHeight("gyM");
         stringw_hl_start  = font.stringWidth("Highlight start: ");
         stringw_hl_end    = font.stringWidth("end: ");
         stringw_hl_len    = font.stringWidth("len: ");
         stringw_sel_start = font.stringWidth("Selection start: ");
         stringw_sel_end   = font.stringWidth("end: ");
         stringw_sel_len   = font.stringWidth("len: ");
         stringw_vis       = font.stringWidth("vis: ");
      }
   }

   // // <method.png>
   // public method autochop_slow(FloatArray _samples, float _startMinThreshold) : boolean {
   //    // Fill autochop_start_offsets / autochop_end_offsets arrays

   //    float startThreshold = 0.07;
   //    // float startMinThreshold = 0.005;  // for catching entire transient
   //    // float startMinThreshold = 0.001;  // for catching entire transient
   //    float startMinThreshold = _startMinThreshold;  // for catching entire transient

   //    // static float startThreshold = 0.01;
   //    // static float startMinThreshold = 0.005;  // for catching entire transient

   //    int startMinNumFramesBack = 512;//60;

   //    // float endThreshold = 0.012;
   //    float endThreshold = 0.001;
   //    // // static float endNumFramesThreshold = 2000;
   //    float autochopSilenceDurationMS = 45.0; // milliseconds (1984 frames @44.1kHz)
   //    int endNumFramesThreshold = (autochopSilenceDurationMS * sample_rate) / 1000.0f;

   //    // // int endNumFramesCheckRestartThreshold = 500;  // #frames below endThreshold before allowing restart
   //    float endThresholdRestart = 0.03;  // when to allow new start
   //    int restartNumFramesThreshold = 1000;


   //    int pickSlice = -1;
   //    int maxSlices = 9999;

   //    // ---- end config ----


   //    autochop_start_offsets.free();
   //    autochop_end_offsets.free();

   //    int numFrames = _samples.numElements / num_channels;

   //    // trace "xxx processData: numFrames="+numFrames;


   //    int frameIdx = 0;
   //    int sliceIdx = 0;
   //    int frameIdxBwd;

   //    int state = 0; // 0=find start, 1=find end

   //    float lastStartMinSmp = 99999;
   //    int lastStartMinIdx = -1;

   //    int endNumFramesCnt;

   //    boolean bAllowRestart = false;
   //    int allowRestartCnt = 0;

   //    compile loop(numFrames)
   //    {
   //       for(int chIdx = 0; chIdx < 1/*num_channels*/; chIdx++)
   //       {
   //          float smp = _samples.get(frameIdx*num_channels+chIdx);
   //          if(smp < 0)
   //             smp = -smp;

   //          int startIdx;
   //          int endIdx;

   //          if(0 == state)
   //          {
   //             if(smp > startThreshold)
   //             {
   //                if(-1 == lastStartMinIdx)
   //                {
   //                   startIdx = frameIdx;
   //                }
   //                else
   //                {
   //                   startIdx = lastStartMinIdx;
   //                }

   //                trace "slice "+sliceIdx+" start at "+startIdx+"   (curNum="+autochop_start_offsets.numElements+" max="+maxSlices+")";
   //                if(autochop_start_offsets.numElements < maxSlices)
   //                {
   //                   if( (-1 == pickSlice) || (sliceIdx == pickSlice) )
   //                   {
   //                      autochop_start_offsets.add(startIdx);
   //                   }
   //                }
   //                endNumFramesCnt = 0;
   //                state = 1;
   //                lastStartMinIdx = -1;
   //                allowRestartCnt = 0;
   //                bAllowRestart = false;
   //             }
   //             else if(smp > startMinThreshold)
   //             {
   //                if(-1 == lastStartMinIdx)
   //                {
   //                   // Force update (first candidate)
   //                   lastStartMinSmp = smp;
   //                   lastStartMinIdx = frameIdx;
   //                }
   //                else if( lastStartMinIdx < (frameIdx - startMinNumFramesBack) )
   //                {
   //                   // Force update (last start candidate is too old)
   //                   lastStartMinSmp = smp;
   //                   lastStartMinIdx = frameIdx;
   //                }
   //             }
   //             else if( lastStartMinIdx < (frameIdx - startMinNumFramesBack) )
   //             {
   //                // Discard last candidate (too old)
   //                lastStartMinIdx = -1;
   //             }
   //          }
   //          else
   //          {
   //             if(smp < endThresholdRestart)
   //             {
   //                allowRestartCnt++;

   //                if(allowRestartCnt >= restartNumFramesThreshold)
   //                {
   //                   bAllowRestart = true; // b_autochop_restart/*true*/;
   //                }
   //             }
   //             else
   //             {
   //                allowRestartCnt = 0;
   //             }

   //             if(smp < endThreshold)
   //             {
   //                endNumFramesCnt++;
   //                if(endNumFramesCnt >= endNumFramesThreshold)
   //                {
   //                   trace "slice end at "+frameIdx+"  (after "+endNumFramesCnt+" frames of silence)";

   //                   if(autochop_end_offsets.numElements < maxSlices)
   //                   {
   //                      if( (-1 == pickSlice) || (sliceIdx == pickSlice) )
   //                      {
   //                         // Search backward and skip zero samples
   //                         endIdx = frameIdx;
   //                         frameIdxBwd = frameIdx;
   //                         while(--frameIdxBwd > startIdx)
   //                         {
   //                            smp = _samples.get(frameIdxBwd*num_channels+chIdx);
   //                            if(0 != smp)
   //                            {
   //                               endIdx = frameIdxBwd + 1;
   //                               break;
   //                            }
   //                         }
   //                         autochop_end_offsets.add(endIdx);
   //                      }
   //                      sliceIdx++;
   //                   }
   //                   state = 0;
   //                }
   //             }
   //             else
   //             {
   //                endNumFramesCnt = 0;

   //                if(bAllowRestart)
   //                {
   //                   // trace "xxx bAllowRestart: smp="+smp+" startThreshold="+startThreshold;
   //                   if(smp > startThreshold)
   //                   {
   //                      autochop_end_offsets.add(frameIdx);

   //                      startIdx = frameIdx;

   //                      trace "slice restart at "+startIdx;

   //                      if(autochop_start_offsets.numElements < maxSlices)
   //                      {
   //                         if( (-1 == pickSlice) || (sliceIdx == pickSlice) )
   //                         {
   //                            autochop_start_offsets.add(startIdx);
   //                         }
   //                      }
   //                      endNumFramesCnt = 0;
   //                      //state = 1;
   //                      lastStartMinIdx = -1;
   //                      allowRestartCnt = 0;
   //                      bAllowRestart = false;
   //                   }

   //                }
   //             }
   //          }

   //       }

   //       frameIdx++;
   //    }

   //    if(1 == state)
   //    {
   //       if(autochop_end_offsets.numElements < maxSlices)
   //       {
   //          if( (-1 == pickSlice) || (sliceIdx == pickSlice) )
   //          {
   //             // Search backward and skip zero samples
   //             endIdx = frameIdx;
   //             frameIdxBwd = frameIdx;
   //             while(--frameIdxBwd > startIdx)
   //             {
   //                smp = _samples.get(frameIdxBwd*num_channels+0/*chIdx*/);
   //                if(0 != smp)
   //                {
   //                   endIdx = frameIdxBwd + 1;
   //                   break;
   //                }
   //             }
   //             autochop_end_offsets.add(endIdx);
   //          }
   //       }
   //    }

   //    Global.Debug("SampleView::AutoChop::process: num_start="+autochop_start_offsets.numElements+" num_end="+autochop_end_offsets.numElements);

   //    return (autochop_start_offsets.numElements > 0);
   // }

   // <method.png>
   public method autochop(FloatArray _samples, float _startMinThreshold) : boolean {
      // Fill autochop_start_offsets / autochop_end_offsets arrays

      float startThreshold           = 0.12;
      float startMinThreshold        = _startMinThreshold;  // for catching entire transient
      int   startMinNumFramesBack    = 512;//60;
      float endThreshold             = 0.001;
      float endThresholdRestart      = 0.08;  // #frames below endThreshold before allowing restart
      int   endNumFramesThreshold    = 1984;////(autochopSilenceDurationMS * sample_rate) / 1000.0f;
      int  restartNumFramesThreshold = 1000;

      float autochopSilenceDurationMS = 45.0; // milliseconds (1984 frames @44.1kHz)

      autochop_start_offsets.free();
      autochop_end_offsets.free();

      int numFrames = _samples.numElements / num_channels;

      tksampleedit_autochop(autochop_start_offsets, autochop_end_offsets,
                            _samples, num_channels,
                            startThreshold,
                            startMinThreshold,
                            startMinNumFramesBack,
                            endThreshold,
                            endNumFramesThreshold,
                            endThresholdRestart,
                            restartNumFramesThreshold
                            );


      Global.Debug("SampleView::AutoChop::process: num_start="+autochop_start_offsets.numElements+" num_end="+autochop_end_offsets.numElements);

      return (autochop_start_offsets.numElements > 0);
   }

   // <method.png>
   public method autochopRMS(FloatArray _samples) : boolean {
      // Fill autochop_start_offsets / autochop_end_offsets arrays

      autochop_start_offsets.free();
      autochop_end_offsets.free();

      int numFrames = _samples.numElements / num_channels;

      // trace "xxx processData: numFrames="+numFrames;
      // trace "xxx config.rmsPeakRatio="+autochop_config.rmsPeakRatio;

      // (note) max args exceeded (16)
      local FloatArray faRatios = [autochop_config.restartRMSRatioShort,
                                   autochop_config.restartRMSRatioLong,
                                   autochop_config.restartRMSRatioImm,
                                   autochop_config.rmsPeakRatio,
                                   ];

      if(true == b_autochop_rms)
      {
         tksampleedit_autochop_rms(autochop_start_offsets, autochop_end_offsets,
                                   _samples, num_channels,
                                   autochop_config.startThreshold,
                                   autochop_config.startMinThreshold,
                                   autochop_config.startMinNumFramesBack,
                                   autochop_config.endThreshold,
                                   autochop_config.endNumFramesThreshold,
                                   autochop_config.restartNumFramesThreshold,
                                   faRatios,
                                   autochop_config.restartRMSRatioLongNumFrames,
                                   autochop_config.restartThresholdImm,
                                   autochop_config.restartRewindNumFrames,
                                   autochop_config.rmsAvgSlew
                                   );
      }
      else
      {
         tksampleedit_autochop_rms_windowed(autochop_start_offsets, autochop_end_offsets,
                                            _samples, num_channels,
                                            autochop_config.slewed_hpf,
                                            autochop_config.slewed_rmsWindowSize * (sample_rate / 1000.0),
                                            autochop_config.slewed_timeout * (sample_rate / 1000.0),
                                            autochop_config.slewed_rmsSlew / 10.0,
                                            autochop_config.slewed_avgPeakRatioSlew / 100.0,
                                            autochop_config.slewed_avgPeakRatioThreshold,
                                            1024/*maxMarkers*/
                                            );

         // trace "xxx #start="+autochop_start_offsets.numElements+" #end="+autochop_end_offsets.numElements;
         // trace "xxx endOffsets="+#(autochop_end_offsets);
      }


      Global.Debug("SampleView::AutoChop::process: num_start="+autochop_start_offsets.numElements+" num_end="+autochop_end_offsets.numElements);

      return (autochop_start_offsets.numElements > 0);
   }

   public method tightenSelection(boolean _bLowMinThreshold) {
      if(sel_endoff <= sel_startoff) // haveSelection ?
         selectAll(true/*bAction*/);

      if(sel_endoff > sel_startoff) // haveSelection ?
      {
         int frameOff = sel_startoff;
         local FloatArray smp;
         smp.visit(samples, sel_startoff*num_channels, (sel_endoff - sel_startoff)*num_channels);
         float minThreshold = _bLowMinThreshold ? AUTOCHOP_MIN_THRESHOLD_LOW : AUTOCHOP_MIN_THRESHOLD_DEF;  // ignore noise floor? (digital recordings)
         autochop(smp, minThreshold);
         Global.Debug("SampleView::tightenSelection: starts="+#(autochop_start_offsets)+" ends="+#(autochop_end_offsets));
         if((autochop_start_offsets.numElements >= 1) &&
            (autochop_end_offsets.numElements >= 1)
            )
         {
            sel_startoff = autochop_start_offsets.first + frameOff;

            if(autochop_end_offsets.numElements >= 2)
            {
               // (todo) check rms, single sample frame could be zero crossing (unlikely, though)
               if( (abs(smp.get(autochop_end_offsets.last - 1)) >= 0.001/*endThreshold*/) ||
                   (abs(smp.get(autochop_end_offsets.last - 2)) >= 0.001/*endThreshold*/) ||
                   (abs(smp.get(autochop_end_offsets.last - 3)) >= 0.001/*endThreshold*/) ||
                   (abs(smp.get(autochop_end_offsets.last - 4)) >= 0.001/*endThreshold*/)
                   )
               {
                  // Ends with non-zero sample, use previous slice
                  sel_endoff = autochop_end_offsets.get(autochop_end_offsets.numElements-2) + frameOff;
               }
               else
               {
                  sel_endoff = autochop_end_offsets.last + frameOff;
               }
            }
            else
            {
               sel_endoff = autochop_end_offsets.last + frameOff;
            }

            redraw();
            trace "SampleView::tightenSelection: sel=("+sel_startoff+";"+sel_endoff+")";
         }
         handleSelectionChanged();
         autochop_start_offsets.free();
         autochop_end_offsets.free();
      }
   }

   public method lazyAutoChopRegionsForced() {
      if(null != samples)
      {
         if((samples.numElements > 0) && (num_channels > 0))
         {
            if(0 == autochop_start_offsets.numElements)
            {
               if(false != b_autochop_rms)
                  autochopRMS(samples);
               else
                  autochop(samples, AUTOCHOP_MIN_THRESHOLD_DEF);

               Global.Debug("SampleView::lazyAutoChopRegions: #start_offsets="+autochop_start_offsets.numElements);
            }
         }
         else
         {
            autochop_start_offsets.free();
            autochop_end_offsets.free();
         }
      }
      else
      {
         autochop_start_offsets.free();
         autochop_end_offsets.free();
      }
   }

   public method lazyAutoChopRegions() {
      if(b_autochop)
      {
         lazyAutoChopRegionsForced();
      }
   }

   protected method invalidateAutoChop() {
      if(b_autochop)
      {
         autochop_start_offsets.free();
         autochop_end_offsets.free();
      }
   }

   public method recalcAutoChopRegions() {
      if(b_autochop)
      {
         invalidateAutoChop();
         lazyAutoChopRegions();
      }
   }

   public method setEnableAutoRecalcRegions(boolean _bEnable) {
      b_autorecalc_autochop = _bEnable;
   }

   public method setEnableAutochop(boolean _bEnable) {
      b_autochop = _bEnable;
   }

   public method setEnableMarkerCreate(boolean _bEnable) {
      b_marker_create = _bEnable;
   }

   public method setEnableMarkerDelete(boolean _bEnable) {
      b_marker_delete = _bEnable;
   }

   public method getNumRegions() : int {
      if(null != samples)
      {
         return autochop_start_offsets.numElements;
      }
      return 0;
   }

   protected method findAutoChopRegionIdxNear(int _frameOff) : int {
      int r = -1;

      if(autochop_start_offsets.numElements > 0)
      {
         int bestIdx = 0;
         int bestDist = 999999999;
         int off;
         int idx = 0;
         foreach off in autochop_start_offsets
         {
            int dist = abs(off - _frameOff);
            // trace "xxx off="+off+" sel_startoff="+sel_startoff+" dist="+dist;
            if(dist < bestDist)
            {
               bestIdx = idx;
               bestDist = dist;
            }

            // Next region
            idx++;
         }

         r = bestIdx;
      }

      return r;
   }

   protected method findAutoChopRegionIdxAt(int _frameOff) : int {
      if(autochop_start_offsets.numElements > 0)
      {
         int idx = 0;
         loop(autochop_start_offsets.numElements)
         {
            int startOff = autochop_start_offsets[idx];
            int endOff = autochop_end_offsets[idx];

            if(startOff <= _frameOff < endOff)
            {
               return idx;
            }

            // Next region
            idx++;
         }
      }

      return -1;
   }

   public method selectNextAutoChopRegion() {
      lazyAutoChopRegions();

      int regionIdx = findAutoChopRegionIdxNear(sel_startoff);
      if(-1 != regionIdx)
      {
         if((sel_startoff != autochop_start_offsets[regionIdx]) ||
            (sel_endoff != autochop_end_offsets[regionIdx])
            )
         {
            setSelection(autochop_start_offsets[regionIdx],
                         autochop_end_offsets[regionIdx]
                         );
            makeSelectionVisible();
            handleSelectionChanged();
            handleRegionSelected();
         }
         else
         {
            if( (regionIdx + 1) < autochop_start_offsets.numElements )
            {
               setSelection(autochop_start_offsets[regionIdx + 1],
                            autochop_end_offsets[regionIdx + 1]
                            );
               makeSelectionVisible();
               handleSelectionChanged();
               handleRegionSelected();
            }
         }
      }
   }

   public method selectPreviousAutoChopRegion() {
      lazyAutoChopRegions();

      int regionIdx = findAutoChopRegionIdxNear(sel_startoff);
      if(-1 != regionIdx)
      {
         if((sel_startoff != autochop_start_offsets[regionIdx]) ||
            (sel_endoff != autochop_end_offsets[regionIdx])
            )
         {
            setSelection(autochop_start_offsets[regionIdx],
                         autochop_end_offsets[regionIdx]
                         );
            makeSelectionVisible();
            handleSelectionChanged();
            handleRegionSelected();
         }
         else if(regionIdx > 0)
         {
            setSelection(autochop_start_offsets[regionIdx - 1],
                         autochop_end_offsets[regionIdx - 1]
                         );
            makeSelectionVisible();
            handleSelectionChanged();
            handleRegionSelected();
         }
      }
   }

   public method moveSelectedRegionLeft() {
      int regionIdx = getSelectedRegionIdx();
      trace "xxx moveSelectedRegionLeft: regionIdx="+regionIdx;
      if(regionIdx > 0)
      {
         undoBegin("moveRegionLeft");

         int numFrames = sel_endoff - sel_startoff;
         int origSelStart = sel_startoff;

         sel_channel_mask = CHANNEL_MASK_LR;
         copySelection();

         sel_startoff = autochop_start_offsets.get(regionIdx - 1);
         int newOff = sel_startoff;
         pasteSelection(false/*bUndoBegin*/);  // increments sel_startoff

         insertSilenceAt_NoUndo(sel_startoff, NUM_BORDER_SILENCE_FRAMES);
         sel_startoff += NUM_BORDER_SILENCE_FRAMES;

         origSelStart += numFrames + NUM_BORDER_SILENCE_FRAMES;
         sel_startoff = origSelStart;
         sel_endoff = sel_startoff + numFrames;

         if(null != plugin)
         {
            plugin.svHandleMoveRegion(sel_startoff, numFrames, newOff);
         }

         deleteSelectionNoUndo(false/*bReselectRegion*/);

         undoEnd();

         handleWaveformChanged();
         if(!b_autorecalc_autochop)
            recalcAutoChopRegions();  // else: already chopped in handleWaveformChanged()
         selectRegionByIdx(regionIdx - 1);
         handleSelectionChanged();
         b_cycle_mode = true;
         handleRegionSelected();

         Global.Print("Move region left");
      }
   }

   public method moveSelectedRegionRight() {
      int regionIdx = getSelectedRegionIdx();
      int numRegions = getNumRegions();
      if((regionIdx+1) < numRegions)
      {
         undoBegin("moveRegionRight");

         int numFrames = sel_endoff - sel_startoff;
         int origSelStart = sel_startoff;

         sel_channel_mask = CHANNEL_MASK_LR;
         copySelection();

         sel_startoff = autochop_end_offsets.get(regionIdx + 1);

         insertSilenceAt_NoUndo(sel_startoff, NUM_BORDER_SILENCE_FRAMES);
         sel_startoff += NUM_BORDER_SILENCE_FRAMES;

         int newOff = sel_startoff;

         pasteSelection(false/*bUndoBegin*/);  // increments sel_startoff

         sel_startoff = origSelStart;
         sel_endoff = sel_startoff + numFrames;

         if(null != plugin)
         {
            plugin.svHandleMoveRegion(sel_startoff, numFrames, newOff);
         }

         deleteSelectionNoUndo(false/*bReselectRegion*/);

         undoEnd();

         handleWaveformChanged();
         if(!b_autorecalc_autochop)
            recalcAutoChopRegions();  // else: already chopped in handleWaveformChanged()
         selectRegionByIdx(regionIdx + 1);
         handleSelectionChanged();
         b_cycle_mode = true;
         handleRegionSelected();

         Global.Print("Move region right");
      }
   }

   protected method trySelectRegionUnderMouse(MouseEvent _ev) : boolean {
      if(null != samples)
      {
         lazyAutoChopRegions();
         int off = calcSampleOffsetAtMouseX(_ev.mouse_rel_x);
         if(off >= 0)
         {
            int regionIdx = findAutoChopRegionIdxAt(off);
            if(-1 == regionIdx)
            {
               regionIdx = findAutoChopRegionIdxNear(off);
            }
            if(-1 != regionIdx)
            {
               setSelection(autochop_start_offsets[regionIdx],
                            autochop_end_offsets[regionIdx]
                            );
               makeSelectionVisible();
               handleSelectionChanged();
               handleRegionSelected();
               UI.CompositeAll();
               return true;
            }
         }
      }
      return false;
   }

   protected method drawArea(int _c32,
                             int _c32Border,
                             int _startoff,
                             int _endoff,
                             int _sampleOff,
                             int _numVisFrames,
                             int _chMask
                             ) {

      if(_endoff >= _startoff)
      {
         // // Double pixPerSmp = (size_x - 4);
         // Double pixPerSmp = (size_x);
         // pixPerSmp = pixPerSmp / _numVisFrames;

         boolean bClipL = false;
         boolean bClipR = false;

         // float startx = (_startoff - _sampleOff) * pixPerSmp;
         float startx = ((_startoff - _sampleOff) * size_x) / _numVisFrames;
         if(startx < 0)
         {
            startx = 0;
            bClipL = true;
         }
         else if(startx >= (size_x-0))
         {
            return;
         }

         // float endx = (_endoff - _sampleOff) * pixPerSmp;
         float endx = ((_endoff - _sampleOff) * size_x) / _numVisFrames;

         startx = int(startx);
         endx = int(endx + 0.5);

         if(startx == endx)
            endx += 1;

         if(endx < 1)
         {
            return;
         }
         else if(endx > (size_x-1))
         {
            bClipR = true;
            endx = size_x-1;
         }

         // startx += 2;
         // endx += 2;

         int cy;
         // int sy = calcSampleSizeY() +1 - 2;
         int sy;

         float regionYT = MARKER_PY * UI.icon_scaling + 1;
         float regionYB = size_y - (UI.IsHiDPI()?24:14);
         float regionSy = (regionYB - regionYT);
         sy = regionSy;

         if(_chMask == CHANNEL_MASK_LR)
         {
            cy = regionYT;
            sy = regionSy;
         }
         else if(_chMask == CHANNEL_MASK_L)
         {
            sy = sy * 0.5f;
         }
         else if(_chMask == CHANNEL_MASK_R)
         {
            sy = sy * 0.5f;
            cy = regionYT + sy;
         }

         UIRenderer.DrawFilledRectangle(startx,        cy,
                                        endx - startx, sy,
                                        _c32
                                        );

         // Highlight left border if not clipped
         if(!bClipL)
         {
            UIRenderer.DrawLine(startx, cy, startx, cy+sy, _c32Border);
         }

         // Highlight right border if not clipped
         if(!bClipR)
         {
            UIRenderer.DrawLine(endx, cy, endx, cy+sy, _c32Border);
         }
      }
   }

   protected method drawHighlight(int _sampleOff, int _numVisFrames) {
      drawArea(color_highlight, color_highlight_border, hl_startoff, hl_endoff, _sampleOff, _numVisFrames, CHANNEL_MASK_LR);
   }

   protected method drawSelection(int _sampleOff, int _numVisFrames) {
      ////trace "xxx drawSelection: start="+sel_startoff+" end="+sel_endoff;

      // (todo) selection start/end is already sorted
      int startoff = sel_startoff;
      int endoff   = sel_endoff;
      if(endoff < startoff)
      {
         int t = startoff;
         startoff = endoff;
         endoff   = t;
      }
      drawArea(color_selection, color_selection_border, startoff, endoff, _sampleOff, _numVisFrames, sel_channel_mask);
   }

   protected method drawAreaInfo() {

      lazyCalcAreaInfoStringWidths(); // also initializes font

      int cx;
      int cy;
      UIRenderer.EnableBlending();

      if(UIRenderer.BeginFilledGouraudTriangles(6))
      {
         // 1
         UIRenderer.ColorARGB(color_areainfo_bg);
         UIRenderer.Vertex2f(2,2);

         UIRenderer.ColorARGB(color_areainfo_bg);
         UIRenderer.Vertex2f(size_x-2, 2);

         UIRenderer.ColorARGB(0);
         UIRenderer.Vertex2f(size_x-2, 2+16);

         // 2
         UIRenderer.ColorARGB(color_areainfo_bg);
         UIRenderer.Vertex2f(2,2);

         UIRenderer.ColorARGB(0);
         UIRenderer.Vertex2f(size_x-2, 2+16);

         UIRenderer.ColorARGB(0);
         UIRenderer.Vertex2f(2, 2+16);

         UIRenderer.End();
      }
      ////UIRenderer.DrawFilledRectangle(2, 2, size_x-4, 16, color_areainfo_bg);

      int ul32 = lnf_colors.get(LookAndFeel.COLOR_ACCEL_UL_FG);

      float areaInfoW = GetAreaInfoValueSx();

      // Draw highlight info
      cx = 10;
      UIRenderer.DrawText("highlight start:", font, color_areainfo_label, ul32, cx, 2, 0/*availW*/, 0/*align*/);
      cx += stringw_hl_start;
      UIRenderer.DrawText(hl_startoff, font, color_areainfo_valuesdw, ul32, cx+1, 2+1, 0/*availW*/, 0/*align*/);
      UIRenderer.DrawText(hl_startoff, font, color_areainfo_value, ul32, cx, 2, 0/*availW*/, 0/*align*/);
      cx += areaInfoW;

      UIRenderer.DrawText("end:", font, color_areainfo_label, ul32, cx, 2, 0/*availW*/, 0/*align*/);
      cx += stringw_hl_end;
      UIRenderer.DrawText(hl_endoff, font, color_areainfo_valuesdw, ul32, cx+1, 2+1, 0/*availW*/, 0/*align*/);
      UIRenderer.DrawText(hl_endoff, font, color_areainfo_value, ul32, cx, 2, 0/*availW*/, 0/*align*/);
      cx += areaInfoW;

      UIRenderer.DrawText("len: ", font, color_areainfo_label, ul32, cx, 2, 0/*availW*/, 0/*align*/);
      cx += stringw_hl_len;
      UIRenderer.DrawText((hl_endoff-hl_startoff), font, color_areainfo_valuesdw, ul32, cx+1, 2+1, 0/*availW*/, 0/*align*/);
      UIRenderer.DrawText((hl_endoff-hl_startoff), font, color_areainfo_value, ul32, cx, 2, 0/*availW*/, 0/*align*/);
      cx += areaInfoW;

      if(null != samples)
      {
         float numFrames = samples.numElements / num_channels;
         int numVisFrames = (numFrames * zoom) +0.5;

         UIRenderer.DrawText("vis: ", font, color_areainfo_label, ul32, cx, 2, 0/*availW*/, 0/*align*/);
         cx += stringw_vis;
         UIRenderer.DrawText(numVisFrames, font, color_areainfo_valuesdw, ul32, cx+1, 2+1, 0/*availW*/, 0/*align*/);
         UIRenderer.DrawText(numVisFrames, font, color_areainfo_value, ul32, cx, 2, 0/*availW*/, 0/*align*/);
      }

      // Draw selection info
      // (todo) selection start/end is already sorted
      int selStart = sel_startoff;
      int selEnd   = sel_endoff;
      if(selEnd < selStart)
      {
         int t = selStart;
         selStart = selEnd;
         selEnd   = t;
      }
      cy = size_y - stringh - 4;///18;
      // cx = size_x - SELINFO_SX;
      cx = 10;
      UIRenderer.DrawText("selection start: ", font, color_areainfo_label, ul32, cx, cy+2, 0/*availW*/, 0/*align*/);
      cx += stringw_sel_start;
      UIRenderer.DrawText(selStart, font, color_areainfo_valuesdw, ul32, cx+1, cy+2+1, 0/*availW*/, 0/*align*/);
      UIRenderer.DrawText(selStart, font, color_areainfo_value, ul32, cx, cy+2, 0/*availW*/, 0/*align*/);
      cx += areaInfoW;

      UIRenderer.DrawText("end:", font, color_areainfo_label, ul32, cx, cy+2, 0/*availW*/, 0/*align*/);
      cx += stringw_sel_end;
      UIRenderer.DrawText(selEnd, font, color_areainfo_valuesdw, ul32, cx+1, cy+2+1, 0/*availW*/, 0/*align*/);
      UIRenderer.DrawText(selEnd, font, color_areainfo_value, ul32, cx, cy+2, 0/*availW*/, 0/*align*/);
      cx += areaInfoW;

      UIRenderer.DrawText("len: ", font, color_areainfo_label, ul32, cx, cy+2, 0/*availW*/, 0/*align*/);
      cx += stringw_sel_len;
      UIRenderer.DrawText((selEnd-selStart), font, color_areainfo_valuesdw, ul32, cx+1, cy+2+1, 0/*availW*/, 0/*align*/);
      UIRenderer.DrawText((selEnd-selStart), font, color_areainfo_value, ul32, cx, cy+2, 0/*availW*/, 0/*align*/);
   }

   public virtual onDrawOverlays() {
      ////trace "xxx SampleView::onDrawOverlays";
      if(null != samples)
      {
         UIRenderer.EnableBlending();

         int numFrames = (samples.numElements / num_channels);
         int numVisFrames = (numFrames * zoom) + 0.5;
         int sampleOff = (numFrames - numVisFrames) * 0.5;// + 0.5;
         int invisFrame = numFrames - (sampleOff + numVisFrames);
         sampleOff += int((invisFrame * offset)+0.5);
         if(sampleOff < 0)
            sampleOff = 0;
         else if(sampleOff >= (numFrames - numVisFrames))
            sampleOff = numFrames - numVisFrames;

         // Disable alpha writes
         sdvg_AlphaWrite(false);

         // Draw highlight
         if(b_render_highlight)
         {
            drawHighlight(sampleOff, numVisFrames);
         }

         // Draw selection
         drawSelection(sampleOff, numVisFrames);

         // Draw text overlays
         drawAreaInfo();

         // Draw current sample play offset
         float playoff;
         if(null != waveform)
         {
            playoff = waveform.uiGetLastPlayedOffset();
            if(playoff >= 0)
            {
               playoff -= waveform.ringOffset;
               if(playoff < 0)
                  playoff += waveform.numFrames;
            }
         }
         else
         {
            playoff = play_offset;
         }

         if(-1.0 != playoff)
         {
            float t = playoff;
            UIRenderer.EnableBlending();
            // trace "xxx sampleview::ondrawoverlays: playoff="+playoff+" last_play_offset="+last_play_offset;
            if(last_play_offset > playoff)
            {
               // Playing backwards
               playoff = last_play_offset;
               last_play_offset = t;
            }
            if( (-1 != last_play_offset) && (-1 != playoff))
            {
               // // if( (playoff - last_play_offset) < 4096 )  // <-- breaks playoff display when sample is transposed up 1/2 octaves
               {
                  if(playoff != last_play_offset)
                  {
                     drawArea(color_playoff_bg, color_playoff, last_play_offset, playoff, sampleOff, numVisFrames, CHANNEL_MASK_LR);
                  }
               }
            }
            UI.CompositeAll(); // redraw as soon as possible
            last_play_offset = t;
         }

         // Enable alpha writes
         sdvg_AlphaWrite(true);
      }
   }

   public =replay= method checkDrawReplayOffset() : boolean {
      float playoff;

      if(null != waveform)
      {
         playoff = waveform.uiGetLastPlayedOffset();
      }
      else
      {
         playoff = play_offset;
      }

      // trace "xxx checkDrawReplayOffset: playoff="+playoff+" last_play_offset="+last_play_offset;

      if(last_play_offset != playoff)
      {
         UI.CompositeAll();
         ////trace "xxx checkDrawReplayOffset: start drawing @playoff="+playoff;
         return true;
      }
      return false;
   }

   public virtual onOpen() {
      // trace "[dbg] SampleView::onOpen";
      if(null == tex_gradient)
      {
         tex_gradient <= new Texture;
         // tex_gradient.alloc(256, 256, 4);
         tex_gradient.alloc(128, 64, 4);
         tex_gradient.flags = TEX_MODULATE | TEX_ALPHA | TEX_CLAMPTOEDGE_S | TEX_CLAMPTOEDGE_T | TEX_MINFILTERLINEAR | TEX_MAGFILTERLINEAR;
         float y = 0.0f;
         float yStep = (1.0 / tex_gradient.sy);
         float xStep = (1.0 / tex_gradient.sx);
         int i = 0;
         loop(tex_gradient.sy)
         {
            float x = 0.0f;
            float l;
            loop(tex_gradient.sx)
            {
               // // // l = mathPowerf(x, 1.4) * 192;
               // l = mathPowerf(x, 1.4 + (y*y * 4.1)) * 192;
               l = mathPowerf(x, 0.8 + (y*y * 4.7)) * 160;
               tex_gradient[i++] = argb(l, l, l, l);
               x += xStep;
            }
            l = 128;
            tex_gradient[i-1] = argb(l, l, l, l);

            y += yStep;
         }
      }

      tex_gradient.unload();
      // // tex_gradient.upload();
   }

   public virtual onDraw() {

      // glFinish();//xxxxxxxxxxxxxxxxx
      // // sdvg_DebugSetEnableWriteVBO(false);
      // int tStart = milliSeconds();

      // trace "xxx sampleView::onDraw: size_y="+size_y+" min_size_y="+minimum_size_y+" pref_size_y="+preferred_size_y+" force="+b_force_size_y+" wf="+#(waveform)+" samples="+#(samples);

      // // UIRenderer.DrawFilledRectangle(0, 0, size_x, size_y, lnf_colors.get(LookAndFeel.COLOR_CUSTOM_EDITOR_BG_LIGHT));
      UIRenderer.DrawFilledRectangle(0, 0, size_x, size_y, color_bg);
      // // UIRenderer.DrawFilledRectangle(0, 0, size_x, size_y, #ffff0000);

      // Disable alpha writes
      sdvg_AlphaWrite(false);

      UIRenderer.SetLineWidth(1.0f);
      // // glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
      // // glEnable(GL_LINE_SMOOTH);

      UIRenderer.SetPointSize(1.0f);
      // // glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
      // // glEnable(GL_POINT_SMOOTH);

      UIRenderer.EnableBlendingAdditiveKeepAlpha();
      // UIRenderer.EnableBlending();

      // Draw samples
      float sampleSizeX = size_x;// - 4;
      float sampleSizeY = calcSampleSizeY() - 4;
      if(null != samples)
      {
         int numFrames = (samples.numElements / num_channels);
         if(numFrames > 0)
         {
            int numVisFrames = (numFrames * zoom) + 0.5;
            ////trace "xxx SampleView:: zoom="+zoom+" numVisFrames = " + numVisFrames;
            int sampleOff = (numFrames - numVisFrames) * 0.5;// + 0.5;
            int invisFrame = numFrames - (sampleOff + numVisFrames);
            sampleOff += int((invisFrame * offset)+0.5);
            if(sampleOff < 0)
               sampleOff = 0;
            else if(sampleOff >= (numFrames - numVisFrames))
               sampleOff = numFrames - numVisFrames;

            ////trace "xxx numVisFrames="+numVisFrames+" sampleOff="+sampleOff+" numFrames="+numFrames;

            Point2f abspos;
            calcAbsolutePositionFBO(abspos);

            // // UI.PushScissors(abspos.x, abspos.y, size_x+0.5, size_y+0.5);
            sdvg_PushScissor(abspos.x, abspos.y, size_x+0.5, size_y+0.5);
            glEnable(GL_SCISSOR_TEST);

            if(null != waveform)
               sampleOff += waveform.ringOffset;

            float minSample = min_sample * zoom_y;
            float maxSample = max_sample * zoom_y;

            if(b_render_regions)
            {
               // Draw markers
               if(!autochop_start_offsets.isEmpty())
               {
                  float regionYT = MARKER_PY * UI.icon_scaling;
                  float regionYB = size_y - (UI.IsHiDPI()?24:14);
                  int regionStartOff;
                  float regionSclX = sampleSizeX / numVisFrames;
                  float regionX;
                  if(UI.IsMacOS())
                  {
                     // stippled lines are severely broken on macOS
                     //   - disappears/fades out at x > ~100
                     //   - line width 1 is rendered as line width 2
                     UIRenderer.SetColorARGB( (color_regions & 0xFFFFFF) | ((((color_regions>>24)&255)>>1)<<24) );
                     if(UIRenderer.BeginFilledTriangles(autochop_start_offsets.numElements * 2 * 3))
                     {
                        foreach regionStartOff in autochop_start_offsets
                        {
                           regionX = ((regionStartOff - sampleOff) * sampleSizeX)/numVisFrames;
                           regionX = int(regionX);
                           // 1
                           UIRenderer.Vertex2f(regionX,   regionYT + 4*UI.icon_scaling);
                           UIRenderer.Vertex2f(regionX+1, regionYT + 4*UI.icon_scaling);
                           UIRenderer.Vertex2f(regionX+1, regionYB);
                           // 2
                           UIRenderer.Vertex2f(regionX,   regionYT + 4*UI.icon_scaling);
                           UIRenderer.Vertex2f(regionX+1, regionYB);
                           UIRenderer.Vertex2f(regionX,   regionYB);
                        }
                        UIRenderer.End();
                     }
                  }
                  else
                  {
                     UIRenderer.SetColorARGB(color_regions);
                     // // glLineStipple(1, 0b1000100010001000);
                     // // glEnable(GL_LINE_STIPPLE);
                     if(UIRenderer.BeginLines(autochop_start_offsets.numElements * 2))
                     {
                        foreach regionStartOff in autochop_start_offsets
                        {
                           regionX = ((regionStartOff - sampleOff) * sampleSizeX)/numVisFrames;
                           regionX = int(regionX);
                           UIRenderer.Vertex2f(regionX, regionYT + 4*UI.icon_scaling);
                           UIRenderer.Vertex2f(regionX, regionYB);
                        }
                        UIRenderer.End();
                     }
                  }
                  // // glDisable(GL_LINE_STIPPLE);
                  // // glLineStipple(1, 0xffff);

                  // draw handles
                  UIRenderer.SetColorARGB(color_regions_handle);
                  if(UIRenderer.BeginFilledTriangles(autochop_start_offsets.numElements * 2 * 3))
                  {
                     foreach regionStartOff in autochop_start_offsets
                     {
                        regionX = ((regionStartOff - sampleOff) * sampleSizeX)/numVisFrames;
                        regionX = int(regionX) + 1;
                        // 1
                        UIRenderer.Vertex2f(regionX-4*UI.icon_scaling, regionYT);
                        UIRenderer.Vertex2f(regionX+4*UI.icon_scaling, regionYT);
                        UIRenderer.Vertex2f(regionX,                   regionYT+MARKER_SY*UI.icon_scaling);
                        // 2
                        UIRenderer.Vertex2f(regionX-4*UI.icon_scaling, regionYT);
                        UIRenderer.Vertex2f(regionX,                   regionYT+MARKER_SY*UI.icon_scaling);
                        UIRenderer.Vertex2f(regionX,                   regionYT+MARKER_SY*UI.icon_scaling);
                     }
                     UIRenderer.End();
                  }
               }
            }

            if(b_render_samples)
            {
               int c32;

               if(b_freedraw)
               {
                  if(b_drawing)
                     c32 = color_samples_drawing;
                  else
                     c32 = color_samples_freedraw;
               }
               else
                  c32 = color_samples;

               UIRenderer.SetColorARGB(c32);

               int rsInner = render_style;
               int rsGradient2 = render_style;
               int c32Skip = color_samples_lines_skip;

               float fFadeLines = float(numVisFrames) / (28*sampleSizeX);
               if(fFadeLines > 1.0f) fFadeLines = 1.0f;
               fFadeLines = 1.0f - fFadeLines;
               fFadeLines *= fFadeLines;
               fFadeLines = 1.0f - fFadeLines;
               float fFade = float(numVisFrames) / (4*sampleSizeX);
               if(fFade > 1.0f) fFade = 1.0f;
               fFade = 1.0f - fFade;
               fFade *= fFade;
               fFade = 1.0f - fFade;
               // trace "xxx fFade="+fFade+" fFadeLines="+fFadeLines;

               if(RS_GRADIENT == rsInner || RS_GRADIENT_AND_LINES == rsInner)
               {
                  if(numVisFrames > (sampleSizeX*8))
                  {
                     rsInner = RS_LINES;
                     rsGradient2 = -1;
                     c32Skip = color_samples_lines_fallback;
                     int a = (c32Skip >> 24) & 255;
                     // a = mathLerpf(a, a*0.25, fFadeLines);
                     // a = mathClampi(a, 4, 255);
                     c32Skip = (c32Skip & 0xFFFFFF) | (a << 24);
                     // trace "xxx fallback fFadeLines="+fFadeLines+" a="+a+" => c32Skip="+UI.GetColorString(c32Skip);
                     // c32 = c32Skip; // ?
                  }
                  else
                  {
                     tex_gradient.bind();
                     tex_gradient.enable();
                     rsInner = RS_GRADIENT;
                     c32Skip = c32;
                  }
               }

               // // if(RS_GRADIENT != rsInner) // xxxxxxx
               {
                  UIRenderer.SetColorARGB(c32Skip);
                  // trace "xxx c32Skip="+UI.GetColorString(c32Skip);
                  tksampleedit_render_sample(samples,
                                             num_channels, sampleOff, numVisFrames,
                                             sampleSizeX, sampleSizeY,
                                             minSample, maxSample,
                                             rsInner, interpol_style,
                                             c32Skip/*c32Skip*/,
                                             c32/*c32Rep*/
                                             );

                  if(UIRenderer.b_sdvg_return_to_gl)
                     sdvg_ReturnToGL();
               }

               if(RS_GRADIENT == rsInner || RS_GRADIENT_AND_LINES == rsInner)
               {
                  tex_gradient.disable();
                  tex_gradient.unbind();
               }

               // trace "xxx rsInner="+rsInner;

               if(RS_GRADIENT_AND_LINES == rsGradient2)
               {
                  UIRenderer.SetColorARGB(c32);
                  // // c32Skip = (numVisFrames > (14*sampleSizeX)) ? color_samples_lines_outer_skip : color_samples;
                  c32Skip = UI.MixColor32(color_samples_lines_outer, color_samples_lines_outer_skip, fFadeLines);
                  UIRenderer.SetColorARGB(c32Skip);
                  tksampleedit_render_sample(samples,
                                             num_channels, sampleOff, numVisFrames,
                                             sampleSizeX, sampleSizeY,
                                             minSample, maxSample,
                                             RS_LINES_OUTER, interpol_style,
                                             c32Skip/*c32Skip*/,
                                             c32Skip/*c32Rep*/
                                             );
                  if(UIRenderer.b_sdvg_return_to_gl)
                     sdvg_ReturnToGL();

                  // trace "xxx fFade="+fFade+" fFadeLines="+fFadeLines;
                  c32Skip = UI.MixColor32(color_samples, color_samples_lines_outer_skip, fFade);
                  c32Skip = UI.MixColor32(0, c32Skip, fFadeLines);
                  if(2000 <= numVisFrames <= 60000)
                  {
                     float fSharpen = (numVisFrames - 2000) / (60000.0 - 2000);
                     fSharpen = sin(fSharpen*PI);
                     // // fSharpen = 1.0 - fSharpen;
                     // // fSharpen *= fSharpen;
                     // // fSharpen = 1.0 - fSharpen;
                     // trace "xxx fSharpen="+fSharpen;
                     fSharpen = mathSmoothStepf(0.0f, 1.0f, fSharpen);
                     c32Skip = UI.MixColor32(c32Skip, color_gradient_sharpen, fSharpen);
                  }

                  UIRenderer.SetColorARGB(c32Skip);
                  // glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
                  tksampleedit_render_sample(samples,
                                             num_channels, sampleOff, numVisFrames,
                                             sampleSizeX, sampleSizeY,
                                             minSample, maxSample,
                                             RS_LINES, interpol_style,
                                             c32Skip/*c32Skip*/,
                                             c32Skip/*c32Rep*/
                                             );
                  if(UIRenderer.b_sdvg_return_to_gl)
                     sdvg_ReturnToGL();
                  // glBlendFunc(GL_SRC_ALPHA, GL_ONE);
               }
            }

            if(b_render_rms)
            {
               if(b_freedraw && b_drawing)
                  c32 = color_rms_drawing;
               else
               {
                  float fFadeRMS;
                  fFadeRMS = float(numVisFrames) / (64*sampleSizeX);
                  if(fFadeRMS > 1.0)
                     fFadeRMS = 1.0;
                  c32 = UI.MixColor32(color_rms, color_rms_zoom_out, fFadeRMS);

                  fFadeRMS = float(numVisFrames) / (6*sampleSizeX);
                  if(fFadeRMS > 1.0)
                     fFadeRMS = 1.0;
                  fFadeRMS *= fFadeRMS;
                  // trace "xxx fFadeRMS="+fFadeRMS;
                  c32 = UI.MixColor32(color_rms_zoom, c32, fFadeRMS);
                  fFadeRMS = float(numVisFrames) / (2*sampleSizeX);
                  if(fFadeRMS > 1.0)
                     fFadeRMS = 1.0;
                  c32 = UI.MixColor32(color_rms_zoom_in, c32, fFadeRMS);
               }
               UIRenderer.SetColorARGB(c32);
               tksampleedit_render_rms(samples, num_channels, sampleOff, numVisFrames,
                                       sampleSizeX, sampleSizeY,
                                       minSample, maxSample
                                       );
               if(UIRenderer.b_sdvg_return_to_gl)
                  sdvg_ReturnToGL();
            }

            // // UI.PopScissors();
            sdvg_PopScissor();
            glDisable(GL_SCISSOR_TEST);
         }
      }

      if(b_draw_bevel_border)
         UIRenderer.DrawDefaultSunkenBorder(0,0,size_x,size_y);

      // Draw centerline
      int ch;
      float ssy = sampleSizeY / num_channels;
      float cy = 0;//2;
      UIRenderer.SetColorARGB(color_centerline);
      if(UIRenderer.BeginLines(num_channels * 2))
      {
         loop(num_channels)
         {
            UIRenderer.Vertex2f(2,             cy + ssy*0.5f);
            UIRenderer.Vertex2f(2+sampleSizeX, cy + ssy*0.5f);

            cy += ssy;
            ch++;
         }
         UIRenderer.End();
      }

      // Draw samples border
      float smpSy = calcSampleSizeY();

      if(b_draw_bevel_border)
         UIRenderer.DrawDefaultSunkenBorder(0,0,size_x, smpSy);

      // // glDisable(GL_LINE_SMOOTH);

      if(zoom < 1.0)
      {
         // Draw scrollbar shade
         UIRenderer.DrawFilledRectangle(2, smpSy, size_x-4, SCROLLBAR_HEIGHT, color_slider_bg);

         if(b_draw_bevel_border)
            UIRenderer.DrawDefaultSunkenBorder(2*0, smpSy, size_x-4*0, SCROLLBAR_HEIGHT);

         // Draw scrollbar knob
         float knobWidth = int(0.5 + zoom * (size_x-4*1));
         if(knobWidth < 4) knobWidth = 4;
         float knobX = int( ((size_x-4*1-knobWidth)*0.5) + ((size_x-4*1-knobWidth)*0.5) * offset );
         UIRenderer.DrawFilledRectangle(2*1+knobX, smpSy+2, knobWidth, SCROLLBAR_HEIGHT-4, color_slider_knob);
         if(b_draw_bevel_border)
            UIRenderer.DrawDefaultRaisedBorder(2*1+knobX, smpSy+2, knobWidth, SCROLLBAR_HEIGHT-4);
      }

      UIRenderer.DisableBlending();

      // Enable alpha writes
      sdvg_AlphaWrite(true);

      if(b_draw_tabfocus_border && hasKeyboardFocus())
      {
         UIRenderer.DrawTabFocusTextBorder(1, 1, size_x-2, smpSy-2);
      }

      // glFinish();//xxxxxxxxxxxxxxxxx
      // int tDelta = milliSeconds() - tStart;
      // trace "xxx SampleView::onDraw: tDelta="+tDelta;
      // sdvg_DebugSetEnableWriteVBO(true);

   }

   public method startPlayTimer() {
      // should be called if a note-on occurs

      ////trace "xxx SampleView::startPlayTimer";
      UI.CancelSchedule(playTimerAction);
      playTimerAction.setTicks(20);
      UI.Schedule(playTimerAction);
      last_play_offset = 0;
   }

   protected method invalidatePlayOffsets() {
      play_offset = -1;
      last_play_offset = -1;
   }

   protected method scheduleAutoscrollTimer() {
      ////trace "xxx scheduleAutoscrollTimer: is_scheduled="+b_autoscroll_timer_scheduled;
      if(!b_autoscroll_timer_scheduled)
      {
         autoscrollTimerAction.setActionConsumer(this);
         autoscrollTimerAction.setActionProvider(this);
         UI.CancelSchedule(autoscrollTimerAction);
         autoscrollTimerAction.setActionName(TA_MOUSE_AUTOSCROLL);
         autoscrollTimerAction.setTicks(1000/30); // scroll 30 rows per sec. max
         UI.Schedule(autoscrollTimerAction);
         b_autoscroll_timer_scheduled = true;
      }
   }

   protected method cancelAutoscrollTimer() {
      if(b_autoscroll_timer_scheduled)
      {
         UI.CancelSchedule(autoscrollTimerAction);
         b_autoscroll_timer_scheduled = false;
      }
   }

   protected method startKeyScroll(int _dir) {
      key_scroll_dir = _dir;
      ta_key_scroll.schedule();
   }

   protected method stopKeyScroll(int _dir) {
      if(key_scroll_dir == _dir)
      {
         ta_key_scroll.cancel();
         key_scroll_dir = 0;
      }
   }

   protected method handleKeyScroll() {
      scrollOffset2(key_scroll_dir * 4, 1.0f);
   }

   protected method handleContextMenuAction(String acName) : boolean {
      UI.SetKeyboardFocus(this);
      context_menu.hide();

      switch(acName)
      {
         case "fitseltowindow":
            fitSelectionToWindow();
            return true;

         case "tools_truncate":
            truncateSelection();
            return true;

         case "tools_autotrim":
            autotrim();
            return true;

         case "tools_reverse":
            reverseSelection();
            return true;

         case "tools_crossfade":
            crossfadeSelection();
            return true;

         case "tools_loopcrossfade":
            loopCrossfadeSelection1(true/*bNearMouse*/);
            return true;

         case "tools_phaseinvert":
            phaseInvertSelection();
            return true;

         case "tools_silence":
            silenceSelection(true/*bUndoBegin*/);
            return true;

         case "tools_surroundsilence":
            surroundSelectionWithSilence(true/*bUndoBegin*/);
            return true;

         case "tools_normalize":
            normalizeSelection(true/*bUndoBegin*/);
            return true;

         case "tools_normalize_regions":
            normalizeRegions(256/*fadeNumFrames*/);
            return true;

         case "tools_amp":
            amplifySelection1(true/*bNearMouse*/);
            return true;

         case "tools_sox":
            showSoXDialog(false/*bNearMouse*/);
            return true;

         case "tools_fadein":
            fadeInSelection(true/*bUndoBegin*/);
            return true;

         case "tools_fadeout":
            fadeOutSelection(true/*bUndoBegin*/);
            return true;

         case "tools_declick_end":
            declickSelectionEnd();
            return true;

         case "tools_declick_start":
            declickSelectionStart();
            return true;

         case "tools_add":
            addClipboardToSelection();
            return true;

         case "channels_tomono":
            convertToMono();
            return true;

         case "channels_tostereo":
            convertToStereo(false/*bForceAndDontStartUndo*/);
            return true;

         case "channels_deleteleft":
            deleteChannel(CHANNEL_MASK_L);
            return true;

         case "channels_deleteright":
            deleteChannel(CHANNEL_MASK_R);
            return true;

         case "showall":
            showAll();
            return true;

         case "selectall":
            selectAll(true/*bAction*/);
            return true;

         case "selectnone":
            selectNone();
            return true;

         case "undo":
            undo();
            return true;

         case "redo":
            redo();
            return true;

         case "undo_clear":
            undoClear();
            return true;

         case "copyseltohl":
            copySelectionToHighlight(true);
            return true;

         case "tightensel":
            tightenSelection(VMOD_LSHIFT == UI.GetKeyMod());
            return true;

         case "copyseltoclipboard":
            copySelection();
            return true;

         case "appendseltoclipboard":
            appendSelectionToClipboardBorderSilence();
            return true;

         case "cutseltoclipboard":
            cutSelection();
            return true;

         case "pasteclipboard_start":
            pasteSelection(true/*bUndoBegin*/);
            return true;

         case "pasteclipboard_end":
            pasteSelectionAtEnd(true/*bUndoBegin*/);
            return true;

         case "pasteclipboard_replace":
            replaceSelectionByClipboard(true/*bUndoBegin*/);
            return true;

         case "exportselection":
            handleExportSelection();
            return true;

         case "multiexportregions":
            handleMultiExportRegions();
            return true;

         case "toggleshowsamples":
            toggleShowSamples();
            return true;

         case "toggleshowrms":
            toggleShowRMS();
            return true;

         case "toggleshowhighlight":
            toggleShowHighlight();
            return true;

         case "toggleshowregions":
            toggleShowRegions();
            return true;

         case "togglefreedraw":
            setFreedrawMode(!b_freedraw);
            return true;

         case "togglecyclemode":
            toggleCycleMode(null/*evOrNull*/);
            return true;

         case "toggleautochoprms":
            toggleAutochopRMS();
            return true;

         case "togglezeroxmode":
            toggleZeroCrossingMode();
            return true;

         case "togglebpmsnap":
            setEnableBPMSnap(!b_bpm_snap, false/*bQuiet*/);
            if(b_bpm_snap)
               setEnableMarkerSnap(false, true/*bQuiet*/);
            return true;

         case "togglemarkersnap":
            setEnableMarkerSnap(!b_marker_snap, false/*bQuiet*/);
            if(b_marker_snap)
               setEnableBPMSnap(false, true/*bQuiet*/);
            return true;

         case "render_dots":
            setRenderStyle(RS_DOTS);
            redraw();
            return true;

         case "render_lines":
            setRenderStyle(RS_LINES);
            redraw();
            return true;

         case "render_delta":
            setRenderStyle(RS_DELTA);
            redraw();
            return true;

         case "render_gradient":
            setRenderStyle(RS_GRADIENT);
            redraw();
            return true;

         case "render_gradient_and_lines":
            setRenderStyle(RS_GRADIENT_AND_LINES);
            redraw();
            return true;

         case "interpol_sh":
            setInterpolation(IS_SH);
            redraw();
            return true;

         case "interpol_linear":
            setInterpolation(IS_LINEAR);
            redraw();
            return true;

         case "interpol_smoothstep":
            setInterpolation(IS_SMOOTHSTEP);
            redraw();
            return true;
      }

      return false;
   }

   protected method handleAreaFloatParamAction(FloatAction acFloat, String acName) {
      boolean bRefocus = false;

      switch(acName)
      {
         case FloatParamEditor.ACTION_VALUECHANGED:
            bRefocus = true;
         case FloatParamEditor.ACTION_VALUECHANGING:
         {
            int i = acFloat.getFloatValue();
            int t;
            switch(fp_area_mode)
            {
               case FPAREAMODE_SELLEN:
                  setSelection(sel_startoff, sel_startoff+i);
                  handleSelectionChanged();
                  break;

               case FPAREAMODE_SELEND:
                  if(i > sel_startoff)
                  {
                     setSelection(sel_startoff, i);
                     handleSelectionChanged();
                  }
                  break;

               case FPAREAMODE_SELSTART:
                  setSelection(i, i + (sel_endoff - sel_startoff));
                  handleSelectionChanged();
                  break;

               case FPAREAMODE_HLLEN:
                  setHighlight(hl_startoff, hl_startoff+i);
                  handleHighlightChanged();
                  break;

               case FPAREAMODE_HLEND:
                  if(i > hl_startoff)
                  {
                     setHighlight(hl_startoff, i);
                     handleHighlightChanged();
                  }
                  break;

               case FPAREAMODE_HLSTART:
                  setHighlight(i, i + (hl_endoff - hl_startoff));
                  handleHighlightChanged();
                  break;
            }
         }

         if(bRefocus)
         {
            UI.SetKeyboardFocus(this);
         }
         return true;
      }

      return false;
   }

   // <ui_handle.png>
   public virtual onDropFiles(StringArray _fileNames) : boolean {
      if(_fileNames.numElements > 0)
      {
         Point2f p;
         calcDropFilesPosition(p);
         Global.Debug("SampleView::onDropFiles: p="+p.getString());
         ondropfiles_frame_off = calcSampleOffsetAtMouseX(p.x);
         Global.Debug("SampleView::onDropFiles: frameOff="+ondropfiles_frame_off);
         return provideAction(ObjectAction.New(getProvidedActionAlias(ACTION_DROP_FILES), this, _fileNames));
      }
   }

   // <method.png>
   public virtual onDropObject(Object _o, MouseEvent _ev) : boolean {
      if(_o instanceof StringArray)
      {
         return onDropFiles(_o);
      }
      return false;
   }

   // <method_get.png>
   public virtual canDropObject(Object _dragObject, MouseEvent _ev) : boolean {
      return (_dragObject instanceof StringArray);
   }

   // <method_get.png>
   public method getDropFilesFrameOff() : int {
      return ondropfiles_frame_off;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _ac) : boolean {

      ActionProvider ap <= _ac.getActionProvider();
      String acName = _ac.getActionName();
      boolean bRefocus = false;
      FloatAction *fac;

      switch(acName)
      {
         case TA_PLAY_MARKER:
            // trace "xxx SampleView::consumeAction: playTimer expired";
            if(!checkDrawReplayOffset())
            {
               startPlayTimer();
            }
            return true;

         case TA_MOUSE_AUTOSCROLL:
            b_autoscroll_timer_scheduled = false;
            float dx = autoscroll_ev.mouse_rel_x - last_rel_x;
            if(false == ((dx > 0) ^ (autoscroll_dir > 0)))
            {
               if(-1 == autoscroll_dir)
               {
                  scrollOffset(autoscroll_ev, -0.25);
               }
               else
               {
                  scrollOffset(autoscroll_ev, -0.25);
               }
            }
            onMouse(autoscroll_ev); // also schedules next timer event
            return true;

         case TA_KEY_SCROLL:
            handleKeyScroll();
            ta_key_scroll.schedule();
            return true;
      }

      switch(@(ap))
      {
         case @(context_menu):
            handleContextMenuAction(acName);
            return true;

         case @(fp_area):
            handleAreaFloatParamAction(_ac, acName);
            return true;

         case @(dlg_num_frames):
            if(TextInputDialog.ACTION_TEXTINPUTDIALOGCLOSED == acName)
            {
               StringAction sac <= _ac;
               loopCrossfadeSelection2(int(sac.getStringValue()));
            }
            return true;

         case @(dlg_scale):
            if(FloatParamDialog.ACTION_FLOATPARAMDIALOGCLOSED == acName)
            {
               fac <= _ac;
               amplifySelection2(fac.getFloatValue());
            }
            return true;
      }
      return true;
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) returns boolean {
      if(Control::beginXFMTag(_form, _attributes))
      {
         return true;
      }
      return false;
   }

   public virtual endXFMTag(AbstractXMLForm _form, HashTable _attributes) {
      initSampleView();
   }

}
