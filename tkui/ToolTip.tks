// ----
// ---- file   : ToolTip.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- license: (c) 2007-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 05May2007
// ---- changed: 09May2007, 22Apr2010, 04Jun2010, 29Mar2011, 09Jan2012, 13Apr2017, 16Feb2018
// ----          28Oct2023, 02Nov2023, 17Mar2024, 11Apr2024
// ----
// ----
// ----

module MToolTip;

namespace ui;


class ToolTip extends FloatingLayer {
   public static ToolTip *active_tooltip;

   protected Label *label;
   protected Layer *trigger_layer;

   public static New(Layer _trigger, String _toolTipCaption, Font _toolTipFontOverride) {
      if(null != _toolTipCaption)
      {
         if(!_toolTipCaption.isBlank())
         {
            local ToolTip t;
            t.initToolTip(_trigger, _toolTipCaption, _toolTipFontOverride);
            return deref t;
         }
      }
      return null;
   }

   public method initToolTip(Layer _trigger, String _toolTipCaption, Font _toolTipFontOverride) {

      initLayer();

      // trace "xxx ToolTip::initToolTip caption=\""+_toolTipCaption+"\" fontOverride="+#(_toolTipFontOverride);

      trigger_layer <= _trigger;

      setLayout(SuperBorderLayout);

      label <= Label.New();
      label.setCaption(_toolTipCaption);
      label.setForegroundColor(lnf_colors.get(LookAndFeel.COLOR_TOOLTIP_CAPTION));
      label.setBackgroundColor(lnf_colors.get(LookAndFeel.COLOR_TOOLTIP_BG));
      float bw = lnf.tooltip_border_width * UI.window_border_scaling;
      label.setPadding4fUnscaled(bw, bw, bw, bw);
      label.setTextPlacement(Layout.LEFT|Layout.CENTERY);
      // label.setPadding4f(0,0,0,0);
      if(null != _toolTipFontOverride)
         label.setFont(_toolTipFontOverride);
      addLayer(label, Layout.CENTER);

      float w, h;
      w = label.getPreferredSizePadX();// // + (UIConstants.WINDOW_BORDER_SIZE_X * UI.window_border_scaling * 2);
      h = label.getPreferredSizePadY();// // + (UIConstants.WINDOW_BORDER_SIZE_Y * UI.window_border_scaling * 2);
      setGeometry(0, 0, w, h);
      invalidateAbsolutePositions();
      layoutHierarchy(true, false);
   }

   public virtual onLookAndFeelChanged() {
      // trace "xxx ToolTip::onLookAndFeelChanged: label="+#(label);
      if(null != label)
      {
         label.setForegroundColor(lnf_colors.get(LookAndFeel.COLOR_TOOLTIP_CAPTION));
         label.setBackgroundColor(lnf_colors.get(LookAndFeel.COLOR_TOOLTIP_BG));
      }
   }

   public method onToolTipKey(Key _k) : boolean {
      explain "Called if a (global) key event is received (even if the keyboard focus is set to a different layer). Can be used to hide the tooltip as soon as the user begins typing. Returns true if the key event has been consumed by the tooltip and should not be sent to the current keyboard layer.";

      if(trigger_layer != null)
      {
         // Allow the trigger_layer to delete the tooltip instance
         trigger_layer.hideToolTip();
         // Note: Do not add code below this line because the tooltip instance should have been deleted by now
      }
      else
      {
         // Oops?
         hide();
      }
      //return true; // Make the first keystroke hide the tooltip
      return false; // Allow typing instantly
   }

   protected virtual makeFloatingLayerVisible() {
      explain "Make tooltip visible. Overwrites FloatingLayer::makeFloatingLayerVisible().";

      UI.AddFloatingLayer(this);
      // Note: do not set mouse/keyboard focus!! (this is what the default makeFloatingLayerVisible() implementation does!)

      b_floating_layer_visible = true;
      active_tooltip <= this;

      postShow();
   }

   public virtual hide() {
      FloatingLayer::hide();
      active_tooltip <= null;
   }

   public virtual onDraw() {
      // // UIRenderer.DrawRectangle(0, 0, getSizeX(), getSizeY(), 1*UI.font_scaling, lnf_colors.get(LookAndFeel.COLOR_TOOLTIP_BORDER));
      // // UIRenderer.DrawRectangle(0, 0, getSizeX(), getSizeY(), 1*UI.font_scaling, #ffff0000);
      // // UIRenderer.DrawRectangle(0, 0, getSizeX(), getSizeY(), 1* UI.window_border_scaling, #ffff0000);
      if(lnf.tooltip_border_width > 0.0f)
         UIRenderer.DrawRectangle(0, 0, getSizeX(), getSizeY(), lnf.tooltip_border_width * UI.window_border_scaling, lnf_colors.get(LookAndFeel.COLOR_TOOLTIP_BORDER));
   }

}
