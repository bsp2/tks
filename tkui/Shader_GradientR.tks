// ----
// ---- file   : Shader_GradientR.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- created: 23Mar2024
// ---- changed: 28Mar2024, 07Apr2024, 13Sep2025
// ----
// ----
// ----

module MShader_GradientR;

namespace ui;


class Shader_GradientR : Shader {
   protected Texture *tex;

   // Inputs:
   //   tex[0] : Texture (GL_TEXTURE_2D)

   static String vs_src =
      "uniform mat4 u_transform; \n"
      " \n"
      "ATTRIBUTE vec2 a_vertex; \n"
      " \n"
      "void main(void) { \n"
      "  gl_Position = u_transform * vec4(a_vertex,0,1); \n"
      "}"
      ;

   static String fs_src =
      "uniform sampler2D u_tex; \n"
      "uniform vec4      u_color_fill; \n"
      "uniform float     u_abs_x; \n"
      "uniform float     u_abs_y; \n"
      "uniform float     u_abs_rx; \n"  // 0.5f / (r - l)
      "uniform float     u_abs_ry; \n"  // 0.5f / (t - b)
      "\n"
      "void main(void) { \n"
      "  float dx =  (gl_FragCoord.x - u_abs_x) * u_abs_rx; \n"
      "  float dy = -(gl_FragCoord.y - u_abs_y) * u_abs_ry; \n"
      "  float d = length(vec2(dx,dy)); \n"
      "  float u = d*0.5 + 0.5; \n"
      "  vec4  c = TEXTURE2D(u_tex, vec2(u, 0)); \n"
      "  c = vec4(mix(u_color_fill.rgb, c.rgb, c.a), u_color_fill.a); \n"
      "  FRAGCOLOR = c; \n"
      "}"
      ;

   public virtual create() : boolean {
      if(createFromStrings(vs_src, fs_src))
      {
         sdvg_BindShader(sdvg_shader_idx);
         sdvg_Uniform1i("u_tex", 0);
         sdvg_BindShader(0);
         if(Configuration.debugLevel >= 2)
            trace "[dbg] ui::Shader_GradientR::create: OK.";
         return true;
      }
      else
      {
         trace "[!!!] ui::Shader_GradientR::create: failed";
      }
      return false;
   }

   public method bindGradientR(Texture _tex, float _absCtrX, float _absCtrY, float _absRx, float _absRy) {
      // (note) gl_FragCoord window origin 0;0 is bottom/left
      tex <= _tex;
      tex.bind();
      tex.enable();
      Shader::bind();
      sdvg_Uniform1f("u_abs_x",  _absCtrX);
      sdvg_Uniform1f("u_abs_y",  _absCtrY);
      sdvg_Uniform1f("u_abs_rx", (1/1.4f) / _absRx);
      sdvg_Uniform1f("u_abs_ry", (1/1.4f) / _absRy);
      // trace "xxx Shader_GradientR: texSz=("+tex.sx+";"+tex.sy+") UI.buffer=("+UI.buffer_width+";"+UI.buffer_height+") ctr=("+_absCtrX+";"+_absCtrY+") r=("+_absRx+";"+_absRy+")";
   }

   public virtual unbind() {
      Shader::unbind();
      if(null != tex)
      {
         tex.disable();
         tex.unbind();
      }
   }

   public virtual onOpen() {
      Shader::onOpen();
      if(null != tex)
         tex.unload();
   }

}
