// ----
// ---- file   : graph.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- created: 27Feb2024
// ---- changed: 28Feb2024, 29Feb2024, 01Mar2024, 02Mar2024, 03Mar2024, 04Mar2024, 05Mar2024
// ----          06Mar2024, 10Mar2024, 11Mar2024, 12Mar2024, 13Mar2024, 14Mar2024, 15Mar2024
// ----          16Mar2024, 17Mar2024, 18Mar2024, 19Mar2024, 20Mar2024, 21Mar2024, 22Mar2024
// ----          23Mar2024, 24Mar2024, 25Mar2024, 26Mar2024, 27Mar2024, 28Mar2024, 29Mar2024
// ----          02Apr2024, 03Apr2024, 04Apr2024, 06Apr2024, 01Feb2025, 02Feb2025, 18Feb2025
// ----          19Feb2025, 21Feb2025, 22Feb2025, 23Feb2025, 10Sep2025
// ----
// ----
// ----

module MGraph;

boolean b_gr_debug  = 1;
boolean b_gr_debug2 = 1;
boolean b_gr_debug3 = 1;  // move / constraint
boolean b_gr_debug4 = 0;  // collapse

boolean b_gr_parse_debug  = 1;
boolean b_gr_parse_debug2 = 1;
boolean b_gr_parse_debug3 = 1;

namespace graph;
use namespace ui;


function SetDebugLevel(int _level) {
   b_gr_debug  = (_level > 0);
   b_gr_debug2 = (_level > 1);
   b_gr_debug3 = (_level > 2);
   b_gr_debug4 = (_level > 3);
   
   b_gr_parse_debug  = (_level > 0);
   b_gr_parse_debug2 = (_level > 1);
   b_gr_parse_debug3 = (_level > 2);
}


// <class.png>
class GRUtils {

   public static ParseAmountString(String _sVal) : float {
      if(_sVal & "%")
         return float(_sVal.replace("%", "")) / 100.0f;
      return float(_sVal);
   }

   public static GetAttribAmount(HashTable _ht, String _key) : float {
      return ParseAmountString(_ht.get(_key));
   }

}


// <class.png>
class Canvas {
   int w;
   int h;
   IntArray data;

   public method init(int _gridW, int _gridH) {
      w = _gridW;
      h = _gridH;
      data.allocAndFill( (w * 3) * (h * 3), 0);
   }

   public method clear() {
      data.fill(0);
   }

   public method plot(int _gridX, int _gridY, int _subX, int _subY, char _c) {
      // trace "xxx plot("+_gridX+","+_gridY+" "+_subX+","+_subY+" c="+((0 != _c) ? tcchar(_c) : 0);
      data[((_gridY * 3 + _subY) * (w*3)) + ((_gridX * 3 + _subX))] = _c;
   }

   public method debugPrint() {
      int j = 0;
      local String buf;
      buf.append(" ");
      buf.appendRepeat("_", w*3);
      buf.append(" \n");
      loop(h * 3)
      {
         buf.append("|");
         // int x = 0;
         loop(w * 3)
         {
            char c = data.get(j++);
            if(0 != c)
               buf.append(tcchar(c));
            else
               buf.append(" ");
         }
         buf.append("|\n");
      }
      buf.append(" ");
      buf.appendRepeat("-", w*3);
      buf.append(" ");
      buf.append("\n");
      trace buf;
   }
}


// <class.png>
class Cell {
   int x;
   int y;
   Node *node;  // null=empty

   static char c_empty = '.';

   public method init(int _x, int _y) {
      // trace "xxx Cell::init("+_x+","+_y+")";
      x = _x;
      y = _y;
   }

   public method isEmpty() : boolean {
      return (null == node);
   }

   public method moveFrom(Cell _c) {
      node <= _c.node;
      if(null != node)
      {
         node.cell <= this;
         _c.node <= null;
      }
   }

   public method getString() : String {
      return "cell("+x+","+y+" node="+((null != node)?node.id:"<null>")+")";
   }

   public method draw(Canvas _canvas) {
      if(null != node)
      {
         // trace "xxx Cell::draw: node.id="+node.id;
         _canvas.plot(x, y, 0, 0, c_empty);
         _canvas.plot(x, y, 1, 0, c_empty);
         _canvas.plot(x, y, 2, 0, c_empty);

         _canvas.plot(x, y, 0, 1, c_empty);
         _canvas.plot(x, y, 1, 1, node.id.getc(0));
         _canvas.plot(x, y, 2, 1, c_empty);

         _canvas.plot(x, y, 0, 2, c_empty);
         _canvas.plot(x, y, 1, 2, c_empty);
         _canvas.plot(x, y, 2, 2, c_empty);

      }
   }

}


// <class.png>
class BBox {
   int minx;
   int miny;
   int maxx;
   int maxy;

   reset() {
      minx = 9999;
      maxx = 0;
      miny = 9999;
      maxy = 0;
   }

   init(int _minx, int _miny, int _maxx, int _maxy) {
      minx = _minx;
      miny = _miny;
      maxx = _maxx;
      maxy = _maxy;
   }

   getWidth() {
      return (maxx + 1 - minx);
   }

   getHeight() {
      return (maxy + 1 - miny);
   }

   getArea() {
      return getWidth() * getHeight();
   }

   public method isSingleCell() : boolean {
      return (getWidth() <= 1) && (getHeight() <= 1);
   }

   extendToCell(Cell _c) {
      if(_c.x < minx)
         minx = _c.x;
      if(_c.x > maxx)
         maxx = _c.x;

      if(_c.y < miny)
         miny = _c.y;
      if(_c.y > maxy)
         maxy = _c.y;
   }

   getString() {
      return "("+minx+";"+miny+";"+maxx+";"+maxy+")";
   }

   getSizeString() {
      return "("+getWidth()+"x"+getHeight()+")";
   }
}


// <class.png>
class AttribsBase {
   HashTable gr_attribs;

   public method initAttribsBase() {
      gr_attribs.alloc(512);
   }

   protected method setNodeAttribS(String _value) {
      // e.g. test34.gr ('s' overrides 'w' from initial style class)
      local StringArray a <= _value.replaceChar(',',';').splitChar(';');
      gr_attribs["w"] = Object(a.get(0));
      if(a.numElements > 1)
         gr_attribs["h"] = Object(a.get(1));
      else
         gr_attribs["h"] = Object(a.get(0));  // quadratic
   }

   protected method setNodeAttribP(String _value) {
      // e.g. test46b.gr
      local StringArray a <= _value.replaceChar(',',';').splitChar(';');
      gr_attribs["x"] = Object(a.get(0));
      if(a.numElements > 1)
         gr_attribs["y"] = Object(a.get(1));
      else
         gr_attribs["y"] = Object(a.get(0));
   }

   public method moveNode(float _x, float _y) {
      // (note) (x;y) position is unscaled
      //         (must divide by UI.font_scaling when converting from window position)
      gr_attribs["x"] = String(_x);
      gr_attribs["y"] = String(_y);
   }

   protected method setNodeAttribPortS(String _value) {
      // e.g. test46c.gr
      local StringArray a <= _value.replaceChar(',',';').splitChar(';');
      gr_attribs["port_w"] = Object(a.get(0));
      if(a.numElements > 1)
         gr_attribs["port_h"] = Object(a.get(1));
      else
         gr_attribs["port_h"] = Object(a.get(0));  // quadratic
   }

   public method getPortW() : float {
      return float(gr_attribs.get("port_w")) * UI.font_scaling;
   }

   public method getPortH() : float {
      return float(gr_attribs.get("port_h")) * UI.font_scaling;
   }

   public method setGRAttrib(String _key, String _value) {
      if("s" == _key)
         setNodeAttribS(_value);  // expand / split 's' into 'w' and 'h'
      else if("p" == _key)
         setNodeAttribP(_value);  // expand / split 'p' into 'x' and 'y'
      else if("port_s" == _key)
         setNodeAttribPortS(_value);  // expand / split 'port_s' into 'port_w' and 'port_h'
      else if("pad_h" == _key)
      {
         gr_attribs["pad_l"] = Object(_value);
         gr_attribs["pad_r"] = Object(_value);
      }
      else if("pad_v" == _key)
      {
         gr_attribs["pad_t"] = Object(_value);
         gr_attribs["pad_b"] = Object(_value);
      }
      else if("ipad_h" == _key)
      {
         gr_attribs["ipad_l"] = Object(_value);
         gr_attribs["ipad_r"] = Object(_value);
      }
      else if("ipad_v" == _key)
      {
         gr_attribs["ipad_t"] = Object(_value);
         gr_attribs["ipad_b"] = Object(_value);
      }
      else if("blend" == _key)
      {
         gr_attribs["bg_blend"]     = Object(_value);
         gr_attribs["border_blend"] = Object(_value);
      }
      else
         gr_attribs[_key] = Object(_value);
   }

   public method setGRAttribIfNotExistsExcept(local String _key, local String _value, local StringArray _aExcept) {
      if("pad_h" == _key)
      {
         setGRAttribIfNotExistsExcept("pad_l", _value, _aExcept);
         setGRAttribIfNotExistsExcept("pad_r", _value, _aExcept);
      }
      else if("pad_v" == _key)
      {
         setGRAttribIfNotExistsExcept("pad_t", _value, _aExcept);
         setGRAttribIfNotExistsExcept("pad_b", _value, _aExcept);
      }
      else if("ipad_h" == _key)
      {
         setGRAttribIfNotExistsExcept("ipad_l", _value, _aExcept);
         setGRAttribIfNotExistsExcept("ipad_r", _value, _aExcept);
      }
      else if("ipad_v" == _key)
      {
         setGRAttribIfNotExistsExcept("ipad_t", _value, _aExcept);
         setGRAttribIfNotExistsExcept("ipad_b", _value, _aExcept);
      }
      else
      {
         if( !gr_attribs.exists(_key) && ((null == _aExcept || !_aExcept.containsObject(_key))) )
            gr_attribs[_key] = Object(_value);  // add previously non-existing attrib
      }
   }

   public static CopyGRAttribs(HashTable _htDst, HashTable _htSrc) {
      String *key;
      foreach key in _htSrc
         _htDst[key] = Object(_htSrc[key]);
   }

   public static CopyGRAttribsIfNotExists(HashTable _htDst, HashTable _htSrc) {
      String *key;
      foreach key in _htSrc
         if(!_htDst.exists(key))
            _htDst[key] = Object(_htSrc[key]);  // add previously non-existing attrib
   }

   public static CopyGRAttribsIfNotExistsExcept(HashTable _htDst, HashTable _htSrc, StringArray _aExcept) {
      String *key;
      foreach key in _htSrc
      {
         if(!_htDst.exists(key) && !_aExcept.containsObject(key))
            _htDst[key] = Object(_htSrc[key]);  // add previously non-existing attrib
      }
   }

   public method hasGRStyleClassAttribs() : boolean {
      return (gr_attribs.numElements > 0);
   }

   public method copyGRAttribsIfNotExists(HashTable _ht) {
      String *key;
      foreach key in _ht
         if(!gr_attribs.exists(key))
            setGRAttrib(key, _ht[key]);  // add previously non-existing attrib
   }

   public method copyGRAttribsIfNotExistsExcept(HashTable _ht, StringArray _aExcept) {
      String *key;
      foreach key in _ht
         setGRAttribIfNotExistsExcept(key, _ht[key], _aExcept);
   }

   public method copyGRAttribsReplace(HashTable _ht) {
      String *key;
      foreach key in _ht
         gr_attribs[key] = Object(_ht[key]);  // add attrib
   }

   public method copyGRStyleClassAttribs(GRStyle _style) {
      String *key;
      HashTable ht <= _style.attribs;
      foreach key in ht
      {
         // trace "xxx copyGRStyleClassAttribs: style.id="+_style.id+" key='"+key+"' val='"+ht[key]+"'";
         setGRAttrib(key, ht[key]);
      }
      if(!gr_attribs.exists("class"))
         gr_attribs["class"] = Object(_style.id);
   }

}


// <class.png>
class Port : UserDataContainer {
   Node  *parent_node;   // !=null if this port was declared in the context of a Node
   Graph *parent_graph;  // !=null if this port was declared in the context of a (Sub-)Graph

   String id;      // port identifier (for edge declarations)
   int    dir;     // Layout.TOP|LEFT|BOTTOM|RIGHT
   float  relpos;  // 0..1 (relative position along edge)

   // Panel (contains GraphPortButton)
   //  (note) graph_data links back to Port
   ui::Layer *ui_content_layer;  // GraphPortButton
   ui::Layer *ui_panel_layer;


   public method getPanelLayerSx() : float {
      if(null != ui_panel_layer)
         return ui_panel_layer.size_x;
      return 0.0f;
   }

   public method getPanelLayerSy() : float {
      if(null != ui_panel_layer)
         return ui_panel_layer.size_y;
      return 0.0f;
   }

   public method getUIContentLayer() : Layer {
      return ui_content_layer;
   }

   public method getUIPanelLayer() : Layer {
      return ui_panel_layer;
   }

}


// <class.png>
class PortsBase : AttribsBase {
   Port *[] ports;

   float ui_port_max_w;  // after GraphForm::createPortsLayerFor()
   float ui_port_max_h;

   public method addPort() : Port {
      Port port <= new Port;
      port.parent_node <= this;
      ports.add(#(deref port));
      return port;
   }

   public method findPort(String _id) : Port {
      Port *port;
      foreach port in ports
         if(port.id == _id)
            return port;
      return null;
   }

   public method getNumPorts() : int {
      return ports.numElements;
   }

   public method getNumPortsForDir(int _dir/*Layout.TOP|LEFT|BOTTOM|RIGHT*/) : int {
      int r = 0;
      Port *port;
      foreach port in ports
         if(_dir == port.dir)
            r++;
      return r;
   }

   public method autoAssignPortPositions(int _dir) {
      // // trace "xxx autoAssignPortPositions: dir="+_dir;
      Port *port;
      local Port*[] portsDir;
      foreach port in ports
         if(port.dir == _dir)
            portsDir.add(port);

      int i = 0;
      loop(portsDir.numElements)
      {
         float start = portsDir[i].relpos;

         // find unassigned span length
         int j = i + 1;
         int spanLen = 1;
         float spanLastStart = start;
         while(j < portsDir.numElements)
         {
            if(portsDir[j].relpos <= start)
            {
               spanLen++;
            }
            else
            {
               spanLastStart = portsDir[j].relpos;
               spanLen++;
               break;
            }
            j++;
         }
         if(j == portsDir.numElements)
            spanLastStart = 1.0f;

         if(b_gr_parse_debug3)
            trace "[trc] PortsBase::autoAssignPortPositions: dir="+_dir+" i="+i+" spanLen="+spanLen+" start="+start+" spanLastStart="+spanLastStart;

         // Interpolate starts
         if(spanLen > 1)
         {
            float startDelta = (spanLastStart - start) / (spanLen - 1);
            float curStart = start + startDelta;
            // trace "xxx port spanLen="+spanLen+" curStart="+curStart+" startDelta="+startDelta;
            j = i +1;
            loop(spanLen - 1)
            {
               port <= portsDir[j];
               port.relpos = curStart;
               curStart += startDelta;
               j++;
            }
         }
         else if(1 == portsDir.numElements)
         {
            port <= portsDir.first;
            port.relpos = 0.5;
         }

         // Next port
         i++;
      }

      if(b_gr_parse_debug2)
      {
         trace "[trc] PortsBase::autoAssignPortPositions: dir="+_dir;
         i = 0;
         loop(portsDir.numElements)
         {
            trace "[trc] PortsBase::autoAssignPortPositions:     ["+i+"] relpos="+portsDir[i].relpos+" id="+portsDir[i].id+"  port="+#(portsDir[i]);
            i++;
         }
      }
   }

   public method applyPortMargins() {
      if(ports.numElements > 0)
      {
         // // trace "xxx applyPortMargins<node>: gr_attribs="+#(gr_attribs);
         if(gr_attribs.exists("ports_margin"))
         {
            String sMargin <= gr_attribs["ports_margin"];
            local StringArray aMargin <= sMargin.splitChar(';');
            float marginT = GRUtils.ParseAmountString(aMargin.get(0));
            float marginL = (aMargin.numElements > 1) ? GRUtils.ParseAmountString(aMargin.get(1)) : marginT;
            float marginB = (aMargin.numElements > 2) ? GRUtils.ParseAmountString(aMargin.get(2)) : marginL;
            float marginR = (aMargin.numElements > 3) ? GRUtils.ParseAmountString(aMargin.get(3)) : marginB;
            // // trace "xxx applyPortMargins: t="+marginT+" l="+marginL+" b="+marginB+" r="+marginR;
            Port *port;
            foreach port in ports
            {
               // // if(1) trace "[trc] PortsBase::applyPortMargins:  port.id="+port.id+"  orig relpos="+port.relpos+" port="+#(port);

               switch(port.dir)
               {
                  default:
                  case Layout.TOP:
                     port.relpos = port.relpos * (1.0f - marginT) + marginT * 0.5f;
                     if(b_gr_parse_debug2) trace "[trc] PortsBase::applyPortMargins:  t  port.id="+port.id+" relpos="+port.relpos;
                     break;

                  case Layout.LEFT:
                     port.relpos = port.relpos * (1.0f - marginL) + marginL * 0.5f;
                     if(b_gr_parse_debug2) trace "[trc] PortsBase::applyPortMargins:  l  port.id="+port.id+" relpos="+port.relpos;
                     break;

                  case Layout.BOTTOM:
                     port.relpos = port.relpos * (1.0f - marginB) + marginB * 0.5f;
                     if(b_gr_parse_debug2) trace "[trc] PortsBase::applyPortMargins:  b  port.id="+port.id+" relpos="+port.relpos;
                     break;

                  case Layout.RIGHT:
                     port.relpos = port.relpos * (1.0f - marginR) + marginR * 0.5f;
                     if(b_gr_parse_debug2) trace "[trc] PortsBase::applyPortMargins:  r  port.id="+port.id+" relpos="+port.relpos;
                     break;
               }
            }
         }
      }
   }

   public method getPortLayerMaxW() : float {
      return ui_port_max_w;
   }

   public method getPortLayerMaxH() : float {
      return ui_port_max_h;
   }

}


// <class.png>
class Node : PortsBase, UserDataContainer {
   String    id;
   String    label;  // (todo) should this be a gr_attribs property instead ?
   boolean   b_helper;
   boolean   b_helper_subgraph;
   boolean   b_ui_helper;  // via "helper" attrib. forces edge connections to center of layer.
   boolean   b_multi_helper;  // used by graph editor for multi-segment connections
   int       serial;   // placement order
   Cell     *cell;     // currently assigned cell or null
   Graph    *parent_subgraph;  // !=null when this is an io_node
   Node     *unfolded_anchor;  // !=null after unfolding sub graph (replaces io_node in future refs)
   Graph    *orig_graph;       // graph to which this node originally belonged to (e.g. a "fixed" layout graph => constrain movement)
   boolean   b_line_break;     // set via '+', move cursor down one grid row (row_spacing) after adding this node during initial layout

   boolean   b_helper_done;        // during pixel/edge layout pass, 1=helper node eliminated (and used as bezier control point)
   int       num_edges_t;          // number of (visible) edges that connect to the top side of this node (see countNumEdgesToNodes())
   int       num_edges_l;          //
   int       num_edges_b;          //
   int       num_edges_r;          //
   int       cur_edge_idx_t;       // temporary during GraphForm layout. 0..num_edges_t-1. reset to 0 during countNumEdgesToNodes()
   int       cur_edge_idx_l;       //
   int       cur_edge_idx_b;       //
   int       cur_edge_idx_r;       //
   boolean   b_position_override;  // override ui_layer.position_x/y. temporary while constructing multi-segment bezier curve
   float     position_override_x;
   float     position_override_y;
   Node     *next_helper_node;     // temporary while constructing multi-segment bezier curve

   int       table_span_x;         // see GridWidget::addTableSubgraph()
   int       table_span_y;
   int       table_span_w;         // (split) span width
   int       table_span_w_spc;     // total span width (with (initially) empty cells after last node)
   Node     *prev_table_node;      // previous span node
   Node     *next_table_node;      // next span node

   // (note) UI layers are valid temporarily (instances are updated when GraphForm layers are rebuilt)
   // (note) Layer.graph_data links back to Node
   Object   *ui_layer;             // opaque UI layer object, e.g. a ui::Panel
   Object   *ui_content_layer;     // inner UI layer object, e.g. a ui::Button
   Panel    *ui_panel_layer;       // [01Feb2025] experimental. see GraphForm::createPanelForLayer() (move graphform)
   Panel    *ui_ports_layer;       // [01Feb2025] experimental. see GraphForm::createPortsLayerFor() (layout port connections)

   // (note) XFM layers are created during GR::parseGR(), then referenced in GraphForm
   String    *xfm_class_name;  // e.g. "Slider", "Dial", "FloatParam", ..
   ui::Layer *xfm_layer;       // null or Layer-derived instance. resolved from xfm_class_name when XFM attrib list is closed (')')
   HashTable  xfm_attribs;


   public method init(String _id) {
      initAttribsBase();
      id = _id;
      label = id;
      xfm_attribs.alloc(512);
   }

   public method initHelper() {
      b_helper = true;
      id = "*";
      label = id;
   }

   public method uiEdgeReset() {
      num_edges_t = 0;
      num_edges_l = 0;
      num_edges_b = 0;
      num_edges_r = 0;
      cur_edge_idx_t = 0;
      cur_edge_idx_l = 0;
      cur_edge_idx_b = 0;
      cur_edge_idx_r = 0;
      b_position_override = false;
      position_override_x = 0;
      position_override_y = 0;
      next_helper_node <= null;
      b_helper_done = false;
   }

   public method beginUIInit() {
      ui_layer <= null;
      ui_panel_layer <= null;
      ui_ports_layer <= null;

      uiEdgeReset();

      table_span_x = 0;
      table_span_y = 0;
      table_span_w = 0;
      table_span_w_spc = 0;
      prev_table_node <= null;
      next_table_node <= null;

      Port *p;
      foreach p in ports
      {
         p.ui_content_layer <= null;
         p.ui_panel_layer <= null;
      }
      ui_port_max_w = 0;
      ui_port_max_h = 0;

      if(null != xfm_layer)
         xfm_layer.removeParentLayerRefs();
   }

   module method renameNode(String _newId) {
      if(b_gr_debug) trace "[dbg] Graph::renameNode: id='"+id+"' newId='"+_newId+"' orig_graph="+#(orig_graph)+" orig_graph.table_layout_rows="+((null != orig_graph)?#(orig_graph.table_layout_rows):"");
      if(b_gr_debug) trace "[dbg] Graph::renameNode:                                parent_subgraph="+#(parent_subgraph)+" parent_subgraph.table_layout_rows="+((null != parent_subgraph)?#(parent_subgraph.table_layout_rows):"");

      id = _newId;

      if(null != parent_subgraph)  // io node ?
         parent_subgraph.id = _newId;
   }

   public method isRightOf(Node _n) : boolean {
      if(null != cell && null != _n.cell)
         return (cell.x > _n.cell.x);
      return false;
   }

   public method getString() : String {
      if(null != cell)
         return "<"+((null != parent_subgraph)?"graph:":"")+id+">("+cell.x+","+cell.y+")";
      else
         return "<"+((null != parent_subgraph)?"graph:":"")+id+">(?,?)";
   }

   public method getUIPanelLayer() : Layer {
      // e.g. for moving graphform
      if(null != ui_panel_layer)
         return ui_panel_layer;
      return ui_layer;
   }

   public method getUIPortsLayer() : Layer {
      // e.g. port / edge layout calculations
      if(null != ui_ports_layer)
         return ui_ports_layer;
      return ui_layer;
   }

   protected method setNodeAttrib(String _key, String _value) {
      // trace "xxx setNodeAttrib(key="+_key+" value="+_value+")";
      if("s" == _key)
         setNodeAttribS(_value);  // expand / split 's' into 'w' and 'h'
      else if("p" == _key)
         setNodeAttribP(_value);  // expand / split 'p' into 'x' and 'y'
      else if("port_s" == _key)
         setNodeAttribPortS(_value);  // expand / split 'port_s' into 'port_w' and 'port_h'
      else if("helper" == _key)
         b_ui_helper = (0 != int(_value));
      else
         setGRAttrib(_key, _value);
   }

   public method addNodeAttrib(String _key, String _value) {
      if(b_gr_parse_debug3)
         trace "[trc] Node::addNodeAttrib: key=\""+_key+"\" value=\""+_value+"\"";
      if("label" == _key)
         label = _value;
      else if("id" == _key)
         renameNode(_value);
      else
      {
         GR.ReplaceLiteral(_value);
         setNodeAttrib(_key, _value);
      }
   }

   public method haveNodeAttrib(String _key) : boolean {
      return gr_attribs.exists(_key);
   }

   public method getNodeAttrib(String _key) {
      return gr_attribs.get(_key);
   }

   public method addXFMAttrib(String _key, String _value) {
      GR.ReplaceLiteral(_value);
      xfm_attribs[_key] = Object(_value);  // store a copy of 'value'
   }

   public method copyXFMStyleClassAttribs(GRStyle _style) {
      String *key;
      HashTable ht <= _style.attribs;
      foreach key in ht
         xfm_attribs[key] = Object(ht[key]);  // add attrib
      if(!xfm_attribs.exists("class"))
         xfm_attribs["class"] = Object(_style.id);
   }

   public method copyXFMAttribsIfNotExists(HashTable _ht) {
      // when nodes/subgraphs inherit parent graph XFM attribs
      String *key;
      foreach key in _ht
         if(!xfm_attribs.exists(key))
            xfm_attribs[key] = Object(_ht[key]);  // add previously non-existing attrib
   }

   public method usesFixedOrTableLayout() : boolean {
      return orig_graph.usesFixedOrTableLayout();
      // // return
      // //    (Graph.LAYOUT_FIXED == orig_graph.layout) ||
      // //    (Graph.LAYOUT_TABLE == orig_graph.layout) ||
      // //    (Graph.LAYOUT_NONE  == orig_graph.layout) ;
   }

   public method usesFixedLayout() : boolean {
      return
         (Graph.LAYOUT_FIXED == orig_graph.layout) ||
         (Graph.LAYOUT_NONE  == orig_graph.layout) ;
   }

   public method isInMainGraph() : boolean {
      return (null != orig_graph) && (null == orig_graph.parent_graph);
   }

   public method setPositionOverride(float _x, float _y) {
      // used by helper nodes (see GraphForm)
      b_position_override = true;
      position_override_x = _x;
      position_override_y = _y;
   }

   public method tableSpanContainsNode(Node _n) : boolean {
      Node c <= this;
      while(null != c.prev_table_node)
         c <= c.prev_table_node; // seek to span start
      while(null != c)
      {
         if(@(c) == @(_n))
            return true;
         c <= c.next_table_node;
      }
      return false;
   }

   public method nodeEdgeOverlap(Layer _lo, int _oDir) : boolean {
      // when cycling edge-chain connection dir via wheelUp/Down()
      Layer l <= getUIPanelLayer();
      if(null != _lo && null != l)
      {
         boolean bAbove = (_lo.position_y < l.position_y);
         boolean bLeft = (_lo.position_x < l.position_x);
         // // trace "xxx oDir="+_oDir+" bAbove="+bAbove+" bLeft="+bLeft;

         switch(_oDir)
         {
            case Layout.LEFT:
               return !bLeft;

            case Layout.RIGHT:
               return bLeft;

            case Layout.TOP:
               return !bAbove;

            case Layout.BOTTOM:
               return bAbove;
         }
      }
      return false;
   }

}


// <class.png>
class Edge : AttribsBase {
   Node     *tail;
   Node     *head;
   boolean   b_cyclic;
   boolean   b_rev;
   String    label;
   Port     *tail_port;
   Port     *head_port;
   int       tail_dir;  // Layout.TOP|LEFT|BOTTOM|RIGHT (n/w/s/e) fallback when tail_port is null. 0=automatic direction
   int       head_dir;
   boolean   b_force_placed;  // 1=helper connection node (connection chain in 'MyGraphForm' editor)

   define int STYLE_NORMAL = 0;  // -> and <-
   define int STYLE_DOTTED = 1;  // .> and <.
   define int STYLE_DASHED = 2;  // => and <=
   define int STYLE_BOLD   = 3;  // >> and <<
   define int STYLE_HIDDEN = 4;  // ~> and <~
   define int STYLE_UNDIR  = 5;  // --
   define int STYLE_BIDIR  = 6;  // <>
   int edge_style;

   int     ui_dir_flags;      // cached result from GraphForm pixel layout pass
   boolean b_ui_xmajor_tail;  // affects the direction of 'arrow_snap' (cached from edge layout pass)
   boolean b_ui_xmajor_head;  // affects the direction of 'arrow_snap' (cached from edge layout pass)
   int     ui_tail_dir;       // cached result from GraphForm pixel layout pass (Layout.TOP|LEFT|BOTTOM|RIGHT)
   int     ui_head_dir;       //


   public method init(Node _tail, Node _head) {
      initAttribsBase();
      tail <= _tail;
      head <= _head;
   }

   public method getOtherNode(Node _n) : Node {
      if(@(tail) == @(_n))
         return head;
      if(@(head) == @(_n))
         return tail;
      return null;
   }

   public method connects(Node _n1, Node _n2) : boolean {
      return
         (@(head) == @(_n1) && @(tail) == @(_n2)) ||
         (@(tail) == @(_n1) && @(head) == @(_n2)) ;
   }

   public method connectsTo(Node _n) : boolean {
      return (@(head) == @(_n)) || (@(tail) == @(_n));
   }

   public method connectsToOnSameLevel(Node _n) : boolean {
      if(connectsTo(_n))
      {
         Node nOther <= getOtherNode(_n);
         return (nOther.cell.y == _n.cell.y);
      }
      return false;
   }

   public method connectsToRHSOnSameLevel(Node _n) : boolean {
      if(connectsTo(_n))
      {
         Node nOther <= getOtherNode(_n);
         if(nOther.cell.y == _n.cell.y)
            return (nOther.cell.x > _n.cell.x);
      }
      return false;
   }

   public method connectsToHelper() : boolean {
      return tail.b_helper || head.b_helper;
   }

   public method isInMainGraph() : boolean {
      return tail.isInMainGraph() && head.isInMainGraph();
   }

   public method getTopCell() : Cell {
      Cell ctail <= tail.cell;
      Cell chead <= head.cell;
      if(null != ctail && null != chead)
      {
         if(ctail.y <= chead.y)
            return ctail;
         return chead;
      }
      return null;
   }

   public method getBottomCell() : Cell {
      Cell ctail <= tail.cell;
      Cell chead <= head.cell;
      // trace "xxx getBottomCell: tail"+Graph.GetNodeString(tail)+" head"+Graph.GetNodeString(head);
      if(null != ctail && null != chead)
      {
         if(ctail.y > chead.y)
            return ctail;
         return chead;
      }
      return null;
   }

   public method isPlaced() : boolean {
      if(b_force_placed)
         return true;
      Cell ctail <= tail.cell;
      Cell chead <= head.cell;
      return (null != ctail) && (null != chead);
   }

   public method isXMajor() : boolean {
      if(gr_attribs.exists("xmajor"))
      {
         String sXMajor <= gr_attribs["xmajor"];
         if("auto" != sXMajor)
            return (0 != int(sXMajor));
      }
      return maybe;
   }

   public method isXMajorTail() : boolean {
      if(gr_attribs.exists("xmajor_tail"))
      {
         String sXMajorTail <= gr_attribs["xmajor_tail"];
         if("auto" != sXMajorTail)
            return (0 != int(sXMajorTail));
      }
      return maybe;
   }

   public method isXMajorHead() : boolean {
      if(gr_attribs.exists("xmajor_head"))
      {
         String sXMajorHead <= gr_attribs["xmajor_head"];
         if("auto" != sXMajorHead)
            return (0 != int(sXMajorHead));
      }
      return maybe;
   }

   public method replaceNode(Node _nOld, Node _nNew) {
      if(@(head) == @(_nOld))
         head <= _nNew;
      if(@(tail) == @(_nOld))
         tail <= _nNew;
   }

   public static GetDirString(int _dir) : String {
      switch(_dir)
      {
         case Layout.TOP:
            return "n";

         case Layout.LEFT:
            return "w";

         case Layout.BOTTOM:
            return "s";

         case Layout.RIGHT:
            return "e";
      }
      return null;
   }

   public method getString() : String {
      return (b_rev?"rev":"")+"edge<tail"+tail.getString()+((null != tail_port)?(":"+tail_port.id):(0 != tail_dir)?(":"+GetDirString(tail_dir)):"")+" head"+head.getString()+((null != head_port)?(":"+head_port.id):(0 != head_dir)?(":"+GetDirString(head_dir)):"")+">";
   }

   public method getTailStringUI() : String {
      return tail.id+((null != tail_port)?(":"+tail_port.id):"");
   }

   public method getHeadStringUI() : String {
      return head.id+((null != head_port)?(":"+head_port.id):"");
   }

   public method getStringUI() : String {
      return getTailStringUI()+" -> "+getHeadStringUI();
   }

   public method draw(Canvas _canvas) {
      Cell ctail <= tail.cell;
      Cell chead <= head.cell;

      if(b_gr_debug2) trace "[trc] draw edge: tail<"+Graph.GetNodeString(tail)+" => head"+Graph.GetNodeString(head)+" style="+GetEdgeStyleName(edge_style);

      if(STYLE_HIDDEN == edge_style)
         return;

      if(null != ctail && null != chead)
      {

         int cx;
         int cy;

         if( (chead.x == ctail.x + 1) &&
             (chead.y == ctail.y + 1)
             )  // down-right
         {
            cx = ctail.x;
            cy = ctail.y;
            _canvas.plot(cx,   cy,   2, 2, '\\');
            _canvas.plot(cx+1, cy+1, 0, 0, '\\');
         }
         else if( (chead.x == ctail.x + 1) &&
                  (chead.y == ctail.y - 1)
                  )  // up-right
         {
            cx = ctail.x;
            cy = chead.y;
            _canvas.plot(cx+1, cy,   0, 2, '/');
            _canvas.plot(cx,   cy+1, 2, 0, '/');
         }
         else if( (chead.x == ctail.x - 1) &&
                  (chead.y == ctail.y + 1)
                  )  // down-left
         {
            cx = ctail.x;
            cy = ctail.y;
            _canvas.plot(cx,   cy,   0, 2, '/');
            _canvas.plot(cx-1, cy+1, 2, 0, '/');
         }
         else if( (chead.x == ctail.x - 1) &&
                  (chead.y == ctail.y - 1)
                  )  // up-left
         {
            cx = ctail.x;
            cy = ctail.y;
            _canvas.plot(cx,   cy,   0, 0, '\\');
            _canvas.plot(cx-1, cy-1, 2, 2, '\\');
         }
         else if(chead.x > ctail.x)
         {
            // horizontal edge L=>R
            if(b_rev)
            {
               if(ctail.y == chead.y)  // should always be true
               {
                  cx = ctail.x + 1;
                  cy = ctail.y;
                  while(cx < chead.x)
                  {
                     _canvas.plot(cx, cy, 0, 1, '<');
                     _canvas.plot(cx, cy, 1, 1, '<');
                     _canvas.plot(cx, cy, 2, 1, '<');
                     cx++;
                  }
               }
               _canvas.plot(ctail.x, ctail.y, 2, 1, '<');
               _canvas.plot(chead.x, chead.y, 0, 1, '<');
            }
            else
            {
               if(ctail.y == chead.y)  // should always be true
               {
                  cx = ctail.x + 1;
                  cy = ctail.y;
                  while(cx < chead.x)
                  {
                     _canvas.plot(cx, cy, 0, 1, '>');
                     _canvas.plot(cx, cy, 1, 1, '>');
                     _canvas.plot(cx, cy, 2, 1, '>');
                     cx++;
                  }
               }
               _canvas.plot(ctail.x, ctail.y, 2, 1, '>');
               _canvas.plot(chead.x, chead.y, 0, 1, '>');
            }
         }
         else if(chead.y > ctail.y)
         {
            // vertical edge down
            if(b_rev)
            {
               if(ctail.x == chead.x)  // should always be true
               {
                  cx = ctail.x;
                  cy = ctail.y + 1;
                  while(cy < chead.y)
                  {
                     _canvas.plot(cx, cy, 1, 2, '^');
                     _canvas.plot(cx, cy, 1, 1, '^');
                     _canvas.plot(cx, cy, 1, 0, '^');
                     cy++;
                  }
               }
               _canvas.plot(ctail.x, ctail.y, 1, 2, '^');
               _canvas.plot(chead.x, chead.y, 1, 0, '^');
            }
            else
            {
               if(ctail.x == chead.x)  // should always be true
               {
                  cx = ctail.x;
                  cy = ctail.y + 1;
                  while(cy < chead.y)
                  {
                     _canvas.plot(cx, cy, 1, 2, 'v');
                     _canvas.plot(cx, cy, 1, 1, 'v');
                     _canvas.plot(cx, cy, 1, 0, 'v');
                     cy++;
                  }
               }
               _canvas.plot(ctail.x, ctail.y, 1, 2, 'v');
               _canvas.plot(chead.x, chead.y, 1, 0, 'v');
            }
         }
         else if(chead.y < ctail.y)
         {
            // vertical edge up
            // trace "xxx b_rev="+b_rev;
            if(b_rev)
            {
               if(ctail.x == chead.x)  // should always be true
               {
                  cx = chead.x;
                  cy = chead.y + 1;
                  while(cy < ctail.y)
                  {
                     _canvas.plot(cx, cy, 1, 2, 'v');
                     _canvas.plot(cx, cy, 1, 1, 'v');
                     _canvas.plot(cx, cy, 1, 0, 'v');
                     cy++;
                  }
               }
               _canvas.plot(ctail.x, chead.y, 1, 2, 'v');
               _canvas.plot(chead.x, ctail.y, 1, 0, 'v');
            }
            else
            {
               if(ctail.x == chead.x)  // should always be true
               {
                  cx = chead.x;
                  cy = chead.y + 1;
                  while(cy < ctail.y)
                  {
                     _canvas.plot(cx, cy, 1, 2, '^');
                     _canvas.plot(cx, cy, 1, 1, '^');
                     _canvas.plot(cx, cy, 1, 0, '^');
                     cy++;
                  }
               }
               _canvas.plot(ctail.x, ctail.y, 1, 0, '^');
               _canvas.plot(chead.x, chead.y, 1, 2, '^');
            }
         }
         else
         {
            // horizontal edge R=>L
            if(b_rev)
            {
               if(ctail.y == chead.y)  // should always be true
               {
                  cx = chead.x + 1;
                  cy = chead.y;
                  while(cx < ctail.x)
                  {
                     _canvas.plot(cx, cy, 0, 1, '>');
                     _canvas.plot(cx, cy, 1, 1, '>');
                     _canvas.plot(cx, cy, 2, 1, '>');
                     cx++;
                  }
               }
               _canvas.plot(chead.x, chead.y, 2, 1, '>');
               _canvas.plot(ctail.x, ctail.y, 0, 1, '>');
            }
            else
            {
               if(ctail.y == chead.y)  // should always be true
               {
                  cx = chead.x + 1;
                  cy = chead.y;
                  while(cx < ctail.x)
                  {
                     _canvas.plot(cx, cy, 0, 1, '<');
                     _canvas.plot(cx, cy, 1, 1, '<');
                     _canvas.plot(cx, cy, 2, 1, '<');
                     cx++;
                  }
               }
               _canvas.plot(chead.x, chead.y, 2, 1, '<');
               _canvas.plot(ctail.x, ctail.y, 0, 1, '<');
            }
         }
      } // if ctail && chead
   }

   public method addEdgeAttrib(String _key, String _value) {
      if(b_gr_parse_debug2)
         trace "[trc] Edge::addEdgeAttrib: key=\""+_key+"\" value=\""+_value+"\"";
      GR.ReplaceLiteral(_value);
      if("pad_h" == _key)
      {
         gr_attribs["pad_l"] = Object(_value);
         gr_attribs["pad_r"] = Object(_value);
      }
      else if("pad_v" == _key)
      {
         gr_attribs["pad_t"] = Object(_value);
         gr_attribs["pad_b"] = Object(_value);
      }
      else
      {
         gr_attribs[_key] = Object(_value);
      }
   }

   public method haveEdgeAttrib(String _key) : boolean {
      return gr_attribs.exists(_key);
   }

   public method getEdgeAttrib(String _key) {
      return gr_attribs.get(_key);
   }

   public method getEdgeAttribAmount(String _key) : float {
      return GRUtils.GetAttribAmount(gr_attribs, _key);
   }

   public static GetEdgeStyleName(int _style) : String {
      local String r = TKS.scriptClassConstantToString(#(_style), Edge, "STYLE_");
      r.replace("STYLE_", "");
      r.toLower();
      return deref r;
   }

   public method isVisible() : boolean {
      return (STYLE_HIDDEN != edge_style);
   }

   public method calcDirFlags(Layer   _lTail, Layer   _lHead,
                              Point2f _pTail, Point2f _pHead
                              ) : int {
      // see ui::Layout.TOP/LEFT/BOTTOM/RIGHT flags
      //  (note) lTail/lHead may differ from tail.ui_layer / head.ui_layer (e.g. while eliminating helper nodes)
      ui_dir_flags = _lTail.calcDirFlagsRelativeTo(_lHead, _pTail, _pHead);
      return ui_dir_flags;
   }
}


// <class.png>
class Graph : AttribsBase /*: PortsBase*/ {
   define int DEF_GRID_W = 8; // 128;
   define int DEF_GRID_H = 8; // 128;

   define int LAYOUT_NONE  = 0;  // [01Feb2025] experimental abs positioning
   define int LAYOUT_GRID  = 1;
   define int LAYOUT_FIXED = 2;
   define int LAYOUT_TABLE = 3;
   int       layout;

   protected StringArray layout_rows;   // used in TABLE and FIXED layout modes
   StringArray *[] *table_layout_rows;  // array of StringArrays (ids) (in table mode)

   String    id;
   int       grid_w;
   int       grid_h;
   int       reset_grid_w;
   int       reset_grid_h;
   boolean   b_start_at_center;     // true=layoutGridInitial() starts at grid center.  false=start at left/top (default=true)
   boolean   b_trim_to_bbox;        // true=trim to bounding box (default)
   Cell  *[] cells;
   Node  *[] nodes;
   Edge  *[] edges;
   Graph *[] graphs;
   Canvas    canvas;
   int       next_node_serial;
   Graph    *parent_graph;

   define int DEF_CELL_SPACING = 5;
   int       initial_col_spacing;   // def=5
   int       initial_row_spacing;   // def=5
   boolean   b_head_first;          // true=add edge head first (def=false)  (remove?)
   boolean   b_flip_x_opt;          // true=try to optimize h-space gaps by flipping node h-placement in rows below
   boolean   b_flip_y_opt;          // true=try to optimize v-space gaps by flipping node v-placement
   boolean   b_flip_x;              // flip horizontally
   boolean   b_flip_y;              // flip vertically
   boolean   b_rotate;              // swap x/y in final pass (LR=>TB)
   boolean   b_cell_slant;          // shift cols in final pass
   boolean   b_slant;               // shift cols in pixel pass
   float     slant_factor;          // see GraphForm slantFactor (def=16)
   boolean   b_zero_margin;         // see GraphForm. set outer graph node padding to 0 (override node padding in the direction of the graph edge)
   boolean   b_unfold;              // false for main graph, initially true for sub-graphs.

   define exception GraphError : Error;

   protected Node   *io_node;      // for sub-graphs (temporary helper node)
   protected Node   *anchor_node;  // where to anchor subgraph in parent graph. must be top-row node. defaults to findTopLeftNode()
   public    String *anchor_id;    // (unresolved) anchor node id. when != null, resolve when getAnchor() is called.

   public ui::Layer *graph_form;   // during pixel layout pass (GraphForm::addEdgesFromGraph())
   HashTable xfm_attribs;

   static StringArray a_node_inherit_from_graph_except =
      ["id",
       "pad", "pad_t", "pad_l", "pad_b", "pad_r", "ipad", "ipad_t", "ipad_l", "ipad_b", "ipad_r",
       "border_width", "border_color", "border_style", "border_shape", "border_blend", "border_alpha"
       "bgcolor",
       // // "bgtint",
       // // "border_tint",
       "bgfill",
       "layout",
       "pixel_layout",
       "flatten",
       // // "xmajor",
       "sgx",
       "sgy",
       "sgxy",
       "w", "h", "s", "sw", "sh",
       "x", "y", 
       "row_padding",
       "col_padding",
       "stack",
       "stack_off",
       ];
       // // "bgfill",

   static StringArray a_edge_inherit_from_node_except =
      ["id",
       "pad", "pad_t", "pad_l", "pad_b", "pad_r", "ipad", "ipad_t", "ipad_l", "ipad_b", "ipad_r",
       "border_width", "border_color", "border_style", "border_shape",  "border_blend", "border_alpha"
       "bgcolor",
       // // "bgtint",
       "bgfill",
       "layout",
       "pixel_layout",
       "flatten",
       // // "xmajor",
       "sgx",
       "sgy",
       "sgxy",
       "w", "h", "s", "sw", "sh",
       "x", "y"
       ];

   static StringArray a_edge_inherit_from_graph_except =
      ["id",
       "pad", "pad_t", "pad_l", "pad_b", "pad_r", "ipad", "ipad_t", "ipad_l", "ipad_b", "ipad_r",
       "border_width", "border_color", "border_style", "border_shape",  "border_blend", "border_alpha"
       "bgcolor",
       // // "bgtint",
       "bgfill",
       "layout",
       "pixel_layout",
       "flatten",
       // // "xmajor",
       "sgx",
       "sgy",
       "sgxy",
       "w", "h", "s", "sw", "sh",
       "x", "y",
       "row_padding",
       "col_padding",
       "stack",
       "stack_off",
       ];

   static StringArray a_subgraph_inherit_from_node_except =
      ["id",
       "pad", "pad_t", "pad_l", "pad_b", "pad_r", "ipad", "ipad_t", "ipad_l", "ipad_b", "ipad_r",
       "border_width", "border_color", "border_style", "border_shape", "border_blend", "border_alpha"
       "bgcolor",
       // // "bgtint",
       "bgfill",
       "layout",
       "pixel_layout",
       "flatten",
       // // "xmajor",
       "sgx",
       "sgy",
       "sgxy",
       "w", "h", "s", "sw", "sh",
       "x", "y",
       "stack",
       "stack_off",
       ];

   static StringArray a_subgraph_inherit_from_graph_except =
      ["id",
       "pad", "pad_t", "pad_l", "pad_b", "pad_r", "ipad", "ipad_t", "ipad_l", "ipad_b", "ipad_r",
       // // "border_width", "border_color", "border_style", "border_shape", "border_blend", "border_alpha"
       // // "bgcolor",
       // // "bgtint",
       // // "bgfill",
       // // "layout",
       // // "pixel_layout",
       "flatten",
       "sgx",
       "sgy",
       "sgxy",
       "w", "h", "s", "sw", "sh",
       "x", "y",
       "stack",
       "stack_off",
       ];

   // temporary during parseGR():
   //  - saved when starting subgraph
   //  - restored when subgraph ends
   namespace GRStyle    *cur_style;
   namespace GRStyle    *cur_node_style;
   namespace GRStyle    *cur_edge_style;
   namespace GRPalette  *cur_palette;
   namespace GRGradient *cur_gradient;


   public method init(int _gridW, int _gridH) {
      initAttribsBase();

      reset_grid_w      = _gridW;
      reset_grid_h      = _gridH;
      b_start_at_center = true;
      b_trim_to_bbox    = true;
      b_unfold          = false;
      // b_unfold          = true;

      layout = LAYOUT_GRID;

      reset();
   }

   public method recursiveBeginUIInit() {
      // called before relayouting/recreating nodelayers+edges (resize)
      local Graph *g;
      foreach g in graphs
         g.recursiveBeginUIInit();
      local Node *n;
      foreach n in nodes
         n.beginUIInit();
   }

   public method recursiveUIEdgeReset() {
      // called before GraphForm::addEdgesFromGraph() is called again
      local Graph *g;
      foreach g in graphs
         g.recursiveUIEdgeReset();
      local Node *n;
      foreach n in nodes
         n.uiEdgeReset();
   }

   public setGridSizeFromString(String _s) {
      local StringArray a <= _s.replaceChar(',',';').splitChar(';');
      int gridW = a.get(0);
      int gridH = a.get(1);
      if(gridW < 1)
         gridW = 1;
      if(gridH < 1)
         gridH = gridW;
      reset_grid_w = gridW;
      reset_grid_h = gridH;
      allocCellsAndCanvas(reset_grid_w, reset_grid_h);
   }

   public method getSizeString() : String {
      return "("+grid_w+"x"+grid_h+")";
   }

   public method haveGraphAttrib(String _key) : boolean {
      return gr_attribs.exists(_key);
   }

   public method getGraphAttrib(String _key) {
      return gr_attribs.get(_key);
   }

   public method syncGRAttribsFromIONode() {
      // (todo) identify *all* attribs that need to be merged
      // trace "xxx this graph.id="+id+" sync gr_attribs from io_node.id="+io_node.id;
      HashTable htSrc <= io_node.gr_attribs;
      String *key;
      foreach key in ["bgcolor"]
      {
         if(htSrc.exists(key))
         {
            if(b_gr_parse_debug2)
               if(gr_attribs.exists(key))
                  trace "xxx syncGRAttribsFromIONode: overwrite key='"+key+"' val='"+gr_attribs[key]+" with newVal='"+htSrc[key]+"'";
            gr_attribs[key] = Object(htSrc[key]);
         }
      }
   }

   public method copyXFMAttribsIfNotExists(HashTable _ht) {
      String *key;
      foreach key in _ht
         if(!xfm_attribs.exists(key))
            xfm_attribs[key] = Object(_ht[key]);  // add previously non-existing attrib
   }

   public method usesFixedOrTableLayout() : boolean {
      return
         (Graph.LAYOUT_FIXED == layout) ||
         (Graph.LAYOUT_TABLE == layout) ||
         (Graph.LAYOUT_NONE  == layout) ;
   }

   public method doUnfold() : boolean {
      ////return (LAYOUT_TABLE != layout) && b_unfold;
      return b_unfold && !usesFixedOrTableLayout();
   }

   public method isXMajor() : boolean {
      if(gr_attribs.exists("xmajor"))
      {
         String sXMajor <= gr_attribs["xmajor"];
         if("auto" != sXMajor)
            return (0 != int(sXMajor));
      }
      return (grid_w > grid_h);
   }

   public method isXMajorTail() : boolean {
      if(gr_attribs.exists("xmajor_tail"))
      {
         String sXMajorTail <= gr_attribs["xmajor_tail"];
         if("auto" != sXMajorTail)
            return (0 != int(sXMajorTail));
      }
      return maybe;
   }

   public method isXMajorHead() : boolean {
      if(gr_attribs.exists("xmajor_head"))
      {
         String sXMajorHead <= gr_attribs["xmajor_head"];
         if("auto" != sXMajorHead)
            return (0 != int(sXMajorHead));
      }
      return maybe;
   }

   public method getLayoutString() : String {
      return TKS.scriptClassConstantToString(#(layout), this, "LAYOUT_");
   }

   public method allocCellsAndCanvas(int _w, int _h) {
      grid_w = _w;
      grid_h = _h;

      cells.free();
      cells.alloc(grid_w * grid_h);
      int y = 0;
      loop(grid_h)
      {
         int x = 0;
         loop(grid_w)
         {
            Cell cell <= new Cell;
            cell.init(x++, y);
            cells.add(#(deref cell));
         }
         y++;
      }
      // trace "xxx ===================== reset: cells="+#(cells);
      canvas.init(grid_w, grid_h);
   }

   public method reset() {

      allocCellsAndCanvas(reset_grid_w, reset_grid_h);

      nodes.free();
      edges.free();
      graphs.free();
      next_node_serial = 0;
      anchor_node <= null;
      anchor_id   <= null;

      initial_col_spacing  = DEF_CELL_SPACING;
      initial_row_spacing  = DEF_CELL_SPACING;
      b_head_first         = false;
      b_flip_x_opt         = false;
      b_flip_y_opt         = false;
      b_rotate             = false;
      b_zero_margin        = true;
   }

   public method addLayoutRow(GR _gr, String _s) {
      if(b_gr_debug3)
         trace "[trc] addLayoutRow: s=\""+_s+"\"";
      layout_rows.add(_s);

      // (note) always split row strings into array of StringArrays
      boolean bTable = isTable();
      if(null == table_layout_rows)
         table_layout_rows <= new PointerArray;

      // lazy-add nodes
      int gridX = 0;
      boolean bFirst = true;
      local StringArray *idWords;  // table mode

      if(_s & "|")
      {
         idWords <= _s.splitChar('|');
         table_layout_rows.add(#(deref idWords));
         String *sId;
         Node *n;
         Node *nWhitespaceHelper;
         // trace "xxx idWords="+#(idWords);
         if(null != idWords && idWords.numElements > 0)
         {
            // node1|node2
            // node3|node4|node5
            // node6|
            if(_s >= '|' && 1 == idWords.numElements)
            {
               // node6|
               idWords.empty();
               String t <= idWords.first;
               t.replace("|","");
            }
            foreach sId in idWords
            {
               boolean bBlank = sId.isBlank();
               if(!bBlank)
               {
                  if(null == findNode(sId))
                  {
                     if(b_gr_debug3) trace "[trc] addLayoutRow: add implicit node '"+sId+"'";
                     if("#" == sId)
                        n <= addNode("#"+gridX+","+(table_layout_rows.numElements-1));  // anonymous Spacer helper node
                     else
                        n <= addNode(sId);
                     n.copyGRStyleClassAttribs(_gr.cur_node_style);
                     n.copyGRAttribsIfNotExistsExcept(gr_attribs, Graph.a_node_inherit_from_graph_except);
                  }
                  bFirst = false;
                  gridX++;
               }
               else if(bTable && bBlank)
               {
                  if(bFirst)
                  {
                     // add whitespace helper node
                     nWhitespaceHelper <= addNode("_");
                     nWhitespaceHelper.table_span_x = 0;
                     nWhitespaceHelper.table_span_y = layout_rows.numElements - 1;
                     nWhitespaceHelper.table_span_w = gridX;
                  }
                  gridX++;
               }
            }
         }
      }
      else
      {
         idWords <= new StringArray;
         table_layout_rows.add(#(deref idWords));
         // trace "xxx addLayoutRow: s=\""+_s+"\"";

         loop(_s.numChars)
         {
            char c = _s.getc(gridX);
            sId <= tcchar(c);

            if(c > ' ')
            {
               if(null == findNode(sId))
               {
                  if(b_gr_debug3)
                     trace "[trc] addLayoutRow: add implicit node '"+sId+"'";
                  if("#" == sId)
                     sId <= "#"+gridX+","+(table_layout_rows.numElements-1);  // anonymous Spacer helper node
                  n <= addNode(sId);
                  // trace "xxx   n.id="+n.id+" sId='"+sId+"'";
                  n.copyGRStyleClassAttribs(_gr.cur_node_style);
                  n.copyGRAttribsIfNotExistsExcept(gr_attribs, Graph.a_node_inherit_from_graph_except);
               }
               bFirst = false;
            }
            else if(bTable && ' ' == c)
            {
               if(bFirst)
               {
                  // add whitespace helper node
                  nWhitespaceHelper <= addNode("_");
                  nWhitespaceHelper.table_span_x = 0;
                  nWhitespaceHelper.table_span_y = layout_rows.numElements - 1;
                  nWhitespaceHelper.table_span_w = gridX;
               }
            }

            idWords.add(sId);
            gridX++;
         }
      }
      // debugPrintNodes();
   }

   protected method getLayoutRowCell(int _x, int _y) : String {
      if(0 <= _y < table_layout_rows.numElements)
      {
         StringArray aRow <= table_layout_rows[_y];
         if(0 <= _x < aRow.numElements)
            return aRow[_x];
      }
      return "";
   }

   protected method clearLayoutRowCell(int _x, int _y) {
      // trace "xxx clearLayoutCell("+_x+","+_y+")";
      if(0 <= _y < table_layout_rows.numElements)
      {
         StringArray aRow <= table_layout_rows[_y];
         if(0 <= _x < aRow.numElements)
            aRow[_x] = "";
      }
   }

   protected method getLayoutRowMaxWidth() : int {
      int r = 0;
      StringArray *a;
      foreach a in table_layout_rows
         r = mathMaxi(r, a.numElements);
      return r;
   }

/*
               if(null == n)
               {
                  if(b_gr_debug) trace "[~~~] Graph::layoutFixedPlaceRowNodes: implicit node.id='"+sNodeId+"' declaration";
                  n <= addNode(sNodeId);
                  n.copyGRAttribsIfNotExistsExcept(gr_attribs, Graph.a_node_inherit_from_graph_except);
               }
*/

   public method findSpansFromLayoutRows() {
      if(null == table_layout_rows)
         return;
      int gridH = table_layout_rows.numElements;
      if(gridH > 0)
      {
         int gridW = getLayoutRowMaxWidth();
         if(b_gr_debug2)
            trace "[trc] Graph::findSpansFromLayoutRows: graph.id=\""+id+"\" gridW="+gridW+" gridH="+gridH;
         if(gridW > 0)
         {
            int gridY = 0;
            loop(gridH)
            {
               int gridX = 0;
               loop(gridW)
               {
                  String sCell <= getLayoutRowCell(gridX, gridY);
                  if(b_gr_debug3)
                     trace "[>>>] findSpansFromLayoutRows: grid=("+gridX+","+gridY+") sCell=\""+sCell+"\"";
                  if(!sCell.isBlank())
                  {
                     // find column and row span width / height
                     int spanMaxX = gridX;
                     int spanMaxY = gridY;
                     int spanY = gridY;
                     while(spanY < gridH)
                     {
                        int spanX = gridX;
                        while(spanX < gridW)
                        {
                           if(getLayoutRowCell(spanX, spanY) == sCell)
                           {
                              spanMaxX = spanX;
                              spanMaxY = spanY;
                              if(spanX > gridX || spanY > gridY)
                                 clearLayoutRowCell(spanX, spanY);
                           }
                           else
                              break;
                           spanX++;
                        }
                        spanY++;
                     }

                     if(spanMaxX > gridX || spanMaxY > gridY)
                     {
                        Node n <= findNode(sCell);
                        if(null != n)
                        {
                           int spanW = spanMaxX - gridX + 1;
                           if(spanW > 1)
                           {
                              if(!n.haveNodeAttrib("sw"))
                                 n.addNodeAttrib("sw", String(spanW));
                           }

                           int spanH = spanMaxY - gridY + 1;
                           if(spanH > 1)
                           {
                              if(!n.haveNodeAttrib("sh"))
                                 n.addNodeAttrib("sh", String(spanH));
                           }

                           if(b_gr_debug2)
                              trace "[>>>] findSpansFromLayoutRows: grid=("+gridX+","+gridY+") sCell=\""+sCell+"\" => spanW="+spanW+" spanH="+spanH+" n.isIO="+(null != n.parent_subgraph);
                        }
                        // else: quietly ignore non-existing node error (should not happen)
                     }
                  }

                  gridX++;
               }
               gridY++;
            }
         }
      }
   }

   public method isTable() : boolean {
      return (LAYOUT_TABLE == layout);
   }

   public method debugPrintTableSpanStarts() {
      Node *n;
      foreach n in nodes
      {
         if(n.table_span_w > 0)
         {
            String s; s.empty();
            Node c <= n;
            while(null != c)
            {
               s.append(c.id);
               c <= c.next_table_node;
            }
            trace "[trc] Graph::debugPrintTableSpanStarts: span start n"+n.getString()+" p=("+n.table_span_x+";"+n.table_span_y+") w="+n.table_span_w+" wSpc="+n.table_span_w_spc+" span="+s;
         }
      }
   }

   public method getIONode() : Node {
      // trace "xxx getIONode: io_node="+#(io_node);
      if(null == io_node)
      {
         io_node <= new Node;
         io_node.init(id);
         io_node.parent_subgraph <= this;
         io_node.orig_graph <= this;
      }
      return io_node;
   }

   public method findTopLeftNode() : Node {
      Node *n;
      local Node *nBest;
      local int   xBest = 9999;
      local int   yBest = 9999;
      foreach n in nodes
      {
         Cell c <= n.cell;
         // trace "xxx findTopLeftNode:"/* n="+#(n)+" */"gridsz=("+grid_w+","+grid_h+") try c="+GetCellString(c);
         if(null != c)
         {
            if(c.x < xBest && c.y < yBest)
            {
               xBest = c.x;
               yBest = c.y;
               nBest <= n;
            }
         }
      }
      return nBest;
   }

   public method setAnchor(Node _n) {
      anchor_node <= _n;
   }

   public method getAnchor() : Node {
      if(null == anchor_node)
      {
         if(null != anchor_id)
         {
            if(b_gr_debug2) trace "[trc] getAnchor: resolve anchor_id=\""+anchor_id+"\"";
            anchor_node <= findNode(anchor_id);
            if(null == anchor_id)
               throw GraphError "getAnchor: failed to resolved anchor_id='"+anchor_id+"'";
         }
         else
         {
            anchor_node <= findTopLeftNode();
            if(b_gr_debug2) trace "[trc] findTopLeftNode => anchor_node="+GetNodeString(anchor_node);
         }
      }
      return anchor_node;
   }

   protected method validateAnchor() : boolean {
      Node anc <= getAnchor();
      if(b_gr_debug3) trace "[trc] validateAnchor: anc="+GetNodeString(anc);
      if(nodes.containsPointer(anc))
      {
         if(null != anc.cell)
         {
            local BBox bb;
            findBBox(bb);
            if(b_gr_debug3) trace "[trc] validateAnchor: anc.cell.y="+anc.cell.y+" bb="+bb.getString();
            boolean bIgnoreTopBottomSide = 0;
            if(bIgnoreTopBottomSide || anc.cell.y == bb.miny)
            {
               return true;
            }
            else if(anc.cell.y == bb.maxy)
            {
               if(b_gr_debug3) trace "[trc] validateAnchor: flipY()";
               flipY();
               return true;
            }
            else
            {
               throw GraphError "validateAnchor: graph \""+id+"\" anchor"+anc.getString()+" is not located on the top or bottom side";
            }
         }
         else
         {
            throw GraphError "validateAnchor: graph \""+id+"\" anchor"+anc.getString()+" is not assigned to a cell";
         }
      }
      else
      {
         debugPrintNodes();
         throw GraphError "validateAnchor: graph \""+id+"\" anchor="+GetNodeString(anc)+" does not belong to this graph";
      }
   }

   public method addNode(String _id) : Node {
      local Node n;
      n.init(/*nodes.numElements, */_id);
      n.orig_graph <= this;
      nodes.add(#(deref n));
      return n;
   }

   public method addNodeHelper() : Node {
      local Node n;
      n.initHelper();
      n.orig_graph <= this;
      nodes.add(#(deref n));
      return n;
   }

   public method findNode(String _id) : Node {
      Node *n;
      // trace "xxx findNode("+_id+")";
      foreach n in nodes
      {
         if(n.id == _id)
         {
            if(null != n.unfolded_anchor)
            {
               // (note) not reached ? (edges are added before layouting/unfolding)
               if(b_gr_debug || b_gr_parse_debug)
                  trace "[dbg] redirect unfolded graph.id="+id+" io_node.id="+_id+" to anchor.id="+GetNodeString(n.unfolded_anchor);
               return n.unfolded_anchor;  // e.g. 'k' replaces 'A' in test22.gr
            }
            // trace "xxx   => n="+GetNodeString(n);
            return n;
         }
      }
      // trace "xxx   => n=null";
      return null;
   }

   public method renameLayoutRowNodeRefs(String _oldId, String _newId) {
      if(b_gr_debug3) trace "[trc] renameLayoutRowNodeRefs: oldId='"+_oldId+"' newId='"+_newId+"' table_layout_rows="+#(table_layout_rows);
      if(null != table_layout_rows)
      {
         StringArray *a;
         foreach a in table_layout_rows
         {
            int gridX = 0;
            loop(a.numElements)
            {
               if(a[gridX] == _oldId)
                  a[gridX] = _newId;
               gridX++;
            }
         }
      }
   }

   public method recursiveFindNodeByPathRel(local StringArray _aPath) : Node {
      local Node *n;
      local Graph *g;
      local Graph *sg;
      local Node *r;
      local String sPathLast <= _aPath.last;
      // trace "xxx recursiveFindNodeByPathRel: path="+#(_aPath)+" sPathLast=\""+sPathLast+"\"";
      local boolean bDebug = false;
      foreach n in nodes
      {
         // if(n.id == sPathLast) trace "xxx recursiveFindNodeByPathRel: try this.id="+id+" n.id="+n.id+" n.parent_subgraph="+#(n.parent_subgraph);
         g <= n.parent_subgraph;  // io node ?
         if(null == g)
         {
            // trace "xxx    n.orig_graph="+#(n.orig_graph);
            g <= n.orig_graph;
            // // if(null != g)
            // //    if(n.id == sPathLast) trace "xxx    n.orig_graph.id="+n.orig_graph.id;
         }
         if(n.id == sPathLast)
         {
            // trace "xxx    sPathLast matches parent g="+#(g);
            if(_aPath.numElements >= 2)
            {
               if(null != g)
               {
                  int pathIdx = _aPath.numElements - 2;
                  sg <= g;
                  loop(_aPath.numElements - 1)
                  {
                     // trace "xxx    compare g.id="+g.id+" == "+_aPath[pathIdx];
                     if(sg.id != _aPath[pathIdx])
                        break;
                     // graph id matches subpath element => continue with next path element
                     sg <= sg.parent_graph;
                     if(null == sg)
                        break;
                     pathIdx--;
                  }

                  if(-1 == pathIdx)
                  {
                     // Current node subpath matches
                     return n;
                  }
                  // else: Current node subpath does not match => try next node
               }
               // else: current node has no parent graph but path has two or more elements => try next node
            }
            else
            {
               // Single-element subpath => matches
               return n;
            }
         }
         // else current node id does not match last path element => try next node

         if(null != g && @(g) != @(this))
         {
            r <= g.recursiveFindNodeByPathRel(_aPath);
            if(null != r)
               return r;
         }

         // Next node
      }
      return null;
   }

   public method replaceNode(Node _nOld, Node _nNew) {
      Edge *e;
      foreach e in edges
         e.replaceNode(_nOld, _nNew);
   }

   public method removeNode(Node _n) {
      if(b_gr_debug3) trace "[trc] Graph::removeNode n"+_n.getString();
      if(b_gr_debug4) Graph.Backtrace();
      nodes.remove(_n);
   }

   public method addEdge(Node _tail, Node _head) : Edge {
      local Edge e;
      if(_tail instanceof Graph)
      {
         Graph gtail <= _tail;
         _tail <= gtail.getIONode();
      }
      if(_head instanceof Graph)
      {
         Graph ghead <= _head;
         _head <= ghead.getIONode();
      }
      e.init(_tail, _head);
      edges.add(#(deref e));
      return e;
   }

   public method addEdgeRev(Node _tail, Node _head) : Edge {
      Edge e <= addEdge(_tail, _head);
      e.b_rev = true;
      return e;
   }

   public method removeEdge(Edge _e) {
      edges.remove(_e);
   }

   public method addGraph(String _id) : Graph {
      local Graph g;
      // // g.init(DEF_GRID_W, DEF_GRID_H);
      g.init(reset_grid_w, reset_grid_h);  // [18Feb2025] inherit from parent graph
      g.id = _id;
      // trace "xxx addGraph: g.id="+g.id+" dbg="+#(g.id);
      g.parent_graph <= this;
      g.reset();
      graphs.add(#(deref g));
      nodes.add(g.getIONode());
      return g;
   }

   static Backtrace() {
      try { throw UncriticalError("debug/backtrace"); } catch(UncriticalError e) { trace e.stackTrace; }
   }

   public static GetEdgeString(Edge _eOrNull) : String {
      if(null != _eOrNull)
         return _eOrNull.getString();
      return "<null>";
   }

   public static GetNodeString(Node _nOrNull) : String {
      if(null != _nOrNull)
         return _nOrNull.getString();
      return "<null>";
   }

   public static GetCellString(Cell _cOrNull) : String {
      if(null != _cOrNull)
         return _cOrNull.getString();
      return "<null>";
   }

   public method setCell(int _x, int _y, Node _n) : Cell {
      if(b_gr_debug2) trace "[trc] setCell("+_x+";"+_y+")="+_n.id;
      if(_x >= grid_w || _y >= grid_h)
      {
         throw GraphError "setCell("+_x+","+_y+") n.id="+_n.id+" out of bounds";
      }
      Cell c <= cells[(_y * grid_w) + _x];
      c.node <= _n;
      _n.cell <= c;
      return c;
   }

   public method getCell(int _x, int _y) : Cell {
      if(_x >= grid_w || _y >= grid_h)
      {
         throw GraphError "getCell("+_x+","+_y+") out of bounds";
      }
      Cell c <= cells[(_y * grid_w) + _x];
      return c;
   }

   protected method swapCells(int _srcX, int _srcY,
                              int _dstX, int _dstY
                              ) {
      Cell cSrc <= getCell(_srcX, _srcY);
      Cell cDst <= getCell(_dstX, _dstY);

      Node nSrc <= cSrc.node;
      Node nDst <= cDst.node;

      if(null != nSrc)
         nSrc.cell <= cDst;

      if(null != nDst)
         nDst.cell <= cSrc;

      if(b_gr_debug) trace "[trc] swapCells(src="+_srcX+","+_srcY+" dst="+_dstX+","+_dstY+"): dst node="+GetNodeString(nSrc);

      cSrc.node <= nDst;
      cDst.node <= nSrc;
   }

   public method isCellEmpty(int _x, int _y) : boolean {
      Cell c <= getCell(_x, _y);
      return (null == c.node);
   }

   public method isCellEmptyCheckEdgeCrossing(int _x, int _y) : boolean {
      Cell c <= getCell(_x, _y);
      if(null != c.node)
         return false;
      if(anyEdgeCrossesRect(_x, _y, 1, 1))
         return false;
      return true;
   }

   protected method layoutGridInitial() {
      Edge *e;
      int curX = 0;
      int curY = 0;
      int startX;
      if(b_start_at_center)
      {
         startX = grid_w / 2;
         curX = startX;
         curY = grid_h / 2;
      }
      else
      {
         startX = 0;
         curX   = 0;
         curY   = 0;
      }

      foreach e in edges
      {
         if(!e.b_cyclic)
         {
            Node ntail <= e.tail;
            Node nhead <= e.head;

            if(null != nhead.cell)
            {
               if(null != ntail.cell)
               {
                  // both head+tail have already been placed => swap head/tail and edge-direction if head occured before tail
                  if(nhead.serial < ntail.serial)
                  {
                     e.head <= ntail;
                     e.tail <= nhead;
                     e.b_rev = true;
                  }
               }
               else
               {
                  // from unplaced to already-placed node => swap head/tail and edge direction
                  e.tail <= nhead;
                  e.head <= ntail;
                  e.b_rev = true;
               }
            }

            if(b_head_first)
            {
               // trace "xxx ntail.id="+ntail.id+" nhead.id="+nhead.id;
               if(null == nhead.cell)
               {
                  nhead.serial = ++next_node_serial;
                  setCell(curX, curY, nhead);

                  if(nhead.b_line_break)
                  {
                     curX  = startX;
                     curY += initial_row_spacing;
                  }
                  else
                  {
                     curX += initial_col_spacing;
                  }
               }

               if(null == ntail.cell)
               {
                  ntail.serial = ++next_node_serial;
                  setCell(curX, curY, ntail);

                  if(ntail.b_line_break)
                  {
                     curX  = startX;
                     curY += initial_row_spacing;
                  }
                  else
                  {
                     curX += initial_col_spacing;
                  }
               }
            }
            else
            {
               // trace "xxx ntail.id="+ntail.id+" nhead.id="+nhead.id;
               if(null == ntail.cell)
               {
                  ntail.serial = ++next_node_serial;
                  setCell(curX, curY, ntail);

                  if(ntail.b_line_break)
                  {
                     curX  = startX;
                     curY += initial_row_spacing;
                  }
                  else
                  {
                     curX += initial_col_spacing;
                  }
               }

               if(null == nhead.cell)
               {
                  nhead.serial = ++next_node_serial;
                  setCell(curX, curY, nhead);

                  if(nhead.b_line_break)
                  {
                     curX  = startX;
                     curY += initial_row_spacing;
                  }
                  else
                  {
                     curX += initial_col_spacing;
                  }
               }
            }
         }

      }
   }

   protected method isCellColEmpty(int _x) : boolean {
      // trace "xxx isCellColEmpty("+_x+")";
      if(_x < grid_w)
      {
         int j = _x;
         loop(grid_h)
         {
            Cell c <= cells.get(j);
            if(!c.isEmpty())
               return false;
            j += grid_w;
         }
      }
      else
      {
         throw GraphError "isCellColEmpty("+_x+"): out of bounds";
      }
      return true;
   }

   protected method isCellRowEmpty(int _y) : boolean {
      // trace "xxx isCellRowEmpty("+_y+")";
      if(_y < grid_h)
      {
         int j = (grid_w * _y);
         loop(grid_w)
         {
            Cell c <= cells.get(j++);
            if(!c.isEmpty())
               return false;
         }
      }
      else
      {
         throw GraphError "isCellRowEmpty("+_y+"): out of bounds";
      }
      return true;
   }

   protected method isCellRowEmptyAfter(int _x, int _y) : boolean {
      if(b_gr_debug) trace "[trc] isCellRowEmptyAfter("+_x+","+_y+")";
      int x = _x + 1;
      if(x < grid_w)
      {
         if(_y < grid_h)
         {
            int j = (grid_w * _y) + x;
            while(x++ < grid_w)
            {
               Cell c <= cells.get(j++);
               if(!c.isEmpty())
                  return false;
            }
         }
         else
         {
            throw GraphError "isCellRowEmptyAfter("+_x+","+_y+"): y out of bounds";
         }
      }
      else
      {
         throw GraphError "isCellRowEmptyAfter("+_x+","+_y+"): x+1 out of bounds";
      }
      return true;
   }

   protected method anyEdgeCrossesRect(int _x, int _y, int _w, int _h) : boolean {
      // Check edge crossing
      Edge *e;
      foreach e in edges
      {
         Cell ctop    <= e.getTopCell();
         Cell cbottom <= e.getBottomCell();
         if(null != ctop && null != cbottom)  // null after sub graph unfolding, ignore
         {
            if(ctop.y < _y && cbottom.y >= (_y + _h))
            {
               if( (_x <= ctop.x    < (_x+_w)) ||
                   (_x <= cbottom.x < (_x+_w))
                   )
                  return true;
            }
         }
      }
      return false;
   }

   protected method isCellRectEmpty(int _x, int _y, int _w, int _h) : boolean {
      if(b_gr_debug3) trace "[trc] isCellRectEmpty("+_x+","+_y+" "+_w+","+_h+")";
      int y = _y;
      loop(_h)
      {
         int x = _x;
         loop(_w)
         {
            if(!isCellEmpty(x++, y))
               return false;
         }
         y++;
      }

      return true;
   }

   protected method isCellRectEmptyWithEdgeCrossings(int _x, int _y, int _w, int _h) : boolean {
      if(b_gr_debug3) trace "[trc] isCellRectEmptyWithEdgeCrossings("+_x+","+_y+" "+_w+","+_h+")";
      if(isCellRectEmpty(_x, _y, _w, _h))
      {
         if(anyEdgeCrossesRect(_x, _y, _w, _h))
            return false;
         return true;
      }
      return false;
   }

   protected method moveCellCol(int _fromX, int _toX,
                                int _minY, int _maxY
                                ) {
      int y = _minY;
      while(y <= _maxY)
      {
         Cell cSrc <= getCell(_fromX, y);
         Cell cDst <= getCell(_toX,   y);
         cDst.moveFrom(cSrc);
         y++;
      }
   }

   protected method moveCellRow(int _fromY, int _toY,
                                int _minX, int _maxX
                                ) {
      int x = _minX;
      while(x <= _maxX)
      {
         Cell cSrc <= getCell(x, _fromY);
         Cell cDst <= getCell(x, _toY);
         cDst.moveFrom(cSrc);
         x++;
      }
   }

   protected method moveCellRectUp(int _srcX, int _srcY, int _w, int _h) {
      // (note) caller must ensure that 'w' cols in row above srcY are empty
      if(b_gr_debug2) trace "[trc] moveCellRectUp: src=("+_srcX+","+_srcY+") sz=("+_w+","+_h+")";
      int dstX = _srcX;
      int dstY = _srcY - 1;
      int y = 0;
      loop(_h)
      {
         int x = 0;
         loop(_w)
         {
            moveCellXY(_srcX + x, _srcY + y,
                        dstX + x,  dstY + y
                       );
            x++;
         }
         y++;
      }
   }

   protected method insertEmptyCellRect(int _x, int _y, int _w, int _h) {
      int srcX = grid_w - _w;
      int srcY = grid_h - _h;
      if(isCellRectEmptyWithEdgeCrossings(srcX, srcY, _w, _h))
      {
         // Move cols and make room (x)
         int x = srcX;
         while(x > _x)
         {
            moveCellCol(x - 1, x,
                        0, grid_h - 1
                        );

            x--;
         }

         // Move rows and make room (y)
         int y = srcY;
         while(y > (_y+1))
         {
            moveCellRow(y - 1, y,
                        0, grid_w - 1
                        );

            y--;
         }

      }
      else
         throw GraphError "insertEmptyCellRect("+_x+","+_y+" "+_w+","+_h+"): shift out of bounds (gridsz=("+grid_w+","+grid_h+"))";
   }

   protected method flipCellRectH(int _srcX, int _srcY, int _w, int _h,
                                  int _dstX, int _dstY
                                  ) {
      int y = 0;
      loop(_h)
      {
         int x = 0;
         loop(_w)
         {
            swapCells(_srcX + x, _srcY + y,
                      _dstX + _w - 1 - x,
                      _dstY + y
                      );
            x++;
         }
         y++;
      }
   }

   protected method flipCellRectUp(int _srcX, int _srcY, int _w, int _h,
                                   int _dstX, int _dstY
                                   ) {
      //        c d
      // a b => a b
      // c d
      //
      int y = 1;
      loop(_h - 1)
      {
         int x = 0;
         loop(_w)
         {
            swapCells(_srcX + x, _srcY + y,
                      _dstX + x,
                      _dstY - y
                      );
            x++;
         }
         y++;
      }
   }

   protected method moveNodeDown(Node _n) {
      Cell cOrig <= _n.cell;
      int cellY = cOrig.y + 1;
      while(!isCellRowEmpty(cellY))
         cellY++;
      Cell cNew <= getCell(cOrig.x, cellY);
      if(!cNew.isEmpty())
      {
         trace "[!!!] moveNodeDown: cell("+cNew.x+","+cNew.y+") not empty";
         throw GraphError "moveNodeDown: cell("+cNew.x+","+cNew.y+") not empty";
      }
      cOrig.node <= null;
      _n.cell <= cNew;
      cNew.node <= _n;
   }

   protected method insertHelperNodeAndEdges(Edge _e, int _helperX, int _helperY) : Edge {
      Node ntail <= _e.tail;
      Node nhead <= _e.head;

      if(b_gr_debug2) trace "[trc] insertHelperNodeAndEdges: hpos=("+_helperX+","+_helperY+") cur ntail"+ntail.getString()+" nhead"+nhead.getString();

      Node nhelper <= addNodeHelper();
      _e.head <= nhelper;
      Edge ehelperhead <= addEdge(nhelper, nhead);
      ehelperhead.b_rev = _e.b_rev;
      if(!isCellEmpty(_helperX, _helperY))
      {
         throw GraphError "insertHelperNodeAndEdges: cell("+_helperX+","+_helperY+") not empty";
      }
      setCell(_helperX, _helperY, nhelper);
      return ehelperhead;
   }

   protected method moveCellXY(int _srcX, int _srcY,
                               int _dstX, int _dstY
                               ) {
      Cell cSrc <= getCell(_srcX, _srcY);
      Cell cDst <= getCell(_dstX, _dstY);
      cDst.moveFrom(cSrc);
   }

   protected method moveCellLeft(Cell _c, Cell _l) {
      // (note) 'c' is not empty, 'l' is empty
      Node n <= _c.node;
      if(b_gr_debug3) trace "[trc] moveCellLeft: c"+n.getString()+" => l("+_l.x+","+_l.y+")";
      _c.node <= null;
      _l.node <= n;
      n.cell <= _l;
   }

   protected method moveCellUp(Cell _c, Cell _u) {
      // (note) 'c' is not empty, 'u' is empty
      Node n <= _c.node;
      if(b_gr_debug2) trace "[trc] moveCellUp: c"+n.getString()+" => u("+_u.x+","+_u.y+")";
      _c.node <= null;
      _u.node <= n;
      n.cell <= _u;
   }

   protected method isCellEdgeConstrainedH(Cell _c) : boolean {
      Edge *e;
      Node n <= _c.node;
      if(null != n && n.usesFixedLayout())
         return true;

      foreach e in edges
      {
         Node ntail <= e.tail;
         Node nhead <= e.head;

         Cell ctail <= ntail.cell;
         Cell chead <= nhead.cell;

         if(ctail.x == _c.x)
         {
            if(chead.x == ctail.x)
               return true;
         }
      }
      return false;
   }

   protected method isCellEdgeConstrainedV(Cell _c, boolean _bPass1) : boolean {
      Edge *e;
      Node n <= _c.node;
      if(null != n && n.usesFixedOrTableLayout())
         return true;

      foreach e in edges
      {
         Node ntail <= e.tail;
         Node nhead <= e.head;

         if(@(ntail) == @(n) || (@(nhead) == @(n)))
         {
            Cell ctail <= ntail.cell;
            Cell chead <= nhead.cell;

            if(ctail.y == _c.y)
            {
               if(chead.y == _c.y)
               {
                  if(_bPass1 || !areCellsEmptyBetween(chead.x, ctail.x, _c.y))
                     return true;
               }
            }
         }
      }
      return false;
   }

   protected method isCellEdgeConstrainedVBiDir(Cell _c, boolean _bPass1) : boolean {
      Edge *e;
      Node n <= _c.node;
      foreach e in edges
      {
         Node ntail <= e.tail;
         Node nhead <= e.head;

         if(@(ntail) == @(n) || (@(nhead) == @(n)))
         {
            Cell ctail <= ntail.cell;
            Cell chead <= nhead.cell;

            if(ctail.y == _c.y)
            {
               if(chead.y == _c.y)
               {
                  if(_bPass1)
                     return true;

                  if(!areCellsEmptyBetween(chead.x, ctail.x, _c.y))
                     return true;

                  // Any other edge that connects to cell.node on same level ?
                  Node nOther <= e.getOtherNode(n);
                  // Edge eOther <= findOtherEdgeToOnSameLevel(nOther, n/*notN*/);
                  Edge eOther <= findOtherEdgeToOnSameLevel(n, nOther/*notN*/);
                  if(b_gr_debug3) trace "[trc] isCellEdgeConstrainedVBiDir: "+_c.getString()+" findOtherEdgeToOnSameLevel(n"+n.getString()+" nOther"+nOther.getString()+")=> eOther="+GetEdgeString(eOther);
                  if(null != eOther)
                     return true;
               }
            }
         }
      }
      return false;
   }

   protected method collapseEmptyCellsH(boolean _bAllowCollapseMainRow, BBox _bb) {
      int y = _bb.miny;
      while(y <= _bb.maxy)
      {
         if(_bAllowCollapseMainRow || y > _bb.miny)
         {
            boolean bMoved;
            do
            {
               bMoved = false;

               int x = _bb.minx;
               while(x <= _bb.maxx)
               {
                  Cell c <= getCell(x, y);
                  if(!c.isEmpty())
                  {
                     if(x > _bb.minx)
                     {
                        if(b_gr_debug3) trace "[trc] collapseEmptyCellsH: try "+c.getString();
                        Cell l <= getCell(x-1, y);
                        if(l.isEmpty())
                        {
                           if(b_gr_debug3) trace "[trc] isCellEdgeConstrainedH("+c.x+","+c.y+")="+isCellEdgeConstrainedH(c);
                           if(!isCellEdgeConstrainedH(c))
                           {
                              moveCellLeft(c, l);
                              bMoved = true;
                              x--; // keep x
                           }
                        }
                        else
                        {
                           if(b_gr_debug3) trace "[trc]    => l"+l.getString()+" is not empty";
                        }
                     }
                  }
                  x++;
               }
            } while(bMoved);
         }
         y++;
      }
   }

   protected method collapseGapsBetweenEdgeNodesH() {
      // (note) move nodes right
      Edge *e;
      boolean bMoved;
      do
      {
         bMoved = false;
         foreach e in edges
         {
            Node ntail <= e.tail;
            Node nhead <= e.head;

            Cell ctail <= ntail.cell;
            Cell chead <= nhead.cell;
            Cell *cNew;

            if(ctail.y == chead.y)
            {
               int distX;
               if(chead.x > ctail.x)
               {
                  distX = chead.x - ctail.x;
                  if(distX > 1)
                  {
                     if(!isCellEdgeConstrainedH(ctail))  // can move tail ?
                     {
                        ctail.node <= null;
                        cNew <= getCell(chead.x - 1, chead.y);
                        ntail.cell <= cNew;
                        cNew.node <= ntail;
                        bMoved = true;
                     }
                  }
               }
               else  // tail > head
               {
                  distX = ctail.x - chead.x;
                  if(distX > 1)
                  {
                     if(!isCellEdgeConstrainedH(chead))  // can move head ?
                     {
                        chead.node <= null;
                        cNew <= getCell(ctail.x - 1, ctail.y);
                        nhead.cell <= cNew;
                        cNew.node <= nhead;
                        bMoved = true;
                     }
                  }
               }
            } // if same level
         } // iterate edges
      }
      while(bMoved);
   }

   protected method canMoveNodeUp(Node _n) : boolean {
      Cell c <= _n.cell;
      return (null != c) && (c.y > 0) && isCellEmpty(c.x, c.y-1);
   }

   protected method canMoveConnectedRowChainUp(Cell _c) : boolean {
      if(_c.y > 0)
      {
         Node nRef <= _c.node;
         Node *n;
         Edge *e;
         Node *nDirect;

         // Find all (horizontal) edges that directly connect to 'nref' (c.node)
         local Edge *[] edgeCandidatesDirect;
         foreach e in edges
         {
            if(e.connectsToOnSameLevel(nRef))
            {
               nDirect <= e.getOtherNode(nRef);
               if(canMoveNodeUp(nDirect))
                  edgeCandidatesDirect.add(e);
               else
                  return false;
            }
         }

         // Iterate all (horizontal) edges that connect to any of the direct edgeCandidates
         Edge *eDirect;
         foreach eDirect in edgeCandidatesDirect
         {
            nDirect <= eDirect.getOtherNode(nRef);
            foreach e in edges
            {
               if(e.connectsToOnSameLevel(nDirect))
               {
                  Node nOther <= e.getOtherNode(nDirect);
                  if(!canMoveNodeUp(nOther))
                     return false;
               }
            }
         }

         return true;
      }
      return false;
   }

   protected method collapseEmptyCellsV(boolean _bPass1, BBox _bb) {
      int x = _bb.minx;
      while(x <= _bb.maxx)
      {
         boolean bMoved;
         do
         {
            bMoved = false;

            int y = _bb.miny;
            while(y <= _bb.maxy)
            {
               Cell c <= getCell(x, y);
               if(!c.isEmpty())
               {
                  if(y > _bb.miny)
                  {
                     Cell u <= getCell(x, y-1);
                     if(u.isEmpty())
                     {
                        boolean bConstrained = isCellEdgeConstrainedVBiDir(c, _bPass1);  // (todo) remove ?
                        if(b_gr_debug3) trace "[trc] isCellEdgeConstrainedVBiDir<pass="+(_bPass1?"1":"2")+">"+c.getString()+"="+bConstrained;
                        if(!bConstrained)
                        {
                           // can move entire connected 'c' node-chain row up ?
                           if(canMoveConnectedRowChainUp(c))
                           {
                              if(_bPass1 || isCellRowEmptyAfter(x, y-1))
                              {
                                 moveCellUp(c, u);
                                 bMoved = true;
                                 y--; // keep y
                              }
                           }
                        }
                     }
                  }
               }
               y++;
            }
         } while(bMoved);
         x++;
      }
   }

   protected method findNextEdgeForHelperTailNode(Node _nHelper) : Edge {
      // find edge that connects nHelper (tail) to next head node (always exists and always unique)
      Edge *e;
      foreach e in edges
      {
         if(@(e.tail) == @(_nHelper))
            return e;
      }
      throw GraphError "findNextEdgeForHelperTailNode: should not be reachable. nHelper="+#(_nHelper);
   }

   protected method deleteHelperEdgeAndHeadNode(Edge _e) {
      if(b_gr_debug3) trace "[trc] deleteHelperEdgeAndHeadNode: e="+_e.getString();
      // (note) e.tail and e.head are both helper nodes. replace eNext.tail (==e.head) by e.tail and remove 'e' and 'e.head'.
      Node nhelper <= _e.head;
      Edge eNext <= findNextEdgeForHelperTailNode(nhelper);  // => eNext.tail == nhelper
      Node netail <= _e.tail;
      eNext.tail <= netail;
      Cell chelper <= nhelper.cell;
      chelper.node <= null;
      // Cell cetail <= netail.cell;
      // cetail.node

      removeEdge(_e);
      removeNode(nhelper);
   }

   protected method findPreviousEdgeForHelperHeadNode(Node _nHelper) : Edge {
      // find edge that connects nHelper (head) to prev tail node (always exists and always unique)
      Edge *e;
      foreach e in edges
      {
         if(@(e.head) == @(_nHelper))
            return e;
      }
      throw GraphError "findPreviousEdgeForHelperHeadNode: should not be reachable. nHelper="+#(_nHelper);
   }

   protected method deleteHelperEdgeAndTailNode(Edge _e) {
      if(b_gr_debug3) trace "[trc] deleteHelperEdgeAndTailNode: e="+_e.getString();
      // (note) e.tail is helper node, e.head is regular node. replace ePrev.head (==e.tail) by e.head and remove 'e' and 'e.tail'
      Node nhelper <= _e.tail;
      Edge ePrev <= findPreviousEdgeForHelperHeadNode(nhelper);  // => ePrev.head == nhelper
      Cell chelper <= nhelper.cell;
      chelper.node <= null;
      ePrev.head <= _e.head;
      removeEdge(_e);
      removeNode(nhelper);
   }

   protected method helperNodeBelongsToEdge(Node _hHelper, Edge _e) : boolean {
      return true;
   }

   protected method getNumNodeEdgeRefs(Node _n) : int {
      Edge *e;
      int numRefs = 0;
      foreach e in edges
         if(e.connectsTo(_n))
            numRefs++;
      return numRefs;
   }

   protected method collapseRedundantEdgesAndNodesH(boolean _bAllowTailNode, boolean _bAllowCollapseMainRow, BBox _bb) : boolean {
      int numCollapsed = 0;
      boolean bCollapsed;
      do
      {
         bCollapsed = false;

         Edge *e;
         foreach e in edges
         {
            Node ntail <= e.tail;
            Node nhead <= e.head;

            Cell ctail <= ntail.cell;
            Cell chead <= nhead.cell;

            if(b_gr_debug4)
            {
               trace "[trc] collapseH<"+(_bAllowTailNode?"tail":"head")+": try tail="+ctail.getString()+".b_helper="+ntail.b_helper+" head="+chead.getString()+".b_helper="+nhead.b_helper+" isCellEdgeConstrainedH(chead)="+isCellEdgeConstrainedH(chead);
               trace "[trc]    areCellsEmptyBetween(ctail.x+1="+(ctail.x+1)+", chead.x-1="+(chead.x-1)+", chead.y="+chead.y+")="+areCellsEmptyBetween(ctail.x+1, chead.x-1, chead.y);
            }

               if(chead.x == ctail.x+1)  // orig
               // // if(chead.y==ctail.y && chead.x == ctail.x+1)
               // // if(chead.y==ctail.y && chead.x > ctail.x)
               // // if(chead.y==ctail.y && (areCellsEmptyBetween(chead.x+1, ctail.x-1, chead.y) || areCellsEmptyBetween(ctail.x+1, chead.x-1, chead.y)))  // [11Mar2024]
               // // if(chead.y == ctail.y && chead.x > ctail.x && areCellsEmptyBetween(ctail.x+1, chead.x-1, chead.y))  // [11Mar2024] test17
            {
               if(ntail.b_helper)
               {
                  if(nhead.b_helper)
                  {
                     if(ctail.y == chead.y && (_bAllowCollapseMainRow || ctail.y > _bb.miny))
                     {
                        // (todo) don't collapse when (last non-helper) head is edge-constrained
                        // /// if(!isCellEdgeConstrainedH(ctail))
                        if(b_gr_debug3) trace "[trc] deleteHelperEdgeAndHeadNode<head>: ctail("+ctail.x+","+ctail.y+") => chead("+chead.x+","+chead.y+")";
                        if(2 == getNumNodeEdgeRefs(nhead))
                        {
                           deleteHelperEdgeAndHeadNode(e);
                           bCollapsed = true;
                           numCollapsed++;
                           break;
                        }
                     }
                  }
                  else if(_bAllowTailNode && !isCellEdgeConstrainedH(chead))
                  {
                     if(ctail.y == chead.y && (_bAllowCollapseMainRow || ctail.y > _bb.miny))
                     {
                        // |.a>>b>>c>>d._________|
                        // |....v......._________|
                        // |___.v....____________|
                        // |___.*>>e.____________| ('e' is nhead)
                        if(b_gr_debug)
                           trace "[trc] deleteHelperEdgeAndTailNode<tail>: ntail"+ntail.getString()+" nhead"+nhead.getString()+" ctail("+ctail.x+","+ctail.y+") => chead("+chead.x+","+chead.y+")";
                        if(helperNodeBelongsToEdge(ntail, e))
                        {
                           if(2 == getNumNodeEdgeRefs(ntail))
                           {
       // return false;
                              deleteHelperEdgeAndTailNode(e);
                              bCollapsed = true;
                              numCollapsed++;
                              break;
                           }
                        }
                     }
                  }
               }
            }
         }
      } while(bCollapsed);

      return (numCollapsed > 0);
   }

   protected method collapseRedundantEdgesAndNodesV(boolean _bAllowTailNode) : boolean {
      int numCollapsed = 0;
      boolean bCollapsed;
      do
      {
         bCollapsed = false;

         Edge *e;
         foreach e in edges
         {
            Node ntail <= e.tail;
            Node nhead <= e.head;
            if(b_gr_debug4) trace "[trc] collapseRedundantEdgesAndNodesV: e="+e.getString();

            Cell ctail <= ntail.cell;
            Cell chead <= nhead.cell;

            if(b_gr_debug4) trace "[trc] collapseV<"+(_bAllowTailNode?"tail":"head")+": try tail"+ntail.getString()+".b_helper="+ntail.b_helper+" head"+nhead.getString()+".b_helper="+nhead.b_helper+" isCellEdgeConstrainedH(chead)="+isCellEdgeConstrainedH(chead);

            if(ntail.b_helper)
            {
               if(nhead.b_helper)
               {
                  if(ctail.x == chead.x)
                  {
                     // (todo) don't collapse when (last non-helper) head is edge-constrained
                     // ///if(!isCellEdgeConstrainedH(ctail))
                     if(b_gr_debug2) trace "[trc] deleteHelperEdgeAndHeadNode: ctail("+ctail.x+","+ctail.y+") => chead("+chead.x+","+chead.y+")";
                     deleteHelperEdgeAndHeadNode(e);
                     bCollapsed = true;
                     numCollapsed++;
                     break;
                  }
               }
               // // else if(_bAllowTailNode && !isCellEdgeConstrainedH(chead))
               // // {
               // //    trace "xxx deleteHelperEdgeAndTailNode: ctail("+ctail.x+","+ctail.y+") => chead("+chead.x+","+chead.y+")";
               // //    deleteHelperEdgeAndTailNode(e);
               // //    bCollapsed = true;
               // //    numCollapsed++;
               // //    break;
               // // }
            }
         }
      } while(bCollapsed);

      return (numCollapsed > 0);
   }

   protected method alignNodeYTo(local Node _n, local int _nYOld) {
      local Edge *e;
      local Cell c <= _n.cell;
      foreach e in edges
      {
         if(@(e.tail) == @(_n))
         {
            // after
            local Node nhead <= e.head;
            local Cell chead <= nhead.cell;
            if(chead.y == _nYOld)
            {
               chead.node <= null;
               local Cell cheadNew <= getCell(chead.x, c.y);
               if(!cheadNew.isEmpty())
               {
                  throw GraphError "alignNodeYTo<after>: cheadNew("+cheadNew.x+","+cheadNew.y+") not empty";
               }
               cheadNew.node <= nhead;
               nhead.cell <= cheadNew;
               alignNodeYTo(nhead, _nYOld);
            }
         }
         else if(@(e.head) == @(_n))
         {
            // before
            local Node ntail <= e.tail;
            if(ntail.b_helper)
            {
               local Cell ctail <= ntail.cell;
               if(ctail.y == _nYOld)
               {
                  ctail.node <= null;
                  local Cell ctailNew <= getCell(ctail.x, c.y);
                  if(!ctailNew.isEmpty())
                  {
                     throw GraphError "alignNodeYTo<before>: ctailNew("+ctailNew.x+","+ctailNew.y+") not empty";
                  }
                  ctailNew.node <= ntail;
                  ntail.cell <= ctailNew;
                  alignNodeYTo(ntail, _nYOld);
               }
            }
         }
      }
   }

   protected method areCellsEmptyBetween(int _startX, int _endX, int _y) {
      int x = _startX;
      while(++x < _endX)
         if(!isCellEmpty(x, _y))
            return false;
      return true;
   }

   protected method checkCollisionsAndMoveNodesDown(boolean _bAllowMoveHelper) : boolean {
      int numCollisions = 0;
      boolean bCollision;
      do
      {
         bCollision = false;
         Edge *e;
         foreach e in edges
         {
            Node ntail <= e.tail;
            Node nhead <= e.head;

            Cell ctail <= ntail.cell;
            Cell chead <= nhead.cell;

            if(!ntail.b_helper && !nhead.b_helper)
            {
               int distX = abs(chead.x - ctail.x);
               bCollision = (ctail.y == chead.y) && !areCellsEmptyBetween(ctail.x, chead.x, ctail.y);
               // if(distX > 1 && !bCollision)
               //    trace "xxx expected collision, distX="+distX+" ntail"+ntail.getString()+" <> nhead"+nhead.getString();
               bCollision |= (ctail.y != chead.y) && (distX > 1);
               if(bCollision)
               {
                  if(b_gr_debug2)
                     trace "[~~~] collision: distX="+distX+" ntail"+ntail.getString()+" <> nhead"+nhead.getString();

                  // move head node down
                  local int nheadOldY = nhead.cell.y;
                  moveNodeDown(nhead);

                  // move same-level nodes after nhead down to same y-level as nhead
                  alignNodeYTo(nhead, nheadOldY);

                  // // // // move same-level nodes before nhead down to same y-level as nhead
                  // // // alignNodeYTo(ntail, nheadOldY, nhead.cell.y);

                  // // create helper node + edges (fill)
                  // // int helperX = nhead.cell.x;
                  // // int helperY = nhead.cell.y;
                  // // while(distX-- > 0 && (nhead.cell.x > ntail.cell.x))
                  // // {
                  // //    helperX--;
                  // //    insertHelperNodeAndEdges(e, helperX, helperY);
                  // // }

                  // create helper node + edges (single)
                  int helperX = ntail.cell.x;
                  int helperY = nhead.cell.y;
                  insertHelperNodeAndEdges(e, helperX, helperY);

                  numCollisions++;
                  break;
               }
            }
            else if(_bAllowMoveHelper && ntail.b_helper && !nhead.b_helper)
            {
               // e.g. test13: b->*->e collides with c->*->e => move helper down and insert another helper below 'e'
               if(ctail.y == chead.y)
               {
                  if(!areCellsEmptyBetween(ctail.x, chead.x, ctail.y))
                  {
                     if(b_gr_debug) trace "[trc] checkCollisionsAndMoveNodesDown:  areCellsEmptyBetween returned false";
                     moveNodeDown(ntail);
                     Edge eHelper <= insertHelperNodeAndEdges(e, chead.x, ntail.cell.y);

                     numCollisions++;
                     bCollision = true;
                     break;
                  }
               }
               else
               {
                  // vertical helper node (inserted when ctail.y == chead.y)
                  // // throw GraphError "checkCollisionsAndMoveNodesDown: ntail"+ntail.getString()+".y != nhead"+nhead.getString()+".y";
               }

            }

         }
      } while(bCollision);

      return (numCollisions > 0 );
   }

   protected method collapseCellsAndRedundantEdgesH(boolean _bAllowCollapseMainRow) {
      local BBox bb;
      findBBox(bb);

      // iterate rows and collapse empty cells while maintaining minimum (x+y) dist
      collapseEmptyCellsH(_bAllowCollapseMainRow, bb);

      // iterate edges and collapse redundant horizontal helper edges and nodes
      if(collapseRedundantEdgesAndNodesH(false/*bAllowTailNodes*/, _bAllowCollapseMainRow, bb))
      {
         if(b_gr_debug) trace "[trc] call collapseEmptyCellsH<head> after edge removal";
         collapseEmptyCellsH(_bAllowCollapseMainRow, bb);
      }

      if(collapseRedundantEdgesAndNodesH(true/*bAllowTailNodes*/, _bAllowCollapseMainRow, bb))
      {
         if(b_gr_debug) trace "[trc] call collapseEmptyCellsH<tail> after edge removal";
         collapseEmptyCellsH(_bAllowCollapseMainRow, bb);
      }
   }

   protected method collapseCellsAndRedundantEdgesV(boolean _bPass1, BBox _bb) {
      // iterate rows and collapse empty cells while maintaining minimum (x+y) dist
      collapseEmptyCellsV(_bPass1, _bb);

      // iterate edges and collapse redundant vertical helper edges and nodes
      if(collapseRedundantEdgesAndNodesV(false/*bAllowTailNodes*/))
      {
         if(b_gr_debug) trace "[trc] call collapseEmptyCellsV<head> after edge removal";
         collapseEmptyCellsV(_bPass1, _bb);
      }

      if(collapseRedundantEdgesAndNodesV(true/*bAllowTailNodes*/))
      {
         if(b_gr_debug) trace "[trc] call collapseEmptyCellsV<tail> after edge removal";
         collapseEmptyCellsV(_bPass1, _bb);
      }
   }

   protected method shiftCellRowsLeftAt(int _x) : boolean {
      // (note) column 'x' is empty, shift all columns after that
      // (note) return true when any source node was != null
      boolean bAny = false;
      int x = _x + 1;
      int k = _x;
      int j =  x;

      loop(grid_h)
      {
         Cell cDst <= cells[k];
         Cell cSrc <= cells[j];

         Node n <= cSrc.node;
         cDst.node <= n;
         if(null != n)
         {
            if(b_gr_debug3) trace "[trc] shiftCellRowsLeftAt("+x+") n="+#(n);
            n.cell <= cDst;
            bAny = true;
         }
         cSrc.node <= null;

         k += grid_w;
         j += grid_w;
      }

      return bAny;
   }

   protected method removeEmptyCols(BBox bb) {
      if(!edges.isEmpty())
      {
         boolean bShifted;
         do
         {
            bShifted = false;
            int x = bb.minx;
            while(x < bb.maxx)
            {
               if(isCellColEmpty(x))
               {
                  // trace "xxx removeEmptyCols: x="+x;
                  bShifted |= shiftCellRowsLeftAt(x);
               }
               x++;
            }
         }
         while(bShifted);
      }
   }

   protected method shiftCellRowsUpAt(int _y) : boolean {
      // (note) row 'y' is empty, shift all rows after that
      // (note) return true when any source node was != null
      int k = _y * grid_w;
      int j =  k + grid_w;
      boolean bAny = false;
      while(j < cells.numElements)
      {
         Cell cDst <= cells[k++];
         Cell cSrc <= cells[j++];

         Node n <= cSrc.node;
         cDst.node <= n;
         // trace "xxx shiftCellRowsUpAt("+_y+") n="+#(n);
         if(null != n)
         {
            n.cell <= cDst;
            bAny = true;
         }
         cSrc.node <= null;
      }
      return bAny;
   }

   protected method removeEmptyRows(BBox _bb) {
      if(!edges.isEmpty())
      {
         boolean bShifted;
         do
         {
            bShifted = false;
            int y = _bb.miny;
            while(y < _bb.maxy)
            {
               if(isCellRowEmpty(y))
               {
                  // trace "xxx removeEmptyRows: y="+y;
                  bShifted |= shiftCellRowsUpAt(y);
               }
               y++;
            }
         }
         while(bShifted);
      }
   }

   protected method optimizeColsAndRows(boolean _bbOnly) {

      local BBox bbAll;
      bbAll.init(0, 0, grid_w-1, grid_h-1);

      local BBox bb;
      findBBox(bb);

      removeEmptyCols(_bbOnly ? bb : bbAll);

      if(1)
      {
         collapseCellsAndRedundantEdgesV(true/*bPass1*/, bb);
         findBBox(bb);
         removeEmptyRows(_bbOnly ? bb : bbAll);
         findBBox(bb);
         collapseCellsAndRedundantEdgesV(false/*bPass1*/, bb);
         findBBox(bb);
         removeEmptyRows(_bbOnly ? bb : bbAll);
      }
   }

   protected method findUniqueEdgeBelow(Node _n) : Edge {
      Edge *e;
      Edge eUnique <= null;
      Cell c <= _n.cell;
      foreach e in edges
      {
         Node ntail <= e.tail;
         Node nhead <= e.head;
         Cell ctail <= ntail.cell;
         Cell chead <= nhead.cell;

         if(@(ntail) == @(_n))
         {
            if(chead.y > c.y)
            {
               if(b_gr_debug) trace "[trc] findUniqueEdgeBelow<tail>: n"+_n.getString()+" edge candidate is tail"+ntail.getString()+" head"+nhead.getString();
               if(null != eUnique)
                  return null;  // not unique
               eUnique <= e;
            }
         }
         else if(@(nhead) == @(_n))
         {
            if(ctail.y > c.y)
            {
               if(b_gr_debug) trace "[trc] findUniqueEdgeBelow<head>: n"+_n.getString()+" edge candidate is tail"+ntail.getString()+" head"+nhead.getString();
               if(null != eUnique)
                  return null;  // not unique
               eUnique <= e;
            }
         }
      }
      return eUnique;
   }

   public method findUniqueEdgeTo(Node _n, Node _notN) : Edge {
      Edge *e;
      Edge eUnique <= null;
      Cell c <= _n.cell;
      foreach e in edges
      {
         Node ntail <= e.tail;
         Node nhead <= e.head;
         Cell ctail <= ntail.cell;
         Cell chead <= nhead.cell;

         if(@(ntail) == @(_n))
         {
            if(@(nhead) != @(_notN))
            {
               if(null != eUnique)
                  return null;  // not unique
               eUnique <= e;
            }
         }
         else if(@(nhead) == @(_n))
         {
            if(@(ntail) != @(_notN))
            {
               if(null != eUnique)
                  return null;  // not unique
               eUnique <= e;
            }
         }
      }
      return eUnique;
   }

   protected method findOtherEdgeTo(Node _n, Node _notN) : Edge {
      Edge *e;
      Cell c <= _n.cell;
      foreach e in edges
      {
         Node ntail <= e.tail;
         Node nhead <= e.head;
         Cell ctail <= ntail.cell;
         Cell chead <= nhead.cell;

         if(@(ntail) == @(_n))
         {
            if(@(nhead) != @(_notN))
            {
               return e;
            }
         }
         else if(@(nhead) == @(_n))
         {
            if(@(ntail) != @(_notN))
            {
               return e;
            }
         }
      }
      return null;
   }

   protected method findOtherEdgeToOnSameLevel(Node _n, Node _notN) : Edge {
      Edge *e;
      Cell c <= _n.cell;
      foreach e in edges
      {
         Node nOther <= e.getOtherNode(_n);
         if(b_gr_debug3) trace "[trc] findOtherEdgeToOnSameLevel: try e="+GetEdgeString(e)+" n"+GetNodeString(_n)+" notN"+GetNodeString(_notN)+" nOther="+GetNodeString(nOther);
         if(null != nOther && @(nOther) != @(_notN) && nOther.cell.y == _n.cell.y)
         {
            Node ntail <= e.tail;
            Node nhead <= e.head;
            Cell ctail <= ntail.cell;
            Cell chead <= nhead.cell;

            if(@(ntail) == @(_n))
            {
               if(@(nhead) != @(_notN))
                  return e;
            }
            else if(@(nhead) == @(_n))
            {
               if(@(ntail) != @(_notN))
                  return e;
            }
         }
      }
      return null;
   }

   protected method flipCellOptRow(int _y) : boolean {
      //  _______________
      // |......___......|
      // |.a>>b>>>>>c>>d.|
      // |....^.___.^....|
      // |___.^.....^....|
      // |___.e<<f..g<<h.|
      // |___............|
      // =>
      //  _______________
      // |......___......|
      // |.a>>b>>>>>c>>d.|
      // |....^.___.^....|
      // |___.^.....^....|
      // |.f>>e.___.g<<h.|
      // |___............|
      Edge *e;
      boolean bFlipped = false;
      foreach e in edges
      {
         Node ntail <= e.tail;
         Node nhead <= e.head;

         Cell ctail <= ntail.cell;
         Cell chead <= nhead.cell;

         int distX;

         if(ctail.y == _y && chead.y == _y)
         {
            // // distX = (chead.x - ctail.x);
            // // if(distX > 1)
            if(1)
            {
               Edge eBelow <= findUniqueEdgeBelow(ntail);  // must be the only edge that connects to ntail from below
               if(b_gr_debug) trace "[trc] flipCellOptRow: y="+_y+" ntail"+ntail.getString()+" nhead"+nhead.getString()+" => eBelow="+GetEdgeString(eBelow);
               if(null != eBelow)
               {
                  Node nBelow <= eBelow.getOtherNode(ntail);
                  if(b_gr_debug) trace "[trc]    nBelow"+nBelow.getString();
                  Edge eBelowNext <= findUniqueEdgeTo(nBelow, ntail/*filter*/);
                  Node nBelowNext <= null;
                  if(null != eBelowNext)
                  {
                     nBelowNext <= eBelowNext.getOtherNode(nBelow);
                     if(b_gr_debug) trace "[trc]    nBelowNext"+nBelowNext.getString();
                     if(nBelowNext.cell.y == nBelow.cell.y)  // must be on same level
                     {
                        local BBox bbBelowNext;
                        bbBelowNext.init(nBelowNext.cell.x, nBelowNext.cell.y,
                                         nBelowNext.cell.x, nBelowNext.cell.y
                                         );
                        boolean bIndirectlyReachable = (null != findFirstIndirectEdgeToNodeVia(nBelowNext, nBelow, bbBelowNext));
                        if(b_gr_debug2) trace "[trc] flipCellOptRow: bIndirectlyReachable="+bIndirectlyReachable+" bbBelowNext="+bbBelowNext.getString();
                        if(!bIndirectlyReachable)
                        {
                           // nBelowNext is part of isolated sub-branch that has no (indirect) connection to 'nBelow' => safe to flip
                           if(b_gr_debug) trace "[trc] bbBelowNext="+bbBelowNext.getString();

                           Cell cBelowNext <= nBelowNext.cell;
                           distX = cBelowNext.x - nBelow.cell.x;
                           if(distX > 0)
                           {
                              distX--;
                              // is there space available left of 'nBelow' for the flipped sub-branch ?
                              if(isCellRectEmptyWithEdgeCrossings(nBelow.cell.x - distX - bbBelowNext.getWidth(),
                                                                  nBelow.cell.y,
                                                                  bbBelowNext.getWidth() + distX,
                                                                  bbBelowNext.getHeight()
                                                                  )
                                 )
                              {
                                 if(b_gr_debug) trace "[dbg] flipCellOptRow: ok, cell rect is empty => flip sub-branch nBelowNext"+nBelowNext.getString()+" @bbBelowNext="+bbBelowNext.getString();
                                 flipCellRectH(nBelowNext.cell.x, nBelowNext.cell.y,
                                               bbBelowNext.getWidth(), bbBelowNext.getHeight(),
                                               nBelow.cell.x - distX - bbBelowNext.getWidth(),
                                               nBelow.cell.y
                                               );

                                 bFlipped = true;
                                 break;
                              }
                           }

                           // // initial version: flip a single node
                           // // if(null == findUniqueEdgeTo(nBelowNext, nBelow/*filter*/))  // must only be connected to nBelow
                           // // {
                           // //    Cell cBelowNext <= nBelowNext.cell;
                           // //    distX = cBelowNext.x - nBelow.cell.x;
                           // //    if(distX > 0)
                           // //    {
                           // //       if(b_gr_debug) trace "[trc] flipCellOptRow: y="+_y+" flip-node candidate nBelowNext"+nBelowNext.getString()+" distX="+distX;

                           // //       int newCellX = nBelow.cell.x - distX;
                           // //       if(newCellX >= 0)
                           // //       {
                           // //          Cell cBelowNextNew <= getCell(newCellX, cBelowNext.y);
                           // //          if(cBelowNextNew.isEmpty())
                           // //          {
                           // //             // flip
                           // //             if(b_gr_debug) trace "[trc] flipCellOptRow: y="+_y+" flip-node "+nBelowNext.getString()+" "+cBelowNext.getString()+" => "+cBelowNextNew.getString();
                           // //             cBelowNext.node <= null;
                           // //             cBelowNextNew.node <= nBelowNext;
                           // //             nBelowNext.cell <= cBelowNextNew;
                           // //             bFlipped = true;
                           // //             break;
                           // //          }
                           // //       }
                           // //    }
                           // // }

                        }
                     }
                  } // if eBelowNext

                  // not flipped, try trivial same-row flip (when nBelow is connected to single leaf node on same row)
                  Edge eBelowSameLevel <= findOtherEdgeToOnSameLevel(nBelow, null/*notN*/);
                  if(b_gr_debug2) trace "[trc] eBelowSameLevel="+GetEdgeString(eBelowSameLevel);
                  if(null != eBelowSameLevel)
                  {
                     Node nBelowSameLevelNext <= eBelowSameLevel.getOtherNode(nBelow);
                     if(nBelowSameLevelNext.isRightOf(nBelow))
                     {
                        if(null == findOtherEdgeTo(nBelowSameLevelNext, nBelow/*notN*/))
                        {
                           // is leaf node
                           if(b_gr_debug2) trace "[trc] nBelowSameLevelNext"+nBelowSameLevelNext.getString()+" is leaf node on the RHS of nBelow"+nBelow.getString();

                           Cell cBelowSameLevelNext <= nBelowSameLevelNext.cell;
                           distX = cBelowSameLevelNext.x - nBelow.cell.x;
                           if(b_gr_debug) trace "[dbg] flipCellOptRow: y="+_y+" flip-node nBelowSameLevelNext"+nBelowSameLevelNext.getString()+" distX="+distX;
                           int newCellX = nBelow.cell.x - distX;
                           if(newCellX >= 0)
                           {
                              Cell cBelowSameLevelNextNew <= getCell(newCellX, cBelowSameLevelNext.y);
                              if(isCellEmptyCheckEdgeCrossing(cBelowSameLevelNextNew.x, cBelowSameLevelNextNew.y))////.isEmpty())
                              {
                                 // flip
                                 if(b_gr_debug) trace "[dbg] flipCellOptRow: y="+_y+" flip single node "+nBelowSameLevelNext.getString()+" => "+cBelowSameLevelNextNew.getString();
                                 if(b_gr_debug) debugPrintEdges();
                                 cBelowSameLevelNext.node <= null;
                                 cBelowSameLevelNextNew.node <= nBelowSameLevelNext;
                                 nBelowSameLevelNext.cell <= cBelowSameLevelNextNew;
                                 bFlipped = true;
                                 break;
                              }
                              // else: can't flip, cell already occupied
                           }
                           // else: can't flip, would be out of bounds

                        } // is leaf node
                     } // isRightOf
                  } // if eBelowSameLevel

               } // if eBelow

            } // if 1
         }
      }
      // if(b_gr_debug) trace "xxx ================= bFlipped="+bFlipped;
      return bFlipped;
   }

   protected method flipCellOpt() {
      if(b_gr_debug) trace "[trc] flipCellOpt";
      boolean bFlipped;
      do
      {
         bFlipped = false;
         int y = 0;
         loop(grid_h - 1)
         {
            if(flipCellOptRow(y))
            {
               bFlipped = true;
               optimizeColsAndRows(true/*bbOnly*/);
               break;  // restart from top row
            }
            y++;
         }
      }
      while(bFlipped);
   }

   public method rotate() {
      int t;
      local Cell *[] newCells;
      int gridHNew = grid_w;
      int gridWNew = grid_h;
      newCells.alloc(gridWNew * gridHNew);
      newCells.useAll();
      int y = 0;
      loop(grid_h)
      {
         int x = 0;
         loop(grid_w)
         {
            Cell c <= cells.getDeref(y*grid_w + x);
            c.x = y;
            c.y = x;
            newCells[x*gridWNew + y] = deref c;
            x++;
         }
         y++;
      }

      cells <= deref newCells;
      grid_w = gridWNew;
      grid_h = gridHNew;

      canvas.init(grid_w, grid_h);
   }

   public method flipX() {
      int t;
      local Cell *[] newCells;
      int gridWNew = grid_w;
      int gridHNew = grid_h;
      newCells.alloc(gridWNew * gridHNew);
      newCells.useAll();
      int y = 0;
      loop(grid_h)
      {
         int x = 0;
         loop(grid_w)
         {
            Cell c <= cells.getDeref(y*grid_w + x);
            newCells[y*gridWNew + (gridWNew-x-1)] = deref c;
            x++;
         }
         y++;
      }

      cells <= deref newCells;
      grid_w = gridWNew;
      grid_h = gridHNew;

      canvas.init(grid_w, grid_h);
   }

   public method flipY() {
      int t;
      local Cell *[] newCells;
      int gridWNew = grid_w;
      int gridHNew = grid_h;
      newCells.alloc(gridWNew * gridHNew);
      newCells.useAll();
      int y = 0;
      loop(grid_h)
      {
         int x = 0;
         loop(grid_w)
         {
            Cell c <= cells.getDeref(y*grid_w + x);
            c.y = (gridHNew-y-1);
            newCells[c.y*gridWNew + x] = deref c;
            x++;
         }
         y++;
      }

      cells <= deref newCells;
      grid_w = gridWNew;
      grid_h = gridHNew;

      canvas.init(grid_w, grid_h);
   }

   protected method findBBox(BBox bb) {
      bb.reset();
      Cell *c;
      foreach c in cells
      {
         if(null != c.node)
         {
            if(c.x < bb.minx)
               bb.minx = c.x;
            if(c.x > bb.maxx)
               bb.maxx = c.x;

            if(c.y < bb.miny)
               bb.miny = c.y;
            if(c.y > bb.maxy)
               bb.maxy = c.y;
         }
      }
   }

   public method findEdge(Node _a, Node _b) : Edge {
      Edge *e;
      foreach e in edges
      {
         if(e.connectsTo(_a) && e.connectsTo(_b))
            return e;
      }
      return null;
   }

   protected method recursiveFindEdgeTo(local PointerArray _edgesDone, local Node _nCur, local Node _to, BBox _bb) : Edge {
      //  (note) updates 'bb' during edge-traversal
      _bb.extendToCell(_nCur.cell);
      local Edge *e;
      foreach e in edges
      {
         if(!_edgesDone.containsPointer(e))
         {
            if(e.connectsTo(_nCur))
            {
               _bb.extendToCell(e.getOtherNode(_nCur).cell);

               if(e.connectsTo(_to))
               {
                  // should not be reachable (direct edge should be part of initial 'edgesDone' array)
                  if(b_gr_debug3) trace "[trc] recursiveFindEdgeTo: found "+GetEdgeString(e);
                  return e;
               }
               else
               {
                  _edgesDone.add(e);
                  Edge eTo <= recursiveFindEdgeTo(_edgesDone, e.getOtherNode(_nCur), _to, _bb);
                  if(null != eTo)
                     return eTo;
               }
            }
            // else
            // {
            //    _edgesDone.add(e);
            // }
         }
      }
      return null;
   }

   protected method findFirstIndirectEdgeToNodeVia(Node _n, Node _nVia, BBox _bb) : Edge {
      // check if 'nVia' is reachable by any chain of edges other than the direct edge between 'n' and 'nVia'
      //  and return first edge found. null=not (indirectly) reachable
      //
      //  (note) updates 'bb' during edge-traversal
      local Edge *[] edgesDone;
      Edge *e;
      foreach e in edges
      {
         if(e.connects(_n, _nVia))
         {
            edgesDone.add(e);
            break;
         }
      }
      // trace "xxx findFirstIndirectEdgeToNodeVia: initial edgesDone="+#(edgesDone);  // should be 1 entry
      return recursiveFindEdgeTo(edgesDone, _n/*cur*/, _nVia/*to*/, _bb);
   }

   protected method findRHSEdgeOnSameLevel(Node _n) : Edge {
      Edge *e;
      foreach e in edges
      {
         if(e.connectsToRHSOnSameLevel(_n))
            return e;
      }
      return null;
   }

   protected method unfoldSubGraphs() : boolean {
      if(b_gr_debug2) trace "[trc] Graph::unfoldSubGraphs: begin node iteration";
      boolean bUnfolded = false;
      Node *n;
      foreach n in nodes
      {
         if(b_gr_debug2) trace "[trc] Graph::unfoldSubGraphs: n"+n.getString();
         if(null != n.parent_subgraph && (null != n.cell))
         {
            Graph subgraph <= n.parent_subgraph;
            if(LAYOUT_TABLE != subgraph.layout && subgraph.b_unfold)  // never unfold table graphs (=> inner layouting only)
            {
               int subW = subgraph.grid_w;
               int subH = subgraph.grid_h;
               if(b_gr_debug) trace "[dbg] Graph::unfoldSubGraphs: subgraph id="+subgraph.id+" sz=("+subW+","+subH+")";
               if(subW > 0 && subH > 0)
               {
                  subgraph.validateAnchor();
                  Node nSubMain <= subgraph.getAnchor();
                  if(b_gr_debug) trace "[trc] Graph::unfoldSubGraphs:    n"+n.getString()+" anchor(nSubMain)"+nSubMain.getString();
                  int anchorX = nSubMain.cell.x;
                  Cell c <= n.cell;
                  Edge *eRHS;
                  if(subgraph.grid_w > 1)
                     eRHS <= findRHSEdgeOnSameLevel(n);
                  else
                     eRHS <= null;
                  int cx, cy;
                  int dx, dy;
                  int emptyW = subW;
                  int emptyH = subH;
                  Node nHelper <= null;
                  Node nMainDst <= null;
                  Cell cMainDst <= null;
                  Edge *e;
                  Edge *eToN;
                  if(null != eRHS)
                  {
                     // (note) this should not happen since there must only be one edge that connects the subgraph
                     // connect via helper node (insert subgraph below io_node)
                     eToN <= findOtherEdgeTo(n, eRHS.getOtherNode(n));
                     if(b_gr_debug) trace "[trc] unfoldSubGraphs: found RHS edge"+eRHS.getString()+" eToN="+GetEdgeString(eToN);
                     if(null != eToN)
                     {
                        nHelper <= addNodeHelper();
                        nHelper.b_helper_subgraph = true;
                        nHelper.orig_graph <= subgraph;  // [25Mar2024]
                        // // nHelper.cell <= c;
                        // // c.node <= nHelper;  // moved by insertEmptyCellRect() => update/restore again later
                        n.cell <= null;  // remove io_node from grid (will be replaced by nHelper after inserting space/copying sub-graph)
                        c.node <= null;
                        addEdge(nSubMain, nHelper);  // (todo) maintain dir (b_rev / head/tail order)
                        eToN.replaceNode(n, nHelper);
                        eRHS.replaceNode(n, nHelper);
                        cx = c.x;
                        cy = c.y;
                        emptyH++;
                        dx = cx;
                        dy = cy + 1;
                     }
                     else
                        throw GraphError "unfoldSubGraphs: eToN is null (n="+n.getString()+")";
                  }
                  else
                  {
                     if(anchorX > 0)
                     {
                        // added for test22. keep for all cases ?
                        nHelper <= addNodeHelper();
                        nHelper.b_helper_subgraph = true;
                        nHelper.orig_graph <= subgraph;  // [25Mar2024]
                        n.cell <= null;  // remove io_node from grid (will be replaced by nHelper after inserting space/copying sub-graph)
                        c.node <= null;
                        eToN <= findUniqueEdgeTo(n, null/*notN*/);
                        // maintain dir (b_rev / head/tail order)
                        if(null != eToN)
                        {
                           Edge eHelper <= addEdge(nSubMain, nHelper);
                           if(b_gr_debug3) trace "[trc]  eToN="+eToN.getString()+" n"+n.getString();
                           eHelper.b_rev = ( (@(eToN.head) == @(n)) ^ eToN.b_rev);
                           if(b_gr_debug3) trace "[trc] eHelper.b_rev="+eHelper.b_rev;
                        }
                        else
                           addEdge(nSubMain, nHelper); // multiple edges to 'n' (should not happen) => ignore direction

                        foreach e in edges
                           e.replaceNode(n, nHelper);
                        cx = c.x;
                        cy = c.y;
                        emptyH++;
                        dx = cx;
                        dy = cy + 1;
                     }
                     else
                     {
                        // remove io_node from grid
                        n.cell <= null;
                        c.node <= null;
                        cx = c.x;
                        cy = c.y;
                        dx = cx;
                        dy = cy;

                        foreach e in edges
                        {
                           if(e.connectsTo(n))
                           {
                              nMainDst <= e.getOtherNode(n);
                              cMainDst <= nMainDst.cell;
                              break;
                           }
                        }
                        if(null == nMainDst)
                           throw GraphError "unfoldSubGraphs: nMainDst is null (n="+n.getString()+")";
                     }
                  }

                  // move subgraph cells into this graph
                  boolean bInserted = false;
                  int x,y;
                  Cell *cSrc;
                  Cell *cDst;

                  if(subgraph.b_flip_x)
                  {
                     insertEmptyCellRect(cx, cy,
                                         emptyW, emptyH
                                         );

                     if(isCellRectEmptyWithEdgeCrossings(dx - subW + anchorX, dy,
                                                         subW, subH
                                                         ))
                     {
                        y = 0;
                        loop(subH)
                        {
                           x = 0;
                           loop(subW)
                           {
                              cSrc <= subgraph.getCell(x, y);
                              cDst <= getCell(dx + subW - x - 1 - (subW - anchorX -1), dy + y);
                              if(b_gr_debug) trace "[trc] subgraph: flipX anchorX="+anchorX+" d=("+dx+","+dy+") cSrc="+cSrc.getString()+" => cDst="+cDst.getString();
                              cDst.moveFrom(cSrc);
                              if(null != cDst.node)
                                 nodes.add(cDst.node);
                              x++;
                           }
                           y++;
                        }

                        bInserted = true;
                     }
                     else
                     {
                        subgraph.debugPrintNodesAndEdges();
                        subgraph.debugPrint();
                        throw GraphError "unfoldSubGraphs<flip_x>: isCellRectEmptyWithEdgeCrossings("+(dx-subW+anchorX)+","+dy+" "+subW+","+subH+") failed (flip_x). subgraph.id="+subgraph.id+" anchor="+GetNodeString(nSubMain);
                     }
                  }

                  if(!bInserted)
                  {
                     insertEmptyCellRect(cx, cy,
                                         emptyW, emptyH
                                         );

                     if(subgraph.b_flip_y)
                     {
                        if(isCellRectEmptyWithEdgeCrossings(dx - anchorX, dy - subH,
                                                            subW, subH
                                                            ))
                        {
                           y = 0;
                           loop(subH)
                           {
                              x = 0;
                              loop(subW)
                              {
                                 cSrc <= subgraph.getCell(x, y);
                                 cDst <= getCell(dx + x - anchorX, dy - y);
                                 cDst.moveFrom(cSrc);
                                 if(null != cDst.node)
                                    nodes.add(cDst.node);
                                 x++;
                              }
                              y++;
                           }
                        }
                        else
                        {
                           subgraph.debugPrintNodesAndEdges();
                           subgraph.debugPrint();
                           throw GraphError "unfoldSubGraphs<flip_y>: isCellRectEmptyWithEdgeCrossings("+(dx-anchorX)+","+dy+" "+subW+","+subH+") failed. subgraph.id="+subgraph.id+" anchor="+GetNodeString(nSubMain);
                        }
                     }
                     else
                     {
                        if(isCellRectEmptyWithEdgeCrossings(dx - anchorX, dy,
                                                            subW, subH
                                                            ))
                        {
                           y = 0;
                           loop(subH)
                           {
                              x = 0;
                              loop(subW)
                              {
                                 cSrc <= subgraph.getCell(x, y);
                                 cDst <= getCell(dx + x - anchorX, dy + y);
                                 cDst.moveFrom(cSrc);
                                 if(null != cDst.node)
                                    nodes.add(cDst.node);
                                 x++;
                              }
                              y++;
                           }
                        }
                        else
                        {
                           subgraph.debugPrintNodesAndEdges();
                           subgraph.debugPrint();
                           throw GraphError "unfoldSubGraphs: isCellRectEmptyWithEdgeCrossings("+(dx-anchorX)+","+dy+" "+subW+","+subH+") failed. subgraph.id="+subgraph.id+" anchor="+GetNodeString(nSubMain);
                        }
                     }
                  }

                  // update edges and replace io_node by top/left subgraph node
                  if(null == nHelper)
                  {
                     foreach e in edges
                     {
                        if(e.connectsTo(n))
                        {
                           e.replaceNode(n, nSubMain);

                           Node nFrom <= e.getOtherNode(nSubMain);
                           if(b_gr_debug) trace "[trc] unfoldSubGraphs: nFrom="+GetNodeString(nFrom)+" c="+c.getString();
                           // // nFrom.cell <= c;
                           // // c.node <= nFrom;
                        }
                     }
                     n.unfolded_anchor <= nSubMain;
                  }

                  // add subgraph edges (by reference)
                  foreach e in subgraph.edges
                     edges.add(e);

                  if(null != nHelper)
                  {
                     c.node <= nHelper;
                     nHelper.cell <= c;
                     n.unfolded_anchor <= nHelper;
                  }
                  else
                  {
                     // Restore moved dst node position
                     Cell cMoved <= nMainDst.cell;
                     cMoved.node <= null;
                     nMainDst.cell <= cMainDst;
                     cMainDst.node <= nMainDst;
                     // // Cell cMoved <= nSubMain.cell;
                     // // cMoved.node <= null;
                     // // c.node <= nSubMain;
                  }

                  n.cell <= null;
                  bUnfolded = true;
               }
               else
                  throw GraphError "unfoldSubGraphs: subgraph n"+n.getString()+" is empty";
            } // if !table
            // // else
            // // {
            //    // trace "xxx Graph::unfoldSubGraphs: subgraph.layout="+subgraph.layout;
            //    // subgraph.debugPrintNodesAndEdges();
            //    // subgraph.debugPrint();
            // // }
         } // if subgraph

         if(bUnfolded)
            break;
      } // loop nodes
      if(b_gr_debug2) trace "[trc] Graph::unfoldSubGraphs: LEAVE. bUnfolded="+bUnfolded;
      return bUnfolded;
   }

   protected method findNodesInBB(BBox _bb, PointerArray _ret) {
      _ret.empty();
      int y = _bb.miny;
      while(y <= _bb.maxy)
      {
         int x = _bb.minx;
         while(x <= _bb.maxx)
         {
            Cell c <= getCell(x, y);
            if(null != c.node)
               _ret.add(c.node);
            x++;
         }
         y++;
      }
   }

   protected method isNodeEdgeConstrainedOutsideOfBB(Node _n, BBox _bb, Node _notN) : boolean {
      // trace "xxx isNodeEdgeConstrainedOutsideOfBB: ==== n"+_n.getString()+" notN"+_notN.getString()+" bb="+_bb.getString();
      Edge *e;
      foreach e in edges
      {
         if(e.connectsTo(_n))
         {
            Node nOther <= e.getOtherNode(_n);
            // trace "xxx isNodeEdgeConstrainedOutsideOfBB: e="+e.getString()+" notN"+_notN.getString()+" nOther"+nOther.getString();
            if(@(nOther) != @(_notN))
            {
               if(null != nOther.cell)
               {
                  Cell cOther <= nOther.cell;
                  if(cOther.x < _bb.minx ||
                     cOther.x > _bb.maxx ||
                     cOther.y < _bb.miny ||
                     cOther.y > _bb.maxy
                     )
                  {
                     // trace "xxx    => isNodeEdgeConstrainedVOutsideOfBB: n"+_n.getString()+" notN"+_notN.getString()+" = true";
                     return true;
                  }
               }
            }
         }
      }
      // trace "xxx   isNodeEdgeConstrainedVOutsideOfBB: n"+_n.getString()+" => return false";
      return false;
   }

   protected method isAnyNodeEdgeConstrainedOutsideOfBB(PointerArray _nodes, BBox _bb, Node _notN) : boolean {
      Node *n;
      foreach n in _nodes
      {
         if(@(n) != @(_notN))
         {
            if(isNodeEdgeConstrainedOutsideOfBB(n, _bb, _notN))
            {
               // trace "xxx         n"+n.getString()+" is constrained. bb="+_bb.getString();
               return true;
            }
         }
      }
      return false;
   }

   protected method isLeafSubtree(Node _n, Node _nVia, int _minY, BBox _retBB, PointerArray _retNodesInBB) : boolean {
      _retBB.reset();
      _retNodesInBB.empty();
      boolean bIndirectlyReachable = (null != findFirstIndirectEdgeToNodeVia(_n, _nVia, _retBB));
      // // if(bIndirectlyReachable)
      // //    trace "xxx moveLeafSubtreesUps<tail>: indirectlyReachable, ntail"+ntail.getString()+" e="+e.getString()+" subtree_bb="+bb.getString()+" sz="+bb.getSizeString();
      if(!bIndirectlyReachable && !_retBB.isSingleCell() && (_retBB.miny >= (_n.cell.y)) && (_retBB.miny >= _minY))
      {
         // trace "xxx moveLeafSubtreesUps<tail>:     preBB candidate ntail"+ntail.getString()+" e="+e.getString()+" subtree_bb="+bb.getString()+" sz="+bb.getSizeString();
         findNodesInBB(_retBB, _retNodesInBB);
         if(!isAnyNodeEdgeConstrainedOutsideOfBB(_retNodesInBB, _retBB, _n/*notN*/))
            return true;
      }
      return false;
   }

   protected method moveLeafSubtreesUp() : boolean {
      // Find "leaf" subtrees (only connected via one edge)
      //  returns true if one or more bboxes have been moved
      boolean bAnyMoved = false;
      if(b_gr_debug3) trace "[>>>] Graph: xxx ....................................... moveLeafSubtreesUp";
      boolean bMoved;
      do
      {
         bMoved = false;
         Edge *e;
         local BBox bbAll;
         findBBox(bbAll);  // (note) don't move past top of graph BB
         local BBox bb;
         local Node *[] nodesInBB;
         local BBox *[] bbCandidates;
         foreach e in edges
         {
            if(e.isPlaced())  // ignore edges to unfolded graphs (cell = null)
            {
               Node ntail <= e.tail;
               Node nhead <= e.head;

               if(b_gr_debug3) trace "[>>>] Graph: moveLeafSubtreesUp: ------- try e="+e.getString();

               // Tail
               if(isLeafSubtree(ntail/*n*/, nhead/*via*/, (bbAll.miny+1)/*miny*/, bb/*retBB*/, nodesInBB/*retNodesInBB*/))
               {
                  if(ntail.cell.y > nhead.cell.y)
                  {
                     if(b_gr_debug3) trace "[trc] moveLeafSubtreesUp<tail>: candidate ntail"+ntail.getString()+" e="+e.getString()+" subtree_bb="+bb.getString()+" sz="+bb.getSizeString();
                     bbCandidates.add(#(Object(bb))); // add a copy of the bounding box
                  }
                  else
                  {
                     if(b_gr_debug3) trace "[>>>] Graph: +++++++++++++++ isLeafSubtree<tail> bb="+bb.getString()+" sz="+bb.getSizeString()+" but y check failed => try y-flip (graph.id="+id+" b_flip_y_opt="+b_flip_y_opt+")";
                     if(b_flip_y_opt && ntail.cell.y == bb.miny && bb.getHeight() > 1)  // (todo) flip around _any_ node
                     {
                        // Check if the bbox can be y-flipped
                        if(isCellRectEmpty(bb.minx,       bb.miny - (bb.getHeight() - 1),
                                           bb.getWidth(), bb.getHeight() - 1
                                           ))
                        {
                           if(b_gr_debug3) trace "[trc]                     => can be y-flipped (bbAll="+bbAll.getString()+")";
                           flipCellRectUp(bb.minx, bb.miny, bb.getWidth(), bb.getHeight(),
                                          bb.minx, bb.miny
                                          );
                           bMoved = true;
                        }
                     }
                  }
               }

               // Head
               if(isLeafSubtree(nhead/*n*/, ntail/*via*/, (bbAll.miny+1)/*miny*/, bb/*retBB*/, nodesInBB/*retNodesInBB*/))
               {
                  if(nhead.cell.y > ntail.cell.y)
                  {
                     if(b_gr_debug3) trace "[>>>] Graph: moveLeafSubtreesUp<head>: candidate nhead"+nhead.getString()+" e="+e.getString()+" subtree_bb="+bb.getString()+" sz="+bb.getSizeString();
                     bbCandidates.add(#(Object(bb))); // add a copy of the bounding box
                  }
                  else
                  {
                     if(b_gr_debug3) trace "[>>>] Graph: +++++++++++++++ isLeafSubtree<head> bb="+bb.getString()+" sz="+bb.getSizeString()+" but y check failed => try y-flip (graph.id="+id+" b_flip_y_opt="+b_flip_y_opt+")";
                     if(b_flip_y_opt && nhead.cell.y == bb.miny && bb.getHeight() > 1)  // (todo) flip around _any_ node
                     {
                        // Check if the bbox can be y-flipped
                        if(isCellRectEmpty(bb.minx,       bb.miny - (bb.getHeight() - 1),
                                           bb.getWidth(), bb.getHeight() - 1
                                           ))
                        {
                           if(b_gr_debug3) trace "[trc]                     => can be y-flipped (bbAll="+bbAll.getString()+")";
                           if(1)
                           {
                              flipCellRectUp(bb.minx, bb.miny, bb.getWidth(), bb.getHeight(),
                                             bb.minx, bb.miny
                                             );
                              bMoved = true;
                           }
                        }
                     }
                  }
               }
            }
         }

         if(!bMoved)
         {
            // Iterate bounding box candidates, process largest first
            while(!bbCandidates.isEmpty())
            {
               int bestArea = 0;
               BBox bestBB <= null;
               BBox *bbCur;
               foreach bbCur in bbCandidates
               {
                  int area = bbCur.getArea();
                  if(area > bestArea)
                  {
                     bestArea = area;
                     bestBB <= bbCur;
                  }
               }

               if(b_gr_debug3) trace "[trc] moveLeafSubtreesUp:    bestBB="+bestBB.getString()+" sz="+bestBB.getSizeString();

               // Check if the bbox can be moved one row up
               if(isCellRectEmpty(bestBB.minx, bestBB.miny - 1, bestBB.getWidth(), 1))
               {
                  // // trace "xxx      todo moveCellRectUp("+bestBB.minx+","+bestBB.miny+" "+bestBB.getWidth()+","+bestBB.getHeight()+")";
                  // (todo) check horizontal edge crossing
                  moveCellRectUp(bestBB.minx, bestBB.miny,
                                 bestBB.getWidth(), bestBB.getHeight()
                                 );
                  bMoved = true;
               }

               bbCandidates.remove(bestBB);
            }

            bAnyMoved |= bMoved;
         } // if !bMoved
      }
      while(bMoved);

      // Not moved
      return false;
   }

   public method debugPrintNodes() {
      Node *n;
      int nIdx = 0;
      foreach n in nodes
      {
         trace "[trc] debugPrintNodes:"/* this="+#(this)+" n="+#(n)+*/" n["+nIdx+"] = "+n.getString()+((null != n.label)?(" label=\""+n.label+"\""):"")+" gr_attribs="+n.gr_attribs;
         nIdx++;
      }
   }

   public method debugPrintNodesNoAttribs() {
      Node *n;
      int nIdx = 0;
      foreach n in nodes
      {
         trace "[trc] debugPrintNodes:"/* this="+#(this)+" n="+#(n)+*/" n["+nIdx+"] = "+n.getString()+((null != n.label)?(" label=\""+n.label+"\""):"")+" ("+n.gr_attribs.numElements+" attribs)";
         nIdx++;
      }
   }

   public method debugPrintEdges() {
      Edge *e;
      int eIdx = 0;
      foreach e in edges
      {
         trace "[trc] debugPrintEdges: e["+eIdx+"] = "+e.getString()+((null != e.label)?(" label=\""+e.label+"\""):"")+" gr_attribs="+e.gr_attribs;
         eIdx++;
      }
   }

   public method debugPrintEdgesNoAttribs() {
      Edge *e;
      int eIdx = 0;
      foreach e in edges
      {
         trace "[trc] debugPrintEdges: e["+eIdx+"] = "+e.getString()+((null != e.label)?(" label=\""+e.label+"\""):"")+" ("+e.gr_attribs.numElements+" attribs)";
         eIdx++;
      }
   }

   public method debugPrintNodesAndEdges() {
      debugPrintNodes();
      debugPrintEdges();
   }

   public method debugPrintNodesAndEdgesNoAttribs() {
      debugPrintNodesNoAttribs();
      debugPrintEdgesNoAttribs();
   }

   public method trimToBoundingBox() {
      int t;
      local BBox bb;
      findBBox(bb);
      if(b_gr_debug) trace "[dbg] Graph::trimToBoundingBox: bb="+bb.getString()+" sz="+bb.getSizeString();
      local Cell *[] newCells;
      int gridWNew = (bb.maxx + 1) - bb.minx;
      int gridHNew = (bb.maxy + 1) - bb.miny;
      newCells.alloc(gridWNew * gridHNew);
      newCells.useAll();
      int y = 0;
      loop(gridHNew)
      {
         int x = 0;
         loop(gridWNew)
         {
            Cell c <= cells.getDeref((y+bb.miny)*grid_w + (bb.minx+x));
            c.y = y;
            c.x = x;
            newCells[y*gridWNew + x] = deref c;
            x++;
         }
         y++;
      }

      cells <= deref newCells;
      grid_w = gridWNew;
      grid_h = gridHNew;

      canvas.init(grid_w, grid_h);
   }

   protected method applySlant() {
      // trace "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx applySlant xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
      int t;
      local BBox bb;
      findBBox(bb);
      if(b_gr_debug) trace "[dbg] Graph::applySlant: bb="+bb.getString()+" sz="+bb.getSizeString();
      local Cell *[] newCells;
      int gridWNew = bb.getWidth() + (bb.getHeight() - 1);
      int gridHNew = bb.getHeight();
      newCells.alloc(gridWNew * gridHNew);
      newCells.useAll();
      int x;
      int y;
      Cell *c;

      y = 0;
      loop(gridHNew)
      {
         x = 0;
         loop(gridWNew)
         {
            c <= new Cell;
            c.init(x+y, y);
            newCells[y*gridWNew + x] = deref c;
            if(b_gr_debug3) trace "[trc] Graph::applySlant: new cell at "+c.x+","+c.y;
            x++;
         }
         y++;
      }

      y = 0;
      loop(bb.getHeight())
      {
         x = 0;
         loop(bb.getWidth())
         {
            c <= cells.getDeref((y+bb.miny)*grid_w + (bb.minx+x));
            c.x = x + y;
            c.y = y;
            newCells[y*gridWNew + x + y] = deref c;
            x++;
         }
         y++;
      }

      cells <= deref newCells;
      grid_w = gridWNew;
      grid_h = gridHNew;

      canvas.init(grid_w, grid_h);
   }

   public method layoutGrid() : boolean {
      try
      {
         layoutGridInitial();

         if(edges.numElements > 0)
         {
            int iter = 1;
            int numIter = 2;
            loop(numIter)
            {
               if(b_gr_debug) trace "[dbg] -------- layout iter="+iter+"/"+numIter;
               checkCollisionsAndMoveNodesDown((iter > 1)/*bAllowMoveHelper*/);
               collapseCellsAndRedundantEdgesH((iter > 1)/*bAllowCollapseMainRow*/);
               iter++;
            }

            optimizeColsAndRows(true/*bbOnly*/);

            if(b_flip_x_opt)
               flipCellOpt();

            if(b_gr_debug) debugPrintNodesAndEdges();

            while(unfoldSubGraphs())
            {
               // debugPrintNodesAndEdges();
               optimizeColsAndRows(true/*bbOnly*/);
               collapseCellsAndRedundantEdgesH(true/*bAllowCollapseMainRow*/);
               optimizeColsAndRows(true/*bbOnly*/);

               if(b_flip_x_opt)
                  flipCellOpt();

               // // // collapseCellsAndRedundantEdgesH(true/*bAllowCollapseMainRow*/);
               // // // optimizeColsAndRows(true/*bbOnly*/);

               // // // optimizeColsAndRows(true/*bbOnly*/);
               // // debugPrintNodesAndEdges();
               // // // break;
            }

            // debugPrint();

            collapseGapsBetweenEdgeNodesH();  // move nodes right

            moveLeafSubtreesUp();

            // // trace "xxx layoutGrid: graph.id="+id+" b_trim_to_bbox="+b_trim_to_bbox;
            if(b_trim_to_bbox)
               trimToBoundingBox();

            if(b_rotate)
               rotate();

            // (note) sub graphs are flipped around anchor node when they are unfolded
            if(b_flip_x && (null == parent_graph || !b_unfold))
               flipX();

            if(b_flip_y && (null == parent_graph || !b_unfold))
               flipY();

            if(b_cell_slant) // (note) "slant" is applied in GraphForm::addNodesFromGraph() (preferable)
               applySlant();
         }
         else
         {
            // no edges (just a single node?)
            if(b_gr_debug || b_gr_parse_debug) trace "[~~~] warning, graph '"+id+"' has no edges (#nodes="+nodes.numElements+"), keeping first node.";
            if(nodes.numElements > 0)
            {
               // keep only the first node so the graph is not empty
               // if(b_gr_debug || b_gr_parse_debug)
               //    debugPrintNodes();
               Cell cFirst <= getCell(0, 0);
               Node nFirst <= nodes.first;
               nFirst.cell <= cFirst;
               cFirst.node <= nFirst;
               // trace "xxx this="+#(this)+" nFirst="+#(nFirst)+" nFirst="+GetNodeString(nFirst);
            }

            if(b_gr_debug2)
               debugPrintNodes();

            if(b_trim_to_bbox)
               trimToBoundingBox();
         }

         if(b_gr_debug2)
            debugPrintNodesAndEdges();

         return true;
      }
      catch(GraphError e)
      {
         trace "[---] Graph::layout: error: "+e.message;
      }
      return false;
   }

   protected method layoutTable() : boolean {
      // (note) table sub graphs look like a single cell to other graphs
      // (note) layouting merely affects the _inner_ node placement of the sub graph cell
      // (note) => don't unfold table graphs
      allocCellsAndCanvas(1, 1);
      return true;
   }

   protected method layoutNonePlaceNodes() {
      // [01Feb2025] experimental abs positioning
      // (note) dummy layout, simply assign nodes to unique cells
      Node *n;
      int cellX = 0;
      foreach n in nodes
      {
         setCell(cellX++, 0, n);
      }
   }

   protected method layoutNone() : boolean {
      // [01Feb2025] experimental abs positioning
      try
      {
         allocCellsAndCanvas(nodes.numElements, 1);

         // Iterate layout_rows and place referenced nodes (single char ids)
         //  - implicitely add undefined nodes
         layoutNonePlaceNodes();

         // // if(b_trim_to_bbox)
         // //    trimToBoundingBox();

         // // if(b_cell_slant) // (note) (pixel) "slant" is applied in GraphForm::addNodesFromGraph() (preferable)
         // //    applySlant();

         if(b_gr_debug2)
            debugPrintNodesAndEdges();

         return true;
      }
      catch(GraphError e)
      {
         trace "[---] Graph::layout: error: "+e.message;
      }
      return false;
   }

   protected method layoutFixedPlaceRowNodes() {
      StringArray *aRow;
      int curY = grid_h / 2;
      int maxCols = 0;
      if(null != table_layout_rows)
      {
         foreach aRow in table_layout_rows
         {
            if(b_gr_debug3) trace "[trc] layoutFixedPlaceRowNodes: aRow="+aRow;
            if(aRow.numElements > maxCols)
               maxCols = aRow.numElements;
            int curX = grid_w / 2;
            int colIdx = 0;
            loop(aRow.numElements)
            {
               String sId = aRow[colIdx];
               if(!sId.isBlank())
               {
                  if(b_gr_debug3) trace "[trc] layoutFixedPlaceRowNodes: sId=\""+sId+"\"";
                  Node n <= findNode(sId);
                  // trace "xxx layoutFixedPlaceRowNodes: sId=\""+sId+"\" => n="+GetNodeString(n);
                  setCell(curX, curY, n);
               }

               curX += initial_col_spacing;
               colIdx++;
            }
            curY++;
         }
      }
   }

   protected method layoutFixed() : boolean {
      try
      {
         // Iterate layout_rows and place referenced nodes (single char ids)
         //  - implicitely add undefined nodes
         layoutFixedPlaceRowNodes();

         if(b_trim_to_bbox)
            trimToBoundingBox();

         if(b_cell_slant) // (note) (pixel) "slant" is applied in GraphForm::addNodesFromGraph() (preferable)
            applySlant();

         if(b_gr_debug2)
            debugPrintNodesAndEdges();

         return true;
      }
      catch(GraphError e)
      {
         trace "[---] Graph::layout: error: "+e.message;
      }
      return false;
   }

   public method layout() : boolean {

      if(b_gr_debug)
         trace "[dbg] Graph::layout: graph.id=\""+id+"\" layout="+layout+":";
      // debugPrintNodesAndEdges();

      if(LAYOUT_NONE != layout)
         findSpansFromLayoutRows();

      boolean r = false;
      switch(layout)
      {
         case LAYOUT_NONE:  // [01Feb2025] experimental abs positioning (pixel_layout=fixed)
            // r = true;
            r = layoutNone();
            break;

         default:
         case LAYOUT_GRID:
            r = layoutGrid();
            break;

         case LAYOUT_TABLE:
            r = layoutTable();
            break;

         case LAYOUT_FIXED:
            r = layoutFixed();
            break;
      }

      // if(r)
      //    debugPrint();

      return r;
   }

   public method debugPrint() {
      // trace "xxx print gridsz=("+grid_w+","+grid_h+")";
      canvas.clear();

      // Draw nodes
      int j = 0;
      loop(grid_h)
      {
         loop(grid_w)
         {
            Cell c <= cells.get(j++);
            c.draw(canvas);
         }
      }

      // Draw edges
      Edge *e;
      foreach e in edges
      {
         e.draw(canvas);
      }

      trace id+"["+grid_w+"x"+grid_h+"]=";
      canvas.debugPrint();
   }

   public method xcountNumEdgesToNodes() {
      Node *n;
      foreach n in nodes
      {
         n.num_edges_t    = 0;
         n.num_edges_l    = 0;
         n.num_edges_b    = 0;
         n.num_edges_r    = 0;
         n.cur_edge_idx_t = 0;
         n.cur_edge_idx_l = 0;
         n.cur_edge_idx_b = 0;
         n.cur_edge_idx_r = 0;
      }
      // Edge *e;
      // foreach e in edges
      // {
      //    if(e.isPlaced() && e.isVisible())
      //    {
      //       Node nhead <= e.head;
      //       nhead.num_edges++;
      //    }
      // }
   }

}


// <class.png>
class GRStyle {
   String id;
   HashTable attribs;

   public initGRStyle(String _id) {
      id = _id;
      attribs.alloc(512);
   }

   protected method setStyleAttribS(String _value) {
      local StringArray aS <= _value.replaceChar(',',';').splitChar(';');
      attribs["w"] = Object(aS.get(0));
      if(aS.numElements > 1)
         attribs["h"] = Object(aS.get(1));
      else
         attribs["h"] = Object(aS.get(0));  // quadratic
   }

   public method addStyleAttrib(String _key, String _value) {
      if(b_gr_parse_debug3) trace "[trc] GRStyle::addStyleAttrib: key=\""+_key+"\" value=\""+_value+"\"";
      GR.ReplaceLiteral(_value);
      if("s" == _key)
         setStyleAttribS(_value);
      else if("pad_h" == _key)
      {
         attribs["pad_l"] = Object(_value);
         attribs["pad_r"] = Object(_value);
      }
      else if("pad_v" == _key)
      {
         attribs["pad_t"] = Object(_value);
         attribs["pad_b"] = Object(_value);
      }
      else
         attribs[_key] = Object(_value);
   }

   public method inheritFrom(GRStyle _base) {
      if(b_gr_parse_debug3) trace "[trc] GRStyle::inheritFrom: base.id='"+_base.id+"'";
      String *key;
      HashTable htBase <= _base.attribs;
      foreach key in htBase
         attribs[key] = htBase[key];  // add or overwrite attrib
   }
}


// <class.png>
class GRPalette {
   String    id;
   HashTable colors;
   IntArray  ordered_colors;  // in the order they were added, e.g. for gradients

   public method initGRPalette(String _id) {
      id = _id;
      colors.alloc(512);
   }

   public method addColor(String _name, String _value) {
      GR.ReplaceLiteral(_value);
      int c32 = _value;
      if(b_gr_parse_debug3)
      {
         Integer io = c32;
         trace "[trc] GRPalette::addColor: name=\""+_name+"\" c32=#"+io.printf("%08x");
      }
      colors[_name] = c32;
      ordered_colors.add(c32);
   }

   public method inheritFrom(GRPalette _base) {
      if(b_gr_parse_debug3) trace "[trc] GRPalette::inheritFrom: base.id='"+_base.id+"'";
      String *key;
      HashTable htBase <= _base.colors;
      foreach key in htBase
         colors[key] = htBase[key];  // add or overwrite color
      ordered_colors.join(ordered_colors, _base.ordered_colors);
   }

   public method hasColor(String _name) : boolean {
      return colors.exists(_name);
   }

   public method getColorAsString(String _name) : String {
      local Integer c32 = colors.get(_name);
      return c32.printf("#%08x");
   }
}


// <class.png>
class GRGradient {
   String     id;
   IntArray   colors;  // in the order they were added
   FloatArray starts;  // color start positions

   Texture *cached_tex;

   public method addColor(float _start, String _value) {
      GR.ReplaceLiteral(_value);
      int c32 = _value;
      if(b_gr_parse_debug2)
         trace "[trc] GRGradient::addColor: start="+_start+" c32="+UI.GetColorString(c32);
      colors.add(c32);
      starts.add(_start);
   }

   public method finish() {
      // fill in missing starts
      int i = 0;
      loop(starts.numElements)
      {
         float start = starts[i];

         // find unassigned span length
         int j = i + 1;
         int spanLen = 1;
         float spanLastStart = start;
         while(j < starts.numElements)
         {
            if(starts[j] <= start)
            {
               spanLen++;
            }
            else
            {
               spanLastStart = starts[j];
               spanLen++;
               break;
            }
            j++;
         }
         if(j == starts.numElements)
            spanLastStart = 1.0f;

         if(b_gr_parse_debug3)
            trace "[trc] GRGradient::finish: i="+i+" spanLen="+spanLen+" start="+start+" spanLastStart="+spanLastStart;

         // Interpolate starts
         if(spanLen > 1)
         {
            float startDelta = (spanLastStart - start) / (spanLen - 1);
            float curStart = start + startDelta;
            j = i +1;
            loop(spanLen - 1)
            {
               starts[j] = curStart;
               curStart += startDelta;
               j++;
            }
         }

         // Next gradient stop/start
         i++;
      }

      if(b_gr_parse_debug2)
      {
         trace "[trc] GRGradient::finish:";
         i = 0;
         loop(colors.numElements)
         {
            trace "[trc]    ["+i+"] start="+starts[i]+" color="+UI.GetColorString(colors[i]);
            i++;
         }
      }
   }

   public method getInterpolatedColorAt(float _p) : int {
      int i = colors.numElements - 1;
      float prevStart = 0.0f;
      loop(colors.numElements)
      {
         float start = starts[i];
         if(_p >= start)
         {
            int color = colors[i];
            int nextColor   = ((i+1)==colors.numElements) ? colors.last : colors[i + 1];
            float nextStart = ((i+1)==colors.numElements) ? 1.0f : starts[i + 1];
            // trace "xxx getInterpolatedColorAt: p="+_p+" color="+UI.GetColorString(color)+" nextColor="+UI.GetColorString(nextColor)+" start="+start+" nextStart="+nextStart;
            return sdvg_MixARGBf(color, nextColor, (_p - start) / (nextStart - start));
         }
         i--;
      }
      return colors.last;
   }

   public method getOrCreateTexture() : Texture {
      if(null == cached_tex)
      {
         int res = colors.numElements * 8;
         cached_tex <= new Texture;
         cached_tex.alloc(res, 1, 4);
         cached_tex.flags = TEX_MINFILTERLINEAR | TEX_MAGFILTERLINEAR | TEX_ALPHA | TEX_CLAMPTOEDGE_S | TEX_CLAMPTOEDGE_T;

         float p = 0.0f;
         float pStep = 1.0f / float(res-1);
         int x = 0;
         loop(res)
         {
            int c32 = getInterpolatedColorAt(p);
            if(b_gr_parse_debug2)
               trace "[>>>] GRGradient::getOrCreateTexture: x="+x+" p="+p+" c32="+UI.GetColorString(c32);
            cached_tex.setXY32(x, 0, c32);
            x++;
            p += pStep;
         }

      }
      return cached_tex;
   }
}


// <class.png>
class GRParseContext {
   String       name;
   StringArray *lines;

   int          cur_line_idx;
   String      *cur_line;
   StringArray *cur_words;

   int restore_token_idx;


   public method initParseContext(String _name, StringArray _lines, int _lineIdx) {
      name   = _name;
      lines <= deref _lines;
      if(b_gr_parse_debug)
         trace "[trc] GRParseContext::initParseContext: lineIdx="+_lineIdx;
      cur_line_idx = _lineIdx;
   }

   public method getSrcLoc() : String {
      if(!name.isBlank())
         return name+":"+(cur_line_idx+1);
      return (cur_line_idx+1);
   }

   public method beginLine(int _lineOffset) : boolean {
      cur_line <= lines.get(cur_line_idx + _lineOffset);
      if(b_gr_parse_debug3)
         trace "[trc] GRParseContext: beginLine: cur_line=\""+cur_line+"\"";
      if(null != cur_line)
      {
         int idxComment = cur_line.indexOf("//", 0);
         if(idxComment >= 0)
            cur_line.substring(0, idxComment);
         String lineTrim;
         cur_line.trim() => lineTrim;
         if(lineTrim.isBlank())
            return false;
         cur_words <= lineTrim.tokenize(" \t-=~<>()[]{}+&|^.;:");
      }
      else
      {
         cur_words <= null;
      }
      if(b_gr_parse_debug3)
         trace "[trc] GRParseContext::beginLine: cur_words="+#(cur_words);
      return (null != cur_words);
   }

   public method nextLine() {
      cur_line_idx++;
      if(b_gr_parse_debug3)
         trace "[trc] GRParseContext::nextLine: => cur_line_idx="+cur_line_idx+" #lines="+lines.numElements;
   }

   public method done() : boolean {
      // trace "xxx done: lines="+#(lines);
      return (cur_line_idx >= lines.numElements);
   }
}


// <class.png>
class GR {

   Graph *main_graph;

   protected Graph *graph;  // current graph

   protected GRStyle    *[] style_classes;
   protected GRPalette  *[] palettes;
   protected GRGradient *[] gradients;

   GRParseContext *[] parse_context_stack;      // context stack
   GRParseContext    *cur_parse_context;        // ref to TOS

   protected StringArray *tokens;  // current line tokens (ref to cur_parse_context.words) (after beginLine())
   protected int token_idx;        // current line token idx

   define int ST_GLOBAL                            = 0;
   define int ST_GLOBAL_INCLUDE                    = 1;
   define int ST_STYLE                             = 100;
   define int ST_STYLE_ID                          = 100;
   define int ST_STYLE_BEGIN                       = 101;
   define int ST_STYLE_BODY                        = 102;
   define int ST_STYLE_INHERIT                     = 104;
   define int ST_STYLE_ATTRIB_ASSIGN               = 105;
   define int ST_STYLE_ATTRIB_VALUE                = 106;
   define int ST_GRAPH_ID                          = 200;
   define int ST_GRAPH_BEGIN                       = 201;
   define int ST_GRAPH_BODY                        = 202;
   define int ST_GRAPH_BODY_NODE_LABEL             = 203;
   define int ST_GRAPH_BODY_EDGE                   = 204;  // "-"|"."|"="|">"|"~"|"<"|"["|"{"
   define int ST_GRAPH_BODY_EDGE_DIR               = 205;  // ">" after "-"
   define int ST_GRAPH_BODY_EDGE_UNDIR             = 206;  // "-" after "-"
   define int ST_GRAPH_BODY_EDGE_HEAD              = 207;  // <head>
   define int ST_GRAPH_BODY_EDGE_REV_DIR           = 208;  // "-" after "<"
   define int ST_GRAPH_BODY_EDGE_REV_HEAD          = 209;  // (reverse) <head>
   define int ST_GRAPH_BODY_EDGE_TAIL_PORT         = 211;  // tail port id
   define int ST_GRAPH_BODY_EDGE_HEAD_PORT_COL     = 212;  // ":" (after edge head id)
   define int ST_GRAPH_BODY_EDGE_HEAD_PORT         = 213;  // head port id
   define int ST_GRAPH_BODY_ATTRIB_ASSIGN          = 230;  // "="
   define int ST_GRAPH_BODY_ATTRIB_VALUE           = 231;  // <attrib_value>
   define int ST_GRAPH_BODY_CLASS_ASSIGN           = 241;  // "="
   define int ST_GRAPH_BODY_CLASS_ID               = 242;  // <style_class_id>
   define int ST_GRAPH_BODY_STYLE                  = 245;  // <unused>
   define int ST_GRAPH_BODY_STYLE_ASSIGN           = 246;  // "="
   define int ST_GRAPH_BODY_STYLE_ID               = 247;  // <style_class_id>
   define int ST_GRAPH_BODY_NODESTYLE_ASSIGN       = 250;  // "="
   define int ST_GRAPH_BODY_NODESTYLE_ID           = 251;  // <style_class_id>
   define int ST_GRAPH_BODY_EDGESTYLE_ASSIGN       = 260;  // "="
   define int ST_GRAPH_BODY_EDGESTYLE_ID           = 261;  // <style_class_id>
   define int ST_GRAPH_BODY_EDGE_ATTRIBS           = 270;  // <edge_attrib_id> or "]"
   define int ST_GRAPH_BODY_EDGE_ATTRIB_ASSIGN     = 271;  // "="
   define int ST_GRAPH_BODY_EDGE_ATTRIB_VALUE      = 272;  // <edge_attrib_value>
   define int ST_GRAPH_BODY_NODE_ATTRIBS           = 280;  // <node_attrib_id> or "]"
   define int ST_GRAPH_BODY_NODE_ATTRIB_ASSIGN     = 281;  // "="
   define int ST_GRAPH_BODY_NODE_ATTRIB_VALUE      = 282;  // <node_attrib_value>
   define int ST_GRAPH_BODY_PALETTE_ASSIGN         = 290;  // "=" after "palette"
   define int ST_GRAPH_BODY_PALETTE_ID             = 291;  // <palette_id> after "="
   define int ST_PALETTE_ID                        = 300;
   define int ST_PALETTE_BEGIN                     = 301;
   define int ST_PALETTE_BODY                      = 302;
   define int ST_PALETTE_INHERIT                   = 304;
   define int ST_PALETTE_COLOR_ASSIGN              = 305;
   define int ST_PALETTE_COLOR_VALUE               = 306;
   define int ST_GRAPH_BODY_XFM_CLASS              = 401;  // widget class name (Slider, Dial, FloatParam, ..)
   define int ST_GRAPH_BODY_XFM                    = 402;  // attribute loop
   define int ST_GRAPH_BODY_XFM_ATTRIB_ASSIGN      = 403;
   define int ST_GRAPH_BODY_XFM_ATTRIB_VALUE       = 404;
   define int ST_GRADIENT_ID                       = 500;
   define int ST_GRADIENT_BEGIN                    = 501;
   define int ST_GRADIENT_BODY                     = 502;
   define int ST_GRADIENT_COLOR_ASSIGN             = 503;
   define int ST_GRADIENT_COLOR_VALUE              = 504;
   define int ST_NODE_PORTS_BEGIN                  = 600;  // "{" (after "ports")
   define int ST_GRAPH_PORTS_BEGIN                 = 601;  // "{" (after "ports")
   define int ST_PORTS                             = 602;  // loop
   define int ST_PORTS_ATTRIB                      = 603;  //
   define int ST_PORTS_ATTRIB_ASSIGN               = 604;  // "="
   define int ST_PORTS_ATTRIB_VALUE                = 605;  //
   define int ST_PORT_DIR_COL                      = 606;  // ":"
   define int ST_PORT_DIR                          = 607;  // n,e,s,w
   define int ST_PORT_POS                          = 608;  // relative position along edge (percentage)
   protected int state;

   define exception ParseError : Error;

   protected Node   *prev_node;
   protected String *prev_attrib_name;  // (todo) stale ref possible ?
   protected String  next_attrib_value; // for dark.blue style palette color names
   protected Edge   *prev_edge;
   protected int     next_edge_style;   // see Edge.STYLE_xxx (def=STYLE_NORMAL)
   protected Port   *cur_port;
   protected Port   *prev_tail_port;
   protected int     prev_tail_dir;     // fallback when prev_tail_port is NULL. 0=auto

   protected int inline_comment_nesting;  // /*..*/

   protected GRStyle *cur_style;  // default style=first declared style or implicit "default" style
   module    GRStyle *cur_node_style;  // never null
   protected GRStyle *cur_edge_style;  // never null

   protected GRPalette  *cur_palette;
   protected GRGradient *cur_gradient;

   protected StringArray *include_paths;


   public method init() {
   }

   public method setIncludePaths(StringArray _paths) {
      include_paths <= Object(deref _paths);
   }

   public method setIncludePathsByRef(StringArray _paths) {
      include_paths <= deref _paths;
   }

   protected method pushParseContext(String _name, boolean _bIncLineIdx, StringArray _lines, int _lineIdx) {
      // 'name': effective path name
      if(null != cur_parse_context)
      {
         if(_bIncLineIdx)
            cur_parse_context.cur_line_idx++;
      }
      cur_parse_context <= new GRParseContext;
      cur_parse_context.initParseContext(deref _name, deref _lines, _lineIdx);
      parse_context_stack.add(#(deref cur_parse_context));
      // trace "xxx push parse_context_stack="+#(parse_context_stack);
      if(b_gr_parse_debug3)
      {
         trace "[trc] pushParseContext bIncLineIdx="+_bIncLineIdx+" newCtx="+#(cur_parse_context)+" name=\""+_name+"\" lineIdx="+_lineIdx;
      }
      cur_parse_context.restore_token_idx = token_idx;
      token_idx = 0;
   }

   protected method popParseContext() { //(boolean _bKeepLineIdx) {
      if(b_gr_parse_debug3)
      {
         trace "[trc] popParseContext cur="+#(cur_parse_context)+" line_idx="+cur_parse_context.cur_line_idx+" parse_context_stack="+#(parse_context_stack)+" num="+parse_context_stack.numElements;
      }
      StringArray oldLines <= cur_parse_context.lines;
      if(parse_context_stack.numElements > 1)
      {
         int lineIdx = cur_parse_context.cur_line_idx;
         parse_context_stack.numElements--;
         cur_parse_context <= parse_context_stack.last;
         tokens    <= cur_parse_context.cur_words;
         token_idx  = cur_parse_context.restore_token_idx;
         if(b_gr_parse_debug3)
            trace "[trc]       restore tokens="+#(tokens)+" token_idx="+token_idx;
         if(/*_bKeepLineIdx ||*/ @(cur_parse_context.lines) == @(oldLines))
         {
            cur_parse_context.cur_line_idx = lineIdx;
            if(b_gr_parse_debug3)
               trace "          continue at line_idx="+cur_parse_context.cur_line_idx;
         }
         return;
      }
      cur_parse_context <= null;
      tokens            <= null;
      if(b_gr_parse_debug3)
         trace "[trc]       restore cur_parse_context=<null>";
   }

   public method getSrcLoc() : String {
      return cur_parse_context.getSrcLoc();
   }

   protected method rewindToken() {
      token_idx--;
   }

   protected method beginStyleClass(String _id) {
      if(b_gr_parse_debug2) trace "[trc] GR::beginStyleClass: id='"+_id+"'";
      cur_style <= findStyleClass(_id);
      if(null == cur_style)
      {
         cur_style <= new GRStyle;
         cur_style.initGRStyle(_id);
         style_classes.add(#(deref cur_style));
      }
      else if(b_gr_parse_debug2)
         trace "[trc] GR::beginStyleClass: updating style '"+_id+"'";
      // // else
      // //    throw ParseError getSrcLoc()+": style class '"+_id+"' already declared";
      cur_node_style <= cur_style;
      cur_edge_style <= cur_style;
   }

   public method findStyleClass(String _id) : GRStyle {
      GRStyle *s;
      foreach s in style_classes
         if(s.id == _id)
            return s;
      return null;
   }

   protected method beginPalette(String _id) {
      if(b_gr_parse_debug2) trace "[trc] GR::beginPalette: id='"+_id+"'";
      cur_palette <= findPalette(_id);
      if(null == cur_palette)
      {
         cur_palette <= new GRPalette;
         cur_palette.initGRPalette(_id);
         palettes.add(#(deref cur_palette));
      }
      else if(b_gr_parse_debug2)
         trace "[trc] GR::beginPalette: updating palette '"+_id+"'";
      // // else
      // //    throw ParseError getSrcLoc()+": palette '"+_id+"' already declared";
   }

   protected method findPalette(String _id) : GRPalette {
      GRPalette *p;
      foreach p in palettes
         if(p.id == _id)
            return p;
      return null;
   }

   protected method beginGradient(String _id) {
      if(b_gr_parse_debug2) trace "[trc] GR::beginGradient: id='"+_id+"'";
      if(null == findGradient(_id))
      {
         cur_gradient <= new GRGradient;
         cur_gradient.id = _id;
         gradients.add(#(deref cur_gradient));
      }
      else if(b_gr_parse_debug2)
         trace "[trc] GR::beginGradient: updating gradient '"+_id+"'";
      // // else
      // //    throw ParseError getSrcLoc()+": gradient '"+_id+"' already declared";
   }

   public method findGradient(String _id) : GRGradient {
      GRGradient *g;
      foreach g in gradients
         if(g.id == _id)
            return g;
      return null;
   }

   protected method beginMainGraph(String _id) {
      if(b_gr_parse_debug) trace "[dbg] GR::beginMainGraph: begin main graph \'"+_id+"\'";
      main_graph <= new Graph;
      main_graph.id = _id;
      main_graph.init(Graph.DEF_GRID_W, Graph.DEF_GRID_H);
      main_graph.reset();
      main_graph.b_unfold = false;  // [23Feb2025] new default is false (i.e. assignment is now redundant)
      graph <= main_graph;

      // // if(style_classes.isEmpty())
      // //    beginStyleClass("default");  // add implicit default style

      // Select first available style class
      cur_style <= findStyleClass("default");/////style_classes.first;
      if(null == cur_style)
      {
         beginStyleClass("default");  // add implicit default style (updates cur_style / cur_node_style / cur_edge_style)
      }
      else
      {
         cur_node_style <= cur_style;
         cur_edge_style <= cur_style;
      }

      // Select first available palette
      cur_palette <= palettes.first;
   }

   protected method saveGraphStyles() {
      // Save current style class/palette/gradient selections
      if(null != graph)
      {
         // trace "xxx save style classes for graph.id="+graph.id+" (cur_style.id="+cur_style.id+")";
         graph.cur_style      <= cur_style;
         graph.cur_node_style <= cur_node_style;
         graph.cur_edge_style <= cur_edge_style;
         graph.cur_palette    <= cur_palette;
         graph.cur_gradient   <= cur_gradient;
      }
   }

   protected method restoreGraphStyles() {
      if(null != graph)
      {
         // Restore style class/palette/gradient selections
         // trace "xxx restore style classes for graph.id="+graph.id;
         cur_style      <= graph.cur_style;
         cur_node_style <= graph.cur_node_style;
         cur_edge_style <= graph.cur_edge_style;
         cur_palette    <= graph.cur_palette;
         cur_gradient   <= graph.cur_gradient;
      }
   }

   protected method beginSubGraph(String _id) {
      Node n <= graph.findNode(_id);  // (todo) remove? handled by replacePrevNodeBySubGraph()
      if(b_gr_parse_debug)
         trace "[dbg] GR::beginSubGraph: begin sub graph \'"+_id+"\' (parent='"+graph.id+"') fwd_node="+Graph.GetNodeString(n);

      saveGraphStyles();

      Graph subgraph <= graph.addGraph(_id);
      // // subgraph.init(Graph.DEF_GRID_W, Graph.DEF_GRID_H);  // [18Feb2025] inherit from parent graph
      // // subgraph.reset();  // [18Feb2025] already done by addGraph()

      // trace "xxx beginSubGraph: copy parent graph gr_attribs="+#(graph.gr_attribs);
      subgraph.copyGRAttribsIfNotExistsExcept(graph.gr_attribs, Graph.a_subgraph_inherit_from_graph_except);
      subgraph.copyGRAttribsIfNotExistsExcept(cur_node_style.attribs, Graph.a_subgraph_inherit_from_node_except);
      graph <= subgraph;
      if(b_gr_parse_debug) trace "[trc] GR::beginSubGraph: id="+_id+" initial gr_attribs="+#(graph.gr_attribs);
   }

   protected method endGraph() {
      graph <= graph.parent_graph;

      restoreGraphStyles();
   }

   protected method replacePrevNodeBySubGraph() {
      if(b_gr_parse_debug3)
         trace "[trc] replacePrevNodeBySubGraph: prev_node"+prev_node.getString();

      saveGraphStyles();

      Graph pGraph <= graph;
      graph <= graph.addGraph(prev_node.id);
      // // graph.init(Graph.DEF_GRID_W, Graph.DEF_GRID_H);  // [18Feb2025] inherit from parent graph
      // // graph.reset();  // [18Feb2025] already done by addGraph()

      // trace "xxx replacePrevNodeBySubGraph: copy prev_node gr_attribs="+#(prev_node.gr_attribs);
      graph.copyGRAttribsIfNotExists(prev_node.gr_attribs);
      // trace "xxx replacePrevNodeBySubGraph: copy parent graph gr_attribs="+#(pGraph.gr_attribs);
      // // // graph.copyGRAttribsIfNotExists(pGraph.gr_attribs);

      Node ioNode <= graph.getIONode();
      pGraph.replaceNode(prev_node, ioNode);
      ioNode.label      = prev_node.label;
      ioNode.gr_attribs = prev_node.gr_attribs;
      pGraph.removeNode(prev_node);
      prev_node <= ioNode;
   }

   protected method getStateString() : String {
      return "state="+TKS.scriptClassConstantToString(#(state), this, "ST_")+"("+state+":"+token_idx+")";
   }

   protected static IsIdentifier(String _s) {
      // (todo) rename to IsString() ?
      return !([";", ".", "-", "~", "=", "+"/*, "#"*/, "{", ":", "[", ">", "<", "graph"/*, "style"*/].containsObject(_s));
   }

   public static ReplaceLiteral(String _value) {
      switch(_value)
      {
         case "true":
            _value = "1";
            break;

         case "false":
            _value = "0";
            break;

         case "on":
            _value = "1";
            break;

         case "off":
            _value = "0";
            break;

         default:
            if('#' == _value.getc(0))
            {
               if(4 == _value.numChars) // #abc => #aabbcc
               {
                  Integer io = _value;
                  io =
                     //  000000
                     (((io&#f00)<<12) | ((io&#f00)<<8)) |
                     (((io&#f0) <<8)  | ((io&#f0) <<4)) |
                     ( (io&15)        | ((io&15)  <<4)) ;
                  // trace "xxx value="+_value+" => "+io.printf("#%08x");
                  _value = io.printf("#%08x");
               }
            }
            else
            {
               int idxSlash = _value.indexOfChar('/', 0);
               if(idxSlash > 0)
               {
                  // fraction (>>1/3<<)
                  local String sNom   <= _value.substring(0, idxSlash);
                  local String sDenom <= _value.substring(idxSlash+1,99);
                  if(sNom.checkConversions() <= YAC_TYPE_FLOAT && sDenom.checkConversions() <= YAC_TYPE_FLOAT)
                     _value = float(sNom) / float(sDenom);
               }
            }
            break;
      }
   }

   protected method setGraphAttribS(String _value) {
      // e.g. test46b.gr
      local StringArray a <= _value.replaceChar(',',';').splitChar(';');
      HashTable ht <= graph.gr_attribs;
      ht["w"] = Object(a.get(0));
      if(a.numElements > 1)
         ht["h"] = Object(a.get(1));
      else
         ht["h"] = Object(a.get(0));
      // // trace "xxx setGraphAttribS: ht="+ht;
   }

   protected method addGraphAttrib(String _key, String _value) {
      // trace "xxx addGraphAttrib(key=\""+_key+"\" value=\""+_value+"\")";
      if("row" != _key)
         ReplaceLiteral(_value);
      HashTable ht <= graph.gr_attribs;
      switch(_key)
      {
         default:
            if(null != graph.parent_graph)
            {
               // Redirect subgraph attrib to IO node (e.g. port attribs in test47)
               Node ioNode <= graph.getIONode();
               ioNode.setGRAttrib(_key, deref _value);
            }
            else
            {
               trace "[~~~] addGraphAttrib: ST_GRAPH_BODY_ATTRIB_VALUE: invalid main graph attrib_name=\""+_key+"\" value=\""+_value+"\" (skipping)";
            }
            break;

         case "grid":
            graph.setGridSizeFromString(_value);
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: graph="+#(graph)+" id="+graph.id+" new grid=("+graph.grid_w+","+graph.grid_h+")";
            break;

         case "pad_col":
         case "col_padding":
         case "pad_row":
         case "row_padding":
         case "slant_factor":
         case "pad":
         case "pad_t":
         case "pad_l":
         case "pad_b":
         case "pad_r":
         case "ipad":
         case "ipad_t":
         case "ipad_l":
         case "ipad_b":
         case "ipad_r":
         case "bgtint":
         case "bgcolor":
         case "bgfill":
         case "bg_pattern":
         case "bg_pattern_intensity":
         case "align":
         case "shape":
         case "shape_round_amount":
         case "shape_round_aspect":
         case "shape_round_limit":
         case "border_shape":
         case "border_style":
         case "border_width":
         case "border_color":
         case "border_tint":
         case "border_dir":
         case "border_blend":
         case "border_alpha":
         case "label_class":
         case "spacer_class":
         case "pixel_layout":
         case "flatten":
         case "sgx":
         case "sgy":
         case "sgxy":
         case "gradient":
         case "gradient_shape":
         case "xmajor":
         case "xmajor_tail":
         case "xmajor_head":
         case "w":  // [01Feb2025] experimental abs positioning (+graph size)
         case "h":  // [01Feb2025] experimental abs positioning (+graph size)
            GR.ReplaceLiteral(_value);
            ht[_key] = Object(_value);
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: graph="+#(graph)+" id="+graph.id+" gr_attribs="+#(ht);
            break;

         case "s":  // [01Feb2025] experimental abs positioning (+graph size)
            setGraphAttribS(_value);
            break;

         case "pad_h":
            GR.ReplaceLiteral(_value);
            ht["pad_l"] = Object(_value);
            ht["pad_r"] = Object(_value);
            break;

         case "pad_v":
            GR.ReplaceLiteral(_value);
            ht["pad_t"] = Object(_value);
            ht["pad_b"] = Object(_value);
            break;

         case "id":
            graph.id = _key;  // rename graph
            break;

         case "layout":
            switch(_value)
            {
               case "none": // [01Feb2025] experimental abs positioning
                  if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set layout=LAYOUT_NONE";
                  graph.layout = Graph.LAYOUT_NONE;
                  break;

               default:
               case "grid":
                  if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set layout=LAYOUT_GRID";
                  graph.layout = Graph.LAYOUT_GRID;
                  break;

               case "table":
                  if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set layout=LAYOUT_TABLE";
                  graph.layout = Graph.LAYOUT_TABLE;
                  break;

               case "fixed":
                  if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set layout=LAYOUT_FIXED";
                  graph.layout = Graph.LAYOUT_FIXED;
                  if(Graph.DEF_CELL_SPACING == graph.initial_col_spacing)
                     graph.initial_col_spacing = 1;
                  if(Graph.DEF_CELL_SPACING == graph.initial_row_spacing)
                     graph.initial_row_spacing = 1;
                  break;
            }
            break;

         case "row":
            graph.addLayoutRow(this, _value);
            break;

         case "cell_spacing":
            graph.initial_col_spacing = mathClampi(int(_value), 1, 20);
            graph.initial_row_spacing = graph.initial_col_spacing;
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set initial_cell_spacing="+graph.initial_col_spacing;
            break;

         case "col_spacing":
            graph.initial_col_spacing = mathClampi(int(_value), 1, 20);
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set initial_col_spacing="+graph.initial_col_spacing;
            break;

         case "row_spacing":
            graph.initial_row_spacing = mathClampi(int(_value), 1, 20);
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set initial_row_spacing="+graph.initial_row_spacing;
            break;

         case "flip_x_opt":
            graph.b_flip_x_opt = (0 != int(_value));
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set b_flip_x_opt="+graph.b_flip_x_opt;
            break;

         case "flip_y_opt":
            graph.b_flip_y_opt = (0 != int(_value));
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set b_flip_y_opt="+graph.b_flip_y_opt;
            break;

         case "rotate":
            graph.b_rotate = (0 != int(_value));
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set b_rotate="+graph.b_rotate;
            break;

         case "flip_x":
            graph.b_flip_x = (0 != int(_value));
            if(b_gr_parse_debug2)
               trace "[trc] addGraphAttrib: set b_flip_x="+graph.b_flip_x;
            break;

         case "flip_y":
            graph.b_flip_y = (0 != int(_value));
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set b_flip_y="+graph.b_flip_y;
            break;

         case "anchor":
            graph.anchor_id <= Object(_value);
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set anchor='"+graph.anchor_id+"'";
            break;

         case "cell_slant":
            graph.b_cell_slant = (0 != int(_value));
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set b_cell_slant="+graph.b_cell_slant;
            break;

         case "slant":
            graph.b_slant = (0 != int(_value));
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set b_slant="+graph.b_slant;
            break;

         case "zero_margin":
            graph.b_zero_margin = (0 != int(_value));
            if(b_gr_parse_debug2) trace "[trc] addGraphAttrib: set zero_margin="+graph.b_zero_margin;
            break;

         case "unfold":
            if(null != graph.parent_graph)
            {
               graph.b_unfold = (0 != int(_value));
               break;
            }
            throw ParseError getSrcLoc()+": \"unfold\" graph attribute is only allowed in sub-graphs";
      }
   }

   public method copyGraphAttribsFromGRStyle(GRStyle _style) {
      HashTable ht <= _style.attribs;
      String *key;
      foreach key in ht
         addGraphAttrib(key, Object(ht[key]));
   }

   protected method tryReplaceColorAttribValue(String _attribName, String _attribValue) {
      if(_attribName & "color" || _attribName & "tint")
      {
         if(null != cur_palette && cur_palette.hasColor(_attribValue))
            _attribValue = cur_palette.getColorAsString(_attribValue);  // e.g. "red" => "#ff0000"
      }
   }

   static BuildPathname(String _newPathname, String _curPathname) : String {
      local String path, file;
      SplitPathname(_newPathname, path, file);
 
      local String curPath, curFile;
      if(null != _curPathname)
      {
         SplitPathname(_curPathname, curPath, curFile);

         if(!curPath.isBlank())
            path.insert(0, curPath+"/");
      }

      if(!path.isBlank())
      {
         local String r <= path+"/"+file;
         return r.replace("//", "/");
      }
      else
         return deref file;
   }

   protected method beginIncludeFile2(String _newPathName) : boolean {
      // trace "xxx beginIncludeFile2: newPathName=\""+_newPathName+"\"";
      local String buf;
      if(buf.loadLocal(_newPathName, true/*bRemoveCR*/) ||
         buf.load(_newPathName, true/*bRemoveCR*/)
         )
      {
         pushParseContext(_newPathName, true/*bIncLineIdx*/, buf.splitChar('\n')/*lines*/, 0/*lineIdx*/);
         cur_parse_context.beginLine(0);
         tokens <= cur_parse_context.cur_words;
         if(b_gr_parse_debug3) trace "[trc] beginIncludeFile: tokens="+#(tokens)+" line_idx="+cur_parse_context.cur_line_idx;
         token_idx = -1;  // parseLineTokens() increments this
         return true;
      }
      return false;
   }

   protected method beginIncludeFile(String _pathName) {
      local String *newPathName;
      local StringArray aTried;

      newPathName <= BuildPathname(_pathName, cur_parse_context.name);
      if(b_gr_parse_debug)
         trace "[dbg] Graph::beginIncludeFile: try newPathName=\""+newPathName+"\" (pathName=\""+_pathName+"\" cur_parse_context.name=\""+cur_parse_context.name+"\")";
      aTried.add(newPathName);

      // trace "xxx include_paths="+#(include_paths);

      if(beginIncludeFile2(newPathName))
         return true;
      else if(null != include_paths)
      {
         // try include paths
         String *incPath;
         foreach incPath in include_paths
         {
            newPathName <= incPath+"/"+ _pathName;
            newPathName.replace("//", "/");
            if(b_gr_parse_debug) trace "[dbg] Graph::beginIncludeFile: try newPathName=\""+newPathName+"\"";
            aTried.add(newPathName);
            if(beginIncludeFile2(newPathName))
               return true;
         }
      }
      throw ParseError getSrcLoc()+": failed to open include file \""+_pathName+"\" (tried "+aTried.string+")";
   }

   protected method parseNextToken() {
      String cTok <= tokens.get(token_idx);

      if("/*" == cTok)
      {
         inline_comment_nesting++;
         return;
      }
      else if("*/" == cTok)
      {
         inline_comment_nesting--;
         if(inline_comment_nesting < 0)
            throw ParseError getSrcLoc()+": inline comment nesting underflow";
         return;
      }

      if(inline_comment_nesting > 0)
         return;

      String nTok  <= tokens.get(token_idx + 1);
      String nnTok <= tokens.get(token_idx + 2);
      if(b_gr_parse_debug3)
         trace "[trc] parseNextToken: "+getStateString()+" cTok='"+cTok+"' nTok='"+nTok+"' nnTok='"+nnTok+"' prev_node="+Graph.GetNodeString(prev_node)+" prev_edge="+Graph.GetEdgeString(prev_edge)+" prev_tail_port="+((null != prev_tail_port)?prev_tail_port.id:"-");

      Node *nHead;
      Graph *prevSubgraph;
      GRPalette *pal;
      GRStyle *edgeLabelStyle;  // "label_class" attribute in inherited attrib or in []
      GRStyle *attribStyle;  // "class" attributes in []
      GRStyle *xfmStyle;

      String pTok <= cTok.quotFlag ? "\nstr" : cTok;  // distinguish between e.g. >>"graph"<< and >>graph<<

      switch(state)
      {
         case ST_GLOBAL:
            switch(pTok)
            {
               default:
                  if(null == main_graph)
                  {
                     // implicit main graph declaration
                     if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GLOBAL: begin implicit main_graph";
                     beginMainGraph("main");
                     rewindToken();
                     state = ST_GRAPH_BODY;
                  }
                  // else: unexpected token
                  return;

               case "include":
                  next_attrib_value.empty();
                  state = ST_GLOBAL_INCLUDE;
                  return;

               case "ports":
                  throw ParseError getSrcLoc()+": unexpected keyword 'ports' found outside of graph or node";

               case "style":
                  if("{" == nTok)
                  {
                     // anonymous / default style class
                     beginStyleClass("default");
                     state = ST_STYLE_BEGIN;
                  }
                  else if("=" == nTok)
                  {
                     // style=mydefaultstyle
                     if(null == main_graph)
                     {
                        // implicit main graph declaration
                        if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GLOBAL: begin implicit main_graph";
                        beginMainGraph("main");
                        rewindToken();
                        state = ST_GRAPH_BODY;
                     }
                     else
                        throw ParseError getSrcLoc()+": unexpected 'style' selector found outside of graph or node";
                  }
                  else
                  {
                     state = ST_STYLE_ID;
                  }
                  return;

               case "palette":
                  if(null == main_graph && "=" == nTok)
                  {
                     // implicit main graph declaration
                     if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GLOBAL: begin implicit main_graph";
                     beginMainGraph("main");
                     rewindToken();
                     state = ST_GRAPH_BODY;
                     return;
                  }
                  state = ST_PALETTE_ID;
                  return;

               case "gradient":
                  if(null == main_graph && "=" == nTok)
                  {
                     // implicit main graph declaration
                     if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GLOBAL: begin implicit main_graph";
                     beginMainGraph("main");
                     rewindToken();
                     state = ST_GRAPH_BODY;
                     return;
                  }
                  state = ST_GRADIENT_ID;
                  return;

               case "graph":
                  if("{" != nTok)
                  {
                     if(null == main_graph)
                     {
                        if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GLOBAL: begin implicit main_graph";
                        beginMainGraph("main");
                     }
                     state = ST_GRAPH_ID;
                  }
                  else if(null == main_graph)
                  {
                     if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GLOBAL: begin main_graph";
                     beginMainGraph("main");
                     state = ST_GRAPH_BEGIN;
                  }
                  else
                  {
                     throw ParseError getSrcLoc()+": sub graphs must not be anonymous";
                  }
                  return;

               case "{":
                  // >>{ a->b }<<
                  if(null == main_graph)
                  {
                     if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GLOBAL: begin implicit main_graph via '{'";
                     beginMainGraph("main");
                     state = ST_GRAPH_BODY;
                     return;
                  }
                  break;
            }
            break;

         case ST_GLOBAL_INCLUDE:
            next_attrib_value.append(cTok);
            if(b_gr_parse_debug2)
               trace "[trc] parseNextToken: ST_GLOBAL_INCLUDE: cTok=\""+cTok+"\" numChars="+cTok.numChars+" next_attrib_value=\""+next_attrib_value+"\" tokens="+#(tokens)+" token_idx="+token_idx;
            if(!cTok.quotFlag)
            {
               if( 1 == cTok.numChars && (" \t-=~<>()[]{}+&|^.;:".indexOfChar(cTok.getc(0), 0) >= 0) ||
                   (null != nTok && (1 == nTok.numChars && (" \t-=~<>()[]{}+&|^.;:".indexOfChar(nTok.getc(0), 0) >= 0))) ||
                   (!next_attrib_value.isBlank() && (token_idx+1) != tokens.numElements)
                   )
               {
                  return;
               }
            }
            beginIncludeFile(next_attrib_value);
            if(null != graph)
               state = ST_GRAPH_BODY;
            else
               state = ST_GLOBAL;
            return;

         case ST_STYLE_ID:
            if(IsIdentifier(cTok))
            {
               beginStyleClass(cTok);
               state = ST_STYLE_BEGIN;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_STYLE_ID: expected style id";
            break;

         case ST_STYLE_BEGIN:
            if("{" == cTok)
            {
               state = ST_STYLE_BODY;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_STYLE_ID: expected '{' in declaration of style class '"+cur_style.id+"'";
            break;

         case ST_STYLE_BODY:
            switch(pTok)
            {
               case ";":
                  return;

               case "}":
                  cur_style <= null;
                  if(null != graph)
                     state = ST_GRAPH_BODY;
                  else
                     state = ST_GLOBAL;
                  return;

               default:
                  if(IsIdentifier(cTok))
                  {
                     if("=" == nTok)
                     {
                        prev_attrib_name <= Object(cTok);  // creates copy of 'cTok' (will be deleted at end of line)
                        state = ST_STYLE_ATTRIB_ASSIGN;
                     }
                     else
                     {
                        prev_attrib_name <= null;  // should already be null
                        state = ST_STYLE_INHERIT;
                        rewindToken();
                     }
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": ST_STYLE_BODY: expected style attribute name (got '"+cTok+"' instead)";
            }
            break;

         case ST_STYLE_INHERIT:
            GRStyle baseStyle <= findStyleClass(cTok);
            if(null != baseStyle)
            {
               cur_style.inheritFrom(baseStyle);
               state = ST_STYLE_BODY;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_STYLE_INHERIT: undeclared style base class '"+cTok+"'";
            break;

         case ST_STYLE_ATTRIB_ASSIGN:
            if("=" == cTok)
            {
               next_attrib_value.empty();
               state = ST_STYLE_ATTRIB_VALUE;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_STYLE_ASSIGN: expected '='";
            break;

         case ST_STYLE_ATTRIB_VALUE:
            if("." == nTok || "-" == nTok)
            {
               next_attrib_value.append(cTok);
            }
            else if("." == cTok || "-" == cTok)
            {
               next_attrib_value.append(cTok);
               // (note) stay in current state and consume strings / "." tokens, e.g. in "1.1;2.2;3.3;4.4"
            }
            else
            {
               cur_style.addStyleAttrib(prev_attrib_name, (next_attrib_value + cTok).replace(",", ";"));
               prev_attrib_name <= null;
               state = ST_STYLE_BODY;
            }
            return;

         case ST_GRAPH_ID:
            if(IsIdentifier(cTok))
            {
               switch(cTok)
               {
                  default:
                     // graph id
                     if(b_gr_parse_debug2)
                        trace "[trc] parseNextToken: ST_GRAPH_ID: graph id is \""+cTok+"\" main_graph="+#(main_graph);
                     if(null != main_graph)
                        beginSubGraph(cTok);
                     else
                        beginMainGraph(cTok);
                     state = ST_GRAPH_BEGIN;
                     return;
               }
            }
            else
               throw ParseError getSrcLoc()+": ST_GRAPH_ID: expected graph id (got '"+cTok+"' instead)";
            break;

         case ST_GRAPH_BEGIN:
            switch(cTok)
            {
               default:
                  throw ParseError getSrcLoc()+": ST_GRAPH_BEGIN: expected '{' (got '"+cTok+"' instead)";

               case "{":
                  state = ST_GRAPH_BODY;
                  return;
            }
            break;

         case ST_GRAPH_BODY:
            switch(pTok)
            {
               default:
                  if(">" != nnTok && "=" == nTok)
                  {
                     // graph attribute
                     prev_attrib_name <= Object(cTok);
                     state = ST_GRAPH_BODY_ATTRIB_ASSIGN;
                     prev_node      <= null;
                     prev_edge      <= null;
                     cur_port       <= null;
                     prev_tail_port <= null;
                     prev_tail_dir   = 0;
                     return;
                  }

                  // node
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  prev_node <= graph.findNode(cTok);
                  if(null == prev_node)
                  {
                     if(graph.isTable())
                        throw GraphError getSrcLoc()+": stray node '"+cTok+"' declaration in table subgraph";
                     if(b_gr_parse_debug3) trace "[trc] parseNextToken: ST_GRAPH_BODY: add node '"+cTok+"' cur_node_style.id="+cur_node_style.id;
                     prev_node <= graph.addNode(cTok);
                     prev_node.copyGRStyleClassAttribs(cur_node_style);
                     prev_node.copyGRAttribsIfNotExistsExcept(graph.gr_attribs, Graph.a_node_inherit_from_graph_except);
                  }
                  else if!(["-", "~", "=", ".", ">", "<", ":"].containsObject(nTok))  // edge decl follows ?
                  {
                     // trace "xxx ST_GRAPH_BODY prev_node cTok="+cTok+" nTok="+nTok;
                     if(b_gr_parse_debug3) trace "[trc] parseNextToken: ST_GRAPH_BODY: node '"+cTok+"' already exists (skipping)";

                     prev_node.copyGRStyleClassAttribs(cur_node_style);
                     prev_node.copyGRAttribsIfNotExistsExcept(graph.gr_attribs, Graph.a_node_inherit_from_graph_except);

                     prevSubgraph <= prev_node.parent_subgraph;
                     if(null != prevSubgraph)
                     {
                        // // AttribsBase.CopyGRAttribs(prev_node.parent_subgraph.gr_attribs,
                        // //                           cur_node_style.attribs
                        // //                           );
                        prevSubgraph.syncGRAttribsFromIONode();
                        // // if(prev_node.haveNodeAttrib("bgcolor"))
                        // //    prevSubgraph.addGraphAttrib(prev_node.getNodeAttrib("bgcolor"));
                        // // AttribsBase.CopyGRAttribsIfNotExists(prevSubgraph.gr_attribs,
                        // //                                      cur_node_style.attribs
                        // //                                      );
                     }
                  }

                  // Copy current style class attribs for previously declared node unless at least one attrib has already been that (via [])
                  //   (note) => the default style is always applied so this is never executed. => set style class before node definition (e.g. before "row=")
                  // // if(!prev_node.hasGRStyleClassAttribs())
                  // //    prev_node.copyGRStyleClassAttribs(cur_node_style);

                  prev_edge <= null;

                  if(null != nTok && nTok.quotFlag)  // >>a "node a"<<
                     state = ST_GRAPH_BODY_NODE_LABEL;
                  return;

               case ":":
                  if(null != prev_node)
                  {
                     prev_tail_port <= null;
                     prev_tail_dir   = 0;
                     state = ST_GRAPH_BODY_EDGE_TAIL_PORT;
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": ST_GRAPH_BODY: stray ':' (missing previous node)";

               case ";":
                  // a;b;c
                  prev_node      <= null;
                  prev_edge      <= null;
                  cur_port       <= null;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  return;

               case "[":
                  if(null != prev_edge)
                  {
                     if(b_gr_parse_debug3) trace "[dbg] parseNextToken: ST_GRAPH_BODY: begin prev_edge="+prev_edge.getString()+" attribs (prev_node="+Graph.GetNodeString(prev_node)+")";
                     state = ST_GRAPH_BODY_EDGE_ATTRIBS;
                     return;
                  }
                  else if(null != prev_node)
                  {
                     if(b_gr_parse_debug3) trace "[dbg] parseNextToken: ST_GRAPH_BODY: begin prev_node="+prev_node.getString()+" attribs";
                     state = ST_GRAPH_BODY_NODE_ATTRIBS;
                     return;
                  }
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY: prev node/edge is null, can't assign attribs (tok='[')";

               case "(":
                  if(null != prev_node)
                  {
                     state = ST_GRAPH_BODY_XFM_CLASS;
                     return;
                  }
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY: prev node is null, can't assign XFM attribs (tok='(')";

               case "-":  // ->
                  // normal edge
                  if(null != prev_node)
                  {
                     if("-" == nTok) // "--"
                     {
                        state = ST_GRAPH_BODY_EDGE_UNDIR;
                        next_edge_style = Edge.STYLE_UNDIR;
                     }
                     else
                     {
                        state = ST_GRAPH_BODY_EDGE_DIR;
                        next_edge_style = Edge.STYLE_NORMAL;
                     }
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": edge tail is null";

               case ".":  // .>
                  // dotted edge
                  if(null != prev_node)
                  {
                     state = ST_GRAPH_BODY_EDGE_DIR;
                     next_edge_style = Edge.STYLE_DOTTED;
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": edge tail is null";

               case "=":  // =>
                  // dashed edge
                  if(">" == nTok)
                  {
                     if(null != prev_node)
                     {
                        state = ST_GRAPH_BODY_EDGE_DIR;
                        next_edge_style = Edge.STYLE_DASHED;
                        return;
                     }
                     else
                        throw ParseError getSrcLoc()+": edge tail is null";
                  }
                  break;

               case ">":  // >>
                  // bold edge
                  if(null != prev_node)
                  {
                     state = ST_GRAPH_BODY_EDGE_DIR;
                     next_edge_style = Edge.STYLE_BOLD;
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": edge tail is null";

               case "~":  // ~>
                  // invisible/hidden edge
                  if(null != prev_node)
                  {
                     state = ST_GRAPH_BODY_EDGE_DIR;
                     next_edge_style = Edge.STYLE_HIDDEN;
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": edge tail is null";

               case "<":
                  // reverse edge
                  // trace "xxx reverse edge prev_node="+#(prev_node)+" nTok='"+nTok+"'";
                  if(null != prev_node)
                  {
                     if(">" == nTok)  // <>
                     {
                        state = ST_GRAPH_BODY_EDGE_DIR;
                        next_edge_style = Edge.STYLE_BIDIR;
                     }
                     else
                     {
                        state = ST_GRAPH_BODY_EDGE_REV_DIR;
                     }
                     return;
                  }
                  else
                  {
                     throw ParseError getSrcLoc()+": reverse edge tail is null";
                  }
                  break;

               case "ports":
                  if(null != prev_edge)
                     state = ST_NODE_PORTS_BEGIN;
                  else
                     state = ST_GRAPH_PORTS_BEGIN;
                  return;

               case "graph":
                  state = ST_GRAPH_ID;
                  prev_node      <= null;
                  prev_edge      <= null;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  return;

               case "{":
                  if(null != prev_node)
                  {
                     // replace previous node by sub graph
                     if(b_gr_parse_debug3) trace "[trc] Graph::parseNextToken: ST_GRAPH_BODY: replace prev_node"+prev_node.getString()+" by sub graph";
                     replacePrevNodeBySubGraph();
                     return;
                  }
                  else
                  {
                     throw ParseError getSrcLoc()+": '{' must be preceded by node declaration";
                  }
                  break;

               case "+":
                  if(null != prev_node)
                  {
                     if(b_gr_parse_debug2) trace "[trc] Graph::parseNextToken: ST_GRAPH_BODY: setting line break ('+') on prev_node"+prev_node.getString();
                     prev_node.b_line_break = true;
                  }
                  else
                     trace "[~~~] Graph::parseNextToken: ST_GRAPH_BODY: ignoring line break ('+') since prev_node is null";
                  return;

               case "class":
                  // copy graph attribs from style class (e.g. layout, pixel_layout, bgcolor, ..)
                  state = ST_GRAPH_BODY_CLASS_ASSIGN;
                  prev_node      <= null;
                  prev_edge      <= null;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  return;

               case "node_style":
                  state = ST_GRAPH_BODY_NODESTYLE_ASSIGN;
                  prev_node      <= null;
                  prev_edge      <= null;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  return;

               case "edge_style":
                  state = ST_GRAPH_BODY_EDGESTYLE_ASSIGN;
                  prev_node      <= null;
                  prev_edge      <= null;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  return;

               case "style":
                  if("{" == nTok)
                  {
                     beginStyleClass("default");
                     state = ST_STYLE_BEGIN;
                     return;
                  }
                  else if("{" == nnTok)
                  {
                     state = ST_STYLE_ID;
                     return;
                  }
                  else if("=" == nTok)
                  {
                     // select default style class for next nodes and edges
                     state = ST_GRAPH_BODY_STYLE_ASSIGN;
                     prev_node      <= null;
                     prev_edge      <= null;
                     prev_tail_port <= null;
                     prev_tail_dir   = 0;
                     return;
                  }
                  throw ParseError getSrcLoc()+": 'style' must be followed by '{' or '<style_id> {'";

               case "palette":
                  if("=" == nTok)
                  {
                     state = ST_GRAPH_BODY_PALETTE_ASSIGN;
                     return;
                  }
                  if("{" == nnTok)
                  {
                     state = ST_PALETTE_ID;
                     return;
                  }
                  throw ParseError getSrcLoc()+": 'palette' must be followed by '<palette_id> {' or '= <palette_id>'";

               case "gradient":
                  if("{" == nnTok)
                  {
                     state = ST_GRADIENT_ID;
                     return;
                  }
                  throw ParseError getSrcLoc()+": 'gradient' must be followed by '<gradient_id> {'";

               case "include":
                  next_attrib_value.empty();
                  state = ST_GLOBAL_INCLUDE;
                  return;

               case "}":
                  if(b_gr_parse_debug2) trace "[trc] parseNextToken: '}' main_graph="+#(main_graph)+" graph="+#(graph)+" graph.parent_graph="+#(graph.parent_graph);
                  if(null != graph.parent_graph)
                  {
                     if(b_gr_parse_debug) trace "[trc] parseNextToken: ------------------------- layout subgraph \'"+graph.id+"'";
                     if(graph.layout())
                     {
                        // trace "xxx ok getAnchor()="+Graph.GetNodeString(graph.getAnchor());
                        if(b_gr_debug2)
                        {
                           graph.debugPrintNodesAndEdges();
                           graph.debugPrint();
                        }
                     }
                     else
                        throw Error "sub graph '"+graph.id+"' layout() failed";
                  }

                  // trace "xxx "+getSrcLoc()+": end (sub-)graph graph.id="+graph.id+" parent_graph="+#(graph.parent_graph);
                  endGraph();  // select graph.parent_graph or null + restore parent graph style/palette
                  if(null != graph)
                     state = ST_GRAPH_BODY;
                  else
                     state = ST_GLOBAL;

                  prev_node      <= null;
                  prev_edge      <= null;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  return;
            }
            break;

         case ST_GRAPH_BODY_NODE_LABEL:
            if(b_gr_parse_debug3) trace "[trc] parseNextToken: ST_GRAPH_BODY_NODE_LABEL: prev_node="+#(prev_node);
            if(b_gr_parse_debug2) trace "[dbg] parseNextToken: assign label \""+cTok+"\" to node '"+prev_node.id+"'";
            prev_node.label = cTok;
            state = ST_GRAPH_BODY;
            prev_edge <= null;
            return;

         case ST_GRAPH_BODY_EDGE:
            switch(cTok)
            {
               default:
                  if(cTok.quotFlag)
                  {
                     prev_edge.label = cTok;
                  }
                  else
                  {
                     if("=" == cTok && ">" == nTok)
                     {
                        state = ST_GRAPH_BODY_EDGE_DIR;
                        next_edge_style = Edge.STYLE_DASHED;
                        return;
                     }

                     // no next edge
                     rewindToken();
                     state = ST_GRAPH_BODY;
                     prev_node      <= null;
                     prev_tail_port <= null;
                     prev_tail_dir   = 0;
                  }
                  return;

               case ":":
                  state = ST_GRAPH_BODY_EDGE_HEAD_PORT;
                  return;

               case "-":  // ->
                  if("-" == nTok) // --
                  {
                     state = ST_GRAPH_BODY_EDGE_UNDIR;
                     next_edge_style = Edge.STYLE_NORMAL;
                  }
                  else
                  {
                     state = ST_GRAPH_BODY_EDGE_DIR;
                     next_edge_style = Edge.STYLE_NORMAL;
                  }
                  return;

               case ".":  // .>
                  state = ST_GRAPH_BODY_EDGE_DIR;
                  next_edge_style = Edge.STYLE_DOTTED;
                  return;

               case ">":  // >>
                  state = ST_GRAPH_BODY_EDGE_DIR;
                  next_edge_style = Edge.STYLE_BOLD;
                  return;

               case "~":  // ~>
                  state = ST_GRAPH_BODY_EDGE_DIR;
                  next_edge_style = Edge.STYLE_HIDDEN;
                  return;

               case "<":
                  if(">" == nTok) // <>
                  {
                     state = ST_GRAPH_BODY_EDGE_DIR;
                     next_edge_style = Edge.STYLE_BIDIR;
                  }
                  else
                  {
                     state = ST_GRAPH_BODY_EDGE_REV_DIR;
                  }
                  return;

               case "[":
                  state = ST_GRAPH_BODY_EDGE_ATTRIBS;
                  return;

               case "{":
                  if(null != prev_node)
                  {
                     // replace previous node by sub graph
                     if(b_gr_parse_debug3) trace "[trc] parseNextToken: ST_GRAPH_BODY: replace prev_node"+prev_node.getString()+" by sub graph";
                     replacePrevNodeBySubGraph();
                     state = ST_GRAPH_BODY;
                     return;
                  }
                  else
                  {
                     throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE: '{' must be preceded by node declaration";
                  }
                  break;
            }
            break;

         case ST_GRAPH_BODY_EDGE_DIR:
            switch(cTok)
            {
               case ">":
                  state = ST_GRAPH_BODY_EDGE_HEAD;
                  return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_DIR: expected '>', have '"+cTok+"'";

         case ST_GRAPH_BODY_EDGE_UNDIR: // --
            switch(cTok)
            {
               case "-":
                  state = ST_GRAPH_BODY_EDGE_HEAD;
                  return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_UNDIR: expected '-', have '"+cTok+"'";

         case ST_GRAPH_BODY_EDGE_HEAD:
            switch(cTok)
            {
               default:
                  nHead <= graph.findNode(cTok);
                  if(null == nHead)
                  {
                     if(graph.isTable())
                        throw GraphError getSrcLoc()+": implicit stray node '"+cTok+"' declaration in table subgraph";
                     if(b_gr_parse_debug2) trace "[dbg] parseNextToken: add implicit edge head node '"+cTok+"'";
                     nHead <= graph.addNode(cTok);
                     nHead.copyGRStyleClassAttribs(cur_node_style);
                     nHead.copyGRAttribsIfNotExistsExcept(graph.gr_attribs, Graph.a_node_inherit_from_graph_except);
                  }
                  // edge from cur_node to nHead
                  prev_edge <= graph.addEdge(prev_node, nHead);
                  prev_edge.copyGRStyleClassAttribs(cur_edge_style);
                  prev_edge.copyGRAttribsIfNotExistsExcept(graph.gr_attribs, Graph.a_edge_inherit_from_graph_except);
                  prev_edge.tail_port <= prev_tail_port;
                  prev_edge.tail_dir   = prev_tail_dir;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  if(prev_edge.haveEdgeAttrib("label_class"))
                  {
                     edgeLabelStyle <= findStyleClass(prev_edge.getEdgeAttrib("label_class"));
                     if(null != edgeLabelStyle)
                     {
                        // trace "xxx copy edgeLabelStyle \""+prev_edge.getEdgeAttrib("label_class")+"\" to edge="+prev_edge.getString();
                        prev_edge.copyGRStyleClassAttribs(edgeLabelStyle);
                     }
                     else
                        throw ParseError getSrcLoc()+": undeclared edge label_class \'"+prev_edge.getEdgeAttrib("label_class")+"\'";
                  }
                  prev_edge.edge_style = next_edge_style;
                  prev_edge.addEdgeAttrib("style", Edge.GetEdgeStyleName(next_edge_style));
                  if(b_gr_parse_debug2)
                     trace "[dbg] parseNextToken: addEdge "+prev_edge.getString();///(tail"+prev_node.getString()+" head"+nHead.getString()+")";
                  prev_node <= nHead;
                  if(":" == nTok)
                     state = ST_GRAPH_BODY_EDGE_HEAD_PORT_COL;  // >>:<port id><<
                  else
                     state = ST_GRAPH_BODY_EDGE;  // try parsing next chained edge
                  return;
            }
            break;

         case ST_GRAPH_BODY_EDGE_REV_DIR:
            switch(cTok)
            {
               case "-":  // <-
                  state = ST_GRAPH_BODY_EDGE_REV_HEAD;
                  next_edge_style = Edge.STYLE_NORMAL;
                  return;

               case ".":  // <.
                  state = ST_GRAPH_BODY_EDGE_REV_HEAD;
                  next_edge_style = Edge.STYLE_DOTTED;
                  return;

               case "=":  // <=
                  state = ST_GRAPH_BODY_EDGE_REV_HEAD;
                  next_edge_style = Edge.STYLE_DASHED;
                  return;

               case "<":  // <<
                  state = ST_GRAPH_BODY_EDGE_REV_HEAD;
                  next_edge_style = Edge.STYLE_BOLD;
                  return;

               case "~":  // <~
                  state = ST_GRAPH_BODY_EDGE_REV_HEAD;
                  next_edge_style = Edge.STYLE_HIDDEN;
                  return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_REV_DIR: expected '-'";

         case ST_GRAPH_BODY_EDGE_REV_HEAD:
            switch(cTok)
            {
               default:
                  nHead <= graph.findNode(cTok);
                  if(null == nHead)
                  {
                     if(graph.isTable())
                        throw GraphError getSrcLoc()+": implicit stray node '"+cTok+"' declaration in table subgraph";
                     if(b_gr_parse_debug) trace "[dbg] parseNextToken: add implicit reverse edge head node '"+cTok+"'";
                     nHead <= graph.addNode(cTok);
                     nHead.copyGRStyleClassAttribs(cur_node_style);
                     nHead.copyGRAttribsIfNotExistsExcept(graph.gr_attribs, Graph.a_node_inherit_from_graph_except);
                  }
                  // reverse edge from cur_node to nHead
                  prev_edge <= graph.addEdgeRev(prev_node, nHead);
                  prev_edge.copyGRStyleClassAttribs(cur_edge_style);
                  prev_edge.copyGRAttribsIfNotExistsExcept(graph.gr_attribs, Graph.a_edge_inherit_from_graph_except);
                  prev_edge.tail_port <= prev_tail_port;
                  prev_edge.tail_dir   = prev_tail_dir;
                  prev_tail_port <= null;
                  prev_tail_dir   = 0;
                  if(prev_edge.haveEdgeAttrib("label_class"))
                  {
                     edgeLabelStyle <= findStyleClass(prev_edge.getEdgeAttrib("label_class"));
                     if(null != edgeLabelStyle)
                     {
                        prev_edge.copyGRStyleClassAttribs(edgeLabelStyle);
                     }
                     else
                        throw ParseError getSrcLoc()+": undeclared edge label_class \'"+prev_edge.getEdgeAttrib("label_class")+"\'";
                  }
                  prev_edge.edge_style = next_edge_style;
                  prev_edge.addEdgeAttrib("style", Edge.GetEdgeStyleName(next_edge_style));
                  if(b_gr_parse_debug2)
                     trace "[dbg] parseNextToken: addEdgeRev "+prev_edge.getString();///(tail"+prev_node.getString()+" head"+nHead.getString()+")";

                  prev_node <= nHead;
                  // // prev_node.copyGRStyleClassAttribs(cur_node_style);

                  if(":" == nTok)
                     state = ST_GRAPH_BODY_EDGE_HEAD_PORT_COL;  // >>:<port id><<
                  else
                     state = ST_GRAPH_BODY_EDGE;  // try parsing next chained edge
                  return;
            }
            break;

         case ST_GRAPH_BODY_EDGE_TAIL_PORT:
            // trace "xxx ST_GRAPH_BODY_EDGE_TAIL_PORT: prev_node="+#(prev_node)+" prev_node.id="+prev_node.id;
            prev_tail_port <= prev_node.findPort(cTok);
            if(null != prev_tail_port)
            {
               state = ST_GRAPH_BODY;
               return;
            }
            else
            {
               switch(cTok)
               {
                  case "n":
                  case "t":
                  case "north":
                  case "top":
                     prev_tail_dir = Layout.TOP;
                     state = ST_GRAPH_BODY;
                     return;

                  case "w":
                  case "l":
                  case "west":
                  case "left":
                     prev_tail_dir = Layout.LEFT;
                     state = ST_GRAPH_BODY;
                     return;

                  case "s":
                  case "b":
                  case "south":
                  case "bottom":
                     prev_tail_dir = Layout.BOTTOM;
                     state = ST_GRAPH_BODY;
                     return;

                  case "e":
                  case "r":
                  case "east":
                  case "right":
                     prev_tail_dir = Layout.RIGHT;
                     state = ST_GRAPH_BODY;
                     return;
               }
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_TAIL_PORT: undeclared port '"+cTok+"'";

         case ST_GRAPH_BODY_EDGE_HEAD_PORT_COL:
            if(":" == cTok)
            {
               state = ST_GRAPH_BODY_EDGE_HEAD_PORT;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_GRAPH_BODY_HEAD_PORT_COL: expected ':' (got '"+cTok+"' instead)";

         case ST_GRAPH_BODY_EDGE_HEAD_PORT:
            prev_edge.head_port <= prev_node.findPort(cTok);
            // die "prev_node.findPort("+cTok+")="+prev_node.findPort(cTok);
            if(null != prev_edge.head_port)
            {
               prev_tail_port <= prev_edge.head_port;
               state = ST_GRAPH_BODY_EDGE;
               return;
            }
            else
            {
               switch(cTok)
               {
                  case "n":
                  case "t":
                  case "north":
                  case "top":
                     prev_edge.head_dir = Layout.TOP;
                     state = ST_GRAPH_BODY_EDGE;
                     return;

                  case "w":
                  case "l":
                  case "west":
                  case "left":
                     prev_edge.head_dir = Layout.LEFT;
                     state = ST_GRAPH_BODY_EDGE;
                     return;

                  case "s":
                  case "b":
                  case "south":
                  case "bottom":
                     prev_edge.head_dir = Layout.BOTTOM;
                     state = ST_GRAPH_BODY_EDGE;
                     return;

                  case "e":
                  case "r":
                  case "east":
                  case "right":
                     prev_edge.head_dir = Layout.RIGHT;
                     state = ST_GRAPH_BODY_EDGE;
                     return;
               }
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_HEAD_PORT: undeclared port '"+cTok+"'";

         case ST_GRAPH_BODY_ATTRIB_ASSIGN:
            if("=" == cTok)
            {
               next_attrib_value.empty();
               state = ST_GRAPH_BODY_ATTRIB_VALUE;
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_ATTRIB_ASSIGN: expected '='";

         case ST_GRAPH_BODY_ATTRIB_VALUE:
            if("." == nTok)
            {
               next_attrib_value.append(cTok);
            }
            else if("." == cTok)
            {
               next_attrib_value.append(cTok);
               // (note) stay in current state and consume strings / "." tokens, e.g. in "1.1;2.2;3.3;4.4"
            }
            else if("-" == cTok)
            {
               if(!next_attrib_value.isBlank())
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_ATTRIB_VALUE: unexpected '-'";
               next_attrib_value.append(cTok);
            }
            else
            {
               next_attrib_value.append(cTok);
               tryReplaceColorAttribValue(prev_attrib_name, next_attrib_value);
               addGraphAttrib(prev_attrib_name, next_attrib_value.replace(",",";"));
               prev_attrib_name <= null;
               state = ST_GRAPH_BODY;
            }
            return;

         case ST_GRAPH_BODY_CLASS_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRAPH_BODY_CLASS_ID;
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_CLASS_ASSIGN: expected '='";

         case ST_GRAPH_BODY_CLASS_ID:
            if(IsIdentifier(cTok))
            {
               GRStyle classStyle <= findStyleClass(cTok);
               if(null != classStyle)
               {
                  copyGraphAttribsFromGRStyle(classStyle);  // calls addGraphAttrib() for each attrib
                  state = ST_GRAPH_BODY;
                  return;
               }
               else
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_CLASS_ID: undeclared style class '"+cTok+"'";  // make this a warning ?
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_CLASS_ID: expected style class id (got \""+cTok+"\" instead)";

         case ST_GRAPH_BODY_STYLE_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRAPH_BODY_STYLE_ID;
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_STYLE_ASSIGN: expected '='";

         case ST_GRAPH_BODY_STYLE_ID:
            if(IsIdentifier(cTok))
            {
               cur_style <= findStyleClass(cTok);
               if(null == cur_style && "default" == cTok)
                  cur_style <= findStyleClass("default");/////style_classes.first;
               cur_node_style <= cur_style;
               cur_edge_style <= cur_style;
               if(null != cur_style)
               {
                  if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GRAPH_BODY_STYLE_ID: select node+edge style class '"+cur_style.id+"'";
                  state = ST_GRAPH_BODY;
                  return;
               }
               else
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_STYLE_ID: undeclared style class '"+cTok+"'";  // make this a warning and revert to default ?
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_STYLE_ID: expected style id (got \""+cTok+"\" instead)";

         case ST_GRAPH_BODY_NODESTYLE_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRAPH_BODY_NODESTYLE_ID;
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_NODESTYLE_ASSIGN: expected '='";

         case ST_GRAPH_BODY_NODESTYLE_ID:
            if(IsIdentifier(cTok))
            {
               cur_node_style <= findStyleClass(cTok);
               if(null != cur_node_style)
               {
                  if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GRAPH_BODY_NODESTYLE_ID: select node style class '"+cur_node_style.id+"'";
                  state = ST_GRAPH_BODY;
                  return;
               }
               else
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_NODESTYLE_ID: undeclared style class '"+cTok+"'";  // make this a warning and revert to default ?
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_NODESTYLE_ID: expected style id (got \""+cTok+"\" instead)";

         case ST_GRAPH_BODY_EDGESTYLE_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRAPH_BODY_EDGESTYLE_ID;
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGESTYLE_ASSIGN: expected '='";

         case ST_GRAPH_BODY_EDGESTYLE_ID:
            if(IsIdentifier(cTok))
            {
               cur_edge_style <= findStyleClass(cTok);
               if(null != cur_edge_style)
               {
                  if(b_gr_parse_debug2) trace "[dbg] parseNextToken: ST_GRAPH_BODY_EDGESTYLE_ID: select node style class '"+cur_edge_style.id+"'";
                  state = ST_GRAPH_BODY;
                  return;
               }
               else
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGESTYLE_ID: undeclared style class '"+cTok+"'";  // make this a warning and revert to default ?
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGESTYLE_ID: expected style id (got \""+cTok+"\" instead)";

         case ST_GRAPH_BODY_EDGE_ATTRIBS:
            switch(cTok)
            {
               case "]":
                  state = ST_GRAPH_BODY;
                  return;

               default:
                  if(IsIdentifier(cTok))
                  {
                     prev_attrib_name <= Object(cTok);
                     state = ST_GRAPH_BODY_EDGE_ATTRIB_ASSIGN;
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_ATTRIBS: expected attrib id (got '"+cTok+"' instead)";
            }
            break;

         case ST_GRAPH_BODY_EDGE_ATTRIB_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRAPH_BODY_EDGE_ATTRIB_VALUE;
               next_attrib_value.empty();
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_ATTRIB_ASSIGN: expected '='";

         case ST_GRAPH_BODY_EDGE_ATTRIB_VALUE:
            if("." == cTok)
            {
               // consume "." in >>dark.blue
               return;
            }
            else if("-" == cTok)
            {
               if(!next_attrib_value.isBlank())
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_ATTRIB_VALUE: unexpected '-'";
               next_attrib_value.append(cTok);
            }
            if("." == nTok)
            {
               // consume first id in >>dark.blue<<
               if(!next_attrib_value.isBlank())
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_EDGE_ATTRIB_VALUE: unexpected '.' after '-'";
               next_attrib_value = cTok;
               return;
            }
            else if(!next_attrib_value.isBlank() && "-" != next_attrib_value)
            {
               pal <= findPalette(next_attrib_value);
               if(null != pal)
               {
                  if(pal.hasColor(cTok))
                     next_attrib_value = pal.getColorAsString(cTok);
                  else
                     throw ParseError getSrcLoc()+": palette \""+next_attrib_value+"\" has no color named \""+cTok+"\"";
               }
               else if( (((next_attrib_value+"."+cTok).checkConversions()) <= YAC_TYPE_FLOAT) )
               {
                  // "3"."14" => 3.14
                  next_attrib_value.append("."+cTok);
               }
               else
                  throw ParseError getSrcLoc()+": undeclared palette \""+next_attrib_value+"\" (can't resolve edge color \""+cTok+"\")";
            }
            else
               next_attrib_value.append(cTok);

            tryReplaceColorAttribValue(prev_attrib_name, next_attrib_value);
            prev_edge.addEdgeAttrib(prev_attrib_name, next_attrib_value.replace(",",";"));
            if("class" == prev_attrib_name)
            {
               GRStyle edgeStyle <= findStyleClass(next_attrib_value);
               if(null != edgeStyle)
               {
                  prev_edge.copyGRStyleClassAttribs(edgeStyle);
               }
               else
               {
                  trace "[~~~] "+getSrcLoc()+": ST_GRAPH_BODY_EDGE_ATTRIB_VALUE: undeclared edge style class \""+next_attrib_value+"\", skipping..";
               }
            }
            else if("label_class" == prev_attrib_name)
            {
               edgeLabelStyle <= findStyleClass(next_attrib_value);
               if(null != edgeLabelStyle)
               {
                  // trace "xxx copyEdgeLabelStyle via attrib label_class";
                  prev_edge.copyGRStyleClassAttribs(edgeLabelStyle);
               }
               else
               {
                  trace "[~~~] "+getSrcLoc()+": ST_GRAPH_BODY_NODE_ATTRIB_VALUE: undeclared edge label_class \""+next_attrib_value+"\", skipping..";
               }
            }

            prev_attrib_name <= null;
            state = ST_GRAPH_BODY_EDGE_ATTRIBS;
            return;

         case ST_GRAPH_BODY_NODE_ATTRIBS:
            switch(cTok)
            {
               case "]":
                  state = ST_GRAPH_BODY;
                  return;

               default:
                  if(IsIdentifier(cTok))
                  {
                     prev_attrib_name <= Object(cTok);
                     state = ST_GRAPH_BODY_NODE_ATTRIB_ASSIGN;
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": ST_GRAPH_BODY_NODE_ATTRIBS: expected attrib id (got '"+cTok+"' instead)";
            }
            break;

         case ST_GRAPH_BODY_NODE_ATTRIB_ASSIGN:
            if("=" == cTok)
            {
               next_attrib_value.empty();
               state = ST_GRAPH_BODY_NODE_ATTRIB_VALUE;
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_NODE_ATTRIB_ASSIGN: expected '='";

         case ST_GRAPH_BODY_NODE_ATTRIB_VALUE:
            if("-" == cTok)
            {
               if(!next_attrib_value.isBlank())
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_NODE_ATTRIB_VALUE: unexpected '-'";
               next_attrib_value = "-";
               return;
            }
            else if("." == cTok)
            {
               // consume "." in >>dark.blue<<
               return;
            }
            if("." == nTok)
            {
               // consume first id in >>dark.blue<<
               if(!next_attrib_value.isBlank())
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_NODE_ATTRIB_VALUE: unexpected '.' after '-'";
               next_attrib_value = cTok;
               return;
            }
            else if(!next_attrib_value.isBlank() && "-" != next_attrib_value)
            {
               pal <= findPalette(next_attrib_value);
               if(null != pal)
               {
                  if(pal.hasColor(cTok))
                     next_attrib_value = pal.getColorAsString(cTok);
                  else
                     throw ParseError getSrcLoc()+": palette \""+next_attrib_value+"\" has no color named \""+cTok+"\"";
               }
               else if( (((next_attrib_value+"."+cTok).checkConversions()) <= YAC_TYPE_FLOAT) )
               {
                  // "3"."14" => 3.14
                  next_attrib_value.append("."+cTok);
               }
               else
                  throw ParseError getSrcLoc()+": undeclared palette \""+next_attrib_value+"\" (can't resolve color \""+cTok+"\")";
            }
            else
               next_attrib_value.append(cTok);

            tryReplaceColorAttribValue(prev_attrib_name, next_attrib_value);
            if("id" == prev_attrib_name)
            {
               graph.renameLayoutRowNodeRefs(prev_node.id, next_attrib_value/*newId*/);
               prev_node.renameNode(next_attrib_value/*newId*/);
            }
            else
            {
               prev_node.addNodeAttrib(prev_attrib_name, next_attrib_value.replace(",",";"));
            }
            if("class" == prev_attrib_name)
            {
               GRStyle nodeStyle <= findStyleClass(next_attrib_value);
               if(null != nodeStyle)
               {
                  prev_node.copyGRStyleClassAttribs(nodeStyle);

                  if(null != prev_node.parent_subgraph)
                  {
                     // is IO node for subgraph, replicate attribs to subgraph
                     prevSubgraph <= prev_node.parent_subgraph;
                     prevSubgraph.copyGRAttribsIfNotExists(prev_node.gr_attribs);
                     // trace "xxx sync graph from new io_node class bgcolor="+UI.GetColorString(prev_node.getNodeAttrib("bgcolor"));
                     // trace "xxx sync graph from new io_node class bgtint="+UI.GetColorString(prev_node.getNodeAttrib("bgtint"));
                     prevSubgraph.syncGRAttribsFromIONode();
                  }
               }
               else
               {
                  trace "[~~~] "+getSrcLoc()+": ST_GRAPH_BODY_NODE_ATTRIB_VALUE: undeclared node style class \""+next_attrib_value+"\", skipping..";
               }
            }
            prev_attrib_name <= null;
            state = ST_GRAPH_BODY_NODE_ATTRIBS;
            return;

         case ST_PALETTE_ID:
            if(IsIdentifier(cTok))
            {
               beginPalette(cTok);
               state = ST_PALETTE_BEGIN;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_PALETTE_ID: expected palette id (got '"+cTok+"' instead)";
            break;

         case ST_PALETTE_BEGIN:
            if("{" == cTok)
            {
               state = ST_PALETTE_BODY;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_PALETTE_ID: expected '{' in declaration of palette '"+cur_palette.id+"'";
            break;

         case ST_PALETTE_BODY:
            switch(cTok)
            {
               case ";":
                  return;

               case "}":
                  cur_palette <= null;
                  if(null != graph)
                     state = ST_GRAPH_BODY;
                  else
                     state = ST_GLOBAL;
                  return;

               default:
                  if(IsIdentifier(cTok))
                  {
                     if("=" == nTok)
                     {
                        prev_attrib_name <= Object(cTok);
                        state = ST_PALETTE_COLOR_ASSIGN;
                     }
                     else
                     {
                        prev_attrib_name <= null;  // should already be null
                        state = ST_PALETTE_INHERIT;
                        rewindToken();
                     }
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": ST_PALETTE_BODY: expected palette color name (got '"+cTok+"' instead)";
            }
            break;

         case ST_PALETTE_INHERIT:
            GRPalette basePalette <= findPalette(cTok);
            if(null != basePalette)
            {
               cur_palette.inheritFrom(basePalette);
               state = ST_PALETTE_BODY;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_PALETTE_INHERIT: undeclared palette '"+cTok+"'";
            break;

         case ST_PALETTE_COLOR_ASSIGN:
            if("=" == cTok)
            {
               state = ST_PALETTE_COLOR_VALUE;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_PALETTE_COLOR_ASSIGN: expected '='";
            break;

         case ST_PALETTE_COLOR_VALUE:
            cur_palette.addColor(prev_attrib_name, cTok);
            prev_attrib_name <= null;
            state = ST_PALETTE_BODY;
            return;

         case ST_GRAPH_BODY_PALETTE_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRAPH_BODY_PALETTE_ID;
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_PALETTE_ASSIGN: expected '=' (got '"+cTok+"' instead)";

         case ST_GRAPH_BODY_PALETTE_ID:
            if(IsIdentifier(cTok))
            {
               cur_palette <= findPalette(cTok);
               if(null == cur_palette && "default" == cTok)
                  cur_palette <= palettes.first;
               if(null != cur_palette)
               {
                  state = ST_GRAPH_BODY;
                  return;
               }
               throw ParseError getSrcLoc()+": ST_GRAPH_BODY_PALETTE_ID: undeclared palette \""+cTok+"\"";
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_PALETTE_ID: expected identifier (got '"+cTok+"' instead)";

         case ST_GRAPH_BODY_XFM_CLASS:
            if(IsIdentifier(cTok))
            {
               if(null != prev_node)
               {
                  prev_node.xfm_class_name <= Object(cTok);

                  xfmStyle <= findStyleClass(prev_node.xfm_class_name);
                  if(null != xfmStyle)
                     prev_node.copyXFMStyleClassAttribs(xfmStyle);

                  state = ST_GRAPH_BODY_XFM;
                  return;
               }
               else
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_XFM_CLASS: prev_node is NULL";
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_XFM_CLASS: expected widget class name (got '"+cTok+"' instead)";

         case ST_GRAPH_BODY_XFM:
            switch(pTok)
            {
               default:
                  prev_attrib_name <= Object(cTok);
                  state = ST_GRAPH_BODY_XFM_ATTRIB_ASSIGN;
                  return;

               case ")":
                  // end of XFM attribs
                  ui::Layer xfmLayer <= UI.NewObjectByFQName(prev_node.xfm_class_name);
                  if(xfmLayer instanceof ui::Layer)
                  {
                     prev_node.xfm_layer <= deref xfmLayer;
                     state = ST_GRAPH_BODY;
                     return;
                     // // if(xfmLayer.beginXFMTag(null/*form*/, prev_node.xfm_attribs))
                     // // {
                     // //    xfmLayer.endXFMTag(null/*form*/, prev_node.xfm_attribs);
                     // //    prev_node.xfm_layer <= deref xfmLayer;
                     // //    state = ST_GRAPH_BODY;
                     // //    return;
                     // // }
                     // // else
                     // //    throw ParseError getSrcLoc()+": ST_GRAPH_BODY_XFM: xfmLayer.beginXFMTag() failed (xfm_class_name=\""+prev_node.xfm_class_name+"\")";
                  }
                  else
                     throw ParseError getSrcLoc()+": ST_GRAPH_BODY_XFM: failed to instantiate widget class \""+prev_node.xfm_class_name+"\"";
            }
            break;

         case ST_GRAPH_BODY_XFM_ATTRIB_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRAPH_BODY_XFM_ATTRIB_VALUE;
               next_attrib_value.empty();
               return;
            }
            throw ParseError getSrcLoc()+": ST_GRAPH_BODY_XFM_ATTRIB_ASSIGN: expected '=' (got '"+cTok+"' instead)";

         case ST_GRAPH_BODY_XFM_ATTRIB_VALUE:
            if("-" == cTok)
            {
               next_attrib_value = "-";
               return;
            }
            else if("." == cTok)
            {
               // consume "." in >>dark.blue
               return;
            }
            if("." == nTok)
            {
               // consume first id in >>dark.blue<<
               if(!next_attrib_value.isBlank())
                  throw ParseError getSrcLoc()+": ST_GRAPH_BODY_XFM_ATTRIB_VALUE: unexpected '.' after '-'";
               next_attrib_value = cTok;
               return;
            }
            else if(!next_attrib_value.isBlank() && "-" != next_attrib_value)
            {
               pal <= findPalette(next_attrib_value);
               if(null != pal)
               {
                  if(pal.hasColor(cTok))
                     next_attrib_value = pal.getColorAsString(cTok);
                  else
                     throw ParseError getSrcLoc()+": palette \""+next_attrib_value+"\" has no color named \""+cTok+"\"";
               }
               else if( (((next_attrib_value+"."+cTok).checkConversions()) <= YAC_TYPE_FLOAT) )
               {
                  // "3"."14" => 3.14
                  next_attrib_value.append("."+cTok);
               }
               else
                  throw ParseError getSrcLoc()+": undeclared palette \""+next_attrib_value+"\" (can't resolve color \""+cTok+"\")";
            }
            else
               next_attrib_value.append(cTok);

            tryReplaceColorAttribValue(prev_attrib_name, next_attrib_value);
            prev_node.addXFMAttrib(prev_attrib_name, next_attrib_value.replace(",",";"));
            if("class" == prev_attrib_name)
            {
               xfmStyle <= findStyleClass(next_attrib_value);
               if(null != xfmStyle)
               {
                  prev_node.copyXFMStyleClassAttribs(xfmStyle);

                  if(null != prev_node.parent_subgraph)
                  {
                     // is IO node for subgraph, replicate attribs to subgraph
                     prevSubgraph <= prev_node.parent_subgraph;
                     prevSubgraph.copyXFMAttribsIfNotExists(prev_node.xfm_attribs);
                  }
               }
               else
               {
                  trace "[~~~] "+getSrcLoc()+": ST_GRAPH_BODY_XFM_ATTRIB_VALUE: undeclared XFM style class \""+next_attrib_value+"\", skipping..";
               }
            }
            prev_attrib_name <= null;
            state = ST_GRAPH_BODY_XFM;
            return;

         case ST_GRADIENT_ID:
            if(IsIdentifier(cTok))
            {
               beginGradient(cTok);
               state = ST_GRADIENT_BEGIN;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_GRADIENT_ID: expected gradient id (got '"+cTok+"' instead)";
            break;

         case ST_GRADIENT_BEGIN:
            if("{" == cTok)
            {
               next_attrib_value.empty();
               state = ST_GRADIENT_BODY;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_GRADIENT_ID: expected '{' in declaration of gradient '"+cur_gradient.id+"'";
            break;

         case ST_GRADIENT_BODY:
            switch(cTok)
            {
               case ";":
                  next_attrib_value.empty();
                  return;

               case "}":
                  cur_gradient.finish();
                  // // cur_gradient.getOrCreateTexture();
                  cur_gradient <= null;
                  if(null != graph)
                     state = ST_GRAPH_BODY;
                  else
                     state = ST_GLOBAL;
                  return;

               case ".":
                  // e.g. >>0.5<<
                  if!(next_attrib_value & ".")
                     next_attrib_value.append(".");
                  else
                     throw ParseError getSrcLoc()+": ST_GRADIENT_BODY: unexpected token '.'";
                  return;

               default:
                  if(IsIdentifier(cTok))
                  {
                     if("=" == nTok)
                     {
                        // e.g. >>0.25 = #ff00ff00<<
                        next_attrib_value.append(cTok);  // color start (float)
                        state = ST_GRADIENT_COLOR_ASSIGN;
                     }
                     else if(next_attrib_value.isBlank() && "." != nTok)
                     {
                        // e.g. >>#ff00ff00<<
                        next_attrib_value = "0";  // implicit color start pos = 0 (will be fixed in GRGradient::finish())
                        state = ST_GRADIENT_COLOR_VALUE;
                        rewindToken();
                     }
                     else
                     {
                        next_attrib_value.append(cTok);
                     }
                     return;
                  }
                  else
                     throw ParseError getSrcLoc()+": ST_GRADIENT_BODY: expected gradient color start or value (got '"+cTok+"' instead)";
            }
            break;

         case ST_GRADIENT_COLOR_ASSIGN:
            if("=" == cTok)
            {
               state = ST_GRADIENT_COLOR_VALUE;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_GRADIENT_COLOR_ASSIGN: expected '='";
            break;

         case ST_GRADIENT_COLOR_VALUE:
            cur_gradient.addColor(mathClampf(next_attrib_value/*start*/, 0.0f, 1.0f), cTok);
            next_attrib_value.empty();
            state = ST_GRADIENT_BODY;
            return;

         case ST_NODE_PORTS_BEGIN:
            if("{" == cTok)
            {
               state = ST_PORTS;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_NODE_PORTS_BEGIN: expected '{'";
            break;

         case ST_GRAPH_PORTS_BEGIN:
            // trace "xxx ST_GRAPH_PORTS_BEGIN cTok="+cTok;
            // trace "xxx   graph.id="+graph.id+" graph.io_node="+#(graph.getIONode());
            if("{" == cTok)
            {
               state = ST_PORTS;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_GRAPH_PORTS_BEGIN: expected '{'";
            break;

         case ST_PORTS:
            // trace "xxx ST_PORTS: prev_node="+#(prev_node);
            switch(cTok)
            {
               case ";":
                  return;

               case "}":
                  if(null != prev_node)
                  {
                     prev_node.autoAssignPortPositions(Layout.TOP);
                     prev_node.autoAssignPortPositions(Layout.LEFT);
                     prev_node.autoAssignPortPositions(Layout.BOTTOM);
                     prev_node.autoAssignPortPositions(Layout.RIGHT);
                     prev_node.applyPortMargins();
                  }
                  else
                  {
                     Node nIO <= graph.getIONode();
                     nIO.autoAssignPortPositions(Layout.TOP);
                     nIO.autoAssignPortPositions(Layout.LEFT);
                     nIO.autoAssignPortPositions(Layout.BOTTOM);
                     nIO.autoAssignPortPositions(Layout.RIGHT);
                     nIO.applyPortMargins();
                  }
                  cur_port <= null;
                  state = ST_GRAPH_BODY;
                  return;

               default:
                  if("=" == nTok)
                  {
                     // >>margin = 20%<<
                     prev_attrib_name <= Object(cTok);
                     state = ST_PORTS_ATTRIB_ASSIGN;
                     return;
                  }

                  // Port id
                  if(IsIdentifier(cTok))
                  {
                     if(null != prev_node)
                     {
                        cur_port <= prev_node.addPort();
                        // trace "xxx begin node.id="+prev_node.id+" port.id='"+cTok+"'";
                        // // trace "xxx    n="+prev_node.getString()+" n.gr_attribs="+#(prev_node.gr_attribs);
                     }
                     else
                     {
                        cur_port <= graph.getIONode().addPort();
                        // trace "xxx begin graph.id="+graph.id+" port.id='"+cTok+"'";
                     }
                     cur_port.id = cTok;
                     state = ST_PORT_DIR_COL;
                     return;
                  }
                  break;
            }
            throw ParseError getSrcLoc()+": ST_PORTS: unexpected token '"+cTok+"'";

         case ST_PORTS_ATTRIB_ASSIGN:
            // consume '='
            next_attrib_value.empty();
            state = ST_PORTS_ATTRIB_VALUE;
            return;

         case ST_PORTS_ATTRIB_VALUE:
            next_attrib_value.append(cTok);
            switch(cTok)
            {
               case ".":
                  return;

               default:
                  if("." == nTok)
                  {
                     if(next_attrib_value.indexOfChar('.',0) < 0)
                        return;
                     else
                        throw ParseError getSrcLoc()+": ST_PORTS_ATTRIB_VALUE: unexpected token '.' in attrib \""+prev_attrib_name+"\" value assignment";
                  }

                  // trace "xxx ST_PORTS_ATTRIB_VALUE: attrib=\"ports_"+prev_attrib_name+"\" val=\""+next_attrib_value+"\"";
                  next_attrib_value.replace(",",";");
                  ReplaceLiteral(next_attrib_value);
                  if(null != prev_node)
                  {
                     prev_node.addNodeAttrib("ports_"+prev_attrib_name, next_attrib_value);
                  }
                  else
                  {
                     // // addGraphAttrib("ports_"+prev_attrib_name, next_attrib_value);
                     graph.getIONode().addNodeAttrib("ports_"+prev_attrib_name, next_attrib_value);
                  }
                  prev_attrib_name <= null;
                  state = ST_PORTS;
                  return;
            }
            break;

         case ST_PORT_DIR_COL:
            if(":" == cTok)
            {
               state = ST_PORT_DIR;
               return;
            }
            else
               throw ParseError getSrcLoc()+": ST_PORT_DIR_COL: expected ':' (got '"+cTok+"' instead)";
            break;

         case ST_PORT_DIR:
            next_attrib_value.empty();
            switch(cTok)
            {
               default:
                  throw ParseError getSrcLoc()+": ST_PORT_DIR: invalid direction '"+cTok+"' (expected n|w|s|e)";

               case "n":
               case "t":
               case "north":
               case "top":
                  cur_port.dir = Layout.TOP;
                  break;

               case "w":
               case "l":
               case "west":
               case "left":
                  cur_port.dir = Layout.LEFT;
                  break;

               case "s":
               case "b":
               case "south":
               case "bottom":
                  cur_port.dir = Layout.BOTTOM;
                  break;

               case "e":
               case "r":
               case "east":
               case "right":
                  cur_port.dir = Layout.RIGHT;
                  break;
            }
            state = ST_PORT_POS;
            // // trace "xxx ST_PORT_DIR: nTok='"+nTok+"' nnTok='"+nnTok+"'";
            if("}" == nTok)
            {
               // no relpos, end of ports decl follows
            }
            else if(/*IsIdentifier(nTok) && */":" == nnTok)
            {
               // no relpos, next port decl follows
               state = ST_PORTS;
            }
            else if( (token_idx+1) == tokens.numElements )
            {
               // no relpos (last token in current line)
               state = ST_PORTS;
            }
            return;

         case ST_PORT_POS:
            switch(cTok)
            {
               case "}":
               case ":":
                  throw ParseError getSrcLoc()+": ST_PORT_POS: expected port position (got '"+cTok+"' instead)";

               default:
                  // trace "xxx ST_PORT_POS: cTok='"+cTok+"'";
                  next_attrib_value.append(cTok);
                  if("." == cTok)
                     return;
                  if("." == nTok)
                  {
                     if(next_attrib_value.indexOfChar('.',0) < 0)
                        return;
                     else
                        throw ParseError getSrcLoc()+": ST_PORT_POS: unexpected token '.'";
                  }
                  if(next_attrib_value & "%")
                     cur_port.relpos = mathClampf(next_attrib_value.replace("%",""), 0.0f, 100.0f) / 100.0f;  // 0%..100%
                  else
                  {
                     ReplaceLiteral(next_attrib_value);
                     cur_port.relpos = mathClampf(next_attrib_value, 0.0f, 1.0f);  // 0..1
                  }
                  if(b_gr_parse_debug2) trace "[trc] ST_PORT_POS: port '"+cur_port.id+"' relpos is "+cur_port.relpos;
                  cur_port <= null;
                  state = ST_PORTS;
            }
            return;

      }
      throw ParseError getSrcLoc()+": "+getStateString()+": unexpected token \'"+cTok+"\'";
   }

   protected method parseLineTokens() {
      // // trace "xxx parseLineTokens: begin";
      if(ST_GRAPH_BODY == state)
      {
         prev_node      <= null;
         prev_edge      <= null;
         prev_tail_port <= null;
         prev_tail_dir   = 0;
      }
      while(token_idx < tokens.numElements)
      {
         // trace "xxx parseLineTokens: token["+token_idx+"]="+tokens[token_idx];
         parseNextToken();
         if(null != tokens)
            token_idx++;
         else
            break;  // after "include" and when first line of included file is a comment
      }
   }

   public static SplitPathname(String name, path, file) {
      // Split last used file name into directory/file components

      int idx = name.lastIndexOf("/");
      int idxDos = name.lastIndexOf("\\");
      if(idxDos > idx)
         idx = idxDos;

      if(-1 != idx)
      {
         name.substring(0, idx) => path;
         name.substring(idx+1, -1) => file;
      }
      else
      {
         path = null;
         file = name;
      }

      // // trace "xxx SplitPathname: name=\""+name+"\" path=\""+path+"\" file=\""+file+"\".";
   }

   public method parseGR(String _buf, String _newPathname, String _curPathname) : Graph {
      try
      {
         state                   = ST_GLOBAL;
         prev_node              <= null;
         prev_edge              <= null;
         prev_tail_port         <= null;
         prev_tail_dir           = 0;
         prev_attrib_name       <= null;
         inline_comment_nesting  = 0;
         cur_style              <= null;
         cur_node_style         <= null;
         cur_edge_style         <= null;
         cur_palette            <= null;
         cur_gradient           <= null;

         if(b_gr_parse_debug2) trace "[trc] Graph::parseGR: newPathname=\""+_newPathname+"\" curPathname=\""+_curPathname+"\"";
         local String pathName <= BuildPathname(_newPathname, _curPathname);
         if(b_gr_parse_debug2) trace "[trc] Graph::parseGR: pathName=\""+pathName+"\"";

         pushParseContext(pathName, false/*bIncLineIdx*/, _buf.splitChar('\n')/*lines*/, 0/*lineIdx*/);

         while(null != cur_parse_context)
         {
            while(!cur_parse_context.done())
            {
               if(cur_parse_context.beginLine(0/*lineOffset*/))
               {
                  tokens <= cur_parse_context.cur_words;
                  token_idx = 0;
                  if(b_gr_parse_debug3) trace "[trc] parseGR: parse line \""+cur_parse_context.cur_line+"\" tokens="+#(tokens);
                  parseLineTokens();
               }

               // Next line
               cur_parse_context.nextLine();
            }

            popParseContext();
         }

         // Succeeded
         return main_graph;
      }
      catch(ParseError e)
      {
         trace "[---] GR::parseGR: caught parser exception >>"+e.message+"<<";
      }
      catch(GraphError e)
      {
         trace "[---] GR::parseGR: caught graph exception >>"+e.message+"<<";
      }
      return null;
   }
}
