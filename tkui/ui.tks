// ----
// ---- file   : ui.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2005-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 03Apr2005
// ---- changed: 19Apr2005, 20Apr2005, 28May2005, 07Jun2005, 09Jun2005, 10Jun2005, 18Jun2005
// ----          23Jun2005, 24Jun2005, 02Jul2005, 17Jul2005, 31Jul2005, 11Aug2005, 13Aug2005
// ----          14Aug2005, 21Jun2006, 24Jun2006, 12Aug2006, 27Apr2007, 28Apr2007, 04May2007
// ----          05May2007, 18May2007, 11Nov2007, 29Aug2007, 29Jan2008, 09Apr2008, 14Apr2008
// ----          13Aug2008, 26Aug2008, 15Sep2008, 01Feb2009, 03Feb2009, 31May2009, 12Sep2009
// ----          21Sep2009, 25Sep2009, 02Jan2010, 03Jan2010, 09Jan2010, 10Jan2010, 17Jan2010
// ----          29Jan2010, 08Feb2010, 22Apr2010, 23Apr2010, 25Apr2010, 25May2010, 01Jun2010
// ----          03Jun2010, 09Jun2010, 16Jun2010, 17Jul2010, 26Sep2010, 29Sep2010, 09Oct2010
// ----          10Oct2010, 15Nov2010, 22Jan2011, 07Feb2011, 18Feb2011, 24Feb2011, 25Feb2011
// ----          13Mar2011, 19Mar2011, 20Mar2011, 27Dec2011, 04Jan2012, 09Jan2012, 23Dec2012
// ----          05Jan2013, 14May2013, 15May2013, 16May2013, 27May2013, 04Jun2013, 09Feb2014
// ----          10Feb2014, 08Mar2014, 20Apr2014, 12Aug2014, 15Aug2014, 18Aug2014, 20Aug2014
// ----          24Sep2014, 30Jan2015, 07Feb2015, 26Feb2015, 11Mar2015, 27Apr2015, 06Nov2015
// ----          13Apr2016, 19Jan2017, 30Jan2017, 09Feb2017, 24Feb2017, 11Mar2017, 24Mar2017
// ----          29Mar2017, 13Apr2017, 14Apr2017, 13May2017, 22May2017, 16Feb2018, 01Mar2018
// ----          02Mar2018, 07Mar2018, 16Mar2018, 17Mar2018, 23Mar2018, 29May2018, 25Jul2018
// ----          16Oct2018, 13Nov2018, 26Nov2018, 27Nov2018, 28Nov2018, 29Nov2018, 01Dec2018
// ----          09Dec2018, 31Dec2018, 12May2019, 14May2019, 16May2019, 25May2019, 14Jun2019
// ----          06Jul2019, 19Jul2019, 24Jul2019, 28Jul2019, 10Sep2019, 07Oct2019, 01Nov2019
// ----          03Nov2019, 07Nov2019, 23Nov2019, 08May2020, 09May2020, 15Jun2020, 20Jun2020
// ----          21Jun2020, 28Jun2020, 10Aug2020, 14Aug2020, 06Nov2020, 15Nov2020, 10Feb2021
// ----          19Feb2021, 30Mar2021, 02Apr2021, 04May2021, 26Sep2021, 11Oct2021, 28Dec2021
// ----          21Feb2022, 22Feb2022, 22Oct2022, 01Dec2022, 04Feb2023, 10Feb2023, 11Feb2023
// ----          12Feb2023, 18Feb2023, 19Feb2023, 21Feb2023, 25Feb2023, 27Feb2023, 04Mar2023
// ----          14Mar2023, 20Apr2023, 16Jul2023, 25Sep2023, 26Sep2023, 03Oct2023, 04Oct2023
// ----          05Oct2023, 19Oct2023, 20Oct2023, 21Oct2023, 27Oct2023, 01Nov2023, 03Nov2023
// ----          05Nov2023, 09Nov2023, 16Nov2023, 18Nov2023, 02Mar2024, 14Mar2024, 18Mar2024
// ----          19Mar2024, 22Mar2024, 23Mar2024, 28Mar2024, 05Apr2024, 10Apr2024, 23Jul2024
// ----          23Jul2024, 16Aug2024, 13Sep2024, 24Sep2024, 05Oct2024, 09Oct2024, 15Dec2024
// ----          26Dec2024, 08Jan2025, 08Feb2025, 18Feb2025, 22Feb2025, 15Mar2025, 27Mar2025
// ----          09Sep2025, 10Sep2025, 11Sep2025, 14Sep2025, 16Sep2025, 17Sep2025, 20Sep2025
// ----
// ----
// ----

module MUI;

use tkopengl;    // used for accelerated graphics rendering
use tksdl;       // the hardware abstraction layer toolkit
use tkminnie;    // GL abstraction layer + VG
use tkfreetype2; // true type font loader/renderer
use tkui;        // required for UI.OpenFileDialog(), UI.SaveFileDialog()

namespace ui;

=uitimer=  // synchronizes timer scheduling/cancelation/onidle-processing

boolean b_benchmark = false;

// true while a Window tries to determine its minimum size.
//  If the flag is set, a SplitPanes omits split_position clipping, for example.
boolean b_layout_minsweep;

boolean b_ui_debug = false;

boolean b_redraw = true;

KeyboardMonitor keyboard_monitor;

int b_benchmark_done = 0;


class TriadKeyConsumer extends ActionConsumer {
   public virtual consumeAction(Action _ac) {
      if(_ac instanceof TimerAction)
      {
         UI.HandleTriadKeyTimeout();
      }
   }
}
TriadKeyConsumer triadkeyConsumer;


class KeyRepeatAction extends TimerAction {
}

class KeyRepeatConsumer extends ActionConsumer {
   public virtual consumeAction(Action _ac) {
      if(_ac instanceof TimerAction)
      {
         UI.HandleKeyRepeat();
      }
   }
}
KeyRepeatConsumer keyRepeatConsumer;



class MouseHoldAction extends TimerAction {
}

class MouseHoldConsumer extends ActionConsumer {
   public virtual consumeAction(Action _ac) {
      if(_ac instanceof TimerAction)
      {
         UI.HandleMouseHold();
      }
   }
}

MouseHoldConsumer mouseHoldConsumer;

MouseEvent mouse_event;


// see HandleKeyboardFocusChanged()
class KeyboardFocusListener {
   public method handleKeyboardFocusChanged(Layer _newKeyboardLayer) {
   }
}


// ---- Callback for the SDL.onClose API signal
function Screen_onClose() {

   try
   {
      UI.OnClose();
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onClose: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onOpen API signal
function Screen_onOpen() {
   if(b_ui_debug)
      trace "\n\n\n[dbg] ui::Screen_onOpen\n\n\n";

   try
   {
      FPS.reset();

      // workaround for keyrepeat on Linux:
      SDL.enableUNICODE(true);
      SDL.enableKeyRepeat(0, 0); // disable keyrepeat

      UI.OnOpen();
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onOpen: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onResize API signal
function Screen_onResize() {
   // (note) HAL calls onOpen() immediately after onResize()
}

// ---- Callback for the SDL.onKeyboard API signal
function Screen_onKeyboard(Key _k) {
   try
   {
      // trace "xxx UI k.pressed="+_k.pressed;

      UI.OnKeyboard(_k);
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onKeyboard: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onMouse API signal
function Screen_onMouse(int _x, int _y, int _cbs, int _nbs) {

   try
   {
      // trace "xxx x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
      // trace "xxx Screen_onMouse: Mouse pos=("+Mouse.x+"; "+Mouse.y+") d=("+Mouse.dx+"; "+Mouse.dy+") cbs="+_cbs+" nbs="+_nbs;
      mouse_event.init(_x / UI.zoom_x,
                       _y / UI.zoom_y,
                       _cbs,
                       _nbs
                       );
      UI.OnMouse(mouse_event);
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onMouse: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onDraw API signal
function Screen_onDraw() {
   // trace "xxx Screen_onDraw: b_redraw="+b_redraw;

   if(b_redraw)
   {
      try
      {
         UI.OnDraw();

         if(b_benchmark)
         {
            UI.RedrawAll();// xxx debug/benchmark
            if( (UI.frame_counter & 63) == 0)
            {
               UI.Debug("UI::Screen_onDraw: FPS="+FPS.real);
            }
         }
      }
      catch(Error e)
      {
         trace "[---] UI::Screen_onDraw: caught exception name="+e.name+", message=\""+e.message+"\"";
         trace e.stackTrace;
      }
   }
}

// ---- Callback for the SDL.onExpose API signal
function Screen_onExpose() {

   try
   {
      // Note: only called after window has been opened
      ////trace "[dbg] UI::Screen_onExpose";
      UI.CompositeAll();
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onExpose: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onApplicationActive API signal
function Screen_onApplicationActive(int _b) {
   try
   {
      ////trace "xxx UI: Screen_onApplicationActive="+_b;
      b_redraw = true;
      UI.OnApplicationActive(_b);
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onApplicationActive: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onMouseFocusActive API signal
function Screen_onMouseFocusActive(int _b) {
   try
   {
      ////trace "xxx UI: Screen_onMouseFocusActive="+_b;
      UI.OnMouseFocusActive(_b);
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onMouseFocusActive: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onTimer API signal
function Screen_onTimer() {
   try
   {
      UI.OnTimer();
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onTimer: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onInputFocusActive API signal
function Screen_onInputFocusActive(int _b) {
   try
   {
      ////trace "xxx UI: Screen_onInputFocusActive="+_b;
      UI.OnInputFocusActive(_b);
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onInputFocusActive: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onDropFiles API signal
function Screen_onDropFiles(int x, int y, StringArray fileNames) {
   try
   {
      ////trace "xxx UI: Screen_onDropFiles;
      UI.OnDropFiles(x, y, deref fileNames);
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onDropFiles: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onMoveWindow API signal
function Screen_onMoveWindow(int x, int y) {
   try
   {
      // trace "xxx UI: Screen_onMoveWindow(x="+x+" y="+y+")
      UI.OnMoveWindow(x, y);
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onMoveWindow: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}

// ---- Callback for the SDL.onDrainEventQueue API signal
function Screen_onDrainEventQueue() {
   try
   {
      // trace "xxx UI: Screen_onDrainEventQueue;
      UI.OnDrainEventQueue();
   }
   catch(Error e)
   {
      trace "[---] UI::Screen_onDrainEventQueue: caught exception name="+e.name+", message=\""+e.message+"\"";
      trace e.stackTrace;
   }
}


// ====
// ==== The static UI class is used to handle hardware-layer abstraction (i.e. interface to SDL).
// ==== The UI object is associated with exactly one top-level desktop or fullscreen OS window.
// ====
class UI : ActionProvider, UIConstants {

   static Logger *logger;

   static boolean b_headless;  // true=don't open window/screen (and don't create GL context)


   // ----
   // ----
   // ---- Look and feel
   // ----
   // ----
   public static LookAndFeel *lnf; // (default) LookAndFeel instance (used to query colors, timeouts, bordersizes etc)
   public static IntArray    *lnf_colors; // ref to lnf.colors

   namespace static LookAndFeel_Light lnf_preset_light;
   namespace static LookAndFeel_Dark  lnf_preset_dark;
   namespace static LookAndFeel_Mono  lnf_preset_mono;

   public static boolean b_debug_lnf_changed_reset_custom_color_flags;  // true=make labels/button reset their custom colors when lnf is changed

   public static boolean b_force_mono_icons;

   static boolean b_keyboard_monitor;

   static boolean b_noframe;
   static boolean b_noresize;

   // false:
   //   - use '<' (VKEY_LESS(60)) (next to lshift) to e.g. clear events in Synergy tracker editor
   //      (note) real US keyboards do not have a key between lshift and z.
   //              on german keyboards the (SDL) raw keycode for this key is VKEY_LESS(60) (=='<>|')
   //              on macOS, the key is reported as VKEY_LESS(60) when a german PC (USB) kbd input source is active
   //               and as VKEY_WORLD7(167) with a US input source (quietly converted to VKEY_LESS)
   // true:
   //   - convert VKEY_SLASH(47) (next to rshift) to VKEY_LESS(60)
   //      (note) US input source on macOS, all keyboard types on Windows (SDL)
   //      (note) overrides Synergy keyjazz key 'E-*'
   static boolean b_key_map_slash_to_less = true;

   // macOS: swap "command" and "option" modifier keys
   //   (=> report PC USB kbd ALT key as VKEY_LALT instead of VKEY_LMETA)
   static boolean b_key_swap_lalt_lmeta_key = IsMacOS();
   static boolean b_key_swap_lalt_lmeta_mod = IsMacOS();

   // macOS: swap ralt (option) / rsuper (command) key codes
   //  (note) when using Macbook instead of PC USB keyboard
   static boolean b_key_swap_ralt_rsuper_key = false && IsMacOS();

   // macOS: report RMETA (MENU key on PC keyboards) as MENU
   static boolean b_key_map_rmeta_to_menu = IsMacOS();

   // macOS: report RMETA (right Windows key on PC keyboards, ) as RSUPER
   // (todo) REMOVE ?
   static boolean b_key_map_rmeta_to_rsuper = false && IsMacOS();

   // macOS: report RSUPER (right Windows key on PC keyboards, ) as RCTRL
   //  (note) for Macbook keyboards that have no RCTRL key
   static boolean b_key_map_rsuper_to_rctrl = IsMacOS();

   // macOS: don't report numpad keys as unicode (like on Windows)
   //         (note) e.g. fixes lctrl-x NUM 0..9 shortcuts by distinguishing between e.g. lctrl-x 1 and lctrl-x NUM 1
   static boolean b_key_no_numpad_unicode = true;

   // macOS: don't report "lalt" key as "lalt-lalt" (or lalt-lmeta) but simply as "lalt" (like on Windows), i.e. clear the modifier flag.
   static boolean b_key_modifier_key_clear_modifier = IsMacOS();

   // macOS: copy/paste with command-c/v (lalt-c/v with PC keyboard) (in addition to ctrl-c/v)
   //  (note) may clash with menu accelerators (PopupMenuBar)
   static boolean b_key_cmd_copy_paste = false;////IsMacOS();

   // ignore unicode and replace by Key.pressed (US raw scan code)
   static boolean b_key_force_us_unicode;

   static boolean b_clear_bg = true;
   static boolean b_draw_root_fbo = true;
   static boolean b_draw_post_fbo = false;

   static boolean b_running;

   static boolean b_space_bar_clicks = true;


   static Debug(String msg) {
      if(Configuration.debugLevel)
         trace "[dbg] "+msg;
   }

   static Debug2(String msg) {
      if(Configuration.debugLevel)
         trace "[trc] "+msg;
   }

   static Backtrace() {
      try { throw UncriticalError("debug/backtrace"); } catch(UncriticalError e) { trace e.stackTrace; }
   }

   static SetLogger(Logger _logger) {
      if(_logger instanceof Logger)
         logger <= deref _logger;
   }

   static LogInfo(String _msg) {
      logger.logInfo(_msg);
   }

   static LogInfoFast(String _msg) {
      logger.logInfoFast(_msg);
   }

   static LogSuccess(String _msg) {
      logger.logSuccess(_msg);
   }

   static LogDebug(String _msg) {
      logger.logDebug(_msg);
   }

   static LogTrace(String _msg) {
      logger.logTrace(_msg);
   }

   static LogVerbose(String _msg) {
      logger.logVerbose(_msg);
   }

   static LogWarning(String _msg) {
      logger.logWarning(_msg);
   }

   static LogError(String _msg) {
      logger.logError(_msg);
   }

   static LogFatal(String _msg) {
      logger.logFatal(_msg);
   }

   public static IsWindows() : boolean {
      return (".dll" == TKS.dllSuffix);
   }

   public static IsMacOS() : boolean {
      return (".dylib" == TKS.dllSuffix);
   }

   public static IsLinux() : boolean {
      return (".so" == TKS.dllSuffix);
   }

   public static SetLookAndFeel(String _name) {
      explain "Set default look and feel (colors, fonts, timeouts, insets etc..)";
      // (note) SetLookAndFeel(LookAndFeel.LIGHT) is called by UI.Initialize()

      Debug("UI::SetLookAndFeel("+_name+")");

      switch(_name)
      {
         default:
         case LookAndFeel.LIGHT:
            lnf <= lnf_preset_light;
            break;

         case LookAndFeel.DARK:
            lnf <= lnf_preset_dark;
            break;

         case LookAndFeel.MONO:
            lnf <= lnf_preset_mono;
            break;
      }

      lnf_colors            <= lnf.colors;
      UIRenderer.lnf_colors <= lnf_colors; // Speed optimization (overwritten during Layer onDraw*())

      HandleLookAndFeelChanged();

      UI.RedrawAll();
   }

   public static SetLookAndFeelResetCustomColors(String _name) {
      b_debug_lnf_changed_reset_custom_color_flags = true;
      SetLookAndFeel(_name);
      b_debug_lnf_changed_reset_custom_color_flags = false;
   }

   public static SetLookAndFeelByIdx(int _lnfIdx) {
      switch(_lnfIdx)
      {
         default:
         case LookAndFeel.IDX_LIGHT:
            SetLookAndFeel(LookAndFeel.LIGHT);
            break;

         case LookAndFeel.IDX_DARK:
            SetLookAndFeel(LookAndFeel.DARK);
            break;

         case LookAndFeel.IDX_MONO:
            SetLookAndFeel(LookAndFeel.MONO);
            break;
      }
   }

   public static PreferMonoIcons() : boolean {
      return
         b_force_mono_icons             ||
         (@(lnf_preset_dark) == @(lnf)) ||
         (@(lnf_preset_mono) == @(lnf)) ;
   }

   public static SetEnableForceMonoIcons(boolean _bEnable, boolean _bInvert) {
      b_force_mono_icons = _bEnable;
      lnf.b_icon_invert_mono = _bInvert;
   }

   public static LookAndFeelForceFlat() {
      lnf_preset_light.forceFlat();
   }

   public static IsLight() : boolean {
      return @(lnf_preset_light) == @(lnf);
   }

   public static IsDarkOrMono() : boolean {
      return
         (@(lnf_preset_dark) == @(lnf)) ||
         (@(lnf_preset_mono) == @(lnf)) ;
   }

   public static IsDark() : boolean {
      return
         (@(lnf_preset_dark) == @(lnf)) ;
   }

   public static IsMono() : boolean {
      return
         (@(lnf_preset_mono) == @(lnf)) ;
   }

   public static CycleLookAndFeel() {
      // Cycle LNF (just for debugging, this won't reach all Layers at once)
      b_debug_lnf_changed_reset_custom_color_flags = true;
      if(@(lnf) == @(lnf_preset_light))
      {
         SetLookAndFeel(LookAndFeel.DARK);
      }
      else if(@(lnf) == @(lnf_preset_dark))
      {
         SetLookAndFeel(LookAndFeel.MONO);
      }
      else if(@(lnf) == @(lnf_preset_mono))
      {
         SetLookAndFeel(LookAndFeel.LIGHT);
      }
      b_debug_lnf_changed_reset_custom_color_flags = false;
   }

   public static GetLookAndFeel(String _name) : LookAndFeel {
      switch(_name)
      {
         default:
         case LookAndFeel.LIGHT:
            return lnf_preset_light;

         case LookAndFeel.DARK:
            return lnf_preset_dark;

         case LookAndFeel.MONO:
            return lnf_preset_mono;
      }
   }

   public static GetLookAndFeelIdx() : int {
      if(@(lnf) == @(lnf_preset_dark))
         return 1;
      if(@(lnf) == @(lnf_preset_mono))
         return 2;
      return 0;
   }

   public static HandleLookAndFeelChanged() {
      // Send event to root layer (+children)
      if(null != root_layer)
         root_layer.recursiveOnLookAndFeelChanged();

      // Send event to floating layers (+children)
      FloatingLayer *fl;
      foreach fl in floating_layers
         fl.recursiveOnLookAndFeelChanged();

      if(b_keyboard_monitor)
         keyboard_monitor.recursiveOnLookAndFeelChanged();
   }

   private static Layer *root_layer;
   private static FBO *root_fbo;
   private static FBO *post_fbo;  // if b_draw_post_fbo==true
   namespace static FBO *current_fbo;  // valid during onDraw()  (last beginPaint() FBO)

   // Dialogs, tooltips, toolbars...
	public static FloatingLayer *[] floating_layers;
   protected static boolean b_remove_floating_layer_nested;  // see RemoveFloatingLayer() (cornercase recursion issue workaround)

   // If true, shade screen before drawing next floating layer
   public static boolean b_shade_modal = true;

   // True=sweep layers and determine dirty regions before actually drawing something
   public static boolean b_transparent_layers = false;

   // True==redraw windows while moving/resizing, False=draw XOR window outline
   private static boolean b_redraw_windowmoveresize = false;

   // True==always show tooltips near window corner
   public static boolean b_force_window_corner_tooltips = false;

   public static int tooltip_show_delay        = UIConstants.TOOLTIP_SHOW_DELAY;
   public static int tooltip_stage2_delay      = UIConstants.TOOLTIP_STAGE2_DELAY;
   public static int tooltip_fast_open_timeout = UIConstants.TOOLTIP_FAST_OPEN_TIMEOUT;
   public static int tooltip_fast_open_delay   = UIConstants.TOOLTIP_FAST_OPEN_DELAY;

   public static SetToolTipShowDelay(int _ms) {
      tooltip_show_delay = mathMaxi(50, _ms);
   }

   public static SetToolTipStage2Delay(int _ms) {
      tooltip_stage2_delay = mathMaxi(50, _ms);
   }

   public static SetToolTipFastOpenTimeout(int _ms) {
      tooltip_fast_open_timeout = mathMaxi(50, _ms);
   }

   public static SetToolTipFastOpenDelay(int _ms) {
      tooltip_fast_open_delay = mathMaxi(50, _ms);
   }

   public static SetEnableRedrawWindowMoveResize(boolean _b) {
      b_redraw_windowmoveresize = _b;
   }

   public static GetEnableRedrawWindowMoveResize() {
      return b_redraw_windowmoveresize;
   }


   public static boolean b_touch_mode;

   public static SetEnableTouchMode(boolean _bEnabled) {
      // - mouseless mode. mousefocus=kbdfocus
      // - also affects tooltip position (false=near mouse, true=always near layer)
      // - textfield renders cursor via xor when false (hack)
      b_touch_mode = _bEnabled;
   }

   public static SetEnableWindowCornerToolTips(boolean _bEnable) {
      b_force_window_corner_tooltips = _bEnable;
   }

   public static SetEnableSpaceBarClicks(boolean _bEnable) {
      b_space_bar_clicks = _bEnable;
   }

   // ---- The Layer which currently has the keyboard focus
   public static Layer *keyboard_layer;
   public static Layer *previous_keyboard_layer; // xxx Should be a stack??
   module static int last_key_mod; // Used to query current key.mod state, e.g. in mouse handler
   module static boolean b_ignore_first_lalt_key = false; // hack to workaround lalt-tab issue
   module static boolean b_lock_keyboard_focus;
   module static KeyboardFocusListener *keyboard_focus_listener;

   public static boolean b_triad_key_mode = false; // lctrl-x escape sequence entered
   public static boolean b_triad_key_lctrl = false; // lctrl pressed
   public static boolean b_triad_key_waitrelease = false; // wait for triad key release before ending triad key mode
   public static boolean triad_key_pressed = 0; // last triad key press
   public static boolean b_triad_key_try_repeat = false; // e.g. lctrl-x c c
   module static boolean b_triad_key_repeating = false; // also see Layer::wantTriadKeyRepeat()
   module static boolean b_triad_key_delayed_end = false; // true when key repeat is requested and mode ends not until lctrl is released
   module static Key triad_key_delayed_end_key;
   module static TimerAction triadkey_timerAction;

   module static boolean b_allow_keyrepeat;
   module static Key repeat_key;
   module static KeyRepeatAction ta_keyrepeat;
   static int key_repeat_rate_frames;
   static int key_repeat_rate;
   static int key_repeat_delay_frames;
   static int key_repeat_delay;
   static boolean b_vsync_keyrepeat;
   static int event_handle_starttime;  // to estimate #frames passed in vsync keyrepeat mode. Also see TimerAction.setTicks

   // --- kb focus selection mode
   private static boolean    b_kbdfocus_selection_mode;
   private static Layer *[]  kbdfocus_candidates;
   private static Layer     *kbdfocus_selection_layer;
   private static boolean    b_kbdfocus_selection_mode_behaviour_hold; // true=must hold down focuskey, false=key toggles

   // ---- The Layer which currently is underneath the mouse pointer (enter/leave)
   public static Layer *mouse_layer;
   public static Layer *preferred_mouse_layer;  // used by Window resize
   protected static boolean b_lock_mouse_focus;
   protected static int mouse_layer_lock_timeout_end_ticks;   // after ScrollPane mousewheel scroll. -1=no lock
   define int MOUSE_LAYER_LOCK_TIMEOUT_TICKS = 650;

   // ---- The Layer which currently has the mouse focus (focus/unfocus)
   public static Layer *mousefocus_layer;

   // ---- Frontmost and active floating layer
   public static FloatingLayer *active_floatinglayer;

   // ---- Freetype font cache
   private static FontCache font_cache;

   private static IconCache icon_cache;

   private static HashTable cursor_cache;
   public static boolean b_skip_cursor;  // (hack) workaround for disappearing cursor in fullscreen mode (and potential crash)

   namespace static boolean b_floatparam_mouse_grab = true;
   namespace static boolean b_slider_mouse_grab = true;

   namespace static boolean b_ignore_next_mouse_release;  // after drag-cancel


   // // define int SCISSORS_STACK_SIZE = 32;
   // // private static IntArray scissors_stack;
   // // private static int scissors_x, scissors_y, scissors_w, scissors_h;
   // // private static int scissors_stacki;

   define int QUEUE_MODE_NONE              = 0;
   define int QUEUE_MODE_FULLSCREEN_TOGGLE = 1;
   define int QUEUE_MODE_REOPEN            = 2;
   private static int queued_screenmodechange;
   private static float queue_orig_px = -1;
   private static float queue_orig_py;
   private static float queue_orig_sx;
   private static float queue_orig_sy;

   // --- Mouse grab
   public static boolean b_mouse_grab; // true=mouse is grabbed
   public static int mouse_grab_x;     // grab start
   public static int mouse_grab_y;     //
   public static int mouse_grab_relx;  // accumulated delta movement
   public static int mouse_grab_rely;  //

   // --- Global/common char filters
   public static CharFilterFloat         char_filter_float;
   public static CharFilterFloatExpr     char_filter_float_expr;
   public static CharFilterHex           char_filter_hex;
   public static CharFilterHexShort      char_filter_hex_short;
   public static CharFilterHexExpr       char_filter_hex_expr;
   public static CharFilterHexShortExpr  char_filter_hex_short_expr;
   public static CharFilterBinary255Expr char_filter_binary255_expr;
   public static CharFilterUFix16        char_filter_ufix16;

   public static boolean b_allow_layout_cache = true;  // false=non-resizable UIs


   public static AddFloatingLayer(FloatingLayer _fl) {
      explain "Adds a new layer on top of all other layers. Please notice that the layer (+children) geometry must already be set";
      // trace "xxx UI.AddFloatingLayer: fl="+#(_fl);

      if(floating_layers.containsPointer(_fl))
      {
         trace "[!!!] UI.AddFloatingLayer: fl="+#(_fl)+" already visible !!";
         Backtrace();
         return;
      }

      floating_layers.add(#(deref _fl));
      _fl.recursiveOnLookAndFeelChanged();
      _fl.redraw();
      UI.CompositeAll();
   }

   public static RemoveFloatingLayer(local FloatingLayer _fl) {
      // (note) might be called recursively when closing the tooltip of a child layer

      local boolean bWasActive = (@(_fl)==@(active_floatinglayer));
      // trace "xxx UI.RemoveFloatingLayer: _fl="+#(_fl)+" bWasActive="+bWasActive;

      LoseKeyboardFocusIfWithin(_fl, true/*bQuiet*/);

      if(bWasActive)
         active_floatinglayer <= null;

      // already done by Window::hide()
      SetPreferredMouseLayer(null);

      // Recursively remove all timers, mouse/keyboard focus for child layers
      RecursiveRemoveLayerRefs(_fl);

      floating_layers.remove(_fl);

      if(bWasActive && !floating_layers.isEmpty())
      {
         active_floatinglayer <= floating_layers.last;

         if(!b_remove_floating_layer_nested)
         {
            b_remove_floating_layer_nested = true;
            // TODO: remember last focused layer and restore focus when layer is re-activated
            // trace "xxx active_floatinglayer="+#(active_floatinglayer);
            active_floatinglayer.focusFirstTabCycleMember();
            SetMouseFocus(active_floatinglayer);  // may call RemoveFloatingLayer() recursively
            b_remove_floating_layer_nested = false;
         }
         else
         {
            trace "[trc] UI::RemoveFloatingLayer: skip nested SetMouseFocus() call";
         }
      }

      // // trace "xxx UI::RemoveFloatingLayer: active_floatinglayer="+#(active_floatinglayer);
      UI.RedrawAll();
   }

   public static RecursiveRemoveLayerRefs(local Layer _l) {
      local Layer *c <= _l.first_child;
      // // trace "xxx RecursiveRemoveLayerRefs: l="+#(_l)+" c="+#(c);
      while(null != c)
      {
         RecursiveRemoveLayerRefs(c);
         c <= c.next;
      }
      RemoveLayer(_l);
   }

   public static RemoveLayer(local Layer _l) {
      // (todo) this should be called RemoveLayerReferences()

      _l.recursiveHideToolTips();

      LoseMouseFocusIfWithin(_l);

      if(@(_l) == @(previous_keyboard_layer))
         previous_keyboard_layer <= null;

      LoseKeyboardFocusIfWithin(_l, true/*bQuiet*/);

      if(@(_l) == @(drag_layer))
         drag_layer <= null;

      if(@(_l) == @(drag_layer_candidate))
      {
         // // trace "xxx HandleMouse: RemoveLayer, set b_try_drag=0";
         b_try_drag = false;
         drag_layer_candidate <= null;
      }

      CancelScheduleFor(_l);
   }

   private static AddKbdFocusCandidates(local Layer c) {
      local Layer *ch <= c.getLayoutFirstChild();
      while(null != ch)
      {
         if(ch instanceof ActionProvider)
         {
            Point2f dummy;
            ch.abs_position_x = Layer.ABS_INVALID; /// xxxxxxxxxxxx
            ch.abs_position_y = Layer.ABS_INVALID;
            ch.calcAbsolutePosition(dummy); // update absolute_position_x/y cache fields
            kbdfocus_candidates.add(ch);
            // // trace "xxx AddKbdFocusCandidate: ch="+ch.getDebugString()+" abs="+ch.getAbsolutePositionString();
         }
         AddKbdFocusCandidates(ch);
         ch <= ch.next;
      }
   }

   public static BeginKbdFocusSelectionMode() {
      kbdfocus_candidates.free();

      trace "[dbg] UI::BeginKbdFocusSelectionMode: keyboard_layer="+#(keyboard_layer);

      b_kbdfocus_selection_mode = true;

      boolean bModal = false;

      Layer c <= active_floatinglayer;
      while(null != c)
      {
         AddKbdFocusCandidates(c);

         if(c.isModal())
         {
            bModal = true;
            break;
         }

         c <= c.next;
      }

      if(!bModal)
         AddKbdFocusCandidates(root_layer);

      if(kbdfocus_candidates.numElements > 0)
      {
         // Set initial selection to current keyboard focus layer or first candidates
         if(null != keyboard_layer)
            kbdfocus_selection_layer <= keyboard_layer;
         else
            kbdfocus_selection_layer <= kbdfocus_candidates[0];
      }
      else
      {
         // No candidates
         b_kbdfocus_selection_mode = false;
      }

      RedrawAll();

      // // trace "xxx initial kbdfocus_selection_layer="+#(kbdfocus_selection_layer);
   }

   public static EndKbdFocusSelectionMode() {
      if(b_kbdfocus_selection_mode)
      {
         b_kbdfocus_selection_mode = false;

         if(@(kbdfocus_selection_layer) != @(keyboard_layer))
         {
            SetKeyboardFocus(kbdfocus_selection_layer);

            if(kbdfocus_selection_layer instanceof Layer)
            {
               kbdfocus_selection_layer.onTabFocus();
               Mouse.warpTo(
                  (kbdfocus_selection_layer.abs_position_x + kbdfocus_selection_layer.size_x*0.5) * zoom_x,
                  (kbdfocus_selection_layer.abs_position_y + kbdfocus_selection_layer.size_y*0.5) * zoom_y
                            );
            }
         }

         kbdfocus_selection_layer <= null;
         RedrawAll();
      }
   }

   private static CancelKbdFocusSelectionMode() {
      b_kbdfocus_selection_mode = false;
      kbdfocus_selection_layer <= null;
      RedrawAll();
   }

   private static ToggleKbdFocusSelectionMode() {
      if(b_kbdfocus_selection_mode)
         EndKbdFocusSelectionMode();
      else
         BeginKbdFocusSelectionMode();
   }

   public static SetKbdFocusSelectionModeBehaviour(boolean _bHoldKey) {
      b_kbdfocus_selection_mode_behaviour_hold = _bHoldKey;
   }

   private static SelectMinDistKbdFocus() {
      float minDist = 9999999;
      Layer minLayer <= null;
      Layer *l;
      foreach l in kbdfocus_candidates
      {
         if(l.tmp_distance >= 0.0f)// && !l.b_decorative)
         {
            if(l.tmp_distance < minDist)
            {
               minDist   = l.tmp_distance;
               minLayer <= l;
            }
         }
      }

      if(null != minLayer)
      {
         if(null != kbdfocus_selection_layer)
            kbdfocus_selection_layer.onKeyboardFocusLost(false/*bQuiet*/);

         kbdfocus_selection_layer <= minLayer;
         kbdfocus_selection_layer.onTabFocus();
         trace "[trc] UI::SelectMinDistKbdFocus: kbdfocus_selection_layer="+kbdfocus_selection_layer.getDebugString();
         RedrawAll();
      }
   }

   public static FindKbdFocusLeft() {
      if(!b_kbdfocus_selection_mode)
         return;
      float px = kbdfocus_selection_layer.abs_position_x + 4;
      float py = kbdfocus_selection_layer.abs_position_y + kbdfocus_selection_layer.size_y * 0.5;

      Layer *l;
      float lx;
      foreach l in kbdfocus_candidates
      {
         l.tmp_distance = -1;
         if(@(l) != @(kbdfocus_selection_layer))
         {
            lx = l.abs_position_x + l.size_x;
            if(lx < px)
            {
               // // float ly = mathAbsMinf(l.abs_position_y-py, l.abs_position_y+l.size_y-py);
               float ly = l.abs_position_y + l.size_y * 0.5 - py;
               float ty = l.abs_position_y - kbdfocus_selection_layer.abs_position_y;
               if(abs(ty) < abs(ly))
                  ly = ty;
               ty = l.abs_position_y + l.size_y - (kbdfocus_selection_layer.abs_position_y+kbdfocus_selection_layer.size_y);
               if(abs(ty) < abs(ly))
                  ly = ty;
               l.tmp_distance = sqrt(ly*ly + (px - lx)*(px - lx));
            }
         }
      }

      SelectMinDistKbdFocus();
   }

   public static FindKbdFocusRight() {
      if(!b_kbdfocus_selection_mode)
         return;

      float px = kbdfocus_selection_layer.abs_position_x + kbdfocus_selection_layer.size_x - 4;// * 0.5;
      float py = kbdfocus_selection_layer.abs_position_y + kbdfocus_selection_layer.size_y * 0.5;

      Layer *l;
      float lx;
      foreach l in kbdfocus_candidates
      {
         l.tmp_distance = -1;
         if(@(l) != @(kbdfocus_selection_layer))
         {
            lx = l.abs_position_x;

            if(lx > px)
            {
               float ly = l.abs_position_y + l.size_y * 0.5 - py;

               float ty = l.abs_position_y - kbdfocus_selection_layer.abs_position_y;
               if(abs(ty) < abs(ly))
                  ly = ty;
               ty = l.abs_position_y + l.size_y - (kbdfocus_selection_layer.abs_position_y+kbdfocus_selection_layer.size_y);
               if(abs(ty) < abs(ly))
                  ly = ty;

               l.tmp_distance = sqrt(ly*ly + (lx - px)*(lx - px));
               // // trace "xxx FindKbdFocusRight: l="+l.getDebugString()+" tmp_distance="+l.tmp_distance;
            }
         }
      }

      SelectMinDistKbdFocus();
   }

   public static FindKbdFocusUp() {
      if(!b_kbdfocus_selection_mode)
         return;

      float py = kbdfocus_selection_layer.abs_position_y +4;
      float px = kbdfocus_selection_layer.abs_position_x + kbdfocus_selection_layer.size_x*0.5;

      Layer *l;
      float ly;
      foreach l in kbdfocus_candidates
      {
         l.tmp_distance = -1;
         if(@(l) != @(kbdfocus_selection_layer))
         {
            ly = l.abs_position_y + l.size_y;

            if(ly < py)
            {
               float lx = l.abs_position_x + l.size_x*0.5 - px;
               float tx = l.abs_position_x - kbdfocus_selection_layer.abs_position_x;
               if(abs(tx) < abs(lx))
                  lx = tx;
               tx = l.abs_position_x + l.size_x - (kbdfocus_selection_layer.abs_position_x+kbdfocus_selection_layer.size_x);
               if(abs(tx) < abs(lx))
                  lx = tx;
               l.tmp_distance = sqrt(lx*lx + (py - ly)*(py - ly));
            }
         }
      }

      SelectMinDistKbdFocus();
   }

   public static FindKbdFocusDown() {
      if(!b_kbdfocus_selection_mode)
         return;

      float py = kbdfocus_selection_layer.abs_position_y + kbdfocus_selection_layer.size_y-4;
      float px = kbdfocus_selection_layer.abs_position_x + kbdfocus_selection_layer.size_x * 0.5;

      Layer *l;
      float ly;
      foreach l in kbdfocus_candidates
      {
         l.tmp_distance = -1;
         if(@(l) != @(kbdfocus_selection_layer))
         {
            ly = l.abs_position_y;

            // // trace "xxx FindKbdFocusDown: candidate l="+#(l)+" ly="+ly+" py="+py;

            if(ly > py)
            {
               float lx = l.abs_position_x + l.size_x*0.5 - px;
               float tx = l.abs_position_x - kbdfocus_selection_layer.abs_position_x;
               if(abs(tx) < abs(lx))
                  lx = tx;
               tx = l.abs_position_x + l.size_x - (kbdfocus_selection_layer.abs_position_x+kbdfocus_selection_layer.size_x);
               if(abs(tx) < abs(lx))
                  lx = tx;
               l.tmp_distance = sqrt(lx*lx + (ly - py)*(ly - py));

               // // trace "xxx FindKbdFocusDown: l="+#(l)+" l.tmp_distance="+l.tmp_distance;
            }
         }
      }

      SelectMinDistKbdFocus();
   }

   public static FindKbdFocusFirstTabRootMember() {
      if(!b_kbdfocus_selection_mode)
         return;

      Layer c <= kbdfocus_selection_layer;
      // // trace "xxx FindKbdFocusFirstTabRootMember c="+#(c)+" cycle_list="+#(c.tab_cycle_list);

      if(null != c.tab_cycle_list)
      {
         // Set focus to first (non-root) cyclemember
         Layer n <= c.tab_cycle_list.get(0);
         while(n.isTabCycleRoot())
         {
            n <= n.tab_cycle_list.get(0);
            if(null == n)
               break;
         }

         if(null != n && !n.b_decorative)
         {
            kbdfocus_selection_layer <= n;
            RedrawAll();
         }
      }
   }

   public static HandleKbdFocusSelectionKey(Key k) : boolean {
      if(!b_kbdfocus_selection_mode)
         return false;

      if(null != kbdfocus_selection_layer)
      {
         switch(k.pressed)
         {
            case VKEY_LEFT:
               if(0 == k.mod)
               {
                  FindKbdFocusLeft();
               }
               else
               {
                  kbdfocus_selection_layer.onKey(k);
               }
               return true;

            case VKEY_RIGHT:
               if(0 == k.mod)
               {
                  FindKbdFocusRight();
               }
               else
               {
                  kbdfocus_selection_layer.onKey(k);
               }
               return true;

            case VKEY_UP:
               if(0 == k.mod)
               {
                  FindKbdFocusUp();
               }
               else
               {
                  kbdfocus_selection_layer.onKey(k);
               }
               return true;

            case VKEY_DOWN:
               if(0 == k.mod)
               {
                  FindKbdFocusDown();
               }
               else
               {
                  kbdfocus_selection_layer.onKey(k);
               }
               return true;

            case VKEY_RETURN:
            case VKEY_SPACE:
               EndKbdFocusSelectionMode();
               return true;

            case VKEY_ESCAPE:
               CancelKbdFocusSelectionMode();
               return true;

            case VKEY_TAB:
               FindKbdFocusFirstTabRootMember();
               return true;

            default:
               kbdfocus_selection_layer.onKey(k);
               return true;
         }
      }
      return false;
   }

   private static DrawKbdFocusSelection() {
      // (note) called after all FBOs have been rendered

      if(null != kbdfocus_selection_layer)
      {
         Layer c <= kbdfocus_selection_layer;

         float px = c.abs_position_x;
         float py = c.abs_position_y;
         float sx = c.size_x;
         float sy = c.size_y;
         // // trace "xxx DrawKbdFocusSelection: pAbs=("+px+";"+py+") s=("+sx+";"+sy+")";

         UIRenderer.SetColor4f(0,0,0, 0.33);
         UIRenderer.EnableBlending();

         // Top
         if(UIRenderer.BeginFilledTriangleStrip(4))
         {
            UIRenderer.Vertex2f(0,              0 );
            UIRenderer.Vertex2f(viewport_width, 0 );
            UIRenderer.Vertex2f(0,              py);
            UIRenderer.Vertex2f(viewport_width, py);
            UIRenderer.End();
         }

         // Left
         if(UIRenderer.BeginFilledTriangleStrip(4))
         {
            UIRenderer.Vertex2f(0,  py   );
            UIRenderer.Vertex2f(px, py   );
            UIRenderer.Vertex2f(0,  py+sy);
            UIRenderer.Vertex2f(px, py+sy);
            UIRenderer.End();
         }

         // Right
         if(UIRenderer.BeginFilledTriangleStrip(4))
         {
            UIRenderer.Vertex2f(px+sx,          py   );
            UIRenderer.Vertex2f(px+sx,          py+sy);
            UIRenderer.Vertex2f(viewport_width, py   );
            UIRenderer.Vertex2f(viewport_width, py+sy);
            UIRenderer.End();
         }

         // Bottom
         if(UIRenderer.BeginFilledTriangleStrip(4))
         {
            UIRenderer.Vertex2f(0,              py+sy);
            UIRenderer.Vertex2f(viewport_width, py+sy);
            UIRenderer.Vertex2f(0,              viewport_height);
            UIRenderer.Vertex2f(viewport_width, viewport_height);
            UIRenderer.End();
         }

         // Active region
         UIRenderer.SetColor4f(1,0,0,1);
         UIRenderer.SetLineWidth(1.0f);
         UIRenderer.DisableBlending();

         if(UIRenderer.BeginLineStrip(5))
         {
            UIRenderer.Vertex2f(px,      py);
            UIRenderer.Vertex2f(px + sx, py);
            UIRenderer.Vertex2f(px + sx, py + sy);
            UIRenderer.Vertex2f(px,      py + sy);
            UIRenderer.Vertex2f(px,      py);
            UIRenderer.End();
         }
      }

   }


   // ----
   // ---- Current/desired size of the viewport (unscaled)
   // ----
   public static int viewport_width = 800, viewport_height = 600;
   public static int buffer_width, buffer_height;  // used for scissor clipping
   public static int multisample_samples;  // e.g. 4
   public static int multisample_buffers;  // 1
   public static int supersample_factor = 1;

   // ---- Zoom / scaling
   public static float zoom_x = 1.0;
   public static float zoom_y = 1.0;

   // ---- Font scaling
   public static float font_scaling = 1.0;

   // ---- Font scaling (TextView / TextEdit pixelfonts) (should be an integer)
   public static float textview_font_scaling = 1;

   public static boolean b_textview_hidpi_font;

   // ---- Font smoothing (true=use 8bit alpha, false=use 1bit alpha)
   public static boolean b_font_smoothing;

   // ---- Icon scaling
   public static float icon_scaling = 1.0;

   // ---- Padding scaling
   public static float pad_scaling = 1.0;

   // ---- Window border scaling
   public static float window_border_scaling = 1.0;

   // see TableModel.getMinimumColumnWidthScaled()
   public static float table_min_col_width_scaling = 1.0;

   protected static float fps_lo;
   protected static float fps_hi;
   protected static boolean b_force_high_framerate;

   // true=attach depth buffer to FBOs
   namespace static boolean b_fbo_depth_buffers;

   // ----
   // ---- Parse the given _xml code, create a Window layer
   // ---- and add it to the root_layer children list.
   // ---- Return the created window.
   // ----
   public static AddWindowXML(String _xml)/*:Window*/ {
   }

   // ----
   // ---- Parse the given _xml code and create a Layer
   // ---- object.
   // ---- Return the created Layer.
   // ----
   public static CreateLayerXML(String _xml)/*:Layer*/ {
   }

   static boolean b_fbo = true;

   // ----
   // ---- Set maximum graphics update interval
   // ----
   public static SetFrameRate(float fpsLo, float fpsHi) {
      fps_lo = fpsLo;
      fps_hi = fpsHi;
      UpdateFrameRate(false/*bHigh*/);
   }

   public static UpdateFrameRate(boolean _bHigh) {
      _bHigh |= b_force_high_framerate | b_benchmark;

      FPS.tickInterval = 1000.0 / (_bHigh ? fps_hi : fps_lo);
      FPS.tickBuffer   = 0;
      if(_bHigh)
         FPS.limit = 0; // rely on 60Hz vsync
      else
         FPS.limit = fps_lo;
   }

   public static QueueToggleFullscreen() {
      explain "Queue screen mode change (fullscreen)";

      queued_screenmodechange = QUEUE_MODE_FULLSCREEN_TOGGLE;
      SDL.exitEventLoop();
   }

   public static QueueReopen() {
      explain "Queue screen mode change";

      queued_screenmodechange = QUEUE_MODE_REOPEN;
      queue_orig_sx = (Viewport.width  / zoom_x);
      queue_orig_sy = (Viewport.height / zoom_y);
      SDL.exitEventLoop();
   }

   public static QueueCustomResizePrefs(int _w, int _h) {
      // Used by PagePrefs and PrefsDialog
      //  (may only be called directly after QueueReopen())
      queue_orig_sx = _w;
      queue_orig_sy = _h;
   }

   public static QueueResize(int _w, int _h) {
      explain "Queue screen mode change";

      queued_screenmodechange = QUEUE_MODE_REOPEN;
      queue_orig_px = Viewport.positionX;
      queue_orig_py = Viewport.positionY;
      queue_orig_sx = (_w  / zoom_x);
      queue_orig_sy = (_h / zoom_y);
      SDL.exitEventLoop();
   }

   public static SetMinimumSize(int _w, int _h) {
      Viewport.setMinimumSize(_w, _h);
   }

   // ----
   // ---- Open a window on the "real" host desktop.
   // ---- This window will become the desktop screen for
   // ---- all tkui Layers.
   // ----
   public static OpenWindow(int _w, int _h) {
      if(Configuration.debugLevel) trace "[dbg] UI::OpenWindow("+_w+"; "+_h+")";

      if(null != root_layer)
      {
         if(_w <= 0)
            _w = root_layer.getPreferredSizeX();

         if(_h <= 0)
            _h = root_layer.getPreferredSizeY();
      }
      if(_w <= 0)
         _w = 800; // default viewport width

      if(_h <= 0)
         _h = 600; // default viewport height

      viewport_width  = _w / zoom_x;
      viewport_height = _h / zoom_y;

      if(!b_headless)
      {
         InitCallbacks();

         SDL.eventPolling  = false; // tksdl default is "true" (do not block while waiting for an SDL event)
         SDL.timerInterval = 20;

         // (note) enabling "DIRTY" redrawing seems to burn a lot of cycles !!?
         //        REDRAW_ALL is ~3.2 times faster (tested with ST2, ~2.5% load instead of ~8.00% !)
         //          ==> reason was the Sleep/SDL_Delay() call after the onIdle() script callback (!). should be fixed now. see tksdl/HAL.cpp
         // (note) if vsync does not work, REDRAW_ALL will probably burn even more cycles
         //        but if it works, CPU load is a tad lower than with REDRAW_DIRTY
         // (note) according to SysInternals processexplorer, the reported CPU load is lower w/ REDRAW_ALL but the cyclecount is the same (?!!)
         // (note) the idle CPU load is significantly higher/measurable w/ REDRAW_ALL ==> better use REDRAW_DIRTY..!
         SDL.redrawFlag = 1/*tksdl::REDRAW_DIRTY*/;  // (note) "REDRAW_DIRTY" constant in this class shadows plugin REDRAW_DIRTY const

         Viewport.flags = (b_noframe ? SDL_NOFRAME : 0) | (b_noresize ? 0 : SDL_RESIZABLE);

         Viewport.doubleBuffer = true;
         Viewport.multisampleSamples = multisample_samples;
         Viewport.multisampleBuffers = multisample_buffers;
         Viewport.openWindow(_w, _h);

         Viewport.pushGLContext();

         if(b_fbo)
         {
           // Load extensions (FBO)
            zglLoadExtensions();
         }

         // Enable vsync
         if(!b_benchmark)
            Viewport.swapInterval(1);
         else
            Viewport.swapInterval(0);
      }

      viewport_width  = _w / zoom_x;
      viewport_height = _h / zoom_y;

      // [14Sep2025] already called by Viewport.openWindow()
      // // if(!b_headless)
      // //    Screen_onOpen();

      Layer *fl;
      foreach fl in floating_layers
         fl.layoutHierarchy(true, false);

      RootLayerResized();

      if(!b_headless)
         Viewport.popGLContext();
   }

   public static Run() {
      if(b_headless)
         return;

      int ts = milliSeconds();
      // Debug("UI::Run: start ms="+ts);

      if(b_keyboard_monitor)
         keyboard_monitor.initKeyboardMonitor();

      UpdateCursors();

      b_running = true;

      for(;;)
      {
         // // InitScissors();
         RedrawAll();
         SDL.eventLoop();
         int te = milliSeconds();
         Debug("UI::Run: eventLoop() returned, ms_delta="+(te-ts));
         if(0 != queued_screenmodechange)
         {
            RevertCursor();
            FreeCursors();

            if(QUEUE_MODE_FULLSCREEN_TOGGLE == queued_screenmodechange)
            {
               Viewport.toggleFullScreen();
               // // Mouse.pointerMode = TKS_MOUSE_POINTER_MANUAL;
            }
            else // QUEUE_MODE_REOPEN
            {
               Viewport.close();

               Viewport.multisampleSamples = multisample_samples;
               Viewport.multisampleBuffers = multisample_buffers;
               UI.OpenWindow(queue_orig_sx * zoom_x, queue_orig_sy * zoom_y);
               if(-1 != queue_orig_px)
                  Viewport.setGeometry(queue_orig_px, queue_orig_py, 0,0);

               // // Mouse.pointerMode = TKS_MOUSE_POINTER_MOVE;
            }
            queued_screenmodechange = QUEUE_MODE_NONE;
            UpdateCursors();
         }
         else
         {
            return;
         }
      }
   }

   public static IsRunning() : boolean {
      return b_running;
   }

   public static Stop() {
      if(!b_headless)
      {
         SDL.exitEventLoop();
         Viewport.close();
      }
      b_running = false;
   }

   module static RootLayerResized() {

      if(!b_headless)
      {
         viewport_width  = Viewport.width / zoom_x;
         viewport_height = Viewport.height / zoom_y;
      }
      LayoutRootLayer();
      RedrawAll();

      if(b_keyboard_monitor)
         keyboard_monitor.updateGeometry();

      if(b_fbo)
      {
         // ---- Framebuffer objects are enabled, create FBO for root layer ----
         if(null == root_fbo)
         {
            root_fbo <= new FBO;
            root_fbo.autoEnableFilter();
            root_fbo.create(viewport_width, viewport_height, supersample_factor);

            if(b_draw_post_fbo)
            {
               post_fbo <= new FBO;
               post_fbo.autoEnableFilter();
               post_fbo.create(viewport_width, viewport_height, 1);
            }
         }
         else
         {
            root_fbo.autoEnableFilter();
            root_fbo.resize(viewport_width, viewport_height);

            if(b_draw_post_fbo)
            {
               post_fbo.autoEnableFilter();
               post_fbo.resize(viewport_width, viewport_height);
            }
         }
      }
   }

   public static RebindRootFBO() : FBO {
      // used by photo_edit app
      if(b_fbo)
      {
         root_fbo.beginPaint();
      }

      // // glViewport(0, 0, viewport_width * zoom_x, viewport_height * zoom_y);
      // // zglInit2D(viewport_width, viewport_height);
      // // glLoadIdentity();

      sdvg_SetFramebufferSize(viewport_width * zoom_x, viewport_height * zoom_y);
      UIRenderer.BeginFrame();
      UIRenderer.ProjInit2D(viewport_width, viewport_height);

      if(!UIRenderer.b_glcore)
         glDrawBuffer(GL_BACK);  // !b_glcore
   }

   public static LayoutRootLayer() {
      if(Configuration.debugLevel >= 2)
         trace "[dbg] UI::LayoutRootLayer: viewport=("+viewport_width+";"+viewport_height+") root_layer="+#(root_layer);

      if(null != root_layer)
      {
         root_layer.setPosition2f(0,0);
         root_layer.setRequiredSize2f(viewport_width, viewport_height);
         // Debug2("UI::LayoutRootLayer: call root_layer.handleResize();");
         root_layer.handleResize();
         // trace "[dbg] UI::LayoutRootLayer: root_layer="+#(root_layer)+" root_layer.size=("+root_layer.size_x+";"+root_layer.size_y+")";
         // // DrainEventQueue();  // [05Oct2024] remove call (breaks key repeat / key released not recvd when onKey() calls this fxn
      }
   }

   module static InitCallbacks() {
      use Screen_onResize            for SDL.onResize;
      use Screen_onClose             for SDL.onClose;
      use Screen_onOpen              for SDL.onOpen;
      use Screen_onDraw              for SDL.onDraw;
      use Screen_onKeyboard          for SDL.onKeyboard;
      use Screen_onMouse             for SDL.onMouse;
      use Screen_onExpose            for SDL.onExpose;
      use Screen_onApplicationActive for SDL.onApplicationActive;
      use Screen_onMouseFocusActive  for SDL.onMouseFocusActive;
      use Screen_onInputFocusActive  for SDL.onInputFocusActive;
      use Screen_onDropFiles         for SDL.onDropFiles;
      use Screen_onMoveWindow        for SDL.onMoveWindow;
      use Screen_onTimer             for SDL.onTimer;
      use Screen_onDrainEventQueue   for SDL.onDrainEventQueue;
   }

   // ----
   // ---- Process mouse event, generate "synthetic" click / double-click events.
   // ----
   protected static Layer *last_mouseclick_layer;
   protected static int last_mouseclick_ticks_l; // used to detect double-clicks
   protected static int last_mouseclick_ticks_r; // used to detect double-clicks
   protected static int last_mouseclick_ticks_m; // used to detect double-clicks
   protected static int last_mouseclick_button;
   protected static ResetMouseClick() {
      last_mouseclick_layer   <= null;
      last_mouseclick_ticks_l  = 0;
      last_mouseclick_ticks_r  = 0;
      last_mouseclick_ticks_m  = 0;
      last_mouseclick_button   = 0;
   }

   private   static MouseEvent drag_last_mouse_ev;
   private   static int        drag_start_mouse_button; // used to determine cancel button
   namespace static Layer     *drag_layer;
   public    static Layer     *drag_layer_candidate;    // Layer under mouse when LMB was first pressed
   private   static Point2f    drag_layer_abspos;       // at drag start. used for calculating relative mouse positions.
   public    static boolean    b_try_drag = false;
   private   static int        drag_threshold = UIConstants.MOUSE_DRAG_THRESHOLD;

   module static MouseHoldAction mousehold_timerAction;
   private static MouseEvent mousehold_event;
   private static Layer *mousehold_layer;  // for onMouseHoldEnd()

   // ---- Mouse hold timer expired
   module static HandleMouseHold() {

      // trace "[dbg] UI::HandleMouseHold: mouse_layer="+#(mouse_layer);
      mousehold_layer <= null;

      if(mouse_layer instanceof Layer)
      {
         b_try_drag = false;
         Layer c <= mouse_layer;
         while(null != c)
         {
            if(c.onMouseHold(mousehold_event)) // Layer specific mouse-hold handling?
            {
               if(@(c) != @(mousefocus_layer))
               {
                  mousefocus_layer <= c;
                  c.onMouseFocus();
               }

               mousehold_layer <= c;

               return true;
            }
            c <= c.getParent();
         }

         if(!mouse_layer.getRoot().isModal())
         {
            // Currently layer does not overwrite onMouseHold. The default behaviour is
            // to "click through" the current window and activate the window below.
            Layer l <= FindFloatingLayerBelowXY(mousehold_event.mouse_abs_x, mousehold_event.mouse_abs_y);

            if(null != l)
               l <= l.getRoot();

            if(l instanceof Window) // Don't allow "click-through" for Dialogs and Popupmenus!
            {
               ActivateFloatingLayer(l);
            }
         }
      }
   }

   protected static HandleMouseEvent(Layer _layer, MouseEvent _ev) : boolean {

      // trace "xxx HandleMouseEvent: layer="+#(_layer)+" mouse_layer="+#(mouse_layer);

      int t = SDL.ticks;
      int lastt = t;

      boolean bHandled = false;

      boolean bIsLeft = (_ev.changed_state & MOUSE_LBUTTON);
      boolean bIsRight = (_ev.changed_state & MOUSE_RBUTTON);
      boolean bIsMiddle = (_ev.changed_state & MOUSE_MBUTTON);

      Layer *l;
      int origMouseRelX;
      int origMouseRelY;
      MouseEvent dragEv;

      if(_ev.leftButtonUp() || _ev.rightButtonUp())
      {
         if(@(mousehold_layer) == @(_layer))
         {
            mousehold_layer <= null;
            l <= _layer;
            while(null != l)
            {
               if(l.onMouseHoldEnd(_ev))
               {
                  // trace "xxx onMouseHoldEnd handled by l="+#(l);
                  bHandled = true;
                  break;
               }
               l <= l.getParent();
            }
         }
      }

      // trace "xxx HandleMouseEvent: currentState="+_ev.current_state+" changedState="+_ev.changed_state;

      if( (_ev.changed_state&MOUSE_LBUTTON) || (_ev.changed_state&MOUSE_RBUTTON) || (_ev.changed_state&MOUSE_MBUTTON) )
      {
         if( ( (_ev.current_state&MOUSE_LBUTTON) && (_ev.changed_state&MOUSE_LBUTTON) ) ||
             ( (_ev.current_state&MOUSE_RBUTTON) && (_ev.changed_state&MOUSE_RBUTTON) ) ||
             ( (_ev.current_state&MOUSE_MBUTTON) && (_ev.changed_state&MOUSE_MBUTTON) )
             )
         {
            ////trace "xxx UI: press MB, last_button="+last_mouseclick_button+" last_ticks="+last_mouseclick_ticks+" t="+t+" last_layer="+#(last_mouseclick_layer);

            // ---- left/right/middle mouse button was pressed
            if(@(last_mouseclick_layer) == @(_layer))
            {
               if( (_ev.isLeftButton()   && (last_mouseclick_ticks_l+UIConstants.MOUSE_DOUBLE_CLICK_TIMEOUT) >= t) ||
                   (_ev.isRightButton()  && (last_mouseclick_ticks_r+UIConstants.MOUSE_DOUBLE_CLICK_TIMEOUT) >= t) ||
                   (_ev.isMiddleButton() && (last_mouseclick_ticks_m+UIConstants.MOUSE_DOUBLE_CLICK_TIMEOUT) >= t)
                   )
               {
                  mousehold_layer <= null;

                  ////trace "xxx dblclick: time ok, last_mouseclick_button="+last_mouseclick_button+" changedstate="+_ev.changed_state;
                  if( !(last_mouseclick_button ^_ev.changed_state) )
                  {
                     // trace "xxx dblclick: last_mouseclick_button="+last_mouseclick_button+" _ev.changed_state="+_ev.changed_state;

                     // Handle mouse doubleclick
                     boolean bMouseDoubleClickHandled = false;
                     l <= _layer;
                     origMouseRelX = _ev.mouse_rel_x;
                     origMouseRelY = _ev.mouse_rel_y;
                     do
                     {
                        bMouseDoubleClickHandled = l.onMouseDoubleClick(_ev);

                        if(true == bMouseDoubleClickHandled)
                        {
                           ////trace "xxx ui: handle double-click l="+#(l);
                           if(bIsLeft)
                              _ev.changed_state &= ~MOUSE_LBUTTON;
                           else if(bIsRight)
                              _ev.changed_state &= ~MOUSE_RBUTTON;
                           else if(bIsMiddle)
                              _ev.changed_state &= ~MOUSE_MBUTTON;
                           lastt = 0;
                        }
                        else if(false == bMouseDoubleClickHandled)
                        {
                           // Propagate to parent
                           _ev.mouse_rel_x += l.position_x; // (???TODO) remove this and leave it to the widget that actually needs this info
                           _ev.mouse_rel_y += l.position_y;
                           l <= l.getParent();
                        }
                     } while( false == bMouseDoubleClickHandled && null != l );

                     if(true == bMouseDoubleClickHandled)
                        bHandled = true;

                     _ev.mouse_rel_x = origMouseRelX;
                     _ev.mouse_rel_y = origMouseRelY;

                     // // // ---- is double click??
                     // // if(_layer.onMouseDoubleClick(_ev))
                     // // {
                     // //    if(bIsLeft)
                     // //    {
                     // //       _ev.changed_state &= ~MOUSE_LBUTTON;
                     // //    }
                     // //    else
                     // //    {
                     // //       _ev.changed_state &= ~MOUSE_RBUTTON;
                     // //    }
                     // //    lastt=0;
                     // //    bHandled = true;
                     // // }

                     //// trace "xxx ResetMouseClick";
                     ResetMouseClick();
                  }
               }
            }

            if(0 == last_mouseclick_button)
            {
               ////trace "xxx set last_mouseclick_button to "+_ev.changed_state;
               // last_mouseclick_button = _ev.changed_state;
               if(_ev.changed_state & MOUSE_LBUTTON)
                  last_mouseclick_button = MOUSE_RBUTTON;
               else if(_ev.changed_state & MOUSE_LBUTTON)
                  last_mouseclick_button = MOUSE_LBUTTON;
               else if(_ev.changed_state & MOUSE_MBUTTON)
                  last_mouseclick_button = MOUSE_MBUTTON;
            }

            if(!bHandled)
            {
               // Try mouse drag
               b_try_drag = true;
               drag_layer_candidate <= _layer;
               drag_last_mouse_ev = _ev;
               // trace "xxx schedule mouse hold timer";

               // Try mouse hold
               mousehold_timerAction.setTicks(UIConstants.MOUSE_HOLD_DELAY);
               mousehold_timerAction.setActionConsumer(mouseHoldConsumer);
               mousehold_timerAction.setActionProvider(UI);
               mousehold_event = _ev;
               CancelScheduleFor(mouseHoldConsumer);
               Schedule(mousehold_timerAction);
               ////trace "xxx schedule mousehold";
            }
            else
            {
               // Doubleclick was handled, cancel drag/hold
               b_try_drag = false;
               // trace "xxx HandleMouse: dblclick, set b_try_drag=0";
               drag_layer_candidate <= null;
               CancelScheduleFor(mouseHoldConsumer);
            }

            last_mouseclick_layer <= _layer;
            if(_ev.isRightButton())
               last_mouseclick_ticks_r = lastt;
            else if(_ev.isLeftButton())
               last_mouseclick_ticks_l = lastt;
            else if(_ev.isMiddleButton())
               last_mouseclick_ticks_m = lastt;

            if(!_layer.getRoot().isModal())
            {
               Window *parentWin <= last_mouseclick_layer.getRoot();
               if(parentWin instanceof Window)
               {
                  ActivateFloatingLayer(parentWin);
               }
               else
               {
                  if(null != active_floatinglayer)
                  {
                     active_floatinglayer.redraw();
                     if(!active_floatinglayer.isModal())
                        active_floatinglayer <= null;
                  }
               }
            }
         }
         else
         {
            // trace "xxx lmb was released drag_layer="+#(drag_layer);

            // trace "xxx HandleMouse: lmb released, set b_try_drag=0";
            b_try_drag = false;
            CancelScheduleFor(mouseHoldConsumer);

            if(null != drag_layer)
            {
               // ---- End drag
               dragEv = _ev;
               dragEv.calcMouseRelv(drag_layer_abspos);

               if(drag_layer.wantMouseDragButtonOnlyEvents() ||
                  (dragEv.mouse_rel_x != drag_last_mouse_ev.mouse_rel_x) ||  // filter button-only events (no movement)
                  (dragEv.mouse_rel_y != drag_last_mouse_ev.mouse_rel_y)     //  (e.g. immediately before end-drag)
                  )
               {
                  drag_layer.onMouseDrag(drag_last_mouse_ev, dragEv);
               }

               if(drag_start_mouse_button & MOUSE_LBUTTON)
               {
                  // Mouse drag was started with LMB
                  // trace "xxx drag start with LMB dragEv.isRightButtonDown()="+dragEv.isRightButtonDown();
                  if(dragEv.rightButtonUp())
                  {
                     drag_layer.onMouseCancelDrag(dragEv);
                     drag_layer <= null;
                     b_ignore_next_mouse_release = true;
                  }
               }
               else
               {
                  // Mouse drag was started with RMB
                  // trace "xxx drag start with RMB dragEv.isLeftButtonUp()="+dragEv.isLeftButtonUp();
                  if(dragEv.leftButtonUp())
                  {
                     drag_layer.onMouseCancelDrag(dragEv);
                     drag_layer <= null;
                     b_ignore_next_mouse_release = true;
                  }
               }

               if(null != drag_layer)
               {
                  // Regular end of mouse drag
                  drag_layer.onMouseEndDrag(dragEv);
                  drag_layer <= null;
               }

               return true;
            } // if null != drag_layer
            else
            {

               // ---- left mouse button was released
               if( (_ev.isLeftButton() && (last_mouseclick_ticks_l+UIConstants.MOUSE_CLICK_TIMEOUT) >= t) ||
                   (_ev.isRightButton() && (last_mouseclick_ticks_r+UIConstants.MOUSE_CLICK_TIMEOUT) >= t) ||
                   (_ev.isMiddleButton() && (last_mouseclick_ticks_m+UIConstants.MOUSE_CLICK_TIMEOUT) >= t)
                   )
               {
                  ////if( (last_mouseclick_ticks+UIConstants.MOUSE_DOUBLE_CLICK_TIMEOUT) >= t )
                  if( (_ev.isLeftButton()  && (last_mouseclick_ticks_l+UIConstants.MOUSE_DOUBLE_CLICK_TIMEOUT) >= t) ||
                      (_ev.isRightButton() && (last_mouseclick_ticks_r+UIConstants.MOUSE_DOUBLE_CLICK_TIMEOUT) >= t) ||
                      (_ev.isMiddleButton() && (last_mouseclick_ticks_m+UIConstants.MOUSE_DOUBLE_CLICK_TIMEOUT) >= t)
                      )
                  {
                     last_mouseclick_button = _ev.changed_state;
                  }
                  else
                  {
                     // Note: do not reset last button state or dblclick will stop working
                     // //last_mouseclick_button = 0;
                  }

                  // ---- is single click??
                  if(@(last_mouseclick_layer)==@(_layer))
                  {
                     // trace "xxx onMouseClick="+_layer.onMouseClick(_ev);
                     boolean bMouseClickHandled = false;
                     l <= _layer;
                     origMouseRelX = _ev.mouse_rel_x;
                     origMouseRelY = _ev.mouse_rel_y;
                     do
                     {
                        bMouseClickHandled = l.onMouseClick(_ev);
                        if(bMouseClickHandled)
                        {
                           ////trace "xxx ui: handle single-click l="+#(l);
                           if(bIsLeft)
                              _ev.changed_state &= ~MOUSE_LBUTTON;
                           else if(bIsRight)
                              _ev.changed_state &= ~MOUSE_RBUTTON;
                           else if(bIsMiddle)
                              _ev.changed_state &= ~MOUSE_MBUTTON;
                           lastt = 0;
                        }
                        else
                        {
                           // Propagate to parent
                           _ev.mouse_rel_x += l.position_x; // (TODO) remove this and leave it to the widget that actually needs this info
                           _ev.mouse_rel_y += l.position_y;
                           l <= l.getParent();
                        }
                     } while( !bMouseClickHandled && (null != l) );

                     if(bMouseClickHandled)
                        bHandled = true;

                     _ev.mouse_rel_x = origMouseRelX;
                     _ev.mouse_rel_y = origMouseRelY;
                  }
                  // //trace "xxx reset mouseclick2";
                  // //ResetMouseClick();
               }
            }

            last_mouseclick_layer <= _layer;

            if(_ev.isRightButton())
               last_mouseclick_ticks_r = t;
            else if(_ev.isLeftButton())
               last_mouseclick_ticks_l = t;
            else if(_ev.isMiddleButton())
               last_mouseclick_ticks_m = t;
         }
      }

      if(_ev.leftButtonDown())
      {
         mousehold_layer <= null;

         // ---- Click-to-focus
         if(@(mousefocus_layer) != @(_layer))
         {
            boolean bMouseFocusLocked = false;
            if(mousefocus_layer instanceof Layer) // xxx != null..
            {
               ////trace "xxx mousefocus_layer="+#(mousefocus_layer);
               bMouseFocusLocked = mousefocus_layer.isMouseFocusLocked();
               if(!bMouseFocusLocked)
               {
                  mousefocus_layer.onMouseUnfocus();
                  // // bHandled = true;
               }
            }
            if(!bMouseFocusLocked && IsMouseFocusAllowed(_layer))
            {
               // trace "xxx setmousefocus_layer to "+#(_layer);
               mousefocus_layer <= _layer;
               _layer.onMouseFocus();
               // // bHandled = true;
            }
         }
      }

      if(_ev.isLeftButtonDown() || _ev.isRightButtonDown()) // button held down ?
      {
         // trace "xxx HandleMouse: l/r down, b_try_drag="+b_try_drag;
         if(b_try_drag)
         {
            // Check if mouse moved more than drag_threshold pixels
            int dragX = _ev.mouse_abs_x - drag_last_mouse_ev.mouse_abs_x;
            int dragY = _ev.mouse_abs_y - drag_last_mouse_ev.mouse_abs_y;
            ////trace "xxx dragX="+dragX+" dragY="+dragY;
            if(dragX || dragY)
            {
               if( sqrt( dragX*dragX + dragY*dragY ) >= drag_threshold )
               {
                  origMouseRelX = _ev.mouse_rel_x;
                  origMouseRelY = _ev.mouse_rel_y;
                  _ev.calcRelForLayer(drag_layer_candidate);

                  ////l <= _layer;
                  l <= drag_layer_candidate;
                  b_try_drag = false;

                  CancelScheduleFor(mouseHoldConsumer);
                  // trace "xxx HandleMouse: drag_threshold, set b_try_drag=0";
                  ////trace "xxx dragX="+dragX+" dragY="+dragY+" drag_layer="+#(drag_layer);
                  while(null != l)
                  {
                     // trace "xxx l="+#(l)+" rel=("+_ev.mouse_rel_x+";"+ _ev.mouse_rel_y+")";

                     if(l.blockMouseDrag(_ev))
                        break;

                     drag_last_mouse_ev.calcRelForLayer(l);
                     _ev.calcRelForLayer(l);
                     drag_start_mouse_button = _ev.current_state;
                     // trace "xxx ---------------------- call l.onMouseBeginDrag";
                     boolean bBeginDrag = l.onMouseBeginDrag(drag_last_mouse_ev, _ev);
                     if(true == bBeginDrag)
                     {
                        drag_layer <= l;
                        l.calcAbsolutePosition(drag_layer_abspos);
                        mouse_layer <= l;
                        drag_layer.onMouseDrag(drag_last_mouse_ev, _ev);
                        bHandled = true;
                        break;
                     }
                     else if(maybe == bBeginDrag)
                     {
                        return true;
                     }
                     else
                     {
                        _ev.mouse_rel_x += l.position_x;
                        _ev.mouse_rel_y += l.position_y;
                        l <= l.parent;
                     }
                  }

                  drag_last_mouse_ev = _ev;

                  _ev.mouse_rel_x = origMouseRelX;
                  _ev.mouse_rel_y = origMouseRelY;
               }
               else
               {
                  // Mouse was moved, restart mouse hold timer
                  // trace "xxx mouse moved, restart mouse hold timer";
                  mousehold_timerAction.setTicks(UIConstants.MOUSE_HOLD_DELAY);
                  mousehold_timerAction.setActionConsumer(mouseHoldConsumer);
                  mousehold_timerAction.setActionProvider(UI);
                  mousehold_event = _ev;
                  CancelScheduleFor(mouseHoldConsumer);
                  Schedule(mousehold_timerAction);
               }
            }
         }
         else if(null != drag_layer)
         {
            dragEv = _ev;
            dragEv.calcMouseRelv(drag_layer_abspos);

            if(drag_layer.onMouseDrag(drag_last_mouse_ev , dragEv))
            {
               // ---- Continue mouse drag
               drag_last_mouse_ev = dragEv;
               bHandled = true;
            }
            else
            {
               // ---- End drag
               drag_layer.onMouseEndDrag(dragEv);
               drag_layer <= null;
            }
         }
      }
      else
      {
         b_try_drag = false;
         // trace "xxx HandleMouse: lmb/rmb released, set b_try_drag=0";
         ////CancelScheduleFor(mouseHoldConsumer);
         //trace "xxx cancel mouseHoldConsumer";
      }

      // (note) '_layer' may have been deleted now (e.g. in onMouseClick())

      if((null == drag_layer) && !bHandled)
      {
         // trace "xxx UI distribute mouse event _layer="+#(_layer);
         Layer cl <= _layer;
         // trace "xxx UI mouseevent mouse_rel=("+_ev.mouse_rel_x+"; "+_ev.mouse_rel_y+")";
         if(null != cl)  // [11Dec2018] may be null e.g. after selecting PopupMenu item
         {
            do
            {
               // trace "xxx onMouse: UI cl="+#(cl);
               // trace "xxx onMouse: UI cl isLayer="+(cl instanceof Layer);
               // // if(cl instanceof Layer)
               // //    trace "xxx onMouse: UI cl.parent="+#(cl.parent);
               // // if(cl instanceof Button)
               // // {
               // //    Button xxxbt <= cl;
               // //    trace "xxxbt.caption="+xxxbt.getCaption();
               // // }
               boolean bResetMouseClick = !cl.wantOnMouseClickAfterOnMouseWasHandled(); // for TableViewData
               if(!cl.onMouse(_ev))
               {
                  _ev.mouse_rel_x += cl.position_x;
                  _ev.mouse_rel_y += cl.position_y;

                  cl <= cl.parent;

                  if(cl instanceof ViewPane)
                  {
                     ViewPane avp <= cl;
                     _ev.mouse_rel_x -= avp.getViewOffsetX();
                     _ev.mouse_rel_y -= avp.getViewOffsetY();
                  }
               }
               else
               {
                  // (note) 'cl' may have been deleted now
                  ////trace "xxx UI mouseevent consumed mouse_rel=("+_ev.mouse_rel_x+"; "+_ev.mouse_rel_y+")";
                  cl <= null;
                  bHandled = true;

                  if(bResetMouseClick)
                  {
                     if(_ev.leftButtonDown() ||
                        _ev.rightButtonDown() ||
                        _ev.middleButtonDown()
                        ) {
                        // [10Sep2019] Don't allow onMouseClick() when down event has already been handled
                        //  (note) while this is technically correct, the issue here is that many widgets
                        //          report e.g. RMB down as handled even though they might not actually have
                        //          handled the event
                        //          For example, old versions of the SampleView started RMB drag as soon as
                        //          the RMB was pressed
                        //          (later versions properly use onMouseBeginDrag() instead)
                        //  (todo) fix widgets (e.g. TableViewData, TextField)
                        ResetMouseClick();
                     }
                  }
               }
            } while(null != cl);
         }
         // trace "xxx UI mouseevent END";
      }

      return bHandled;
   }

   namespace static BeginMouseDragOther(Layer _l, MouseEvent _ev) {
      // (note) used by TextEdit (number edit)
      UI.SetMouseFocus(_l);
      _l.calcAbsolutePosition(drag_layer_abspos);
      _ev.mouse_rel_x = _l.getSizeX()*0.5;
      _ev.mouse_rel_y = _l.getSizeY()*0.5;
      _ev.mouse_abs_x = drag_layer_abspos.x + _ev.mouse_rel_x;
      _ev.mouse_abs_y = drag_layer_abspos.y + _ev.mouse_rel_y;
      _l.warpTo(_ev.mouse_rel_x, _ev.mouse_rel_y);
      b_try_drag = true;
      drag_layer_candidate <= _l;
      drag_last_mouse_ev = _ev;
      // // _l.onMouseBeginDrag(_ev/*dragStart*/, _ev);
      // // drag_layer <= _l;
   }

   public static ActivateFloatingLayer(FloatingLayer _w) : boolean {
      ////trace "xxx UI::ActivateFloatingLayer w="+#(_w);

      if(_w instanceof FloatingLayer)
      {
         if(@(active_floatinglayer) != @(_w))
         {
            FloatingLayerToFront(_w);
            active_floatinglayer <= _w;
            _w.redraw();
            _w.focusFirstTabCycleMember();
            return true;
         }
      }
      else
      {
         active_floatinglayer <= null;
         RedrawAll();
      }
      return false;
   }

   public static ActivatePreviousWindow() {
      // Note: the active_floatinglayer is not necessary the last element in the floating_layers array (e.g. think of tooltips)
      int idx = floating_layers.indexOfPointer(active_floatinglayer, 0);
      while(--idx >= 0)
      {
         Window l <= floating_layers[idx];
         if(l instanceof Window)
         {
            ActivateFloatingLayer(l);
            l.focusWindowTitleBar();
            return;
         }
      }
   }

   public static ActivateNextWindow() {
      // Note: the active_floatinglayer is not necessary the last element in the floating_layers array (e.g. think of tooltips)
      int idx = floating_layers.indexOfPointer(active_floatinglayer, 0);
      for(int i = 0; i < idx; i++)
      {
         Window l <= floating_layers[i];
         if(l instanceof Window)
         {
            ActivateFloatingLayer(l);
            l.focusWindowTitleBar();
            return;
         }
      }
   }

   module static CallOnUIActivate() {
      if(null != keyboard_layer)
      {
         // usually handled by PopupMenuBarButton so that alt-tab closes the pulldown
         // menu once the application re-gains the focus.
         // xxx does this cause problems with window managers that use mouseover-focus
         //     rather than click-to-focus?
         // trace "xxx UI::CallOnUIActivate: keyboard_layer="+#(keyboard_layer);
         keyboard_layer.onUIActivate();
      }

      // // if(null != root_layer)
      // //    root_layer.onRootLayerActivated();

   }

   module static CallOnUIDeactivate() {
      if(null != keyboard_layer)
      {
         // usually handled by PopupMenuBarButton so that alt-tab closes the pulldown
         // menu once the application re-gains the focus.
         // xxx does this cause problems with window managers that use mouseover-focus
         //     rather than click-to-focus?
         keyboard_layer.onUIDeactivate();
      }
      // trace "xxx UI::CallOnUIDeactivate";

      // hack to workaround lalt-tab issue
      last_key_mod &= ~(VMOD_LALT|VMOD_LMETA);
      b_ignore_first_lalt_key = true;

      // Fix grabbed mouse
      if(b_mouse_grab)
         UngrabMouse();

      drag_layer <= null;
   }

   module static OnApplicationActive(int _b) {

      if(global_redraw_num_frames > 0)
         global_redraw_frames_left = global_redraw_num_frames;

      ////trace "[dbg] UI::OnApplicationActive: b="+_b;
      if(_b)
      {
         CallOnUIActivate();

         Viewport.needRedraw();

         if(null != root_layer)
            root_layer.onRootLayerActivated();
      }
      else
      {
         CallOnUIDeactivate();

         CancelScheduleFor(keyRepeatConsumer);
      }
   }

   module static OnInputFocusActive(boolean _b) {

      if(_b && global_redraw_num_frames > 0)
         global_redraw_frames_left = global_redraw_num_frames;

      ////trace "[dbg] UI::OnInputFocusActive: b="+_b;
      if(_b)
      {
         CallOnUIActivate();
      }
      else
      {
         CallOnUIDeactivate();
      }
   }

   module static OnMouseFocusActive(boolean _b) {

      if(_b && global_redraw_num_frames > 0)
         global_redraw_frames_left = global_redraw_num_frames;

      // trace "[dbg] UI::OnMouseFocusActive: b="+_b+" mouse_layer="+#(mouse_layer);
      Layer *mlRoot;
      if(!_b)
      {
         // workaround:
         //  check if no mouse buttons are pressed to handle
         //  mousefocus-lost event on x11 when dragging a slider
         //  while mouse leaves the window
         if(!Mouse.buttons)
         {
            if(mouse_layer instanceof Layer)
            {
               // trace "xxx onMouseFocusActive: mouse_layer.getRoot()="+#(mouse_layer.getRoot());
               mlRoot <= mouse_layer.getRoot();
               if(!mlRoot.isModal() && !mlRoot.isPopup())
               {
                  // trace "[dbg] UI::OnMouseFocusActive: leave mouse_layer.root="+#(mouse_layer.getRoot())+" !modal";
                  ////MouseEvent *ev <= MouseEvent.New(Mouse.x, Mouse.y, Mouse.buttons, 0);
                  mouse_event.init(Mouse.x / UI.zoom_x,
                                   Mouse.y / UI.zoom_y,
                                   Mouse.buttons,
                                   0
                                   );
                  mouse_layer.onMouseLeave(mouse_event);
                  mouse_layer <= null;
               }
            }
            else
            {
               if(null != mouse_layer)
                  trace "[!!!] UI::OnMouseFocusActive: mouse_layer is not a Layer !!!";
            }

            CompositeAll();
         }

      }
      else
      {
         mouse_layer_lock_timeout_end_ticks = -1;

         // Focus topmost modal dialog window or root layer
         if(mouse_layer instanceof Layer)
         {
            mlRoot <= mouse_layer.getRoot();
            if(!mlRoot.isModal() && !mlRoot.isPopup())
            {
               mouse_layer <= null;
            }
         }
         else
         {
            mouse_layer <= null;  // [27May2018] workaround for very rare crash (after window resize?!) (TEST!)
         }
      }
   }

   static float ondropfiles_x;
   static float ondropfiles_y;

   module static OnDropFiles(int x, y, StringArray _fileNames) {
      // trace "xxx UI::OnDropFiles: p=("+x+";"+y+") fileNames="+_fileNames;

      ondropfiles_x = x / UI.zoom_x;
      ondropfiles_y = y / UI.zoom_y;

      Layer l <= FindFloatingLayerAtXY(ondropfiles_x, ondropfiles_y);
      // trace "xxx UI::OnDropFiles: 1 l="+#(l);
      if(null == l)
      {
         l <= root_layer.layerAt2f(ondropfiles_x, ondropfiles_y);
         // trace "xxx UI::OnDropFiles: 2 l="+#(l)+" p=("+ondropfiles_x+","+ondropfiles_y+")";
      }
      // trace "xxx UI::OnDropFiles: l="+#(l)+" p=("+ondropfiles_x+","+ondropfiles_y+") UI.zoom=("+UI.zoom_x+";"+UI.zoom_y+")";

      if(null != l)
      {
         boolean bAllow = true;

         if(null != active_floatinglayer)
         {
            if(active_floatinglayer.isModal())
            {
               bAllow = (@(l.getRoot()) == @(active_floatinglayer)) || (@(l) == @(active_floatinglayer));
            }
         }

         if(bAllow)
         {
            while(null != l)
            {
               // trace "xxx UI::OnDropFiles: call l="+#(l)+" onDropFiles";
               if(l.onDropFiles(deref _fileNames))
               {
                  break;
               }
               else
               {
                  l <= l.parent;
               }
            }
         }
      }
   }

   static int last_move_window_px = -1;
   static int last_move_window_py;
   module static OnMoveWindow(int _x, int _y) {
      if(null != root_layer)
      {
         if(_x != last_move_window_px || _y != last_move_window_py)
         {
            last_move_window_px = _x;
            last_move_window_py = _y;
            root_layer.onRootLayerMoved(_x, _y);
         }
      }
   }

   public static FindLayerAtXY(float _x, _y) : Layer {
      explain "Find layer at absolute mouse coordinates.";

      return root_layer.layerAt2f(_x, _y);
   }

   public static FindLayerAtMouseXY() : Layer {
      return FindLayerAtXY(GetMouseX(), GetMouseY());
   }

   public static FindLayerAtDropXY() : Layer {
      return FindLayerAtXY(ondropfiles_x, ondropfiles_y);
   }

   public static GetNumFloatingLayers() : int {
      ////trace "xxx floating_layers = "+#(floating_layers);
      return floating_layers.numElements;
   }

   public static GetNumModalFloatingLayers() : int {
      ////trace "xxx floating_layers = "+#(floating_layers);
      FloatingLayer *fl;
      int r = 0;
      foreach fl in floating_layers
      {
         if(fl.isModal())
            r++;
      }
      return r;
   }

   public static FindFloatingLayerAtXY(float _x, _y) : Layer {
      explain "Find floating layer / window resp. subwindow within that layer at (x;y) position";
      int i = floating_layers.numElements-1;
      Layer *l;
      while(i >= 0)
      {
         Layer fl <= floating_layers[i];
         if(fl.containsAbsoluteXY(_x, _y))
         {
            l <= fl.layerAt2f(_x, _y);
            if(null == l)
               l <= fl;
            return l;
         }
         i--;
      }
      return null;
   }

   public static FindFloatingLayerBelowXY(float _x, _y) : Layer {
      explain "Find floating layer / window below window at (x;y) position (if any)";
      int i = floating_layers.numElements - 1;
      Layer *l;
      while(i >= 0)
      {
         Layer fl <= floating_layers[i];
         if(fl.containsAbsoluteXY(_x, _y))
         {
            i--;
            while(i >= 0)
            {
               fl <= floating_layers[i];
               if(fl.containsAbsoluteXY(_x, _y))
                  return fl;
               i--;
            }
            return null;
         }
         i--;
      }
      return null;
   }

   public static GetMouseX() : float {
      return Mouse.x / zoom_x;
   }

   public static GetMouseY() : float {
      return Mouse.y / zoom_y;
   }

   public static IgnoreNextMouseRelease() {
      b_ignore_next_mouse_release = true;
   }

   module static OnMouse(MouseEvent _ev) {

      if(global_redraw_num_frames > 0)
         global_redraw_frames_left = global_redraw_num_frames;

      // trace "xxx FindLayerAtMouseXY()="+#(FindLayerAtMouseXY());

      if(b_kbdfocus_selection_mode)
         return;

      Point2f abspos;
      ////trace "UI::OnMouse: c="+_ev.current_state+" n="+_ev.changed_state;
      // trace "UI::OnMouse: mouseLayer="+#(mouse_layer);
      // trace "UI::OnMouse: drag_layer="+#(drag_layer);
      // trace "UI:.OnMouse: active_floatinglayer="+#(active_floatinglayer);
      // trace "UI::OnMouse: c="+_ev.current_state+" n="+_ev.changed_state+" mouse_layer="+#(mouse_layer);
      // // trace "UI::OnMouse: last_key_mod="+last_key_mod;
      // trace "UI::OnMouse: b_mouse_grab="+b_mouse_grab;

      if(b_mouse_grab)
      {
         // trace "xxx UI::OnMouse: grabbed Mouse.d=("+Mouse.dx+";"+Mouse.dy+")";
         _ev.mouse_abs_x = mouse_grab_x;
         _ev.mouse_abs_y = mouse_grab_y;
         mouse_grab_relx += Mouse.dx / zoom_x;
         mouse_grab_rely += Mouse.dy / zoom_y;
      }

      if(b_ignore_next_mouse_release && ((0 != _ev.changed_state) && (0 == _ev.current_state)))
      {
         b_ignore_next_mouse_release = false;
         return;
      }

      Layer l <= preferred_mouse_layer;

      if(null == l)
         l <= FindFloatingLayerAtXY(_ev.mouse_abs_x, _ev.mouse_abs_y);

      if(null == l && null != root_layer)
         l <= root_layer.layerAt2f(_ev.mouse_abs_x, _ev.mouse_abs_y);

      if(null == l && null != drag_layer) // [01Nov2023] fix SampleView marker drag when LMB is released outside of window
         l <= drag_layer;

      // trace "xxx UI::OnMouse: mouse_layer="+#(mouse_layer)+" l="+#(l);

      if(mouse_layer instanceof Layer)
      {
         mouse_layer.calcAbsolutePosition(abspos);
         _ev.calcMouseRelv(abspos);

         if(mouse_layer_lock_timeout_end_ticks >= 0)
         {
            // Mouse-over focus locked to scrollpane after wheel-scroll
            HandleMouseEvent(mouse_layer, _ev);
            return;
         }

         // trace "xxx mouse_layer relPos="+mouse_layer.position_x+"; "+mouse_layer.position_y;
         // trace "xxx mouse_layer abpos="+abspos.x+"; "+abspos.y;

         // trace "xxx mouse_layer ("+#(mouse_layer)+") size="+mouse_layer.getSizeString()+" min="+mouse_layer.getMinimumSizeString()+" pref="+mouse_layer.getPreferredSizeString()+" pos="+mouse_layer.getPositionString()+" first_child="+#(mouse_layer.first_child);

          // Layer *xxx <= mouse_layer.parent;
          // if(null != xxx)
          // {
          //    trace "xxx mouse_layer.parent ("+#(xxx)+") size="+xxx.getSizeString()+" min="+xxx.getMinimumSizeString()+" pref="+xxx.getPreferredSizeString()+" pos="+xxx.getPositionString();
          // }

         ////trace "xxx UI::OnMouse: Mouse=("+Mouse.x+"; "+Mouse.y+") layerabspos=("+abspos.x+"; "+abspos.y+")";
         ////trace "2UI::OnMouse: c="+_ev.current_state+" n="+_ev.changed_state+" bLocked="+mouse_layer.isMouseFocusLocked();
         // trace "xxx UI::OnMouse:: mouse_layer="+#(mouse_layer);

         boolean bNotModalChild = false;
         // trace "xxx UI::OnMouse: 2 active_floatinglayer="+#(active_floatinglayer);
         if(null != active_floatinglayer)
         {
            if(active_floatinglayer.isModal())
            {
               if(null != l)
                  bNotModalChild = (@(l.getRoot()) != @(active_floatinglayer)) && (@(l) != @(active_floatinglayer));
            }
            if(active_floatinglayer.isPopup())
            {
               // trace "xxx active_floatinglayer isPopup bNotModalChild="+bNotModalChild;

               if(bNotModalChild)
               {
                  if(null == drag_layer)
                  {
                     if(active_floatinglayer.handleNonChildMouseOver(_ev, l)) // Used for popup submenus
                        return;
                  }
               }
               // Hide popup window when the user clicks outside its area
               if( (_ev.leftButtonDown() || _ev.rightButtonDown()) && bNotModalChild )
               {
                  if(null == drag_layer)
                  {
                     // // if(!mouse_layer.isMouseFocusLocked())
                     // // {
                     // //    trace "xxx UI::onMouse: hide floating layer (click outside area) active_floatinglayer="+#(active_floatinglayer);
                     active_floatinglayer.hideByMouseClick();
                     return;
                     // // }
                  }
               }
            }
         }

         // Check if mouse focus is locked or current mouse focus layer is modal; allow focusing of mouse layer child layers
         if(mouse_layer.isMouseFocusLocked() || bNotModalChild) //(mouse_layer.getRoot().isModal() && !(l.getRoot() == active_floatinglayer)) )
         {
            // trace "xxx onMouse: HandleMouseEvent mouse_layer="+#(mouse_layer)+" _ev="+#(_ev);
            HandleMouseEvent(mouse_layer, _ev);
            return;
         }
         else
         {
            if(@(l) != @(mouse_layer))
            {
               Layer c <= mouse_layer;
               float origMouseRelX = _ev.mouse_rel_x;
               float origMouseRelY = _ev.mouse_rel_y;
               // trace "xxx UI::onMouseLeave: c="+#(c);
               c.onMouseLeave(_ev);
               // call onMouseLeave() for all parent layers until root layer is reached or mouse_rel >= 0
               for(;;)
               {
                  // translate to parent coordinate system
                  _ev.mouse_rel_x += c.position_x;
                  _ev.mouse_rel_y += c.position_y;

                  if((_ev.mouse_rel_x >= 0) && (_ev.mouse_rel_y >= 0))
                  {
                     c <= c.parent;
                     if(null != c)
                     {
                        if( (_ev.mouse_rel_x > c.size_x) || (_ev.mouse_rel_y > c.size_y) )
                        {
                           c.onMouseLeave(_ev);
                        }
                     }
                     break;
                  }

                  c <= c.parent;

                  if(null == c)
                     break;

                  c.onMouseLeave(_ev);
               }
               _ev.mouse_rel_x = origMouseRelX;
               _ev.mouse_rel_y = origMouseRelY;

               ////trace "xxx UI::OnMouse mouse_layer<=null";
               // (note) when using mouse-grab drag, isMouseFocusLocked() should return true while grabbed
               //         (to prevent this code from being reached)
               mouse_layer <= null;
            }
         }
      }

      if(null != l)
      {
         // // boolean bMouseAllowed = !b_mouse_grab && (null == drag_layer);////true;  // 12May2019 not while mouse is grabbed
         boolean bMouseAllowed = !IsMouseFocusLocked();

         if(bMouseAllowed)
         {
            if(null != active_floatinglayer)
            {
               if(active_floatinglayer.isModal())
               {
                  bMouseAllowed = (@(l.getRoot()) == @(active_floatinglayer)) || (@(l) == @(active_floatinglayer));
               }
            }
         }

         if(bMouseAllowed)
         {
            // trace "xxx mouse_layer="+#(mouse_layer)+" mouse_layer_lock_timeout_end_ticks="+mouse_layer_lock_timeout_end_ticks;
            if(@(l) != @(mouse_layer))
            {
               if( (null == mouse_layer) || (mouse_layer_lock_timeout_end_ticks < 0) )
               {
                  ResetMouseClick();
                  // --- Call root mouse enter
                  Layer lroot <= l.getRoot();
                  lroot.calcAbsolutePosition(abspos);
                  _ev.calcMouseRelv(abspos);
                  lroot.onChildMouseEnter(_ev);
                  // --- Call child mouse enter
                  l.calcAbsolutePosition(abspos);
                  _ev.calcMouseRelv(abspos);
                  l.onMouseEnter(_ev);
                  mouse_layer_lock_timeout_end_ticks = -1;
               }
            }

            {
               // ---- distribute MouseEvent to layer under mouse resp. parent layers if not handled
               if(IsMouseFocusAllowed(l))
               {
                  l.calcAbsolutePosition(abspos);
                  _ev.calcMouseRelv(abspos);
                  // // trace "xxx OnMouse set mouse_layer="+#(l)+" drag_layer="+#(drag_layer);
                  mouse_layer <= l;
                  if(!HandleMouseEvent(l, _ev))
                  {
                     // Pass unhandled mousewheel events to current keyboardlayer (e.g. useful for ComboBoxes)
                     if(null != keyboard_layer)
                     {
                        if(_ev.current_state & (MOUSE_WHEELUP | MOUSE_WHEELDOWN))
                        {
                           _ev.current_state &= (MOUSE_WHEELUP | MOUSE_WHEELDOWN);
                           _ev.changed_state &= (MOUSE_WHEELUP | MOUSE_WHEELDOWN);
                           HandleMouseEvent(keyboard_layer, _ev);
                        }
                     }
                  }
               }
            }
         } // if bMouseAllowed
      }

   }

   public static GrabMouse(/*MouseEvent _dragStart*/) {
      explain "Grab mouse and adjust mouse_rel_x/mouse_rel_y fields accordingly";
      // trace "xxx UI: GrabMouse";
      b_mouse_grab = true;
      mouse_grab_x = Mouse.x / UI.zoom_x;
      mouse_grab_y = Mouse.y / UI.zoom_y;
      mouse_grab_relx = 0;
      mouse_grab_rely = 0;
      Mouse.grab();  // warps mouse to center of screen
      // // float warpDx = Mouse.x - _dragStart.mouse_abs_x;
      // // float warpDy = Mouse.y - _dragStart.mouse_abs_y;
      // // _dragStart.mouse_abs_x = Mouse.x;
      // // _dragStart.mouse_abs_y = Mouse.y;
   }

   public static UngrabMouse() {
      explain "Ungrab mouse";
      b_mouse_grab = false;
      Mouse.ungrab();
   }

   public static FloatingLayerToFront(Layer _l) {
      if(floating_layers.numElements > 1)
      {
         int idxs = floating_layers.indexOfPointer(_l, 0);
         if(idxs >= 0)
         {
            FloatingLayer o <= floating_layers.getDeref(idxs);
            floating_layers.delete(idxs);
            floating_layers.add(#(deref o));

            CompositeAll();
         }
      }
   }

   static GetFrontMostFloatingLayer() : FloatingLayer {
      return floating_layers.getLast();
   }

   // ----
   // ---- Keyboard handling
   // ----

   protected static IntArray repeating_special_keys <= [VKEY_UP, VKEY_DOWN, VKEY_LEFT, VKEY_RIGHT,
                                                        VKEY_RETURN,
                                                        VKEY_HOME, VKEY_END,
                                                        VKEY_DELETE, VKEY_INSERT, VKEY_BACKSPACE,
                                                        VKEY_PAGEUP, VKEY_PAGEDOWN,
                                                        VKEY_F1,
                                                        VKEY_F2,
                                                        VKEY_F3,
                                                        VKEY_F4,
                                                        VKEY_F5,
                                                        VKEY_F6,
                                                        VKEY_F7,
                                                        VKEY_F8,
                                                        VKEY_F9,
                                                        VKEY_F10,
                                                        VKEY_F11,
                                                        VKEY_F12,
                                                        VKEY_KP0,
                                                        VKEY_KP1,
                                                        VKEY_KP2,
                                                        VKEY_KP3,
                                                        VKEY_KP4,
                                                        VKEY_KP5,
                                                        VKEY_KP6,
                                                        VKEY_KP7,
                                                        VKEY_KP8,
                                                        VKEY_KP9,
                                                        VKEY_KP_DIVIDE,
                                                        VKEY_KP_MULTIPLY,
                                                        VKEY_KP_PLUS,
                                                        VKEY_KP_MINUS

   ];

   protected static PointerArray accelerator_lists; // AcceleratorList references

   public static AddAcceleratorList(AcceleratorList _al) {
      accelerator_lists.add(#(_al));
   }

   public static RemoveAcceleratorList(AcceleratorList _al) {
      int idx = accelerator_lists.indexOfPointer(_al, 0);
      if(-1 != idx)
         accelerator_lists.delete(idx);
   }

   public static CheckAllAcceleratorLists(Key _k) : boolean {
      // Walk accelerator lists to find match
      AcceleratorList *al;
      foreach al in accelerator_lists
      {
         if(al.handleKey(_k))
         {
            ////trace "xxx UI::CheckAllAcceleratorLists: al="+#(al)+" accelerator key \""+_k.name+"\" was handled.";
            return true;
         }
      }
      return false;
   }

   public static GetKeyMod() : int {
      explain "Query the current key modifier state.";
      return last_key_mod;
   }

   public static KeyModNone() : boolean {
      return (0 == last_key_mod);
   }

   public static KeyModCtrl() : boolean {
      return (last_key_mod & VMOD_LCTRL) || (last_key_mod & VMOD_RCTRL);
   }

   public static KeyModCtrlOnly() : boolean {
      return (last_key_mod == VMOD_LCTRL) || (last_key_mod == VMOD_RCTRL);
   }

   public static KeyModShift() : boolean {
      return (last_key_mod & VMOD_LSHIFT) || (last_key_mod & VMOD_RSHIFT);
   }

   public static KeyModShiftOnly() : boolean {
      return (last_key_mod == VMOD_LSHIFT) || (last_key_mod == VMOD_RSHIFT);
   }

   public static KeyModAlt() : boolean {
      return (last_key_mod & VMOD_LALT) || (last_key_mod & VMOD_RALT);
   }

   public static KeyModAltOnly() : boolean {
      return (last_key_mod == VMOD_LALT) || (last_key_mod == VMOD_RALT);
   }

   public static IsAutoFocusKey(Key _k) : boolean {
      if!([VKEY_LCTRL, VKEY_RCTRL, VKEY_LALT, VKEY_RALT, VKEY_LSHIFT, VKEY_RSHIFT,
           '^', '+', '#',
           ' ', VKEY_EQUALS].contains(_k.code))
      {
         return true;
      }
      return false;
   }

   public static ScheduleTriadKeyTimer() {
      // trace "\n\n\nxxx UI::ScheduleTriadKeyTimer";
      triadkey_timerAction.setTicks(UIConstants.TRIADKEY_TIMEOUT);
      triadkey_timerAction.setActionConsumer(triadkeyConsumer);
      triadkey_timerAction.setActionProvider(UI);
      triadkey_timerAction.name = "TA_TRIADKEY_TIMEOUT";
      CancelTriadKeyTimer();
      Schedule(triadkey_timerAction);
   }

   public static CancelTriadKeyTimer() {
      CancelScheduleFor(triadkeyConsumer);
   }

   public static HandleTriadKeyTimeout() {

      // Abort triad key mode
      b_triad_key_mode = false;
      b_triad_key_waitrelease = false;

      // Let layer show help dialog (or do nothing)
      Layer c <= keyboard_layer;
      while(null != c)
      {
         if(c.onTriadKeyTimeout())
            break;
         c <= c.parent;
      }
   }

   static public SetEnableVSyncKeyRepeat(boolean _bEnable) {
      b_vsync_keyrepeat = _bEnable;
   }

   static private StartOrContinueKeyRepeat(Key _k) {
      if(_k.code <= 1)
         return;
      // trace "xxx UI::StartOrContinueKeyRepeat _k.pressed="+_k.pressed+" vsync="+b_vsync_keyrepeat;
      // UI.Backtrace();

      CancelScheduleFor(keyRepeatConsumer);

      ta_keyrepeat.name = "UI_keyrepeat";
      ta_keyrepeat.b_ondraw = b_vsync_keyrepeat;
      if(repeat_key.code == _k.code)
      {
         if(b_vsync_keyrepeat)
         {
            ta_keyrepeat.setTicks(key_repeat_rate_frames);
         }
         else
         {
            ta_keyrepeat.setTicks(key_repeat_rate);
         }
      }
      else
      {
         if(b_vsync_keyrepeat)
         {
            ta_keyrepeat.setTicks(key_repeat_delay_frames);
         }
         else
         {
            ta_keyrepeat.setTicks(key_repeat_delay);
         }
      }
      ta_keyrepeat.setActionConsumer(keyRepeatConsumer);
      ta_keyrepeat.setActionProvider(UI);

      /////trace "xxx UI::RecursiveHandleKey: Schedule KeyRepeat TimerAction SDL.ticks="+(SDL.ticks)+" ta.ticks="+ta_keyrepeat.getTicks();
      repeat_key = _k; // copy Key
      Schedule(ta_keyrepeat);
   }

   // ---- Key repeat/delay timer expired, resend keyevent (both pressed+released)
   static module HandleKeyRepeat() {
      // trace "xxx HandleKeyRepeat: repeat_key code="+repeat_key.code+" mod="+repeat_key.mod+" unicode="+repeat_key.unicode;

      if(keyboard_layer instanceof Layer)
      {
         if(b_triad_key_repeating)
         {
            keyboard_layer.onTriadKey(repeat_key);
            StartOrContinueKeyRepeat(repeat_key);
            return;
         }

         if(b_kbdfocus_selection_mode)
         {
            repeat_key.pressed = repeat_key.code;
            HandleKbdFocusSelectionKey(repeat_key);
            StartOrContinueKeyRepeat(repeat_key);

            repeat_key.released = repeat_key.code;
            HandleKbdFocusSelectionKey(repeat_key);
         }
         else
         {
            boolean bHandled = false;

            // Handle virtual keypress event
            //  Note: this will schedule the keyrepeat timer if the key was handled and is repeatable
            repeat_key.pressed = repeat_key.code;
            bHandled |= RecursiveHandleKey(keyboard_layer, repeat_key);

            // Handle virtual keyrelease event
            repeat_key.released = repeat_key.code;
            bHandled |= RecursiveHandleKey(keyboard_layer, repeat_key);

            // trace "xxx HandleKeyRepeat: bHandled"+bHandled;

            if(!bHandled)
            {
               // Call "global" root layer keyboard handler
               repeat_key.pressed = repeat_key.code;
               if(null != root_layer)
                  bHandled |= RecursiveHandleKey(root_layer, repeat_key);

               repeat_key.released = repeat_key.code;
               if(null != root_layer)
                  bHandled |= RecursiveHandleKey(root_layer, repeat_key);

               if(!bHandled)
               {
                  StartOrContinueKeyRepeat(repeat_key);
               }
            }
         }
      }
   }

   static private StopKeyRepeat(Key _k) {
      // trace "xxx StopKeyRepeat k.code="+_k.code;
      CancelScheduleFor(keyRepeatConsumer);
   }

   public static CancelKeyRepeat() {
      // trace "xxx CancelKeyRepeat";
      // Backtrace();
      repeat_key.code = 0;
      CancelScheduleFor(keyRepeatConsumer);
   }

   static private HandleKeyRepeatEnd(Key _k) {
      if(_k.code <= 1)
         return;

      // trace "xxx HandleKeyRepeatEnd: _k.code="+_k.code;

      // Handle end of key repeat
      if(_k.released)
      {
         if(_k.code == repeat_key.code)
         {
            CancelKeyRepeat();
         }
      }
   }

   public static SetEnableKeyRepeat(boolean _bRepeat) {
      b_allow_keyrepeat = _bRepeat;
      if(!_bRepeat)
         CancelScheduleFor(keyRepeatConsumer);
   }

   public static ConfigureKeyRepeat(int _delay, _rate) {
      if(_delay > 0)
         key_repeat_delay = _delay;

      if(_rate > 0)
         key_repeat_rate = _rate;
   }

   public static ConfigureKeyRepeatFrames(int _delay, _rate) {
      if(_delay > 0)
         key_repeat_delay_frames = _delay;

      if(_rate > 0)
         key_repeat_rate_frames = _rate;
   }

   public static MacOSGetInputSource() : String {
      // (note) was used in tksdl12-compat build. not required anymore for tksdl2.
      local String buf;
      buf.alloc(8192);
      local String cmd <= "defaults read ~/Library/Preferences/com.apple.HIToolbox.plist AppleSelectedInputSources";
      psystem(cmd, 'r', buf);
      // trace buf;
      local StringArray a <= buf.splitChar('\n');
      String *line;
      foreach line in a
      {
         if(line & "\"KeyboardLayout Name\"")
         {
            line.replace("\"KeyboardLayout Name\" = ", "");
            line.replace("\"", "");
            line.replace(";", "");
            line.trim();  // => "PC-Tastatur, Deutsch", "Finnish", "U.S.", ""(CN Wubi), "Arabic", ..
            if(line.isBlank())
               return null;
            return Object(line);
         }
         else if(line & "com.apple.inputmethod")
         {
            if(line & "Tamil.AnjalIM")
               return "Tamil Anjal";
         }
      }
      return null;
   }

   // <input source>, <domain>, <forceusunicode>
   protected static StringArray macos_input_source_to_domain_table = [
      "Afghan Dari",    "af",      "y",
      "Albanian",       "al",      "n",
      "Austrian",       "at",      "n",
      "Australian",     "au",      "n",
      "Azeri",          "az",      "y",
      "Belgian",        "be",      "n",
      "Bulgarian",      "bg",      "y",
      "Brazilian",      "br",      "n",
      "Byelorussian",   "by",      "y",
      "Canadian",       "ca",      "n",
      "Swiss German",   "ch",      "n",
      "Czech",          "cz",      "n",
      "German",         "de",      "n",
      "Deutsch",        "de",      "n",
      "Danish",         "dk",      "n",
      "Estonian",       "ee",      "n",
      "Arabic",         "eg",      "y",
      "Spanish",        "es",      "n",
      "Finnish",        "fi",      "n",
      "French",         "fr",      "n",
      "Greek",          "gr",      "y",
      "Croatian",       "hr",      "y",
      "Hungarian",      "hu",      "n",
      "Irish",          "ie",      "n",
      "Hebrew",         "il",      "y",
      "Kurdish",        "krd",     "y",
      "Tamil Anjal",    "lk",      "y",
      "Lithuanian",     "lt",      "y",
      "Latvian",        "lv",      "n",
      "Macedonian",     "mk",      "y",
      "Latin American", "mx",      "n",
      "Dutch",          "nl",      "n",
      "Norwegian",      "no",      "n",
      "Urdu",           "pk",      "y",
      "Polish",         "pl",      "n",
      "Portuguese",     "pt",      "n",
      "Romanian",       "ro",      "y",
      "Serbian",        "rs",      "y",
      "Russian",        "ru",      "y",
      "Swedish",        "se",      "n",
      "Slovak",         "sk",      "n",
      "Slovenian",      "si",      "y",
      //"Syriac",         "sy",      "y", // a..z unicodes reported as 0
      "Thai",           "th",      "y",
      "Turkmen",        "tm",      "n",
      "Turkish",        "tr",      "n",
      "Ukrainian",      "ua",      "y",
      "British",        "uk",      "n",
      "U.S.",           "us",      "n",
      "Hawaiian",       "hawaii",  "n",
      "Vietnamese",     "vn",      "y",
      "Welsh",          "wales",   "n",
                                                                      ];

   protected static AutoDetectLocalToRawKeyTable() : boolean {
      // (note) was used in tksdl12-compat build. not required anymore for tksdl2.
      if(IsMacOS())
      {
         String sInputSource <= MacOSGetInputSource();
         if(null != sInputSource)
         {
            if(Configuration.debugLevel)
               trace "[dbg] UI::AutoDetectLocalToRawKeyTable<macOS>: current input source is \""+sInputSource+"\"";
            String domain = "us";
            int j = 0;
            loop(macos_input_source_to_domain_table.numElements / 3)
            {
               // trace macos_input_source_to_domain_table[j+0];
               if(sInputSource & macos_input_source_to_domain_table[j+0])
               {
                  domain = macos_input_source_to_domain_table[j+1];
                  trace "[dbg] UI::AutoDetectLocalToRawKeyTable<macOS>: domain=\""+domain+"\" forceUSUnicode="+macos_input_source_to_domain_table[j+2];
                  Key.SetLocalToRawKeyTableByName(domain);
                  SetEnableForceUSUnicode("y" == macos_input_source_to_domain_table[j+2]);
                  break;
               }
               j += 3;
            }
         }
         else
         {
            trace "[~~~] UI::AutoDetectLocalToRawKeyTable<macOS>: failed to determine current input source";
            // // // Key.SetLocalToRawKeyTableByName("");  // keep previously set key table
         }
      }
   }

   public static SetLocalToRawKeyTableByName(String _domain) : boolean {
      // (note) was used in tksdl12-compat build. not required anymore for tksdl2.
      if(Configuration.debugLevel)
         trace "[dbg] UI::SetLocalToRawKeyTableByName(\""+_domain+"\")";
      if("auto" == _domain)
         return AutoDetectLocalToRawKeyTable();
      else
         return Key.SetLocalToRawKeyTableByName(_domain);
   }

   public static SetEnableKeyMapSlashToLess(boolean _bEnable) {
      b_key_map_slash_to_less = _bEnable;
   }

   public static SetEnableKeyCmdCopyPaste(boolean _bEnable) {
      b_key_cmd_copy_paste = _bEnable;
   }

   public static SetEnableForceUSUnicode(boolean _bEnable) {
      trace "[dbg] UI::SetEnableForceUSUnicode("+_bEnable+")";
      b_key_force_us_unicode = _bEnable;
   }

   // maps raw scancode (US unicode/ASCII) to shifted character
   protected static IntArray shifted_scan_code_table = [
      ' ',  ' ',
      '`',  '~',
      '1',  '!',
      '2',  '@',
      '3',  '#',
      '4',  '$',
      '5',  '%',
      '6',  '^',
      '7',  '&',
      '8',  '*',
      '9',  '(',
      '0',  ')',
      '-',  '_',
      '=',  '+',
      '[',  '{',
      ']',  '}',
      ';',  ':',
      '\'', '\"',
      '\\', '|',
      'Â§',  'Â±',
      ',',  '<',
      '.',  '>',
      '/',  '?',
                                                        ];

   protected static MapShiftedScanCode(int _code) : int {
      if('a' <= _code <= 'z')
         return _code & ~32;  // => A..Z
      int j = 0;
      loop(shifted_scan_code_table.numElements/2)
      {
         if(shifted_scan_code_table[j+0] == _code)
            return shifted_scan_code_table[j+1];
         j += 2;
      }
      return 0; // ctrl, shift, alt, return, ..
   }

   public static OnKeyboard(Key _k) {

      // trace "xxx OnKeyboard: k.name="+_k.name+" k.code="+_k.code+" k.mod="+_k.mod+" k.pressed="+_k.pressed+" k.released="+_k.released;

      if(global_redraw_num_frames > 0)
         global_redraw_frames_left = global_redraw_num_frames;

      if(b_key_modifier_key_clear_modifier)
      {
         if(_k.code == VKEY_LSHIFT && _k.mod & VMOD_LSHIFT)
            _k.mod &= ~VMOD_LSHIFT;

         if(_k.code == VKEY_RSHIFT && _k.mod & VMOD_RSHIFT)
            _k.mod &= ~VMOD_RSHIFT;

         if(_k.code == VKEY_LCTRL && _k.mod & VMOD_LCTRL)
            _k.mod &= ~VMOD_LCTRL;

         if(_k.code == VKEY_RCTRL && _k.mod & VMOD_RCTRL)
            _k.mod &= ~VMOD_RCTRL;

         if(_k.code == VKEY_LALT && _k.mod & VMOD_LALT)
            _k.mod &= ~VMOD_LALT;

         if(_k.code == VKEY_LALT && _k.mod & VMOD_LMETA)  // when using macos_keymap_*
            _k.mod &= ~VMOD_LMETA;

         if(_k.code == VKEY_LMETA && _k.mod & VMOD_LALT)  // when using macos_keymap_*
         {
         // //    _k.code = VKEY_LALT;
            _k.mod &= ~VMOD_LALT;
         }

         if(_k.code == VKEY_RALT && _k.mod & VMOD_RALT)
            _k.mod &= ~VMOD_RALT;

         if(_k.code == VKEY_LMETA && _k.mod & VMOD_LMETA)
            _k.mod &= ~VMOD_LMETA;

         if(_k.code == VKEY_RMETA && _k.mod & VMOD_RMETA)
            _k.mod &= ~VMOD_RMETA;

         if(_k.code == VKEY_LSUPER && _k.mod & VMOD_LMETA)
            _k.mod &= ~VMOD_LMETA;

         if(_k.code == VKEY_RSUPER && _k.mod & VMOD_RMETA)
            _k.mod &= ~VMOD_RMETA;

         if(_k.code == VKEY_LSUPER && _k.mod & VMOD_LALT)
            _k.mod &= ~VMOD_LALT;

         if(_k.code == VKEY_RSUPER && _k.mod & VMOD_RALT)
            _k.mod &= ~VMOD_RALT;

      }

      if(b_key_swap_lalt_lmeta_key)
      {
         // (note) LMETA = lcontrol on macOS (SDL)
         // (note) LALT = lcommand on macOS (SDL)
         if(_k.code == VKEY_LMETA)
            _k.code = VKEY_LALT;
         else if(_k.code == VKEY_LALT)
            _k.code = VKEY_LMETA;
      }

      if(b_key_swap_lalt_lmeta_mod)
      {
         boolean bLMETA = (0 != (_k.mod & VMOD_LMETA));
         boolean bLALT  = (0 != (_k.mod & VMOD_LALT));
         // trace "xxx b_key_swap_lalt_lmeta: _k.name="+_k.name+" bLMETA="+bLMETA+" bLALT="+bLALT;
         if(bLMETA ^ bLALT)
         {
            if(bLMETA)
            {
               bLMETA = false;
               bLALT  = true;
            }
            else
            {
               bLMETA = true;
               bLALT  = false;
            }
            _k.mod = (_k.mod & ~(VMOD_LMETA|VMOD_LALT)) | (bLMETA ? VMOD_LMETA : 0) | (bLALT ? VMOD_LALT : 0);
         }

      }

      // trace "xxx 2 OnKeyboard: k.name="+_k.name+" k.code="+_k.code+" k.mod="+_k.mod+" _k.pressed="+_k.pressed;

      if(b_key_swap_ralt_rsuper_key)
      {
         // Macbook keyboard
         if(_k.code == VKEY_RALT)
            _k.code = VKEY_RSUPER;
         else if(_k.code == VKEY_RSUPER)
            _k.code = VKEY_RALT;
      }

      // trace "xxx 2 OnKeyboard: k.name="+_k.name+" k.code="+_k.code+" k.mod="+_k.mod;

      if(b_key_map_rsuper_to_rctrl)
      {
         if(_k.code == VKEY_RSUPER)
            _k.code = VKEY_RCTRL;
      }

      if(b_key_no_numpad_unicode)
      {
         if((0 != _k.unicode) &&
            (VKEY_KP0/*256*/ <= _k.code <= (VKEY_KP_EQUALS/*272*/))
            )
            _k.unicode = 0;
      }

      if(b_key_map_rmeta_to_menu)
      {
         if(_k.code == VKEY_RMETA)
            _k.code = VKEY_MENU;
      }

      if(_k.code == 167/*SDLK_WORLD_7,macos german PC kbd with US input source,key between lshift and z*/)
         _k.code = VKEY_LESS/*60*/;

      if(b_key_force_us_unicode)
      {
         // (note) allow ASCII-text editing with eastern/non-QWERTY keyboards
         // trace "xxx UI::force_us_unicode: pressed="+_k.pressed;
         if(_k.pressed)
         {
            if!([VKEY_LSHIFT, VKEY_LCTRL, VKEY_LMETA, VKEY_LALT, VKEY_LSUPER,
                 VKEY_RSHIFT, VKEY_RCTRL, VKEY_RMETA, VKEY_RALT, VKEY_RSUPER, VKEY_MENU,
                 VKEY_ESCAPE, VKEY_RETURN,
                 VKEY_PRINT, VKEY_HELP, VKEY_SYSREQ, VKEY_PAUSE, VKEY_SCROLLOCK,
                 VKEY_INSERT, VKEY_DELETE, VKEY_BACKSPACE,
                 VKEY_HOME, VKEY_END, VKEY_PAGEUP, VKEY_PAGEDOWN,
                 VKEY_F1, VKEY_F2, VKEY_F3, VKEY_F4, VKEY_F5, VKEY_F6,
                 VKEY_F7, VKEY_F8, VKEY_F9, VKEY_F10, VKEY_F11, VKEY_F12,
                 VKEY_KP0, VKEY_KP1, VKEY_KP2, VKEY_KP3, VKEY_KP4, VKEY_KP5, VKEY_KP6, VKEY_KP7, VKEY_KP8, VKEY_KP9,
                 VKEY_KP_PERIOD, VKEY_KP_DIVIDE, VKEY_KP_MULTIPLY, VKEY_KP_MINUS, VKEY_KP_PLUS, VKEY_KP_ENTER, VKEY_KP_EQUALS,
                 ]
                .contains(_k.pressed)
                )
            {
               if(_k.modShift())
                  _k.unicode = MapShiftedScanCode(_k.pressed); // !@#$%^&(..
               else
                  _k.unicode = _k.pressed;

               // trace "xxx UI::force_us_unicode: pressed="+_k.pressed+" => unicode="+_k.unicode+" \'"+tcchar(_k.unicode)+"\'";
            }
         }
      }

      if(b_key_map_slash_to_less)
      {
         if(_k.code == VKEY_SLASH/*47*/)
            _k.code = VKEY_LESS/*60*/;
      }

      // trace "xxx 3 OnKeyboard: k.name="+_k.name+" k.code="+_k.code+" k.mod="+_k.mod+" _k.pressed="+_k.pressed;

      if(b_ui_debug)
      {
         trace "[trc] OnKeyboard keyboard_layer="+#(keyboard_layer)+" key="+_k.name+" pressed="+_k.pressed+" code="+_k.code+" ("+TKS.constantToString(_k.code, "VKEY_")+") mod="+_k.mod+" uni="+tcchar(_k.unicode);
      }

      if(VKEY_PRINT/*316*/ == _k.code)
      {
         if(_k.pressed)
         {
            if(_k.modNone())
            {
               if(null != root_layer)
                  root_layer.onCycleAppLookAndFeel();
               // else: lshift: take screenshot (windows)
            }
            else if(_k.modCtrl())
            {
               if(_k.modShift())
               {
                  SelectPreviousFBOColorGrading();
               }
               else
               {
                  SelectNextFBOColorGrading();
               }
            }
            else if(_k.modShift())
            {
               TogglePostFBOColorGrading();
            }
            else if(_k.modAlt())
            {
               if(null != root_layer)
                  root_layer.onScreenShot();
            }
         }
         return;
      }

      event_handle_starttime = SDL.ticks;

      if(b_keyboard_monitor)
         keyboard_monitor.addKey(_k);

      boolean bHandled = false;
      Layer *c;

      // Convert modifier key press/release to modifier bitmask
      switch(_k.pressed)
      {
         case VKEY_LCTRL:
            last_key_mod |= VMOD_LCTRL;
            break;

         // // case VKEY_RCTRL:
         // //    last_key_mod |= VMOD_RCTRL;
         // //    break;

         case VKEY_LSHIFT:
            last_key_mod |= VMOD_LSHIFT;
            break;

         case VKEY_LALT:
            last_key_mod |= VMOD_LALT;
            b_ignore_first_lalt_key = false;
            break;

         case VKEY_LMETA:
            last_key_mod |= VMOD_LMETA;
            break;

         case VKEY_MENU/*319*/:  // right Amiga key
            if(b_kbdfocus_selection_mode_behaviour_hold)
            {
               BeginKbdFocusSelectionMode();
            }
            else
            {
               ToggleKbdFocusSelectionMode();
            }
            return;

         case 1319: // right Amiga key (temp hold)
            BeginKbdFocusSelectionMode();
            return;
      }

      switch(_k.released)
      {
         case VKEY_LCTRL:
            last_key_mod &= ~VMOD_LCTRL;

            // End triad key mode after key repeat while lctrl is being held down ?
            if(b_triad_key_delayed_end)
            {
               if(keyboard_layer instanceof Layer)
               {
                  b_triad_key_delayed_end = false;
                  b_triad_key_mode = false;
                  keyboard_layer.onEndTriadKeyMode(triad_key_delayed_end_key);
               }
            }
            CancelTriadKeyTimer();
            b_triad_key_lctrl = false;

            if(b_triad_key_mode)
            {
               if(keyboard_layer instanceof Layer)
               {
                  // send LCTRL release (might not be handled in regular code path otherwise)
                  //  (note) fixes TrigSeq "stuck in step recording mode" issue (after lctrl-x)
                  RecursiveHandleKey(keyboard_layer, _k);
                  bHandled = true;
               }
            }
            break;

         case VKEY_LSHIFT:
            last_key_mod &= ~VMOD_LSHIFT;
            break;

         case VKEY_LALT:
            last_key_mod &= ~VMOD_LALT;
            break;

         case VKEY_LMETA:
            last_key_mod &= ~VMOD_LMETA;
            break;

         case 319: // right Amiga key
            if(b_kbdfocus_selection_mode_behaviour_hold)
            {
               EndKbdFocusSelectionMode();
            }
            return;

         case 1319: // right Amiga key (temp hold)
            EndKbdFocusSelectionMode();
            return;
      }

      // hack: Filter out LALT modifier after lalt-tab (SDL bug?)
      if(b_ignore_first_lalt_key)
      {
         _k.mod = _k.mod & ~VMOD_LALT;
      }

      // Try to delegate key event to kbdfocus selection mode
      if(b_kbdfocus_selection_mode)
      {
         HandleKbdFocusSelectionKey(_k);
         boolean bReturnOrSpace = (VKEY_RETURN == _k.pressed) || (VKEY_SPACE == _k.pressed);
         if(_k.pressed && !bReturnOrSpace)
         {
            StartOrContinueKeyRepeat(_k);
         }
         else
         {
            HandleKeyRepeatEnd(_k);
         }
         if(!bReturnOrSpace)
         {
            return;
         }
      }

      // Try to delegate key event to tooltip
      if(null != ToolTip.active_tooltip)
      {
         if(ToolTip.active_tooltip.onToolTipKey(_k))
            return;
      }

      // Try to delegate key event to layer under mouse
      if(mouse_layer instanceof Layer)
      {
         if(mouse_layer.onMouseKey(_k))
            return;
      }

      // Handle triad key wait release mode
      if(!bHandled)
      {
         if(b_triad_key_waitrelease)
         {
            // trace "xxx ui: triadkeydbg: waitrelease: _k.name="+_k.name+" released="+_k.released+" expect="+triad_key_pressed;
            if(_k.released == triad_key_pressed)
            {
               // trace "xxx ui: triadkeydbg: end triad key mode: keyboard_layer="+#(keyboard_layer);
               b_triad_key_mode = false;
               b_triad_key_waitrelease = false;

               // onEndTriadKeyMode()
               //  Note: if key handler has switched keyboardfocus, this will be received by a different layer
               c <= keyboard_layer;
               while(null != c)
               {
                  if(last_key_mod == VMOD_LCTRL)
                  {
                     if(c.wantTriadKeyRepeat(_k))
                     {
                        // don't leave mode, wait for next accelerator keypress
                        // trace "xxx ok, wantTriadKeyRepeat()==true, c="+#(c);
                        b_triad_key_mode = true;
                        triad_key_delayed_end_key = _k;
                        b_triad_key_delayed_end = true;
                        break;
                     }
                  }
                  if(c.onEndTriadKeyMode(_k))
                  {
                     break;
                  }
                  c <= c.parent;
               }

               b_triad_key_repeating = false;
               HandleKeyRepeatEnd(_k);

               // try to continue triad key mode as long as lctrl is pressed
               b_triad_key_try_repeat = _k.modCtrl();
            }

            bHandled = true;
         }
      }

      // trace "xxx ui: triadkeydbg: b_triad_key_mode="+b_triad_key_mode+" b_triad_key_lctrl="+b_triad_key_lctrl+" b_triad_key_waitrelease="+b_triad_key_waitrelease;

      if(!bHandled)
      {
         // Handle triad key mode (lctrl-x escape sequence)
         if(keyboard_layer instanceof Layer)
         {
            if(keyboard_layer.wantTriadKeyMode())
            {
               ////trace "xxx ui: triadkeydbg: b_triad_key_mode="+b_triad_key_mode+" _k.name="+_k.name+" b_triad_key_try_repeat="+b_triad_key_try_repeat;
               boolean bTriadKeyForceCancel = false;  // for lctrl-x x special case handling

               if(b_triad_key_mode)
               {
                  boolean bLeaveTriadMode = false;

                  if(b_triad_key_delayed_end)
                  {
                     c <= keyboard_layer;
                     bLeaveTriadMode = true;
                     do
                     {
                        if(c.wantTriadKeyRepeat(_k))
                        {
                           bLeaveTriadMode = false;
                           break;
                        }
                        c <= c.parent;
                     }
                     while(null != c)

                     // // if(!keyboard_layer.wantTriadKeyRepeat(_k))
                     // // {
                     // //    bLeaveTriadMode = true;
                     // // }
                  }

                  if(!bLeaveTriadMode)
                  {
                     if(_k.pressed > 1) // pressed so that unicode field is filled out and LCTRL release is filtered..
                     {
                        // // if(!([VKEY_LCTRL, VKEY_RCTRL, VKEY_LSHIFT, VKEY_RSHIFT, VKEY_LALT, VKEY_RALT, VKEY_LSUPER, VKEY_RSUPER].contains(_k.code)))
                        if(!([VKEY_LCTRL, VKEY_LSHIFT, VKEY_LALT, VKEY_LSUPER, VKEY_RSUPER].contains(_k.code)))
                        {
                           ////trace "xxx ui: triadkeydbg: key="+_k.name;
                           CancelTriadKeyTimer();
                           b_triad_key_waitrelease = true;
                           triad_key_pressed = _k.pressed;

                           // onTriadKey()
                           boolean bTriadKeyHandled = false;
                           c <= keyboard_layer;
                           while(null != c)
                           {
                              if(c.onTriadKey(_k))
                              {
                                 bTriadKeyHandled = true;

                                 if('x' == _k.code)
                                 {
                                    // Special case: lctrl-x x
                                    b_triad_key_repeating = false;
                                    // // b_triad_key_lctrl = false;
                                    b_triad_key_try_repeat = false;
                                    b_triad_key_mode = false;
                                    bTriadKeyForceCancel = true;
                                    b_triad_key_waitrelease = false;
                                    CancelTriadKeyTimer();
                                 }
                                 else
                                 {
                                    if(c.wantTriadKeyRepeat(_k))
                                    {
                                       b_triad_key_repeating = true;
                                       StartOrContinueKeyRepeat(_k);
                                    }
                                 }
                                 break;
                              }
                              c <= c.parent;
                           }

                           if(!bTriadKeyForceCancel)
                           {
                              b_triad_key_try_repeat = _k.modCtrl();
                              b_triad_key_lctrl = b_triad_key_try_repeat;
                              ////trace "xxx ui: triadkeydbg try_repeat="+b_triad_key_try_repeat;
                           }
                        }
                        else
                        {
                           // Filter modifier keys
                           bHandled = true;
                        }
                     }

                     bHandled = true;
                  }
                  else
                  {
                     b_triad_key_delayed_end = false;
                     b_triad_key_mode = false;
                     keyboard_layer.onEndTriadKeyMode(triad_key_delayed_end_key);
                  }
               }

               // trace "xxx ui: triadkeydbg b_triad_key_lctrl="+b_triad_key_lctrl+ "_k.name="+_k.name;

               if(_k.pressed == VKEY_LCTRL)
               {
                  b_triad_key_lctrl = true;
               }
               else if((_k.pressed == 'x') && !_k.modShift() && !bTriadKeyForceCancel)
               {
                  // trace "xxx ui: triadkeydbg x pressed, b_triad_key_lctrl="+b_triad_key_lctrl;
                  if(b_triad_key_lctrl)
                  {
                     if(null != keyboard_layer)
                     {
                        if(keyboard_layer.onKey(_k))
                        {
                           // Corner-case: Widget supports triad key mode but also may use lctrl-x itself
                           //  (e.g. a TextField, if there's a selection)
                           b_triad_key_mode = false;
                           b_triad_key_lctrl = false;
                           return true;
                        }
                     }

                     b_triad_key_mode = true;
                     b_triad_key_delayed_end = false;
                     c <= keyboard_layer;
                     while(null != c)
                     {
                        if(c.onBeginTriadKeyMode())
                           break;
                        c <= c.parent;
                     }
                     bHandled = true;
                     ScheduleTriadKeyTimer();
                  }
               }
               else if(_k.released == VKEY_LCTRL)
               {
                  /* ignore */
                  // // trace "xxx UI::triadkeymode: LCTRL released b_triad_key_try_repeat="+b_triad_key_try_repeat;
                  if(b_triad_key_try_repeat)
                  {
                     b_triad_key_try_repeat = false;
                     b_triad_key_mode = false;
                     CancelTriadKeyTimer();
                  }
                  b_triad_key_lctrl = false;
               }
            } // wantTriadKeyMode
            else
            {
               b_triad_key_mode = false; // always reset in case the keyboard focus has changed to a different layer
               b_triad_key_lctrl = false;
            }
         } // if keyboard_layer
         else
         {
            b_triad_key_mode = false; // always reset in case the keyboard focus has changed to none
            b_triad_key_lctrl = false;
         }
      } // if !handled


      if(!bHandled)
      {
         // Handle regular keypress/release
         if(keyboard_layer instanceof Layer)
         {
            // trace "xxx RecursiveHandleKey: try keyboard_layer="+#(keyboard_layer)+" _k.pressed="+_k.pressed+" _k.mod="+_k.mod+" _k.name="+_k.name;
            bHandled = RecursiveHandleKey(keyboard_layer, _k);
            // trace "xxx RecursiveHandleKey:   keyboard_layer="+#(keyboard_layer)+" bHandled="+bHandled+" _k.pressed="+_k.pressed;
         }
      }

      if(!bHandled)
      {
         // Handle accelerator lists
         if(_k.pressed)
         {
            ////trace "xxx UI::onKeyboard: unhandled key name=\""+_k.name+"\"";

            // Note: Since accelerator lists are currently only used by the "PopupMenu" class
            //       it is safe to simply deactivate the accelerators when a modal window
            //       is active.

            boolean bCheckAccels = true;
            if(active_floatinglayer instanceof FloatingLayer)
               bCheckAccels = ! (active_floatinglayer.isModal());

            if(bCheckAccels)
               bHandled = CheckAllAcceleratorLists(_k);
         }
      }

      if(!bHandled)
      {
         // trace "xxx ui: handle global key "+_k.name;
         // Call "global" root layer keyboard handler
         if(null != root_layer)
            bHandled = RecursiveHandleKey(root_layer, _k);
      }

      if(_k.released)
      {
         HandleKeyRepeatEnd(_k);
      }
      else
      {
         if(!bHandled)
         {
            if(VKEY_NUMLOCK != _k.code) // hack
               StartOrContinueKeyRepeat(_k); // 20Aug2014
         }
      }

      ////trace "xxx ui::OnKeyboard: key="+_k.name+" pressed"+_k.pressed+" klayer="+#(keyboard_layer)+" bHandled="+bHandled;
   }

   public static SetEnableLockKeyboardFocus(boolean _bLocked) : boolean {
      explain "Lock keyboard focus (careful here!!!)";
      return = b_lock_keyboard_focus;
      b_lock_keyboard_focus = _bLocked;
      return;
   }

   public static IsKeyboardFocusLocked() : boolean {
      return b_lock_keyboard_focus;
   }

   public static LoseKeyboardFocus() {
      explain "Set keyboard focus to none. Do not generate events.";

      if(!b_lock_keyboard_focus)
      {
         // trace "xxx UI::LoseKeyboardFocus: current="+#(keyboard_layer);

         previous_keyboard_layer <= keyboard_layer;
         keyboard_layer <= null;

         HandleKeyboardFocusChanged();
      }
   }

   public static LoseKeyboardFocusIfWithin(local Layer _l, boolean _bQuiet) {
      explain "Set keyboard focus to if it is currently set to _l or one of its child layers. Do not generate events.";

      if(!b_lock_keyboard_focus)
      {
         // trace "xxx LoseKeyboardFocusIfWithin="+#(_l)+" keyboard_layer="+#(keyboard_layer);

         if(null != keyboard_layer)
         {
            if(@(keyboard_layer) == @(_l))
            {
               keyboard_layer.onKeyboardFocusLost(_bQuiet);
               // trace "xxx LoseKeyboardFocusIfWithin: 1 unset keyboard_layer";
               keyboard_layer <= null;

               HandleKeyboardFocusChanged();
            }
            else
            {
               if(_l.hasChildLayer(keyboard_layer))
               {
                  keyboard_layer.onKeyboardFocusLost(_bQuiet);
                  // trace "xxx LoseKeyboardFocusIfWithin: 2 unset keyboard_layer";
                  // UI.Backtrace();
                  keyboard_layer <= null;

                  HandleKeyboardFocusChanged();
               }
            }
         }
      }
   }

   // ---- Query the current keyboard focus layer
   public static GetKeyboardFocus() : Layer {
      if(null != keyboard_layer && !(keyboard_layer instanceof Layer))
      {
         trace "[!!!] UI.GetKeyboardFocus: keyboard_layer is not a Layer";
         UI.Backtrace();
      }
      return keyboard_layer;
   }

   public static SetKeyboardFocusListener(KeyboardFocusListener _listener) {
      keyboard_focus_listener <= _listener;
   }

   module static HandleKeyboardFocusChanged() {
      // called when keyboard_layer has changed
      if(null != keyboard_focus_listener)
         keyboard_focus_listener.handleKeyboardFocusChanged(keyboard_layer);
   }

   // ---- Let a layer grab the keyboard focus
   public static SetKeyboardFocusEx(local Layer _l, boolean _bAllowMouseFocus) {
      if(0)
      {
         trace "xxx UI.SetKeyboardFocus to "+#(_l)+" current keyboard_layer="+#(keyboard_layer)+" previous="+#(previous_keyboard_layer)+" b_lock_keyboard_focus="+b_lock_keyboard_focus;
         Backtrace();
      }

      if(!b_lock_keyboard_focus)
      {
         if(@(_l) != @(keyboard_layer))
         {
            Layer oldKeyboardLayer <= keyboard_layer;

            if(oldKeyboardLayer instanceof Layer)
            {
               previous_keyboard_layer <= oldKeyboardLayer;
               oldKeyboardLayer.onKeyboardFocusLost(false/*bQuiet*/);
               CancelScheduleFor(keyRepeatConsumer);
            }

            // (note) onKeyboardFocusLost() may have changed keyboardfocus again
            keyboard_layer <= _l;

            if(_l instanceof Layer)
            {
               _l.onKeyboardFocus();

               if(b_touch_mode && _bAllowMouseFocus)
               {
                  // trace "xxx mouse_layer="+#(mouse_layer)+" l="+#(_l);
                  if(@(mouse_layer) != @(_l))
                  {
                     UI.SetMouseFocus(_l);
                  }
               }
            }

            HandleKeyboardFocusChanged();
         }
         else
         {
            previous_keyboard_layer <= keyboard_layer;
         }
      }
      // trace "xxx UI::SetKeyboardFocus: focus is now "+#(keyboard_layer);
   }

   // ---- Let a layer grab the keyboard focus
   public static SetKeyboardFocus(local Layer _l) {
      SetKeyboardFocusEx(_l, true/*bAllowMouseFocus*/);
   }

   public static SetKeyboardTabFocus(Layer _l) {
      if(!b_lock_keyboard_focus)
      {
         SetKeyboardFocus(_l);

         if(keyboard_layer instanceof Layer)
            keyboard_layer.onTabFocus();
      }
   }

   public static SetKeyboardFocusQuiet(Layer _l) {
      // Should only be used under very rare circumstances (e.g. NodeTrackerEnvelopeView triadic key handler)
      // trace "xxx SetKeyboardFocusQuiet: set keyboard_layer to l="+#(_l);
      keyboard_layer <= _l;
   }

   public static IsMouseFocusAllowed(Layer _l) : boolean {
      //
      // Determine whether it is allowed to focus the given layer _l.
      //  - Stop at first modal layer
      //  - Allow non-modal layers in front of the first modal layer..?!
      //
      int i = floating_layers.numElements -1;
      while(i >= 0)
      {
         Layer c <= floating_layers[i];
         if(c.isModal())
         {
            return (@(_l.getRoot()) == @(c)) || (@(_l) == @(c));
         }
         else if( (@(_l.getRoot()) == @(c))  || (@(_l) == @(c)) )
         {
            return true;
         }
         i--;
      }
      return true;
   }

   public static SetEnableFloatParamMouseGrab(boolean _bEnable) {
      b_floatparam_mouse_grab = _bEnable;
   }

   public static SetEnableSliderMouseGrab(boolean _bEnable) {
      b_slider_mouse_grab = _bEnable;
   }

   public static SetPreferredMouseLayer(Layer _l) {
      // Used by Window when mouse is near window border (resize)
      preferred_mouse_layer <= _l;
   }

   public static SetEnableLockMouseFocus(boolean _bLocked) {
      explain "Lock mouse focus (careful here!!!)";
      b_lock_mouse_focus = _bLocked;
   }

   public static StartMouseFocusWheelTimeOut() {
      // after ScrollPane wheel-scroll
      mouse_layer_lock_timeout_end_ticks = SDL.ticks + MOUSE_LAYER_LOCK_TIMEOUT_TICKS;
   }

   public static IsMouseFocusLocked() : boolean {
      return b_lock_mouse_focus || b_mouse_grab || (mouse_layer_lock_timeout_end_ticks > 0);//// || (null != drag_layer);
   }

   // ---- Let a layer grab the mouse focus
   public static SetMouseFocus(Layer _l) {
      // // // if(!IsMouseFocusLocked() && !b_mouse_grab)
      if(!IsMouseFocusLocked())
      {
         if(null != _l)
         {
            if(IsMouseFocusAllowed(_l))
            {
               ////trace "xxx SetMouseFocus: mouse_layer="+#(mouse_layer)+" _l="+#(_l);
               Point2f abspos;
               mouse_event.init(Mouse.x / UI.zoom_x,
                                Mouse.y / UI.zoom_y,
                                Mouse.buttons,
                                0
                                );
               MouseEvent *ev <= mouse_event;
               if(mouse_layer instanceof Layer)
               {
                  mouse_layer.calcAbsolutePosition(abspos);
                  ev.calcMouseRelv(abspos);
                  mouse_layer.onMouseLeave(ev);
               }
               if(_l instanceof Layer)
               {
                  if(@(_l) != @(mouse_layer))
                  {
                     // xxx Call onChildMouseEnter even if this is a synthetic event!??
                     mouse_layer <= _l;
                     _l.calcAbsolutePosition(abspos);
                     ev.calcMouseRelv(abspos);
                     _l.onMouseEnter(ev);
                  }
               }
               else
               {
                  mouse_layer <= null;
               }
            }
         }
         else
         {
            mouse_layer <= null;
         }
      }
   }

   public static GetMouseFocus() : Layer {
      return mouse_layer;
   }

   public static LoseMouseFocusIfWithin(local Layer _l) {
      explain "Set mouse focus to null if it is currently set to _l or one of its child layers. Do not generate events.";

      // // if(!IsMouseFocusLocked() && !b_mouse_grab)
      if(!IsMouseFocusLocked())
      {
         // trace "xxx LoseMouseFocusIfWithin="+#(_l)+" mouse_layer="+#(mouse_layer);
         local MouseEvent dummyEv;

         if(null != mouse_layer)
         {
            if(@(mouse_layer) == @(_l))
            {
               mouse_layer.onMouseLeave(dummyEv);
               mouse_layer <= null;
            }
            else
            {
               if(_l.hasChildLayer(mouse_layer))
               {
                  mouse_layer.onMouseLeave(dummyEv);
                  mouse_layer <= null;
               }
            }
         }

         if(null != mousefocus_layer)
         {
            if(@(mousefocus_layer) == @(_l))
            {
               mousefocus_layer <= null;
            }
            else
            {
               if(_l.hasChildLayer(mousefocus_layer))
               {
                  mousefocus_layer.onMouseLeave(dummyEv);
                  mousefocus_layer <= null;
               }
            }
         }
      }
   }

   public static UnsetMouseFocus(MouseEvent _ev) {
      explain "Make the current mouse layer lose the focus. Generates onMouseLeave event.";

      // // if(!IsMouseFocusLocked() && !b_mouse_grab)
      if(!IsMouseFocusLocked())
      {
         if(mouse_layer instanceof Layer)
         {
            Point2f abspos;
            mouse_layer.calcAbsolutePosition(abspos);
            _ev.calcMouseRelv(abspos);
            mouse_layer.onMouseLeave(_ev);
            mouse_layer <= null;
         }
      }
   }

   public static RecursiveHandleKey(Layer c, Key _k) : boolean {
      boolean bHandled = false;
      boolean bAllowRepeat = b_allow_keyrepeat;
      boolean bIsRoot = @(c) == @(root_layer);

      if(bAllowRepeat)
      {
         // do not repeat modifier keys (shift/ctrl/alt..)
         bAllowRepeat =
            // //(27 != _k.code) &&
            ( (1 < _k.code < 256) || repeating_special_keys.contains(_k.code) );
      }

      while(c instanceof Layer)
      {
         if(bIsRoot ||  (@(root_layer) != @(c))) // handle root layer last
         {
            // trace "xxx UI: call c.OnKey, c="+#(c)+" k="+_k.name+" _k.pressed="+_k.pressed;

            boolean bKeyRepeat = bAllowRepeat;
            if(bKeyRepeat)
            {
               // Note: layer may have been destroyed when onKey() returns so query for
               //       keyrepeat before calling the keyboard handler
               bKeyRepeat = c.wantKeyRepeat(_k);
               // trace "xxx _k.name="+_k.name+" _k.code="+_k.code+" bKeyRepeat="+bKeyRepeat;
            }

            // trace "xxx k.code="+_k.code+" bAllowRepeat="+bAllowRepeat+" bKeyRepeat="+bKeyRepeat;
            // trace "xxx UI::c.onKey: c="+#(c)+" k="+_k.name;

            if(c.onKey(_k))
            {
               // (note) 'c' may have been deleted by now
               if(_k.pressed > 1)
               {
                  if(bKeyRepeat)
                  {
                     // // trace "xxx UI::RecursiveHandleKey: keyboard_layer.wantKeyRepeat(_k="+_k.name+")="+keyboard_layer.wantKeyRepeat(_k);
                     // trace "xxx UI::RecursiveHandleKey: keyboard_layer="+#(keyboard_layer);
                     StartOrContinueKeyRepeat(_k);
                  }
                  else
                  {
                     StopKeyRepeat(_k);
                  }
               }

               bHandled = true;
               ////trace "xxx UI::RecursiveHandleKey: bHandled=true k="+_k.name;
               c <= null;
            }
            else
            {
               // Keyboard layer did not consume the keyboard. Back-propagate to parent layer
               // trace "xxx    RecursiveHandleKey: try c="+#(c)+" c.parent="+#(c.parent);
               if(bIsRoot && _k.pressed)
               {
                  // trace "xxx root StopKeyRepeat";
                  CancelKeyRepeat(); // [18Feb2025]
               }
               c <= c.parent;
            }
         }
         else
         {
            // Skip root layer (always handled last)
            c <= null;
         }
      }

      return bHandled;
   }

   // ----
   // ---- Rendering
   // ----
   define int PAINT_NONE     = 0b0000;
   define int PAINT_DIRTY    = 0b0001;
   define int PAINT_ALL      = 0b1111;

   define int MAX_DIRTY_AND_DEFERRED_REGIONS = 256;
   explain "Maximum number of dirty regions for optimized drawing. If this number is exceeded, all layers will be redrawn.
   also: Maximum number of regions that may request redraw() during redraw().";

   protected static int     global_paint_flag = PAINT_DIRTY; // default is to only paint "dirty" layers
   public    static int     current_paint_flag; // reset to PAINT_NONE after each render pass
   public    static int     next_paint_flag; // reset to global_paint_flag before each render pass
   public    static boolean b_sweep_dirty;  // (todo) [16Oct2018] looks like this can be remove_window (always false)
   protected static int     redraw_all_count;
   protected static boolean b_repainting;
   protected static boolean b_draw_overlays; // true=currently repainting overlays => use windowcoords for scissor rect
   protected static boolean b_draw_overlays_post;  // true=currently repainting overlays to post_fbo (don't zoom)
   protected static boolean b_hide_all_overlays;

   define int REDRAW_DIRTY     = 0;  // default (redraw/composite when necessary)
   // workarounds for Intel Macs??:
   define int REDRAW_COMPOSITE = 1;  // expensive, composite screen at 60 or even 120 fps
   define int REDRAW_ALL       = 2;  // very expensive, redraw entire screen at 60 or even 120 fps
   protected static int     global_redraw_mode;
   protected static int     global_redraw_num_frames;   // "timeout" (#frames) after mouse/key event. 0=unlimited, -1=off
   protected static int     global_redraw_frames_left;  //


   // List of rectangluar screen areas that need to be redrawn
   //  (note) we cannot keep references to Layers since they might have been deleted
   //         between redraw() and OnDraw()..
   public static Rectangle2f dirty_regions[];

   // List of regions that were requested to be repainted during onDraw()
   public static Rectangle2f deferred_regions[];

   // true=don't queue any layers for redraw or redrawAll() or compositeAll()
   public static boolean b_lock_redraw;

   public static Function *ondraw_post_process_hook;

   public static SetOnDrawPostProcessHook(Function _fun) {
      ondraw_post_process_hook <= _fun;
   }

   private static boolean     b_mark_region = false;
   private static Rectangle2f marked_region;
   private static boolean     b_last_marked_region_valid;
   private static Rectangle2f last_marked_region;
   private static float       marked_region_border_size;

   public static BeginMarkRegion(Rectangle2f _region, float _bs) {
      b_mark_region              = true;
      b_last_marked_region_valid = false;
      marked_region              = _region;
      marked_region_border_size  = _bs;
   }

   public static UpdateMarkedRegion(Rectangle2f _region) {
      marked_region = _region;
   }

   public static EndMarkRegion() {
      b_mark_region = false;
      CompositeAll();
   }

   // // public static AddDirtyRegion(Rectangle2f _r) {
   // //    trace "xxx add dirty region r="+_r.getString();
   // //    if(_r.qx > _r.px) // filter empty regions at startup (redraw() before layout)
   // //    {
   // //       if(!b_transparent_layers)
   // //       {
   // //          dirty_regions.add(_r);
   // //          next_paint_flag |= UI.PAINT_DIRTY;
   // //          Viewport.needRedraw();
   // //       }
   // //       else
   // //       {
   // //          RedrawAll();
   // //       }
   // //    }
   // // }

   // public static AddDeferredRegion(Rectangle2f _r) {
   //    if(!b_transparent_layers)
   //    {
   //       deferred_regions.add(_r);
   //       next_paint_flag |= UI.PAINT_DIRTY;
   //       Viewport.needRedraw();
   //    }
   //    else
   //    {
   //       CompositeAll();
   //    }
   // }

   public static SetGlobalPaintFlag(int _mode) {
      global_paint_flag = _mode;
   }

   public static SetGlobalRedrawMode(int _mode, int _numFrames) {
      global_redraw_mode       = _mode;
      global_redraw_num_frames = _numFrames;
      trace "[dbg] UI.SetGlobalRedrawMode(mode="+_mode+" timeout="+global_redraw_num_frames+")";
   }

   public static RedrawDirty(Layer _l) {
      // Add dirty region

      if(!b_lock_redraw)
      {
         ////trace "xxx UI::RedrawDirty l="+#(_l);

         if(_l.size_x > 0) // filter layers that have not been layouted, yet
         {
            if(b_fbo || !b_transparent_layers)
            {
               boolean bAddDirty = (PAINT_ALL != next_paint_flag);

               if(!b_fbo)
               {
                  // If layer is a modal and non-resizable floatinglayer then do not repaint regions beneath that layer
                  FloatingLayer *fl <= _l.getRoot();
                  if(fl instanceof FloatingLayer)
                  {
                     bAddDirty = false;//!fl.isMovable(); // || fl.isResizable();
                  }

                  if(b_shade_modal)
                  {
                     FloatingLayer *win;
                     foreach win in floating_layers
                     {
                        if(win.isFloatingLayerVisible())
                        {
                           if(win.isModal())
                           {
                              bAddDirty = false;
                              break;
                           }
                        }
                     }
                  }
               }

               if(bAddDirty)
               {
                  ////trace "xxx UI::AddDirty: next_paint_flag="+next_paint_flag;
                  if(dirty_regions.numElements < MAX_DIRTY_AND_DEFERRED_REGIONS)
                  {
                     Rectangle2f r <= _l.getScreenRegion();
                     ////trace "xxx redraw dirty region r="+r.getString();
                     if(b_repainting)
                     {
                        deferred_regions.add(r); // Add a copy of the layer region
                     }
                     else
                     {
                        dirty_regions.add(r); // Add a copy of the layer region
                     }
                     ////trace "xxx UI::RedrawDirty: dirty_regions.numElements"+dirty_regions.numElements;
                     next_paint_flag |= PAINT_DIRTY;
                  }
                  else
                  {
                     // Debug("UI: #dirty > MAXDIRTY, "+(dirty_regions.numElements)+" > "+MAX_DIRTY_AND_DEFERRED_REGIONS);
                     next_paint_flag = PAINT_ALL;
                  }
               }
               else
               {
                  if(GetNumFloatingLayers() > 0)
                  {
                     // (potentially) repainting layer behind window(s)
                     // note: commenting out the following causes glitches if shade_modal is enabled
                     CompositeAll();
                  }
               }

               Viewport.needRedraw();
            }
            else
            {
               _l.paint_flag = PAINT_NONE;
               // xxx use dirty regions
               RedrawAll();
            }
         }
      }
   }

   public static LockRedraw() {
      explain "Disable UI redraws";
      b_lock_redraw = true;
   }

   public static UnlockRedraw() {
      explain "Re-enable UI redraws";
      b_lock_redraw = false;
   }

   public static RedrawAll() {
      explain "Redraw the entire screen";
      // trace "xxx UI::RedrawAll";

      if(!b_lock_redraw)
      {
         next_paint_flag = PAINT_ALL;
         Viewport.needRedraw();
      }
   }

   public static CompositeAll() {
      // trace "xxx UI::CompositeAll";
      if(!b_lock_redraw)
      {
         if(b_fbo)
         {
            Viewport.needRedraw();
         }
         else
         {
            RedrawAll();
         }
      }
   }

   module static OnClose() {
      // (todo) recursively call onClose
      trace "[dbg] UI::OnClose called";
   }

   module static OnOpen() {
      if(Configuration.debugLevel >= 2)
         Debug("UI::OnOpen");

      RevertCursor();

      UIRenderer.OnOpen();

      // // // (note) not updating the buffer_width/height immediately
      // // //         causes wrong clipping in viewpanes (in first draw call after resize)
      // // viewport_width  = Viewport.width / zoom_x;
      // // viewport_height = Viewport.height / zoom_y;
      // // buffer_width = viewport_width;
      // // buffer_height = viewport_height;

      DestroyAllShaders();

      if(null != root_layer)
         root_layer.recursiveOnOpen();
      RootLayerResized();
      font_cache.onOpen();
      icon_cache.onOpen();

      String *shaderClass;
      foreach shaderClass in shaders
      {
         Shader shader <= shaders[shaderClass];
         shader.onOpen();
      }

      SDL.enableUNICODE(true);

      if(b_fbo)
      {
         root_fbo.destroyContextLost();
         root_fbo.create(viewport_width, viewport_height, supersample_factor);

         if(b_draw_post_fbo)
         {
            if(null != tex_post_fbo_color_grading)
               tex_post_fbo_color_grading.unload();
            post_fbo.destroyContextLost();
            post_fbo.create(viewport_width, viewport_height, 1);
         }
      }

      Layer *fl;
      foreach fl in floating_layers
      {
         fl.recursiveOnOpen(); // also calls fbo.destroyContextLost()
      }

      Debug("UI::OnOpen: root layer resized to ("+viewport_width+"; "+viewport_height+")");
   }

   module static DrawMarkedRegion() {
      UIRenderer.DrawXORRectangle(marked_region.qx, marked_region.qy,
                                  marked_region.px-marked_region.qx, marked_region.py-marked_region.qy,
                                  marked_region_border_size
                                  );
   }


   static int dbg_composite_count;

   static int frame_counter;

   public static SetEnableHideAllOverlays(boolean _bEnabled) {
      b_hide_all_overlays = _bEnabled;
   }

   public static CreateColorGradingTexture256x16(String _localPathname) : Texture {
      local Texture tex;
      local Texture tmp;
      tmp.loadLocalImage(_localPathname, 0,0,4);
      tex.alloc(16, 16*16, 4);
      tex.target = GL_TEXTURE_3D;
      tex.sz = 16;  // number of depth slices
      tex.flags = TEX_CLAMPTOEDGE_S | TEX_CLAMPTOEDGE_T | TEX_MINFILTERLINEAR | TEX_MAGFILTERTRILINEAR;
      // Copy horizontal slice to vertical slices for tex3d
      int dy = 0;
      int qx = 0;
      loop(16)
      {
         tex.copyRegion(tmp, tmp.sx - 256 + qx, tmp.sy - 16, 16, 16, 0, dy);
         dy += 16;
         qx += 16;
      }
      return deref tex;
   }

   namespace static Texture *tex_default_fbo_color_grading;
   namespace static Texture *tex_post_fbo_color_grading;

   namespace static int c32_forced_textcolor;
   public static boolean b_skip_bevel_border;

   public static StringArray  post_fbo_color_grading_texture_cycle_list;
   protected static int       post_fbo_color_grading_texture_cycle_list_idx;
   protected static String    post_fbo_color_grading_texture_cycle_list_directory;
   protected static Function *post_fbo_color_grading_cycle_cbk;
   protected static int       post_fbo_color_grading_texture_cycle_list_idx_queued_cbk = -1;
   public static    float     post_fbo_color_grading_amount = 1.0f;

   public static SetDefaultFBOColorGrading256x16FromLocalFile(String _localPathname) {
      tex_default_fbo_color_grading <= CreateColorGradingTexture256x16(_localPathname);
   }

   public static SetPostFBOColorGrading256x16FromLocalFile(String _localPathname) {
      if(null != _localPathname)
      {
         tex_post_fbo_color_grading <= CreateColorGradingTexture256x16(_localPathname);
         if(null != tex_post_fbo_color_grading)
         {
            trace "[dbg] UI: enable post FBO color grading, lut=\""+_localPathname+"\"";
            UI.b_draw_post_fbo = true;
         }
      }
   }

   public static SetPostFBOColorGradingCycleList(StringArray _gradientPathNames, String _dir) {
      post_fbo_color_grading_texture_cycle_list = _gradientPathNames;
      post_fbo_color_grading_texture_cycle_list_directory = _dir;
   }

   public static SetPostFBOColorGrading256x16ByCycleIdx(int _idx) {
      post_fbo_color_grading_texture_cycle_list_idx = _idx;
      if(0 <= _idx < (post_fbo_color_grading_texture_cycle_list.numElements-1))
      {
         SetPostFBOColorGrading256x16FromLocalFile(post_fbo_color_grading_texture_cycle_list_directory + "/" + post_fbo_color_grading_texture_cycle_list.get(post_fbo_color_grading_texture_cycle_list_idx));

         if(null != root_layer)
         {
            if(null == post_fbo)
            {
               post_fbo <= new FBO;
               post_fbo.autoEnableFilter();
               post_fbo.create(viewport_width, viewport_height, 1/*supersampleFactor*/);
            }
         }

         if(1)
         {
            if(null != post_fbo_color_grading_cycle_cbk)
               post_fbo_color_grading_cycle_cbk.eval([_idx]);
         }
         else
         {
            // Postpone callback until first frame is rendered (OnDraw())
            post_fbo_color_grading_texture_cycle_list_idx_queued_cbk = _idx;
         }

         if(null != root_layer)
            CompositeAll();
      }
   }

   public static SelectNextFBOColorGrading() {
      if(post_fbo_color_grading_texture_cycle_list.numElements > 0)
      {
         post_fbo_color_grading_texture_cycle_list_idx = mathWrapi(post_fbo_color_grading_texture_cycle_list_idx + 1, 0, post_fbo_color_grading_texture_cycle_list.numElements-1);
         SetPostFBOColorGrading256x16ByCycleIdx(post_fbo_color_grading_texture_cycle_list_idx);
      }
   }

   public static SelectPreviousFBOColorGrading() {
      if(post_fbo_color_grading_texture_cycle_list.numElements > 0)
      {
         post_fbo_color_grading_texture_cycle_list_idx = mathWrapi(post_fbo_color_grading_texture_cycle_list_idx - 1, 0, post_fbo_color_grading_texture_cycle_list.numElements-1);
         SetPostFBOColorGrading256x16ByCycleIdx(post_fbo_color_grading_texture_cycle_list_idx);
      }
   }

   public static SetPostFBOColorGradingCycleCbk(Function _f) {
      post_fbo_color_grading_cycle_cbk <= _f;
   }

   public static TogglePostFBOColorGrading() {
      if(null != tex_post_fbo_color_grading)
      {
         b_draw_post_fbo = !b_draw_post_fbo;

         if(b_draw_post_fbo)
         {
            post_fbo <= new FBO;
            post_fbo.autoEnableFilter();
            post_fbo.create(viewport_width, viewport_height, 1/*supersampleFactor*/);
         }

         CompositeAll();
         trace "[dbg] UI::TogglePostFBOColorGrading: b_draw_post_fbo="+b_draw_post_fbo;
      }
      else
      {
         trace "[~~~] UI::TogglePostFBOColorGrading: no texture set";
      }
   }

   public static SetPostFBOColorGradingAmount(float _f) {
      post_fbo_color_grading_amount = _f;
   }

   public static SetForcedTextColor32(int _c32) {
      // Can be useful for inverted color gradings to improve text readability
      c32_forced_textcolor = _c32;
   }

   public static OnDraw() {
      // trace "xxx onDraw: -------------------- focus mouse="+#(mouse_layer)+" keyboard="+#(keyboard_layer);

      zglEnableGLCore(UIRenderer.b_glcore);

      event_handle_starttime = SDL.ticks;

      ProcessTimers(true/*bOnDraw*/);

      b_repainting = true;
      b_draw_overlays = false;
      b_draw_overlays_post = false;

      if(-1 != post_fbo_color_grading_texture_cycle_list_idx_queued_cbk)
      {
         if(null != post_fbo_color_grading_cycle_cbk)
            post_fbo_color_grading_cycle_cbk.eval([post_fbo_color_grading_texture_cycle_list_idx_queued_cbk]);
         post_fbo_color_grading_texture_cycle_list_idx_queued_cbk = -1;
      }

      // // glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
      // // glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
      // // glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
      // // glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

      glDisable(GL_STENCIL_TEST);
      UIRenderer.DisableTexture2D();
      if(!UIRenderer.b_glcore)
         glDisable(GL_ALPHA_TEST);  // b_glcore
      glDisable(GL_DEPTH_TEST);
      UIRenderer.DisableBlending();
      sdvg_DisableScissor();

      if(!UIRenderer.b_glcore)
         glDrawBuffer(GL_BACK);  // !b_glcore

      buffer_width  = viewport_width;
      buffer_height = viewport_height;
      // trace "xxx ondraw: vp=("+buffer_width+";"+buffer_height+")";

      sdvg_SetFramebufferSize(buffer_width * zoom_x, buffer_height * zoom_y);
      // trace "xxx SetFramebufferSize(sx="+(buffer_width * zoom_x)+" sy="+(buffer_height * zoom_y)+")";

      // // ResetScissors();

      UIRenderer.BeginFrame();

      UIRenderer.SetViewport(0, 0, viewport_width, viewport_height);
      sdvg_SetScissor(0, 0, viewport_width, viewport_height);

      if(!b_fbo)
      {
         UIRenderer.ProjInit2D(viewport_width, viewport_height);
         // // glLoadIdentity();
      }

      sdvg_DisableBlending();

      if(0 && !b_benchmark_done)
      {
         b_benchmark_done = true;
         int benchIter = 4000;
         int tGL;
         int tSDVG;

         tGL = milliSeconds();
         loop(benchIter)
         {
            UIRenderer.DrawFilledRectangle(10, 10, 100, 20, #ff00ff00);
         }
         tGL = milliSeconds() - tGL;

         tSDVG = milliSeconds();
         loop(benchIter)
         {
            sdvg_SetFillColorARGB(#ff00ff00);
            sdvg_DrawFilledRectangle(10, 10, 100, 20);
            sdvg_ReturnToGL();
         }
         tSDVG = milliSeconds() - tSDVG;

         trace "xxx benchmark: tGL="+tGL+" tSDVG="+tSDVG;
      }

      ////trace "xxx UI::onDraw b_mark_region="+b_mark_region;

      if(!b_fbo && b_mark_region)
      {
         // Only update XOR marker
         if(b_last_marked_region_valid)
         {
            // Undo last frame marker
            UIRenderer.DrawXORRectangle(last_marked_region.qx, last_marked_region.qy,
                                        last_marked_region.px-last_marked_region.qx, last_marked_region.py-last_marked_region.qy,
                                        marked_region_border_size
                                        );
         }
         ////trace "xxx UI: draw marked region qx="+marked_region.qx+" qy="+marked_region.qy;
         DrawMarkedRegion();
         last_marked_region = marked_region;
         b_last_marked_region_valid = true;
      }
      else
      {
         /////trace "xxx ui.OnDraw: dirty="+dirty_regions.numElements+" def'rd="+deferred_regions.numElements;

         current_paint_flag = next_paint_flag;
         next_paint_flag = global_paint_flag;

         ///*xxx*/ current_paint_flag = PAINT_ALL;

         boolean bForceRedraw = (PAINT_ALL == current_paint_flag);
         if(bForceRedraw)
         {
            // trace "xxx bForceRedraw: redraw_all_count="+redraw_all_count;
            if( ((++redraw_all_count)&31) == 0)
            {
               if(!b_benchmark)
                  Debug("UI::RedrawAll: #"+redraw_all_count);
            }
         }
         // trace "xxx UI: bForceRedraw="+bForceRedraw;

         FloatingLayer *fl;

         b_sweep_dirty = false; // old code used to handle transparent regions

         if(b_fbo)
            root_fbo.beginPaint();

         if(bForceRedraw && b_clear_bg)
         {
            // Draw root layer background
            int windowBg32 = lnf_colors.get(LookAndFeel.COLOR_WINDOW_BG);
            // // glClearColor(((windowBg32>>16)&255)/255.0,
            // //              ((windowBg32>> 8)&255)/255.0,
            // //              ((windowBg32    )&255)/255.0,
            // //              ((windowBg32>>24)&255)/255.0
            // //              );
            // // glClear(GL_COLOR_BUFFER_BIT/*|GL_DEPTH_BUFFER_BIT*/);
            sdvg_ClearARGB(windowBg32);
         }

         if( bForceRedraw || ( (current_paint_flag & PAINT_DIRTY) && (dirty_regions.numElements > 0) ) )
         {
            if(null != root_layer)
               root_layer.drawHierarchy(bForceRedraw, false/*bCheckIntersect*/,
                                        0/*viewOffX*/, 0/*viewOffY*/,
                                        viewport_width, viewport_height
                                        );

            if(b_fbo)
               root_fbo.endPaint();

            // Draw floating layers
            ////trace "xxx -------------- Draw floating layers";
            ////trace "xxx bforceredraw="+bForceRedraw;
            foreach fl in floating_layers
            {
               if(fl instanceof FloatingLayer) // xxx 25Mar2017: temporary workaround to prevent deleted object crash (NodeMonitor)
               {
                  // trace "xxx UI::drawfloatinglayer: fl="+#(fl);

                  if(b_fbo)
                     fl.beginPaint();

                  ////trace "xxx UI drawFloatingLayer fl="+#(fl);

                  if(!b_fbo)
                  {
                     if(b_shade_modal && bForceRedraw)
                     {
                        ////trace "xxx fl="+#(fl)+" ml="+#(mouse_layer);
                        fl.drawShadeModal();
                     }
                  }

                  // (note) remove this, blending is enabled when background is drawn
                  // // if(b_transparent_layers)
                  // // {
                  // //    glEnable(GL_BLEND);
                  // //    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
                  // // }

                  fl.drawHierarchy(bForceRedraw, true/*bCheckIntersect*/,
                                   -fl.getPositionX()/*viewShiftX*/, -fl.getPositionY()/*viewShiftY*/,
                                   fl.getSizeX(), fl.getSizeY()
                                   );

                  // (note) remove this, blending might already be disabled, anyway
                  // // if(b_transparent_layers)
                  // // {
                  // //    glDisable(GL_BLEND);
                  // // }

                  if(b_fbo)
                     fl.endPaint();
               }
               else
               {
                  trace "[~~~] UI: fl@"+@(fl)+" is not a FloatingLayer!!!";
               }
            }
            /////trace "-------------- **END** Draw floating layers";
         }
         else
         {
            if(b_fbo)
               root_fbo.endPaint();
         }


         // Debug: print list of dirty rectangles
         if(0)
         {
            trace "[dbg] ----------------------------------------------------";
            Rectangle2f *r;
            int ri = 0;
            foreach r in dirty_regions
            {
               trace "[dbg] ["+ri+"]: ("+r.qx+"; "+r.qy+") ("+r.px+"; "+r.py+")";
               ri++;
            }
         }

         if(b_fbo)
         {
            // Composite layers
            // trace "xxx UI::OnDraw: composite layers "+dbg_composite_count+++" postFBO="+b_draw_post_fbo;

            if(b_draw_post_fbo)
            {
               post_fbo.setColorGradingTexture(tex_post_fbo_color_grading);
               post_fbo.beginPaint();
               // // ResetScissors();
               sdvg_SetScissor(0, 0,
                               buffer_width  * UI.supersample_factor,
                               buffer_height * UI.supersample_factor
                               );
            }
            else
            {
               // // glViewport(0, 0, viewport_width * zoom_x, viewport_height * zoom_y);
               // // zglInit2D(viewport_width, viewport_height);
               // // glLoadIdentity();
               // // ResetScissorsZoom();
               UIRenderer.SetViewport(0, 0,
                                      viewport_width  * zoom_x,  // * UI.supersample_factor???
                                      viewport_height * zoom_y
                                      );
               sdvg_SetScissor(0, 0,
                               buffer_width  * zoom_x * UI.supersample_factor,
                               buffer_height * zoom_y * UI.supersample_factor
                               );
               UIRenderer.ProjInit2D(viewport_width, viewport_height);
               UIRenderer.ModelInitIdentity();

               if(!UIRenderer.b_glcore)
                  glDrawBuffer(GL_BACK);  // !b_glcore
            }

            UIRenderer.EnableTexture2D();

            // Blit root layer
            if(b_draw_root_fbo)
            {
               root_fbo.composite(0, 0,
                                  0, 0,
                                  viewport_width, viewport_height
                                  );
            }

            // Draw overlays
            if(!b_hide_all_overlays)
            {
               b_draw_overlays = true;
               b_draw_overlays_post = b_draw_post_fbo;

               UIRenderer.DisableTexture2D();

               if(null != root_layer)
                  root_layer.handleDrawOverlays();

               UIRenderer.EnableTexture2D();
            }

            if(b_transparent_layers)
               UIRenderer.EnableBlending();

            // Blit windows
            foreach fl in floating_layers
            {
               fl.composite();
               UIRenderer.DisableTexture2D();
               fl.handleDrawOverlays();
               UIRenderer.EnableTexture2D();
            }

            UIRenderer.DisableTexture2D();

            if(b_transparent_layers)
               UIRenderer.DisableBlending();

            // Show XOR marker
            if(b_mark_region)
               DrawMarkedRegion();

            if(b_draw_post_fbo)
            {
               post_fbo.endPaint();

               UIRenderer.EnableTexture2D();

               // // glViewport(0, 0, viewport_width * zoom_x, viewport_height * zoom_y);
               // // zglInit2D(viewport_width, viewport_height);
               // // glLoadIdentity();
               UIRenderer.SetViewport(0, 0, viewport_width * zoom_x, viewport_height * zoom_y);
               UIRenderer.ProjInit2D(viewport_width, viewport_height);
               UIRenderer.ModelInitIdentity();

               if(!UIRenderer.b_glcore)
                  glDrawBuffer(GL_BACK);  // !b_glcore

               glDisable(GL_BLEND);

               post_fbo.composite(0, 0,
                                  0, 0,
                                  viewport_width, viewport_height
                                  );

               UIRenderer.DisableTexture2D();
            }

            // trace "xxx UI::repaint";
            if(global_redraw_frames_left >= 0)
            {
               boolean bMayRedraw = (0 == global_redraw_num_frames) || (global_redraw_frames_left > 0);
               if(global_redraw_frames_left > 0)
                  global_redraw_frames_left--;

               if(bMayRedraw)
               {
                  if(Configuration.debugLevel > 10)
                     Debug("UI::OnDraw: global_redraw_mode="+global_redraw_mode+" frames_left="+global_redraw_frames_left);

                  if(REDRAW_COMPOSITE == global_redraw_mode)
                     CompositeAll();
                  else if(REDRAW_ALL == global_redraw_mode)
                     RedrawAll();
               }
            }
         }

         // Empty current dirty_regions array and exchange for deferred regions
         //trace "[...] finished redrawing "+dirty_regions.numElements+" dirty regions. (time="+milliSeconds()+")";
         dirty_regions.empty();
         Rectangle2f t <= deref dirty_regions;
         dirty_regions <= deref deferred_regions;
         deferred_regions <= deref t;
      }

      b_repainting = false;

      // Keyboard focus selection mode?
      if(b_kbdfocus_selection_mode)
         DrawKbdFocusSelection();

      if(b_keyboard_monitor)
      {
         keyboard_monitor.pushParentViewPaneScissors();
         keyboard_monitor.onDrawOverlays();
         keyboard_monitor.popParentViewPaneScissors();
      }

      if(ondraw_post_process_hook instanceof Function)
         ondraw_post_process_hook.eval(null/*args*/);

      UIRenderer.EndFrame();

      frame_counter++;
   }

   // ---- Query the current root layer
   public static GetRootLayer() : Layer {
      return root_layer;
   }

   // ---- Set the current root layer
   public static SetRootLayer(Layer _newRootLayer) {
      if(_newRootLayer instanceof Layer)
      {
         root_layer <= deref _newRootLayer;
         if(0 != Viewport.depth) // has the Viewport already been openend?
            LayoutRootLayer();
         HandleLookAndFeelChanged(); // Update colors
      }
      else
      {
         trace "[---] UI::SetRootLayer: _newRootLayer is not an instanceof Layer.\n";
      }
   }

   // ---- Set the current root form
   public static SetRootForm(Form _newRootForm) {
      if(_newRootForm instanceof Form)
      {
         root_layer <= deref _newRootForm;

         _newRootForm.onInitForm(); // initialize the form

         if(Viewport.depth > 0) // has the Viewport already been openend?
         {
            LayoutRootLayer(); // layout root layer
         }
         HandleLookAndFeelChanged(); // Update colors
      }
      else
      {
         trace "[---] UI::SetRootLayer: _newRootLayer is not an instanceof Layer.\n";
      }
   }

   public static AddOverlay(Layer _l) {
      if(null != root_layer)
         root_layer.addOverlay(_l);
   }

   public static RemoveOverlay(Layer _l) {
      if(null != root_layer)
         root_layer.removeOverlay(_l);
   }

   namespace static HashTable shaders;

   public static RegisterShaderClass(Shader _class) {
      Debug("UI::RegisterShaderClass: name=\""+_class.yacMetaClassName()+"\"");
      Shader shader <= Object(_class);
      shaders[_class.yacMetaClassName()] = deref shader;
   }

   public static UnregisterShaderClass(Shader _class) {
      if(shaders.exists(_class.yacMetaClassName()))
         shaders.delete(_class.yacMetaClassName());
   }

   public static DestroyAllShaders() {
      String *name;
      foreach name in shaders
      {
         Shader shader <= shaders[name];
         shader.destroy();
      }
   }

   public static UnregisterAllShaders() {
      DestroyAllShaders();
      shaders.free();
   }

   public static GetShaderByName(String _name) : Shader {
      return shaders.get(_name);
   }

   public static GetShader(Shader _class) : Shader {
      return shaders.get(_class.yacMetaClassName());
   }

   public static SetEnableHeadless(boolean _bEnable) {
      // call before Initialize()
      b_headless = _bEnable;
      b_fbo      = false;
   }

   public static ConfigureMultisampling(int _numSamples, int _numBuffers) {
      // call before Initialize()
      multisample_samples = _numSamples;
      multisample_buffers = _numBuffers;
   }

   public static ConfigureSupersampling(int _numSamples) {
      supersample_factor = mathClampi(_numSamples, 1, 4);
   }

   public static ConfigureHiDPI() {
      // utility function. must be called before Initialize()
      UI.SetFontScaling(2.0);
      UI.SetTextViewFontScaling(1.0);
      UI.SetEnableTextViewHiDPIFont(true);
      UI.SetEnableFontSmoothing(true);
      UI.SetIconScaling(2.0);
      UI.SetPadScaling(2.0);
      UI.SetWindowBorderScaling(2.0);
      UI.SetTableMinimumColumnWidthScaling(0.68);
   }

   public static ConfigureScaling(float _s) {
      _s = mathClampf(_s, 1.0f, 4.0f);
      // utility function. must be called before Initialize() (and after ConfigureHiDPI())
      UI.SetFontScaling(_s);
      UI.SetIconScaling(_s);
      UI.SetPadScaling(_s);
      UI.SetWindowBorderScaling(_s);
   }

   public static ConfigureGL(boolean _bGLCore, boolean _bDrawGL) {
      UIRenderer.b_glcore  = _bGLCore;
      UIRenderer.b_draw_gl = _bDrawGL;

      if(_bGLCore)
         putenv("TKSDL_GLCORE=1");
   }

   public static Initialize(StringArray _arguments) {
      Debug("UI::Initialize()");

      b_force_high_framerate = false;
      SetFrameRate(30, 60);

      UIRenderer.Init();

      // Set default look and feel theme and create color caches
      lnf_preset_light.initLookAndFeel();
      lnf_preset_dark .initLookAndFeel();
      lnf_preset_mono .initLookAndFeel();

      SetLookAndFeel(LookAndFeel.LIGHT);
      // SetLookAndFeel(LookAndFeel.DARK);
      // SetLookAndFeel(LookAndFeel.MONO);

      SDL.enableUNICODE(true);
      // ---- SDL keyrepeat needs to be turned off
      // // SDL.enableKeyRepeat(500, 30);
      SDL.enableKeyRepeat(0, 0);
      b_allow_keyrepeat = true;

      icon_cache.init(300);

      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/fixed.ttf", "fixed", Font.STYLE_NORMAL, UIConstants.FIXED_FONTRESOURCE_SIZE));
      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/fixed.ttf", "fixed", Font.STYLE_NORMAL, UIConstants.FIXED_FONTRESOURCE_SIZE2));
      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/default.ttf", "default", Font.STYLE_NORMAL, UIConstants.DEFAULT_FONTRESOURCE_SIZE1));
      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/default-bold.ttf", "default", Font.STYLE_BOLD, UIConstants.DEFAULT_FONTRESOURCE_SIZE1));
      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/default.ttf", "default", Font.STYLE_NORMAL, UIConstants.DEFAULT_FONTRESOURCE_SIZE2));
      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/default.ttf", "default", Font.STYLE_BOLD, UIConstants.DEFAULT_FONTRESOURCE_SIZE1BOLD));
      // // AddFontResource(FT2PakFileFontResource.New("fonts/default-bold.ttf", "default", Font.STYLE_BOLD, UIConstants.DEFAULT_FONTRESOURCE_SIZE1BOLD));
      // // AddFontResource(FT2PakFileFontResource.New("fonts/default-italic.ttf", "default", Font.STYLE_ITALIC, UIConstants.DEFAULT_FONTRESOURCE_SIZE1ITALIC));
      AddFontResource(FT2PakFileFontResource.NewUnscaled("tkui:fonts/default.ttf", "default_unscaled", Font.STYLE_NORMAL, UIConstants.DEFAULT_FONTRESOURCE_SIZE1));
      AddFontResource(FT2PakFileFontResource.NewUnscaled("tkui:fonts/default.ttf", "default_unscaled", Font.STYLE_NORMAL, UIConstants.DEFAULT_FONTRESOURCE_SIZE_HIDPI_WINDOWTITLE));
      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/default.ttf", "default", Font.STYLE_NORMAL, UIConstants.DEFAULT_FONTRESOURCE_SMALL_HIDPI));
      AddFontResource(FT2PakFileFontResource.New("tkui:fonts/default.ttf", "default", Font.STYLE_NORMAL, UIConstants.DEFAULT_FONTRESOURCE_SMALL_LODPI));

      // // AddFontAlias("default", "fixed");
      AddFontAlias("default bold 11", "bold");

      AddIcon(PNGIcon.NewMono("arr_u",      "tkui:icons/arr_u.png"));
      AddIcon(PNGIcon.NewMono("arr_r",      "tkui:icons/arr_r.png"));
      AddIcon(PNGIcon.New    ("arr_r_inv",  "tkui:icons/arr_r_inv.png"));  // popupmenufolderbutton
      AddIcon(PNGIcon.NewMono("arr_d",      "tkui:icons/arr_d.png"));
      AddIcon(PNGIcon.NewMono("arr_l",      "tkui:icons/arr_l.png"));

      AddIcon(PNGIcon.NewMono("arr2x_u",      "tkui:icons/arr2x_u.png"));
      AddIcon(PNGIcon.NewMono("arr2x_r",      "tkui:icons/arr2x_r.png"));
      AddIcon(PNGIcon.NewMono("arr2x_r_inv",  "tkui:icons/arr2x_r_inv.png"));
      AddIcon(PNGIcon.NewMono("arr2x_d",      "tkui:icons/arr2x_d.png"));
      AddIcon(PNGIcon.NewMono("arr2x_l",      "tkui:icons/arr2x_l.png"));

      AddIcon(PNGIcon.New("chb_0",      "tkui:icons/chb_0.png"));
      AddIcon(PNGIcon.New("chb_0_1",    "tkui:icons/chb_0_1.png"));
      AddIcon(PNGIcon.New("chb_1",      "tkui:icons/chb_1.png"));
      AddIcon(PNGIcon.New("chb_1_0" ,   "tkui:icons/chb_1_0.png"));
      AddIcon(PNGIcon.New("chb_2",      "tkui:icons/chb_2.png"));
      AddIcon(PNGIcon.New("chb_2_0" ,   "tkui:icons/chb_2_0.png"));

      AddIcon(PNGIcon.New("chb_0_dark",      "tkui:icons/chb_0_dark.png"));
      AddIcon(PNGIcon.New("chb_0_1_dark",    "tkui:icons/chb_0_1_dark.png"));
      AddIcon(PNGIcon.New("chb_1_dark",      "tkui:icons/chb_1_dark.png"));
      AddIcon(PNGIcon.New("chb_1_0_dark" ,   "tkui:icons/chb_1_0_dark.png"));
      AddIcon(PNGIcon.New("chb_2_dark",      "tkui:icons/chb_2_dark.png"));
      AddIcon(PNGIcon.New("chb_2_0_dark" ,   "tkui:icons/chb_2_0_dark.png"));

      AddIcon(PNGIcon.New("chb2x_0",      "tkui:icons/chb2x_0.png"));
      AddIcon(PNGIcon.New("chb2x_0_1",    "tkui:icons/chb2x_0_1.png"));
      AddIcon(PNGIcon.New("chb2x_1",      "tkui:icons/chb2x_1.png"));
      AddIcon(PNGIcon.New("chb2x_1_0" ,   "tkui:icons/chb2x_1_0.png"));
      AddIcon(PNGIcon.New("chb2x_2",      "tkui:icons/chb2x_2.png"));
      AddIcon(PNGIcon.New("chb2x_2_0" ,   "tkui:icons/chb2x_2_0.png"));

      AddIcon(PNGIcon.New("chb2x_0_dark",      "tkui:icons/chb2x_0_dark.png"));
      AddIcon(PNGIcon.New("chb2x_0_1_dark",    "tkui:icons/chb2x_0_1_dark.png"));
      AddIcon(PNGIcon.New("chb2x_1_dark",      "tkui:icons/chb2x_1_dark.png"));
      AddIcon(PNGIcon.New("chb2x_1_0_dark" ,   "tkui:icons/chb2x_1_0_dark.png"));
      AddIcon(PNGIcon.New("chb2x_2_dark",      "tkui:icons/chb2x_2_dark.png"));
      AddIcon(PNGIcon.New("chb2x_2_0_dark" ,   "tkui:icons/chb2x_2_0_dark.png"));

      AddIcon(PNGIcon.New("rab_0",      "tkui:icons/rab_0.png"));
      AddIcon(PNGIcon.New("rab_0_1",    "tkui:icons/rab_0_1.png"));
      AddIcon(PNGIcon.New("rab_1",      "tkui:icons/rab_1.png"));
      AddIcon(PNGIcon.New("rab_1_0" ,   "tkui:icons/rab_1_0.png"));

      AddIcon(PNGIcon.New("rab2x_0",      "tkui:icons/rab2x_0.png"));
      AddIcon(PNGIcon.New("rab2x_0_1",    "tkui:icons/rab2x_0_1.png"));
      AddIcon(PNGIcon.New("rab2x_1",      "tkui:icons/rab2x_1.png"));
      AddIcon(PNGIcon.New("rab2x_1_0" ,   "tkui:icons/rab2x_1_0.png"));

      AddIcon(PNGIcon.New("penguin",    "tkui:icons/futurosoft/penguin.png"));
      AddIcon(PNGIcon.New("error",      "tkui:icons/error.png"));
      AddIcon(PNGIcon.New("success",    "tkui:icons/success.png"));
      AddIcon(PNGIcon.New("idea",       "tkui:icons/idea.png"));
      AddIcon(PNGIcon.New("info",       "tkui:icons/info.png"));
      AddIcon(PNGIcon.New("info_mono",  "tkui:icons/info_mono.png"));
      AddIcon(PNGIcon.New("test",       "tkui:icons/futurosoft/test.png"));
      AddIcon(PNGIcon.New("textinput",  "tkui:icons/textinput.png"));
      AddIcon(PNGIcon.New("choice",     "tkui:icons/choice.png"));
      AddIcon(PNGIcon.New("dockbtn",    "tkui:icons/dockbtn.png"));
      AddIcon(PNGIcon.New("dockbtndn",  "tkui:icons/dockbtndn.png"));
      AddIcon(PNGIcon.New("windock",    "tkui:icons/windock.png"));
      AddIcon(PNGIcon.New("treeopen",   "tkui:icons/treeopen.png"));
      AddIcon(PNGIcon.New("treeopenfat","tkui:icons/treeopenfat.png"));
      AddIcon(PNGIcon.New("treeclosed", "tkui:icons/treeclosed.png"));
      AddIcon(PNGIcon.New("treeclosedfat", "tkui:icons/treeclosedfat.png"));
      AddIcon(PNGIcon.New("treeleaf",   "tkui:icons/treeleaf.png"));
      AddIcon(PNGIcon.New("treeopenempty",   "tkui:icons/treeopenempty.png"));
      AddIcon(PNGIcon.New("treeclosedempty", "tkui:icons/treeclosedempty.png"));
      AddIcon(PNGIcon.New("treespacer", "tkui:icons/treespacer.png"));

      // (note) post-pone cursor shape init until Run() (i.e. when cursorZoom has been configured by the app)
      // // CreateCursors();

      RegisterShaderClass(Shader_ColorGrading);
      RegisterShaderClass(Shader_InvertColor);
      RegisterShaderClass(Shader_SharpenFilter);
      RegisterShaderClass(Shader_SharpenFilterAndColorGrading);
      RegisterShaderClass(Shader_PatternFill);
      RegisterShaderClass(Shader_GradientV);
      RegisterShaderClass(Shader_GradientH);
      RegisterShaderClass(Shader_GradientR);
      RegisterShaderClass(Shader_PatternGradientV);
      RegisterShaderClass(Shader_PatternGradientH);
      RegisterShaderClass(Shader_PatternGradientR);

      dirty_regions.alloc(MAX_DIRTY_AND_DEFERRED_REGIONS);
      deferred_regions.alloc(MAX_DIRTY_AND_DEFERRED_REGIONS);

      key_repeat_delay_frames = UIConstants.KEY_REPEAT_DELAY_FRAMES;
      key_repeat_rate_frames  = UIConstants.KEY_REPEAT_RATE_FRAMES; // vsync'd key repeat

      key_repeat_delay = UIConstants.KEY_REPEAT_DELAY;
      key_repeat_rate  = UIConstants.KEY_REPEAT_RATE;

      mouse_layer_lock_timeout_end_ticks = -1;

      mousehold_timerAction.setActionName("mousehold");
   }

   public static Exit() {
      FreeCursors();
      cursor_none <= null;

      UIRenderer.Exit();
   }

   static private Cursor *cursor_none;
   static private Cursor *current_cursor;
   static private String current_cursor_name;

   public static AddCursor(String _name, Cursor _cursor) {
      explain "Add a cursor resource";
      cursor_cache[_name] = deref _cursor;
   }

   public static FreeCursors() {
      current_cursor <= null;
      current_cursor_name = "";
      cursor_cache.free();
   }

   public static CreateCursors() {
      if(b_ui_debug) trace "[dbg] UI::CreateCursors: cursor_zoom="+SDL.cursorZoom;
      AddCursor(UIConstants.CURSOR_NORMAL   , CursorShapes.GetNormal()     );
      AddCursor(UIConstants.CURSOR_MOVE     , CursorShapes.GetMove()       );
      AddCursor(UIConstants.CURSOR_MOVEX    , CursorShapes.GetMoveX()      );
      AddCursor(UIConstants.CURSOR_MOVEY    , CursorShapes.GetMoveY()      );
      AddCursor(UIConstants.CURSOR_MOVEXYD  , CursorShapes.GetMoveXYDown() );
      AddCursor(UIConstants.CURSOR_MOVEXYU  , CursorShapes.GetMoveXYUp()   );
      AddCursor(UIConstants.CURSOR_TYPE     , CursorShapes.GetType()       );
      AddCursor(UIConstants.CURSOR_DENIED   , CursorShapes.GetDenied()     );
      AddCursor(UIConstants.CURSOR_GRAB     , CursorShapes.GetGrab()       );
      AddCursor(UIConstants.CURSOR_GRABBED  , CursorShapes.GetGrab3()      );
      AddCursor(UIConstants.CURSOR_SPLITX   , CursorShapes.GetSplitX()     );
      AddCursor(UIConstants.CURSOR_SPLITY   , CursorShapes.GetSplitY()     );
      AddCursor(UIConstants.CURSOR_ADD      , CursorShapes.GetAdd()        );
      AddCursor(UIConstants.CURSOR_PENCIL   , CursorShapes.GetPencil()     );
      AddCursor(UIConstants.CURSOR_NOPENCIL , CursorShapes.GetNoPencil()   );
   }

   public static UpdateCursors() {
      // during init, after screen mode change, and/or after cursor zoom has changed
      ShowCursor(UIConstants.CURSOR_NONE);
      ShowCursor(UIConstants.CURSOR_NONE); // force update
      FreeCursors();
      CreateCursors();
      ShowCursor(UIConstants.CURSOR_MOVE); // force update
      ShowCursor(UIConstants.CURSOR_NORMAL);
   }

   public static ShowCursor(String _name) : boolean {
      explain "Select named cursor shape";

      if(UIConstants.CURSOR_NONE == _name)
      {
         if(null == cursor_none)
            cursor_none <= CursorShapes.GetNone();
         cursor_none.show();
         current_cursor_name = "";
         return true;
      }

      if(b_skip_cursor)
         return true;

      //trace "xxx ShowCursor(\""+_name+"\")";

      if(_name != current_cursor_name)
      {
         Cursor csr <= cursor_cache.get(_name);
         if(null != csr)
         {
            current_cursor <= csr;
            current_cursor_name = _name;
            // trace "xxx ShowCursor: csr="+#(csr);
            return csr.show();
         }
         else
         {
            trace "[---] UI::ShowCursor: unknown cursor \"" + _name +"\".";
         }
      }
      else
      {
         return true;
      }
      return false;
   }

   public static RevertCursor() {

      if(b_skip_cursor)
         return;

      if(null != current_cursor)
      {
         current_cursor.revert();
         current_cursor <= null;
         current_cursor_name.empty();
      }
   }

   public static ShowCursorIf(String _lastName, String _newName) : boolean {
      // trace "xxx ShowCursorIf(lastName=\""+_lastName+"\" currentName=\""+current_cursor_name+"\" newName=\""+_newName+"\")";
      if(_lastName == current_cursor_name)
      {
         return ShowCursor(_newName);
      }
      return false;
   }

   public static ShowCursorIfNot(String _lastName, String _newName) : boolean {
      ////trace "xxx ShowCursorIfNot(lastName=\""+_lastName+"\" currentName=\""+current_cursor_name+"\" newName=\""+_newName+"\")";
      if(_lastName != current_cursor_name)
      {
         return ShowCursor(_newName);
      }
      return false;
   }

   // ---- Add a new font resource
   public static AddFontResource(FontResource _fr) : boolean {
      return font_cache.addFontResource(deref _fr);
   }

   // ---- Adds an alias for the given font name
   public static AddFontAlias(String _fontName, _aliasFontName) {
      font_cache.addFontAlias(_fontName, _aliasFontName);
   }

   // ---- Get a font by String, e.g. "fixed 12", "default italic 15"
   public static GetFontByNameEx(String _fontName_extendedStyleFlags_desiredSize, boolean _bExactSizeMatch) : Font {
      // trace "xxx UI::GetFontByName: name=\""+_fontName_extendedStyleFlags_desiredSize+"\"";
      ////trace "UI.GetFontByName("+_fontName_extendedStyleFlags_desiredSize+")";
      return font_cache.getFontByName(_fontName_extendedStyleFlags_desiredSize, _bExactSizeMatch);
   }

   // ---- Get a font by String, e.g. "fixed 12", "default italic 15"
   public static GetFontByName(String _fontName_extendedStyleFlags_desiredSize) : Font {
      // trace "xxx UI::GetFontByName: name=\""+_fontName_extendedStyleFlags_desiredSize+"\"";
      ////trace "UI.GetFontByName("+_fontName_extendedStyleFlags_desiredSize+")";
      return font_cache.getFontByName(_fontName_extendedStyleFlags_desiredSize, false/*bExactSizeMatch*/);
   }


   // ----
   // ---- Common Dialog support
   // ----

   public static PathNameToURL(String _s) : String {
      // macOS file dialog expects URL-like pathname strings (e.g. for initial directory)
      if(null != _s)
      {
         local String r;
         r = _s;
         r.replace(" ", "%20");
         return deref r;
      }
      return null;
   }

   public static OpenFileDialog(
      String _suggestedPath,  // initial directory
      String _suggestedFile,  // suggested file name
      String _windowTitle,    // caption of the (modal) dialog window
      Object _filterNames,    // array object which holds the filter names, e.g. ["C-Files", "Script-Files", "Images"]
      Object _filterStrings,  // array object which holds the filter patterns , e.g. ["*.c", "*.tks", "*.png"]
      boolean _bMultiSel,     // enable multiple selection
      boolean _bDirsOnly      // only select directories
   )  {
      explain "Show a file dialog which lets the user select one or many files / directories. The dialogs are currently handled by a simple native OS toolkit wrapper (GTK+ or Win32).

 @return null or single String, or StringArray (if multiple selection is enabled
";
      if(IsMacOS())
      {
         // // _suggestedPath <= PathNameToURL(_suggestedPath);  // " " => "%20"
         // // _suggestedFile <= PathNameToURL(_suggestedFile);

         if(null != _suggestedPath)
         {
            if(null != _suggestedFile)
               _suggestedPath <= PathNameToURL(_suggestedPath+"/"+_suggestedFile);  // " " => "%20"
         }
         else
         {
            if(null != _suggestedFile)
               _suggestedPath <= PathNameToURL(_suggestedFile);  // " " => "%20"
         }
         _suggestedFile <= PathNameToURL(_suggestedFile);
      }

      Object r <= TKUI_OpenFileDialog(_suggestedPath,
                                      _suggestedFile,
                                      _windowTitle,
                                      _filterNames,
                                      _filterStrings,
                                      _bMultiSel,
                                      _bDirsOnly
                                      );


      // (note) on macOS (13.2) the returned file name(s) do _not_ contain URL-like "%20" escape sequences
      //         (unlike the suggestedPath input arg)

      return deref r;
   }

   public static SaveFileDialog(
      String _suggestedPath,  // initial directory
      String _suggestedFile,  // suggested file name
      String _windowTitle,    // caption of the (modal) dialog window
      Object _filterNames,    // array object which holds the filter names, e.g. ["C++-Files", "Script-Files", "Images"]
      Object _filterStrings,  // array object which holds the filter patterns , e.g. ["*.cpp", "*.tks", "*.png"]
      boolean _bDirsOnly      // only select directories
                                  ) : String {
      explain "Show a file dialog which lets the user select one or many files / directories. The dialogs are currently handled by a simple native OS toolkit wrapper (GTK+ or Win32).";

      String r <= TKUI_SaveFileDialog(_suggestedPath,
                                      _suggestedFile,
                                      _windowTitle,
                                      _filterNames,
                                      _filterStrings,
                                      _bDirsOnly
                                      );
      return deref r;
   }

   // ----
   // ---- Timer support
   // ----
   protected static List timers; // chronologically ordered list of scheduled TimerActions
   protected static List timers_ondraw; // chronologically ordered list of scheduled TimerActions

   static DebugPrintTimerList(List timerList) {
      ListNode *t;
      ListNode c <= timerList.head;
      int timerIdx = 0;
      while(null != c)
      {
         TimerAction ta <= c.objectValue;
         int ct = ta.getTicks();
         trace "xxx UI::DebugPrintTimerList: timer["+timerIdx+"] c="+#(c)+" ta="+#(ta)+" name="+ta.name+" ticks="+ct+" ta.consumer="+#(ta.getActionConsumer());
         c <= c.next;
         timerIdx++;
      }
   }

   static DebugPrintTimers() {
      DebugPrintTimerList(timers);
   }

   module =uitimer= static ProcessTimers(boolean _bOnDraw) {
      // trace "xxx UI.ProcessTimers";
      int st;
      List *timerList;

      if(_bOnDraw)
      {
         st = frame_counter;
         timerList <= timers_ondraw;
         if(null != timerList.head)
         {
            Viewport.needRedraw();
         }
         // trace "xxx ProcessTimers:: frame_counter st="+st;
      }
      else
      {
         st = SDL.ticks;
         timerList <= timers;
      }

      // trace "xxx process timers list:";
      // DebugPrintTimerList(timerList);

      // ---- Process timer queue
      for(;;)
      {
         ListNode *t, c <= timerList.head;
         if(null == c)
            return;

         TimerAction *ta;
         while(null != c)
         {
            ta <= c.objectValue;
            if(ta instanceof TimerAction)
            {
               int ct = ta.getTicks();
               // trace "xxx UI::ProcessTimers: pending timer ta.name="+ta.name+" ct="+ct+" st="+st;
               // if(_bOnDraw)
               //    trace "xxx c="+#(c)+" ct="+ct+" st="+st;
               ////trace "xxx ta="+#(ta)+" ct="+ct+" st="+st;
               if(ct <= st)
               {
                  ta <= c.derefObjectValue();
                  timerList.remove(c);
                  // trace "xxx UI::ProcessTimers: timer<"+ta.name+"> expired. ta.ticks="+ct+" curTicks="+st;//+" ta="+#(ta);
                  TKS.unlockNamedMutex("uitimer"); // prevent potential deadlock (e.g. "=replay=" in st)
                  ta.onTimerExpired();
                  TKS.lockNamedMutex("uitimer");
                  break;
               }
               else
               {
                  return;
               }
            }
            else
            {
               // Should not be reachable
               trace "[!!!] UI::ProcessTimers: ta="+#(ta)+" is not a TimerAction. removing node c="+#(c)+" from timerList";
               timerList.remove(c);
               break;
            }
         } // while c
      }
   }

   // Process pending TimerActions
   // static int xxxTimerCount = 0;
   public static OnTimer() {
      // trace "xxx UI::OnTimer "+(xxxTimerCount++);
      event_handle_starttime = SDL.ticks;  // for vsync keyrepeat mode

      ProcessTimers(false/*bOnDraw*/);

      if(mouse_layer_lock_timeout_end_ticks > 0)
      {
         if(event_handle_starttime > mouse_layer_lock_timeout_end_ticks)
         {
            // End mousewheel lock timeout (e.g. ScrollPane wheel-scroll)
            mouse_layer_lock_timeout_end_ticks = -1;
         }
      }
   }

   // ---- Insert TimerAction in timers list, sort by time
   public =uitimer= static Schedule(TimerAction _ta) {
      // trace "xxx UI::Schedule: ta="+#(_ta);
      // UI.Backtrace();
      if(_ta instanceof TimerAction)
      {
         if(_ta.getActionName().isBlank())
         {
            trace "[~~~] UI::Schedule: ta.name=\""+_ta.getActionName()+"\" ta.consumer="+#(_ta.getActionConsumer());
            UI.Backtrace();
         }
         // trace "xxx UI::Schedule: ta.b_ondraw="+_ta.b_ondraw;
         List *timerList;

         if(_ta.b_ondraw)
            timerList <= timers_ondraw;
         else
            timerList <= timers;

         int et = _ta.getTicks();
         ListNode c <= timerList.head;
         ListNode l <= null;
         TimerAction *ta;

         while(null != c)
         {
            ta <= c.objectValue;
            int ct = ta.getTicks();
            if(ct > et)
               break;
            l <= c;
            c <= c.next;
         }

         if(null != l)
            timerList.insert(#(deref _ta), l);
         else
            timerList.addFirst(#(deref _ta));

         // trace "xxx UI::Schedule: timer ta="+#(ta)+" ta.name=\""+_ta.name+"\" ticks="+_ta.getTicks()+" scheduled. l="+#(l);
      }
      else
      {
         trace "[---] ui::Schedule: ta="+#(_ta)+" is not a valid TimerAction object.";
      }
   }


   protected static CancelSchedule2(List _timerList, TimerAction _ta) {
      if(null != _ta)
      {
         ListNode *t, *c <= _timerList.head;
         TimerAction *ta;
         while(null != c)
         {
            ta <= c.objectValue;
            if(@(ta)==@(_ta))
            {
               t <= c;
               c <= c.next;
               //trace "xxx UI::CancelSchedule: removing ta="+ta.name;
               _timerList.remove(t);
               return true;
            }
            else
            {
               c <= c.next;
            }
         }
      }
   }

   // ---- Remove a specific TimerAction
   public =uitimer= static CancelSchedule(TimerAction _ta) : boolean {
      explain "Cancel the given timeraction. Return true if a matching timer was found, false otherwise.";

      if(_ta.b_ondraw)
         CancelSchedule2(timers_ondraw, _ta);
      else
         CancelSchedule2(timers, _ta);

      return false;
   }

   protected static CancelScheduleFor2(List _timerList, ActionConsumer _aac) {
      ListNode *t, *c <= _timerList.head;
      TimerAction *ta;
      while(null != c)
      {
         ta <= c.objectValue;
         // trace "xxx UI.CancelScheduleFor2: try c="+#(c)+" ta="+#(ta)+" aac="+#(_aac);
         if((null != ta) && @(ta.getActionConsumer()) == @(_aac))
         {
            t <= c;
            c <= c.next;
            _timerList.remove(t);
         }
         else
         {
            c <= c.next;
         }
      }
   }

   // ---- Remove all TimerActions for the given ActionConsumer
   public =uitimer= static CancelScheduleFor(ActionConsumer _aac) {
      // trace "xxx UI::CancelScheduleFor(aac="+#(_aac)+")";
      CancelScheduleFor2(timers, _aac);
      CancelScheduleFor2(timers_ondraw, _aac);
      // trace "xxx UI::CancelScheduleFor(aac="+#(_aac)+") new timerlist:";
      // DebugPrintTimers();
   }

   // ----
   // ---- Clipboard support
   // ----
   public static SetClipboard(Object _o) {
      // trace "xxx UI.SetClipboard o="+#(_o);
      SDL_SetClipboard(_o);
   }

   public static GetClipboard() {
      return SDL_GetClipboard();
   }


   // ----
   // ---- Icon support
   // ----
   public static AddIcon(Icon _icon) {
      icon_cache.addIcon(deref _icon);
   }

   public static GetIcon(String _name) : Icon {
      return icon_cache.getIcon(_name);
   }

   // ----
   // ---- GL clipping
   // ----

   public static SetViewport(int x, y, w, h) {
      if(b_fbo)
      {
         // // glViewport(x*UI.supersample_factor,
         // //            (buffer_height-y-h)*UI.supersample_factor,
         // //            w*UI.supersample_factor,
         // //            h*UI.supersample_factor
         // //            );
         UIRenderer.SetViewport(x*UI.supersample_factor,
                                y*UI.supersample_factor,
                                w*UI.supersample_factor,
                                h*UI.supersample_factor
                                );
      }
      else
      {
         // // glViewport(x * zoom_x,
         // //            (buffer_height-y-h) * zoom_y,
         // //            w * zoom_x,
         // //            h * zoom_y
         // //            );
         UIRenderer.SetViewport(x * zoom_x,
                                y * zoom_y,
                                w * zoom_x,
                                h * zoom_y
                                );
      }
   }

   public static SetZoom(float _zoomX, float _zoomY) {
      explain "Set overall UI zoom level. Must be called before opening the window/screen.";

      zoom_x = _zoomX;
      zoom_y = _zoomY;
   }

   public static SetCursorZoom(int _zoom) {
      if(b_ui_debug) trace "[dbg] UI::SetCursorZoom("+_zoom+")";
      SDL.cursorZoom = mathClampi(_zoom, 1, 8);
   }

   public static SetFontScaling(float _zoom) {
      if(b_ui_debug) trace "[dbg] UI::SetFontScaling: zoom="+_zoom;
      font_scaling = mathClampf(_zoom, 1.0, 16.0);
   }

   public static GetFontScaling() : float {
      return font_scaling;
   }

   public static SetEnableFontSmoothing(boolean _bEnable) {
      b_font_smoothing = _bEnable;
   }

   public static GetEnableFontSmoothing() : boolean {
      return b_font_smoothing;
   }

   public static IsHiDPI() : boolean {
      return (font_scaling >= 1.2);
   }

   public static IsLoDPI() : boolean {
      return (font_scaling < 1.2);
   }

   public static SetTextViewFontScaling(float _zoom) {
      if(b_ui_debug) trace "[dbg] UI::SetTextViewFontScaling: zoom="+_zoom;
      textview_font_scaling = mathClampf(_zoom, 1.0, 16.0);
   }

   public static SetEnableTextViewHiDPIFont(boolean _bEnable) {
      b_textview_hidpi_font = _bEnable;
   }

   public static SetIconScaling(float _zoom) {
      icon_scaling = mathClampf(_zoom, 1.0, 16.0);
   }

   public static GetIconScaling() : float {
      return icon_scaling;
   }

   public static SetPadScaling(float _zoom) {
      pad_scaling = mathClampf(_zoom, 1.0, 16.0);
   }

   public static GetPadScaling() : float {
      return pad_scaling;
   }

   public static SetWindowBorderScaling(float _s) {
      window_border_scaling = mathClampf(_s, 0.0, 16.0);
   }

   public static GetWindowBorderScaling() : float {
      return window_border_scaling;
   }

   public static SetTableMinimumColumnWidthScaling(float _s) {
      table_min_col_width_scaling = _s;
   }

   // public static InitScissors() {
   //    scissors_stacki = SCISSORS_STACK_SIZE;
   //    scissors_stack.alloc(4 * SCISSORS_STACK_SIZE);
   //    scissors_stack.numElements = scissors_stack.maxElements;
   // }

   // public static ResetScissors() {
   //    // Called at the beginning of a frame in case a crash occured (in the last frame) before PopScissors() could be called
   //    scissors_stacki = SCISSORS_STACK_SIZE;
   //    scissors_x = 0;
   //    scissors_y = 0;
   //    scissors_w = buffer_width;
   //    scissors_h = buffer_height;
   //    glScissor(0, 0, scissors_w*UI.supersample_factor, scissors_h*UI.supersample_factor);
   // }

   // public static ResetScissorsZoom() {
   //    // Called before drawing the overlays
   //    scissors_stacki = SCISSORS_STACK_SIZE;
   //    scissors_x = 0;
   //    scissors_y = 0;
   //    scissors_w = buffer_width * zoom_x*UI.supersample_factor;
   //    scissors_h = buffer_height * zoom_y*UI.supersample_factor;
   //    glScissor(0, 0, scissors_w, scissors_h);
   // }

   // public static PushScissors(int _x, _y, _w, _h) {

   //    // trace "xxx UI::PushScissors: cur=("+scissors_x+";"+scissors_y+";"+scissors_w+";"+scissors_h+") new=("+_x+";"+_y+";"+_w+";"+_h+") buffer_height="+buffer_height;

   //    if((!b_fbo || b_draw_overlays) && !b_draw_overlays_post)
   //    {
   //       // trace "xxx UI::PushScissors: apply zoom=("+zoom_x+";"+zoom_y+")";
   //       _x *= zoom_x;
   //       _y *= zoom_y;
   //       _w *= zoom_x;
   //       _h *= zoom_y;

   //       _y = (buffer_height * zoom_y - _y) - _h;
   //    }
   //    else
   //    {
   //       _y = (buffer_height - _y) - _h;
   //    }

   //    scissors_stack[--scissors_stacki] = scissors_h;
   //    scissors_stack[--scissors_stacki] = scissors_w;
   //    scissors_stack[--scissors_stacki] = scissors_y;
   //    scissors_stack[--scissors_stacki] = scissors_x;

   //    if(_x < 0)
   //    {
   //       _w += _x;
   //       _x = 0;
   //    }
   //    if(_y < 0)
   //    {
   //       _h += _y;
   //       _y = 0;
   //    }

   //    // (note) FBO might be larger than viewport
   //    // // if(_w > Viewport.width)
   //    // //    _w = Viewport.width;
   //    // // if(_h > Viewport.height)
   //    // //    _h = Viewport.height;

   //    if(scissors_w > 0)
   //    {
   //       if(_x < scissors_x)
   //          _w -= (scissors_x - _x);
   //       if(_y < scissors_y)
   //          _h -= (scissors_y - _y);
   //       // ---- intersect with last scissors region
   //       if(_x > scissors_x)
   //       {
   //          scissors_w -= (_x - scissors_x);
   //          scissors_x = _x;
   //       }
   //       if(_y > scissors_y)
   //       {
   //          scissors_h -= (_y - scissors_y);
   //          scissors_y = _y;
   //       }
   //       if(_w < scissors_w)
   //          scissors_w = _w;
   //       else if(scissors_w < 0)
   //          scissors_w = 0;
   //       if(_h < scissors_h)
   //          scissors_h = _h;
   //       else if(scissors_h < 0)
   //          scissors_h = 0;
   //    }
   //    else
   //    {
   //       scissors_x = _x;
   //       scissors_y = _y;
   //       scissors_w = _w;
   //       scissors_h = _h;
   //    }
   //    if(scissors_w < 0) scissors_w = 0;
   //    if(scissors_h < 0) scissors_h = 0;
   //    // trace "xxx set scissors_x="+scissors_x+" y="+scissors_y+" w="+scissors_w+" h="+scissors_h;
   //    glScissor(scissors_x*UI.supersample_factor,
   //              scissors_y*UI.supersample_factor,
   //              scissors_w*UI.supersample_factor,
   //              scissors_h*UI.supersample_factor
   //              );
   // }

   // public static PopScissors() {
   //    // trace "xxx UI::PopScissors: cur=("+scissors_x+";"+scissors_y+";"+scissors_w+";"+scissors_h+")";

   //    scissors_x = scissors_stack[scissors_stacki++];
   //    scissors_y = scissors_stack[scissors_stacki++];
   //    scissors_w = scissors_stack[scissors_stacki++];
   //    scissors_h = scissors_stack[scissors_stacki++];

   //    // trace "xxx UI::PopScissors:   restore=("+scissors_x+";"+scissors_y+";"+scissors_w+";"+scissors_h+")";

   //    glScissor(scissors_x*UI.supersample_factor,
   //              scissors_y*UI.supersample_factor,
   //              scissors_w*UI.supersample_factor,
   //              scissors_h*UI.supersample_factor
   //              );
   // }

   public static SetEnableTransparentLayers(boolean _b) {
      explain "Enable transparent layers";
      b_transparent_layers = _b;
      RedrawAll();
   }

   public static GetEnableTransparentLayers() : boolean {
      explain "Query whether transparent layers are currently enabled.";
      return b_transparent_layers;
   }

   public static SetEnableForceHighFramerate(boolean _bEnabled) {
      b_force_high_framerate = _bEnabled;
   }

   public static SetEnableFBO(boolean _bEnabled) {
      b_fbo = _bEnabled && !b_headless;
      if(!b_fbo)
         UI.SetGlobalPaintFlag(UI.PAINT_ALL);
   }

   public static SetEnableFBODepthBuffers(boolean _bEnabled) {
      b_fbo_depth_buffers = _bEnabled;
   }

   public static SetEnableShadeModal(boolean _b)  : boolean {
      explain "Enable background shading when modal floating layers are drawn. Returns previous setting.";
      return = b_shade_modal;
      b_shade_modal = _b;
      if(b_running)
         CompositeAll();
   }

   public static GetAcceleratorChar(String _s) : char {
      explain "Extract accelerator key (prefixed by \\a) from string. Returns null if no accel key was found.";

      if(null != _s)
      {
         int idx = _s.indexOfChar('\a', 0);
         if(idx != -1)
         {
            int c = _s[idx+1];
            // Make it lowercase
            if( (c>='A') && (c<='Z') )
               c |= 32;
            return c;
            ////trace "xxx accel key name=\""+k.name+"\"";
            // Note: must compare key unicode+alpha fields otherwise we'd have to re-translate the key back to the raw key code!
            //       Since the unicode field is merely virtual we need to use the alpha field to store the unicode (ASCII..) value
         }
      }
      return 0;
   }

   public static NewObjectByFQName(String _s) : Object {
      explain "Allocate new object by fully qualified name.";

      String *nspaceName;
      String *className;
      int nspIdx = _s.indexOf("::", 0);
      if(-1 != nspIdx)
      {
         if(0 != nspIdx)
         {
            // mynamespace::MyClass
            nspaceName <= _s.substring(0, nspIdx);
            className <= _s.substring(nspIdx+2, _s.length-(nspIdx+2));
            return TKS.newObjectByName(nspaceName, className);
         }
         else
         {
            // ::MyClass
            className <= _s.substring(2, _s.length-2);
            return TKS.newObjectByName(null, className);
         }
      }
      else
      {
         // MyClass
         className <= _s;
         // trace "xxx UI::NewObjectByFQName: call newObjectByName: nsp=\"ui\" className=\""+className+"\"";
         Object r <= TKS.newObjectByName("ui", className);
         // trace "xxx UI::NewObjectByFQName: call   => r="+#(r);
         if(null == r)
         {
            // Try default namespace
            r <= TKS.newObjectByName(null, className);
         }
         return deref r;
      }
   }

   public static GetColorString(int _c32) : String {
      local Integer io = _c32;
      return io.printf("#%08x");
   }

   static MixColor32(int x, int y, float t) : int {
      // int ax = (x>>24)&255;
      // int rx = (x>>16)&255;
      // int gx = (x>> 8)&255;
      // int bx = (x    )&255;

      // int ay = (y>>24)&255;
      // int ry = (y>>16)&255;
      // int gy = (y>> 8)&255;
      // int by = (y    )&255;

      // return argb(ax + (ay - ax) * t,
      //             rx + (ry - rx) * t,
      //             gx + (gy - gx) * t,
      //             bx + (by - bx) * t
      //             );
      return sdvg_MixARGBf(x, y, t);
   }

   static TintColor32(int a, int b) : int {
      // return MixColor32(a, 0xFF000000 | (b&0x00FFFFFF), ((b>>24)&255)/255.0);
      return sdvg_TintARGB(a, b);
   }

   static TintColor32Alpha(int a, int b, byte _a) : int {
      // return (MixColor32(a, 0xFF000000 | (b&0x00FFFFFF), ((b>>24)&255)/255.0) & 0x00ffffff) | (_a << 24);
      return sdvg_TintRGBAlpha(a, b, _a);
   }

   static Color32Alpha(int _c32, byte _a) : int {
      // return (_c32 & 0xFFffFF) | (_a << 24);
      return sdvg_RGBAlpha(_c32, _a);
   }

   static DebugPrintC32(String _prefix, int _c32) {
      Integer io = _c32;
      trace _prefix+io.printf("#%08x");
   }

   // (note) removed b/c LookAndFeel can be set per Layer (moved to UIRenderer class)
   //   - GetColor(), GetColorAlpha(), GetTintedColor(), GetTintedColorAlpha(;

   static HSVTOARGB32(float h, s, v, byte _a) : int {
      // converts alpha '_a' (0..255) + hue (0..360) + saturation/value (0..1) to ARGB32 int

      // if(h >= 360)
      //    h -= 360;
      // h /= 60;
      // int i = h;
      // float f = h - i;

      // int p = 255 * v * ( 1 - s );
      // int q = 255 * v * ( 1 - s * f );
      // int t = 255 * v * ( 1 - s * ( 1 - f ) );

      // v *= 255;

      // switch(i)
      // {
      //    case 0:
      //       return argb(_a, v, t, p);
      //    case 1:
      //       return argb(_a, q, v, p);
      //    case 2:
      //       return argb(_a, p, v, t);
      //    case 3:
      //       return argb(_a, p, q, v);
      //    case 4:
      //       return argb(_a, t, p, v);
      //    default:
      //       return argb(_a, v, p, q);
      // }

      return sdvg_HSVAToARGB(h, s, v, _a);
   }

   static RGB32TOHSV(int _c32, Float h, s, v) {

      // float r = ( (_c32 >> 16) & 255 ) * (1.0f / 255);
      // float g = ( (_c32 >>  8) & 255 ) * (1.0f / 255);
      // float b = ( (_c32      ) & 255 ) * (1.0f / 255);

      // v = mathMaxf(r, g);
      // v = mathMaxf(v, b);

      // float t = mathMinf(r, g);
      // t = mathMinf(t, b);

      // if(0 == v)
      //    s = 0;
      // else
      //    s = (v - t) / v;

      // float cr = (v - r) / (v - t);
      // float cg = (v - g) / (v - t);
      // float cb = (v - b) / (v - t);

      // if(r == v)
      //    h = cb - cg;
      // else if(g == v)
      //    h = 2 + cr - cb;
      // else if(b == v)
      //    h = 4 + cg - cr;

      // h *= 60;

      // if(h < 0)
      //    h += 360;

      return sdvg_ARGBToHSVA(_c32, h, s, v);
   }

   public static IntToBinary255String(byte _val) : String {
      _val &= 255;

      String r = "0b";
      int bit = 128;
      loop(8)
      {
         if(_val & bit)
            r.append("1");
         else
            r.append("0");
         bit >>= 1;
      }

      return r;
   }

   // <method_get.png>
   static GetEnableString(local boolean _bEnabled) : String {
      return (maybe == _bEnabled) ? "enabled(maybe)" : (false != _bEnabled) ? "enabled" : "disabled";
   }

   // <method.png>
   public static GetPluralString(int _num) : String {
      if((0 == _num) || (abs(_num) > 1))
         return "s";
      return "";
   }

   public static SaveScreenShotPNG(String _pathName, int _offX, int _offY, int _w, int _h) : boolean {
      trace "[dbg] UI.SaveScreenShotPNG: pathName=\""+_pathName+"\" off=("+_offX+","+_offY+") s=("+_w+","+_h+")";
      _w = mathClampi(_w, 0, Viewport.width);
      _h = mathClampi(_h, 0, Viewport.height);
      if(0 == _w)
         _w = Viewport.width;
      if(0 == _h)
         _h = Viewport.height;

      local Texture tex;
      boolean ret = false;
      if(tex.alloc(_w, _h, 4))
      {
         glBindFramebuffer(GL_FRAMEBUFFER, 0);
         // glReadBuffer(GL_BACK);
         glReadBuffer(GL_FRONT);
         glFinish();
         int off = 0;
         int y = (Viewport.height - 1 - _offY);
         int texY = 0;
         // trace "xxx vph="+Viewport.height+" vpy="+y;
         loop(_h)
         {
            if(1)
            {
               // (todo) does not seem to always work on macOS ??
               // (note) it does work in another test, though (e.g. plot.tks)
               zglReadColorPixelsX(tex, off, _offX, y, _w);
               tex.clearAlpha(#ff);
            }
            else
            {
               // work on macOS but is _very_ slow (resolves whole FB per pixel ??!)
               int x = _offX;
               int texX = 0;
               loop(_w)
               {
                  int c32 = zglReadColorPixel(x++, y);
                  c32 |= #ff000000;
                  tex.setXY32(texX++, texY, c32);
               }
               texY++;
            }

            y--;
            off += _w;
         }
         ret = tex.saveImage(_pathName);
      }
      return ret;
   }

   public static GetGLFramebufferId_RootFBO() : int {
      // called by gledit
      return root_fbo.getGLFramebufferId();
   }

   public static DrainEventQueue() {
      // issue: (SDL1) "mouse-clicks sometimes only start working after 2x cmd-tab" (on macOS)
      // this seems to help but does not completely resolve the issue (it just happens less frequently)
      //  (todo) check if this is still an issue with SDL2
      // trace "xxx DrainEventQueue";
      // UI.Backtrace();
      if(IsMacOS())
      {
         SDL.drainEventQueue();

         UI.CancelKeyRepeat();
      }
   }

   public static OnDrainEventQueue() {
      // called by SDL.drainEventQueue()
      if(null != root_layer)
      {
         root_layer.onDrainEventQueue();
      }
   }

}

// Install default Logger (may be overriden by application via UI.SetLogger())
UI.logger <= new Logger;
