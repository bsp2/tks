// ----
// ---- file   : PopupMenuButton.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2007-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- changed: 29Apr2007, 06May2007, 20May2007, 29Jan2010, 22Apr2010, 10Jun2010, 12Feb2012
// ----          28Sep2014, 14Feb2015, 10Feb2018, 16Feb2018, 23Feb2018, 16Oct2018, 27Nov2018
// ----          27Feb2020, 20Oct2023, 21Oct2023, 22Mar2024, 24Mar2024, 20Sep2024, 04Oct2024
// ----          05Oct2024, 10Sep2025
// ----
// ----
// ----

module MPopupMenuButton;

namespace ui;


class PopupMenuButton extends Button {

   define int ACCEL_IPAD_L = 4;
   define int ACCEL_IPAD_R = 2;

   protected String accelerator_name; // e.g. "lctrl-c"
   protected String alt_accelerator_name; // e.g. "lctrl-x s"

   protected String accelerator_caption; // e.g. "lctrl-x s / lctrl-c"

   protected boolean b_inactive;

   protected Font    *font_accel;
   public    boolean  b_accel_align_left;
   protected int      bt_psx;


   public method initPopupMenuButton() {
      initButton();

      setFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);
      setTextPlacement(Layout.LEFT | Layout.CENTERY);
      setAlignment(Layout.EXPANDX|Layout.CENTERY);
      b_redraw_parent = UI.b_transparent_layers; // [16Oct2018] fix mouseover color trails

      font_accel <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_POPUPACCEL);

      b_no_lctrl_hold_modifier = true;
   }

   public method setActive(boolean _bActive) {
      b_inactive = !_bActive;
      setEditable(_bActive);
   }

   public method isActive() : boolean {
      return !b_inactive;
   }

   public getAcceleratorName() : String {
      return accelerator_name;
   }

   public method onAcceleratorKey(AcceleratorKey _k) {
      handleButtonClick(null/*ev*/);
   }

   public virtual calcPreferredSizeX() : boolean {
      Button::calcPreferredSizeX();
      bt_psx = preferred_size_x;
      if(!accelerator_caption.isBlank())
      {
         preferred_size_x += ACCEL_IPAD_L + ACCEL_IPAD_R + font.stringWidth(accelerator_caption);
      }
      return true;
   }

   public virtual onKey(Key _k) : boolean {
      switch(_k.pressed)
      {
         case VKEY_LEFT:
         case VKEY_RIGHT:
         case VKEY_UP:
         case VKEY_DOWN:
            // Do not pass these keys to the default Layer implementation which uses
            // them for tab-cycling
            return false;
      }
      return Button::onKey(_k);
   }

   public virtual onKeyboardFocus() {
      redraw();
   }

   public virtual onMouseEnter(MouseEvent _ev) : boolean {
      Layer::onMouseEnter(_ev);
      UI.SetKeyboardFocus(this);
      return true;
   }

   public virtual onMouseLeave(MouseEvent _ev) : boolean {
      Layer::onMouseLeave(_ev);
      loseKeyboardFocus();
      redraw();
   }

   public virtual wantKeyRepeat(Key _k) : boolean {
      return true;
   }

   public virtual onDraw() {
      int c32;
      int c32bg;

      // Draw background
      if(hasKeyboardFocus())
      {
         c32 = lnf_colors.get(LookAndFeel.COLOR_POPUPMENUBUTTON_MOUSEOVER_TEXT_FG);

         if(b_pressed)
         {
            c32bg = lnf_colors.get(LookAndFeel.COLOR_POPUPMENUBUTTON_ACTIVE_BG);
            c32bg = sdvg_TintARGB(c32bg, bg32_tint);
            UIRenderer.DrawFilledRectangle(0, 0,  getSizeX(), getSizeY(), c32bg);
         }
         else
         {
            c32bg = lnf_colors.get(LookAndFeel.COLOR_POPUPMENUBUTTON_MOUSEOVER_BG);
            c32bg = sdvg_TintARGB(c32bg, bg32_tint);
            UIRenderer.DrawFilledRectangle(0, 0,  getSizeX(), getSizeY(), c32bg);
         }
      }
      else
      {
         c32 = lnf_colors.get(LookAndFeel.COLOR_POPUPMENUBUTTON_TEXT_FG);

         c32bg = lnf_colors.get(LookAndFeel.COLOR_POPUPMENUBUTTON_INACTIVE_BG);
         c32bg = sdvg_TintARGB(c32bg, bg32_tint);
         UIRenderer.DrawFilledRectangle(0, 0,  getSizeX(), getSizeY(), c32bg);
      }

      // Draw caption
      if(b_inactive)
      {
         c32 = sdvg_MixARGBf(c32, c32bg, 0.6);
      }
      setForegroundColor(c32);

      Label::drawTransparentCached(0, 0);

      // Draw accelerator caption
      if(!accelerator_caption.isBlank())
      {
         float px;

         if(b_accel_align_left)
         {
            px = bt_psx + ACCEL_IPAD_L;
         }
         else
         {
            px = getSizeX() - ACCEL_IPAD_R - 2 - font_accel.stringWidth(accelerator_caption);
         }

         float py = (getSizeY() - getCaptionHeight() - ipad_t - ipad_b)*0.5 + ipad_t;
         c32 =
            lnf_colors.get(hasKeyboardFocus() ?
                           LookAndFeel.COLOR_ACCELNAME_FG_ACTIVE :
                           LookAndFeel.COLOR_ACCELNAME_FG_INACTIVE
                           );

         int ul32 = lnf_colors.get(LookAndFeel.COLOR_ACCEL_UL_FG);

         if(b_inactive)
         {
            c32  = sdvg_MixARGBf(c32,  lnf_colors.get(LookAndFeel.COLOR_WINDOW_BG), 0.6);
            ul32 = sdvg_MixARGBf(ul32, lnf_colors.get(LookAndFeel.COLOR_WINDOW_BG), 0.6);
         }

         UIRenderer.DrawText(accelerator_caption, font_accel, c32, ul32, (int)px, (int)py, 0/*availW*/, 0/*align*/); // -2 for button border
      }
   }

   public method setAccelerators(String _primary, String _secondary) {

      accelerator_name     = _primary;
      alt_accelerator_name = _secondary;

      accelerator_caption.empty();

      if(!alt_accelerator_name.isBlank())
      {
         accelerator_caption.append(" ");
         accelerator_caption.append(alt_accelerator_name);
      }

      if(!accelerator_name.isBlank())
      {
         if(!accelerator_caption.isBlank())
            accelerator_caption.append(" OR ");
         else
            accelerator_caption.append(" ");
         accelerator_caption.append(accelerator_name);
      }
   }

   public virtual setFontByName(String _fontName) {
      Button::setFontByName(_fontName);

      font_accel <= font;
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {
      if(true)//Button::beginXFMTag(_form, _attributes))
      {
         initPopupMenuButton();

         boolean bHaveIcon = false;
         String atname, atnamelc, atval, atvaluc;
         StringArray atsplit;
         foreach atname in _attributes
         {
            atval <= _attributes[atname];

            atname.toLower() => atnamelc;

            switch(atnamelc)
            {
               case "autoresolve": // copied from Layer, since parent beginXFMTag() is not called
                  b_noautoresolve = !int(atval);
                  break;

               case "caption":
                  setCaption(atval);
                  break;

               case "actionname":
                  setProvidedActionAlias(Button.ACTION_CLICK, atval);
                  break;

               case "iconname":
                  Icon ico <= UI.GetIcon(atval);
                  if(ico != null)
                  {
                     bHaveIcon = true;
                     setIcon(ico);
                     setIconPlacement(Layout.LEFT);
                     setIconPadRight(UIConstants.POPUPMENU_ICON_PAD_R);
                  }
                  break;

               case "acceleratorkey":
                  accelerator_name = atval;
                  break;

               case "altacceleratorkey":
                  alt_accelerator_name = atval;
                  break;

               case "active":
                  setActive(int(atval));
                  break;

               case "tooltipcaption":
                  setToolTipCaption(atval);
                  break;
            }
         }

         setAccelerators(accelerator_name, alt_accelerator_name);

         if(!bHaveIcon)
         {
            setInnerPadLeft(UIConstants.BUTTON_INSET_LEFT + UIConstants.POPUPMENU_ICON_WIDTH*UI.icon_scaling + UIConstants.POPUPMENU_ICON_PAD_R);
         }

         lockInnerPadding();

         return true;
      }
      return false;
   }

}
