// ----
// ----    file: Layout.tks
// ----  author: Copyright (c) 2005-2025 by Bastian Spiegel <bs@tkscript.de>
// ----
// ---- license: Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ----    info:
// ----
// ---- changed: 19Apr2005, 20Apr2005, 28May2005, 07Jun2005, 09Jun2005, 10Jun2005, 18Jun2005
// ----          23Jun2005, 24Jun2005, 25Jun2005, 17Jul2005, 10Aug2005, 13Aug2005, 14Aug2005
// ----          10Jan2006, 12Aug2006, 28Apr2007, 29Apr2007, 30Apr2007, 05May2007, 30Oct2007,
// ----          11Nov2007, 02Feb2009, 09Jan2012, 27Dec2020, 20Oct2023, 21Oct2023, 22Oct2023
// ----          28Oct2023, 19Mar2024, 28Mar2024, 29Mar2024, 23Feb2025
// ----
// ----
// ----

module MLayout;

namespace ui;


class Layout {

   define int LEFT      = 1 << 0;            //   1
   define int RIGHT     = 1 << 1;            //   2
   define int TOP       = 1 << 2;            //   4
   define int BOTTOM    = 1 << 3;            //   8
   define int EXPANDX   = 1 << 4;            //  16
   define int EXPANDY   = 1 << 5;            //  32
   define int BASELINEX = 1 << 6;            //  64 (todo?)
   define int BASELINEY = 1 << 7;            // 128 vertical layer justification in final layout pass

   define int CENTERX  = LEFT | RIGHT;       //   3
   define int CENTERY  = TOP | BOTTOM;       //  12
   define int CENTER   = CENTERX | CENTERY;  //  15

   define int BASELINE = CENTERY | BASELINEY;

   define int DIRECTION_MASK = CENTER;

   define int HORIZONTAL = CENTERX | EXPANDX;
   define int VERTICAL   = CENTERY | EXPANDY;

   define int EXPAND   = EXPANDX | EXPANDY;

   define float FILL  = 2048*8;
   define float FILLX = 1920*8;
   define float FILLY = 1440*8;


   // ----
   // ---- The layoutChildLayersOf() method layouts the child-layers
   // ---- of the given layer according to their layout_hints fields.
   // ----
   public method layoutChildLayersOf(local Layer _layer, local boolean _bInvalidateSizeCaches, local boolean _bLayoutFinal) {
      trace "Layout::layoutChildLayersOf(Layer): no-op.";
   }

   // ----
   // ---- Calculate the preferred horizontal size _layer (taking into account its direct child layers).
   // ----
   public method calcPreferredSizeXOf(local Layer _layer) {
   }

   // ----
   // ---- Calculate the preferred vertical size of _layer (taking into account its direct child layers).
   // ----
   public method calcPreferredSizeYOf(local Layer _layer) {
   }

   // ----
   // ---- Calculate the preferred horizontal and vertical sizes _layer (taking into account its direct child layers).
   // ----
   public method calcPreferredSizeOf(local Layer _layer) {
      calcPreferredSizeXOf(_layer);
      calcPreferredSizeYOf(_layer);
   }

   // [12Mar2024] test23e.gr
   public method recursiveUpdatePreferredPanelSizeOf(local Layer _layer) : boolean {
      local Layer c <= _layer.getLayoutFirstChild();
      if(null != c)
      {
         while(null != c)
         {
            if(c instanceof Composite)
            {
               recursiveUpdatePreferredPanelSizeOf(c);
            }
            c <= c.next;
         }
         calcPreferredSizeOf(_layer);
      }
   }

   // ----
   // ---- Calculate the minimum horizontal size _layer (taking into account ints child layers).
   // ----
   public method calcMinimumSizeXOf(local Layer _layer) {
   }

   // ----
   // ---- Calculate the minimum vertical size of _layer (taking into account its child layers).
   // ----
   public method calcMinimumSizeYOf(local Layer _layer) {
   }

   // ----
   // ---- Calculate the minimum horizontal and vertical sizes _layer (taking into account its child layers).
   // ----
   public method calcMinimumSizeOf(local Layer _layer) {
      calcMinimumSizeXOf(_layer);
      calcMinimumSizeYOf(_layer);
   }

   public static IsOppositeX(int _placementA, int _placementB) : boolean {
      return
         ( (LEFT  == (_placementA & CENTERX)) && (RIGHT == (_placementB & CENTERX)) ) ||
         ( (RIGHT == (_placementA & CENTERX)) && (LEFT  == (_placementB & CENTERX)) ) ;
   }

   public static IsOppositeY(int _placementA, int _placementB) : boolean {
      return
         ( (TOP    == (_placementA & CENTERY)) && (BOTTOM == (_placementB & CENTERY)) ) ||
         ( (BOTTOM == (_placementA & CENTERY)) && (TOP    == (_placementB & CENTERY)) ) ;
   }

   public static SwapDirFlags(int _dirFlags) : int {
      if(_dirFlags & Layout.LEFT)
         _dirFlags = (_dirFlags & ~Layout.LEFT) | Layout.RIGHT;
      else if(_dirFlags & Layout.RIGHT)
         _dirFlags = (_dirFlags & ~Layout.RIGHT) | Layout.LEFT;
      if(_dirFlags & Layout.TOP)
         _dirFlags = (_dirFlags & ~Layout.TOP) | Layout.BOTTOM;
      else if(_dirFlags & Layout.BOTTOM)
         _dirFlags = (_dirFlags & ~Layout.BOTTOM) | Layout.TOP;
      return _dirFlags;
   }

   public static CalcDirFlagsRelativeTo(Vector2f _p, Vector2f _o) : int {
      int r = 0;
      if(_o.x > _p.x)
         r |= Layout.RIGHT;
      else if(_o.x < _p.x)
         r |= Layout.LEFT;
      if(_o.y > _p.y)
         r |= Layout.BOTTOM;
      else if(_o.y < _p.y)
         r |= Layout.TOP;
      return r;
   }

   static OppositeDir(int _dir) : int {
      switch(_dir)
      {
         default:
         case Layout.TOP:
            _dir = Layout.BOTTOM;
            break;

         case Layout.LEFT:
            _dir = Layout.RIGHT;
            break;

         case Layout.BOTTOM:
            _dir = Layout.TOP;
            break;

         case Layout.RIGHT:
            _dir = Layout.LEFT;
            break;
      }
      return _dir;
   }

   static CycleDir(int _dir, boolean _bInc) : int {
      switch(_dir)
      {
         default:
         case Layout.TOP:
            _dir = _bInc ? Layout.LEFT : Layout.RIGHT;
            break;

         case Layout.LEFT:
            _dir = _bInc ? Layout.BOTTOM : Layout.TOP;
            break;

         case Layout.BOTTOM:
            _dir = _bInc ? Layout.RIGHT : Layout.LEFT;
            break;

         case Layout.RIGHT:
            _dir = _bInc ? Layout.TOP : Layout.BOTTOM;
            break;
      }
      return _dir;
   }

}
