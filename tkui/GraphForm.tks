// ----
// ---- file   : GraphForm.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- created: 02Mar2024
// ---- changed: 03Mar2024, 04Mar2024, 05Mar2024, 06Mar2024, 10Mar2024, 11Mar2024, 12Mar2024
// ----          13Mar2024, 14Mar2024, 15Mar2024, 16Mar2024, 17Mar2024, 18Mar2024, 19Mar2024
// ----          20Mar2024, 21Mar2024, 22Mar2024, 23Mar2024, 24Mar2024, 25Mar2024, 26Mar2024
// ----          27Mar2024, 28Mar2024, 29Mar2024, 01Apr2024, 02Apr2024, 03Apr2024, 04Apr2024
// ----          05Apr2024, 06Apr2024, 08Apr2024, 09Apr2024, 10Apr2024, 01Feb2025, 02Feb2025
// ----          18Feb2025, 20Feb2025, 21Feb2025, 22Feb2025, 10Sep2025, 11Sep2025, 12Sep2025
// ----          13Sep2025, 14Sep2025
// ----
// ----
// ----

module MGraphForm;

boolean b_gf_debug   = 0;
boolean b_gf_debug2  = 0;
boolean b_gf_debug3  = 0;  // tesselate / rendering
boolean b_gf_debug4  = 0;  // printHierarchy()

boolean b_gf_profile = 0;

namespace ui;

use namespace graph;

boolean b_graphedge_shapes = 1;


function SetEnableProfiling(boolean _bEnable) {
   b_gf_profile = _bEnable;
}

function SetDebugLevel(int _level) {
   b_gf_debug  = (_level > 0);
   b_gf_debug2 = (_level > 1);
   b_gf_debug3 = (_level > 2);
   b_gf_debug4 = (_level > 3);
}


// <class.png>
class GraphPortButton : Button {
   public method initGraphPortButton() {
      Button::initButton();
   }
}


// <class.png>
class GraphEdgeArrow {
   int        fgcolor;          // "arrow_fgcolor" attribute (or "fgcolor" fallback)
   int        border_color;     // "arrow_border_color" attribute (def=#000)
   float      border_width;     // "arrow_border_width" attribute (def=0 / no border)
   float      linewidth;        // "arrow_linewidth" attribute. def=1
   float      angle;            // "arrow_angle" attribute. def=35(deg)
   float      len;              // "arrow_len" attribute. def=6(px)
   float      ilen_amt;         // "arrow_ilen" attribute. def=0%
   float      snap_amt;         // 0..1 (snap to 90° degree angles)
}

// <class.png>
class GraphEdge {

   static boolean bMacOS = (TKS.dllSuffix == ".dylib");
   static boolean bCanDoLineStipple = !bMacOS;
   static boolean bCanDoLineBlend   = !bMacOS;

   Edge *edge;
   Node *n_tail;      // (note) actual tail/head may differ from edge after helper node elimination
   Node *n_head;

   float abs_x_tail;
   float abs_y_tail;

   float abs_x_head;
   float abs_y_head;

   int        fgcolor;                  // "edge_fgcolor" attribute  (or "fgcolor" fallback)
   int        fgcolor_left;             // "edge_fgcolor_left" attribute [def=use edge_fgcolor]
   int        fgcolor_right;            // "edge_fgcolor_right" attribute [def=use edge_fgcolor]
   float      width;                    // >1 for Edge.STYLE_BOLD
   float      width_start;              // [def=width]
   float      width_end;                // [def=width]
   float      width_exp;                // [def=1.0]
   float      width_left;               // [def=0(no left border)]
   float      width_right;              // [def=0(no right border)]
   boolean    b_width_adaptive;         // true=scale left/right widths [def=true]
   float      width_adaptive_min;       // [def=0.05]
   float      width_adaptive_max;       // [def=4]
   short      pattern;                  // Edge.STYLE_DOTTED and DASHED

   GraphEdgeArrow arrow;
   GraphEdgeArrow arrow_rev;

   boolean    b_arrow_tail;             // 1=draw arrow towards tail ("<>" Edge.STYLE_BIDIR, reverse edges)
   boolean    b_arrow_head;             // 1=draw arrow towards head
   boolean    b_arrow_solid;            // 1=solid filled triangle  0=lines  ("arrow_style" attribute "solid")
   Point2f    cached_arrow_head_l;      // extruded arrow head vertex (left)  (when b_arrow_head=true)
   Point2f    cached_arrow_head_r;      // extruded arrow head vertex (right)
   Point2f    cached_arrow_head_dst;    // arrow head destination vertex
   Point2f    cached_arrow_head_inner;  // arrow head inner destination vertex
   Point2f    cached_arrow_tail_l;      // extruded arrow tail vertex (left)  (when b_arrow_tail=true)
   Point2f    cached_arrow_tail_r;      // extruded arrow tail vertex (right)
   Point2f    cached_arrow_tail_dst;    // arrow tail destination vertex
   Point2f    cached_arrow_tail_inner;  // arrow tail inner destination vertex
   boolean    b_curve;                  // 1=draw bezier or right-angled curve ("edge_shape" attribute "curve" or "rcurve")
   boolean    b_rcurve;                 // 1=draw right-angled curve           ("edge_shape" attribute "rcurve")
   boolean    b_line;                   // 1=draw straight line                ("edge_shape" attribute "line")
   FloatArray curve_vertices;
   float      curve_bendiness;          // 0..1 ("edge_bend"/"bend" attribute). def=0.5
   boolean    b_curve_bend_h_tail;      // 1=curve connects to left/right side of tail node  0=top/bottom side
   boolean    b_curve_bend_h_head;      // 1=curve connects to left/right side of head node  0=top/bottom side
   boolean    b_curve_c;                // 1=explicit curve control points (c1+c2) (from helper node)  0=automatic control points (def)
   float      curve_c1x;                // when b_curve_c==1
   float      curve_c1y;                // when b_curve_c==1
   float      curve_c2x;                // when b_curve_c==1
   float      curve_c2y;                // when b_curve_c==1
   ShapePolyline *curve_shape;

   public method initShape(Edge edge) {
      b_curve  = true;
      b_rcurve = false;
      b_line   = false;
      if(edge.haveEdgeAttrib("edge_shape"))
      {
         String sCurve <= edge.getEdgeAttrib("edge_shape");
         b_rcurve = ("rcurve" == sCurve);
         b_curve  = ("curve"  == sCurve) | b_rcurve;
         b_line   = ("line"   == sCurve);
      }
   }

   public method init(Edge _e, Node _tail, Node _head) {
      edge   <= _e;
      n_tail <= _tail;
      n_head <= _head;
      setEdgeStyle(edge.edge_style);

      if(edge.haveEdgeAttrib("edge_width"))
         width = float(edge.getEdgeAttrib("edge_width")) * UI.font_scaling;

      if(edge.haveEdgeAttrib("edge_width_start"))
         width_start = float(edge.getEdgeAttrib("edge_width_start")) * UI.font_scaling;

      if(width_start < 0.001f)
         width_start = width;

      if(edge.haveEdgeAttrib("edge_width_end"))
         width_end = float(edge.getEdgeAttrib("edge_width_end")) * UI.font_scaling;

      if(width_end < 0.001f)
         width_end = width;

      if(edge.haveEdgeAttrib("edge_width_exp"))
         width_exp = float(edge.getEdgeAttrib("edge_width_exp"));
      else
         width_exp = 1.0f;

      if(edge.haveEdgeAttrib("edge_width_left"))
         width_left = float(edge.getEdgeAttrib("edge_width_left")) * UI.font_scaling;

      if(edge.haveEdgeAttrib("edge_width_right"))
         width_right = float(edge.getEdgeAttrib("edge_width_right")) * UI.font_scaling;

      int tintPost = edge.haveEdgeAttrib("tint") ? int(edge.getEdgeAttrib("tint")) : 0;

      if(edge.haveEdgeAttrib("edge_fgcolor"))
         fgcolor = #ff000000 | int(edge.getEdgeAttrib("edge_fgcolor"));
      else if(edge.haveEdgeAttrib("edge_color"))
         fgcolor = #ff000000 | int(edge.getEdgeAttrib("edge_fgcolor"));
      else if(edge.haveEdgeAttrib("fgcolor"))
         fgcolor = #ff000000 | int(edge.getEdgeAttrib("fgcolor"));
      else if(edge.haveEdgeAttrib("color"))
         fgcolor = #ff000000 | int(edge.getEdgeAttrib("color"));
      else
         fgcolor = #ff000000;

      int tint = 0;
      if(edge.haveEdgeAttrib("edge_fgtint"))
         tint = edge.getEdgeAttrib("edge_fgtint");
      else if(edge.haveEdgeAttrib("fgtint"))
         tint = edge.getEdgeAttrib("fgtint");
      if(0 != tint)
         fgcolor = sdvg_TintARGB(fgcolor, tint);
      if(0 != tintPost)
         fgcolor = sdvg_TintARGB(fgcolor, tintPost);

      if(edge.haveEdgeAttrib("edge_fgcolor_left"))
         fgcolor_left = int(edge.getEdgeAttrib("edge_fgcolor_left"));
      else
         fgcolor_left = fgcolor;

      tint = 0;
      if(edge.haveEdgeAttrib("edge_fgtint_left"))
         tint = int(edge.getEdgeAttrib("edge_fgtint_left"));
      if(0 != tint)
         fgcolor_left = sdvg_TintARGB(fgcolor_left, tint);

      if(edge.haveEdgeAttrib("edge_fgcolor_right"))
         fgcolor_right = int(edge.getEdgeAttrib("edge_fgcolor_right"));
      else
         fgcolor_right = fgcolor;

      tint = 0;
      if(edge.haveEdgeAttrib("edge_fgtint_right"))
         tint = int(edge.getEdgeAttrib("edge_fgtint_right"));
      if(0 != tint)
         fgcolor_right = sdvg_TintARGB(fgcolor_right, tint);

      if(edge.haveEdgeAttrib("edge_width_adaptive"))
         b_width_adaptive = (0 != int(edge.getEdgeAttrib("edge_width_adaptive")));
      else
         b_width_adaptive = true;

      if(edge.haveEdgeAttrib("adaptive_width_min"))
         width_adaptive_min = float(edge.getEdgeAttrib("edge_width_adaptive_min")) * UI.font_scaling;
      else
         width_adaptive_min = 0.05f;

      if(edge.haveEdgeAttrib("adaptive_width_max"))
         width_adaptive_max = float(edge.getEdgeAttrib("edge_width_adaptive_max")) * UI.font_scaling;
      else
         width_adaptive_max = 4.0f;

      if(edge.haveEdgeAttrib("bend"))
         curve_bendiness = edge.getEdgeAttribAmount("bend");
      else if(edge.haveEdgeAttrib("edge_bend"))
         curve_bendiness = edge.getEdgeAttribAmount("edge_bend");
      else
         curve_bendiness = 0.5f;
      curve_bendiness = mathClampf(curve_bendiness, 0.0f, 1.0f);

      int fgtintDef = edge.haveEdgeAttrib("fgtint") ? edge.getEdgeAttrib("fgtint") : 0;

      readArrowAttribs(arrow, ""/*suffix*/, fgcolor/*defColor*/, fgtintDef, tintPost);
      arrow_rev = arrow;
      readArrowAttribs(arrow_rev, "_rev"/*suffix*/, arrow.fgcolor/*defColor*/, 0/*fgtintDef*/, tintPost);  // test26.gr
   }

   public method freeGraphEdge() {
      if(null != curve_shape)
         curve_shape.freeShape();
   }

   public method getSVGWidth() : float {
      if(width_start > 0.0f && width_end > 0.0f)
         return (width_start + width_end) * 0.5f;
      return width;
   }

   protected method readArrowAttribs(GraphEdgeArrow _arrow, String _suffix, int _fgcolorDef, int _fgtintDef, int _tintPost) {
      if(edge.haveEdgeAttrib("arrow_fgcolor"+_suffix))
         _arrow.fgcolor = #ff000000 | int(edge.getEdgeAttrib("arrow_fgcolor"+_suffix));
      else
         _arrow.fgcolor = _fgcolorDef;
      int tint = 0;
      if(edge.haveEdgeAttrib("arrow_fgtint"+_suffix))
         tint = edge.getEdgeAttrib("arrow_fgtint"+_suffix);
      else if(edge.haveEdgeAttrib("fgtint"+_suffix))
         tint = edge.getEdgeAttrib("fgtint"+_suffix);
      else
         tint = _fgtintDef;
      if(0 != tint)
         _arrow.fgcolor = sdvg_TintARGB(_arrow.fgcolor, tint);
      if(0 != _tintPost)
         _arrow.fgcolor = sdvg_TintARGB(_arrow.fgcolor, _tintPost);

      // if(0)
      // {
      //    Integer io  = _fgcolorDef;
      //    Integer ioa = arrow_fgcolor;
      //    trace "xxx edge fgcolorDef="+io.printf("#%08x")+" arrow_fgcolor="+ioa.printf("%08x");
      // }

      if(edge.haveEdgeAttrib("arrow_linewidth"+_suffix))
         _arrow.linewidth = mathClampf(float(edge.getEdgeAttrib("arrow_linewidth"+_suffix)), 1.0f, 20.0f);
      else if(_suffix.isBlank())
         _arrow.linewidth = 1.0f;

      if(edge.haveEdgeAttrib("arrow_angle"+_suffix))
         _arrow.angle = mathClampf(float(edge.getEdgeAttrib("arrow_angle"+_suffix)), 10.0f, 70.0f);
      else if(_suffix.isBlank())
         _arrow.angle = 35.0f;

      if(edge.haveEdgeAttrib("arrow_len"+_suffix))
         _arrow.len = mathClampf(float(edge.getEdgeAttrib("arrow_len"+_suffix)), 2.0f, 64.0f) * UI.font_scaling;
      else if(_suffix.isBlank())
         _arrow.len = 6.0f * UI.font_scaling;

      if(edge.haveEdgeAttrib("arrow_ilen"+_suffix))
         _arrow.ilen_amt = mathClampf(edge.getEdgeAttribAmount("arrow_ilen"+_suffix), 0.0f, 1.0f);

      if(edge.haveEdgeAttrib("arrow_snap"+_suffix))
         _arrow.snap_amt = mathClampf(edge.getEdgeAttribAmount("arrow_snap"+_suffix), 0.0f, 1.0f);

      tint = 0;
      if(edge.haveEdgeAttrib("arrow_border_color"+_suffix))
         _arrow.border_color = #ff000000 | int(edge.getEdgeAttrib("arrow_border_color"+_suffix));
      else if(_suffix.isBlank())
         _arrow.border_color = #ff000000;
      if(edge.haveEdgeAttrib("arrow_fgtint"+_suffix))
         tint = edge.getEdgeAttrib("arrow_fgtint"+_suffix);
      else if(edge.haveEdgeAttrib("fgtint"+_suffix))
         tint = edge.getEdgeAttrib("fgtint"+_suffix);
      if(0 != tint)
         _arrow.border_color = sdvg_TintARGB(_arrow.border_color, tint);
      if(0 != _tintPost)
         _arrow.border_color = sdvg_TintARGB(_arrow.border_color, _tintPost);

      if(edge.haveEdgeAttrib("arrow_border_width"+_suffix))
         _arrow.border_width = mathClampf(edge.getEdgeAttrib("arrow_border_width"+_suffix), 0, 16);
   }

   public method copyAttribsFrom(GraphEdge _o) {
      fgcolor              = _o.fgcolor;
      fgcolor_left         = _o.fgcolor_left;
      fgcolor_right        = _o.fgcolor_right;
      arrow                = _o.arrow;
      arrow_rev            = _o.arrow_rev;
      width                = _o.width;
      width_start          = _o.width_start;
      width_end            = _o.width_end;
      width_exp            = _o.width_exp;
      width_left           = _o.width_left;
      width_right          = _o.width_right;
      b_width_adaptive     = _o.b_width_adaptive;
      width_adaptive_min   = _o.width_adaptive_min;
      width_adaptive_max   = _o.width_adaptive_max;
      pattern              = _o.pattern;
      b_arrow_tail         = _o.b_arrow_tail;
      b_arrow_head         = _o.b_arrow_head;
      b_arrow_solid        = _o.b_arrow_solid;
      b_curve              = _o.b_curve;
      b_rcurve             = _o.b_rcurve;
      b_line               = _o.b_line;
      curve_bendiness      = _o.curve_bendiness;
      b_curve_bend_h_tail  = _o.b_curve_bend_h_tail;
      b_curve_bend_h_head  = _o.b_curve_bend_h_head;
      b_curve_c            = _o.b_curve_c;
      curve_c1x            = _o.curve_c1x; // ??
      curve_c1y            = _o.curve_c1y; // ??
      curve_c2x            = _o.curve_c2x; // ??
      curve_c2y            = _o.curve_c2y; // ??
   }

   public method trySnapTailPosX(float _tailSnapTh, float _tailLeftX, float _tailSx) {
      // trace "xxx trySnapTailPosX: abs_x_head="+abs_x_head+" tailLeftX="+_tailLeftX+" tailRightX="+(_tailLeftX+_tailSx);
      if(_tailLeftX <= abs_x_head < (_tailLeftX + _tailSx))
      {
         float dx = abs_x_head - abs_x_tail;
         if(abs(dx) <= _tailSnapTh)
         {
            // move tail position to straighten vertical edge (e.g. test38d.gr)
            abs_x_tail = abs_x_head;
         }
      }
   }

   public method trySnapTailPosY(float _tailSnapTh, float _tailTopY, float _tailSy) {
      // trace "xxx trySnapTailPosY: abs_y_head="+abs_y_head+" tailTopY="+_tailTopY+" tailBotY="+(_tailTopY+_tailSy);
      if(_tailTopY <= abs_y_head < (_tailTopY + _tailSy))
      {
         float dy = abs_y_head - abs_y_tail;
         // trace "xxx     dy="+dy+" tailSnapTh="+_tailSnapTh;
         if(abs(dy) <= _tailSnapTh)
         {
            // move tail position to straighten horizontal edge (e.g. test30.gr)
            abs_y_tail = abs_y_head;
         }
      }
   }

   protected method calcCurveDistB() : float {
      return
         (#ffff == pattern) ? 2.0f : 99999.0f
         * UI.font_scaling
         ;
   }

   protected method calcCurveDistP() : float {
      return
         ((#ffff == pattern) ? 2.0f : (#F8F8/*dash*/ == pattern) ? 1.0f : 1.0f/*dot*/)
         * UI.font_scaling
         ;
   }

   public method tesselateCurve() {
      if(b_curve)
      {
         curve_vertices.empty();
         float c1x, c1y, c2x, c2y;
         if(b_curve_c)
         {
            c1x = curve_c1x;
            c1y = curve_c1y;
            c2x = curve_c2x;
            c2y = curve_c2y;
         }
         else
         {
            if(b_curve_bend_h_tail)
            {
               c1x = mathLerpf(abs_x_tail, abs_x_head, curve_bendiness);
               c1y = abs_y_tail;
            }
            else
            {
               c1x = abs_x_tail;
               c1y = mathLerpf(abs_y_tail, abs_y_head, curve_bendiness);
            }

            if(b_curve_bend_h_head)
            {
               c2x = mathLerpf(abs_x_head, abs_x_tail, curve_bendiness);
               c2y = abs_y_head;
            }
            else
            {
               c2x = abs_x_head;
               c2y = mathLerpf(abs_y_head, abs_y_tail, curve_bendiness);
            }
         }

         float curveDistB = calcCurveDistB();
         float curveDistP = calcCurveDistP();

         if(b_rcurve)
         {
            // trace "xxx rcurve edge="+edge.getString()+" tailDir="+edge.ui_tail_dir+" headDir="+edge.ui_head_dir+" b_curve_c="+b_curve_c;
            // trace "xxx rcurve edge="+edge.getString()+" abs_tail=("+abs_x_tail+";"+abs_y_tail+") abs_head=("+abs_x_head+";"+abs_y_head+") edge.ui_tail_dir="+edge.ui_tail_dir;
            local FloatArray rcurveVertices <= (b_graphedge_shapes && #ffff != pattern) ? new FloatArray : curve_vertices;

            rcurveVertices.add2(abs_x_tail, abs_y_tail);
            switch(edge.ui_tail_dir)
            {
               case Layout.TOP:
                  switch(edge.ui_head_dir)
                  {
                     case Layout.TOP:
                        // t -> t (ILL)
                        break;

                     case Layout.LEFT:
                        // t -> l
                        rcurveVertices.add2(abs_x_tail, abs_y_head);
                        break;

                     case Layout.BOTTOM:
                        // t -> b
                        rcurveVertices.add2(abs_x_tail, (abs_y_tail + abs_y_head)*0.5f);
                        rcurveVertices.add2(abs_x_head, (abs_y_tail + abs_y_head)*0.5f);
                        break;

                     case Layout.RIGHT:
                        // t -> r
                        rcurveVertices.add2(abs_x_tail, abs_y_head);
                        break;
                  }
                  break;

               case Layout.LEFT:
                  switch(edge.ui_head_dir)
                  {
                     case Layout.TOP:
                        // l -> t
                        rcurveVertices.add2(abs_x_head, abs_y_tail);
                        break;

                     case Layout.LEFT:
                        // l -> l (ILL)
                        break;

                     case Layout.BOTTOM:
                        // l -> b
                        rcurveVertices.add2(abs_x_head, abs_y_tail);
                        break;

                     case Layout.RIGHT:
                        // l -> r
                        // if(n_head.b_helper || n_head.b_ui_helper)  // (todo)
                        // {
                        //    rcurveVertices.add2(abs_x_tail, abs_y_head);
                        // }
                        // else
                        {
                           rcurveVertices.add2((abs_x_tail + abs_x_head)*0.5f, abs_y_tail);
                           rcurveVertices.add2((abs_x_tail + abs_x_head)*0.5f, abs_y_head);
                        }
                        break;
                  }
                  break;

               case Layout.BOTTOM:
                  switch(edge.ui_head_dir)
                  {
                     case Layout.TOP:
                        // b -> t
                        if(n_head.b_helper || n_head.b_ui_helper)
                        {
                           rcurveVertices.add2(abs_x_tail, abs_y_head);
                        }
                        else
                        {
                           rcurveVertices.add2(abs_x_tail, (abs_y_tail + abs_y_head)*0.5f);
                           rcurveVertices.add2(abs_x_head, (abs_y_tail + abs_y_head)*0.5f);
                        }
                        break;

                     case Layout.LEFT:
                        // b -> l
                        rcurveVertices.add2(abs_x_tail, abs_y_head);
                        break;

                     case Layout.BOTTOM:
                        // b -> b (ILL)
                        break;

                     case Layout.RIGHT:
                        // b -> r
                        rcurveVertices.add2(abs_x_tail, abs_y_head);
                        break;
                  }
                  break;

               case Layout.RIGHT:
                  switch(edge.ui_head_dir)
                  {
                     case Layout.TOP:
                        // r -> t
                        rcurveVertices.add2(abs_x_head, abs_y_tail);
                        break;

                     case Layout.LEFT:
                        // r -> l
                        if(n_head.b_helper || n_head.b_ui_helper)
                        {
                           rcurveVertices.add2(abs_x_head, abs_y_tail);
                        }
                        else
                        {
                           rcurveVertices.add2((abs_x_tail + abs_x_head)*0.5f, abs_y_tail);
                           rcurveVertices.add2((abs_x_tail + abs_x_head)*0.5f, abs_y_head);
                        }
                        break;

                     case Layout.BOTTOM:
                        // r -> b
                        rcurveVertices.add2(abs_x_head, abs_y_tail);
                        break;

                     case Layout.RIGHT:
                        // r -> r (ILL)
                        break;
                  }
                  break;
            }

            rcurveVertices.add2(abs_x_head, abs_y_head);

            // trace "xxx        rcurveVertices="+rcurveVertices.string2;
            ShapePolyline.RemoveDuplicateVertices(rcurveVertices, false/*bClosed*/);
            // trace "xxx rcurveVertices<nodup>="+rcurveVertices.string2;

            if(b_graphedge_shapes && #ffff != pattern)
            {
               ShapePolyline.SubdividePolylineVertices(curve_vertices, rcurveVertices, curveDistB, curveDistP, false/*bClosed*/);
               // // ShapePolyline.RemoveDuplicateVertices(curve_vertices, false/*bClosed*/);
            }
         }
         else
         {
            // trace "xxx curve edge="+edge.getString()+" abs_tail=("+abs_x_tail+";"+abs_y_tail+") abs_head=("+abs_x_head+";"+abs_y_head+")";
            local FloatArray curveVertsPreSubdiv; curveVertsPreSubdiv.empty();

            local FloatArray curveVerts <= (#ffff != pattern) ? curveVertsPreSubdiv : curve_vertices;
            curveVerts.bezierCubicDeCasteljau2d(abs_x_tail, abs_y_tail,   // p1
                                                c1x, c1y,
                                                c2x, c2y,
                                                abs_x_head, abs_y_head,   // p2
                                                1.0, 1.0,   // scale x/y
                                                9,          // recursion limit
                                                curveDistB, // bendiness threshold
                                                curveDistP, // distance threshold
                                                null/*retCurveTArray*/
                                                );

            if(#ffff != pattern)
            {
               // trace "~~~~~~~ eqdist BEGIN";
               curve_vertices.empty();
               ShapePolyline.AppendEqualDistVertices(curve_vertices,
                                                     curveVerts,
                                                     curveDistP,
                                                     false/*bClosed*/
                                                     );
               // trace "xxx curve_vertices="+curve_vertices.string2;
            }

            // // ShapePolyline.RemoveDuplicateVertices(curve_vertices, false/*bClosed*/);
            // trace "~~~~~~~ eqdist curve_vertices="+curve_vertices.string2;

            // if(#ffff != pattern)
            //    trace "xxx pattern, #curve_vertices="+(curve_vertices.numElements/2);
         }

         if(b_gf_debug3) trace "[dbg] GraphForm::tesselateCurve: "+edge.getString()+" bezier curve has "+(curve_vertices.numElements/2)+" vertices.";
         if(b_gf_debug3) trace "[trc] GraphForm::tesselateCurve:    tail=("+abs_x_tail+";"+abs_y_tail+") head=("+abs_x_head+";"+abs_y_head+")";
         if(0 && b_gf_debug)
         {
            int i = 0;
            loop(curve_vertices.numElements/2)
            {
               trace "[trc]     v["+(i/2)+"] = ("+curve_vertices.get(i)+";"+curve_vertices.get(i+1)+")";
               i += 2;
            }
         }

      } // if b_curve
   }

   protected method lazyCreateCurveShape() {
      if(b_graphedge_shapes && null == curve_shape)
      {
         // trace "xxx b_curve="+b_curve+" b_line="+b_line+" width="+width+" width_left="+width_left;
         if(b_curve)
         {
            curve_shape <= ShapePolyline.New(curve_vertices, fgcolor, width*0.5, pattern);  // (note) default alpha is 255
         }
         else if(b_line)
         {
            float curveDistB = calcCurveDistB();
            float curveDistP = calcCurveDistP();
            local FloatArray faLine <= new FloatArray;
            faLine.bezierCubicDeCasteljau2d(abs_x_tail, abs_y_tail,   // p1
                                            abs_x_head, abs_y_head,   // c1 (straight line)
                                            abs_x_tail, abs_y_tail,   // c2 (straight line)
                                            abs_x_head, abs_y_head,   // p2
                                            1.0, 1.0,   // scale x/y
                                            9,          // recursion limit
                                            curveDistB, // bendiness threshold
                                            curveDistP, // distance threshold
                                            null/*retCurveTArray*/
                                            );

            curve_shape <= ShapePolyline.New(faLine, fgcolor, width*0.5, pattern);  // (note) default alpha is 255
            curve_shape.tesselate();
         }

         if(null != curve_shape)
         {
            if(width_start != width_end)
               curve_shape.calcLineWidthArrayFromVertices(width_start*0.5, width_end*0.5, width_exp);

            if(width_left > 0.0f)
            {
               ShapePolyline shapeL <= curve_shape.getOrCreateShapeLeft();
               shapeL.setForegroundColor(fgcolor_left);
               shapeL.setAlpha(255);
               shapeL.setLineWidth(width_left * 0.5);
               shapeL.setEnableAdaptiveWidth(b_width_adaptive);
               shapeL.setAdaptiveWidthMin(width_adaptive_min*0.5);
               shapeL.setAdaptiveWidthMax(width_adaptive_max*0.5);
               // // shapeL.setLineJointType(lineJointType);
               // // shapeL.setMiterLimit(miterLimit);
               // // shapeL.setEnableClosed(bClosed);
            }

            if(width_right > 0.0f)
            {
               ShapePolyline shapeR <= curve_shape.getOrCreateShapeRight();
               shapeR.setForegroundColor(fgcolor_right);
               shapeR.setAlpha(255);
               shapeR.setLineWidth(width_right * 0.5);
               shapeR.setEnableAdaptiveWidth(b_width_adaptive);
               shapeR.setAdaptiveWidthMin(width_adaptive_min * 0.5);
               shapeR.setAdaptiveWidthMax(width_adaptive_max * 0.5);
               // // shapeR.setLineJointType(lineJointType);
               // // shapeR.setMiterLimit(miterLimit);
               // // shapeR.setEnableClosed(bClosed);
            }

            curve_shape.tesselate();
         }
      }
   }

   protected method setEdgeStyle(int _edgeStyle) {

      switch(_edgeStyle)
      {
         default:
         case Edge.STYLE_NORMAL:
            pattern = #FFFF;
            width   = 1.0f * UI.font_scaling;
            b_arrow_head = !edge.b_rev && !n_head.b_helper;
            b_arrow_tail =  edge.b_rev && !n_head.b_helper;
            break;

         case Edge.STYLE_DOTTED:
            if(bCanDoLineStipple || b_graphedge_shapes)
               pattern = #CCCC;  // not working on macOS (line disappears)
            else
               pattern = #FFFF;
            width   = 1.0f * UI.font_scaling;
            b_arrow_head = !edge.b_rev && !n_head.b_helper;
            b_arrow_tail =  edge.b_rev && !n_head.b_helper;
            break;

         case Edge.STYLE_DASHED:
            if(bCanDoLineStipple || b_graphedge_shapes)
               pattern = #F8F8;  // not working on macOS (line disappears)
            else
               pattern = #FFFF;
            width   = 1.0f * UI.font_scaling;
            b_arrow_head = !edge.b_rev && !n_head.b_helper;
            b_arrow_tail =  edge.b_rev && !n_head.b_helper;
            break;

         case Edge.STYLE_BOLD:
            pattern = #FFFF;
            width   = 2.0f * UI.font_scaling;
            b_arrow_head = !edge.b_rev && !n_head.b_helper;
            b_arrow_tail =  edge.b_rev && !n_head.b_helper;
            break;

         case Edge.STYLE_HIDDEN:
            pattern = 0;
            width   = 0.0f;
            fgcolor = 0;
            break;

         case Edge.STYLE_UNDIR:
            pattern = #ffff;
            width   = 1.0f * UI.font_scaling;
            break;

         case Edge.STYLE_BIDIR:
            pattern = #ffff;
            width   = 1.0f * UI.font_scaling;
            b_arrow_head = !n_head.b_helper;
            b_arrow_tail = !n_tail.b_helper;
            break;
      }

      b_arrow_solid = true;
      if(edge.haveEdgeAttrib("arrow_style"))
         b_arrow_solid = ("solid" == edge.getEdgeAttrib("arrow_style"));

      // (todo) "arrow_shape" attribute
      if(edge.haveEdgeAttrib("arrow_shape"))
      {
         String sShape <= edge.getEdgeAttrib("arrow_shape");  // (todo) should be in readArrowAttribs() ?
         if("none" == sShape)
         {
            b_arrow_head = false;
            b_arrow_tail = false;
         }
      }

   }

   protected method calcArrowVerticesInt(float _srcX, float _srcY, float _dstX, float _dstY,
                                         Point2f _pL, Point2f _pR, Point2f _pDst, Point2f _pInner,
                                         boolean _bTail,
                                         GraphEdgeArrow _arrow
                                         ) {
      float d  = _arrow.len;   // 12.0
      // // float di = (_arrow.len - _arrow.len * _arrow.ilen_amt);
      float a  = _arrow.angle; // 35.0;

      float nx = (_dstX - _srcX);
      float ny = (_dstY - _srcY);
      float nxSnap = nx;
      float nySnap = ny;
      float l  = 1.0f / sqrt(nx*nx + ny*ny);
      nx *= l;
      ny *= l;

      // trace "xxx calcArrowVerticesInt: n=("+nx+";"+ny+") l="+l+" edge.ui_dir_flags="+edge.ui_dir_flags+" arrow.snap_amt="+_arrow.snap_amt+" src=("+_srcX+";"+_srcY+") dst=("+_dstX+";"+_dstY+")";

      if(_arrow.snap_amt > 0.0f)
      {
         // trace "xxx n=("+nx+";"+ny+")";

         if(1)
         {
            int dirFlags = edge.ui_dir_flags;
            if(_bTail)
               dirFlags = Layout.SwapDirFlags(dirFlags);

            if(dirFlags & Layout.TOP)
            {
               if(dirFlags & Layout.LEFT)
               {
                  // dst is on the top/left side of src
                  nxSnap =  0.0f;
                  nySnap = -1.0f;
               }
               else
               {
                  // dst is on the top/right side of src
                  if(edge.b_ui_xmajor_head)
                  {
                     nxSnap = 1.0f;
                     nySnap = 0.0f;
                  }
                  else
                  {
                     nxSnap =  0.0f;
                     nySnap = -1.0f;
                  }
               }
            }
            else if(dirFlags & Layout.BOTTOM)
            {
               if(dirFlags & Layout.LEFT)
               {
                  // dst is on the bottom/left side of src
                  nxSnap = 0.0f;
                  nySnap = 1.0f;
               }
               else
               {
                  // dst is on the bottom/right side of src
                  if(edge.b_ui_xmajor_head)
                  {
                     nxSnap = 1.0f;
                     nySnap = 0.0f;
                  }
                  else
                  {
                     nxSnap = 0.0f;
                     nySnap = 1.0f;
                  }
               }
            }
            else if(dirFlags & Layout.LEFT)
            {
               // dst is on the left side of src
               nxSnap = -1.0f;
               nySnap = 0.0f;
            }
            else
            {
               // dst is on the right side of src
               nxSnap = 1.0f;
               nySnap = 0.0f;
            }
         }
         else
         {
            if(abs(nx) > abs(ny))
            {
               if(nx >= 0.0f)
                  nxSnap = 1.0f;
               else
                  nxSnap = -1.0f;
               _dstY -= nySnap * 0.25f * _arrow.snap_amt;
               nySnap = 0.0f;
            }
            else
            {
               if(ny >= 0.0f)
                  nySnap = 1.0f;
               else
                  nySnap = -1.0f;
               _dstX -= nxSnap * 0.25f * _arrow.snap_amt;
               nxSnap = 0.0f;
            }
         }

         nx = mathLerpf(nx, nxSnap, _arrow.snap_amt);
         ny = mathLerpf(ny, nySnap, _arrow.snap_amt);
         l  = 1.0f / sqrt(nx*nx + ny*ny);
         nx *= l;
         ny *= l;
      }

      nx *= d;
      ny *= d;

      float al = (-a * 2PI) * (1.0f/360);
      float s = sin(al);
      float c = cos(al);
      float lx = c*nx - s*ny;
      float ly = s*nx + c*ny;

      float ar = (a * 2PI) * (1.0f/360);
      s = sin(ar);
      c = cos(ar);
      float rx = c*nx - s*ny;
      float ry = s*nx + c*ny;

      _pL.init(_dstX - lx, _dstY - ly);
      _pR.init(_dstX - rx, _dstY - ry);
      _pDst.init(_dstX, _dstY);

      _pInner.init((_pL.x + _pR.x) * 0.5, (_pL.y + _pR.y) * 0.5);
      nx = _pDst.x - _pInner.x;
      ny = _pDst.y - _pInner.y;
      l = _arrow.ilen_amt;
      _pInner.init(_pInner.x + nx*l, _pInner.y + ny*l);

   }

   public method calcArrowVertices() {
      if(b_curve)
      {
         if(b_arrow_head)
         {
            calcArrowVerticesInt(curve_vertices.get(curve_vertices.numElements - 4 +0),
                                 curve_vertices.get(curve_vertices.numElements - 4 +1),
                                 curve_vertices.get(curve_vertices.numElements - 4 +2),
                                 curve_vertices.get(curve_vertices.numElements - 4 +3),
                                 cached_arrow_head_l,
                                 cached_arrow_head_r,
                                 cached_arrow_head_dst,
                                 cached_arrow_head_inner,
                                 false/*bTail*/,
                                 arrow
                                );
            abs_x_head = (cached_arrow_head_l.x + cached_arrow_head_r.x) * 0.5;
            abs_y_head = (cached_arrow_head_l.y + cached_arrow_head_r.y) * 0.5;
            // trace "xxx ----------- edge="+edge.getString();
            // trace "xxx edgeLR=("+abs_x_head+";"+abs_y_head+")";
            abs_x_head = cached_arrow_head_inner.x;
            abs_y_head = cached_arrow_head_inner.y;
            // trace "xxx edgeInner=("+abs_x_head+";"+abs_y_head+")";
            curve_vertices[curve_vertices.numElements - 4 +2] = abs_x_head;
            curve_vertices[curve_vertices.numElements - 4 +3] = abs_y_head;
         }

         if(b_arrow_tail)
         {
            calcArrowVerticesInt(curve_vertices.get(2),
                                 curve_vertices.get(3),
                                 curve_vertices.get(0),
                                 curve_vertices.get(1),
                                 cached_arrow_tail_l,
                                 cached_arrow_tail_r,
                                 cached_arrow_tail_dst,
                                 cached_arrow_tail_inner,
                                 true/*bTail*/,
                                 arrow_rev
                                 );
            abs_x_tail = cached_arrow_tail_inner.x;
            abs_y_tail = cached_arrow_tail_inner.y;
            curve_vertices[0] = abs_x_tail;
            curve_vertices[1] = abs_y_tail;
         }
      }
      else // "line" or "none"
      {
         int srcX = int(abs_x_tail);
         int srcY = int(abs_y_tail);
         int dstX = int(abs_x_head);
         int dstY = int(abs_y_head);

         if(b_arrow_head)
         {
            calcArrowVerticesInt(srcX, srcY,
                                 dstX, dstY,
                                 cached_arrow_head_l,
                                 cached_arrow_head_r,
                                 cached_arrow_head_dst,
                                 cached_arrow_head_inner,
                                 false/*bTail*/,
                                 arrow
                                 );
            abs_x_head = cached_arrow_head_inner.x;
            abs_y_head = cached_arrow_head_inner.y;
         }

         if(b_arrow_tail)
         {
            calcArrowVerticesInt(dstX, dstY,
                                 srcX, srcY,
                                 cached_arrow_tail_l,
                                 cached_arrow_tail_r,
                                 cached_arrow_tail_dst,
                                 cached_arrow_tail_inner,
                                 true/*bTail*/,
                                 arrow_rev
                                 );
            abs_x_tail = cached_arrow_tail_inner.x;
            abs_y_tail = cached_arrow_tail_inner.y;
         }
      }
   }

   protected method drawArrow(Point2f _pL, Point2f _pR, Point2f _pDst, Point2f _pInner, GraphEdgeArrow _arrow) {

      if(0)
      {
         trace "xxx GraphEdge::drawArrow: l=("+_pL.x+";"+_pL.y+")";
         trace "xxx GraphEdge::drawArrow: dst=("+_pDst.x+";"+_pDst.y+")";
         trace "xxx GraphEdge::drawArrow: inner=("+_pInner.x+";"+_pInner.y+")";
         trace "xxx GraphEdge::drawArrow: r=("+_pR.x+";"+_pR.y+")";
      }

      if(b_arrow_solid)
      {
         UIRenderer.SetColorARGB(_arrow.fgcolor);

         if(_arrow.ilen_amt > 0.0f)
         {
            if(UIRenderer.BeginFilledTriangles(6))
            {
               UIRenderer.Vertex2f(_pL.x,     _pL.y);
               UIRenderer.Vertex2f(_pDst.x,   _pDst.y);
               UIRenderer.Vertex2f(_pInner.x, _pInner.y);

               UIRenderer.Vertex2f(_pR.x,     _pR.y);
               UIRenderer.Vertex2f(_pInner.x, _pInner.y);
               UIRenderer.Vertex2f(_pDst.x,   _pDst.y);
               UIRenderer.End();
            }

            if(_arrow.border_width > 0.1f)
            {
               UIRenderer.SetColorARGB(_arrow.border_color);
               UIRenderer.SetLineWidth(_arrow.border_width*UI.supersample_factor);
               UIRenderer.BeginLineStripAA(5);
               UIRenderer.Vertex2f(_pL.x,     _pL.y);
               UIRenderer.Vertex2f(_pDst.x,   _pDst.y);
               UIRenderer.Vertex2f(_pR.x,     _pR.y);
               UIRenderer.Vertex2f(_pInner.x, _pInner.y);
               UIRenderer.Vertex2f(_pL.x,     _pL.y);
               UIRenderer.End();
               UIRenderer.SetLineWidth(1.0f);
            }
         }
         else
         {
            // triangle
            if(UIRenderer.BeginFilledTriangles(3))
            {
               UIRenderer.Vertex2f(_pL.x,   _pL.y);
               UIRenderer.Vertex2f(_pDst.x, _pDst.y);
               UIRenderer.Vertex2f(_pR.x,   _pR.y);
               UIRenderer.End();
            }

            if(_arrow.border_width > 0.1f)
            {
               UIRenderer.SetColorARGB(_arrow.border_color);
               UIRenderer.SetLineWidth(_arrow.border_width*UI.supersample_factor);
               if(UIRenderer.BeginLineStripAA(4))
               {
                  UIRenderer.Vertex2f(_pL.x,   _pL.y);
                  UIRenderer.Vertex2f(_pDst.x, _pDst.y);
                  UIRenderer.Vertex2f(_pR.x,   _pR.y);
                  UIRenderer.Vertex2f(_pL.x,   _pL.y);
                  UIRenderer.End();
               }
               UIRenderer.SetLineWidth(1.0f);
            }
         }
      }
      else
      {
         UIRenderer.SetLineWidth(_arrow.linewidth*UI.supersample_factor);
         UIRenderer.DrawLineAA(_pL.x, _pL.y, _pDst.x, _pDst.y, _arrow.fgcolor);
         UIRenderer.DrawLineAA(_pR.x, _pR.y, _pDst.x, _pDst.y, _arrow.fgcolor);
         UIRenderer.SetLineWidth(1.0f);
      }
   }

   protected method appendSVGArrowInt(String _buf, Point2f _pL, Point2f _pR, Point2f _pDst, Point2f _pInner, GraphEdgeArrow _arrow) {

      if(0)
      {
         trace "xxx GraphEdge::drawArrow: l=("+_pL.x+";"+_pL.y+")";
         trace "xxx GraphEdge::drawArrow: dst=("+_pDst.x+";"+_pDst.y+")";
         trace "xxx GraphEdge::drawArrow: inner=("+_pInner.x+";"+_pInner.y+")";
         trace "xxx GraphEdge::drawArrow: r=("+_pR.x+";"+_pR.y+")";
      }

      local String *sPathBegin;
      local String *sPathEnd;

      if(b_arrow_solid)
      {
         sPathBegin <= "  <path fill="+GraphForm.GetSVGColorString(_arrow.fgcolor&0xFFffFF);

         if(_arrow.border_width > 0.1f)
         {
            sPathBegin.append(" stroke="+GraphForm.GetSVGColorString(_arrow.border_color & 0xFFffFF));
            sPathBegin.append(" stroke-width=\""+_arrow.border_width+"\"");
         }

         sPathEnd <= " z\"/>\n";

         if(_arrow.ilen_amt > 0.0f)
         {
            _buf.append(sPathBegin);
            _buf.append(" d=\"M"+_pL.x+" "+_pL.y+" L"+_pDst.x+" "+_pDst.y);
            _buf.append(" L"+_pR.x+" "+_pR.y);
            _buf.append(" L"+_pInner.x+" "+_pInner.y);
            _buf.append(sPathEnd);
         }
         else
         {
            // triangle
            _buf.append(sPathBegin);
            _buf.append(" d=\"M "+_pL.x+" "+_pL.y+" L "+_pDst.x+" "+_pDst.y);
            _buf.append(" L "+_pR.x+" "+_pR.y);
            _buf.append(sPathEnd);
         }
      }
      else
      {
         sPathBegin <= "  <path stroke="+GraphForm.GetSVGColorString(_arrow.fgcolor&0xFFffFF);
         sPathBegin.append(" stroke-width:"+_arrow.linewidth);
         sPathEnd   <= " z\"/>\n";

         _buf.append(sPathBegin);
         _buf.append(" d=\"M"+_pL.x+" "+_pL.y);
         _buf.append(" L"+_pDst.x+" "+_pDst.y);
         _buf.append(" L"+_pR.x+" "+_pR.y);
         _buf.append(sPathEnd);
      }
   }

   public method translate2f(float _tx, float _ty) {
      abs_x_tail += _tx;
      abs_y_tail += _ty;

      abs_x_head += _tx;
      abs_y_head += _ty;

      cached_arrow_head_l.x += _tx;
      cached_arrow_head_l.y += _ty;

      cached_arrow_head_r.x += _tx;
      cached_arrow_head_r.y += _ty;

      cached_arrow_head_dst.x += _tx;
      cached_arrow_head_dst.y += _ty;

      cached_arrow_head_inner.x += _tx;
      cached_arrow_head_inner.y += _ty;

      cached_arrow_tail_l.x += _tx;
      cached_arrow_tail_l.y += _ty;

      cached_arrow_tail_r.x += _tx;
      cached_arrow_tail_r.y += _ty;

      cached_arrow_tail_dst.x += _tx;
      cached_arrow_tail_dst.y += _ty;

      cached_arrow_tail_inner.x += _tx;
      cached_arrow_tail_inner.y += _ty;

      curve_c1x += _tx;
      curve_c1y += _ty;

      curve_c2x += _tx;
      curve_c2y += _ty;

      if(b_curve)
      {
         int j = 0;
         loop(curve_vertices.numElements / 2)
         {
            curve_vertices[j + 0] = curve_vertices[j + 0] + _tx;
            curve_vertices[j + 1] = curve_vertices[j + 1] + _ty;
            j += 2;
         }
      }
   }

   public method draw() {
      if(b_gf_debug3)
         trace "[>>>] draw ge: e="+edge.getString()+" from=("+abs_x_tail+";"+abs_y_tail+") to=("+abs_x_head+";"+abs_y_head+")";

      if(!UIRenderer.b_glcore)
         glLineStipple(2, pattern);
      UIRenderer.SetLineWidth(width*UI.supersample_factor);

      lazyCreateCurveShape();

      if(null != curve_shape)
      {
         curve_shape.draw();
      }
      else if(b_curve)
      {
         // "edge_shape" = "curve" | "rcurve"
         UIRenderer.SetColorARGB(fgcolor);
         if(UIRenderer.BeginLineStrip(curve_vertices.numElements/2))
         {
            UIRenderer.Vertex2f(curve_vertices.get(0),
                                curve_vertices.get(1)
                                );
            int j = 2;
            loop(curve_vertices.numElements/2 - 1)
            {
               float nx = curve_vertices.get(j++);
               float ny = curve_vertices.get(j++);
               UIRenderer.Vertex2f(nx, ny);
            }
            UIRenderer.End();
         }
      }
      else if(b_line)
      {
         // "edge_shape" = "line"
         int srcX = int(abs_x_tail);
         int srcY = int(abs_y_tail);
         int dstX = int(abs_x_head);
         int dstY = int(abs_y_head);
         UIRenderer.DrawLineAA(srcX, srcY, dstX, dstY, fgcolor);
      }

      UIRenderer.SetLineWidth(1.0f);

      if(b_arrow_tail)
         drawArrow(cached_arrow_tail_l, cached_arrow_tail_r, cached_arrow_tail_dst, cached_arrow_tail_inner, arrow_rev);

      if(b_arrow_head)
         drawArrow(cached_arrow_head_l, cached_arrow_head_r, cached_arrow_head_dst, cached_arrow_head_inner, arrow);
   }

   public method appendSVGArrow(String _buf) {
      if(b_arrow_tail)
         appendSVGArrowInt(_buf, cached_arrow_tail_l, cached_arrow_tail_r, cached_arrow_tail_dst, cached_arrow_tail_inner, arrow_rev);

      if(b_arrow_head)
         appendSVGArrowInt(_buf, cached_arrow_head_l, cached_arrow_head_r, cached_arrow_head_dst, cached_arrow_head_inner, arrow);
   }

}


// <class.png>
class TableGraphPanel : Panel {
   GraphForm *parent_graph_form;
   Graph *subgraph;  // table subgraph ref
   Node *[] *a_span_start_nodes;
   int max_span_w;
   int num_rows;

   public method initTableGraphPanel(GraphForm _graphForm, Graph _subgraph) {
      initPanel();
      setEnableDecorative(true);
      setPanelBackgroundStyle(Panel.STYLE_SOLID);
      setPanelBackgroundShape(Panel.SHAPE_RECT);
      setPanelBorderWidth(0.0f);

      parent_graph_form <= _graphForm;
      subgraph <= _subgraph;

      a_span_start_nodes <= new PointerArray;
      max_span_w = 0;
   }

   public virtual layoutHierarchy(local boolean _bInvalidateSizeCaches, local boolean _bLayoutFinal) {

      Panel::layoutHierarchy(_bInvalidateSizeCaches, _bLayoutFinal);

      if(!_bLayoutFinal)
      {
         // // trace "xxx a_span_start_nodes="+#(a_span_start_nodes);
         parent_graph_form.layoutTableLayers(subgraph, max_span_w, num_rows, false/*bLargestFirst*/, a_span_start_nodes);
         if(b_gf_debug4)
            trace "[trc] TableGraphPanel::layoutHierarchy: subgraph.id='"+subgraph.id+"' this.getDebugString()="+this.getDebugString();
      }

   }
}


// <class.png>
class GraphForm : Form {
   define float MAX_PADDING = 1024.0f;
   define float MAX_LABEL_INNER_PADDING = 512.0f;
   define float MAX_LABEL_ICON_PADDING = 128.0f;

   protected GR *gr;
   public String last_gr_pathname;

   Graph *graph;  // ref to gr.main_graph

   protected GraphForm *parent_graph_form;  // or null

   define int ST_INIT_NODES = 0;  // 0=add nodes
   define int ST_INIT_EDGES = 1;  // 1=nodes added, add edges
   define int ST_INIT_DONE  = 2;  // 2=edges added, all done
   protected int graph_ui_init_state;

   protected GraphEdge *[] graph_edges;
   protected boolean b_graph_edges_translated;

   protected StringArray *include_paths;

   protected GraphPortButton *port_button_class;  // must be derived from GraphPortButton


   public method initGraphForm(GraphForm _parent) {
      initPanel();
      setEnableCollapse(true);
      setPanelBorderWidth(0.0f);
      setEditable(true);
      setPanelBackgroundStyle(Panel.STYLE_SOLID);
      parent_graph_form <= _parent;
      port_button_class <= GraphPortButton;
   }

   public method setPortButtonClass(GraphPortButton _class) {
      port_button_class <= _class;
   }

   public static GetGRAttrib(HashTable ht, String key, String defValue) : String {
      if(ht.exists(key))
         return ht[key];
      return defValue;
   }

   public static GetGRAttribInt(HashTable ht, String key, int defValue) : int {
      if(ht.exists(key))
         return ht[key];
      return defValue;
   }

   public static GetGRAttribFloat(HashTable ht, String key, float defValue) : float {
      if(ht.exists(key))
         return ht[key];
      return defValue;
   }

   protected method setLabelTextPlacementFromGRAttribs(Label _lb, HashTable _ht) : int {
      if(_ht.exists("text_pos"))
      {
         String sTextPos <= _ht["text_pos"];
         local StringArray atsplit <= sTextPos.toLower().splitChar(';');
         int placement = Layer.ParseAlignmentFlagsFromArray(atsplit);
         if(0 != placement)
         {
            _lb.setTextPlacement(placement);
            return placement;
         }
      }
      return 0;
   }

   protected method setLabelIconPlacementFromGRAttribs(Label _lb, HashTable _ht) : int {
      if(_ht.exists("icon_pos"))
      {
         String sIconPos <= _ht["icon_pos"];
         local StringArray atsplit <= sIconPos.toLower().splitChar(';');
         int placement = Layer.ParseAlignmentFlagsFromArray(atsplit);
         if(0 != placement)
         {
            _lb.setIconPlacement(placement);
            return placement;
         }
      }
      return 0;
   }

   protected method setLabelConfigFromGRAttribs(Label _lb, String _sLabel, HashTable _ht) {

      if(_ht.exists("font"))
         _lb.setFontByName(_ht["font"]);
      else
         _lb.setFontByName("default");  // fallback to default font

      _lb.setTextPlacement(Layout.CENTER | Layout.BASELINEY);  // default text placement
      // // _lb.setTextPlacement(Layout.LEFT);
      setLabelTextPlacementFromGRAttribs(_lb, _ht/*n.gr_attribs*/);

      if(_ht.exists("icon"))
         _lb.setIconByName(_ht["icon"]);
      setLabelIconPlacementFromGRAttribs(_lb, _ht/*n.gr_attribs*/);
      setLabelIconPaddingFromGRAttribs(_lb, _ht/*n.gr_attribs*/);

      if(!(_lb instanceof ComboBox) && !(_lb instanceof CheckBox))
         setLabelInnerPaddingFromGRAttribs(_lb, _ht/*n.gr_attribs*/);

      local String sLabel = _sLabel;
      sLabel.replace("\\n", "\n");
      if(sLabel.isBlank() || ("none" == GetGRAttrib(_ht, "label_style", "default")))
      {
         // // UI.Backtrace();
         // // if(null != _nOrNull)
         // //    trace "xxx nocaption n="+_nOrNull.getString();
         _lb.setEnableCaption(false);
      }
      else
         _lb.setCaption(sLabel);
      ///// lb.setFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED_LARGE);
      ////bt.setFontByName("graph_node");
      // if(sLabel.isBlank())
      //    UI.Backtrace();

      if(_ht.exists("rotate"))
         _lb.setRotationByString(_ht["rotate"]);
   }

   protected method setLayerColorAndTintFromGRAttribs(Layer _l, HashTable _ht) {
      Button bt <= (_l instanceof Button) ? _l : null;

      int tintPost = _ht.exists("tint") ? int(_ht["tint"]) : 0;

      if(_ht.exists("bgcolor"))
      {
         int nodeBgColor = int(_ht["bgcolor"]) & 0x00FFFFFF;

         int tint = 0;
         if(_ht.exists("bgtint"))
            tint = sdvg_TintARGB(tint, int(_ht["bgtint"]));

         // [02Feb2025] only apply tintPost once
         // // if(0 != tintPost)
         // //    tint = sdvg_TintARGB(tint, tintPost);

         if(0 != tint)
            nodeBgColor = sdvg_TintARGB(nodeBgColor, tint);

         if(0 != tintPost)
            nodeBgColor = sdvg_TintARGB(nodeBgColor, tintPost);

         // trace "xxx button nodeBgColor="+UI.GetColorString(nodeBgColor);
         // // if(0 != nodeBgColor)
         // // {
            _l.setBackgroundColor(nodeBgColor);
            _l.setAlpha(255);
            _l.setEnableFillBackground(true);
         // // }
      }

      if(null != bt)
         bt.setEnableLabelButton(true);

      if(_ht.exists("bgfill"))
      {
         _l.setEnableFillBackground(0 != int(_ht["bgfill"]));
         if(null != bt)
            bt.setEnableLabelButton(true);
      }

      int nodeFgColor = -2; // lnf.getColor(LookAndFeel.COLOR_LABEL_CAPTION_FG);

      if(_ht.exists("label_fgcolor"))
         nodeFgColor = int(_ht["label_fgcolor"]) & 0x00FFffFF;
      else if(_ht.exists("fgcolor"))
         nodeFgColor = int(_ht["fgcolor"]) & 0x00FFffFF;

      if(-2 != nodeFgColor)
      {
         tint = 0;
         if(_ht.exists("label_fgtint"))
            tint = int(_ht["label_fgtint"]);
         else if(_ht.exists("fgtint"))
            tint = int(_ht["fgtint"]);
         if(0 != tint)
            nodeFgColor = sdvg_TintARGB(nodeFgColor, tint);
         if(0 != tintPost)
            nodeFgColor = sdvg_TintARGB(nodeFgColor, tintPost);
         _l.setForegroundColor(#ff000000 | nodeFgColor);
      }
   }

   protected method setLayerAlignmentFromGRAttribs(Layer _l, HashTable _ht) : int {
      if(_ht.exists("align"))
      {
         String sAlign <= _ht["align"];
         local StringArray atsplit <= sAlign.toLower().splitChar(';');
         int align = Layer.ParseAlignmentFlagsFromArray(atsplit);
         if(0 != align)
         {
            _l.setAlignment(align);
            return align;
         }
      }
      return 0;
   }

   protected method setPanelBackgroundPatternAndGradientFromGRAttribs(Panel _p, HashTable _ht) {

      if(_ht.exists("bg_blend"))
         _p.setPanelBackgroundBlend( Panel.ParsePanelBlendFromString(_ht["bg_blend"]) );

      if(_ht.exists("bg_pattern") && "none" != _ht["bg_pattern"])
      {
         _p.setPanelBackgroundPatternByName(_ht["bg_pattern"]);

         if(_ht.exists("bg_pattern_intensity"))
         {
            local String sIntensity = _ht["bg_pattern_intensity"];
            if(sIntensity & "%")
               _p.setPanelBackgroundPatternIntensity(float(sIntensity.replace("%",""))/100.0f);
            else
               _p.setPanelBackgroundPatternIntensity(_ht["bg_pattern_intensity"]);
         }
      }

      if(_ht.exists("bg_gradient"))
      {
         // trace "xxx find gradient \""+_ht["bg_gradient"]+"\"";
         GRGradient gradient <= gr.findGradient(_ht["bg_gradient"]);
         if(null != gradient)
         {
            _p.setPanelBackgroundGradientTexture(gradient.getOrCreateTexture());

            if(_ht.exists("bg_gradient_shape"))
               _p.setPanelBackgroundGradientShape( Panel.ParsePanelGradientShapeFromString(_ht["bg_gradient_shape"]) );
         }
         else
         {
            trace "[~~~] GraphForm::setPanelBackgroundPatternAndGradientFromGRAttribs: undeclared gradient '"+_ht["bg_gradient"]+"', skipping..";
         }
      }
   }

   protected method setPanelBorderFromGRAttribs(Panel _p, HashTable _ht) {
      // // boolean bBorder = false;

      if(_ht.exists("border_width"))
      {
         _p.setPanelBorderWidth(mathMaxf(0, _ht["border_width"]));
         _p.setPanelBorderDir(Layout.CENTER/*all*/);
         _p.setPanelBorderStyle(Panel.STYLE_SOLID);
      }

      if(_ht.exists("border_color"))
      {
         int c32 = int(_ht["border_color"]);

         int tint = 0;
         if(_ht.exists("border_tint"))
            tint = _ht["border_tint"];
         if(0 != tint)
            c32 = sdvg_TintARGB(c32, tint);

         int tintPost = _ht.exists("tint") ? int(_ht["tint"]) : 0;
         if(0 != tintPost)
            c32 = sdvg_TintARGB(c32, tintPost);
         _p.setPanelBorderColor( #ff000000 | c32 );
      }

      if(_ht.exists("border_dir"))
      {
         String sDir <= _ht["border_dir"];
         local StringArray atsplit <= sDir.toLower().splitChar(';');
         int dir = Layer.ParseAlignmentFlagsFromArray(atsplit);
         if(0 != dir)
            _p.setPanelBorderDir(dir);
      }

      if(_ht.exists("shape"))
         _p.setPanelShape( Panel.ParsePanelShapeFromString(_ht["shape"]) );   // (note) update both bg_shape and border_shape

      if(_ht.exists("border_shape"))
         _p.setPanelBorderShape( Panel.ParsePanelShapeFromString(_ht["border_shape"]) );

      if(_ht.exists("shape_round_amount"))
         _p.setPanelShapeRoundAmount(GRUtils.GetAttribAmount(_ht, "shape_round_amount"));

      if(_ht.exists("shape_round_aspect"))
         _p.setPanelShapeRoundAspect(_ht["shape_round_aspect"]);

      if(_ht.exists("shape_round_limit"))
         _p.setPanelShapeRoundLimit(_ht["shape_round_limit"]);

      if(_ht.exists("shape_rhomb_tx"))
         _p.setPanelShapeRhombTx(_ht["shape_rhomb_tx"]);

      if(_ht.exists("shape_rhomb_ty"))
         _p.setPanelShapeRhombTy(_ht["shape_rhomb_ty"]);

      if(_ht.exists("shape_ellipse_rx"))
         _p.setPanelShapeEllipseRx(_ht["shape_ellipse_rx"]);

      if(_ht.exists("shape_ellipse_ry"))
         _p.setPanelShapeEllipseRy(_ht["shape_ellipse_ry"]);

      if(_ht.exists("shape_hexagon_scl"))
         _p.setPanelShapeHexagonScale(mathClampf(_ht["shape_hexagon_scl"], 0.5, 1.0f));

      if(_ht.exists("shape_hexagon_ax"))
         _p.setPanelShapeHexagonAx(mathMaxf(0.0f, _ht["shape_hexagon_ax"]));

      if(_ht.exists("shape_hexagon_ay"))
         _p.setPanelShapeHexagonAy(mathMaxf(0.0f, _ht["shape_hexagon_ay"]));

      if(_ht.exists("shape_tri_ax"))
         _p.setPanelShapeTriAx(mathMaxf(0.0f, _ht["shape_tri_ax"]));

      if(_ht.exists("shape_tri_ay"))
         _p.setPanelShapeTriAy(mathMaxf(0.0f, _ht["shape_tri_ay"]));

      if(_ht.exists("border_style"))
      {
         // trace "xxx setPanelStyle("+_ht["border_style"]+")";
         if("none" == _ht["border_style"])
            trace "xxx parse border_style=none   p="+#(_p)+" id="+_p.layer_id;
         _p.setPanelStyle( Panel.ParsePanelStyleFromString(_ht["border_style"]) );   // (note) update both bg_style and border_style
      }

      if(_ht.exists("border_blend"))
         _p.setPanelBorderBlend( Panel.ParsePanelBlendFromString(_ht["border_blend"]) );

      if(_ht.exists("border_alpha"))
         _p.setPanelBorderAlpha(mathClampi(_ht["border_alpha"], 0, 255));

      if(_ht.exists("border_pattern") && "none" != _ht["border_pattern"])
      {
         _p.setPanelBorderPatternByName(_ht["border_pattern"]);

         if(_ht.exists("border_pattern_intensity"))
            _p.setPanelBorderPatternIntensity(_ht["border_pattern_intensity"]);
      }

      if(_ht.exists("border_gradient"))
      {
         GRGradient gradient <= gr.findGradient(_ht["border_gradient"]);
         if(null != gradient)
         {
            _p.setPanelBorderGradientTexture(gradient.getOrCreateTexture());

            if(_ht.exists("border_gradient_shape"))
               _p.setPanelBorderGradientShape( Panel.ParsePanelGradientShapeFromString(_ht["border_gradient_shape"]) );
         }
         else
         {
            trace "[~~~] GraphForm::setPanelBorderFromGRAttribs: undeclared gradient '"+_ht["border_gradient"]+"', skipping..";
         }
      }

      if(_ht.exists("stack"))
         _p.setPanelStack(_ht["stack"]);

      if(_ht.exists("stack_off"))
      {
         local StringArray aStackOff <= _ht["stack_off"].replaceChar(',', ';').splitChar(';');
         _p.setPanelStackOffScaled(aStackOff.get(0),
                                   (aStackOff.numElements >= 2) ? aStackOff.get(1) : aStackOff.get(0)
                                   );
      }

      if(_ht.exists("stack_alpha_dcy"))
         _p.setPanelStackAlphaDecay(_ht["stack_alpha_dcy"]);

      if(_ht.exists("stack_alpha_exp"))
         _p.setPanelStackAlphaExponent(_ht["stack_alpha_exp"]);
   }

   protected method createPanelForLayer(Node _nOrNull, Layer _l, HashTable _ht/*gr_attribs*/, boolean _bDefAlignTopLeft) : Panel {
      Panel *lp;

      // trace "xxx createPanelForLayer: n="+Graph.GetNodeString(_nOrNull)+" ht="+#(_ht);

      // default alignment
      if(_bDefAlignTopLeft)
         _l.setAlignment(Layout.TOP | Layout.LEFT);
      else
         _l.setAlignment(Layout.EXPANDX | Layout.BASELINE);

      // alignment override
      int alignFlagsHint = setLayerAlignmentFromGRAttribs(_l, _ht);  // "align" attrib
      if(0 == alignFlagsHint)
         alignFlagsHint = Layout.EXPANDX | Layout.BASELINE;

      if(_ht.exists("shape") && "none" == _ht["shape"])
      // // if("none" == _ht.get("shape"))  // (todo) change <string> == <void> ?? (currently returns true)
      {
         // trace "xxx _ht.get("shape")=\""+_ht.get("shape")+"\"";
         // node is invisible (e.g. a connection helper node)
         Panel pInvis <= Panel.New();
         pInvis.setGraphData(_nOrNull);
         pInvis.setPadding4f(0,0,0,0);
         pInvis.setEnableCollapse(true);
         pInvis.setEnableDecorative(true);
         pInvis.setEnableFillBackground(false);
         pInvis.setPanelBackgroundShape(Panel.SHAPE_NONE);
         pInvis.setPanelBackgroundStyle(Panel.STYLE_SOLID);
         pInvis.setPanelBorderShape(Panel.SHAPE_NONE);
         pInvis.setPanelBorderWidth(0.0f);
         _l.setEnableFillBackground(false);
         // trace "xxx createPanelForLayer: n="+((null != _nOrNull)?_nOrNull.getString():"-")+" shape=none, curReqSize="+_l.getRequiredSizeString()+" align="+_l.alignment;
         if(0 == _l.getRequiredSizeX())
         {
            _l.setRequiredSizeX(1);
            pInvis.setRequiredSizeX(1);
         }
         if(0 == _l.getRequiredSizeY())
         {
            _l.setRequiredSizeY(1);
            pInvis.setRequiredSizeY(1);
         }
         _l.setPadding4f(0,0,0,0);
         pInvis.addLayer(deref _l, Layout.CENTER);

         if(0 != alignFlagsHint)
            pInvis.setAlignment(alignFlagsHint);
         else
            pInvis.setAlignment(Layout.CENTER | Layout.BASELINEY);

         if(null != _nOrNull)
         {
            _nOrNull.ui_layer <= pInvis;
            _nOrNull.ui_content_layer <= _l;
            pInvis.setLayerId("invis_"+_nOrNull.id);
         }

         return deref pInvis;
      }

      Panel p <= Panel.New();
      p.setGraphData(_nOrNull);
      p.setPadding4f(0,0,0,0);
      p.setPanelShape(Panel.SHAPE_RECT);
      p.setEnableCollapse(true);
      p.setEnableDecorative(true);
      p.setPanelBorderWidth(0.0f);
      p.setPanelBackgroundStyle(Panel.STYLE_SOLID);

      // // p.setPanelBorderStyle(Panel.STYLE_NONE);
      // // p.setPanelBackgroundStyle(Panel.STYLE_SOLID);

      if(null != _nOrNull)
         p.setLayerId("p_"+_nOrNull.id);

      Label lb <= (_l instanceof Label) ? _l : null;

      boolean bBorder = false;
      Panel pInner <= Panel.New();
      pInner.setGraphData(_nOrNull);
      pInner.setPadding4f(0,0,0,0);
      pInner.setEnableCollapse(true);
      pInner.setEnableDecorative(true);
      // // pInner.setPanelShape(Panel.SHAPE_RECT);
      pInner.setPanelBackgroundStyle(Panel.STYLE_SOLID);
      if(null != _nOrNull)
         pInner.setLayerId("pInner_"+_nOrNull.id);
      setPanelBorderFromGRAttribs(pInner, _ht);
      setPanelBackgroundPatternAndGradientFromGRAttribs(pInner, _ht);
      float pBorderWidth = pInner.getPanelBorderWidth();
      // trace "xxx createPanelForLayer: n"+n.getString()+" border_width="+pBorderWidth+" style="+pInner.getPanelBorderStyle()+" dir="+pInner.getPanelBorderDir()+" shape="+pInner.getPanelBorderShape();
      int bgShape = pInner.getPanelBackgroundShape();
      // // if( (Panel.STYLE_SOLID == pInner.getPanelBorderStyle() && pBorderWidth >= 0.25f && (Panel.SHAPE_NONE != bgShape)) || (Panel.SHAPE_DEFAULT != bgShape) )
      if( (Panel.STYLE_SOLID == pInner.getPanelBorderStyle() && pBorderWidth >= 0.25f && (Panel.SHAPE_NONE != bgShape)) || (Panel.SHAPE_DEFAULT != bgShape) )
      {
         // // pInner.setPanelAlpha(GetGRAttribInt(_ht, "bgfill", 1) ? 255 : 0);
         pInner.setEnableFillBackground(0 != GetGRAttribInt(_ht, "bgfill", 1));
         byte alpha = GetGRAttribInt(_ht, "alpha", 255);
         pInner.setAlpha(alpha);
         pInner.setPanelAlpha(alpha); // [12Sep2025]

         int borderDir = pInner.getPanelBorderDir();
         if(pBorderWidth < 0.25f || (0 == borderDir) || (Panel.SHAPE_DEFAULT != bgShape))
         {
            // pInner.setDebug(true);
            pBorderWidth += 0.5f;
            borderDir = Layout.CENTER/*all*/;
            if(_l instanceof Label)
            {
               // pInner.setPanelTint(lb.getBackgroundColor() | #ff000000);
               pInner.setBackgroundColor(lb.getBackgroundColor());
               pInner.setPanelAlpha(255);
               // trace "xxx pInner="+#(pInner)+" lb.getBackgroundColor()="+UI.GetColorString(lb.getBackgroundColor());
               lb.outer_border_panel <= pInner;
               lb.setEnableFillBackground(false); // [19Mar2024]
            }
            else if(_l instanceof Panel)
            {
               lp <= _l;
               // trace "xxx lp.panel_tint="+UI.GetColorString(lp.panel_tint);
               pInner.setBackgroundColor(lp.getBackgroundColor());
               pInner.setPanelTint(lp.panel_tint);
               pInner.setPanelAlpha(lp.panel_alpha);
               pInner.setPanelBackgroundPatternIndex(lp.getPanelBackgroundPatternIndex());
               pInner.setPanelBackgroundPatternIntensity(lp.getPanelBackgroundPatternIntensity());
               // // pInner.setPanelTint(#ffFF0000);
               // // pInner.setPanelAlpha(0);
               // // pInner.setDebug(true);
            }
         }

         float shrinkX, shrinkY;
         if([Panel.SHAPE_RHOMB, Panel.SHAPE_ELLIPSE].contains(bgShape)) // Panel.SHAPE_HEXAGON
         {
            if(0 == pInner.size_x && null != lb)
            {
               // workaround for "hexagon shape padding depends on unknown layer size" issue (todo) improve
               pInner.setSize2f(lb.getMinimumSizePadX(), lb.getMinimumSizePadY());
            }
            // trace "xxx pInner="+#(pInner)+" pInner.panel_bg_shape="+pInner.panel_bg_shape+" 1 pInner.size="+pInner.getSizeString();
            shrinkX = pInner.calcPanelLabelShrinkX();
            shrinkY = pInner.calcPanelLabelShrinkY();
            // trace "xxx pInner="+#(pInner)+" pInner.panel_bg_shape="+pInner.panel_bg_shape+" sz="+pInner.getSizeString()+" shrink=("+shrinkX+";"+shrinkY+")";
            // // _l.setPadding4f(shrinkY, shrinkX, shrinkY, shrinkX);  // (todo) setPadding4f() scales by 'pad_scaling' (2.0 in HiDPI mode)
            _l.setPadding4fUnscaled(shrinkY, shrinkX, shrinkY, shrinkX);  // (note) setPadding4f() scales by 'pad_scaling' (2.0 in HiDPI mode)
         }
         else
         {
            pBorderWidth *= 0.5;

            if(borderDir & Layout.TOP)
               _l.setPadTop(pBorderWidth);
            if(borderDir & Layout.LEFT)
               _l.setPadLeft(pBorderWidth);
            if(borderDir & Layout.BOTTOM)
               _l.setPadBottom(pBorderWidth);
            if(borderDir & Layout.RIGHT)
               _l.setPadRight(pBorderWidth);
         }

         float stackW = pInner.calcPanelStackExtraWidth();
         float stackH = pInner.calcPanelStackExtraHeight();
         // trace "xxx pInner stackExtraW="+stackW+" stackExtraH="+stackH+" pInner.pad_right="+pInner.pad_right+" pInner.pad_bottom="+pInner.pad_bottom;

         if(stackW > 0.0f)
            pInner.setPadRightUnscaled(pInner.pad_right + stackW);

         if(stackH > 0.0f)
            pInner.setPadBottomUnscaled(pInner.pad_bottom + stackH);

         // trace "xxx pInner 2 stackExtraW="+stackW+" stackExtraH="+stackH+" pInner.pad_right="+pInner.pad_right+" pInner.pad_bottom="+pInner.pad_bottom;

         // // _l.setAlignment(Layout.EXPAND);
         pInner.addLayer(deref _l, Layout.CENTER);

         if(0 != alignFlagsHint)
            pInner.setAlignment(alignFlagsHint);
         else
            pInner.setAlignment(Layout.CENTER | Layout.BASELINEY);  //CENTERX

         pInner.layout_weight_x = _l.layout_weight_x;
         pInner.layout_weight_y = _l.layout_weight_y;

         bBorder = true;
         p.addLayer(deref pInner, Layout.CENTER);

         // trace "xxx createPanelForLayer: pInner.panel_alpha="+pInner.panel_alpha+" pInner.panel_tint="+UI.GetColorString(pInner.panel_tint)+" bg_shape="+pInner.panel_bg_shape;

         // // p.setPanelAlpha(0);
         // // p.setDebug(true);

         if(null != _nOrNull)
         {
            _nOrNull.ui_layer         <= pInner;
            _nOrNull.ui_content_layer <= _l;
         }
      }

      if(0 != alignFlagsHint)
         p.setAlignment(alignFlagsHint);
      else
         p.setAlignment(Layout.CENTER | Layout.BASELINEY); // CENTERX

      p.layout_weight_x = _l.layout_weight_x;
      p.layout_weight_y = _l.layout_weight_y;

      if(!bBorder)
      {
         // trace "xxx createPanelForLayer: l="+_l.getDebugString();
         // // _l.setAlignment(Layout.EXPAND); // [19Mar2024] ?? (test32.gr)
         p.addLayer(deref _l, Layout.CENTER);
         if(null != _nOrNull)
         {
            _nOrNull.ui_layer         <= _l;
            _nOrNull.ui_content_layer <= _l;
         }
      }
      else
      {
         // // p.setPanelAlpha(0);
         p.setEnableFillBackground(false);
         p.setPanelBorderShape(Panel.SHAPE_NONE);
         p.setPanelBackgroundShape(Panel.SHAPE_NONE);
      }

      if(null != _nOrNull && null == _nOrNull.parent_subgraph)  // not a subgraph io node ?
         p.setEnableLayerGroup(true);

      if(null != _nOrNull)
         _nOrNull.ui_panel_layer <= p;  // [01Feb2025] experimental (abs positioning)

      return deref p;
   }

   protected static NewPortPanel() : Panel {
      Panel p <= Panel.New();
      // // p.setPanelShape(Panel.SHAPE_RECT);
      p.setPanelShape(Panel.SHAPE_NONE);
      p.setEnableCollapse(true);
      p.setEnableDecorative(true);
      p.setPanelBorderWidth(0.0f);
      p.setPanelBackgroundStyle(Panel.STYLE_NONE);
      p.setPanelBorderStyle(Panel.STYLE_NONE);
      // // p.setEnableLayerGroup(true); // ?
      // // p.setPanelBackgroundStyle(Panel.STYLE_FLAT);
      // // _l.setPadding4f(50,50,50,50);
      // // p.setPadding4f(8,8,8,8);
      return deref p;
   }

   protected method createPortsLayerFor(Node _n, Layer _l) : Layer {
      // trace "xxx createPortsLayerFor: n.id="+_n.id+" #ports="+_n.getNumPorts()+" gr_attribs="+#(_n.gr_attribs);
      if(_n.getNumPorts() > 0)
      {
         float portW = _n.getPortW();  // prescaled for HiDPI

         if(portW >= 1)
         {
            float portH = _n.getPortH();
            if(portH < 1)
               portH = portW;

            // trace "xxx ~~~~~~~~~~~~~~~~~~ createPortsLayerFor: portSz=("+portW+";"+portH+") n.id="+_n.id+" #ports="+_n.getNumPorts();

            Layer lContent <= _n.ui_content_layer;
            // trace "xxx lContent="+#(lContent);

            Panel pInner <= NewPortPanel();
            pInner.addLayer(deref _l, Layout.CENTER);

            Panel pOuter <= NewPortPanel();
            pOuter.addLayer(deref pInner, Layout.CENTER);
            pOuter.setPanelBackgroundStyle(Panel.STYLE_FLAT);
            // pOuter.setDebug(true); // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ debug

            HashTable ht <= _n.gr_attribs;
            int tintPost = ht.exists("tint") ? int(ht["tint"]) : 0;
            int tint;

            int portBgColor = 0;
            if(ht.exists("port_bgcolor"))
            {
               portBgColor = int(ht["port_bgcolor"]) & 0x00FFFFFF;

               tint = 0;
               if(ht.exists("port_bgtint"))
                  tint = sdvg_TintARGB(tint, int(ht["port_bgtint"]));

               if(0 != tint)
                  portBgColor = sdvg_TintARGB(portBgColor, tint);

               if(0 != tintPost)
                  portBgColor = sdvg_TintARGB(portBgColor, tintPost);
            }

            int portFgColor = 0;
            if(ht.exists("port_fgcolor"))
            {
               portFgColor = int(ht["port_fgcolor"]) & 0x00FFFFFF;

               tint = 0;
               if(ht.exists("port_fgtint"))
                  tint = sdvg_TintARGB(tint, int(ht["port_fgtint"]));

               if(0 != tint)
                  portFgColor = sdvg_TintARGB(portFgColor, tint);

               if(0 != tintPost)
                  portFgColor = sdvg_TintARGB(portFgColor, tintPost);
            }

            float padT = portH;
            float padL = portW;
            float padB = portH;
            float padR = portW;
            local Panel *pT;
            local Panel *pL;
            local Panel *pB;
            local Panel *pR;

            float portSx = portW;
            float portSy = portH;

            graph::Port *port;
            foreach port in _n.ports
            {
               GraphPortButton bt <= port_button_class.yacNew();
               bt.initGraphPortButton();
               // bt.setDebug(true);
               // if(null != _nOrNull)
               //    bt.setLayerId(_nOrNull.id);
               bt.setGraphData(port);
               bt.setPadding4f(0,0,0,0);  // (note) can be skipped
               bt.setEnableDrawKeyboardFocus(false);
               bt.setEnableCursorKeyTabCycling(false);
               bt.setCaption(port.id);
               bt.setTextPlacement(Layout.CENTER);
               if(ht.exists("port_font"))
               {
                  // // trace "xxx  port_font="+ht["port_font"];
                  bt.setFontByName(ht["port_font"]);
               }
               // // bt.setRequiredSize2f(portW, portH);
               bt.setMinimumSize2f(mathMaxf(portW, bt.getMinimumSizeX()), mathMaxf(portH, bt.getMinimumSizeY()));
               bt.setEnableForceMinimumSize(true, true);
               bt.setAlignment(Layout.CENTERX);
               bt.setEnableLabelButton(true);
               bt.setInnerPadding4f(-2*UI.font_scaling,0,0,0);

               Panel pBt <= NewPortPanel();
               pBt.setGraphData(port);
               pBt.addLayer(deref bt, Layout.CENTER);
               pBt.setPanelBorderStyle(Panel.STYLE_SOLID);
               pBt.setPanelShape(Panel.SHAPE_ROUND);
               float portBorderWidth;
               if(ht.exists("port_border_width"))
                  portBorderWidth = ht["port_border_width"];  // will be scaled by UI.font_scaling
               else
                  portBorderWidth = 1.0f;
               pBt.setPanelBorderWidth(portBorderWidth);
               int portBorderColor;
               if(ht.exists("port_border_color"))
                  portBorderColor = int(ht["port_border_color"]) & 0x00FFFFFF;
               else
                  portBorderColor = #ff000000;
               pBt.setPanelBorderColor(portBorderColor);
               pBt.setPanelShapeRoundAmount(0.2f);
               pBt.setPanelShapeRoundAspect(16.0f/10.0f);
               pBt.setPanelShapeRoundLimit(12.0f);
               float btPad = portBorderWidth*2;
               bt.setPadding4f(btPad, btPad, btPad, btPad);

               // // portBgColor = #ffff0000;
               if(0 != portBgColor)
               {
                  bt.setBackgroundColor(portBgColor);
                  bt.setEnableFillBackground(true);
                  bt.setAlpha(255);

                  pBt.setPanelBackgroundStyle(Panel.STYLE_SOLID);
                  pBt.setBackgroundColor(portBgColor);
                  pBt.setPanelBackgroundAlpha(255);
                  pBt.setPanelAlpha(255);
                  pBt.setEnableFillBackground(true);
                  pBt.setAlpha(255);
               }

               if(0 != portFgColor)
                  bt.setForegroundColor(portFgColor);

               port.ui_content_layer <= bt;
               port.ui_panel_layer <= pBt;

               portSx = mathMaxf(portSx, pBt.getMinimumSizeX());
               portSy = mathMaxf(portSy, pBt.getMinimumSizeY());

               switch(port.dir)
               {
                  case Layout.TOP:
                     padT = 0;
                     if(null == pT)
                     {
                        pT <= NewPortPanel();
                        pT.setAlignment(Layout.EXPANDX);
                        pOuter.addLayer(deref pT, Layout.TOP);
                     }
                     pBt.setAlignment(Layout.BOTTOM);
                     pT.addLayer(deref pBt, Layout.RIGHT);
                     break;

                  case Layout.LEFT:
                     padL = 0;
                     if(null == pL)
                     {
                        pL <= NewPortPanel();
                        pL.setAlignment(Layout.EXPANDY);
                        // pL.setDebug(true);
                        pInner.addLayer(deref pL, Layout.LEFT);
                     }
                     pBt.setAlignment(Layout.RIGHT);
                     pL.addLayer(deref pBt, Layout.BOTTOM);
                     break;

                  case Layout.BOTTOM:
                     padB = 0;
                     if(null == pB)
                     {
                        pB <= NewPortPanel();
                        pB.setAlignment(Layout.EXPANDX);
                        pOuter.addLayer(deref pB, Layout.BOTTOM);
                     }
                     pBt.setAlignment(Layout.TOP);
                     pB.addLayer(deref pBt, Layout.RIGHT);
                     break;

                  case Layout.RIGHT:
                     padR = 0;
                     if(null == pR)
                     {
                        pR <= NewPortPanel();
                        pR.setAlignment(Layout.EXPANDY);
                        pInner.addLayer(deref pR, Layout.RIGHT);
                     }
                     pBt.setAlignment(Layout.LEFT);
                     pOuter.addLayer(deref pBt, Layout.BOTTOM);
                     break;
               }

            } // loop ports

            // // // pInner.setPadding4f(padT, padL, padB, padR);

            // // // pOuter.setPadding4fUnscaled(padT, 0, padB, 0);
            // // // pInner.setPadding4fUnscaled(0, padL, 0, padR);

            // // trace "xxx portS=("+portSx+";"+portSy+") portWH=("+portW+";"+portH+")";

            _n.ui_port_max_w = portSx;
            _n.ui_port_max_h = portSy;

            if(padT > 0)
               pOuter.setPadTopUnscaled(portSy);
            if(padL > 0)
               pInner.setPadLeftUnscaled(portSx);
            if(padB > 0)
               pOuter.setPadBottomUnscaled(portSy);
            if(padR > 0)
               pInner.setPadRightUnscaled(portSx);

            _n.ui_panel_layer <= pOuter;
            _n.ui_ports_layer <= pOuter;

            return deref pOuter;

         } // if portW >= 1
      } // if #ports > 0

      // No port widget
      return deref _l;
   }

   protected method setLayerSizeFromGRAttribs(Layer _l, HashTable _ht/*gr_attribs*/) {
      String sW <= null;
      String sH <= null;

      if(_ht.exists("w"))
         sW <= _ht["w"];

      if(_ht.exists("h"))
         sH <= _ht["h"];

      if(null != sW)
      {
         if(sW & "%")
         {
            _l.setLayoutWeightX(mathClampf(float(sW.replace("%","")) / 100.0f, 0.0f, 1.0f));
         }
         // // else if(float(sW) <= 1.0f)
         // //    _l.setLayoutWeightX(mathMaxf(float(sW), 0.0f));
         else
         {
            _l.setEnableLockSizeX(false);
            _l.setRequiredSizeXScaled(sW);
            _l.setEnableLockSizeX(true);
            // trace "xxx setRequiredSizeXScaled(sW="+sW+")";
         }
      }

      if(null != sH)
      {
         if(sH & "%")
         {
            _l.setLayoutWeightY(mathClampf(float(sH.replace("%","")) / 100.0f, 0.0f, 1.0f));
         }
         // // else if(float(sH) <= 1.0f)
         // //    _l.setLayoutWeightY(mathMaxf(float(sH), 0.0f));
         else
         {
            _l.setEnableLockSizeY(false);
            _l.setRequiredSizeYScaled(sH);
            _l.setEnableLockSizeY(true);
         }
      }
   }

   protected method setLayerRequiredSizeFromAttribs(Layer _l, HashTable _ht) {
      // [01Feb2025] experimental abs positioning/size
      //  (todo) use setLayerSizeFromGRAttribs() ?!!

      setLayerSizeFromGRAttribs(_l, _ht);

      // trace "xxx setLayerRequiredSizeFromAttribs: ht="+_ht;

      // if(_ht.exists("w"))
      //    _l.setRequiredSizeXScaled(_ht.get("w"));

      // if(_ht.exists("h"))
      //    _l.setRequiredSizeYScaled(_ht.get("h"));
   }

   protected method hasAreaZero(HashTable _ht) : boolean {
      String sW <= null;
      String sH <= null;

      if(_ht.exists("w"))
         sW <= _ht["w"];

      if(_ht.exists("h"))
         sH <= _ht["h"];

      return
         ((null != sW) && 0 == float(sW.replace("%",""))) ||
         ((null != sH) && 0 == float(sH.replace("%",""))) ;
   }

   protected method setToolTipFromGRAttribs(Layer _l, HashTable _ht/*gr_attribs*/) {
      if(_ht.exists("tooltip"))
      {
         local String sToolTip = _ht["tooltip"];
         sToolTip.replace("\\n", "\n");
         _l.setToolTipCaption(sToolTip);
      }
   }

   protected method setLayerSizeGroupFromGRAttribs(Layer _l, HashTable _ht/*gr_attribs*/) {
      if(_ht.exists("sgxy"))
      {
         SizeGroupXY sgxy <= lazyAddSizeGroupXYByName("sgxy_"+_ht.get("sgxy"));
         _l.setSizeGroup(sgxy);
      }
      else if(_ht.exists("sgy"))
      {
         SizeGroupY sgy <= lazyAddSizeGroupYByName("sgy_"+_ht.get("sgy"));
         _l.setSizeGroup(sgy);
      }
      else if(_ht.exists("sgx"))
      {
         SizeGroupX sgx <= lazyAddSizeGroupXByName("sgx_"+_ht.get("sgx"));
         _l.setSizeGroup(sgx);
      }
   }

   protected method createButtonForNodeOrLabel(Node _nOrNull, String _sLabel, HashTable _ht/*gr_attribs*/) : Layer {
      // if(null != _nOrNull)
      //    trace "xxx createButtonForNodeOrLabel: id=\""+_nOrNull.id+"\" label=\""+_nOrNull.label+"\" sLabel=\""+_sLabel+"\"";
      Button bt <= Button.New();
      bt.setEnableMouseEvents(false);
      // bt.setDebug(true);
      if(null != _nOrNull)
      {
         bt.setLayerId(_nOrNull.id);
         bt.setGraphData(_nOrNull);
      }
      bt.setPadding4f(0,0,0,0);  // (note) can be skipped
      bt.setEnableDrawKeyboardFocus(false);
      bt.setEnableCursorKeyTabCycling(false);

      setLayerSizeFromGRAttribs(bt, _ht);

      setLabelConfigFromGRAttribs(bt, _sLabel, _ht);

      // // // trace "xxx initButtonFromNode: set n.ui_layer="+#(bt)+" (1)";
      // // // n.ui_layer <= bt;

      setToolTipFromGRAttribs(bt, _ht);

      setLayerColorAndTintFromGRAttribs(bt, _ht);

      GraphForm rootGraphForm <= this;
      while(null != rootGraphForm.parent_graph_form)
         rootGraphForm <= rootGraphForm.parent_graph_form;
      bt.setLinkedRedraw(rootGraphForm);  // for alpha blending to work correctly (i.e. to not accumulate when button is redraw multiple times)

      return createPanelForLayer(_nOrNull, deref bt, _ht/*n.gr_attribs*/, false/*bDefAlignTopLeft*/);  // sets n.ui_layer
   }

   public virtual getDisplayedText() : String {
      return (null != graph) ? ("Graph.id="+graph.id+",layout="+graph.getLayoutString()+",unfold="+graph.doUnfold()) : "<no graph>";
   }

   protected method useNodeWidget(Node _n, HashTable _ht/*gr_attribs*/) : Layer {
      // called when xfm_layer has been pre-allocated while parsing GR (e.g. >>a(CheckBox caption="hello" selected=1)<<)
      Layer l <= _n.xfm_layer;  // (note) do _not_ take ownership
      l.setLayerId(_n.id);
      l.setGraphData(_n);
      l.setPadding4f(0,0,0,0);  // (note) can be skipped

      setLayerSizeFromGRAttribs(l, _ht);

      setToolTipFromGRAttribs(l, _ht);

      if(l instanceof Label)
      {
         Label lb <= l;
         setLabelConfigFromGRAttribs(lb, _n.label, _ht);
      }

      setLayerColorAndTintFromGRAttribs(l, _ht);

      GraphForm rootGraphForm <= this;
      while(null != rootGraphForm.parent_graph_form)
         rootGraphForm <= rootGraphForm.parent_graph_form;
      l.setLinkedRedraw(rootGraphForm);  // for alpha blending to work correctly (i.e. to not accumulate when button is redraw multiple times)

      // (note) XFM attribs have precedence over GR attribs
      if(l.beginXFMTag(null/*form*/, _n.xfm_attribs))
      {
         l.endXFMTag(null/*form*/, _n.xfm_attribs);
      }
      else
      {
         trace "[---] GraphForm::useNodeWidget: beginXFMTag() failed (node.id="+_n.id+" l.class="+l.yacMetaClassName()+")";
         // // throw ParseError getSrcLoc()+": ST_GRAPH_BODY_XFM: xfmLayer.beginXFMTag() failed (xfm_class_name=\""+prev_node.xfm_class_name+"\")";
      }

      return createPanelForLayer(_n, l, _ht/*n.gr_attribs*/, false/*bDefAlignTopLeft*/);  // sets n.ui_layer / n.ui_panel_layer
   }

   protected method splitTableSpan(Node nLong, Node nShort) {
      if(b_gf_debug) trace "[trc] GraphForm::splitTableSpan: nLong"+nLong.getString()+" x="+nLong.table_span_x+" w="+nLong.table_span_w+" nShort"+nShort.getString()+" x="+nShort.table_span_x+" w="+nShort.table_span_w;
      Node nLongSplitStart <= nLong;
      Node *n;
      loop(nShort.table_span_w)
      {
         if(null != nLongSplitStart.next_table_node)
         {
            nLongSplitStart <= nLongSplitStart.next_table_node;
         }
         else
         {
            // end of nLong (empty cells follow)
            ////nLong.table_span_w = nShort.table_span_w;
            return;
         }
      }
      if(null != nLongSplitStart)
      {
         n <= nLongSplitStart.prev_table_node;
         if(null != n)
            n.next_table_node <= null;
         nLongSplitStart.prev_table_node <= null;
         nLongSplitStart.table_span_w = nLong.table_span_w - (nLongSplitStart.table_span_x - nLong.table_span_x);
         nLong.table_span_w = nShort.table_span_w;
      }
   }

   protected method splitTableSpanAtSpan(Node nLong, Node nOther) {
      // (note) nOther is located within x-region of nLong
      if(b_gf_debug) trace "[trc] GraphForm::splitTableSpan: nLong"+nLong.getString()+" x="+nLong.table_span_x+" w="+nLong.table_span_w+" nOther"+nOther.getString()+" x="+nOther.table_span_x+" w="+nOther.table_span_w;
      Node nLongSplitStart <= nLong;
      Node *n;
      loop(nOther.table_span_w)
      {
         if(null != nLongSplitStart.next_table_node)
         {
            nLongSplitStart <= nLongSplitStart.next_table_node;
         }
         else
         {
            // end of nLong (empty cells follow)
            // // nLong.table_span_w = nOther.table_span_x - nLong.table_span_x;
            return;
         }
      }
      if(null != nLongSplitStart)
      {
         n <= nLongSplitStart.prev_table_node;
         if(null != n)
            n.next_table_node <= null;
         nLongSplitStart.prev_table_node <= null;
         nLongSplitStart.table_span_w = nLong.table_span_w - (nLongSplitStart.table_span_x - nLong.table_span_x);
         nLong.table_span_w = nOther.table_span_x - nLong.table_span_x;
      }
   }

   protected method reverseChildLayers(Panel p) {
      // trace "xxx reverseChildLayers: ENTER";
      // // Layer l <= deref p.first_child;
      Layer l <= p.first_child;
      if(null != l)
      {
         local Layer *[] a;
         // trace "xxx l="+#(l)+" l.next="+#(l.next);
         while(null != l)
         {
            Layer n <= l.next;
            l <= p.unlinkChildLayer(l);
            a.add(#(deref l));
            l.setLayoutHints(Layout.LEFT);
            l <= n;
         }
         int idx = a.numElements;
         Layer prev <= null;
         p.first_child <= null;
         loop(a.numElements)
         {
            l <= a.getDeref(--idx);
            // trace "xxx idx="+idx+" l="+#(l);
            l.next <= null;
            // trace "xxx l="+#(l)+" prev="+#(prev);
            if(null == p.first_child)
               p.first_child <= deref l;
            else
               prev.next <= deref l;
            // trace "xxx set prev="+#(l);
            prev <= l;
         }
      }
      // trace "xxx reverseChildLayers: LEAVE";
      // trace "xxx    p="+#(p)+"  p.first_child="+#(p.first_child)+" p.first_child.next="+#(p.first_child.next);
      // // exit(10);
      // p.printHierarchy();
   }

   namespace method layoutTableLayers(local Graph _subgraph, local int _maxSpanW, local int _numRows, local boolean _bLargestFirst, local PointerArray _aSpanStartNodes) {
      local Node *n;
      local Node *nTmp;
      local Layer *l;
      local int rowIdx;
      if(b_gf_debug2) trace "[trc] layoutTableLayers: subgraph.id="+_subgraph.id;
      if(b_gf_debug2)
      {
         _subgraph.debugPrintNodesAndEdges();
         _subgraph.debugPrint();
      }
      /*
         - iterate spans from largest to smallest
            - iterate other rows and find nodes/layers within x-span (n.ui_layer)
               - when node starts span, span end must not exceed x-span end
               - calc max px width (all rows)
               - lock layer width (setRequiredSizeX)
         - iterate other rows and find nodes/layers within x-span
            - when node starts span, span end must not exceed x-span end
            - if px width is < max px width
               - evenly distribute delta-x to layers (and setRequiredSizeX())
      */
      local boolean bDebugLayout = (0 && b_gf_debug) | 0;
      loop(1)
      {
         local float extraWPerNode;
         local int curSpanW = _bLargestFirst ? _maxSpanW : 1;
         while(_bLargestFirst ? (curSpanW > 0) : (curSpanW <= _maxSpanW))
         {
            Node *nSpanStart;
            local int spanPass = 1;
            // float maxSpanPxW = 0;
            loop(2)
            {
               foreach nSpanStart in _aSpanStartNodes
               {
                  if(nSpanStart.table_span_w == curSpanW)
                  {
                     local float maxSpanPxW = 0;

                     local int spanMinX = nSpanStart.table_span_x;
                     local int spanMaxX = nSpanStart.table_span_x + nSpanStart.table_span_w_spc - 1;
                     local int spanY = nSpanStart.table_span_y;
                     local float spanPxW = 0;
                     if(bDebugLayout) trace "[trc] -------------------------------------------------- align<pass="+spanPass+"> span id="+nSpanStart.id+" y="+spanY+(("i"==nSpanStart.id)?"*********************":"")+(("nodeB" == nSpanStart.id)?"<-------------------------------------------------------":"");

                     nTmp <= nSpanStart;
                     local int thisSpanNumNodes = 0;
                     while(null != nTmp)
                     {
                        l <= nTmp.ui_layer;
                        // l <= nTmp.getUIOuterLayer(); // ?
                        spanPxW += l.getSizePadX();
                        // // spanPxW += l.getPreferredSizePadX();
                        nTmp <= nTmp.next_table_node;
                        thisSpanNumNodes++;
                     }

                     // // if(1 == spanPass)
                     // // {
                        if(spanPxW > maxSpanPxW)
                           maxSpanPxW = spanPxW;
                     // // }

                     if(bDebugLayout) trace "[trc] process<pass="+spanPass+"> nSpanStart"+nSpanStart.getString()+" spanY="+spanY+" spanMinX="+spanMinX+" spanMaxX="+spanMaxX+" w="+nSpanStart.table_span_w+" wSpc="+nSpanStart.table_span_w_spc+" pxW="+spanPxW+" maxSpanPxW="+maxSpanPxW;
                     rowIdx = 0;
                     loop(_numRows)
                     {
                        if(bDebugLayout) trace "[trc] <pass="+spanPass+">   rowIdx="+rowIdx;
                        if(rowIdx != spanY)
                        {
                           local float rowSpanPxW = 0.0f;
                           local int numRowSpanNodes = 0;
                           local Node *[] aRowSpanNodes; aRowSpanNodes.empty();
                           local int rowSpanEnd = 0;
                           local boolean bFirst = true;
                           foreach n in _subgraph.nodes
                           {
                              if(n.table_span_y == rowIdx)
                              {
                                 if(bDebugLayout) trace "[trc] candidate n.id="+n.id+" x="+n.table_span_x+" w="+n.table_span_w+" wSpc="+n.table_span_w_spc;
                                 if(spanMinX <= n.table_span_x <= spanMaxX)
                                 {
                                    // // if(n.table_span_w <= 1 || (null != n.next_table_node && (n.table_span_x + n.table_span_w - 1/*empty space*/) <= spanMaxX) )
                                    if( (!bFirst || (n.table_span_x == nSpanStart.table_span_x)) && (n.table_span_w <= 1 || (n.table_span_x + n.table_span_w_spc - 1/*empty space*/) <= spanMaxX) )
                                    {
                                       bFirst = false;
                                       if(bDebugLayout) trace "[trc] <pass="+spanPass+">      node within span id="+nSpanStart.id+" w="+curSpanW+": n"+n.getString()+" x="+n.table_span_x+" y="+n.table_span_y;
                                       l <= n.ui_layer;
                                       // l <= n.getUIOuterLayer(); // ?
                                       local float rowNodeW = l.getSizePadX();
                                       // // float rowNodeW = l.getPreferredSizePadX();
                                       if(bDebugLayout) trace "[trc] <pass="+spanPass+"> n.id="+n.id+" rowNodeW="+rowNodeW;
                                       rowSpanPxW += rowNodeW;
                                       l.setRequiredSizePadX(rowNodeW); // lock width
                                       numRowSpanNodes++;
                                       aRowSpanNodes.add(n);
                                       if( (n.table_span_x + n.table_span_w) > rowSpanEnd )
                                          rowSpanEnd = (n.table_span_x + n.table_span_w);
                                    }
                                 }
                              }
                           }

                           if(bDebugLayout) trace "[trc] <pass="+spanPass+">    => "+numRowSpanNodes+" rowIdx="+rowIdx+" node(s) rowSpanPxW="+rowSpanPxW+" maxSpanPxW="+maxSpanPxW;

                           // // if(1 == spanPass)
                           // // {
                              if(rowSpanPxW > maxSpanPxW)
                                 maxSpanPxW = rowSpanPxW;
                           // // }

                           if(numRowSpanNodes > 0)
                           {
                              if(rowSpanPxW < maxSpanPxW)
                              {
                                 // Evenly distribute extra space to aRowSpanNodes layers
                                 extraWPerNode = (maxSpanPxW - rowSpanPxW) / numRowSpanNodes;
                                 if(bDebugLayout) trace "[trc] <pass="+spanPass+">      => row "+rowIdx+" extraWPerNode="+extraWPerNode;
                                 foreach n in aRowSpanNodes
                                 {
                                    l <= n.ui_layer;
                                    // l <= n.getUIOuterLayer(); // ?
                                    l.setRequiredSizePadX(l.getSizePadX() + extraWPerNode);
                                    if(bDebugLayout) trace "[trc]                add extraW="+extraWPerNode+" to n"+n.getString()+(("nodeB" == n.id)?"<-------------------------------------------------------":"");
                                 }
                              }
                           }
                        }

                        // Next row
                        rowIdx++;
                     }

                     if(2 == spanPass)
                     {
                        if(maxSpanPxW > spanPxW)
                        {
                           // increase width of 'this' span
                           extraWPerNode = (maxSpanPxW - spanPxW) / thisSpanNumNodes;
                           if(bDebugLayout) trace "[trc] <pass="+spanPass+">      => <this> nSpanStart"+nSpanStart.getString()+" spanY="+spanY+" spanPxW="+spanPxW+" maxSpanPxW="+maxSpanPxW+" #nodes="+thisSpanNumNodes+" extraWPerNode="+extraWPerNode;
                           nTmp <= nSpanStart;
                           while(null != nTmp)
                           {
                              l <= nTmp.ui_layer;
                              // l <= nTmp.getUIOuterLayer(); // ?
                              l.setRequiredSizePadX(l.getSizePadX() + extraWPerNode);
                              nTmp <= nTmp.next_table_node;
                           }
                        }
                     }

                  }
               } // iterate span starts

               // Next pass
               spanPass++;
            } // loop 2 span passes

            // Next smaller span
            if(_bLargestFirst)
               curSpanW--;
            else
               curSpanW++;
         }
      } // loop 1

      // // printHierarchy();
   }

   protected method addTableSubgraph(local Graph _subgraph, local TableGraphPanel _pTable) {
      local boolean bDebug = 0 && b_gf_debug;

      // // String *sRow;
      local Panel *pRow;

      // // StringArray aRows <= _subgraph.layout_rows;
      local PointerArray aRows <= _subgraph.table_layout_rows;  // array of StringArrays
      local StringArray *aRow;
      local int rowIdx;
      local int colIdx;
      local char c;
      local String *sId;
      local Node *n;

      local Node *[] aSpanStartNodes <= _pTable.a_span_start_nodes;
      // // aSpanStartNodes.empty();
      local int maxSpanW = 0;
      local boolean bBlank;

      // - find col span starts and lengths
      //    - prev char is whitespace or beginning of line
      //    - span ends at EOL or next non-whitespace char
      rowIdx = 0;
      loop(aRows.numElements)
      {
         // // sRow <= aRows[rowIdx];
         aRow <= aRows[rowIdx];

         colIdx = 0;
         local boolean bWhitespace = true;
         local boolean bFirstInRow = true;
         local Node nCurSpan <= null;
         local Node nSpanHead <= null;
         // // loop(sRow.numChars)
         loop(aRow.numElements)
         {
            // // c = sRow.getc(colIdx);
            // // sId <= tcchar(c);
            sId <= aRow[colIdx];
            bBlank = sId.isBlank();
            // // if(c > ' ')
            if(!bBlank)
            {
               n <= _subgraph.findNode(sId);
               if(b_gf_debug2) trace "[trc] GraphForm::addTableSubgraph: sId="+sId+" n="+#(n);

               if(bWhitespace)
               {
                  // new span
                  if(null != nCurSpan)
                  {
                     // end last span
                     if(nCurSpan.table_span_w > maxSpanW)
                        maxSpanW = nCurSpan.table_span_w;
                     nCurSpan <= null;
                     nSpanHead <= null;
                  }

                  // start new span
                  nCurSpan <= n;
                  // trace "xxx start span";
                  nCurSpan.table_span_x = colIdx;
                  nCurSpan.table_span_y = rowIdx;
                  nCurSpan.table_span_w_spc = 1;
                  nSpanHead <= n;
                  aSpanStartNodes.add(n);
               }
               // else: add n to current span

               if(null != nCurSpan)
               {
                  nCurSpan.table_span_w++;
                  n.table_span_x = colIdx;
                  n.table_span_y = rowIdx;
                  if(colIdx != nCurSpan.table_span_x)
                  {
                     // continue span
                     n.prev_table_node <= nSpanHead;
                     nSpanHead.next_table_node <= n;
                  }
                  nSpanHead <= n;
               }
               bWhitespace = false;
            }
            else
            {
               // whitespace
               bWhitespace = true;
               if(null != nCurSpan)
               {
                  // continue span (add empty space)
                  nCurSpan.table_span_w++;
                  nCurSpan.table_span_w_spc++;
               }
            }

            // Next column
            colIdx++;
         }

         if(null != nCurSpan)
         {
            // end last span
            if(nCurSpan.table_span_w > maxSpanW)
               maxSpanW = nCurSpan.table_span_w;
            nCurSpan <= null;
         }

         // Next row
         rowIdx++;
      }

      if(bDebug)
      {
         _subgraph.debugPrintTableSpanStarts();
         if(b_gf_debug) trace "[trc] GraphForm::addTableSubgraph: maxSpanW="+maxSpanW+" aSpanStartNodes="+#(aSpanStartNodes);
      }

      // Split spans
      foreach n in aSpanStartNodes
      {
         local Node *o;
         foreach o in _subgraph.nodes
         {
            if(@(o) != @(n))
            {
               if(!n.tableSpanContainsNode(o))
               {
                  if(o.table_span_x == n.table_span_x)
                  {
                     // both n and o start new span
                     if(o.table_span_w == n.table_span_w)
                     {
                        // same span length (keep)
                     }
                     else if(o.table_span_w > 0)
                     {
                        // both n and start new span with different lengths
                        if(n.table_span_w > o.table_span_w)
                        {
                           // split n span at o
                           if(bDebug) trace "xxx GraphForm::addTableSubgraph: split x="+n.table_span_x+" n"+n.getString()+".span_w="+n.table_span_w+" o"+o.getString()+".span_w="+o.table_span_w;
                           splitTableSpan(n, o);
                        }
                        else
                        {
                           // split o span at n
                           splitTableSpan(o, n);
                        }
                     }
                     else
                     {
                     }
                  }
                  else if(o.table_span_w > 0)  // starts span ?
                  {
                     if(n.table_span_x <= o.table_span_x < (n.table_span_x + n.table_span_w))
                     {
                        if(bDebug) trace "[trc] GraphForm::addTableSubgraph: split span n"+n.getString()+" (x="+n.table_span_x+" w="+n.table_span_w+") at cell "+o.getString()+" x="+o.table_span_x;
                        splitTableSpanAtSpan(n, o);
                     }
                  }
               }
            }
         }
      }

      // New spans after split
      if(bDebug)
         _subgraph.debugPrintTableSpanStarts();

      local int gridX;
      local Button *bt;
      local Layer *l;
      local Node *nTmp;

      // Create UI span panels and layers
      rowIdx = aRows.numElements - 1;
      local Panel *pSpan;
      while(rowIdx >= 0)
      {
         // trace "xxx ------------------------------------------ begin rowIdx="+rowIdx;
         // // sRow <= aRows[rowIdx];
         aRow <= aRows[rowIdx];
         pRow <= Panel.New();
         pRow.setLayerId("tblrow_"+rowIdx);
         pRow.setPadding4f(0,0,0,0);
         pRow.setEnableCollapse(true);
         pRow.setEnableDecorative(true);
         pRow.setPanelBorderWidth(0.0f);
         pRow.setPanelBackgroundStyle(Panel.STYLE_SOLID);

         _pTable.addLayer(deref pRow, Layout.TOP);

         // // if(!sRow.isBlank())
         if(!aRow.isEmpty())
         {
            // Find all nodes that start new span in this row
            //   (note) nodes are already sorted in ascending-x order
            //   (todo) add nodes from right to left ?
            foreach n in _subgraph.nodes
            {
               if(n.table_span_y == rowIdx && n.table_span_w > 0)  // starts new span in this row ?
               {
                  pSpan <= Panel.New();
                  pSpan.setLayerId("pSpan");
                  pSpan.setPadding4f(0,0,0,0);
                  pSpan.setEnableCollapse(true);
                  pSpan.setEnableDecorative(true);
                  pSpan.setPanelBorderWidth(0.0f);
                  // pSpan.setPanelBackgroundStyle(Panel.STYLE_SOLID);

                  pSpan.setAlignment(Layout.EXPANDY | Layout.BASELINE);
                  // // pSpan.setRequiredSizeX(n.table_span_w * 250);
                  pRow.addLayer(deref pSpan, Layout.RIGHT);
                  // trace "xxx ----------- add layer n"+n.getString();
                  // // float cellW = pSpan.size_x / n.table_span_w;

                  // Add all nodes in this span
                  //   (todo) add nodes from right to left ?
                  while(null != n)
                  {
                     HashTable *htAttribs;

                     local Graph gSubgraph <= n.parent_subgraph;
                     if(null != gSubgraph)
                     {
                        // Subgraph table node
                        local GraphForm gw <= new GraphForm;
                        gw.initGraphForm(this/*parent_graph_form*/);
                        gw.setPortButtonClass(port_button_class);
                        gw.setLayerId(n.id);  // [18Feb2025]
                        gw.setEnableDecorative(true);
                        gw.graph <= gSubgraph;
                        gSubgraph.graph_form <= gw;
                        if(b_gf_debug2) trace "[trc] GraphForm::addTableSubgraph: Subgraph table node n"+n.getString()+" gw="+#(gw);
                        htAttribs <= gSubgraph.gr_attribs;
                        setLayerRequiredSizeFromAttribs(gw, htAttribs);  // [01Feb2025] experimental abs positioning/size
                        l <= createPanelForLayer(n, deref gw, htAttribs, true/*bDefAlignTopLeft*/);
                        // // setLayerPaddingFromGRAttribs(l, graph.gr_attribs);
                        setLayerPaddingFromGRAttribs(l, htAttribs);
                        setLayerSizeGroupFromGRAttribs(gw, htAttribs);

                        // // pSpan.addLayer(deref l, Layout.RIGHT);
                        // trace "xxx addTableSubgraph: subgraph="+#(gSubgraph)+" gr_attribs="+#(gSubgraph.gr_attribs);
                        // (note) addNodesFromGraph() is called in layoutHierarchy()
                        // (note) addEdgesFromGraph() is called in onResize() (at end of layout pass)
                        if(b_gf_debug2) trace "[trc] GraphForm::addTableSubgraph: Subgraph table node n"+n.getString()+" gw="+#(gw)+" --------------- END";
                     }
                     else
                     {
                        // Regular table node
                        htAttribs <= n.gr_attribs;
                        if(null != n.xfm_layer)
                           l <= useNodeWidget(n, n.gr_attribs);
                        else
                           l <= createButtonForNodeOrLabel(n, n.label, htAttribs);  // (note) sets n.ui_layer
                        setLayerPaddingFromGRAttribs(l, htAttribs);
                        setLayerSizeGroupFromGRAttribs(n.ui_content_layer, htAttribs);
                     }

                     // // l.setRequiredSizeX(cellW);
                     // trace "xxx set n.ui_layer="+#(l)+" (2)";
                     pSpan.addLayer(deref l, Layout.RIGHT);

                     // Next span node
                     n <= n.next_table_node;
                  }

                  reverseChildLayers(pSpan);
               }
            }

            reverseChildLayers(pRow);
         }
         // trace "xxx ------------------------------------------ end rowIdx="+rowIdx;

         // Next row
         rowIdx--;
      }

      if(1)
      {
         _pTable.max_span_w = maxSpanW;
         _pTable.num_rows   = aRows.numElements;
         // <continued in TableGraphPanel::layoutHierarchy()>
      }
      else
      {
         // Calc initial layer sizes
         relayout();
         // // // // UI.LayoutRootLayer();
         // // // printHierarchy();

         layoutTableLayers(_subgraph, maxSpanW, aRows.numElements, false/*bLargestFirst*/, aSpanStartNodes);
         // // layoutTableLayers(_subgraph, maxSpanW, aRows.numElements, true/*bLargestFirst*/, aSpanStartNodes);
      }
   }

   protected method setLayerPaddingFromGRAttribs(Layer l, HashTable ht) {
      float padT = -1.0f;
      float padL = -1.0f;
      float padB = -1.0f;
      float padR = -1.0f;

      if(ht.exists("pad"))
      {
         local StringArray aPad <= ht["pad"].splitChar(';');
         String *sPad;

         sPad <= aPad.get(0);
         if("auto" != sPad)
            padT = sPad;

         sPad <= (aPad.numElements >= 2) ? aPad.get(1) : aPad.last;
         if("auto" != sPad)
            padL = sPad;

         sPad <= (aPad.numElements >= 3) ? aPad.get(2) : aPad.last;
         if("auto" != sPad)
            padB = sPad;

         sPad <= (aPad.numElements >= 4) ? aPad.get(3) : aPad.last;
         if("auto" != sPad)
            padR = sPad;
      }

      if(ht.exists("pad_t"))
         padT = ("auto" != ht["pad_t"]) ? ht["pad_t"] : -1.0f;

      if(ht.exists("pad_l"))
         padL = ("auto" != ht["pad_l"]) ? ht["pad_l"] : -1.0f;

      if(ht.exists("pad_b"))
         padB = ("auto" != ht["pad_b"]) ? ht["pad_b"] : -1.0f;

      if(ht.exists("pad_r"))
         padR = ("auto" != ht["pad_r"]) ? ht["pad_r"] : -1.0f;

      if(padT >= 0.0f)
         l.setPadTop(mathClampf(padT, 0, MAX_PADDING));

      if(padL >= 0.0f)
         l.setPadLeft(mathClampf(padL, 0, MAX_PADDING));

      if(padB >= 0.0f)
         l.setPadBottom(mathClampf(padB, 0, MAX_PADDING));

      if(padR >= 0.0f)
         l.setPadRight(mathClampf(padR, 0, MAX_PADDING));
   }

   protected method setPanelInnerPaddingFromGRAttribs(Layer l, HashTable ht) {
      float padT = -1.0f;
      float padL = -1.0f;
      float padB = -1.0f;
      float padR = -1.0f;

      if(ht.exists("ipad"))
      {
         local StringArray aPad <= ht["ipad"].splitChar(';');
         String *sPad;

         sPad <= aPad.get(0);
         if("auto" != sPad)
            padT = sPad;

         sPad <= (aPad.numElements >= 2) ? aPad.get(1) : aPad.last;
         if("auto" != sPad)
            padL = sPad;

         sPad <= (aPad.numElements >= 3) ? aPad.get(2) : aPad.last;
         if("auto" != sPad)
            padB = sPad;

         sPad <= (aPad.numElements >= 4) ? aPad.get(3) : aPad.last;
         if("auto" != sPad)
            padR = sPad;
      }

      if(ht.exists("ipad_t"))
         padT = ("auto" != ht["ipad_t"]) ? ht["ipad_t"] : -1.0f;

      if(ht.exists("ipad_l"))
         padL = ("auto" != ht["ipad_l"]) ? ht["ipad_l"] : -1.0f;

      if(ht.exists("ipad_b"))
         padB = ("auto" != ht["ipad_b"]) ? ht["ipad_b"] : -1.0f;

      if(ht.exists("ipad_r"))
         padR = ("auto" != ht["ipad_r"]) ? ht["ipad_r"] : -1.0f;

      if(b_gf_debug2)
         trace "[trc] setPanelInnerPaddingFromGRAttribs: pad=("+padT+";"+padL+";"+padB+";"+padR+")";

      if(padT >= 0.0f)
      {
         // // trace "xxx call l="+#(l)+" setPadTop("+padT+") l.getDebug()="+l.getDebug();
         l.setPadTop(mathClampf(padT, 0, MAX_PADDING));
      }

      if(padL >= 0.0f)
         l.setPadLeft(mathClampf(padL, 0, MAX_PADDING));

      if(padB >= 0.0f)
         l.setPadBottom(mathClampf(padB, 0, MAX_PADDING));

      if(padR >= 0.0f)
         l.setPadRight(mathClampf(padR, 0, MAX_PADDING));
   }

   protected method setLabelInnerPaddingFromGRAttribs(Label l, HashTable ht) {
      float padT = -1.0f;
      float padL = -1.0f;
      float padB = -1.0f;
      float padR = -1.0f;

      if(ht.exists("ipad"))
      {
         local StringArray aPad <= ht["ipad"].splitChar(';');
         String *sPad;
         // // trace "xxx setLabelInnerPaddingFromGRAttribs: aPad="+#(aPad);

         sPad <= aPad.get(0);
         if("auto" != sPad)
            padT = sPad;

         sPad <= (aPad.numElements >= 2) ? aPad.get(1) : aPad.last;
         if("auto" != sPad)
            padL = sPad;

         sPad <= (aPad.numElements >= 3) ? aPad.get(2) : aPad.last;
         if("auto" != sPad)
            padB = sPad;

         sPad <= (aPad.numElements >= 4) ? aPad.get(3) : aPad.last;
         if("auto" != sPad)
            padR = sPad;
      }

      if(ht.exists("ipad_t"))
         padT = ("auto" != ht["ipad_t"]) ? ht["ipad_t"] : -1.0f;

      if(ht.exists("ipad_l"))
         padL = ("auto" != ht["ipad_l"]) ? ht["ipad_l"] : -1.0f;

      if(ht.exists("ipad_b"))
         padB = ("auto" != ht["ipad_b"]) ? ht["ipad_b"] : -1.0f;

      if(ht.exists("ipad_r"))
         padR = ("auto" != ht["ipad_r"]) ? ht["ipad_r"] : -1.0f;

      if(padT >= 0.0f)
      {
         l.setInnerPadTopScaled(mathClampf(padT, 0, MAX_LABEL_INNER_PADDING));
         l.b_xfm_ipad = true; // (todo) this should be per direction
      }

      if(padL >= 0.0f)
      {
         l.setInnerPadLeftScaled(mathClampf(padL, 0, MAX_LABEL_INNER_PADDING));
         l.b_xfm_ipad = true; // (todo) this should be per direction
      }

      if(padB >= 0.0f)
      {
         l.setInnerPadBottomScaled(mathClampf(padB, 0, MAX_LABEL_INNER_PADDING));
         l.b_xfm_ipad = true; // (todo) this should be per direction
      }

      if(padR >= 0.0f)
      {
         l.setInnerPadRightScaled(mathClampf(padR, 0, MAX_LABEL_INNER_PADDING));
         l.b_xfm_ipad = true; // (todo) this should be per direction
      }
   }

   protected method setLabelIconPaddingFromGRAttribs(Label l, HashTable ht) {
      float padT = -1.0f;
      float padL = -1.0f;
      float padB = -1.0f;
      float padR = -1.0f;

      if(ht.exists("icon_pad"))
      {
         local StringArray aPad <= ht["icon_pad"].splitChar(';');
         String *sPad;
         // // trace "xxx setLabelIconPaddingFromGRAttribs: aPad="+#(aPad);

         sPad <= aPad.get(0);
         if("auto" != sPad)
            padT = sPad;

         sPad <= (aPad.numElements >= 2) ? aPad.get(1) : aPad.last;
         if("auto" != sPad)
            padL = sPad;

         sPad <= (aPad.numElements >= 3) ? aPad.get(2) : aPad.last;
         if("auto" != sPad)
            padB = sPad;

         sPad <= (aPad.numElements >= 4) ? aPad.get(3) : aPad.last;
         if("auto" != sPad)
            padR = sPad;
      }

      if(ht.exists("icon_pad_t"))
         padT = ("auto" != ht["icon_pad_t"]) ? ht["icon_pad_t"] : -1.0f;

      if(ht.exists("ipad_l"))
         padL = ("auto" != ht["icon_pad_l"]) ? ht["icon_pad_l"] : -1.0f;

      if(ht.exists("icon_pad_b"))
         padB = ("auto" != ht["icon_pad_b"]) ? ht["icon_pad_b"] : -1.0f;

      if(ht.exists("icon_pad_r"))
         padR = ("auto" != ht["icon_pad_r"]) ? ht["icon_pad_r"] : -1.0f;

      if(padT >= 0.0f)
      {
         l.setIconPadTop(mathClampf(padT, 0, MAX_LABEL_ICON_PADDING));
         l.b_xfm_ipad_icon = true; // (todo) this should be per direction
      }

      if(padL >= 0.0f)
      {
         l.setIconPadLeft(mathClampf(padL, 0, MAX_LABEL_ICON_PADDING));
         l.b_xfm_ipad_icon = true; // (todo) this should be per direction
      }

      if(padB >= 0.0f)
      {
         l.setIconPadBottom(mathClampf(padB, 0, MAX_LABEL_ICON_PADDING));
         l.b_xfm_ipad_icon = true; // (todo) this should be per direction
      }

      if(padR >= 0.0f)
      {
         l.setIconPadRight(mathClampf(padR, 0, MAX_LABEL_ICON_PADDING));
         l.b_xfm_ipad_icon = true; // (todo) this should be per direction
      }
   }

   protected method copyBackgroundFromGRAttribsToPanel(HashTable _ht, Panel _p) {

      if(_ht.exists("bg_blend"))
         _p.setPanelBackgroundBlend( Panel.ParsePanelBlendFromString(_ht["bg_blend"]) );

      int tintPost = _ht.exists("tint") ? int(_ht["tint"]) : 0;

      int c32 = 0;
      if(_ht.exists("bgcolor"))
         c32 = #ff000000 | int(_ht["bgcolor"]);

      int tint = 0;
      if(_ht.exists("bgtint"))
         tint = _ht["bgtint"];
      if(0 != tint)
         c32 = sdvg_TintARGB(c32, tint);

      if(0 != c32)
      {
         if(0 != tintPost)
            c32 = sdvg_TintARGB(c32, tintPost);

         // trace "xxx copyBackgroundFromGRAttribsToPanel: this="+#(this)+" c24="+UI.GetColorString(c32 & 0x00FFFFFF);

         _p.setBackgroundColor(c32);

         if(_ht.exists("bgfill"))
            _p.setEnableFillBackground(0 != int(_ht["bgfill"]));
      }

      if(_ht.exists("alpha"))
         _p.setPanelAlpha(_ht["alpha"]);
      else
         _p.setPanelAlpha(255);

      if(_ht.exists("bgalpha"))
         _p.setPanelBackgroundAlpha(_ht["bgalpha"]);

      setPanelBackgroundPatternAndGradientFromGRAttribs(_p, _ht);
   }

   protected method copyPanelShapeAndBorderAttribs(Panel pSrc, Panel pDst/*, boolean _bDstIsTable*/) {
      pDst.panel_bg_shape     = pSrc.panel_border_shape;  // replicate border_shape to bg_shape
      pDst.panel_border_shape = pSrc.panel_border_shape;

      pDst.panel_shape_round_amount = pSrc.panel_shape_round_amount;
      pDst.panel_shape_round_aspect = pSrc.panel_shape_round_aspect;
      pDst.panel_shape_round_limit  = pSrc.panel_shape_round_limit;

      pDst.panel_shape_rhomb_tx = pSrc.panel_shape_rhomb_tx;
      pDst.panel_shape_rhomb_ty = pSrc.panel_shape_rhomb_ty;

      pDst.panel_border_width = pSrc.panel_border_width;
      pDst.panel_border_c24   = pSrc.panel_border_c24;
      pDst.panel_border_alpha = pSrc.panel_border_alpha;
      pDst.panel_border_blend = pSrc.panel_border_blend;
      pDst.panel_border_dir   = pSrc.panel_border_dir;

      pDst.setPanelAlpha(0);
      // pDst.setDebug(true);
   }

   protected method addNodesFromGraph_BorderLayout() {
      if(b_gf_debug) trace "[trc] GraphForm::addNodesFromGraph: this="+#(this)+" graph.sz="+graph.getSizeString();
      setLayout(SuperBorderLayout);
      // // removeChildHierarchy();

      local GraphForm rootGraphForm <= this;
      while(null != rootGraphForm.parent_graph_form)
         rootGraphForm <= rootGraphForm.parent_graph_form;

      local HashTable *htSpacer;
      if(graph.haveGraphAttrib("spacer_class"))
      {
         GRStyle spacerStyle <= rootGraphForm.gr.findStyleClass(graph.getGraphAttrib("spacer_class"));
         if(null != spacerStyle)
            htSpacer <= spacerStyle.attribs;
         else
            trace "[~~~] addNodesFromGraph: undeclared spacer_class '"+graph.getGraphAttrib("spacer_class")+"' (graph.id='"+graph.id+"'), skipping..";
      }

      local int gridX;
      SizeGroupX *sgx;

      // Create column size groups
      size_groups.free();
      gridX = 0;
      loop(graph.grid_w)
      {
         sgx <= new SizeGroupX;
         size_groups["sgx"+gridX] = deref sgx;
         gridX++;
      }

      // float gridSclX = 100.0;
      // float gridSclY =

      local float defPaddingX = 16.0f;
      local float defPaddingY = 12.0f;
      local float slantFactor = 16.0f;

      // // // if(graph.haveGraphAttrib("pad_col"))
      // // //    defPaddingX = graph.getGraphAttrib("pad_col");
      if(graph.haveGraphAttrib("col_padding"))
         defPaddingX = graph.getGraphAttrib("col_padding");

      // // // if(graph.haveGraphAttrib("pad_row"))
      // // //    defPaddingY = graph.getGraphAttrib("pad_row");
      if(graph.haveGraphAttrib("row_padding"))
         defPaddingY = graph.getGraphAttrib("row_padding");

      if(graph.haveGraphAttrib("slant_factor"))
         slantFactor = graph.getGraphAttrib("slant_factor");

      if(!graph.b_slant)
         slantFactor = 0;

      if(null == graph.parent_graph)
         setLayerPaddingFromGRAttribs(this, graph.gr_attribs);

      // (note) background is rendered _before_ graph edges
      int tintPost = graph.haveGraphAttrib("tint") ? int(graph.getGraphAttrib("tint")) : 0;

      int graphBgColor = 0;
      if(graph.haveGraphAttrib("bgcolor"))
         graphBgColor = int(graph.getGraphAttrib("bgcolor"));
      if(graph.haveGraphAttrib("bgtint"))
         graphBgColor = sdvg_TintARGB(graphBgColor, graph.getGraphAttrib("bgtint"));
      if(0 != graphBgColor)
      {
         if(0 != tintPost)
            graphBgColor = sdvg_TintARGB(graphBgColor, tintPost);
         setPanelAlphaAndTint(255, graphBgColor | 0xFF000000);
      }
      else
         setPanelAlphaAndTint(255, #fff9f9f9);

      // (note) graph edges are rendered _after_ background and nodes
      local Panel pCtr <= Panel.New();
      pCtr.setLayerId("graph_"+graph.id+"_pCtr");
      pCtr.setEnableCollapse(true);
      pCtr.setEnableDecorative(true);
      pCtr.setPanelBackgroundStyle(Panel.STYLE_SOLID);

      pCtr.setPadding4f(0,0,0,0);
      // if(null != graph.parent_graph)
      //    setLayerPaddingFromGRAttribs(pCtr, graph.gr_attribs);

      if(graph.haveGraphAttrib("bgfill"))
      {
         setEnableFillBackground(0 != int(graph.getGraphAttrib("bgfill")));
         pCtr.setEnableFillBackground(0 != int(graph.getGraphAttrib("bgfill")));
      }

      if(null == graph.parent_graph)
      {
         Panel pParent <= parent;
         if(pParent instanceof Panel)
         {
            pParent.setPanelAlphaAndTint(panel_alpha, panel_tint);
            pParent.setEnableFillBackground(getEnableFillBackground());
         }
      }

      // trace "xxx addNodesFromGraph: graph.gr_attribs="+#(graph.gr_attribs);

      // pCtr.setDebug(true);
      addLayer(deref pCtr, Layout.CENTER | Layout.BASELINEY);

      local int gridY = graph.grid_h - 1;
      loop(graph.grid_h)
      {
         gridX = 0;
         local Panel pRow <= Panel.New();
         pRow.setLayerId("graph_"+graph.id+"_row"+gridY);
         // pRow.setAlignment(Layout.LEFT | Layout.TOP);
         pRow.setEnableCollapse(true);
         pRow.setEnableDecorative(true);
         pRow.setPanelBackgroundStyle(Panel.STYLE_SOLID);
         pCtr.addLayer(deref pRow, Layout.TOP);

         if(gridY > 0 && slantFactor > 0.0f)
         {
            local Spacer spcSlant <= Spacer.New();
            // // spcSlant.initSpacer();
            spcSlant.setRequiredSize2f(slantFactor * gridY, 4);
            // spcSlant.setDebug(true);
            pRow.addLayer(deref spcSlant, Layout.RIGHT);
            // Label lbX <= Label.New();
            // lbX.setCaption("slant");
            // pRow.addLayer(deref lbX, Layout.RIGHT);
         }

         loop(graph.grid_w)
         {
            local Cell c <= graph.getCell(gridX, gridY);
            // trace "xxx c="+#(c);
            sgx <= size_groups.get("sgx"+gridX);
            local Layer l <= null;
            local int tint;
            local HashTable *htAttribs <= null;
            local Panel *pOuter;

            if(null != c.node)
            {
               local Node n <= c.node;
               local Graph subgraph <= n.parent_subgraph;
               local boolean bAdded = false;

               if(null != subgraph)
               {
                  if(b_gf_debug)
                     trace "[trc] GraphForm::addNodesFromGraph_BorderLayout: n"+n.getString()+" TABLE subgraph.id="+subgraph.id;

                  if(Graph.LAYOUT_TABLE == subgraph.layout)
                  {
                     local TableGraphPanel pTable <= new TableGraphPanel;
                     pTable.initTableGraphPanel(this, subgraph);
                     pTable.setLayerId("TABLE_GRAPH_"+subgraph.id);
                     pTable.setEnableCollapse(true);
                     pTable.setPanelBorderWidth(0.0f);
                     pTable.setPadding4f(0,0,0,0);
                     // // pTable.setPanelAlpha(0);

                     setLayerSizeGroupFromGRAttribs(pTable, subgraph.gr_attribs);

                     local Panel pTableIPad <= Panel.New();
                     pTableIPad.setLayerId("TABLE_GRAPH_IPad");
                     pTableIPad.setEnableCollapse(true);
                     pTableIPad.setEnableDecorative(true);
                     pTableIPad.setPanelBorderWidth(0.0f);
                     pTableIPad.setPanelBorderStyle(Panel.STYLE_NONE);
                     pTableIPad.setPanelBackgroundStyle(Panel.STYLE_SOLID);
                     pTableIPad.setPadding4f(0,0,0,0);
                     // // pTableIPad.setPanelAlpha(0);
                     setPanelInnerPaddingFromGRAttribs(pTable, subgraph.gr_attribs);
                     copyBackgroundFromGRAttribsToPanel(subgraph.gr_attribs, pTable); // ?? (==> !! fixes center row/table bg in test23d.gr)
                     copyBackgroundFromGRAttribsToPanel(subgraph.gr_attribs, pTableIPad);
                     if(b_gf_debug) trace "[trc] ************************ table subgraph.id="+subgraph.id+" gr_attribs="+#(subgraph.gr_attribs);
                     // pTableIPad.setDebug(true);
                     pTableIPad.addLayer(deref pTable, Layout.CENTER);
                     // pTableIPad.setDebug(true);

                     // // pTable.copyPanelAlphaAndTintFrom(gw);
                     // // // l <= deref pTable;
                     pOuter <= createPanelForLayer(n, deref pTableIPad, subgraph.gr_attribs, true/*bDefAlignTopLeft*/);
                     l <= deref pOuter;
                     // trace "xxx pOuter.panel_border_shape="+pOuter.panel_border_shape;
                     if(Panel.SHAPE_RECT != pOuter.panel_border_shape)
                     {
                        // // if(Panel.SHAPE_DEFAULT != pOuter.panel_bg_shape)
                           copyPanelShapeAndBorderAttribs(pOuter, pTableIPad);
                        // // else
                        // // {
                        // //    pOuter.setPanelAlpha(0);
                        // //    pOuter.setPanelBorderWidth(0);
                        // // }
                     }

                     // trace "xxx table subgraph.id="+subgraph.id+" gr_attribs="+#(subgraph.gr_attribs);
                     // // // setLayerPaddingFromGRAttribs(l, subgraph.gr_attribs);
                     if(b_gf_debug2) trace "[trc] GraphForm::addNodesFromGraph_BorderLayout: table subgraph: pTable     panel_alpha="+pTable.panel_alpha+" panel_tint="+UI.GetColorString(pTable.panel_tint)+" bg_shape="+pTable.panel_bg_shape;
                     if(b_gf_debug2) trace "[trc] GraphForm::addNodesFromGraph_BorderLayout: table subgraph: pTableIPad panel_alpha="+pTableIPad.panel_alpha+" panel_tint="+UI.GetColorString(pTableIPad.panel_tint)+" bg_shape="+pTableIPad.panel_bg_shape;
                     if(b_gf_debug2) trace "[trc] GraphForm::addNodesFromGraph_BorderLayout: table subgraph: pOuter     panel_alpha="+pOuter.panel_alpha+" panel_tint="+UI.GetColorString(pOuter.panel_tint)+" bg_shape="+pOuter.panel_bg_shape;
                     // // pTable.setPanelAlphaAndTint(255, #ff00ff00);
                     htAttribs <= subgraph.gr_attribs;
                     pRow.addLayer(deref l, Layout.RIGHT);
                     // pRow.setDebug(true);

                     addTableSubgraph(subgraph, pTable);
                     bAdded = true;
                  }
                  // // else if(!subgraph.b_unfold && (null != n.cell))
                  else if(!subgraph.doUnfold() && (null != n.cell))
                  {
                     // // local Panel pGraph <= Panel.New();
                     // // pGraph.setLayerId("SUBGRAPH_"+subgraph.id);
                     // // // pGraph.setEnableCollapse(true);
                     // // pGraph.setPadding4f(0,0,0,0);
                     // // l <= deref pGraph;
                     // // pRow.addLayer(deref l, Layout.RIGHT);

                     local GraphForm gw <= new GraphForm;
                     gw.initGraphForm(this/*parent_graph_form*/);
                     gw.setPortButtonClass(port_button_class);
                     gw.setLayerId(n.id);  // [18Feb2025]
                     gw.setEnableDecorative(true);
                     gw.graph <= subgraph;
                     subgraph.graph_form <= gw;
                     setLayerRequiredSizeFromAttribs(gw, subgraph.gr_attribs);  // [01Feb2025] experimental abs positioning/size
                     setLayerSizeGroupFromGRAttribs(gw, subgraph.gr_attribs);
                     // // // gw.setAlignment(Layout.BASELINEY);
                     // // pGraph.addLayer(deref gw, Layout.CENTER);
                     local Panel pGraph <= Panel.New();
                     pGraph.setEnableCollapse(true);
                     pGraph.setEnableDecorative(true);
                     pGraph.setPanelBackgroundStyle(Panel.STYLE_SOLID);
                     pGraph.setPadding4f(0,0,0,0);
                     pGraph.addLayer(deref gw, Layout.CENTER);
                     copyBackgroundFromGRAttribsToPanel(subgraph.gr_attribs, pGraph);  // (note) pGraph
                     setPanelInnerPaddingFromGRAttribs(gw, subgraph.gr_attribs);
                     // gw.setPadding4f(50,50,50,50);
                     // gw.setDebug(true);
                     pOuter <= createPanelForLayer(n, deref pGraph, subgraph.gr_attribs, true/*bDefAlignTopLeft*/);
                     if(Panel.SHAPE_RECT != pOuter.panel_border_shape)
                     {
                        copyPanelShapeAndBorderAttribs(pOuter, pGraph);
                     }
                     l <= deref pOuter;
                     // // htAttribs <= subgraph.gr_attribs;
                     htAttribs <= new HashTable;
                     htAttribs = subgraph.gr_attribs;
                     htAttribs.realloc(512);
                     Graph.CopyGRAttribsIfNotExists(htAttribs, n.gr_attribs);  // e.g. for "sw" and "sh" span width/height attribs
                     // // Graph.CopyGRAttribsIfNotExistsExcept(htAttribs, n.gr_attribs, Graph.a_subgraph_inherit_from_node_except);  // e.g. for "sw" and "sh" span width/height attribs

                     // (todo)
                     // l <= createPortsLayerFor(n, deref l);

                     pRow.addLayer(deref l, Layout.RIGHT);
                     if(b_gf_debug2)
                     {
                        trace "[trc] GraphForm::addSubgraph: Subgraph node n"+n.getString()+" gw="+#(gw);
                        subgraph.debugPrint();
                     }
                     bAdded = true;
                  }
               }

               if(!bAdded)
               {
                  if( n.b_helper || hasAreaZero(n.gr_attribs) || ('#' == n.id.getc(0)) ) // "*" / "#"
                  {
                     if(0)
                     {
                        local Label lb <= Label.New();
                        // // lb.setCaption(n.label);
                        lb.setFontByName("graph_node");
                        lb.setEnableFillBackground(false);
                        lb.setBackgroundColor(0);

                        // // if(n.haveNodeAttrib("bgcolor"))
                        // // {
                        // //    lb.setBackgroundColor(#ff000000 | int(n.getNodeAttrib("bgcolor")));
                        // //    lb.setEnableFillBackground(true);
                        // // }
                        // // else
                        // // {
                        // //    lb.setBackgroundColor(#fff6f6f6);
                        // //    lb.setEnableFillBackground(true);
                        // // }

                        if(n.haveNodeAttrib("node_fgcolor"))
                           lb.setForegroundColor(#ff000000 | int(n.getNodeAttrib("node_fgcolor")));
                        else if(n.haveNodeAttrib("fgcolor"))
                           lb.setForegroundColor(#ff000000 | int(n.getNodeAttrib("fgcolor")));

                        l <= deref lb;
                        pRow.addLayer(deref l, Layout.RIGHT);
                        n.ui_layer <= l;
                        n.ui_content_layer <= l;
                     }
                     else
                     {
                        // Helper node will be used as curve control point
                        local Spacer spcHelper <= Spacer.New();
                        // // spcHelper.initSpacer();
                        spcHelper.setRequiredSize2f(1,1);  // [12Mar2024] set size (0;0) ? (0.01 does not work / clipped to 1)
                        spcHelper.setPadding4f(0,0,0,0);
                        // spcHelper.setAlignment(Layout.CENTERY);
                        spcHelper.setAlignment(Layout.CENTER);  // [21Mar2024] CENTER
                        setLayerSizeFromGRAttribs(spcHelper, n.gr_attribs);
                        setLayerAlignmentFromGRAttribs(spcHelper, n.gr_attribs);
                        setLayerSizeGroupFromGRAttribs(spcHelper, n.gr_attribs);
                        l <= deref spcHelper;
                        pRow.addLayer(deref l, Layout.RIGHT);
                        n.ui_layer <= l;
                        n.ui_content_layer <= l;
                     }
                  }
                  else if(1)
                  {
                     if(null != n.xfm_layer)
                        l <= useNodeWidget(n, n.gr_attribs);
                     else
                        l <= createButtonForNodeOrLabel(n, n.label, n.gr_attribs);  // (note) sets n.ui_content_layer to bt and n.ui_layer to outer panel
                     // // setLayerPaddingFromGRAttribs(l, n.gr_attribs);
                     htAttribs <= n.gr_attribs;
                     setLayerSizeGroupFromGRAttribs(n.ui_content_layer, htAttribs);
                     pRow.addLayer(deref l, Layout.RIGHT);
                  }
                  else
                  {
                     local Spacer spcNodeDebug <= Spacer.New();
                     // // spcNodeDebug.initSpacer();
                     l <= deref spcNodeDebug;
                     pRow.addLayer(deref l, Layout.RIGHT);
                  }

                  // trace "xxx gridPos=("+gridX+";"+gridY+") n="+n.getString()+" => l="+#(l);
                  // // trace "xxx set n.ui_layer="+#(l)+" (3)";
                  // // // n.ui_layer <= l;
               }
            }
            else
            {
               // Empty cell
               local Spacer spc <= Spacer.New();
               spc.setAlignment(Layout.CENTER);  // [21Mar2024]
               // // spc.initSpacer();
               l <= deref spc;
               pRow.addLayer(deref l, Layout.RIGHT);
            }

            // // // // // l.setAlignment(Layout.BASELINEY);
            // // l.setPadding4f(defPaddingY+1, defPaddingX, defPaddingY, defPaddingX);  // (todo) why +1?

            if(l instanceof Spacer && ((null == n) || !n.b_helper))
            {
               l.setPadding4f(0,0,0,0);
            }
            else
            {
               // trace "xxx l="+#(l)+" n.ui_content_layer="+#(n.ui_content_layer)+"(dpyStr=\""+(n.ui_content_layer.getDisplayedText())+"\") defPaddingY="+defPaddingY;
               l.setPadding4f(defPaddingY, defPaddingX, defPaddingY, defPaddingX);
            }

            if(null != htAttribs)
               setLayerPaddingFromGRAttribs(l, htAttribs);

            if( null != n && null != htSpacer && ('#' == n.id.getc(0)) )
            {
               setLayerPaddingFromGRAttribs  (l, htSpacer);
               setLayerSizeFromGRAttribs     (l, htSpacer);
               setLayerSizeGroupFromGRAttribs(l, htSpacer);
            }

            if(graph.b_zero_margin)
            {
               if(0 == gridY)
                  l.setPadTop(0.0f);
               if(gridY == (graph.grid_h-1))
                  l.setPadBottom(0.0f);

               if(0 == gridX)
                  l.setPadLeft(0.0f);
               if(gridX == (graph.grid_w-1))
                  l.setPadRight(0.0f);
            }

            // if(l.pad_top > 0.0f)
            //    trace "xxx   graph l="+#(l)+" l.pad_top="+l.pad_top;

            l.setSizeGroup(sgx);

            gridX++;
         }
         gridY--;
      }

      // setRequiredSize2f(1000, 1000);  // (todo) move/change

      // trace "xxx GraphForm: minSz="+getMinimumSizeString();
      // trace "xxx GraphForm: prefSz="+getPreferredSizeString();
      if(b_gf_debug4) printHierarchy();
   }

   protected method assignRequiredPositionsToNodeLayers() {
      setLayout(null);

      // // gridY = graph.grid_h - 1;
      // // loop(graph.grid_h)
      // // {
      // //    gridX = 0;

      // //    loop(graph.grid_w)
      // //    {
      // //       c <= graph.getCell(gridX, gridY);
      // //       // trace "xxx c="+#(c);
      // //       l <= null;
      // //       htAttribs <= null;

      // //       if(null != c.node)
      // //       {
      // //          n <= c.node;
      // //          htAttribs <= n.gr_attribs;
      // //          // // l <= n.ui_layer;
      // //          l <= n.getUIPanelLayer();
      // //          if(null != l)
      // //          {
      // //             // trace "xxx n.id="+n.id+" l="+#(l)+" lcontent="+#(n.ui_content_layer)+" lpanel="+#(n.ui_panel_layer); //+" htAttribs="+htAttribs;
      // //             if(htAttribs.exists("x"))
      // //             {
      // //                l.setRequiredPosition2fScaled(htAttribs.get("x"), htAttribs.get("y"));
      // //                // trace "xxx GraphForm: bFixed=1 n.id="+n.id+"  l="+#(l)+"  p=("+l.getPositionString();
      // //             }
      // //          }
      // //       }

      // //       gridX++;
      // //    }
      // //    gridY--;
      // // }

      Node *n;
      foreach n in graph.nodes
      {
         HashTable htAttribs <= n.gr_attribs;
         Layer l <= n.getUIPanelLayer();
         if(null != l)
         {
            // trace "xxx n.id="+n.id+" l="+#(l)+" lcontent="+#(n.ui_content_layer)+" lpanel="+#(n.ui_panel_layer); //+" htAttribs="+htAttribs;
            if(htAttribs.exists("x"))
            {
               l.setRequiredPosition2fScaled(htAttribs.get("x"), htAttribs.get("y"));
               // trace "xxx GraphForm: bFixed=1 n.id="+n.id+"  l="+#(l)+"  p=("+l.getPositionString();
            }
         }
      }
   }

   protected method addNode_GridLayout(local Node      n,
                                       local HashTable _htSpacerOrNull,
                                       local Value     _rethtAttribs,
                                       local float     _defPaddingX,
                                       local float     _defPaddingY,
                                       local Value     _retl
                                       ) : Layer {
      // returns outer Layer / Panel
      local Layer *l;
      local Layer *lOuter;
      local Panel *pOuter;
      local boolean bAdded = false;
      local HashTable *htAttribs;
      local Graph subgraph <= n.parent_subgraph;
      if(null != subgraph)
      {
         if(b_gf_debug)
            trace "[trc] GraphForm::addNodesFromGraph_GridLayout: n"+n.getString()+" subgraph.id="+subgraph.id+" subgraph.layout="+subgraph.layout+" subgraph.doUnfold="+subgraph.doUnfold();

         if(Graph.LAYOUT_TABLE == subgraph.layout)
         {
            local TableGraphPanel pTable <= new TableGraphPanel;
            pTable.initTableGraphPanel(this, subgraph);
            pTable.setLayerId("TABLE_GRAPH_"+subgraph.id);
            pTable.setEnableCollapse(true);
            pTable.setPanelBorderWidth(0.0f);
            pTable.setPadding4f(0,0,0,0);
            setLayerSizeGroupFromGRAttribs(pTable, subgraph.gr_attribs);

            local Panel pTableIPad <= Panel.New();
            pTableIPad.setLayerId("TABLE_GRAPH_IPad");
            pTableIPad.setEnableCollapse(true);
            pTableIPad.setEnableDecorative(true);
            pTableIPad.setPanelBackgroundStyle(Panel.STYLE_SOLID);
            pTableIPad.setPanelBorderWidth(0.0f);
            pTableIPad.setPanelBorderStyle(Panel.STYLE_NONE);
            pTableIPad.setPanelBorderShape(Panel.SHAPE_NONE);
            pTableIPad.setPadding4f(0,0,0,0);
            setPanelInnerPaddingFromGRAttribs(pTable, subgraph.gr_attribs);
            copyBackgroundFromGRAttribsToPanel(subgraph.gr_attribs, pTable); // ?? (==> !! fixes center row/table bg in test23d.gr)
            copyBackgroundFromGRAttribsToPanel(subgraph.gr_attribs, pTableIPad);
            if(b_gf_debug) trace "[trc] ************************ table subgraph.id="+subgraph.id+" gr_attribs="+#(subgraph.gr_attribs);
            pTableIPad.addLayer(deref pTable, Layout.CENTER);
            // pTableIPad.setDebug(true);

            pOuter <= createPanelForLayer(n, deref pTableIPad, subgraph.gr_attribs, true/*bDefAlignTopLeft*/);
            l <= deref pOuter;
            // trace "xxx pOuter.panel_border_shape="+pOuter.panel_border_shape;
            if(Panel.SHAPE_RECT != pOuter.panel_border_shape)
            {
               copyPanelShapeAndBorderAttribs(pOuter, pTableIPad);
            }

            // trace "xxx table subgraph.id="+subgraph.id+" gr_attribs="+#(subgraph.gr_attribs);
            // // // setLayerPaddingFromGRAttribs(l, subgraph.gr_attribs);
            if(b_gf_debug2) trace "[trc] GraphForm::addNodesFromGraph<GridLayout>: table subgraph: pTable     panel_alpha="+pTable.panel_alpha+" panel_tint="+UI.GetColorString(pTable.panel_tint)+" bg_shape="+pTable.panel_bg_shape;
            if(b_gf_debug2) trace "[trc] GraphForm::addNodesFromGraph<GridLayout>: table subgraph: pTableIPad panel_alpha="+pTableIPad.panel_alpha+" panel_tint="+UI.GetColorString(pTableIPad.panel_tint)+" bg_shape="+pTableIPad.panel_bg_shape;
            if(b_gf_debug2) trace "[trc] GraphForm::addNodesFromGraph<GridLayout>: table subgraph: pOuter     panel_alpha="+pOuter.panel_alpha+" panel_tint="+UI.GetColorString(pOuter.panel_tint)+" bg_shape="+pOuter.panel_bg_shape;
            // // pTable.setPanelAlphaAndTint(255, #ff00ff00);
            htAttribs <= subgraph.gr_attribs;

            addTableSubgraph(subgraph, pTable);
            bAdded = true;
         }
         // // else if(!subgraph.b_unfold && (null != n.cell))
         else if(!subgraph.doUnfold() && (null != n.cell))
         {
            local GraphForm gw <= new GraphForm;
            gw.initGraphForm(this/*parent_graph_form*/);
            gw.setPortButtonClass(port_button_class);
            gw.setLayerId(n.id);  // [18Feb2025]
            gw.setEnableDecorative(true);
            gw.graph <= subgraph;
            setLayerRequiredSizeFromAttribs(gw, subgraph.gr_attribs);  // [01Feb2025] experimental abs positioning/size
            subgraph.graph_form <= gw;
            setLayerSizeGroupFromGRAttribs(gw, subgraph.gr_attribs);
            local Panel pGraph <= Panel.New();
            pGraph.setEnableCollapse(true);
            pGraph.setEnableDecorative(true);
            pGraph.setPanelBackgroundStyle(Panel.STYLE_SOLID);
            pGraph.setPadding4f(0,0,0,0);
            pGraph.addLayer(deref gw, Layout.CENTER);
            copyBackgroundFromGRAttribsToPanel(subgraph.gr_attribs, pGraph);  // (note) pGraph
            setPanelInnerPaddingFromGRAttribs(gw, subgraph.gr_attribs);
            // gw.setDebug(true);
            // trace "xxx pOuter subgraph.gr_attribs="+#(subgraph.gr_attribs);
            pOuter <= createPanelForLayer(n, deref pGraph, subgraph.gr_attribs, true/*bDefAlignTopLeft*/);
            // trace "xxx subgraph: n.ui_layer="+#(n.ui_layer)+" n.ui_content_layer="+#(n.ui_content_layer);
            if(Panel.SHAPE_RECT != pOuter.panel_border_shape)
               copyPanelShapeAndBorderAttribs(pOuter, pGraph);

            // // // l <= deref pOuter;
            // // trace "xxx call createPortsLayerFor subgraph";
            lOuter <= createPortsLayerFor(n, deref pOuter);
            l <= lOuter;
            // // htAttribs <= subgraph.gr_attribs;
            htAttribs <= new HashTable;
            htAttribs = subgraph.gr_attribs;
            htAttribs.realloc(512);
            Graph.CopyGRAttribsIfNotExists(htAttribs, n.gr_attribs);  // e.g. for "sw" and "sh" span width/height attribs
            // // Graph.CopyGRAttribsIfNotExistsExcept(htAttribs, n.gr_attribs, Graph.a_subgraph_inherit_from_node_except);  // e.g. for "sw" and "sh" span width/height attribs
            if(b_gf_debug2)
            {
               trace "[trc] GraphForm::addNodesFromGraph_GridLayout: subgraph node n"+n.getString()+" gw="+#(gw);
               subgraph.debugPrint();
            }
            bAdded = true;

         }
      }

      if(!bAdded)
      {
         if( n.b_helper || hasAreaZero(n.gr_attribs) || ('#' == n.id.getc(0)) ) // "*" / "#"
         {
            if(0)
            {
               local Label lb <= Label.New();
               lb.setFontByName("graph_node");
               lb.setEnableFillBackground(false);
               lb.setBackgroundColor(0);

               if(n.haveNodeAttrib("node_fgcolor"))
                  lb.setForegroundColor(#ff000000 | int(n.getNodeAttrib("node_fgcolor")));
               else if(n.haveNodeAttrib("fgcolor"))
                  lb.setForegroundColor(#ff000000 | int(n.getNodeAttrib("fgcolor")));

               l <= deref lb;
               n.ui_layer <= l;
               n.ui_content_layer <= l;
            }
            else
            {
               // Helper node will be used as curve control point
               local Spacer spcHelper <= Spacer.New();
               // // spcHelper.initSpacer();
               spcHelper.setRequiredSize2f(1,1);  // [12Mar2024] set size (0;0) ? (0.01 does not work / clipped to 1)
               spcHelper.setPadding4f(0,0,0,0);
               // spcHelper.setAlignment(Layout.CENTERY);
               spcHelper.setAlignment(Layout.CENTER);  // [21Mar2024] CENTER
               setLayerSizeFromGRAttribs(spcHelper, n.gr_attribs);
               setLayerAlignmentFromGRAttribs(spcHelper, n.gr_attribs);
               setLayerSizeGroupFromGRAttribs(spcHelper, n.gr_attribs);
               l <= deref spcHelper;
               n.ui_layer <= l;
               n.ui_content_layer <= l;
               l.setLayerId((n.b_helper?"helper_":"zero_")+n.id);
            }
         }
         else if(1)
         {
            if(null != n.xfm_layer)
               l <= useNodeWidget(n, n.gr_attribs);
            else
               l <= createButtonForNodeOrLabel(n, n.label, n.gr_attribs);  // (note) sets n.ui_content_layer to bt and n.ui_layer to outer panel
            htAttribs <= n.gr_attribs;
            setLayerSizeGroupFromGRAttribs(n.ui_content_layer, htAttribs);
            // trace "xxx addNodesFromGraph_GridLayout: add regular node n="+n.getString()+" => l="+#(l);
         }
         else
         {
            local Spacer spcNodeDebug <= Spacer.New();
            // // spcNodeDebug.initSpacer();
            l <= deref spcNodeDebug;
         }

         // trace "xxx gridPos=("+gridX+";"+gridY+") n="+n.getString()+" => l="+#(l);
         // // trace "xxx set n.ui_layer="+#(l)+" (3)";
         // // n.ui_layer <= l;
      }

      // // if(null != n)
      // //    lOuter <= createPortsLayerFor(n, deref l);

      if(null == lOuter)
         lOuter <= deref l;

      // // Panel pCell <= Panel.New();
      // // pCell.setEnableCollapse(true);
      // // pCell.setPreferredSize2f(defPaddingX, defPaddingY);
      // // pCell.addLayer(deref l, Layout.CENTER);
      // // addGridLayer(deref pCell, gridX, gridY, 1, 1);

      if( (l instanceof Spacer) && !n.b_helper )
      {
         l.setPadding4f(0,0,0,0);
      }
      else
      {
         // if(null != n && (l instanceof Spacer))
         //    trace " Spacer n.id="+n.id+" b_helper="+n.b_helper;
         // trace "xxx l="+#(l)+" n.ui_content_layer="+#(n.ui_content_layer)+"(dpyStr=\""+(n.ui_content_layer.getDisplayedText())+"\") defPaddingY="+defPaddingY;
         l.setPadding4f(_defPaddingY, _defPaddingX, _defPaddingY, _defPaddingX);
      }

      if(null != htAttribs)
         setLayerPaddingFromGRAttribs(l, htAttribs);

      // // if( null != n && null != htSpacerOrNull && ('#' == n.id.getc(0)) )
      if( null != _htSpacerOrNull && ('#' == n.id.getc(0)) )
      {
         setLayerPaddingFromGRAttribs  (l, _htSpacerOrNull);
         setLayerSizeFromGRAttribs     (l, _htSpacerOrNull);
         setLayerSizeGroupFromGRAttribs(l, _htSpacerOrNull);
      }

      _retl.objectValue = l;
      _rethtAttribs = #(deref htAttribs);

      return deref lOuter;
   }

   protected method addNodes_fixed_GridLayout(local HashTable _htSpacerOrNull,
                                              local float     _defPaddingX,
                                              local float     _defPaddingY
                                              ) {
      local Node *n;
      local int gridX = 0;
      foreach n in graph.nodes
      {
         local Value vl;
         local Value vhtAttribs;

         Layer lOuter <= addNode_GridLayout(n,
                                            _htSpacerOrNull,
                                            vhtAttribs,
                                            _defPaddingX,
                                            _defPaddingY,
                                            vl
                                            );

         Layer l <= vl.objectValue;
         HashTable htAttribs <= vhtAttribs.objectValue;

         addGridLayer(deref lOuter, gridX++, 0/*gridY*/, 1/*colSpanW*/, 1/*rowSpanH*/);

         if(b_gf_debug2) trace "[dbg] GraphForm::addNodes_fixed_GridLayout: add l="+l.getDebugString()+" htAttribs="+#(htAttribs);
      }
   }

   protected method addNodes_GridLayout(local HashTable _htSpacerOrNull,
                                        local float     _defPaddingX,
                                        local float     _defPaddingY
                                        ) {
      local Layer *l;

      local int gridY = graph.grid_h - 1;
      loop(graph.grid_h)
      {
         local int gridX = 0;

         // (todo) slant
         // if(gridY > 0 && slantFactor > 0.0f)
         // {
         //    local Spacer spcSlant <= new Spacer;
         //    spcSlant.initSpacer();
         //    spcSlant.setRequiredSize2f(slantFactor * gridY, 4);
         //    // spcSlant.setDebug(true);
         //    pRow.addLayer(deref spcSlant, Layout.RIGHT);
         // }

         loop(graph.grid_w)
         {
            local Cell c <= graph.getCell(gridX, gridY);
            // trace "xxx c="+#(c);
            l <= null;
            // // local int tint;
            local Node n <= c.node;

            if(null != n)
            {
               local Value vl;
               local Value vhtAttribs;

               Layer lOuter <= addNode_GridLayout(n,
                                                  _htSpacerOrNull,
                                                  vhtAttribs,
                                                  _defPaddingX,
                                                  _defPaddingY,
                                                  vl
                                                  );

               l <= vl.objectValue;
               HashTable htAttribs <= vhtAttribs.objectValue;

               int colSpanW = 1;
               int rowSpanH = 1;
               if(null != htAttribs)
               {
                  if(htAttribs.exists("sw"))
                     colSpanW = mathMaxi(1, htAttribs["sw"]);

                  if(htAttribs.exists("sh"))
                     rowSpanH = mathMaxi(1, htAttribs["sh"]);
               }

               // trace "xxx addGridLayer grid=("+gridX+","+gridY+") l="+#(l);
               addGridLayer(deref lOuter, gridX, gridY, colSpanW, rowSpanH);

               if(b_gf_debug2) trace "[dbg] GraphForm::addNodes_GridLayout: ("+gridX+";"+gridY+") add l="+l.getDebugString()+" htAttribs="+#(htAttribs);
            }
            else
            {
               // Empty cell
               // trace "xxx empty cell";
               local Spacer spc <= Spacer.New();
               spc.alignment = Layout.CENTER;  // [21Mar2024]
               l <= deref spc;
               l.setLayerId("empty_"+gridX+"_"+gridY);
               l.setPadding4f(0,0,0,0);

               // trace "xxx addGridLayer grid=("+gridX+","+gridY+") l="+#(l);
               addGridLayer(deref l, gridX, gridY, 1/*colSpanW*/, 1/*rowSpanH*/);

               if(b_gf_debug2) trace "[dbg] GraphForm::addNodes_GridLayout: spacer ("+gridX+";"+gridY+") add l="+l.getDebugString();
            }


            if(graph.b_zero_margin)
            {
               if(0 == gridY)
                  l.setPadTop(0.0f);
               if(gridY == (graph.grid_h-1))
                  l.setPadBottom(0.0f);

               if(0 == gridX)
                  l.setPadLeft(0.0f);
               if(gridX == (graph.grid_w-1))
                  l.setPadRight(0.0f);
            }

            gridX++;
         }
         gridY--;
      }
   }

   protected method addNodesFromGraph_GridLayout(local boolean _bFixed) {
      if(b_gf_debug) trace "[trc] GraphForm::addNodesFromGraph_GridLayout: this="+#(this)+" graph.sz="+graph.getSizeString()+" bFixed="+_bFixed;
      setLayout(GridLayout);

      local GraphForm rootGraphForm <= this;
      while(null != rootGraphForm.parent_graph_form)
         rootGraphForm <= rootGraphForm.parent_graph_form;

      local HashTable *htSpacer;
      if(graph.haveGraphAttrib("spacer_class"))
      {
         GRStyle spacerStyle <= rootGraphForm.gr.findStyleClass(graph.getGraphAttrib("spacer_class"));
         if(null != spacerStyle)
            htSpacer <= spacerStyle.attribs;
         else
            trace "[~~~] addNodesFromGraph_GridLayout: undeclared spacer_class '"+graph.getGraphAttrib("spacer_class")+"' (graph.id='"+graph.id+"'), skipping..";
      }

      local float defPaddingX = 16.0f;
      local float defPaddingY = 12.0f;
      local float slantFactor = 16.0f;

      if(graph.haveGraphAttrib("pad_col"))
         defPaddingX = graph.getGraphAttrib("pad_col");
      else if(graph.haveGraphAttrib("col_padding"))
         defPaddingX = graph.getGraphAttrib("col_padding");

      if(graph.haveGraphAttrib("pad_row"))
         defPaddingY = graph.getGraphAttrib("pad_row");
      else if(graph.haveGraphAttrib("row_padding"))
         defPaddingY = graph.getGraphAttrib("row_padding");

      if(graph.haveGraphAttrib("slant_factor"))
         slantFactor = graph.getGraphAttrib("slant_factor");

      /*Layer::*/layout_grid_slant_factor = graph.b_slant ? slantFactor : 0.0f;

      // // if(null == graph.parent_graph)
      // //    setLayerPaddingFromGRAttribs(this, graph.gr_attribs);

      // (note) background is rendered _before_ graph edges
      int tintPost = graph.haveGraphAttrib("tint") ? int(graph.getGraphAttrib("tint")) : 0;

      int graphBgColor = 0;
      if(graph.haveGraphAttrib("bgcolor"))
         graphBgColor = int(graph.getGraphAttrib("bgcolor"));
      if(graph.haveGraphAttrib("bgtint"))
         graphBgColor = sdvg_TintARGB(graphBgColor, graph.getGraphAttrib("bgtint"));
      if(0 != graphBgColor)
      {
         if(0 != tintPost)
            graphBgColor = sdvg_TintARGB(graphBgColor, tintPost);
         setPanelAlphaAndTint(255, graphBgColor | 0xFF000000);
      }
      else
         setPanelAlphaAndTint(255, #fff9f9f9);

      if(null == graph.parent_graph)
      {
         Panel pParent <= parent;
         if(pParent instanceof Panel)
            pParent.setPanelAlphaAndTint(panel_alpha, panel_tint);
      }

      // // (note) graph edges are rendered _after_ background and nodes
      // // local Panel pCtr <= Panel.New();
      // // pCtr.setLayerId("graph_"+graph.id+"_pCtr");
      // // pCtr.setEnableCollapse(true);
      // // pCtr.setEnableDecorative(true);
      // // pCtr.setPadding4f(0,0,0,0);
      // // // if(null != graph.parent_graph)
      // // //    setLayerPaddingFromGRAttribs(pCtr, graph.gr_attribs);

      // // // pCtr.setDebug(true);
      // // addLayer(deref pCtr, Layout.CENTER | Layout.BASELINEY);

      // trace "xxx addNodesFromGraph_GridLayout: graph.gr_attribs="+#(graph.gr_attribs);
      // trace "xxx addNodesFromGraph_GridLayout: graph.id='"+graph.id+"' gridSz=("+graph.grid_w+","+graph.grid_h+")";

      if(_bFixed)
      {
         addNodes_fixed_GridLayout(htSpacer, defPaddingX, defPaddingY);
         assignRequiredPositionsToNodeLayers();
      }
      else
      {
         addNodes_GridLayout(htSpacer, defPaddingX, defPaddingY);
      }

      if(b_gf_debug) trace "[dbg] GraphForm::addNodesFromGraph<GridLayout>: minSz="+getMinimumSizeString();
      if(b_gf_debug) trace "[dbg] GraphForm::addNodesFromGraph<GridLayout>: prefSz="+getPreferredSizeString();
      if(b_gf_debug4) printHierarchy();

      // trace "xxx addNodesFromGraph_GridLayout: this.alignment="+alignment;
   }

   protected method calcHeadPoint(Point2f _p,
                                  float _startX,
                                  float _startY,
                                  float _endX,
                                  float _endY,
                                  int   _curEdgeIdx,
                                  int   _numEdges,
                                  HashTable _htAttribs
                                  ) {
      // avoid arrow collisions when multiple edges connect to the same node
      float d = 0.0f;
      float o = 0.0f;

      float nx = (_endX - _startX);
      float ny = (_endY - _startY);
      float l = sqrt(nx*nx + ny*ny);

      if(_numEdges > 1)
      {
         float hpAmount = 0.125f;
         if(_htAttribs.exists("headpoint_amount"))
            hpAmount = GRUtils.GetAttribAmount(_htAttribs, "headpoint_amount");

         float hpMinDist = 8.0f;
         if(_htAttribs.exists("headpoint_mindist"))
            hpMinDist = float(_htAttribs["headpoint_mindist"]);
         hpMinDist *= UI.font_scaling;

         // // d = mathMinf(0.5f, _numEdges * hpAmount);
         d = mathClampf(_numEdges * hpAmount, 0.15f, 0.85f);
         float minPixelDist = hpMinDist;
         if(l > minPixelDist)
         {
            // test21.gr: keep min pixel distance
            if(d*l < minPixelDist)
               d = minPixelDist / l;
         }
         o = _curEdgeIdx / float(_numEdges - 1);
      }
      else
      {
         d = 1.0f;
         o = 0.5f;
      }

      _p.x = _startX + (nx * (d * o + (1.0f - d)*0.5f));
      _p.y = _startY + (ny * (d * o + (1.0f - d)*0.5f));

      if(b_gf_debug2)
         trace "[trc] calcHeadPoint: start=("+_startX+";"+_startY+") end="+_endX+";"+_endY+") curEdgeIdx="+_curEdgeIdx+" numEdges="+_numEdges+" => p="+_p.getString();
   }

   protected method getNodePosition(Node _n, Point2f _p, float _distX, float _distY) {
      if(_n.b_position_override)
      {
         _p.x = _n.position_override_x;  // dist already factored in
         _p.y = _n.position_override_y;
      }
      else
      {
         // Layer l <= _n.ui_layer;
         Layer l <= _n.getUIPortsLayer();
         l.calcPositionWithin(this, _p);
         _p.x -= _distX;
         _p.y -= _distY;
         if(b_gf_debug2) trace "[trc] getNodePosition: n="+_n.getString()+" l="+#(l)+" displayedText=\""+l.getDisplayedText()+"\" p="+_p.getString();
      }
   }

   protected method findGraphEdge(Node _a, Node _b) : GraphEdge {
      GraphEdge *ge;
      foreach ge in graph_edges
      {
         Edge e <= ge.edge;
         if(e.connectsTo(_a) && e.connectsTo(_b))
            return ge;
      }
      return null;
   }

   // // protected method getDirFlagsVia(Layer lTail, Layer lHead, Point2f pVia) {
   // //    // return position of head relative to tail with respect to control point 'pVia'
   // //    if( (lTail.y + lTail.size_y) < lHead.y )
   // //    {
   // //       // tail above head
   // //    }
   // //    else
   // //    {
   // //       // head above tail
   // //    }
   // // }

   protected static CenterPoint(Point2f p, Size2f s) {
      p.init(p.x + (s.x * 0.5f),
             p.y + (s.y * 0.5f)
             );
      s.x = 0;
      s.y = 0;
   }

   protected static CenterPointLayer(Point2f p, Layer l) {
      p.init(p.x + (l.getSizePadX() * 0.5f),
             p.y + (l.getSizePadY() * 0.5f)
             );
   }

   protected method freeGraphEdges() {
      GraphEdge *ge;
      foreach ge in graph_edges
         ge.freeGraphEdge();  // delete OpenGL VBO (when b_graphedge_shapes = true)   (todo) is the GL context current at this point ?
      graph_edges.free();
   }

   protected method addEdgesFromGraph() {
      // Edges
      if(b_gf_debug) trace "[trc] GraphForm::addEdgesFromGraph: graph.id="+graph.id+" #edges="+(graph.edges.numElements);
      freeGraphEdges();
      graph.recursiveUIEdgeReset();

      Edge *e;
      boolean bGraphXMajorTail = graph.isXMajorTail();
      boolean bGraphXMajorHead = graph.isXMajorHead();
      boolean bGraphXMajor = graph.isXMajor();
      if(maybe == bGraphXMajorTail)
         bGraphXMajorTail = bGraphXMajor;
      if(maybe == bGraphXMajorHead)
         bGraphXMajorHead = bGraphXMajor;
      boolean bXMajorTail;
      boolean bXMajorHead;
      Node *nTail;
      Node *nHead;
      Layer *lTail;
      Layer *lHead;
      Point2f pTail;
      Point2f pHead;
      GraphEdge *ge;
      Point2f pDst;
      int dirFlags;
      Layer *lHelper;
      int forcedDirHead;

      // Pass 1: calc direction flags (head in relation to tail) and number of connection to node sides (top/left/bottom/right)
      foreach e in graph.edges
      {
         if(e.isPlaced() && e.isVisible())
         {
            bXMajorTail = e.isXMajorTail();
            bXMajorHead = e.isXMajorHead();
            // trace "xxx addEdgesFromGraph: graph("+graph.id+") bXMajor="+bGraphXMajor+" edge bXMajorTail="+bXMajorTail+" (e="+e.getString()+")";
            if(maybe == bXMajorTail)
               bXMajorTail = bGraphXMajorTail;
            if(maybe == bXMajorHead)
               bXMajorHead = bGraphXMajorHead;

            nTail <= e.tail;
            nHead <= e.head;
            // lTail <= nTail.ui_layer;
            // lHead <= nHead.ui_layer;
            lTail <= nTail.getUIPortsLayer();
            lHead <= nHead.getUIPortsLayer();

            // trace "xxx e="+e.getString()+" lTail="+#(lTail)+" lHead="+#(lHead);
            if(null != lTail && null != lHead)
            {
               // trace "lTail.pos="+lTail.getPositionString()+" lTail.parent="+#(lTail.parent)+" lTail.position_x="+lTail.position_x;
               lTail.calcPositionWithin(this, pTail);
               lHead.calcPositionWithin(this, pHead);
               dirFlags = e.calcDirFlags(lTail, lHead, pTail, pHead);  // updates e.ui_dir_flags
               e.b_ui_xmajor_tail = bXMajorTail;
               e.b_ui_xmajor_head = bXMajorHead;
               // trace "xxx e="+e.getString()+" pTail="+pTail.getString()+" pHead="+pHead.getString()+" => dirFlags="+dirFlags;

               if(null != e.head_port)
                  forcedDirHead = e.head_port.dir;
               else
                  forcedDirHead = e.head_dir;

               // // if(nHead.id == "l")
               // //    trace "xxx nHead.id=l  forcedDirHead="+forcedDirHead;

               switch(forcedDirHead)
               {
                  case Layout.TOP:     // n
                     nHead.num_edges_t++;
                     break;

                  case Layout.LEFT:    // w
                     nHead.num_edges_l++;
                     break;

                  case Layout.BOTTOM:  // s
                     nHead.num_edges_b++;
                     break;

                  case Layout.RIGHT:   // e
                     nHead.num_edges_r++;
                     break;

                  default: // auto(0)
                     if(dirFlags & Layout.RIGHT)
                     {
                        if(dirFlags & Layout.BOTTOM)
                        {
                           // head is on the right/bottom side of tail
                           if(bXMajorHead)
                              nHead.num_edges_l++;
                           else
                              nHead.num_edges_t++;
                        }
                        else if(dirFlags & Layout.TOP)
                        {
                           // head is on the right/top side of tail
                           if(bXMajorHead)
                              nHead.num_edges_l++;  // [23Mar2024]
                           else
                              nHead.num_edges_b++;  // [14Mar2024]
                        }
                        else
                        {
                           // head is on the right side of tail
                           nHead.num_edges_l++;
                        }
                     }
                     else if(dirFlags & Layout.LEFT)
                     {
                        if(dirFlags & Layout.BOTTOM)
                        {
                           // head is on the bottom/left side of tail
                           nHead.num_edges_t++;
                        }
                        else if(dirFlags & Layout.TOP)
                        {
                           // head is on the top/left side of tail
                           nHead.num_edges_b++;
                        }
                        else
                        {
                           // head is on the left side of tail
                           nHead.num_edges_r++;
                        }
                     }
                     else
                     {
                        if(dirFlags & Layout.BOTTOM)
                        {
                           // head is on the bottom side of tail
                           nHead.num_edges_t++;
                        }
                        else if(dirFlags & Layout.TOP)
                        {
                           // head is on the top side of tail
                           nHead.num_edges_b++;
                        }
                        else
                        {
                           // head overlaps? with tail (?!)
                           trace "xxx head overlaps? with tail (?!) nHead"+nHead.getString();
                        }
                     }
                     break;
               } // switch forcedDirHead

               // // if(nHead.id == "l")
               // //    trace "xxx nHead.id=l num_edges_l="+nHead.num_edges_l;

            } // if ui_layers
         } // if isPlaced
      }

      // Pass 2: layout edges
      Size2f  tailSz;
      Size2f  headSz;
      Edge   *eTail;
      Node   *nTailOther;
      Edge   *eHead;
      Node   *nHeadOther;
      Point2f pAvg;
      Layer  *lTmp;
      Node   *nTmp;
      Node   *nTmp2;
      Edge   *eTmp;
      Point2f pTmp;
      Point2f pVia;
      boolean bVia;
      int     dirFlagsViaTail;  // position of helper node relative to tail
      int     dirFlagsViaHead;  // position of helper node relative to head
      boolean bViaDoneTail;
      boolean bViaDoneHead;
      int     forcedDirTail;
      Port   *tailPort;
      Port   *headPort;

      float tailDistX = 1.0f * UI.font_scaling;
      float tailDistY = 1.0f * UI.font_scaling;

      float headDistX = tailDistX;
      float headDistY = tailDistY;

      foreach e in graph.edges
      {
         if(e.isPlaced() && e.isVisible())
         {
            bXMajorTail = e.isXMajorTail();
            bXMajorHead = e.isXMajorHead();
            // trace "xxx addEdgesFromGraph: graph("+graph.id+") bXMajor="+bGraphXMajor+" edge bXMajor="+bXMajor+" (e="+e.getString()+")";
            if(maybe == bXMajorTail)
               bXMajorTail = bGraphXMajorTail;
            if(maybe == bXMajorHead)
               bXMajorHead = bGraphXMajorHead;

            nTail <= e.tail;
            nHead <= e.head;
            // lTail <= nTail.ui_layer;
            // lHead <= nHead.ui_layer;
            lTail <= nTail.getUIPortsLayer();
            lHead <= nHead.getUIPortsLayer();
            if(null != lTail && null != lHead)
            {
               headPort <= e.head_port;
               tailPort <= e.tail_port;

               if(null != tailPort)
                  forcedDirTail = tailPort.dir;
               else
                  forcedDirTail = e.tail_dir;

               if(null != headPort)
                  forcedDirHead = headPort.dir;
               else
                  forcedDirHead = e.head_dir;

               // trace "xxx ------------- e="+e.getString()+" lTail="+lTail.getDebugString()+" lHead="+lHead.getDebugString();
               bVia = false;
               bViaDoneTail = false;
               bViaDoneHead = false;

               // trace "lTail.pos="+lTail.getPositionString()+" lTail.parent="+#(lTail.parent)+" lTail.position_x="+lTail.position_x;
               getNodePosition(nTail, pTail,  // get nTail.ui_layer.position_x/y  OR nTail.override_position_x/y
                               nTail.b_ui_helper ? 0 : tailDistX,
                               nTail.b_ui_helper ? 0 : tailDistY
                               );
               getNodePosition(nHead, pHead,
                               nHead.b_ui_helper ? 0 : headDistX,
                               nHead.b_ui_helper ? 0 : headDistY
                               );
               dirFlags = e.ui_dir_flags;  // use dirFlags from pass1 (don't recalc, must use original (helper-)node positions)
               // trace "xxx e="+e.getString()+" pTail="+pTail.getString()+" pHead="+pHead.getString()+" => dirFlags="+dirFlags;

               ge <= new GraphEdge;
               // trace "xxx new GraphEdge";
               ge.initShape(e);

               tailSz.x = lTail.size_x + tailDistX*2;
               tailSz.y = lTail.size_y + tailDistY*2;

               headSz.x = lHead.size_x + headDistX*2;
               headSz.y = lHead.size_y + headDistY*2;

               float tailPBWH = 0;
               // trace "xxx lTail="+#(lTail);
               if(lTail instanceof Panel)
               {
                  Panel lTailPanel <= lTail;
                  tailPBWH = lTailPanel.panel_border_width;
               }

               float headPBWH = 0;
               if(lHead instanceof Panel)
               {
                  Panel lHeadPanel <= lHead;
                  tailPBWH = lHeadPanel.panel_border_width;
               }

               float tailPadR = lTail.pad_right  - tailPBWH;
               float tailPadB = lTail.pad_bottom - tailPBWH;

               float headPadR = lHead.pad_right  - headPBWH;
               float headPadB = lHead.pad_bottom - headPBWH;

               // trace "xxx nHead="+nHead.getString()+".b_ui_helper="+nHead.b_ui_helper;

               if(nTail.b_helper || nTail.b_ui_helper)
               {
                  CenterPoint(pTail, tailSz);
                  tailPadB = 0;
                  tailPadR = 0;
               }

               if(nHead.b_helper || nHead.b_ui_helper)
               {
                  CenterPoint(pHead, headSz);
                  headPadB = 0;
                  headPadR = 0;
               }

               boolean bHelperDone = false;
               boolean bSkipEdge = false;

               if(nTail.b_helper)
               {
                  if(!nTail.b_helper_done)
                  {
                     pTail.x = pTail.x + tailSz.x * 0.5f;
                     tailSz.x = 0.0f;

                     pTail.y = pTail.y + tailSz.y * 0.5f;
                     tailSz.y = 0.0f;

                     if(null == nTail.next_helper_node)
                     {
                        // Check if head is regular node and tail also connects to regular node
                        if(!nHead.b_helper)
                        {
                           eTail <= graph.findUniqueEdgeTo(nTail, nHead/*notN*/);
                           if(null != eTail)
                           {
                              nTailOther <= eTail.getOtherNode(nTail);
                              if(!nTailOther.b_helper)
                              {
                                 // single helper node, e.g. test13.gr c->e
                                 if(b_gf_debug2) trace "[trc] <tail> control point nTail"+nTail.getString()+" nTailOther"+nTailOther.getString()+" nHead"+nHead.getString();
                                 // => nTailOther->nHead via control point node nTail
                                 ge.b_curve_c = true;
                                 ge.curve_c1x = pTail.x;
                                 ge.curve_c1y = pTail.y;
                                 ge.curve_c2x = pTail.x;
                                 ge.curve_c2y = pTail.y;
                                 // lTail <= nTailOther.ui_layer;
                                 lTail <= nTailOther.getUIPortsLayer();
                                 lTail.calcPositionWithin(this, pTail);
                                 dirFlags = lTail.calcDirFlagsRelativeTo(lHead, pTail, pHead);
                                 nTail.b_helper_done = true;
                                 // trace "xxx set nTail"+nTail.getString()+".b_helper_done";
                                 nTail <= nTailOther;
                                 tailSz.x = lTail.size_x + tailDistX*2;
                                 tailSz.y = lTail.size_y + tailDistY*2;
                                 CenterPoint(pTail, tailSz);
                                 bHelperDone = true;
                              }
                              else
                              {
                                 // chained helper nodes, e.g. test13.gr b->e
                                 if(b_gf_debug2) trace "[trc] <tail> chained helper e="+e.getString()+" nTailOther"+nTailOther.getString()+" is helper";

                                 // move nTail half-way towards nTailOther and store tail position override (for next edge)
                                 getNodePosition(nTailOther, pTmp, tailDistX, tailDistY);
                                 // CenterPointLayer(pTmp, nTailOther.ui_layer);
                                 CenterPointLayer(pTmp, nTailOther.getUIPortsLayer());

                                 if(!ge.b_rcurve)
                                 {
                                    pTail.x = mathLerpf(pTail.x, pTmp.x, 0.5f);
                                    pTail.y = mathLerpf(pTail.y, pTmp.y, 0.5f);
                                 }
                                 nTail.b_position_override  = true;
                                 nTail.position_override_x  = pTail.x;
                                 nTail.position_override_y  = pTail.y;
                                 nTail.b_helper_done        = true;
                                 nTail.next_helper_node    <= nTailOther;  // save for pass3
                                 bHelperDone = true;
                              }
                           } // if null != eTail
                        } // if !nHead.b_helper
                     } // if null == nTail.next_helper_node
                  } // !nTail.b_helper_done
                  else
                  {
                     bSkipEdge = true;
                  }
               }

               if(!bHelperDone)
               {
                  if(b_gf_debug2)
                     trace "[trc] =================================== helper<head> GraphEdge dirFlags="+dirFlags+"  nTail"+nTail.getString()+" nHead"+nHead.getString();

                  if(nHead.b_helper)
                  {
                     // trace "xxx nHead"+nHead.getString()+".b_helper=1  nHead.b_helper_done="+nHead.b_helper_done;

                     if(!nHead.b_helper_done)
                     {
                        pHead.x = pHead.x + headSz.x * 0.5f;
                        headSz.x = 0.0f;

                        pHead.y = pHead.y + headSz.y * 0.5f;
                        headSz.y = 0.0f;

                        if(null == nHead.next_helper_node)
                        {
                           // Check if tail is regular node and head also connects to regular node
                           if(!nTail.b_helper)
                           {
                              eHead <= graph.findUniqueEdgeTo(nHead, nTail/*notN*/);
                              if(null != eHead)
                              {
                                 nHeadOther <= eHead.getOtherNode(nHead);
                                 if(!nHeadOther.b_helper)
                                 {
                                    if(b_gf_debug2) trace "[trc] <head> control point nHead"+nHead.getString()+" nTail"+nTail.getString()+(eHead.b_rev?"<-":"->")+"nHeadOther"+nHeadOther.getString()+" *****************************";
                                    // => nTail<>nHeadOther via control point node nHead
                                    bVia = true; pVia.x = pHead.x; pVia.y = pHead.y;
                                    dirFlagsViaTail = dirFlags; // position of helper relative to tail
                                    if(b_gf_debug2) trace "[trc]          dirFlagsViaTail="+dirFlagsViaTail;
                                    ge.b_curve_c = true;
                                    float ty;
                                    if(!ge.b_rcurve)
                                       ty = mathLerpf(pTail.y, pHead.y, 0.98f);
                                    else
                                       ty = pHead.y;
                                    ge.curve_c1x = pHead.x;
                                    ge.curve_c1y = ty;//pHead.y;
                                    ge.curve_c2x = pHead.x;
                                    ge.curve_c2y = ty;//pHead.y;
                                    getNodePosition(nHeadOther, pTmp, headDistX, headDistY);
                                    // lTmp <= nHeadOther.ui_layer;
                                    lTmp <= nHeadOther.getUIPortsLayer();
                                    dirFlagsViaHead = lTmp.calcDirFlagsRelativeTo(lHead, pTmp, pHead);  // position of helper relative to head
                                    if(b_gf_debug2) trace "[trc]          dirFlagsViaHead="+dirFlagsViaHead;
                                    pHead = pTmp;
                                    lHead <= lTmp;
                                    dirFlags = lTail.calcDirFlagsRelativeTo(lHead, pTail, pHead);
                                    if(b_gf_debug2) trace "[trc]          pTail="+pTail.getString()+" pHead="+pHead.getString()+" => new dirFlags="+dirFlags;
                                    nHead.b_helper_done = true;
                                    if(b_gf_debug2) trace "[trc] set nHead"+nHead.getString()+".b_helper_done";
                                    nHead <= nHeadOther;
                                    headSz.x = lHead.size_x;
                                    headSz.y = lHead.size_y;
                                    bHelperDone = true;
                                 }
                                 else
                                 {
                                    if(b_gf_debug2) trace "[trc] <head> chained helper e="+e.getString()+" nHeadOther"+nHeadOther.getString()+" is helper";
                                    // move nHead half-way towards nHeadOther and store head position override (for next edge)

                                    eTmp <= graph.findUniqueEdgeTo(nHeadOther, nHead/*notN*/);
                                    if(b_gf_debug2) trace "[trc]     findUniqueEdgeTo(nHeadOther"+nHeadOther.getString()+" nHead"+nHead.getString()+") => eTmp="+Graph.GetEdgeString(eTmp);
                                    if(null != eTmp)
                                    {
                                       nTmp <= eTmp.getOtherNode(nHeadOther);
                                       // trace "xxx      nTmp"+nTmp.getString();
                                       // curve chain is nTail(regular)->nHead(helper1)->nHeadOther(helper2)->nTmp(regular)
                                       if(b_gf_debug2) trace "[trc]      curve-chain: 1) "+nTail.getString();
                                       if(b_gf_debug2) trace "[trc]      curve-chain: 2) "+nHead.getString();
                                       if(b_gf_debug2) trace "[trc]      curve-chain: 3) "+nHeadOther.getString();
                                       if(b_gf_debug2) trace "[trc]      curve-chain: 4) "+nTmp.getString();
                                       //  (todo) support longer chains
                                       nTail     .next_helper_node <= nHead;
                                       nHead     .next_helper_node <= nHeadOther;      // save for pass3
                                       nHeadOther.next_helper_node <= nTmp;
                                       nTmp      .next_helper_node <= null;

                                       nHead     .b_helper_done = true;

                                       // move nHead(helper) towards tail
                                       CenterPoint(pHead, headSz); // already done?
                                       if(b_gf_debug2) trace "[trc]   ~~~~~~~~~~~~~ pHead="+pHead.getString()+" headSz="+headSz.getString();
                                       nHead.setPositionOverride(pHead.x, pHead.y);

                                       // move nHeadOther(helper2) towards nHead(helper1)
                                       // lTmp <= nHeadOther.ui_layer;
                                       lTmp <= nHeadOther.getUIPortsLayer();
                                       getNodePosition(nHeadOther, pTmp, headDistX, headDistY);
                                       pTmp.x = pTmp.x + lTmp.size_x*0.5;
                                       pTmp.y = pTmp.y + lTmp.size_y*0.5;
                                       if(!ge.b_rcurve)
                                       {
                                          pTmp.x = mathLerpf(pTmp.x, pHead.x, 0.33f);
                                          pTmp.y = mathLerpf(pTmp.y, pHead.y, 0.33f);
                                       }
                                       nHeadOther.setPositionOverride(pTmp.x, pTmp.y);

                                       bHelperDone = true;
                                    }

                                 }
                              } // if null != eHead
                           } // if !nTail.b_helper
                        } // if null == nHead.next_helper_node
                     } // if !nHead.b_helper_done
                     else
                     {
                        bSkipEdge = true;
                     }
                  } // if nHead.b_helper
               } // if !bHelperDone

               if(!bSkipEdge)
               {
                  ge.init(e, nTail, nHead);
                  graph_edges.add(#(deref ge));

                  if(b_gf_debug2)
                     trace "[trc] add GraphEdge dirFlags="+dirFlags+"  nTail"+nTail.getString()+" nHead"+nHead.getString();

                  // trace "xxx e="+e.getString()+" forcedDirTail="+forcedDirTail+" forcedDirHead="+forcedDirHead;

                  boolean bAllowTailSnapY = false;  // LEFT/RIGHT
                  boolean bAllowHeadSnapY = false;  // LEFT/RIGHT

                  boolean bAllowTailSnapX = false;  // TOP/BOTTOM
                  boolean bAllowHeadSnapX = false;  // TOP/BOTTOM

                  // trace "xxx nTail.id="+nTail.id+" forcedDirTail="+forcedDirTail+" tailPort="+#(tailPort);

                  float tailPortMaxW = nTail.getPortLayerMaxW();
                  float tailPortMaxH = nTail.getPortLayerMaxH();

                  float headPortMaxW = nHead.getPortLayerMaxW();
                  float headPortMaxH = nHead.getPortLayerMaxH();

                  float tailPortW = (null != tailPort) ? tailPort.getPanelLayerSx() : nTail.getPortW();
                  float tailPortH = (null != tailPort) ? tailPort.getPanelLayerSy() : nTail.getPortH();

                  float headPortW = (null != headPort) ? headPort.getPanelLayerSx() : nHead.getPortW();
                  float headPortH = (null != headPort) ? headPort.getPanelLayerSy() : nHead.getPortH();

                  float tailRelPos = (null != tailPort) ? tailPort.relpos : 0.5f;
                  float headRelPos = (null != headPort) ? headPort.relpos : 0.5f;

                  float portX;
                  float portY;

                  if(0 != forcedDirTail)
                  {
                     e.ui_tail_dir = forcedDirTail;
                     switch(forcedDirTail)
                     {
                        case Layout.TOP:
                           // connect from top side of tail
                           portX = tailPortMaxW + (tailSz.x - tailPortMaxW*2) * tailRelPos;
                           portY = 0 + (tailPortMaxH - tailPortH);
                           ge.abs_x_tail = pTail.x + portX;
                           ge.abs_y_tail = pTail.y + portY;
                           ge.b_curve_bend_h_tail = false;
                           bViaDoneTail = true;
                           bAllowTailSnapX = true;
                           break;

                        case Layout.LEFT:
                           // connect from left side of tail
                           ge.abs_x_tail = pTail.x + (tailPortMaxW - tailPortW);
                           ge.abs_y_tail = pTail.y + tailPortMaxH + (tailSz.y - tailPortMaxH*2) * tailRelPos;
                           ge.b_curve_bend_h_tail = true;
                           bViaDoneTail = true;
                           bAllowTailSnapY = true;
                           break;

                        case Layout.BOTTOM:
                           // connect from bottom side of tail
                           ge.abs_x_tail = pTail.x + tailPortMaxW + (tailSz.x - tailPortMaxW*2) * tailRelPos;
                           ge.abs_y_tail = pTail.y + tailSz.y + tailPadB - (tailPortMaxH - tailPortH);
                           ge.b_curve_bend_h_tail = false;
                           bViaDoneTail = true;
                           bAllowTailSnapX = true;
                           break;

                        case Layout.RIGHT:
                           // connect from right side of tail
                           ge.abs_x_tail = pTail.x + tailSz.x + tailPadR - (tailPortMaxW - tailPortW);
                           ge.abs_y_tail = pTail.y + tailPortMaxH + (tailSz.y - tailPortMaxH*2) * tailRelPos;
                           ge.b_curve_bend_h_tail = true;
                           bViaDoneTail = true;
                           bAllowTailSnapY = true;
                           break;
                     }
                  }

                  if(0 != forcedDirHead)
                  {
                     e.ui_head_dir = forcedDirHead;
                     dirFlags = Layout.SwapDirFlags(forcedDirHead);
                     switch(forcedDirHead)
                     {
                        case Layout.TOP:
                           // connect to top side of head
                           if(null != headPort)
                           {
                              ge.abs_x_head = pHead.x + headPortMaxW + (headSz.x - headPortMaxW*2 + headPadR) * headRelPos;
                              ge.abs_y_head = pHead.y + (headPortMaxH - headPortH);
                           }
                           else
                           {
                              calcHeadPoint(pDst,
                                            pHead.x,                       pHead.y,
                                            pHead.x + headSz.x + headPadR, pHead.y,
                                            nHead.cur_edge_idx_t++,
                                            nHead.num_edges_t,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                           }
                           bViaDoneHead = true;
                           bAllowHeadSnapX = true;
                           break;

                        case Layout.LEFT:
                           // connect to left side of head
                           if(null != headPort)
                           {
                              ge.abs_x_head = pHead.x + (headPortMaxW - headPortW);
                              ge.abs_y_head = pHead.y + headPortMaxH + (headSz.y - headPortMaxH*2 + headPadB) * headRelPos;
                           }
                           else
                           {
                              calcHeadPoint(pDst,
                                            pHead.x, pHead.y,
                                            pHead.x, pHead.y + headSz.y + headPadB,
                                            nHead.cur_edge_idx_l++,
                                            nHead.num_edges_l,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                           }
                           ge.b_curve_bend_h_head = true;
                           bViaDoneHead = true;
                           bAllowHeadSnapY = true;
                           break;

                        case Layout.BOTTOM:
                           // connect to bottom side of head
                           if(null != headPort)
                           {
                              ge.abs_x_head = pHead.x + headPortMaxW + (headSz.x - headPortMaxW*2 + headPadR) * headRelPos;
                              ge.abs_y_head = pHead.y + headSz.y + headPadB - (headPortMaxH - headPortH);
                           }
                           else
                           {
                              calcHeadPoint(pDst,
                                            pHead.x,                       pHead.y + headSz.y + headPadB,
                                            pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                            nHead.cur_edge_idx_b++,
                                            nHead.num_edges_b,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                           }
                           bViaDoneHead = true;
                           bAllowHeadSnapX = true;
                           break;

                        case Layout.RIGHT:
                           // connect to right side of head
                           if(null != headPort)
                           {
                              ge.abs_x_head = pHead.x + headSz.x + headPadR - (headPortMaxW - headPortW);
                              ge.abs_y_head = pHead.y + headPortMaxH + (headSz.y - headPortMaxH*2 + headPadB) * headRelPos;
                           }
                           else
                           {
                              calcHeadPoint(pDst,
                                            pHead.x + headSz.x + headPadR, pHead.y,
                                            pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                            nHead.cur_edge_idx_r++,
                                            nHead.num_edges_r,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                           }
                           ge.b_curve_bend_h_head = true;
                           bViaDoneHead = true;
                           bAllowHeadSnapY = true;
                           break;
                     }
                  }

                  if(!(bViaDoneTail && bViaDoneHead))
                  {
                     // trace "xxx nTail.id="+nTail.id+" nHead.id="+nHead.id+" dirFlags="+dirFlags;
                     if(dirFlags & Layout.RIGHT)
                     {
                        if(dirFlags & Layout.BOTTOM)
                        {
                           if(bVia)
                           {
                              if(!bViaDoneTail)
                              {
                                 if(dirFlagsViaTail & Layout.RIGHT)
                                 {
                                    // helper node is below tail
                                    if(b_gf_debug2) trace "[trc]     helper node is on the right side of tail";
                                    ge.abs_x_tail = pTail.x + tailSz.x + tailPadR;
                                    ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                                    ge.b_curve_bend_h_tail = true;
                                    bViaDoneTail = true;
                                    bAllowTailSnapY = true;
                                    e.ui_tail_dir = Layout.RIGHT;
                                 }
                                 else if(dirFlagsViaTail & Layout.LEFT)
                                 {
                                    // helper node is on the left side of tail
                                    if(b_gf_debug2) trace "[trc]     helper node is on the left side of tail";
                                    ge.abs_x_tail = pTail.x;
                                    ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                                    ge.b_curve_bend_h_tail = true;
                                    bViaDoneTail = true;
                                    bAllowTailSnapY = true;
                                    e.ui_tail_dir = Layout.LEFT;
                                 }
                                 else if(dirFlagsViaTail & Layout.BOTTOM)
                                 {
                                    // helper node is below tail
                                    if(b_gf_debug2) trace "[trc]     helper node is below tail   nTail"+nTail.getString()+" nHead"+nHead.getString();
                                    ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                                    ge.abs_y_tail = pTail.y + tailSz.y + tailPadB;
                                    bViaDoneTail = true;
                                    bAllowTailSnapX = true;
                                    e.ui_tail_dir = Layout.BOTTOM;
                                 }
                              }

                              if(!bViaDoneHead)
                              {
                                 if(dirFlagsViaHead & Layout.TOP)
                                 {
                                    // helper node is on top of head
                                    if(b_gf_debug2) trace "[trc]     helper node is on top of head";
                                    calcHeadPoint(pDst,
                                                  pHead.x,                       pHead.y,
                                                  pHead.x + headSz.x + headPadR, pHead.y,
                                                  nHead.cur_edge_idx_t++,
                                                  nHead.num_edges_t,
                                                  nHead.gr_attribs
                                                  );
                                    ge.abs_x_head = pDst.x;
                                    ge.abs_y_head = pDst.y;
                                    bViaDoneHead = true;
                                    bAllowHeadSnapX = true;
                                    e.ui_head_dir = Layout.TOP;
                                 }
                                 else if(dirFlagsViaHead & Layout.LEFT)
                                 {
                                    // helper node is on the left side of head
                                    if(b_gf_debug2) trace "[trc]     helper node is on the left side of head";
                                    calcHeadPoint(pDst,
                                                  pHead.x, pHead.y,
                                                  pHead.x, pHead.y + headSz.y + headPadB,
                                                  nHead.cur_edge_idx_l++,
                                                  nHead.num_edges_l,
                                                  nHead.gr_attribs
                                                  );
                                    ge.b_curve_bend_h_head = true;
                                    ge.abs_x_head = pDst.x;
                                    ge.abs_y_head = pDst.y;
                                    bViaDoneHead = true;
                                    bAllowHeadSnapY = true;
                                    e.ui_head_dir = Layout.LEFT;
                                 }
                              }
                           }

                           // head is on the bottom/right side of tail
                           if(!bViaDoneTail)
                           {
                              if(bXMajorTail)
                              {
                                 // connect from right side of tail
                                 ge.abs_x_tail = pTail.x + tailSz.x + tailPadR;
                                 ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                                 ge.b_curve_bend_h_tail = true;
                                 bAllowTailSnapY = true;
                                 e.ui_tail_dir = Layout.RIGHT;
                              }
                              else
                              {
                                 // connect from bottom side of tail
                                 ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                                 ge.abs_y_tail = pTail.y + tailSz.y + tailPadB;
                                 bAllowTailSnapX = true;
                                 e.ui_tail_dir = Layout.BOTTOM;
                              }
                              bViaDoneTail = true;
                           }

                           if(!bViaDoneHead)
                           {
                              if(bXMajorHead)
                              {
                                 // connect to left side of head
                                 calcHeadPoint(pDst,
                                               pHead.x, pHead.y,
                                               pHead.x, pHead.y + headSz.y + headPadB,
                                               nHead.cur_edge_idx_l++,
                                               nHead.num_edges_l,
                                               nHead.gr_attribs
                                               );
                                 ge.b_curve_bend_h_head = true;
                                 ge.abs_x_head = pDst.x;
                                 ge.abs_y_head = pDst.y;
                                 bAllowHeadSnapY = true;
                                 e.ui_head_dir = Layout.LEFT;
                              }
                              else
                              {
                                 // connect to top side of head
                                 calcHeadPoint(pDst,
                                               pHead.x,                       pHead.y,
                                               pHead.x + headSz.x + headPadR, pHead.y,
                                               nHead.cur_edge_idx_t++,
                                               nHead.num_edges_t,
                                               nHead.gr_attribs
                                               );
                                 ge.abs_x_head = pDst.x;
                                 ge.abs_y_head = pDst.y;
                                 bAllowTailSnapX = true;
                                 e.ui_head_dir = Layout.TOP;
                              }
                              bViaDoneHead = true;
                           }
                        }
                        else if(dirFlags & Layout.TOP)
                        {
                           if(bVia)
                           {
                              if(!bViaDoneTail)
                              {
                                 if(dirFlagsViaTail & Layout.RIGHT)
                                 {
                                    // helper node is below tail
                                    if(b_gf_debug2) trace "[trc]     helper node is on the right side of tail";
                                    ge.abs_x_tail = pTail.x + tailSz.x + tailPadR;
                                    ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                                    ge.b_curve_bend_h_tail = true;
                                    bViaDoneTail = true;
                                    bAllowTailSnapY = true;
                                    e.ui_tail_dir = Layout.RIGHT;
                                 }
                              }

                              if(!bViaDoneHead)
                              {
                                 if(dirFlagsViaHead & Layout.BOTTOM)
                                 {
                                    // helper node is below head. connect to bottom side of head
                                    if(b_gf_debug2) trace "[trc]     helper node is below head";
                                    calcHeadPoint(pDst,
                                                  pHead.x,                       pHead.y + headSz.y + headPadB,
                                                  pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                                  nHead.cur_edge_idx_b++,  // (todo) correctly calc num_edges (should align with pass 1!!)
                                                  nHead.num_edges_b,
                                                  nHead.gr_attribs
                                                  );
                                    ge.abs_x_head = pDst.x;
                                    ge.abs_y_head = pDst.y;
                                    ge.b_curve_bend_h_head = true;
                                    bViaDoneHead = true;
                                    bAllowHeadSnapX = true;
                                    e.ui_head_dir = Layout.BOTTOM;
                                 }
                              }
                           }

                           if(!bViaDoneTail)
                           {
                              // head is on the top/right side of tail
                              if(bXMajorTail)
                              {
                                 // connect from right side of tail
                                 ge.abs_x_tail = pTail.x + tailSz.x + tailPadR;
                                 ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                                 ge.b_curve_bend_h_tail = true;
                                 bAllowTailSnapY = true;
                                 e.ui_tail_dir = Layout.RIGHT;
                              }
                              else
                              {
                                 // connect from top side of tail
                                 ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                                 ge.abs_y_tail = pTail.y;
                                 bAllowTailSnapX = true;
                                 e.ui_tail_dir = Layout.TOP;
                              }
                           }

                           if(!bViaDoneHead)
                           {
                              if(bXMajorHead)
                              {
                                 // connect to left side of head
                                 calcHeadPoint(pDst,                                     // [23Mar2024] test32f.gr
                                               pHead.x, pHead.y,
                                               pHead.x, pHead.y + headSz.y + headPadB,
                                               nHead.cur_edge_idx_l++,
                                               nHead.num_edges_l,
                                               nHead.gr_attribs
                                               );
                                 ge.abs_x_head = pDst.x;
                                 ge.abs_y_head = pDst.y;
                                 ge.b_curve_bend_h_head = true;
                                 bAllowHeadSnapY = true;
                                 e.ui_head_dir = Layout.LEFT;
                              }
                              else
                              {
                                 // connect to bottom side of head
                                 calcHeadPoint(pDst,                                     // [14Mar2024] test29.gr
                                               pHead.x,                       pHead.y + headSz.y + headPadB,
                                               pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                               nHead.cur_edge_idx_b++,
                                               nHead.num_edges_b,
                                               nHead.gr_attribs
                                               );
                                 ge.abs_x_head = pDst.x;
                                 ge.abs_y_head = pDst.y;
                                 bAllowHeadSnapX = true;
                                 e.ui_head_dir = Layout.BOTTOM;
                              }
                           }
                        }
                        else
                        {
                           // head is on the right side of tail
                           // trace "xxx head is on the right side of tail";

                           if(!bViaDoneTail)
                           {
                              // connect from right side of tail
                              ge.abs_x_tail = pTail.x + tailSz.x + tailPadR;
                              ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                              ge.b_curve_bend_h_tail = true;
                              bAllowTailSnapY = true;
                              e.ui_tail_dir = Layout.RIGHT;
                           }

                           if(!bViaDoneHead)
                           {
                              // connect to left side of head
                              calcHeadPoint(pDst,
                                            pHead.x, pHead.y,
                                            pHead.x, pHead.y + headSz.y + headPadB,
                                            nHead.cur_edge_idx_l++,
                                            nHead.num_edges_l,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                              ge.b_curve_bend_h_head = true;
                              bAllowHeadSnapY = true;
                              e.ui_head_dir = Layout.LEFT;
                           }
                        }
                     }
                     else if(dirFlags & Layout.LEFT)
                     {
                        if(dirFlags & Layout.BOTTOM)
                        {
                           // head is on the bottom/left side of tail
                           // trace "xxx    head is on the bottom/left side of tail  nHead"+nHead.getString()+" nTail"+nTail.getString();
                           if(bVia)
                           {
                              if(!bViaDoneTail)
                              {
                                 if(dirFlagsViaTail & Layout.BOTTOM)
                                 {
                                    // helper node is below tail
                                    if(b_gf_debug2) trace "[trc]     helper node is below tail";
                                    ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                                    ge.abs_y_tail = pTail.y + tailSz.y + tailPadB;
                                    bViaDoneTail = true;
                                    bAllowTailSnapX = true;
                                    e.ui_tail_dir = Layout.BOTTOM;
                                 }
                                 else if(dirFlagsViaTail & Layout.LEFT)
                                 {
                                    // helper node is on the left side of tail
                                    if(b_gf_debug2) trace "[trc]     helper node is on the left side of tail";
                                    ge.abs_x_tail = pTail.x;
                                    ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                                    ge.b_curve_bend_h_tail = true;
                                    bViaDoneTail = true;
                                    bAllowTailSnapY = true;
                                    e.ui_tail_dir = Layout.LEFT;
                                 }
                              }

                              if(!bViaDoneHead)
                              {
                                 if(dirFlagsViaHead & Layout.RIGHT)
                                 {
                                    // helper node is on the right side of head
                                    if(b_gf_debug2) trace "[trc]     helper node is on the right side of head";
                                    calcHeadPoint(pDst,
                                                  pHead.x + headSz.x + headPadR, pHead.y,
                                                  pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                                  nHead.cur_edge_idx_r++,
                                                  nHead.num_edges_r,
                                                  nHead.gr_attribs
                                                  );
                                    ge.abs_x_head = pDst.x;
                                    ge.abs_y_head = pDst.y;
                                    ge.b_curve_bend_h_head = true;
                                    bViaDoneHead = true;
                                    bAllowHeadSnapY = true;
                                    e.ui_head_dir = Layout.RIGHT;
                                 }
                              }
                           }

                           if(!bViaDoneTail)
                           {
                              if(0 && bXMajorTail)
                              {
                                 // connect from left side of tail
                                 ge.abs_x_tail = pTail.x;
                                 ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                                 ge.b_curve_bend_h_tail = true;
                                 bAllowTailSnapY = true;
                                 e.ui_tail_dir = Layout.LEFT;
                              }
                              else
                              {
                                 // connect from bottom side of tail
                                 ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                                 ge.abs_y_tail = pTail.y + tailSz.y + tailPadB;
                                 bAllowTailSnapX = true;
                                 e.ui_tail_dir = Layout.BOTTOM;
                              }
                           }

                           if(!bViaDoneHead)
                           {
                              if(0 && bXMajorHead)
                              {
                                 // connect to right side of head
                                 calcHeadPoint(pDst,
                                               pHead.x + headSz.x + headPadR, pHead.y,
                                               pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                               nHead.cur_edge_idx_r++,
                                               nHead.num_edges_r,
                                               nHead.gr_attribs
                                               );
                                 ge.b_curve_bend_h_head = true;
                                 bAllowHeadSnapY = true;
                                 e.ui_head_dir = Layout.RIGHT;
                              }
                              else
                              {
                                 // connect to top side of head
                                 calcHeadPoint(pDst,
                                               pHead.x,                       pHead.y,
                                               pHead.x + headSz.x + headPadR, pHead.y,
                                               nHead.cur_edge_idx_t++,
                                               nHead.num_edges_t,
                                               nHead.gr_attribs
                                               );
                                 bAllowHeadSnapX = true;
                                 e.ui_head_dir = Layout.TOP;
                              }
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                           }
                        }
                        else if(dirFlags & Layout.TOP)
                        {
                           // head is on the top/left side of tail

                           if(!bViaDoneTail)
                           {
                              // connect from top side of tail
                              ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                              ge.abs_y_tail = pTail.y;
                              bAllowTailSnapX = true;
                              e.ui_tail_dir = Layout.TOP;
                           }

                           if(!bViaDoneHead)
                           {
                              // connect to bottom side of head
                              calcHeadPoint(pDst,
                                            pHead.x,                       pHead.y + headSz.y + headPadB,
                                            pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                            nHead.cur_edge_idx_b++,
                                            nHead.num_edges_b,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                              bAllowHeadSnapX = true;
                              e.ui_head_dir = Layout.BOTTOM;
                           }
                        }
                        else
                        {
                           // head is on the left side of tail
                           if(b_gf_debug2) trace "[trc] head is on the left side of tail";

                           if(!bViaDoneTail)
                           {
                              // connect from left side of tail
                              ge.abs_x_tail = pTail.x;
                              ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                              ge.b_curve_bend_h_tail = true;
                              bAllowTailSnapY = true;
                              e.ui_tail_dir = Layout.LEFT;
                           }

                           if(!bViaDoneHead)
                           {
                              // connect to right side of head
                              calcHeadPoint(pDst,
                                            pHead.x + headSz.x + headPadR, pHead.y,
                                            pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                            nHead.cur_edge_idx_r++,
                                            nHead.num_edges_r,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                              ge.b_curve_bend_h_head = true;
                              bAllowHeadSnapY = true;
                              e.ui_head_dir = Layout.RIGHT;
                           }
                        }
                     }
                     else
                     {
                        if(dirFlags & Layout.BOTTOM)
                        {
                           // head is on the bottom side of tail
                           if(b_gf_debug2) trace "[trc]   head is on the bottom side of tail  nTail"+nTail.getString()+" nHead"+nHead.getString();
                           if(b_gf_debug2) trace "[trc]       pTail="+pTail.getString()+" tailSz="+tailSz.getString();
                           if(b_gf_debug2) trace "[trc]       pHead="+pHead.getString()+" headSz="+headSz.getString();

                           if(!bViaDoneTail)
                           {
                              // connect from bottom side of tail
                              ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                              ge.abs_y_tail = pTail.y + tailSz.y + tailPadB;
                              bAllowTailSnapX = true;
                              e.ui_tail_dir = Layout.BOTTOM;
                           }

                           if(!bViaDoneHead)
                           {
                              if(0 && bXMajorHead)  // test38.gr
                              {
                                 // connect to right side of head
                                 calcHeadPoint(pDst,
                                               pHead.x + headSz.x + headPadR, pHead.y,
                                               pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                               nHead.cur_edge_idx_r++,
                                               nHead.num_edges_r,
                                               nHead.gr_attribs
                                               );
                                 ge.b_curve_bend_h_head = true;
                                 bAllowHeadSnapY = true;
                                 e.ui_head_dir = Layout.RIGHT;
                              }
                              else
                              {
                                 // connect to top side of head
                                 calcHeadPoint(pDst,
                                               pHead.x,                       pHead.y,
                                               pHead.x + headSz.x + headPadR, pHead.y,
                                               nHead.cur_edge_idx_t++,
                                               nHead.num_edges_t,
                                               nHead.gr_attribs
                                               );
                                 bAllowHeadSnapX = true;
                                 e.ui_head_dir = Layout.TOP;
                              }
                              if(b_gf_debug2) trace "[trc]       => pDst(head)="+pDst.getString();
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                           }
                        }
                        else if(dirFlags & Layout.TOP)
                        {
                           // head is on the top side of tail
                           // trace "xxx head is on the top side of tail  nTail"+nTail.getString()+" nHead"+nHead.getString();

                           if(!bViaDoneTail)
                           {
                              // connect from top side of tail
                              ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                              ge.abs_y_tail = pTail.y;
                              bAllowTailSnapX = true;
                              e.ui_tail_dir = Layout.TOP;
                           }

                           if(!bViaDoneHead)
                           {
                              // connect to bottom side of head
                              calcHeadPoint(pDst,
                                            pHead.x,                       pHead.y + headSz.y + headPadB,
                                            pHead.x + headSz.x + headPadR, pHead.y + headSz.y + headPadB,
                                            nHead.cur_edge_idx_b++,
                                            nHead.num_edges_b,
                                            nHead.gr_attribs
                                            );
                              ge.abs_x_head = pDst.x;
                              ge.abs_y_head = pDst.y;
                              bAllowHeadSnapX = true;
                              e.ui_head_dir = Layout.BOTTOM;
                           }
                        }
                        else
                        {
                           // head overlaps? with tail (?!)
                           if(!bViaDoneTail)
                           {
                              ge.abs_x_tail = pTail.x + (tailSz.x + tailPadR) * 0.5f;
                              ge.abs_y_tail = pTail.y + (tailSz.y + tailPadB) * 0.5f;
                           }

                           if(!bViaDoneHead)
                           {
                              ge.abs_x_head = pHead.x + (headSz.x + headPadR) * 0.5f;
                              ge.abs_y_head = pHead.y + (headSz.y + headPadB) * 0.5f;
                           }
                        }
                     }
                  } // if !(bViaDoneTail && bViaDoneHead)

                  if(bAllowTailSnapX && bAllowHeadSnapX)
                  {
                     float tailSnapXTh = GetGRAttribFloat(e.gr_attribs, "tail_snap_x", 8.0f) * UI.font_scaling;
                     ge.trySnapTailPosX(tailSnapXTh, pTail.x, tailSz.x);
                  }

                  if(bAllowTailSnapY && bAllowHeadSnapY)
                  {
                     float tailSnapYTh = GetGRAttribFloat(e.gr_attribs, "tail_snap_y", 5.0f) * UI.font_scaling;
                     ge.trySnapTailPosY(tailSnapYTh, pTail.y, tailSz.y);
                  }

               } // if !bSkipEdge
            } // if ui_layers
         }
      } // iterate edges

      // Pass 3: consolidate helper node chains and update bezier curve control points
      boolean bConsolidated;
      do
      {
         bConsolidated = false;
         Node *n;
         foreach n in graph.nodes
         {
            if(null != n.next_helper_node)
            {
               // 'n' starts 4-node curve chain  (todo) support longer chains
               Node n1 <= n;
               Node n2 <= n1.next_helper_node;
               Node n3 <= n2.next_helper_node;
               Node n4 <= n3.next_helper_node;
               if(b_gf_debug2)
               {
                  trace "[trc] consolidate: curve-chain:";
                  trace "[trc]                n1"+n1.getString();
                  trace "[trc]                n2"+n2.getString();
                  trace "[trc]                n3"+n3.getString();
                  trace "[trc]                n4"+n4.getString();
               }

               Point2f p1; getNodePosition(n1, p1, tailDistX, tailDistY);  // tail
               Point2f p2; getNodePosition(n2, p2, headDistX, headDistY);  // helper1
               Point2f p3; getNodePosition(n3, p3, headDistX, headDistY);  // helper2
               Point2f p4; getNodePosition(n4, p4, tailDistX, tailDistY);  // head

               // (note) ge12 already exists
               if(b_gf_debug2) trace "[trc] findGraphEdge(n1"+n1.getString()+" n2"+n2.getString()+")";
               GraphEdge ge12 <= findGraphEdge(n1, n2);
               // trace "xxx ge12="+#(ge12);

               // create ge23
               e <= graph.findEdge(n2, n3);
               // trace "xxx e="+#(e);
               GraphEdge ge23 <= new GraphEdge;
               ge23.init(e, n2, n3);
               ge23.copyAttribsFrom(ge12);
               graph_edges.add(#(deref ge23));
               // trace "xxx ge23="+#(ge23);

               // (note) ge34 already exists
               if(b_gf_debug2) trace "[trc] findGraphEdge(n3"+n3.getString()+" n4"+n4.getString()+")";
               GraphEdge ge34 <= findGraphEdge(n3, n4);
               // trace "xxx ge34="+#(ge34);

               p1.x = ge12.abs_x_tail;  // tail connection "port"
               p1.y = ge12.abs_y_tail;

               p4.x = ge34.abs_x_head;
               p4.y = ge34.abs_y_head;

               if(b_gf_debug2)
               {
                  trace "[trc]     p1="+p1.getString();
                  trace "[trc]     p2="+p2.getString();
                  trace "[trc]     p3="+p3.getString();
                  trace "[trc]     p4="+p4.getString();
               }

               // // e <= ge12.edge;
               ge12.b_curve_c = true;
               ge12.curve_c1x = p2.x;
               ge12.curve_c1y = p2.y;
               ge12.curve_c2x = p1.x;
               ge12.curve_c2y = p1.y;
               ge12.abs_x_head = p2.x;
               ge12.abs_y_head = p2.y;
               // move head towards tail
               if(!ge12.b_rcurve)
               {
                  ge12.abs_x_head = mathLerpf(p1.x, ge12.abs_x_head, 0.33f);
                  ge12.abs_y_head = mathLerpf(p1.y, ge12.abs_y_head, 0.33f);
               }

               ge23.abs_x_tail = ge12.abs_x_head; // p2.x
               ge23.abs_y_tail = ge12.abs_y_head; // p2.y
               ge23.abs_x_head = p3.x;
               ge23.abs_y_head = p3.y;
               // move head towards tail
               if(!ge23.b_rcurve)
               {
                  ge23.abs_x_head = mathLerpf(ge23.abs_x_head, ge23.abs_x_tail, 0.33f);
                  ge23.abs_y_head = mathLerpf(ge23.abs_y_head, ge23.abs_y_tail, 0.33f);
               }

               ge23.b_curve_c = true;
               ge23.curve_c1x = ge12.abs_x_head;  // p2.x
               ge23.curve_c1y = ge23.abs_y_head;  // p3.y
               ge23.curve_c2x = ge12.abs_x_head;  // p2.x
               ge23.curve_c2y = ge23.abs_y_head;  // p3.y

               ge34.abs_x_tail = ge23.abs_x_head; // p3.x
               ge34.abs_y_tail = ge23.abs_y_head; // p3.y
               ge34.abs_x_head = p4.x;
               ge34.abs_y_head = p4.y;

               ge34.b_curve_c = true;
               ge34.curve_c1x = p4.x;
               ge34.curve_c1y = ge23.abs_y_head;//p3.y;
               ge34.curve_c2x = p4.x;
               ge34.curve_c2y = ge23.abs_y_head;//p3.y;

               // ge12.fgcolor = #ffff0000;
               // ge34.fgcolor = #ffff0000;

               n1.next_helper_node <= null;
               n2.next_helper_node <= null;
               n3.next_helper_node <= null;
               n4.next_helper_node <= null;
            }
         }
      }
      while(bConsolidated);

      // Pass 4: tesselate bezier curves
      foreach ge in graph_edges
      {
         ge.tesselateCurve();
         ge.calcArrowVertices();
         ge.tesselateCurve();
      }
   }

   protected method addEdgeLabelsFromGraph(Graph _graph) {
      // trace "[trc] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ addEdgeLabelsFromGraph: graph.id='"+_graph.id+"'";
      GraphForm graphForm <= _graph.graph_form;
      // trace "xxx addEdgeLabelsFromGraph: graphFrom="+#(graphForm);
      if(null != graphForm)  // null when subgraph uses TABLE layout
      {
         GraphEdge *ge;
         foreach ge in graphForm.graph_edges
         {
            Edge e <= ge.edge;
            if(e.isPlaced() && e.isVisible())
            {
               // trace "xxx addEdgeLabelsFromGraph: e="+e.getString();
               HashTable ht <= e.gr_attribs;
               String sLabel <= e.label;
               if(sLabel.isBlank())
                  sLabel <= ht["label"];
               if(null != sLabel && !sLabel.isBlank() && ("none" != GetGRAttrib(ht, "label_style", "default")))
               {
                  float relPos = 0.5f;
                  if(ht.exists("label_relpos"))
                     relPos = GRUtils.GetAttribAmount(ht, "label_relpos");
                  float labelCtrX = mathLerpf(ge.abs_x_tail, ge.abs_x_head, relPos);
                  float labelCtrY = mathLerpf(ge.abs_y_tail, ge.abs_y_head, relPos);

                  // trace "xxx sLabel=\""+sLabel+"\"";
                  Layer l <= createButtonForNodeOrLabel(null/*nOrNull*/, sLabel, ht/*gr_attribs*/);
                  // trace "xxx create label font="+ht.get("font");
                  float minSx = l.getMinimumSizeX();
                  float minSy = l.getMinimumSizeY();
                  l.setRequiredSize2f(minSx, minSy);
                  if(l instanceof Panel)
                  {
                     // // // copyBackgroundFromGRAttribsToPanel(ht, l);
                     l.relayout();
                  }
                  // trace "xxx addEdgeLabelsFromGraph: graph.id='"+_graph.id+"' edge="+e.getString()+" label=\""+sLabel+"\" labelCtr=("+labelCtrX+";"+labelCtrY+") minSz=("+minSx+";"+minSy+")";

                  int placement = Layout.CENTER;
                  // if(e.haveEdgeAttrib("label_pos"))
                  // {
                  //    local StringArray atsplit <= e.getEdgeAttrib("label_pos").toLower().splitChar(';');
                  //    placement = Layer.ParseAlignmentFlagsFromArray(atsplit);
                  //    if(0 != placement)
                  //    {
                  //       // int dirFlags = e.ui_dir_flags;
                  //       // if(dirFlags == Layout.LEFT || dirFlags == Layout.RIGHT)
                  //       // {
                  //       //    // horizontal edge
                  //       // }
                  //       // else if(dirFlags == Layout.TOP || dirFlags == Layout.BOTTOM)
                  //       // {
                  //       //    // vertical edge
                  //       // }
                  //    }
                  // }

                  setLayerPaddingFromGRAttribs(l, ht/*gr_attribs*/);
                  setLayerAlignmentFromGRAttribs(l, ht/*gr_attribs*/);

                  if(0 != l.alignment)
                     placement = l.alignment;

                  // trace "xxx edge label \""+sLabel+"\" padding="+l.getPaddingString();

                  switch(placement)
                  {
                     case Layout.CENTER:
                     case Layout.CENTERX:
                     case Layout.CENTERY:
                     default:
                        l.setPosition2f(labelCtrX - minSx*0.5 + l.pad_left - l.pad_right,
                                        labelCtrY - minSy*0.5 + l.pad_top - l.pad_bottom
                                        );
                        break;

                     case Layout.LEFT:
                        l.setPosition2f(labelCtrX - minSx - l.pad_right,
                                        labelCtrY - minSy*0.5 + l.pad_top - l.pad_bottom
                                        );
                        break;

                     case Layout.RIGHT:
                        l.setPosition2f(labelCtrX + l.pad_left - l.pad_right,
                                        labelCtrY - minSy*0.5 + l.pad_top - l.pad_bottom
                                        );
                        break;

                     case Layout.TOP:
                        l.setPosition2f(labelCtrX - minSx*0.5 + l.pad_left - l.pad_right,
                                        labelCtrY - minSy + l.pad_top - l.pad_bottom
                                        );
                        break;

                     case Layout.BOTTOM:
                        l.setPosition2f(labelCtrX - minSx*0.5 + l.pad_left - l.pad_right,
                                        labelCtrY + l.pad_top - l.pad_bottom
                                        );
                        break;
                  }

                  addChildLayer(deref l);
               }
            }
         }
      }
   }

   protected method addEdgeLabels() {
      Graph *g;
      foreach g in graph.graphs
         addEdgeLabelsFromGraph(g);
      addEdgeLabelsFromGraph(graph);
   }

   protected method adjustPortButtonPositionsInGraph(Graph _g) {
      Node n <= _g.getIONode();
      if(null != n)
      {
         if(n.getNumPorts() > 0)
         {
            Layer lPanel <= n.getUIPanelLayer();
            if(null != lPanel)
            {
               float w = lPanel.size_x;
               float h = lPanel.size_y;
               float portMaxW = n.getPortLayerMaxW();
               float portMaxH = n.getPortLayerMaxH();

               // // trace "xxx adjustPortButtonPositionsInGraph: graph io node has "+n.getNumPorts()+" port(s) sz=("+w+";"+h+")";
               Port *port;
               foreach port in n.ports
               {
                  Layer l <= port.ui_panel_layer;
                  if(null != l)
                  {
                     float portW = l.size_x;
                     float portH = l.size_y;
                     // // trace "xxx adjustPortButtonPositionsInGraph: port.id="+port.id+" relpos="+port.relpos+" layerSz=("+portW+";"+portH+") #portsDir="+n.getNumPortsForDir(port.dir);

                     // (note) LEFT/RIGHT are added to pInner, TOP/BOTTOM to pOuter
                     switch(port.dir)
                     {
                        case Layout.TOP:
                           l.setPositionX(portMaxW - portW*0.5 + (w-portMaxW*2) * port.relpos);
                           break;

                        case Layout.LEFT:
                           l.setPositionY( - portH*0.5 + (h-portMaxH*2) * port.relpos);
                           break;

                        case Layout.BOTTOM:
                           l.setPositionX(portMaxW - portW*0.5 + (w-portMaxW*2) * port.relpos);
                           break;

                        case Layout.RIGHT:
                           l.setPositionY( - portH*0.5 + (h-portMaxH*2) * port.relpos);
                           break;
                     }
                  } // if null != l
               }
            }
         }
      }
   }

   protected method adjustPortButtonPositions() {
      Graph *g;
      foreach g in graph.graphs
         adjustPortButtonPositionsInGraph(g);
   }

   protected method addNodes() {
      float t = milliSeconds();
      if(graph.haveGraphAttrib("pixel_layout"))
      {
         switch(graph.getGraphAttrib("pixel_layout"))
         {
            default:
            case "grid":
               addNodesFromGraph_GridLayout(false/*bFixed*/);
               break;

            case "fixed":
               addNodesFromGraph_GridLayout(true/*bFixed*/);
               break;

            case "border":
               addNodesFromGraph_BorderLayout();
               break;
         }
      }
      else
      {
         addNodesFromGraph_GridLayout(false/*bFixed*/);
      }

      if(b_gf_profile) trace "[pro] GraphForm::layoutHierarchy: addNodesFromGraph() took "+(milliSeconds()-t)+" ms";
      recursiveBuildTabCycleLists();
      // // invalidateSizeCaches();
      // // // exit(20);
      // // // trace "xxx main graph layout done, hierarchy:";
      // // // printHierarchy();
   }

   protected method lazyAddNodesFromGraph() {
      // called by layoutHierarchy()
      if(null != graph)
      {
         if(ST_INIT_NODES/*0*/ == graph_ui_init_state)
         {
            // trace "[dbg] GraphForm::lazyAddNodesFromGraph: this="+#(this)+" graph_ui_init_state="+graph_ui_init_state;

            addNodes();

            // // // UI.LayoutRootLayer();

            if(b_gf_debug && null == graph.parent_graph)
               trace "[dbg] GraphForm::lazyAddNodesFromGraph: final main graph padding="+getPaddingString();

            graph_ui_init_state = ST_INIT_EDGES/*1*/;
         }
      }
   }

   public virtual recursiveBeginResize() {
      // called by UI.LayoutRootLayer() via UI.SetRootLayer() and UI.RootLayerResized()
      //  - called after pos/size have been updated but before layoutHierarchy()
      if(b_gf_debug)
         trace "[dbg] GraphForm::recursiveBeginResize: this="+#(this);

      if(null != graph)
         graph.recursiveBeginUIInit();  // invalidate ui_layer and other UI related state (edge connection counts etc)

      Panel::recursiveBeginResize();  // nothing to do..no child layers left (can skip call????)

      if(b_gf_debug2) trace "[>>>] GraphForm::recursiveBeginResize: removing node child layers and graph_edges";

      UI.LoseMouseFocusIfWithin(this);
      UI.LoseKeyboardFocusIfWithin(this, true/*bQuiet*/);

      removeChildHierarchy();
      graph_edges.free();
      graph_ui_init_state = ST_INIT_NODES/*0*/;
   }

   public virtual layoutHierarchy(local boolean _bInvalidateSizeCaches, local boolean _bLayoutFinal) {

      lazyAddNodesFromGraph();

      Panel::layoutHierarchy(_bInvalidateSizeCaches, _bLayoutFinal);

      if(null != graph)
      {
         if(_bLayoutFinal)
         {
            if(b_gf_debug4)
            {
               trace "xxx GraphForm::layoutHierarchy: graph.id='"+graph.id+"' this.getDebugString()="+getDebugString();
               printHierarchy();
            }
         }
      }
   }

   public method drawGraphEdges(float _tx, float _ty) {
      // // glTranslatef(_tx, _ty, 0);
      UIRenderer.ModelTranslate2f(_tx, _ty);
      GraphEdge *ge;
      foreach ge in graph_edges
      {
         // trace "xxx draw ge.edge="+(ge.edge.getString());
         ge.draw();
      }
      // // glTranslatef(-_tx, -_ty, 0);
      UIRenderer.ModelTranslate2f(-_tx, -_ty);
   }

   protected method recursiveDrawEdges(local float _tx, local float _ty) {
      local Layer c <= getLayoutFirstChild();
      while(null != c)
      {
         if(c instanceof GraphForm)
         {
            GraphForm gw <= c;
            gw.recursiveDrawEdges(_tx + c.position_x, _ty + c.position_y);
         }
         c <= c.next;
      }

      drawGraphEdges(_tx, _ty);
   }

   protected method drawEdges() {
      // Draw edges
      if(GraphEdge.bCanDoLineStipple && !UIRenderer.b_glcore)
         glEnable(GL_LINE_STIPPLE);  // !b_glcore
      // // glEnable(GL_LINE_SMOOTH);
      // // glEnable(GL_POLYGON_SMOOTH);
      // // glDisable(GL_CULL_FACE);
      if(GraphEdge.bCanDoLineBlend)
         UIRenderer.EnableBlending(); // line disappears on macOS

      if(b_graph_edges_translated)
      {
         // All edges were merged to this graph
         // trace "xxx drawEdges this graph.id="+graph.id+" #edges="+graph_edges.numElements;
         drawGraphEdges(0, 0);
      }
      else
      {
         // Recurse into sub graphs
         recursiveDrawEdges(0, 0);
      }

      if(GraphEdge.bCanDoLineBlend)
         UIRenderer.DisableBlending();
      // // glDisable(GL_POLYGON_SMOOTH);
      // // glDisable(GL_LINE_SMOOTH);
      if(GraphEdge.bCanDoLineStipple && !UIRenderer.b_glcore)
         glDisable(GL_LINE_STIPPLE);  // !b_glcore
   }

   public method joinEdges(PointerArray _edges) {
      // trace "xxx joinEdges: graph.id="+graph.id+" this.graph_edges="+#(graph_edges)+" edges="+#(_edges);
      // graph_edges <=
      graph_edges.joinDD(graph_edges, _edges);
      // trace "xxx joinEdges:     POST graph.id="+graph.id+" this.graph_edges="+#(graph_edges)+" edges="+#(_edges);
   }

   public method recursiveFlattenEdgesToMainGraph(local GraphForm _gwMain, local float _tx, local float _ty) {
      local Layer c <= getLayoutFirstChild();
      while(null != c)
      {
         if(c instanceof GraphForm)
         {
            GraphForm gw <= c;
            // trace "xxx recurse into graph gw.graph.id="+(gw.graph.id)+" t=("+_tx+";"+_ty+") => tsub=("+(_tx+c.position_x)+";"+(_ty+c.position_y)+")"+" #edges="+(gw.graph_edges.numElements);
            gw.recursiveFlattenEdgesToMainGraph(_gwMain, _tx + c.position_x, _ty + c.position_y);
         }
         c <= c.next;
      }

      GraphEdge *ge;
      foreach ge in graph_edges
         ge.translate2f(_tx, _ty);

      if(@(_gwMain) != @(this))
      {
         // trace "xxx joinEdges: subgraph.id="+graph.id+" graph_edges="+#(graph_edges)+" gwMain="+#(_gwMain)+" gwMain.graph_edges="+#(_gwMain.graph_edges);
         _gwMain.joinEdges(graph_edges);
         graph_edges.free();
      }
   }

   public method translateFlattenedLayers(float _tx, float _ty) {
      local Layer c <= getLayoutFirstChild();
      while(null != c)
      {
         c.position_x += _tx;
         c.position_y += _ty;
         c <= c.next;
      }

      GraphEdge *ge;
      foreach ge in graph_edges
         ge.translate2f(_tx, _ty);
   }

   public method flattenEdges() {
      // trace "xxx flattenEdges: main="+#(this)+" main.graph_edges="+#(graph_edges);
      recursiveFlattenEdgesToMainGraph(this, 0, 0);
      b_graph_edges_translated = true;
   }

   public static GetSVGColorString(int _c24) : String {
      Integer io = _c24 & 0x00FFffFF;
      return io.printf("\"#%06x\"");
   }

   public static GetSVGColorStringNoQuot(int _c24) : String {
      Integer io = _c24 & 0x00FFffFF;
      return io.printf("#%06x");
   }

   public static GetSVGStyleStrokeColorAndOpacityString(int _c24, float _borderAlpha) : String {
      Integer io = _c24 & 0x00FFffFF;
      return "stroke:"+io.printf("#%06x")+((_borderAlpha < 1.0f) ? (";stroke-opacity:"+_borderAlpha) : "");
   }

   public static GetSVGStrokeOpacityString(float _borderAlpha) : String {
      return (_borderAlpha < 1.0f) ? ("stroke-opacity=\""+_borderAlpha+"\"") : "";
   }

   protected static StringToSVG(String _text) : String {
      local String r <= _text.replace("&", "&amp;");
      r.replace("<", "&lt;");
      r.replace(">", "&gt;");
      return deref r;
   }

   protected method appendSVGButtonsAndPanels(String buf, boolean _bStartWithLabels) {
      boolean bEmit = !_bStartWithLabels;
      Layer c <= getLayoutFirstChild();
      // printHierarchy();
      Panel *pBorder;
      float arcW;
      float arcH;
      boolean bDebug = 0;
      local String sTransform;
      while(null != c)
      {
         // trace "xxx appendSVGButtonsAndPanels: bEmit="+bEmit+" c="+#(c);
         if(bEmit)
         {
            if(c instanceof Label)
            {
               Label lb <= c;
               pBorder <= lb.outer_border_panel;

               float px = int(lb.getPositionX());
               float py = int(lb.getPositionY());

               float sx = int(lb.getSizeX());
               float sy = int(lb.getSizeY());

               local String sCaption = StringToSVG(lb.getCaption());
               if(!sCaption.isBlank())
               {
                  // trace "xxx lb.caption=\""+lb.getCaption()+" p=("+px+";"+py+") s=("+sx+";"+sy+")";

                  float baselineY = lb.getBaselineY();
                  Font font <= lb.getFont();
                  if(bDebug) trace "xxx c.displayedText=\""+lb.getDisplayedText()+"\" font.size="+font.getSize()+" pBorder="+#(pBorder)+" baselineY="+baselineY+" cached_text_y="+lb.cached_text_y;
                  float textX = px + lb.cached_text_x;
                  float textY = py + /*baselineY + */lb.getCaptionOffsetY() + lb.cached_text_y;  // +lb.baseline_content_shift_y
                  // if(11 == font.getSize())
                  //    textY += 3;

                  if(1.8 <= UI.font_scaling <= 2.2)
                     textX -= 1;
                  else if(UI.font_scaling < 1.1)
                     textY += 1 + font.getHeight() * 0.085;
                  else
                     textY += 1 + font.getHeight() * 0.05;

                  // trace "xxx sCaption=\""+sCaption+"\"";
                  int numLineBreaks = sCaption.numIndicesOf("\n");

                  if(0 == numLineBreaks)
                  {
                     textY += font.getHeight();
                     textY += font.getDescender();
                  }
                  else
                  {
                     textY += font.getHeight();
                     textY += font.getDescender();
                  }
                  textY -= 2;
                  // trace "xxx lb.caption=\""+lb.getCaption()+"\" text=("+textX+";"+textY+") cachedSz=("+lb.cached_text_w+";"+lb.cached_text_h+")";

                  if(0 && null != pBorder && !_bStartWithLabels)
                  {
                     buf.append("  <rect x=\""+px+"\" y=\""+py+"\" width=\""+sx+"\" height=\""+sy+"\"");
                     arcW = pBorder.calcPanelArcW();
                     arcH = pBorder.calcPanelArcH();
                     buf.append(" rx=\""+arcW+"\" ry=\""+arcH+"\"");

                     buf.append(" style=\"");
                     buf.append("fill:"+GetSVGColorStringNoQuot(pBorder.panel_tint&#ffffff));
                     buf.append(";stroke-width:"+(pBorder.getPanelBorderWidth()*UI.font_scaling)+";stroke:"+GetSVGColorStringNoQuot(pBorder.panel_border_c24)+"\"");
                     buf.append(" />\n");
                  }
                  else if(lb.getEnableFillBackground())
                  {
                     buf.append("  <rect x=\""+px+"\" y=\""+py+"\" width=\""+sx+"\" height=\""+sy+"\"");
                     buf.append(" fill="+GetSVGColorString(lb.getBackgroundColor()));
                     buf.append(" />\n");
                  }

                  buf.append("  <text ");
                  float textAlignX;
                  switch( (numLineBreaks > 0) ? (lb.getTextPlacement() & Layout.CENTERX) : Layout.LEFT )
                  {
                     default: // LEFT
                        textAlignX = textX;
                        break;

                     case Layout.RIGHT:
                        textAlignX = textX + (sx - lb.ipad_r - lb.cached_text_w);
                        buf.append(" text-anchor=\"end\"");
                        break;

                     case Layout.CENTERX:
                        textAlignX = textX + lb.cached_text_w*0.5;
                        buf.append(" text-anchor=\"middle\"");
                        break;
                  }

                  sTransform.empty();
                  if(lb.b_rotate)
                  {
                     // trace "xxx rotate p=("+px+";"+py+") s=("+sx+";"+sy+") text=("+textX+";"+textY+") textSz=("+lb.cached_text_w+";"+lb.cached_text_h+")";

                     if(lb.b_rotate_ccw)
                     {
                        // tx 116+194+(235-194)*0.5
                        // ty 132+(96+35*0.5)*0.5
                        sTransform = " text-anchor=\"start\" transform=\"rotate(-90) translate("+(-(py+lb.cached_text_w+(sy-lb.cached_text_w)*0.5))+" "+(px+(sx + lb.cached_text_h*0.5)*0.5)+")\"";
                        textX = 0;
                        textY = 0;
                     }
                     else
                     {
                        // tx 35+(396-193)*0.5
                        // ty 634+(64-35*0.5)*0.5
                        sTransform = " text-anchor=\"start\" transform=\"rotate(90) translate("+(py+(sy-lb.cached_text_w)*0.5)+" "+(-(px+(sx - lb.cached_text_h*0.5)*0.5))+")\"";
                        textX = 0;
                        textY = 0;
                     }

                  }

                  if(textX > 0.0f)
                     buf.append(" x=\""+textX+"\"");
                  if(textY > 0.0f)
                     buf.append(" y=\""+textY+"\"");
                  buf.append(" font-size=\""+int(font.getSize() * UI.font_scaling)+"\"");
                  // // buf.append(" alignment-baseline=\"middle\" text-anchor=\"middle\"");
                  buf.append(" font-family=\"Tahoma,sans-serif\"");
                  buf.append(" fill="+GetSVGColorString(lb.getForegroundColor()));
                  buf.append(" "+sTransform+">");

                  if(numLineBreaks > 0)
                  {
                     local String aLines <= sCaption.splitChar('\n');
                     String *sLine;
                     int textLineX = textAlignX;
                     int textLineY = textY;
                     foreach sLine in aLines
                     {
                        // // buf.append("<tspan x=\"0\" dy=\"2em\">"+sLine+"</tspan>");
                        buf.append("<tspan x=\""+textLineX+"\" y=\""+textLineY+"\">"+sLine+"</tspan>");
                        textLineY += font.getHeight();
                     }
                  }
                  else
                  {
                     buf.append(sCaption);
                  }

                  buf.append("</text>  /* sz=("+lb.cached_text_w+";"+lb.cached_text_h+") */\n");

               } // if !caption.isBlank
            }
            else if(c instanceof Panel)
            {
               Panel p <= c;

               if(bDebug)
                  trace "xxx ---- panel p="+#(p)+" id="+p.layer_id+" alpha="+p.panel_alpha+" bg_shape="+p.panel_bg_shape+" border_shape="+p.panel_border_shape+" sz="+p.getSizeString()+" c32_bg="+UI.GetColorString(p.c32_bg)+" border_color="+UI.GetColorString(p.panel_border_c24)+" border_style="+p.panel_border_style+" border_width="+p.panel_border_width;

               if( (p.panel_alpha > 0/* || UI.BLEND_OFF == p.panel_bg_blend*/) || p.panel_border_width > 0.0f)
               {
                  int stackNum    = (p.panel_stack > 1) ? (p.panel_stack - 1) : 0;
                  float stackOffX = stackNum * p.panel_stack_off_x;
                  float stackOffY = stackNum * p.panel_stack_off_y;

                  float bgAlpha = p.panel_alpha * p.panel_bg_alpha * (1.0 / 65025.0);
                  int c32Bg = sdvg_TintARGB(p.c32_bg, p.bg32_tint);
                  c32Bg = sdvg_TintARGB(c32Bg, p.panel_tint);
                  c32Bg = (c32Bg & 0x00FFFFFF);///// | (bgAlpha << 24);

                  // // if(Panel.SHAPE_NONE == p.panel_bg_shape)
                  // //    bgAlpha = 0.0f;

                  float borderAlpha = p.panel_alpha * p.panel_border_alpha * (1.0 / 65025.0);
                  if(UI.BLEND_OFF == p.panel_border_blend)// && p.panel_alpha > 0)
                  {
                     // borderAlpha *= 1.0f;
                     // if(0 == p.panel_border_c24)
                        borderAlpha = 1.0f;
                  }
                  else if(UI.BLEND_SRCOVER != p.panel_border_blend && p.panel_alpha > 0)
                     borderAlpha = p.panel_alpha * (0.5f / 255.0f);
                  int c32Border = p.panel_border_c24 & 0x00FFFFFF;
                  // trace "xxx borderAlpha="+borderAlpha;

                  int stackIdx = stackNum + 1;
                  loop(stackNum + 1)
                  {
                     // // String sPanelFill <= (0 != ((p.panel_tint >> 24) & 255)) ? ("fill="+GetSVGColorString(p.panel_tint)) : "fill=none";
                     String sPanelFill = (0 && stackIdx > 1) ? "fill=\"none\"" : (p.b_fill_bg ? ("fill="+GetSVGColorString(c32Bg)) : "fill=\"none\"");

                     float curBgAlpha;
                     if(stackIdx > 1)
                     {
                        curBgAlpha = mathPowerf(bgAlpha * p.panel_stack_alpha_decay, stackIdx * mathLerpf(p.panel_stack_alpha_exp, 1.0f, 0.42f));
                        // trace "xxx SVG stackIdx="+stackIdx+" bgAlpha="+bgAlpha+" curBgAlpha="+curBgAlpha;
                     }
                     else
                     {
                        curBgAlpha = bgAlpha;
                        // trace "xxx SVG panel_alpha="+p.panel_alpha+" panel_bg_alpha="+p.panel_bg_alpha+" bgAlpha="+bgAlpha;
                     }
                     if(curBgAlpha < 1.0)
                        sPanelFill.append(" fill-opacity=\""+curBgAlpha+"\"");

                     float curBorderAlpha;
                     if(stackIdx > 1)
                     {
                        curBorderAlpha = mathPowerf(borderAlpha * p.panel_stack_alpha_decay, stackIdx * mathLerpf(p.panel_stack_alpha_exp, 1.0f, 0.42f));
                        if(b_gf_debug2) trace "xxx SVG stackIdx="+stackIdx+" borderAlpha="+borderAlpha+" curBorderAlpha="+curBorderAlpha;
                     }
                     else
                     {
                        curBorderAlpha = borderAlpha;
                        if(b_gf_debug2) trace "xxx SVG panel_border_alpha="+p.panel_border_alpha+" borderAlpha="+borderAlpha+" curBorderAlpha="+curBorderAlpha;
                     }

                     // if(Panel.STYLE_DEFAULT == p.panel_border_style)
                     //    curBorderAlpha = 0.0f;  // (todo) commented, now fix test23d.gr

                     float pbw = p.getPanelBorderWidth() * UI.font_scaling;
                     // if(pbw > 0.0f)
                     //    pbw = mathMaxf(0.5f, pbw);

                     px = int(p.getPositionX() + stackOffX);
                     py = int(p.getPositionY() + stackOffY);
                     sx = int(p.getSizeX()) - pbw * 1.0f;
                     sy = int(p.getSizeY()) - pbw * 1.0f;

                     float tx, ty;
                     float cx, cy;

                     float rx;
                     float ry;

                     float drax, dray;

                     if([Panel.STYLE_DEFAULT, Panel.STYLE_SOLID].contains(p.panel_border_style))
                     {
                        // trace "xxx bg_shape="+p.panel_bg_shape+" border_shape="+p.panel_border_shape;
                        // trace "xxx c32_bg="+UI.GetColorString(p.c32_bg)+" border_width="+p.panel_border_width+" pbw="+pbw;

                        // solid
                        if([Panel.SHAPE_ROUND].contains(p.panel_bg_shape)     ||
                           [Panel.SHAPE_ROUND].contains(p.panel_border_shape)
                           )
                        {
                           // round, solid shape
                           arcW = p.calcPanelArcW();
                           arcH = p.calcPanelArcH();

                           buf.append("  <rect x=\""+px+"\" y=\""+py+"\" width=\""+sx+"\" height=\""+sy+"\" "+sPanelFill);
                           buf.append(" rx=\""+arcW+"\" ry=\""+arcH+"\"");
                           buf.append(" style=\"stroke-width:"+pbw+";"+GetSVGStyleStrokeColorAndOpacityString(c32Border, curBorderAlpha));
                           buf.append("\"");
                           buf.append("/>\n");
                        }
                        else if([Panel.SHAPE_DEFAULT, Panel.SHAPE_RECT].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_DEFAULT, Panel.SHAPE_RECT].contains(p.panel_border_shape)
                                )
                        {
                           // rectangular, solid shape
                           if(Layout.CENTER/*all*/ == p.panel_border_dir)
                           {
                              // trace "xxx dbg pbw="+pbw;
                              // buf.append("  <!--dbg id="+p.layer_id+" pbw="+pbw+" border_style="+p.panel_border_style+"-->");
                              // buf.append("  <rect x=\""+(px+pbw*0.5)+"\" y=\""+(py+pbw*0.5)+"\" width=\""+(sx-pbw)+"\" height=\""+(sy-pbw)+"\" "+sPanelFill+" stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha)+"/>\n"); // /*palpha="+p.panel_alpha+" ptint="+p.panel_tint+"*/

                              buf.append("  <rect x=\""+px+"\" y=\""+py+"\" width=\""+sx+"\" height=\""+sy+"\" "+sPanelFill+" stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha)+"/>\n"); // /*palpha="+p.panel_alpha+" ptint="+p.panel_tint+"*/

                              // trace "xxx dbg  stroke-width=\""+pbw+"\"";
                           }
                           else
                           {
                              buf.append("  <rect x=\""+px+"\" y=\""+py+"\" width=\""+sx+"\" height=\""+sy+"\" "+sPanelFill+" />\n");
                              local String sPanelBorderDirStroke <= " stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha);

                              float bdX = px;
                              float bdY = py;
                              float bdW = sx;
                              float bdH = sy;

                              if(p.panel_border_dir & Layout.TOP)
                                 buf.append("  <line x1=\""+bdX+"\" y1=\""+bdY+"\" x2=\""+(bdX+bdW)+"\" y2=\""+bdY+"\" "+sPanelBorderDirStroke+"/> /*t*/\n");

                              if(p.panel_border_dir & Layout.RIGHT)
                                 buf.append("  <line x1=\""+(bdX+bdW)+"\" y1=\""+bdY+"\" x2=\""+(bdX+bdW)+"\" y2=\""+(bdY+bdH)+"\" "+sPanelBorderDirStroke+"/> /*t*/\n");

                              if(p.panel_border_dir & Layout.BOTTOM)
                                 buf.append("  <line x1=\""+(bdX+bdW)+"\" y1=\""+(bdY+bdH)+"\" x2=\""+bdX+"\" y2=\""+(bdY+bdH)+"\" "+sPanelBorderDirStroke+"/> /*t*/\n");

                              if(p.panel_border_dir & Layout.LEFT)
                                 buf.append("  <line x1=\""+bdX+"\" y1=\""+(bdY+bdH)+"\" x2=\""+bdX+"\" y2=\""+bdY+"\" "+sPanelBorderDirStroke+"/> /*t*/\n");
                           }
                        }
                        else if([Panel.SHAPE_RHOMB].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_RHOMB].contains(p.panel_border_shape)
                                )
                        {
                           // rhomb, solid shape
                           tx = p.getPanelShapeRhombTx()*0.5;
                           ty = p.getPanelShapeRhombTy()*0.5;
                           px += pbw;
                           py += pbw;
                           sx -= pbw*2;
                           sy -= pbw*2;
                           buf.append("  <path d=\"M"+(px+tx)+" "+(py-ty)+" L"+(px+tx+sx)+" "+(py-ty)+" L"+(px-tx+sx)+" "+(py+ty+sy)+" L"+(px-tx)+" "+(py+ty+sy)+" z\" "+sPanelFill+" stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha)+"/>\n");
                        }
                        else if([Panel.SHAPE_DIAMOND].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_DIAMOND].contains(p.panel_border_shape)
                                )
                        {
                           // rotated rhomb, solid shape
                           cx = px + sx * 0.5;
                           cy = py + sy * 0.5;
                           rx = /*p.getPanelShapeDiamondRx()*/sx*0.5 - pbw*0.5;
                           ry = /*p.getPanelShapeDiamondRy()*/sy*0.5 - pbw*0.5;
                           buf.append("  <path d=\"M"+(cx)+" "+(cy-ry)+" L"+(cx+rx)+" "+(cy)+" L"+(cx)+" "+(cy+ry)+" L"+(cx-rx)+" "+(cy)+" z\" "+sPanelFill+" stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha)+"/>\n");
                        }
                        else if([Panel.SHAPE_ELLIPSE].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_ELLIPSE].contains(p.panel_border_shape)
                                )
                        {
                           // ellipse, solid shape
                           cx = px + sx * 0.5;
                           cy = py + sy * 0.5;
                           rx = /*p.getPanelShapeEllipseRx()*/sx*0.5 - pbw*0.5;
                           ry = /*p.getPanelShapeEllipseRy()*/sy*0.5 - pbw*0.5;
                           buf.append("  <ellipse cx=\""+cx+"\" cy=\""+cy+"\" rx=\""+rx+"\" ry=\""+ry+"\" "+sPanelFill+" stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha)+"/>\n");
                        }
                        else if([Panel.SHAPE_HEXAGON].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_HEXAGON].contains(p.panel_border_shape)
                                )
                        {
                           // hexagon, solid shape
                           rx = sx * 0.5;
                           ry = sy * 0.5;

                           cx = px + rx;
                           cy = py + ry;

                           drax = rx - panel_shape_hexagon_ax;
                           dray = ry - panel_shape_hexagon_ay;

                           buf.append("  <path d=\"M"+cx+" "+(cy-ry)+" L"+(cx+drax)+" "+(cy-dray*0.5)+" L"+(cx+drax)+" "+(cy+dray*0.5)+" L"+(cx)+" "+(cy+ry)+" L"+(cx-drax)+" "+(cy+dray*0.5)+" L"+(cx-drax)+" "+(cy-dray*0.5)+"z\" "+sPanelFill+" stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha)+"/>\n");
                        }
                        else if([Panel.SHAPE_TRI].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_TRI].contains(p.panel_border_shape)
                                )
                        {
                           // tri, solid shape
                           buf.append("  <path d=\"M"+(px+panel_shape_tri_ax)+" "+(py+sy)+" L"+(px+(sx*0.5))+" "+(py+panel_shape_tri_ay)+" L"+(px+sx-panel_shape_tri_ax)+" "+(py+sy)+"z\" "+sPanelFill+" stroke-width=\""+pbw+"\" stroke="+GetSVGColorString(c32Border)+" "+GetSVGStrokeOpacityString(curBorderAlpha)+"/>\n");
                        }
                     }
                     else if([Panel.STYLE_DOTTED, Panel.STYLE_DASHED].contains(p.panel_border_style))
                     {
                        // dashed or dotted
                        // // px = p.getPositionX() + stackOffX;
                        // // py = p.getPositionY() + stackOffY;
                        float pw = p.getSizeX();
                        float ph = p.getSizeY();

                        if([Panel.SHAPE_ROUND].contains(p.panel_bg_shape) ||
                           [Panel.SHAPE_ROUND].contains(p.panel_border_shape)
                           )
                           // // if([Panel.SHAPE_ROUND].contains(p.panel_bg_shape))
                        {
                           // round, dashed or dotted shape
                           //  (note) A rx ry rotation large-arc-flag sweep-flag x y
                           arcW = p.calcPanelArcW();
                           arcH = p.calcPanelArcH();
                           buf.append("  <path d=\"M"+(px+arcW)+" "+py);
                           // t
                           buf.append(" L"+(px+pw-arcW)+" "+py);
                           // rt
                           buf.append(" A"+arcW+" "+arcH+" 0.0 0 1 "+(px+pw)+" "+(py+arcH));
                           // r
                           buf.append(" L"+(px+pw)+" "+(py+ph-arcH));
                           // rb
                           buf.append(" A"+arcW+" "+arcH+" 0.0 0 1 "+(px+pw-arcW)+" "+(py+ph));
                           // b
                           buf.append(" L"+(px+arcW)+" "+(py+ph));
                           // lb
                           buf.append(" A"+arcW+" "+arcH+" 0.0 0 1 "+px+" "+(py+ph-arcH));
                           // l
                           buf.append(" L"+px+" "+(py+arcH));
                           // lt
                           buf.append(" A"+arcW+" "+arcH+" 0.0 0 1 "+(px+arcW)+" "+py);
                           buf.append(" z\"");

                           // // if(Panel.SHAPE_DEFAULT != p.panel_border_shape)
                           // // {
                           // //    buf.append("  <rect x=\""+p.getPositionX()+"\" y=\""+p.getPositionY()+"\" width=\""+p.getSizeX()+"\" height=\""+p.getSizeY()+"\"");
                           // //    arcW = p.calcPanelArcW();
                           // //    arcH = p.calcPanelArcH();
                           // //    buf.append(" rx=\""+arcW+"\" ry=\""+arcH+"\" fill=\"none\"");
                           // //    buf.append(" style=\"fill:none;stroke-width:"+p.getPanelBorderWidth()+";stroke:"+GetSVGColorStringNoQuot(p.panel_border_24)+"\"");
                           // //    buf.append("/>\n");
                           // // }
                        }
                        else if([Panel.SHAPE_DEFAULT, Panel.SHAPE_RECT].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_DEFAULT, Panel.SHAPE_RECT].contains(p.panel_border_shape)
                                )
                        {
                           // rectangular, dashed or dotted shape
                           //   (note) stroke-dasharray does not work with 'rect' element
                           buf.append("  <path d=\"M"+px+" "+py+" L"+(px+pw)+" "+py+" L"+(px+pw)+" "+(py+ph)+" L"+px+" "+(py+ph)+" z\"");
                        }
                        else if([Panel.SHAPE_RHOMB].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_RHOMB].contains(p.panel_border_shape)
                                )
                        {
                           // rhomb, dashed or dotted shape
                           tx = p.getPanelShapeRhombTx()*0.5;// - pbw;
                           ty = p.getPanelShapeRhombTy()*0.5;// - pbw;
                           px += pbw;
                           py += pbw;
                           sx -= pbw*2;
                           sy -= pbw*2;
                           buf.append("  <path d=\"M"+(px+tx)+" "+(py-ty)+" L"+(px+tx+sx)+" "+(py-ty)+" L"+(px-tx+sx)+" "+(py+ty+sy)+" L"+(px-tx)+" "+(py+ty+sy)+" z\"");
                        }
                        else if([Panel.SHAPE_DIAMOND].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_DIAMOND].contains(p.panel_border_shape)
                                )
                        {
                           // rotated rhomb, dashed or dotted shape
                           cx = px + sx * 0.5;
                           cy = py + sy * 0.5;
                           rx = /*p.getPanelShapeDiamondRx()*/sx*0.5 - pbw*0.5;
                           ry = /*p.getPanelShapeDiamondRy()*/sy*0.5 - pbw*0.5;
                           buf.append("  <path d=\"M"+(cx)+" "+(cy-ry)+" L"+(cx+rx)+" "+(cy)+" L"+(cx)+" "+(cy+ry)+" L"+(cx-rx)+" "+(cy)+" z\"");
                        }
                        else if([Panel.SHAPE_ELLIPSE].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_ELLIPSE].contains(p.panel_border_shape)
                                )
                        {
                           // ellipse, dashed or dotted shape
                           cx = px + sx * 0.5;
                           cy = py + sy * 0.5;
                           rx = /*p.getPanelShapeEllipseRx()*/sx*0.5 - pbw*0.5;
                           ry = /*p.getPanelShapeEllipseRy()*/sy*0.5 - pbw*0.5;
                           buf.append("  <ellipse cx=\""+cx+"\" cy=\""+cy+"\" rx=\""+rx+"\" ry=\""+ry+"\" ");
                        }
                        else if([Panel.SHAPE_HEXAGON].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_HEXAGON].contains(p.panel_border_shape)
                                )
                        {
                           // hexagon, dashed or dotted shape
                           rx = sx * 0.5;
                           ry = sy * 0.5;

                           cx = px + rx;
                           cy = py + ry;

                           drax = rx - panel_shape_hexagon_ax;
                           dray = ry - panel_shape_hexagon_ay;

                           buf.append("  <path d=\"M"+cx+" "+(cy-ry)+" L"+(cx+drax)+" "+(cy-dray*0.5)+" L"+(cx+drax)+" "+(cy+dray*0.5)+" L"+(cx)+" "+(cy+ry)+" L"+(cx-drax)+" "+(cy+dray*0.5)+" L"+(cx-drax)+" "+(cy-dray*0.5)+"z\"");
                        }
                        else if([Panel.SHAPE_TRI].contains(p.panel_bg_shape) ||
                                [Panel.SHAPE_TRI].contains(p.panel_border_shape)
                                )
                        {
                           // tri, dashed or dotted shape
                           buf.append("  <path d=\"M"+(px+panel_shape_tri_ax)+" "+(py+sy)+" L"+(px+(sx*0.5))+" "+(py+panel_shape_tri_ay)+" L"+(px+sx-panel_shape_tri_ax)+" "+(py+sy)+"z\"");
                        }

                        buf.append(" "+sPanelFill+" style=\"stroke-width:"+pbw+";"+GetSVGStyleStrokeColorAndOpacityString(c32Border, curBorderAlpha));

                        switch(p.panel_border_style)
                        {
                           default:
                           case Panel.STYLE_DEFAULT:
                           case Panel.STYLE_SOLID:
                              break;

                           case Panel.STYLE_DOTTED:
                              buf.append(";stroke-dasharray:3 3");
                              break;

                           case Panel.STYLE_DASHED:
                              buf.append(";stroke-dasharray:10 6");
                              break;
                        }

                        buf.append("\"");
                        buf.append("/>\n");
                     }

                     if(--stackIdx > 0)
                     {
                        // // trace "xxx drawPanelBorder: stackOff=("+stackOffX+";"+stackOffY+")";
                        stackOffX -= p.panel_stack_off_x;
                        stackOffY -= p.panel_stack_off_y;
                     }

                  } // loop stackNum + 1

               } // if panel_alpha > 0
            } // else if is Panel
         } // if bEmit

         if(c.b_invoke_parent_ondrawchildpost)
            bEmit = _bStartWithLabels;

         c <= c.next;
      }
   }

   protected method appendSVGEdges(String buf, boolean bDebug, boolean _bMainGraph) {
      GraphEdge *ge;
      foreach ge in graph_edges
      {
         Edge e <= ge.edge;

         boolean bInMainGraph = e.isInMainGraph();

         if( ( _bMainGraph &&  bInMainGraph) ||
             (!_bMainGraph && !bInMainGraph)
             )
         {
            if(ge.b_curve)
            {
               if(ge.b_rcurve)
               {
                  // rectangular edge
                  FloatArray curveVerts <= ge.curve_vertices;
                  int vtxOff = 2;
                  buf.append("  <path d=\"M"+curveVerts[0]+" "+curveVerts[1]);
                  loop((curveVerts.numElements-2) / 2)
                  {
                     buf.append(" L"+curveVerts[vtxOff+0]+" "+curveVerts[vtxOff+1]);
                     vtxOff += 2;
                  }
                  buf.append("\"");
               }
               else
               {
                  // quadratic spline edge
                  float c1x;
                  float c1y;
                  float c2x;
                  float c2y;
                  if(ge.b_curve_c)
                  {
                     if(bDebug) trace "xxx ge.c1=("+ge.curve_c1x+";"+ge.curve_c1y+")";
                     c1x = ge.curve_c1x;
                     c1y = ge.curve_c1y;
                     c2x = ge.curve_c2x;
                     c2y = ge.curve_c2y;
                  }
                  else
                  {
                     if(ge.b_curve_bend_h_tail)
                     {
                        c1x = mathLerpf(ge.abs_x_tail, ge.abs_x_head, ge.curve_bendiness);
                        c1y = ge.abs_y_tail;
                     }
                     else
                     {
                        c1x = ge.abs_x_tail;
                        c1y = mathLerpf(ge.abs_y_tail, ge.abs_y_head, ge.curve_bendiness);
                     }

                     if(ge.b_curve_bend_h_head)
                     {
                        c2x = mathLerpf(ge.abs_x_head, ge.abs_x_tail, ge.curve_bendiness);
                        c2y = ge.abs_y_head;
                     }
                     else
                     {
                        c2x = ge.abs_x_head;
                        c2y = mathLerpf(ge.abs_y_head, ge.abs_y_tail, ge.curve_bendiness);
                     }
                  }

                  if(bDebug) trace "xxx curve tail="+ge.abs_x_tail+";"+ge.abs_y_tail+" c="+c1x+";"+c1y+" head="+ge.abs_x_head+";"+ge.abs_y_head;

                  buf.append("  <path d=\"M"+ge.abs_x_tail+" "+ge.abs_y_tail+" C"+c1x+" "+c1y+" "+c2x+" "+c2y+" "+ge.abs_x_head+" "+ge.abs_y_head+"\"");
               }
            }
            else
            {
               // line
               buf.append("  <line x1=\""+ge.abs_x_tail+"\" y1=\""+ge.abs_y_tail+"\" x2=\""+ge.abs_x_head+"\" y2=\""+ge.abs_y_head+"\"");
            }
            buf.append(" style=\"fill:none;stroke:"+GetSVGColorStringNoQuot(ge.fgcolor&0xFFffFF)+";stroke-width:"+ge.getSVGWidth());
            switch(e.edge_style)
            {
               default:
               case Edge.STYLE_NORMAL:
                  break;

               case Edge.STYLE_DOTTED:
                  buf.append(";stroke-dasharray:3 3");
                  break;

               case Edge.STYLE_DASHED:
                  buf.append(";stroke-dasharray:7 5");
                  break;
            }
            buf.append("\"");
            buf.append("/>\n");
         }
      }
   }

   public method exportSVG(String _pathname, boolean _bHTML) : boolean {
      boolean bDebug = false;

      // apply padding translation
      float padT = mathMaxf(2.0f, pad_top);
      float padL = mathMaxf(2.0f, pad_left);
      float padB = mathMaxf(2.0f, pad_bottom);
      float padR = mathMaxf(2.0f, pad_right);
      translateFlattenedLayers(padL, padT);

      local String buf;
      if(_bHTML)
      {
         buf.append("<!-- document: \""+_pathname+"\" source: \""+last_gr_pathname+"\" -->\n");
         buf.append("<html><head><title>"+last_gr_pathname+"</title></head><body><h1>graph: \""+StringToSVG(last_gr_pathname)+"\"</h1>\n");
      }
      buf.append("<svg width=\""+(getSizeX()+padL+padR)+"\" height=\""+(getSizeY()+padT+padB)+"\" xmlns=\"http://www.w3.org/2000/svg\">\n");
      buf.append("  <!-- bg -->\n");
      buf.append("  <rect width=\"100%\" height=\"100%\" fill="+GetSVGColorString(panel_tint)+"/>\n");

      buf.append("  <!-- edges -->\n");
      appendSVGEdges(buf, bDebug, true/*bMainGraph*/);

      buf.append("  <!-- nodes -->\n");
      appendSVGButtonsAndPanels(buf, false/*start_with_b_invoke_parent_ondrawchildpost*/);

      buf.append("  <!-- edges (sub) -->\n");
      appendSVGEdges(buf, bDebug, false/*bMainGraph*/);

      buf.append("  <!-- edge arrows -->\n");
      GraphEdge *ge;
      foreach ge in graph_edges
         ge.appendSVGArrow(buf);

      buf.append("  <!-- labels -->\n");
      appendSVGButtonsAndPanels(buf, true/*start_with_b_invoke_parent_ondrawchildpost*/);

      buf.append("</svg>\n");
      if(_bHTML)
         buf.append("</body></html>");
      if( (_bHTML && _pathname >= ".html") ||
          (!_bHTML && _pathname >= ".svg")
          )
      {
         buf.saveLocal(_pathname);
      }

      if(!UI.b_headless)
      {
         // undo padding translation
         translateFlattenedLayers(-padL, -padT);
      }

      return true;
   }

   public virtual onResize() {
      Layer::onResize();

      if(null != graph && ST_INIT_EDGES/*1*/ == graph_ui_init_state)
      {
         graph_ui_init_state = ST_INIT_DONE/*2*/;
         float t = milliSeconds();
         addEdgesFromGraph();
         if(b_gf_profile) trace "[pro] GraphForm::onResize: addEdgesFromGraph() took "+(milliSeconds()-t)+" ms";

         adjustPortButtonPositions();

         if(null == graph.parent_graph)
         {
            if(b_gf_debug4)
               printHierarchy();

            if(!graph.haveGraphAttrib("flatten") || 0 != int(graph.getGraphAttrib("flatten")))
            {
               if(1)
                  flattenHierarchy(true/*bIgnoreLayerGroups*/);
               else if(1)
                  flattenHierarchy(false/*bIgnoreLayerGroups*/);
               // if(b_gf_debug4) printHierarchy();

               Layer lastChild <= getLastChild();
               // trace "xxx lastChild="+#(lastChild);
               if(null != lastChild)
                  lastChild.setEnableInvokeParentOnDrawChildPost(true);

               flattenEdges();

               addEdgeLabels();

               if(1)
                  flattenHierarchy(true/*bIgnoreLayerGroups*/);
               else if(1)
                  flattenHierarchy(false/*bIgnoreLayerGroups*/);
            }

            // printHierarchy();

            onResizeFormPost();
         }
      }
   }

   public virtual onDraw() {
      if(b_gf_debug)
         trace "[>>>] GraphForm::onDraw: graph_ui_init_state="+graph_ui_init_state+" this="+#(this)+" graph="+#(graph)+" size="+getSizeString();

      Panel::onDraw();
   }

   public virtual onDrawPost() {
      Panel::onDrawPost();
      // // drawEdges();
   }

   public virtual onDrawChildPost(Layer _childLayer) {
      // // Panel::onDrawChildPost();
      // trace "[>>>] onDrawChildPost: last child layer before edge is "+_childLayer.getDebugString();
      drawEdges();
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {
      initGraphForm(null/*parent_graph_form*/);

      return Layer::beginXFMTag(_form, _attributes);
   }

   public method setIncludePaths(StringArray _paths) {
      include_paths <= Object(deref _paths);
   }

   public method parseGraphForm(String _buf, String _name) : boolean {
      // 'name': current path name (for error reporting and includes)

      UI.LoseMouseFocusIfWithin(this);
      UI.LoseKeyboardFocusIfWithin(this, true/*bQuiet*/);
      removeChildHierarchy();
      // // setPadding4f(0,0,0,0);  // reset in case previous test case modified this (e.g. test29.gr)

      gr <= new GR;
      gr.init();
      gr.setIncludePathsByRef(include_paths);

      float t = milliSeconds();
      graph <= gr.parseGR(_buf, _name, null/*curPathName*/);
      if(b_gf_profile) trace "[pro] GraphForm::endXFMTag: gr.parseGR() took "+(milliSeconds()-t)+" ms";

      if(null != graph)
      {
         graph.graph_form <= this;
         if(b_gf_debug) trace "[trc] GraphForm::endXFMTag: -------------------------- layout main graph \'"+graph.id+"'";

         setEnableLockSize(false);

         t = milliSeconds();

         if(graph.layout())
         {
            // // setDebug(true);
            // // trace "xxx parseGraphForm: main graph ipad="+(graph.gr_attribs["ipad"]+" getDebug()="+getDebug());
            setPanelInnerPaddingFromGRAttribs(this, graph.gr_attribs);
            setLayerRequiredSizeFromAttribs(this, graph.gr_attribs);  // [01Feb2025] experimental abs positioning/size
            // // trace "xxx main graph padding="+getPaddingString();
            // // // // copyBackgroundFromGRAttribsToPanel(graph.gr_attribs, parent);

            if(b_gf_profile) trace "[pro] GraphForm::endXFMTag: graph.layout() took "+(milliSeconds()-t)+" ms";
            if(b_gf_debug2)
            {
               graph.debugPrintNodes();
               graph.debugPrintEdges();
            }
            if(b_gf_debug)
               graph.debugPrint();
            graph_ui_init_state = ST_INIT_NODES/*0*/;

            // Succeeded
            return true;
         }
         else
         {
            trace "[---] GraphForm::endXFMTag: graph.layout() failed.";
         }
      }

      return false;
   }

   public virtual endXFMTag(AbstractXMLForm _form, HashTable _attributes) {
      String sFlowText <= _attributes.get("<>");
      if(null != sFlowText && !sFlowText.isBlank())
      {
         if(b_gf_debug2) trace "[trc] GraphForm::endXFMTag: flowtext=>>"+sFlowText+"<<";

         parseGraphForm(sFlowText, "xfm");
      }

      if(isTabCycleRoot())
         buildTabCycleList();
   }

   public method findLayerByPathAbs(StringArray aPath) : Layer {
      Graph g <= graph;
      String *sPath;
      int pathIdx = 0;
      foreach sPath in aPath
      {
         Node n <= g.findNode(sPath);
         if(null != n)
         {
            if((pathIdx+1) == aPath.numElements)
            {
               // last path element, must be a node (not a subgraph)
               if(null == n.parent_subgraph)
                  return n.ui_content_layer;
               return null;
            }
            else if(null != n.parent_subgraph)
            {
               g <= n.parent_subgraph;
               pathIdx++;
            }
            else
               return null;  // in-between path element is a node but expected a subgraph
         }
         else
            return null;
      }
      return null;
   }

   public method findLayerByPathRel(StringArray aPath) : Layer {
      Node n <= graph.recursiveFindNodeByPathRel(aPath);
      if(null != n)
         return n.ui_content_layer;
      return null;
   }

   public method findLayerByPath(String _path) : Layer {
      local StringArray aPath <= _path.splitChar('.');
      Layer l <= findLayerByPathAbs(aPath);
      if(null == l)
         l <= findLayerByPathRel(aPath);
      return l;
   }

}
