// ----
// ---- file   : Scroller.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2005-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- changed: 31Jul2005, 30Oct2007, 09Aug2008, 10Aug2008, 01Feb2009, 31May2009, 15Mar2011
// ----          20Mar2011, 21Feb2017, 10Feb2018, 16Feb2018, 13Nov2018, 29Nov2018, 03Nov2019
// ----          03Apr2021, 27Jun2021, 04Oct2023, 08Oct2023, 11Nov2023, 22Mar2024, 23Mar2024
// ----
// ----
// ----

module MScroller;

namespace ui;


class Scroller extends Control {
   define float BUTTON_W = 18;
   define float BUTTON_H = 16;

   define String ACTION_INCVALUE = "onIncScroller";
   define String ACTION_DECVALUE = "onDecScroller";
   define String ACTION_VALUECHANGING = Slider.ACTION_VALUECHANGING; // map to this namespace
   define String ACTION_VALUECHANGED = Slider.ACTION_VALUECHANGED; // map to this namespace

   namespace RepeatButton *btinc;
   namespace RepeatButton *btdec;
   namespace Slider       *slider;


   public static New(float _min, _max, _value, _step) : Scroller {
      local Scroller sc;
      sc.initScroller(_min, _max, _value, _step);
      sc.initLayout();
      return deref sc;
   }

   public static NewVertical(float _min, _max, _value, _step) : Scroller {
      local Scroller sc;
      sc.initScroller(_min, _max, _value, _step);
      sc.setVertical(true);
      sc.initLayout();
      return deref sc;
   }

   public method initScrollerPre() {
      initLayer();

      slider <= new Slider;
      slider.initSlider(0, 10, 0, 1);

      btinc <= new RepeatButton;
      btinc.initRepeatButton();
      btinc.setLayerStyle(lnf.slider_layer_style);
      // // trace "xxx Scoller::btinc: layer_style="+btinc.layer_style+" lnf.slider_layer_style="+lnf.slider_layer_style;
      btinc.setIconScale(UI.icon_scaling);

      btdec <= new RepeatButton;
      btdec.initRepeatButton();
      btdec.setLayerStyle(lnf.slider_layer_style);
      btdec.setIconScale(UI.icon_scaling);
   }

   public method initScroller(float _min, _max, _value, _step) {

      if(null == lnf_colors)
         initScrollerPre();

      slider.initSlider(_min, _max, _value, _step);
      slider.setBorderSize(0);
      updateButtonActionAliases();
      btinc.setCaption("");
      btdec.setCaption("");
   }

   public virtual setLayerStyle(int _style) {
      Control::setLayerStyle(_style);
      btinc.setLayerStyle(_style);
      btdec.setLayerStyle(_style);
      slider.setLayerStyle(layer_style);
      if(LookAndFeel.STYLE_FLAT == layer_style)
         slider.setBorderSize(0);
   }

   public method setEnableBlendReplaceAlpha(boolean _bEnable) {
      slider.setEnableBlendReplaceAlpha(_bEnable);
   }

   protected method updateButtonActionAliases() {
      if(slider.isFlipped())
      {
         btinc.setProvidedActionAlias(RepeatButton.ACTION_CLICK, ACTION_DECVALUE);
         btdec.setProvidedActionAlias(RepeatButton.ACTION_CLICK, ACTION_INCVALUE);
      }
      else
      {
         btinc.setProvidedActionAlias(RepeatButton.ACTION_CLICK, ACTION_INCVALUE);
         btdec.setProvidedActionAlias(RepeatButton.ACTION_CLICK, ACTION_DECVALUE);
      }
   }

   namespace method initLayout() {
      btdec.setPadding4f(0,0,0,0);
      btinc.setPadding4f(0,0,0,0);

      slider.setPadding4f(0,0,0,0);

      setLayout(SuperBorderLayout);

      float btW = BUTTON_W;
      float btH = BUTTON_H;

      if(slider.isVertical())
      {
         btdec.setIcon(UI.GetIcon("arr_u"));
         btdec.setIconPlacement(Layout.CENTER);
         btdec.setInnerPadding4f(1,1,1,1);
         btdec.setRequiredSize2f(btW, btH);
         btdec.setAlignment(Layout.EXPANDX);

         btinc.setIcon(UI.GetIcon("arr_d"));
         btinc.setIconPlacement(Layout.CENTER);
         btinc.setInnerPadding4f(2,1,1,1);
         btinc.setRequiredSize2f(btW, btH);
         btinc.setAlignment(Layout.EXPANDX);

         slider.setAlignment(Layout.EXPAND);

         addLayer(btdec,  Layout.TOP);
         addLayer(slider, Layout.CENTER);
         addLayer(btinc,  Layout.BOTTOM);
      }
      else
      {
         btdec.setIcon(UI.GetIcon("arr_l"));
         btdec.setIconPlacement(Layout.CENTER);
         btdec.setInnerPadding4f(1,1,1,1);
         btdec.setRequiredSize2f(btW, btH);
         btdec.setAlignment(Layout.EXPANDY);

         btinc.setIcon(UI.GetIcon("arr_r"));
         btinc.setIconPlacement(Layout.CENTER);
         btinc.setInnerPadding4f(1,2,1,1);
         btinc.setRequiredSize2f(btW, btH);
         btinc.setAlignment(Layout.EXPANDY);

         slider.setAlignment(Layout.EXPAND);

         addLayer(btdec,  Layout.LEFT);
         addLayer(slider, Layout.CENTER);
         addLayer(btinc,  Layout.RIGHT);
      }

      btinc.setEnableForceMinimumSize(true, true);
      btdec.setEnableForceMinimumSize(true, true);
   }

   public virtual setLookAndFeelRef(LookAndFeel _lnf, boolean _bForce) {
      // In case scroller is not visible, yet
      Layer::setLookAndFeelRef(_lnf, _bForce);

      slider.setLookAndFeelRef(_lnf, _bForce);
      btinc.setLookAndFeelRef(_lnf, _bForce);
      btdec.setLookAndFeelRef(_lnf, _bForce);
   }

   public virtual onLookAndFeelChanged() {
      // // trace "xxx Label::onLookAndFeelChanged: caption=\""+caption+"\" this="+#(this);
      Layer::onLookAndFeelChanged();

      slider.onLookAndFeelChanged();
      btinc.onLookAndFeelChanged();
      btdec.onLookAndFeelChanged();
   }

   public method recalcKnobSize() {
      slider.recalcKnobSize();
   }

   public virtual getDefaultPreferredSizeX() : float {
      // collapse instead of expand
      return 0;
   }

   public virtual getDefaultPreferredSizeY() : float {
      // collapse instead of expand
      return 0;
   }

   // ---- delegates to "slider" instance

   public method setRange(float _min, _max) {
      slider.setRange(_min, _max);
   }

   public method setMinValue(float _min) {
      slider.setMinValue(_min);
   }

   public method getMinValue() : float {
      return slider.getMinValue();
   }

   public method setMaxValue(float _max) {
      slider.setMaxValue(_max);
   }

   public method getMaxValue() : float {
      return slider.getMaxValue();
   }

   public method setStepCoarse(float _s) {
      slider.setStepCoarse(_s);
   }

   public method getStepCoarse() : float {
      return slider.getStepCoarse();
   }

   public method getMoveDirection() : int {
      return slider.getMoveDirection();
   }

   public method setValue(float _value) {
      slider.setValue(_value);
   }

   public method getValue() : float {
      return slider.getValue();
   }

   public method incCoarse() : boolean {
      return slider.incCoarse();
   }

   public method decCoarse() : boolean {
      return slider.decCoarse();
   }

   public method validateValue() {
      slider.validateValue();
   }

   public method setRelativeKnobSize (float _visible) {
      // // trace "xxx Scroller::setRelativeKnobSize("+_visible+")";
      slider.setRelativeKnobSize(_visible);
   }

   public method setKnobSize(float _size) {
      slider.setKnobSize(_size);
   }

   public method getKnobSize() : float {
      return slider.getKnobSize();
   }

   public method setVertical(boolean _b) {
      slider.setVertical(_b);
   }

   public method setFlip(boolean _b) {
      slider.setFlip(_b);
      updateButtonActionAliases();
   }

   public method isVertical() : boolean {
      return slider.isVertical();
   }

   public method setEnableAdaptiveKnobSize(boolean _b) {
      slider.setEnableAdaptiveKnobSize(_b);
   }

   public method isKnobSizeAdaptive() : boolean {
      return slider.isKnobSizeAdaptive();
   }

   public method getIncrementButton() : RepeatButton {
      explain "Returns the Button control which is used to to scroll down/right";
      return btinc;
   }

   public method getDecrementButton() : RepeatButton {
      explain "Returns the Button control which is used to to scroll up/left";
      return btdec;
   }

   public method getSlider() : Slider/*AbstractSlider*/ {
      explain "Query the current slider control";
      return slider;
   }

   public virtual setToolTipCaption(String _toolTipCaption) {
      slider.setToolTipCaption(_toolTipCaption);
   }

   public method setEnableFlatHighContrast(boolean _bEnable) {
      slider.setEnableFlatHighContrast(_bEnable);
   }

   public virtual setBackgroundTint(int _c32) {
      slider.setBackgroundTint(_c32);
      btinc .setBackgroundTint(_c32);
      btdec .setBackgroundTint(_c32);
   }

   public virtual setForegroundTint(int _c32) {
      slider.setForegroundTint(_c32);
      btinc .setForegroundTint(_c32);
      btdec .setForegroundTint(_c32);
   }

   public virtual consumeAction(Action _ac) : boolean {
      String *name <= _ac.getActionName();

      if(@(_ac.getActionProvider()) == @(slider))
      {
         // Replace action provider
         _ac.setActionProvider(this);
      }

      switch(name) {
         case ACTION_INCVALUE:
            slider.incCoarse();
            return true;

         case ACTION_DECVALUE:
            slider.decCoarse();
            return true;
      }
      return false;
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {

      initScrollerPre();

      if(Control::beginXFMTag(_form, _attributes))
      {
         String *atname, *atval;
         StringArray *atsplit;
         float scMin = 0;
         float scMax = 1;
         float scVal = 0;
         float scStepCoarse = 0.1;
         boolean scVertical = false;
         boolean scFlip = false;
         foreach atname in _attributes
         {
            atval <= _attributes[atname];
            switch(atname.toLower())
            {
               case "minvalue":  // **DEPRECATED**
               case "min":
                  scMin = atval;
                  break;

               case "maxvalue":  // **DEPRECATED**
               case "max":
                  scMax = atval;
                  break;

               case "value":
                  scVal = atval;
                  break;

               case "step":
               case "stepcoarse":
                  scStepCoarse = atval;
                  break;

               case "vertical":
                  scVertical = atval;
                  break;

               case "flip":
                  scFlip = atval;
                  break;

               default:
                  switch(atname)
                  {
                     case ACTION_VALUECHANGED:
                     case ACTION_VALUECHANGING:
                        _form.addHandledAction(atname, FloatAction, atval);
                        break;
                  }
                  break;
            }
         }
         initScroller(scMin, scMax, scVal, scStepCoarse);
         setStepCoarse(scStepCoarse);
         setVertical(scVertical ? true : false);
         setFlip(scFlip ? true : false);
         initLayout();
      }
      return true;
   }

}
