// ----
// ----    file: (Super-)BorderLayout.tks
// ----  author: (c) 2005-2025 by Bastian Spiegel <bs@tkscript.de>
// ---- license:
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ----    info: this is part of the "ui" toolkit.
// ----
// ---- changed: 09Jun2005, 11Jun2005, 18Jun2005, 17Jul2005, 11Aug2005, 20Aug2005, 29Apr2007,
// ----          11Nov2007, 27Jun2011, 03Jul2011, 08Jul2011, 20Dec2011, 12Aug2014, 31Aug2014
// ----          15Mar2015, 20Oct2023, 22Oct2023, 27Oct2023, 31Oct2023, 12Mar2024, 19Mar2024
// ----          01Feb2025
// ----
// ----
// ----

module MSuperBorderLayout;

namespace ui;


// ====
// ==== The (Super-)BorderLayout arranges an arbitrary number of layers in a compass-like fashion:
// ==== Each layer hints the BorderLayout manager to place the layer in the NORTH, SOUTH,
// ==== WEST, EAST, resp. TOP, BOTTOM, LEFT, RIGHT or CENTER direction ("layout_hints").
// ==== The CENTER layer is resized to fit the remaining space left after all "border" layers
// ==== have been layouted with regard to their "preferredSize".
// ==== When the CENTER layer area is smaller than the CENTER layers preferredSize, the border layers
// ==== are shrunk until their "minimumSize" is reached. If the CENTER layer still does
// ==== not fit in....bad luck ;)
// ==== In case multiple layers are added in the same direction they will be stacked.
// ====
class SuperBorderLayout extends Layout {

   // ----
   // ---- Sum the minimum sizes of the child layers of _layer
   // ----
   public virtual calcMinimumSizeXOf(local Layer _layer) {
      ///print "calcMinimumSizeXOf("+#(_layer)+")";
      local Layer thisLayer <= _layer;
      local Layer c <= thisLayer.getLayoutFirstChild();
      if(null == c)
      {
         thisLayer.setMinimumSizeX(0);
         return;
      }

      local float msx=0;
      local float topMinSizeX = 0, bottomMinSizeX = 0;
      local float leftMinSize = 0, rightMinSize = 0;
      local float centerMinX = 0;
      while(null != c)
      {
         switch(c.layout_hints & Layout.DIRECTION_MASK)
         {
            case Layout.LEFT:
               msx += c.getMinimumSizePadX();
               break;

            case Layout.RIGHT:
               msx += c.getMinimumSizePadX();
               // trace "xxx Layout.RIGHT minSizePadX c="+#(c)+" c.getMinimumSizePadX="+c.getMinimumSizePadX();
               break;

            case Layout.TOP:
               if(c.getMinimumSizePadX() > topMinSizeX)
                  topMinSizeX = c.getMinimumSizePadX();
               break;

            case Layout.BOTTOM:
               if(c.getMinimumSizePadX() > bottomMinSizeX)
                  bottomMinSizeX = c.getMinimumSizePadX();
               break;

            case Layout.CENTER:
               if(c.getMinimumSizePadX() > centerMinX)
                  centerMinX = c.getMinimumSizePadX();
               // trace "xxx Layout.CENTER minSizeX c="+#(c)+" c.getMinimumSizeX="+c.getMinimumSizeX();
               // trace "xxx Layout.CENTER minSizePadX c="+#(c)+" c.getMinimumSizePadX="+c.getMinimumSizePadX();
               break;
         }
         c <= c.next;
      }

      msx += centerMinX;

      if(topMinSizeX > msx)
         msx = topMinSizeX;
      if(bottomMinSizeX > msx)
         msx = bottomMinSizeX;

      // trace "xxx thisLayer("+#(thisLayer)+".minimumSizeX="+msx;
      thisLayer.setMinimumSizeX(msx);
   }


   // ----
   // ---- Sum the preferred sizes of the child layers of _layer
   // ----
   public virtual calcPreferredSizeXOf(local Layer _layer) {
      // trace "calcPreferredSizeXOf("+#(_layer)+")";
      local Layer thisLayer <= _layer;
      local Layer c <= thisLayer.getLayoutFirstChild();
      if(null == c)
      {
         thisLayer.setPreferredSizeX(0);
         return;
      }

      local float psx = 0;
      local float topPrefSizeX = 0, bottomPrefSizeX = 0;
      local float centerX = 0, centerMinX = 0;
      while(null != c)
      {
         switch(c.layout_hints & Layout.DIRECTION_MASK)
         {
            case Layout.LEFT:
               // trace "xxx calcPreferredSizeXOf<LEFT>: this="+_layer.getDebugString()+" c="+c.getDebugString();
               psx += c.getPreferredSizePadX();
               break;

            case Layout.RIGHT:
               // trace "xxx calcPreferredSizeXOf<RIGHT>: this="+_layer.getDebugString()+" c="+c.getDebugString();
               psx += c.getPreferredSizePadX();
               break;

            case Layout.TOP:
               if(c.getPreferredSizePadX() > topPrefSizeX)
                  topPrefSizeX = c.getPreferredSizePadX();
               break;

            case Layout.BOTTOM:
               if(c.getPreferredSizePadX() > bottomPrefSizeX)
                  bottomPrefSizeX = c.getPreferredSizePadX();
               break;

            case Layout.CENTER:
               if(c.getPreferredSizePadX() > centerX)
                  centerX = c.getPreferredSizePadX();
               break;
         }
         c <= c.next;
      }

      psx += centerX;

      if(topPrefSizeX > psx)
         psx = topPrefSizeX;

      if(bottomPrefSizeX > psx)
         psx = bottomPrefSizeX;

      // trace "xxx calcPreferredSizeXOf: this="+_layer.getDebugString()+" psx="+psx;

      thisLayer.setPreferredSizeX(psx);
   }


   // ----
   // ---- Sum the minimum sizes of the child layers of _layer
   // ----
   public virtual calcMinimumSizeYOf(local Layer _layer) {
      ////print "calcMinimumSizeYOf("+#(_layer)+")";
      local Layer thisLayer <= _layer;
      local Layer c <= thisLayer.getLayoutFirstChild();
      if(null == c)
      {
         thisLayer.setMinimumSizeY(0);
         return;
      }

      local float msy = 0;
      local float topMinSize = 0, bottomMinSize = 0;
      local float centerMinY = 0;
      while(null != c)
      {
         switch(c.layout_hints & Layout.DIRECTION_MASK)
         {
            case Layout.LEFT:
               if(c.getMinimumSizePadY() > centerMinY)
                  centerMinY = c.getMinimumSizePadY();
               break;

            case Layout.RIGHT:
               if(c.getMinimumSizePadY() > centerMinY)
                  centerMinY = c.getMinimumSizePadY();
               break;

            case Layout.TOP:
               msy += c.getMinimumSizePadY();
               break;

            case Layout.BOTTOM:
               msy += c.getMinimumSizePadY();
               break;

            case Layout.CENTER:
               if(c.getMinimumSizePadY() > centerMinY)
                  centerMinY = c.getMinimumSizePadY();
               break;
         }
         c <= c.next;
      }

      msy += centerMinY;

      thisLayer.setMinimumSizeY(msy);
   }


   // ----
   // ---- Sum the preferred sizes of the child layers of _layer
   // ----
   public virtual calcPreferredSizeYOf(local Layer _layer) {
      ////print "calcPreferredSizeYOf("+#(_layer)+")";
      local Layer thisLayer <= _layer;
      local Layer c <= thisLayer.getLayoutFirstChild();
      if(null == c)
      {
         thisLayer.setPreferredSizeY(0);
         return;
      }

      local float psy = 0;
      local float centerY = 0;

      while(null != c)
      {
         switch(c.layout_hints & Layout.DIRECTION_MASK)
         {
            case Layout.LEFT:
               if(c.getPreferredSizePadY() > centerY)
                  centerY = c.getPreferredSizePadY();
               break;

            case Layout.RIGHT:
               if(c.getPreferredSizePadY() > centerY)
                  centerY = c.getPreferredSizePadY();
               break;

            case Layout.TOP:
               psy += c.getPreferredSizePadY();
               break;

            case Layout.BOTTOM:
               psy += c.getPreferredSizePadY();
               break;

            case Layout.CENTER:
               if(c.getPreferredSizePadY() > centerY)
                  centerY = c.getPreferredSizePadY();
               break;
         }
         c <= c.next;
      }

      psy += centerY;

      thisLayer.setPreferredSizeY(psy);
   }


   // ----
   // ---- Layout the child layers of _layer..
   // ----
   public virtual layoutChildLayersOf(local Layer _thisLayer, local boolean _bInvalidateSizeCaches, local boolean _bLayoutFinal) {

      // trace "xxx ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ layoutChildLayersOf "+#(_thisLayer)+"="+_thisLayer.getDebugString();

      local Layer c <= _thisLayer.getLayoutFirstChild();
      if(null == c)
         return;

      local float thisX = _thisLayer.getLayoutSizeX();
      local float thisY = _thisLayer.getLayoutSizeY();

      // trace "xxx layoutChildLayersOf: layer="+#(_layer)+" this_size=("+thisX+";"+thisY+") minSize="+_thisLayer.getMinimumSizeString();

      if( (0 == thisX) || (0 == thisY) )
      {
         if(Configuration.debugLevel > 1)
            trace "[~~~] BorderLayout: this layer has not been layouted yet (layer="+#(_thisLayer)+" parent="+#(_thisLayer.getParent())+").";
         return;
      }

      if( (thisX == Layer.DEFAULT_PREFERRED_SIZE_X) || (thisY == Layer.DEFAULT_PREFERRED_SIZE_Y) )
      {
         if(Configuration.debugLevel > 1)
            trace "[~~~] BorderLayout: this layer has not been layouted yet (layer="+#(_thisLayer)+").";
         return;
      }

      ////trace "[...] BorderLayout::layoutChildLayersOf("+#(_thisLayer)+") layoutFirstChild="+#(c);
      ////trace "[...] BorderLayout: available space="+thisX+"x"+thisY;


      // ---- first sort the child layers of thisLayer into the following 4 arrays
      local Layer *[] topLayers;    //    topLayers.empty();
      local Layer *[] bottomLayers; // bottomLayers.empty();
      local Layer *[] leftLayers;   //   leftLayers.empty();
      local Layer *[] rightLayers;  //  rightLayers.empty();

      local float topPrefSizeX=0, bottomPrefSizeX=0, topMinSizeX=0, bottomMinSizeX=0, topSize=0, bottomSize=0, leftSize=0, rightSize=0, centerX=0, centerY=0;
      local float topMinSize=0, bottomMinSize=0, leftMinSize=0, rightMinSize=0, centerMinX=0, centerMinY=0;
      local float totalX, totalY, topNewSize, bottomNewSize, leftNewSize, rightNewSize, centerNewX, centerNewY, t, tpref, tmin;
      local Layer centerLayer <= null;

      local float prefh, prefw;
      while(null != c)
      {
         c.b_layer_relayout_queued = false; // [22Oct2023]
         // // c.invalidateContentLayout(); // [28Oct2023]

         if(c.layout_weight_x > 0f)
         {
            // trace "xxx BorderLayout c="+#(c)+" layout_weight_x="+c.layout_weight_x+" thisX="+thisX;
            c.setPreferredSizeX(thisX * c.layout_weight_x);
         }

         if(c.layout_weight_y>0f)
         {
            // trace "xxx BorderLayout c="+#(c)+" layout_weight_y="+c.layout_weight_y+" thisY="+thisY;
            c.setPreferredSizeY(thisY * c.layout_weight_y);
         }

         switch(c.layout_hints & Layout.DIRECTION_MASK)
         {
            case Layout.LEFT:
               leftLayers.add(c);
               leftSize += c.getPreferredSizePadX();
               leftMinSize += c.getMinimumSizePadX();
               if(c.getPreferredSizePadY() > centerY)
                  centerY = c.getPreferredSizePadY();
               if(c.getMinimumSizePadY() > centerMinY)
                  centerMinY = c.getMinimumSizePadY();
               break;

            case Layout.RIGHT:
               rightLayers.add(c);
               rightSize += c.getPreferredSizePadX();
               rightMinSize += c.getMinimumSizePadX();
               if(c.getPreferredSizePadY() > centerY)
                  centerY = c.getPreferredSizePadY();
               if(c.getMinimumSizePadY() > centerMinY)
                  centerMinY = c.getMinimumSizePadY();
               break;

            case Layout.TOP:
               topLayers.add(c);
               topSize += c.getPreferredSizePadY();
               topMinSize += c.getMinimumSizePadY();
               if(c.getPreferredSizePadX() > topPrefSizeX)
                  topPrefSizeX = c.getPreferredSizePadX();
               if(c.getMinimumSizePadX() > topMinSizeX)
                  topMinSizeX = c.getMinimumSizePadX();
               break;

            case Layout.BOTTOM:
               bottomLayers.add(c);
               bottomSize += c.getPreferredSizePadY();
               bottomMinSize += c.getMinimumSizePadY();
               if(c.getPreferredSizePadX() > bottomPrefSizeX)
                  bottomPrefSizeX = c.getPreferredSizePadX();
               if(c.getMinimumSizePadX() > bottomMinSizeX)
                  bottomMinSizeX = c.getMinimumSizePadX();
               break;

            case Layout.CENTER:
               if(null != centerLayer)
               {
                  trace "[---] BorderLayout: more than one CENTER layer found. ignoring..(old center="+#(centerLayer)+" dupe="+#(c)+" parent="+#(c.parent)+" root="+#(c.getRoot())+")";
               }
               else
               {
                  centerLayer <= c;
                  if(c.getPreferredSizePadX() > centerX)
                     centerX = c.getPreferredSizePadX();
                  if(c.getPreferredSizePadY() > centerY)
                     centerY = c.getPreferredSizePadY();
                  if(c.getMinimumSizePadX() > centerMinX)
                     centerMinX = c.getMinimumSizePadX();
                  if(c.getMinimumSizePadY() > centerMinY)
                     centerMinY = c.getMinimumSizePadY();
               }
               break;
         }
         c <= c.next;
      }

      local float origTopSize = topSize, origBottomSize = bottomSize, origLeftSize = leftSize, origRightSize = rightSize;

      if(centerX < centerMinX)
         centerX = centerMinX;

      if(centerY < centerMinY)
         centerY = centerMinY;

//       trace "[...] BorderLayout:   numLeftLayers="+  leftLayers.numElements;
//       trace "[...] BorderLayout:  numRightLayers="+ rightLayers.numElements;
//       trace "[...] BorderLayout:    numTopLayers="+   topLayers.numElements;
//       trace "[...] BorderLayout: numBottomLayers="+bottomLayers.numElements;

      //trace "xxx BorderLayout:    topLayers="+#(topLayers);
      //trace "xxx BorderLayout: bottomLayers="+#(bottomLayers);
      //trace "xxx BorderLayout:   leftLayers="+#(leftLayers);
      //trace "xxx BorderLayout:  rightLayers="+#(rightLayers);

      // totalX=(leftMinSize+rightMinSize+centerMinX);
      // if(totalX<topMinSizeX)
      //    totalX=topMinSizeX;
      // if(totalX<bottomMinSizeX)
      //    totalX=bottomMinSizeX;

//       if(totalX>thisX)
//       {
         // xxx weight sizes against thisX and scale relative...
         //print "[---] BorderLayout: child layers minimum width ("+totalX+") exceeds layer width ("+thisX+")";
         //return;
//       }

      // totalY=(topMinSize+bottomMinSize+centerMinY);
//       if(totalY>thisY)
//       {
         // xxx weight sizes against thisY and scale relative
         //print "[---] BorderLayout: child layers minimum height ("+totalY+") exceeds layer height ("+thisY+")";
         //return;
//       }

       // trace "xxx topSize="+topSize+" bottomSize="+bottomSize+" centerY="+centerY;
       // trace "xxx topMinSize="+topMinSize+" bottomMinSize="+bottomMinSize+" centerMinY="+centerMinY;


      totalY = (topSize + bottomSize + centerY);
      local float totalMinY = (topMinSize + bottomMinSize + centerMinY);

      if(totalY > thisY)
      {
         // More space requested than available
         local float extraY = thisY - totalMinY;

         if(extraY < 0)
            extraY = 0;

         local float totalReqExtraY = (topSize - topMinSize) + (bottomSize - bottomMinSize) + (centerY - centerMinY);

         // trace "xxx extraY="+extraY+" totalReqExtraY="+totalReqExtraY+" thisY="+thisY;

         topNewSize    = topMinSize    + extraY * ((topSize    - topMinSize)    / totalReqExtraY);
         bottomNewSize = bottomMinSize + extraY * ((bottomSize - bottomMinSize) / totalReqExtraY);
         centerNewY    = centerMinY    + extraY * ((centerY    - centerMinY)    / totalReqExtraY);

         // trace "xxx => topNewSize="+topNewSize+" bottomNewSize="+bottomNewSize+" centerNewY="+centerNewY;

         ///trace "[...] BorderLayout: topMinSize="+topMinSize+" bottomMinSize="+bottomMinSize+" centerMinY="+centerMinY+" totalY="+totalY+" thisY="+thisY;
         ///trace "[...] BorderLayout: topNewSize="+topNewSize+" bottomNewSize="+bottomNewSize+" centerNewY="+centerNewY+" totalY="+totalY+" thisY="+thisY;
      }
      else
      {
         // More space available than requested => expand center Y
         topNewSize    = topSize;
         bottomNewSize = bottomSize;
         centerNewY    = (thisY - topNewSize - bottomNewSize);
      }

      totalX = (leftSize + rightSize + centerX);
      local float totalMinX = (leftMinSize + rightMinSize + centerMinX);

      if(totalX > thisX)
      {
         // More space requested than available
         local float extraX = thisX - totalMinX;

         if(extraX < 0)
            extraX = 0;

         local float totalReqExtraX = (leftSize-leftMinSize) + (rightSize - rightMinSize) + (centerX - centerMinX);

         leftNewSize  = leftMinSize  + extraX * ((leftSize  - leftMinSize)  / totalReqExtraX);
         rightNewSize = rightMinSize + extraX * ((rightSize - rightMinSize) / totalReqExtraX);
         centerNewX   = centerMinX   + extraX * ((centerX   - centerMinX)   / totalReqExtraX);

         //trace "[...] BorderLayout: leftMinSize="+leftMinSize+" rightMinSize="+rightMinSize+" centerMinX="+centerMinX+" totalX="+totalX+" thisX="+thisX;
         //trace "[...] BorderLayout: leftNewSize="+leftNewSize+" rightNewSize="+rightNewSize+" centerNewX="+centerNewX+" totalX="+totalX+" thisX="+thisX;

      }
      else
      {
         // More space available than requested => expand center X
         leftNewSize  = leftSize;
         rightNewSize = rightSize;
         centerNewX   = (thisX - leftNewSize - rightNewSize);
      }

      // trace "xxx thisX="+thisX+" sumNewSize="+(leftNewSize+rightNewSize+centerNewX);
      // trace "xxx thisY="+thisY+" sumNewSize="+(topNewSize+bottomNewSize+centerNewY);

      // // if(topNewSize < 0)
      // //    die "oops topNewSize="+topNewSize;

      // // if(centerNewY < 0)
      // //    die "oops centerNewY="+centerNewY;

      // ---- now layout the left / right / top / bottom layer arrays
      //                          <minsize>       <availSize>    <posY>      <sizeY>     <startX>               <dir>
      layoutLayersH(leftLayers,   leftMinSize,    leftNewSize,   topNewSize, centerNewY, leftNewSize,           -1);
      layoutLayersH(rightLayers,  rightMinSize,   rightNewSize,  topNewSize, centerNewY, leftNewSize+centerNewX, 1);
      //                          <minsize>       <availSize>    <posX>      <sizeX>     <startY>               <dir>
      layoutLayersV(topLayers,    topMinSize,     topNewSize,    0,          thisX,      topNewSize,            -1);
      layoutLayersV(bottomLayers, bottomMinSize,  bottomNewSize, 0,          thisX,      topNewSize+centerNewY,  1);

      // ---- layout center layer
      if(null != centerLayer)
      {
         local float cpsx;
         local float cpsy;
         local float ctrx, ctry, csx, csy;

         cpsx = centerLayer.getPreferredSizePadX();
         cpsy = centerLayer.getPreferredSizePadY();

         // if(centerLayer.getLayout() instanceof FlowLayout)
         //    trace "xxx SuperBorderLayout: centerLayer FlowLayout cpsx="+cpsx+" centerNewX="+centerNewX;

         if(cpsx > 0)
         {
            if(cpsx < centerNewX)
            {
               // ---- layer requires less horizontal space than available
               // ---- check alignment hints
               switch(centerLayer.alignment & Layout.HORIZONTAL)
               {
                  case Layout.LEFT:
                     ctrx = 0;
                     csx  = cpsx;
                     break;

                  case Layout.EXPANDX:
                     ctrx = 0;
                     csx  = centerNewX;
                     break;

                  default:
                  case Layout.CENTERX:
                     ctrx = (centerNewX - cpsx) * 0.5;
                     csx  = cpsx;
                     break;

                  case Layout.RIGHT:
                     ctrx = centerNewX - cpsx;
                     csx  = cpsx;
                     break;
               }
            }
            else
            {
               ctrx = 0;
               csx  = centerNewX;
            }
         }
         else
         {
            ctrx = 0;
            csx = 0;
         }

         // if(centerLayer.getLayout() instanceof FlowLayout)
         //    trace "xxx SuperBorderLayout: centerLayer FlowLayout cpsy="+cpsy+" centerNewY="+centerNewY;

         if(cpsy > 0)
         {
            if(cpsy < centerNewY)
            {
               // ---- layer requires less vertical space than available
               // ---- check alignment hints
               switch(centerLayer.alignment & Layout.VERTICAL)
               {
                  case Layout.TOP:
                     ctry = 0;
                     csy  = cpsy;
                     break;

                  case Layout.BOTTOM:
                     ctry = centerNewY - cpsy;
                     csy  = cpsy;
                     break;

                  case Layout.EXPANDY:
                     ctry = 0;
                     csy  = centerNewY;
                     break;

                  default:
                  case Layout.CENTERY:
                     ctry = (centerNewY - cpsy) * 0.5;
                     csy  = cpsy;
                     break;
               }
            }
            else
            {
               ctry = 0;
               csy  = centerNewY;
            }
         }
         else
         {
            ctry = 0;
            csy = 0;
         }

         centerLayer.setPosition2f(leftNewSize + ctrx + centerLayer.pad_left,
                                   topNewSize  + ctry + centerLayer.pad_top
                                   );
         centerLayer.setSize2f(csx - centerLayer.pad_left - centerLayer.pad_right,
                               csy - centerLayer.pad_top  - centerLayer.pad_bottom
                               );


         // trace "xxx BorderLayout: centerLayer position=("+centerLayer.position_x+"; "+centerLayer.position_y+") size=("+centerLayer.size_x+"; "+centerLayer.size_y+") prefSize=("+centerLayer.getPreferredSizePadX()+";"+centerLayer.getPreferredSizePadY()+") minSize=("+centerLayer.getMinimumSizePadX()+";"+centerLayer.getMinimumSizePadY()+")";
      }

      if(_bLayoutFinal)
         applyCommonBaselineAdjustmentsLR(_thisLayer,
                                          leftLayers,
                                          rightLayers,
                                          centerLayer,
                                          centerNewY/*sizeAvail*/
                                          );


      // ---- All layers have been layouted by now, now layout their child layers
      // ---- This section may be called recursively so we may not refer to the variables above
      local Layer ch <= _thisLayer.getLayoutFirstChild();
      do
      {
         // trace "xxx BorderLayout: this="+#(thisLayer)+" ch="+#(ch)+" thisSize="+_thisLayer.getSizeX()+";"+_thisLayer.getSizeY();
         ch.layoutHierarchy(_bInvalidateSizeCaches, _bLayoutFinal);
         ch <= ch.next;
      }
      while(null != ch);

      if(_bLayoutFinal)
      {
         // Recursively move composite layers to common baseline
         //  (note) baseline justifications _within_ composite layers have already been done
         // trace "xxx ------------- shift  SuperBorderLayout: call thisLayer.layoutApplyCompositeBaselineAdjustments() #childLayers="+thisLayer.getNumChildLayers()+" --------------";
         _thisLayer.layoutApplyCompositeBaselineAdjustments();
      }
   }

   private findCommonBaseline(local Layer _parent, local PointerArray _layers, local float _maxBaselineY) : float {
      local Layer *c;
      foreach c in _layers
      {
         if(c.alignment & Layout.BASELINEY)
         {
            // // baselineY = c.layoutFindEffectiveBaselineY();
            local float baselineY = c.getBaselineY();
            if(baselineY > 0.0f)
            {
               if(_parent.getDebug())
                  trace "xxx shift  this="+#(_parent)+" find c="+#(c)+" c.id="+c.layer_id+" c.caption=\""+c.getDisplayedText()+"\" py="+c.getPositionY()+" baselineY="+baselineY+" oldMaxBaseLineY="+_maxBaselineY;
               baselineY += c.getPositionY();
               if(baselineY > _maxBaselineY)
                  _maxBaselineY = baselineY;
            }
         }
      }
      return _maxBaselineY;
   }

   private applyCommonBaselineAdjustments(local PointerArray _layers, local float _maxBaselineY, local float _sizeAvail) {
      // Shift layers vertically to common baseline (e.g. mixed font sizes)
      local Layer *c;
      foreach c in _layers
         c.layoutApplyCommonBaselineAdjustments(_maxBaselineY, _sizeAvail);
   }

   private method applyCommonBaselineAdjustmentsLR(local Layer        _thisLayer,
                                                   local PointerArray _layersLeft,
                                                   local PointerArray _layersRight,
                                                   local Layer        _centerLayer,
                                                   local float        _sizeAvail
                                                   ) {
      local float maxBaselineY = findCommonBaseline(_thisLayer, _layersLeft, 0);
      maxBaselineY = findCommonBaseline(_thisLayer, _layersRight, maxBaselineY);

      if(null != _centerLayer && (_centerLayer.alignment & Layout.BASELINEY))
         maxBaselineY = mathMaxf(maxBaselineY, _centerLayer.getBaselineY()+_centerLayer.getPositionY());

      // Remember baseline for Layer::layoutApplyCompositeBaselineAdjustments()
      if(_thisLayer.getDebug() && Layer.b_debug_layout)
         trace "xxx shift  this="+#(_thisLayer)+" this.id="+_thisLayer.layer_id+" update cached_composite_effective_baseline_y to maxBaselineY="+maxBaselineY;
      _thisLayer.cached_composite_effective_baseline_y = maxBaselineY;

      if(maxBaselineY > 0.0f)
      {
         applyCommonBaselineAdjustments(_layersLeft,  maxBaselineY, _sizeAvail);
         applyCommonBaselineAdjustments(_layersRight, maxBaselineY, _sizeAvail);
         if(null != _centerLayer)
            _centerLayer.layoutApplyCommonBaselineAdjustments(maxBaselineY, _sizeAvail);
      }
   }

   private method layoutLayersH(local PointerArray _layers, local float _minSize, local float _size, _posY, _sizeY, _cp, _dir) {

      local float availSize = _size;
      local float availDynSize = _size;

      local float sx;
      local float prefSizeX;
      local float minSizeX;

      // Accumulate preferred sizes and calculate space available for (dynamic) layouting (=> subtract padding)
      local float totalPrefSizeX = 0.0f;
      local Layer *c;
      foreach c in _layers
      {
         c.tmp_preferred_size_x = c.getPreferredSizeX();
         // trace "xxx c.getPreferredSizeX="+c.getPreferredSizeX()+" c.getMinimumSizeX()="+c.getMinimumSizeX();
         // trace "xxx layoutLayersH: c="+c.getDebugString()+" minSize="+_minSize+" newSize="+_size;
         totalPrefSizeX += c.tmp_preferred_size_x;
         availDynSize -= c.pad_left + c.pad_right;
      }

      // trace "xxx layoutLayersH: minSize="+_minSize+" size="+_size+" totalPrefSizeX="+totalPrefSizeX+" availDynSize="+availDynSize;

      // Apply minimum size constraints => may reduce space available for dynamic layouting even further
      foreach c in _layers
      {
         if(!c.b_lock_size_x)
         {
            prefSizeX = c.tmp_preferred_size_x;
            minSizeX = c.getMinimumSizeX();
            sx = availDynSize * ( prefSizeX / totalPrefSizeX );
         }
         else
         {
            sx = c.size_x;
            prefSizeX = sx;
            minSizeX = sx;
         }

         // trace "xxx availSize="+availSize+" availDynSize="+availDynSize+" prefSizeX="+prefSizeX+" minSizeX="+minSizeX+" sx="+sx;

         if(sx < minSizeX)
         {
            sx = minSizeX;
            totalPrefSizeX -= prefSizeX;
            availDynSize -= sx;
            c.tmp_preferred_size_x = 0;
            c.setSizeX(sx);
         }
      }

      foreach c in _layers
      {
         local float sy = c.getPreferredSizeY();

         if(!c.b_lock_size_x)
         {
            prefSizeX = c.tmp_preferred_size_x;

            if(prefSizeX > 0)
            {
               // Distribute extra space
               sx = availDynSize * ( prefSizeX / totalPrefSizeX );
            }
            else
            {
               // Minsize constraint was applied, use size calculated in previous pass
               sx = c.getSizeX();
            }
         }
         else
         {
            sx = c.size_x;
            prefSizeX = sx;
         }

         // trace "xxx availSize="+availSize+" availDynSize="+availDynSize+" prefSizeX="+prefSizeX+" sx="+sx;

         if(_dir < 0)
         {
            _cp -= sx + c.pad_left + c.pad_right;
         }

         local float px = c.pad_left;
         local float py = c.pad_top;

         local float pspy = c.getPreferredSizePadY();

         // if(c.getDebug())
         //    trace "xxx layout pspy="+pspy+" avail="+_sizeY+" minSizeY="+c.getMinimumSizeY();

         if(pspy > 0)
         {
            if(pspy < _sizeY)
            {
               // Layer requires less vertical space than available
               switch(c.alignment & Layout.VERTICAL)
               {
                  case Layout.CENTERY:
                     py = (_sizeY - sy - c.pad_top - c.pad_bottom) * 0.5 + c.pad_top; // 31Aug2014: +c.pad_top
                     break;

                  case Layout.TOP:
                     break;

                  case Layout.BOTTOM:
                     py = _sizeY - sy - c.pad_bottom;
                     break;

                  default:
                     if(c.alignment & Layout.EXPANDY)
                     {
                        py = c.pad_top;
                        sy = _sizeY - c.pad_top - c.pad_bottom;
                     }
                     break;
               }
            }
            else
            {
               // Layer requests more vertical space than available
               sy = _sizeY - c.pad_top - c.pad_bottom;
            }
         }
         else
         {
            sx = 0;
            sy = 0;
         }

         c.setPosition2f(_cp + px, py + _posY);
         c.setSize2f(sx, sy);

         if(_dir > 0)
         {
            _cp += sx + c.pad_left + c.pad_right;
         }

         if(prefSizeX > 0)
         {
            totalPrefSizeX -= prefSizeX;
            availDynSize -= sx;
         }

         availSize -= sx + c.pad_left + c.pad_right;

         // Next layer
      }

   }

   private method layoutLayersV(local PointerArray _layers, local float _minSize, local float _size, _posX, _sizeX, _cp, _dir) {

      local float sy;
      local float prefSizeY;
      local float minSizeY;

      local float availSize = _size;
      local float availDynSize = _size;

      // Accumulate preferred sizes and calculate space available for (dynamic) layouting (=> subtract padding)
      local float totalPrefSizeY = 0.0f;
      local Layer *c;
      foreach c in _layers
      {
         if(!c.b_lock_size_y)
         {
            c.tmp_preferred_size_y = c.getPreferredSizeY();
            // trace "xxx layoutLayersV: c="+c.getDebugString()+" minSize="+_minSize+" newSize="+_size;
            // trace "xxx c.getPreferredSizeY="+c.getPreferredSizeY()+" c.getMinimumSizeY()="+c.getMinimumSizeY();
         }
         else
         {
            c.tmp_preferred_size_y = c.size_y;
         }
         totalPrefSizeY += c.tmp_preferred_size_y;
         availDynSize -= c.pad_top + c.pad_bottom;
      }

      // trace "xxx layoutLayersH: minSize="+_minSize+" size="+_size+" totalPrefSizeY="+totalPrefSizeY+" availDynSize="+availDynSize;

      // Apply minimum size constraints => may reduce space available for dynamic layouting even further
      foreach c in _layers
      {
         if(!c.b_lock_size_y)
         {
            prefSizeY = c.tmp_preferred_size_y;
            minSizeY = c.getMinimumSizeY();
            sy = availDynSize * ( prefSizeY / totalPrefSizeY );
         }
         else
         {
            sy = c.size_y;
            prefSizeY = sy;
            minSizeY = sy;
         }

         // trace "xxx availSize="+availSize+" availDynSize="+availDynSize+" prefSizeY="+prefSizeY+" minSizeY="+minSizeY+" sy="+sy;

         if(sy < minSizeY)
         {
            sy = minSizeY;
            totalPrefSizeY -= prefSizeY;
            availDynSize -= sy;
            c.tmp_preferred_size_y = 0;
            c.setSizeY(sy);
         }
      }

      foreach c in _layers
      {
         local float sx = c.getPreferredSizeX();

         if(!c.b_lock_size_y)
         {
            prefSizeY = c.tmp_preferred_size_y;

            if(prefSizeY > 0)
            {
               // Distribute extra space
               sy = availDynSize * ( prefSizeY / totalPrefSizeY );
            }
            else
            {
               // Minsize constraint was applied, use size calculated in previous pass
               sy = c.getSizeY();
            }
         }
         else
         {
            sy = c.size_y;
            prefSizeY = sy;
         }

         // trace "xxx availSize="+availSize+" availDynSize="+availDynSize+" prefSizeY="+prefSizeY+" sy="+sy;

         if(_dir < 0)
         {
            _cp -= sy + c.pad_top + c.pad_bottom;
         }

         local float px = c.pad_left;
         local float py = c.pad_top;

         local float pspx = c.getPreferredSizePadX();

         if(pspx > 0)
         {
            if(pspx < _sizeX)
            {
               // Layer requires less horizontal space than available
               switch(c.alignment & Layout.HORIZONTAL)
               {
                  case Layout.CENTERX:
                     px = (_sizeX - sx - c.pad_left - c.pad_right) * 0.5;
                     break;

                  case Layout.LEFT:
                     break;

                  case Layout.RIGHT:
                     px = _sizeX - sx - c.pad_right;
                     break;

                  default:
                     if(c.alignment & Layout.EXPANDX)
                     {
                        sx = _sizeX - c.pad_left - c.pad_right;
                     }
                     break;
               }
            }
            else
            {
               // Layer requests more vertical space than available
               sx = _sizeX - c.pad_left - c.pad_right;
            }
         }
         else
         {
            sx = 0;
            sy = 0;
         }

         c.setPosition2f(px + _posX, _cp + py);
         c.setSize2f(sx, sy);

         if(_dir > 0)
         {
            _cp += sy + c.pad_top + c.pad_bottom;
         }

         if(prefSizeY > 0)
         {
            totalPrefSizeY -= prefSizeY;
            availDynSize -= sy;
         }

         availSize -= sy + c.pad_top + c.pad_bottom;

         // Next layer
      }
   }

}

class BorderLayout : SuperBorderLayout { } // shortcut for use in .xfm files
