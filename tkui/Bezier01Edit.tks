// ----
// ---- file   : Bezier01Edit.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- created: 12Jun2021
// ---- changed: 13Jun2021, 03Oct2023, 10Sep2025, 11Sep2025, 13Sep2025, 14Sep2025, 17Sep2025
// ----
// ----
// ----

module MBezier01Edit;

namespace ui;


// <class.png>
class BezierLUT01 {
   FloatArray lut;
   int lut_sz;

   init(int _size) {
      lut.allocAndFill(_size, 0);
      lut_sz = _size;
   }

   update(float _ctlX, float _ctlY) {
      float cx2 = 2*_ctlX;
      float cy2 = 2*_ctlY;
      float omcx2 = 1.0 - cx2;
      float omcy2 = 1.0 - cy2;

      int over = 2;
      float t = 0;
      float tStep = 1.0 / (over * lut_sz);
      // trace "xxx lut.numElements="+lut.numElements;
      // lut.fill(0);//xxxx
      // // loop((lut_sz+1) * over)
      loop(lut_sz * over)
      {
         float t2 = t*t;
         float mx = t2*omcx2 + t*cx2;
         float my = t2*omcy2 + t*cy2;

         // // lut[int(mx * lut_sz + 0.5)] = my;
         lut[int(mx * lut_sz)] = my;

         t += tStep;
      }
      lut[0] = 0.0;
      lut[lut_sz-1] = 1.0;
      // trace "xxx lut.get(0)="+get(0);
      // trace "xxx lut.get(1)="+get(1);
   }

   // get(float _t) {
   //    return lut.winLinear(_t * (lut_sz-1));
   // }
}


// <class.png>
class Bezier01Edit extends Control {

   define int LUT_SIZE = 4096;
   define int CTL_RES  = 16;  // total size = CTL_RES*CTL_RES*LUT_SIZE floats (4MB for sz=4096 res=16)
   define float EXP_RANGE = 7.0;

   define String ACTION_PARAMS_CHANGED;

   static FloatArray *[] luts;
   static int lut_sz;
   static int ctl_res;

   float ctl_x;
   float ctl_y;
   float ctl_exp;
   boolean b_flip;

   protected float drag_start_x;
   protected float drag_start_y;
   protected float drag_start_ctl_x;
   protected float drag_start_ctl_y;
   protected float drag_start_ctl_exp;

   protected boolean b_pressed;

   define int DRAG_NONE   = 0;
   define int DRAG_CTL    = 1;
   define int DRAG_EXP    = 2;
   define int DRAG_PRESET = 3;
   protected int drag_mode;

   protected PopupMenu *pm_context;

   protected boolean b_draw_border;


   public static New() : Bezier01Edit {
      local Bezier01Edit be;
      be.initLayer();
      be.initBezier01Edit();
      return deref be;
   }

   public static LazyInitializeLUTs() {
      if(luts.isEmpty())
      {
         local BezierLUT01 lut;
         lut.init(LUT_SIZE);
         lut_sz  = LUT_SIZE;
         ctl_res = CTL_RES;

         float ctlStep = 1.0 / (ctl_res - 1);
         float ctlY = 0.0;
         loop(ctl_res)
         {
            float ctlX = 0.0;
            loop(ctl_res)
            {
               FloatArray fa <= new FloatArray;
               luts.add(#(deref fa));
               // trace "xxx ctlX="+ctlX+" ctlY="+ctlY;
               lut.update(ctlX, ctlY);
               fa = lut.lut;
               // trace "xxx fa="+fa;
               ctlX += ctlStep;
            }

            ctlY += ctlStep;
         }
      }
   }

   public static GetLUT(float _ctlX, float _ctlY) : FloatArray {
      int iCtlX = mathClampi(ctl_res * _ctlX, 0, ctl_res-1);
      int iCtlY = mathClampi(ctl_res * _ctlY, 0, ctl_res-1);
      // trace "xxx iCtlX="+iCtlX+" iCtlY="+iCtlY;
      FloatArray lut <= luts.get(iCtlY * ctl_res + iCtlX);
      return lut;
   }

   public method initBezier01Edit() {
      b_editable = true;
      b_draw_border = true;

      resetParams();

      LazyInitializeLUTs();
   }

   public method setEnableDrawBorder(boolean _bEnable) {
      b_draw_border = _bEnable;
   }

   public virtual onLookAndFeelChanged() {
      Layer::onLookAndFeelChanged();
   }

   public virtual getProvidedActionNames() : StringArray {
      return [ACTION_PARAMS_CHANGED
              ];
   }

   protected method provideParamsChanged() {
      provideAction(Action.New(getProvidedActionAlias(ACTION_PARAMS_CHANGED), this));
   }

   public method resetParams() {
      ctl_x   = 0.5;
      ctl_y   = 0.5;
      ctl_exp = 0.0f;
      b_flip  = false;
      redraw();
   }

   public method toggleFlip() {
      b_flip = !b_flip;
      provideParamsChanged();
      redraw();
   }

   public method loadPreset(int _idx) {
      switch(_idx)
      {
         case 0:
            ctl_x   = 0.5;
            ctl_y   = 0.5;
            ctl_exp = 0.0f;
            // b_flip  = false;
            break;


         case 1:
            ctl_x   = 0.145833;
            ctl_y   = 1;
            ctl_exp = 0.85;
            // b_flip  = false;
            break;

         case 2:
            ctl_x   = 0.18125;
            ctl_y   = 0.9;
            ctl_exp = 0.0f;
            // b_flip  = false;
            break;

         case 3:
            ctl_x   = 0.484375;
            ctl_y   = 0.72;
            ctl_exp = -1.4f;
            // b_flip  = false;
            break;

         case 4:
            ctl_x   = 0.3125;
            ctl_y   = 0.260417;
            ctl_exp = -1.35;
            // b_flip  = true;
            break;

         case 5:
            ctl_x   = 0.940625;
            ctl_y   = 0.0;
            ctl_exp = -1.85f;
            // b_flip  = false;
            break;

         case 6:
            ctl_x   = 0.38125;
            ctl_y   = 1.0;
            ctl_exp = 1.85f;
            // b_flip  = false;
            break;

         case 7:
            ctl_x   = 0.489583;
            ctl_y   = 0.739583;
            ctl_exp = 1.6;
            // b_flip  = false;
            break;

         case 8:
            ctl_x   = 0.75;
            ctl_y   = 0.22;
            ctl_exp = 0.0f;
            // b_flip  = false;
            break;

         case 9:
            ctl_x   = 0.946875;
            ctl_y   = 0.415;
            ctl_exp = 0.65f;
            // b_flip  = false;
            break;
      }

      provideParamsChanged();
      redraw();
   }

   protected method showPopupMenu() {

      PopupMenuButton *pmb;

      pm_context <= PopupMenu.New(this);

      pmb <= pm_context.addDefaultButton("Reset", "reset");
      pmb.setAccelerators("r", "LMB-dblclick");

      pm_context.addSeparator();
      pmb <= pm_context.addCheckButton("Flip", b_flip, "flip");
      pmb.setAccelerators("f", "WHEEL");

      pm_context.addSeparator();
      pmb <= pm_context.addDefaultButton("Load Preset 1", "preset_1");
      pmb.setAccelerators("1", "");
      pmb <= pm_context.addDefaultButton("Load Preset 2", "preset_2");
      pmb.setAccelerators("2", "");
      pmb <= pm_context.addDefaultButton("Load Preset 3", "preset_3");
      pmb.setAccelerators("3", "");
      pmb <= pm_context.addDefaultButton("Load Preset 4", "preset_4");
      pmb.setAccelerators("4", "");
      pmb <= pm_context.addDefaultButton("Load Preset 5", "preset_5");
      pmb.setAccelerators("5", "");
      pmb <= pm_context.addDefaultButton("Load Preset 6", "preset_6");
      pmb.setAccelerators("6", "");
      pmb <= pm_context.addDefaultButton("Load Preset 7", "preset_7");
      pmb.setAccelerators("7", "");
      pmb <= pm_context.addDefaultButton("Load Preset 8", "preset_8");
      pmb.setAccelerators("8", "");
      pmb <= pm_context.addDefaultButton("Load Preset 9", "preset_9");
      pmb.setAccelerators("9", "");

      pm_context.showNearMouse(-6, -6);

      hideToolTip();
      cancelToolTipTimer();
   }

   public virtual onKey(Key _k) : boolean {
      if(_k.modNone())
      {
         switch(_k.pressed)
         {
            case 'f':
               toggleFlip();
               return true;

            case 'r':
               resetParams();
               provideParamsChanged();
               return true;

               // Presets
            case '1':
               loadPreset(1);
               return true;

            case '2':
               loadPreset(2);
               return true;

            case '3':
               loadPreset(3);
               return true;

            case '4':
               loadPreset(4);
               return true;

            case '5':
               loadPreset(5);
               return true;

            case '6':
               loadPreset(6);
               return true;

            case '7':
               loadPreset(7);
               return true;

            case '8':
               loadPreset(8);
               return true;

            case '9':
               loadPreset(9);
               return true;

            case 'd':
               trace "[dbg] params:\nctl_x   = "+ctl_x+";\nctl_y   = "+ctl_y+";\nctl_exp = "+ctl_exp+";\nb_flip  = "+b_flip+";\n";
               return true;
         }
      }
      return Control::onKey(_k);
   }

   public virtual onMouseClick(MouseEvent _ev) : boolean {
      UI.SetKeyboardFocus(this);
   }

   public virtual onMouse(MouseEvent _ev) : boolean {
      if(_ev.wheelUp() || _ev.wheelDown())
      {
         toggleFlip();
         return true;
      }
   }

   public virtual onMouseDoubleClick(MouseEvent _ev) : boolean {
      if(_ev.isLeftButton())
      {
         grabKeyboardFocus();
         resetParams();
         provideParamsChanged();
         return true;
      }
      return false;
   }

   public virtual onMouseBeginDrag(MouseEvent _dragStart, MouseEvent _ev) : boolean {
      drag_start_x = _dragStart.mouse_rel_x;
      drag_start_y = _dragStart.mouse_rel_y;

      if(_ev.isLeftButtonDown() && _ev.isRightButtonDown())
      {
         drag_mode = DRAG_PRESET;
         drag_start_ctl_y = ctl_y;
         b_pressed = true;
         grabKeyboardFocus();
         return true;
      }
      if(_ev.isRightButtonDown())
      {
         drag_mode = DRAG_EXP;
         drag_start_ctl_exp = ctl_exp;
         b_pressed = true;
         grabKeyboardFocus();
         return true;
      }
      else if(_ev.isLeftButtonDown())
      {
         drag_mode = DRAG_CTL;
         drag_start_ctl_x = ctl_x;
         drag_start_ctl_y = ctl_y;
         b_pressed = true;
         grabKeyboardFocus();
         return true;
      }
      return false;
   }

   public virtual onMouseDrag(MouseEvent _lastEv, MouseEvent _ev) : boolean {
      float relX = _ev.mouse_rel_x - drag_start_x;
      float relY = _ev.mouse_rel_y - drag_start_y;

      float sx = getSizeX();
      float sy = getSizeY();

      if(b_flip)
         relY = -relY;

      if(DRAG_EXP == drag_mode)
      {
         ctl_exp = mathClampf(drag_start_ctl_exp + relY*0.05, -EXP_RANGE, EXP_RANGE);
         // Global.Debug2("ctl_exp="+ctl_exp);
         provideParamsChanged();
         redraw();
      }
      else if(DRAG_CTL == drag_mode)
      {
         if(b_flip)
            relX = -relX;
         ctl_x = mathClampf(drag_start_ctl_x + relX*(1.0 / sx), 0, 1);
         ctl_y = mathClampf(drag_start_ctl_y - relY*(1.0 / sy), 0, 1);
         // Global.Debug2("ctl=("+ctl_x+";"+ctl_y+")");
         provideParamsChanged();
         redraw();
      }
      else if(DRAG_PRESET == drag_mode)
      {
         int pst = (relY/8) % 10;
         if(pst < 0)
            pst = -pst;
         loadPreset(pst);
      }
      return true;
   }

   public virtual onMouseEndDrag(MouseEvent _ev) {
      b_pressed = false;
      redraw();
   }

   public virtual onMouseCancelDrag(MouseEvent _ev) {
      b_pressed = false;
      if(DRAG_EXP == drag_mode)
      {
         ctl_exp = drag_start_ctl_exp;
         provideParamsChanged();
      }
      else if(DRAG_CTL == drag_mode)
      {
         ctl_x = drag_start_ctl_x;
         ctl_y = drag_start_ctl_y;
         provideParamsChanged();
      }
      redraw();
   }

   public virtual onMouseHold(MouseEvent _startEv) : boolean {
      if(_startEv.isRightButtonDown())
      {
         showPopupMenu();
         return true;
      }
      return false;
   }

   public virtual onDraw() {

      float sx = getSizeX();
      float sy = getSizeY();

      Point2f abspos;
      calcAbsolutePositionFBO(abspos);
      sdvg_PushScissor(abspos.x+0.5, abspos.y+0.5, sx+0.5, sy+0.5);
      sdvg_EnableScissor();

      if(b_draw_border)
         UIRenderer.PushViewport(abspos.x+2, abspos.y+2, sx-4, sy-4);
      else
         UIRenderer.PushViewport(abspos.x, abspos.y, sx, sy);

      UIRenderer.PushProjMatrix();
      UIRenderer.ProjInitOrtho(1,1);

      UIRenderer.PushModelMatrix();
      UIRenderer.ModelInitIdentity();

      if(UIRenderer.b_gl_attrib_stack)
         glPushAttrib(GL_ALL_ATTRIB_BITS);  // b_gl_attrib_stack

      UIRenderer.EnableBlending();
      UIRenderer.SetLineWidth(1.0f);

      glClearColor(0.1, 0.1, 0.125, 1);
      glClear(GL_COLOR_BUFFER_BIT);

      UIRenderer.DrawLineAA(-1.0f, 0.0f,
                            1.0f, 0.0f,
                            #FF333340
                            );

      UIRenderer.DrawLineAA(0.0f, -1.0f,
                            0.0f, 1.0f,
                            #FF333340
                            );

      // Render curve
      float t = 0;
      float cx;
      float cy;
      float tStep = 1.0f / (sx-1);

      if(b_pressed)
         UIRenderer.SetColor3f(0.65,0.9, 0.65);
      else
         UIRenderer.SetColor3f(0.85,0.85,0.9);

      UIRenderer.EnableBlending();

      FloatArray lut <= GetLUT(ctl_x, ctl_y);

      UIRenderer.BeginLineStripAA(sx + 1);
      UIRenderer.Vertex2f(-1.0f, 0.0f);
      loop(sx)
      {
         cy = lut.winLinear( (b_flip ? (1.0 - t) : t) * (lut_sz-1));
         cy = mathLogLinExpf(cy, ctl_exp);

         if(b_flip)
            cy = 1.0 - cy;

         cx = t * 2.0 - 1.0;
         cy = cy * 2.0 - 1.0;

         UIRenderer.Vertex2f(cx, cy);

         t += tStep;
      }
      UIRenderer.End();

      // Restore previous GL state
      UIRenderer.DisableBlending();

      if(UIRenderer.b_gl_attrib_stack)
         glPopAttrib();  // b_gl_attrib_stack

      UIRenderer.PopProjMatrix();

      UIRenderer.PopModelMatrix();

      sdvg_PopScissor();
      sdvg_DisableScissor();

      UIRenderer.PopViewport();

      if(b_draw_border)
         UIRenderer.DrawDefaultSunkenBorder(0, 0, sx, sy);
   }

   public virtual consumeAction(Action _action) : boolean {

      if(@(_action.getActionProvider()) == @(pm_context))
      {
         String acName = _action.getActionName();
         grabKeyboardFocus();
         pm_context <= null;
         switch(acName)
         {
            case "reset":
               restartToolTipTimer();
               resetParams();
               provideParamsChanged();
               return true;

            case "flip":
               toggleFlip();
               return true;

            case "preset_1":
               loadPreset(1);
               return true;

            case "preset_2":
               loadPreset(2);
               return true;

            case "preset_3":
               loadPreset(3);
               return true;

            case "preset_4":
               loadPreset(4);
               return true;

            case "preset_5":
               loadPreset(5);
               return true;

            case "preset_6":
               loadPreset(6);
               return true;

            case "preset_7":
               loadPreset(7);
               return true;

            case "preset_8":
               loadPreset(8);
               return true;

            case "preset_9":
               loadPreset(9);
               return true;
         }
      }
      return Control::consumeAction(_action);
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {

      if(Control::beginXFMTag(_form, _attributes))
      {
         initBezier01Edit();

         String *atname, *atval, atvaluc;
         StringArray *atsplit;
         String *atsplitv;

         foreach atname in _attributes
         {
            atval <= _attributes[atname];
            switch(atname.toLower())
            {
               case "drawborder":
                  setEnableDrawBorder(int(atval));
                  break;
            }
         }

         return true;
      }
   }

}
