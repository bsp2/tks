// ----
// ---- file   : RepeatButton.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2005-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- created: 10Aug2005
// ---- changed: 05May2007, 14Apr2008, 01Feb2009, 31May2009, 14Jun2009, 09Jan2010, 22Apr2010,
// ----          10Feb2018, 16Feb2018, 27Dec2020, 08Oct2023, 01Nov2023, 22Mar2024, 04Oct2024
// ----          05Oct2024
// ----
// ----
// ----

module MRepeatButton;

namespace ui;


class RepeatButton extends Label, ActionProvider {

   define String ACTION_CLICK    = "onClick";     // LMB
   define String ACTION_CLICKALT = "onClickAlt";  // RMB

   protected boolean b_pressed;
   protected boolean b_alt;

   define String TA_REPEAT;
   protected TimerAction ta_repeat;
   protected int repeat_count;


   public method initRepeatButton() {
      initLayer();

      ta_repeat.setActionName(TA_REPEAT);
      ta_repeat.setActionConsumer(this);
   }

   public function NewTextButton(String _caption) {
      local RepeatButton b;
      b.setEnableFillBackground(true);
      b.setFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);
      b.setCaption(_caption);
      b.setEnableCaptionDim(false);
      return deref b;
   }

   public function NewIconButton(String _iconName, int _placement) {
      local RepeatButton b;
      b.setIcon(UI.GetIcon(_iconName));
      b.setIconPlacement(_placement);
      b.setEnableFillBackground(false);
      b.setEnableCaptionDim(false);
      return deref b;
   }

   public virtual getProvidedActionNames() : StringArray {
      return [ACTION_CLICK, ACTION_CLICKALT];
   }

   public virtual onMouseEnter(MouseEvent _ev) : boolean {
      if(_ev.current_state&MOUSE_LBUTTON) // LMB held down??
      {
         b_pressed = true;
         b_alt     = false;
         redraw();
         return true;
      }
      else if(_ev.current_state&MOUSE_RBUTTON) // RMB held down??
      {
         b_pressed = true;
         b_alt     = true;
         redraw();
         return true;
      }
      else
      {
         return Label::onMouseEnter(_ev);
      }
   }

   public virtual onMouseLeave(MouseEvent _ev) : boolean {
      Label::onMouseLeave(_ev);
      redraw();
      b_pressed=false;
      cancelRepeatTimer();
      return true;
   }

   public virtual onMouse(MouseEvent _ev) : boolean {
      boolean bConsumed = false;
      if( (_ev.changed_state&MOUSE_LBUTTON) || (_ev.changed_state&MOUSE_RBUTTON) )
      {
         hideToolTip();
         bConsumed=true;
         redraw();
         if( (_ev.current_state&MOUSE_LBUTTON) || (_ev.current_state&MOUSE_RBUTTON) )
         {
            b_pressed=true;
            b_alt = (_ev.current_state&MOUSE_RBUTTON) ? true : false;
            provideAction(Action.New(getProvidedActionAlias(b_alt ? ACTION_CLICKALT : ACTION_CLICK), this));

            startRepeatTimer();

         }
         else
         {
            b_pressed = false;
            b_alt     = false;
            cancelRepeatTimer();
         }
      }
      return bConsumed;
   }

   private method startRepeatTimer() {
      int tnr = ++repeat_count;
      if(tnr > 20)
         tnr = 20;
      tnr = (20.0f / tnr) * 10;
      ta_repeat.setTicks(tnr);
      UI.Schedule(ta_repeat);
   }

   private method cancelRepeatTimer() {
      UI.CancelScheduleFor(this);
      repeat_count = 0;
   }

   public virtual onKey(Key _key) : boolean {
      switch(_key.pressed)
      {
         case VKEY_SPACE:
            provideAction(Action.New(getProvidedActionAlias(ACTION_CLICK), this));
            return true;

         case VKEY_RETURN:
            provideAction(Action.New(getProvidedActionAlias(ACTION_CLICKALT), this));
            return true;
      }
      return false;
   }

   protected method drawBevel() {
      int c32;

      if(isMouseOver())
      {
         if(b_pressed)
         {
            c32 = lnfGetTintedColor(LookAndFeel.COLOR_REPEATBUTTON_BG, bg32_tint);
            UIRenderer.DrawFilledRectangle(0, 0,  getSizeX(), getSizeY(), c32);
            c32 = lnfGetTintedColor(LookAndFeel.COLOR_BORDER_DIMLIGHT, bg32_tint);
            UIRenderer.DrawRectangle(0, 0, getSizeX(), getSizeY(), UIConstants.DEFAULT_BORDER_SIZE, c32);
         }
         else
         {
            UIRenderer.DrawDefaultInactiveBackgroundTint(0, 0,  getSizeX(), getSizeY(), bg32_tint);
            UIRenderer.DrawSoftShadowRaisedBorderTint(0, 0, getSizeX(), getSizeY(), bg32_tint);
         }
      }
      else
      {
         UIRenderer.DrawDefaultControlBackgroundTint(0, 0, getSizeX(), getSizeY(), bg32_tint);
         UIRenderer.DrawSoftShadowRaisedBorderTint(0, 0, getSizeX(), getSizeY(), bg32_tint);
      }

      Label::drawTransparentCached(0, 0);
   }

   protected method drawFlat() {
      int c32;

      if(isMouseOver())
      {
         if(b_pressed)
         {
            c32 = lnfGetTintedColor(LookAndFeel.COLOR_REPEATBUTTON_BG, bg32_tint);
            UIRenderer.DrawFilledRectangle(0, 0,  getSizeX(), getSizeY(), c32);
         }
         else
         {
            UIRenderer.DrawDefaultInactiveBackgroundTint(0, 0, getSizeX(), getSizeY(), bg32_tint);
         }
      }
      else
      {
         UIRenderer.DrawDefaultControlBackgroundAlphaTint(0, 0, getSizeX(), getSizeY(), 255/*alpha*/, bg32_tint);
      }

      Label::drawTransparentCached(0, 0);
   }

   public virtual onDraw() {
      if(LookAndFeel.STYLE_BEVEL == layer_style)
         drawBevel();
      else
         drawFlat();
   }

   public virtual consumeAction(Action _ac) : boolean {
      if(b_pressed)
      {
         switch(_ac.getActionName())
         {
            case TA_REPEAT:
               provideAction(Action.New(getProvidedActionAlias(b_alt ? ACTION_CLICKALT : ACTION_CLICK), this));
               startRepeatTimer();
               return true;
         }
      }
      return Label::consumeAction(_ac);
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {

      initRepeatButton();

      if(Label::beginXFMTag(_form, _attributes))
      {
         String *atname, *atval;
         StringArray *atsplit;
         foreach atname in _attributes
         {
            atval <= _attributes[atname];
            switch(atname)
            {
               case "actionAlias":
                  atsplit <= atval.splitChar('=');
                  setProvidedActionAlias(atsplit.get(0), atsplit.get(1));
                  break;

               case "onClick":
                  _form.addHandledAction(atname, Action, atval);
                  break;

               case "onClickAlt":
                  _form.addHandledAction(atname, Action, atval);
                  break;
            }
         }
      }
      return true;
   }

}
