// ----
// ---- file   : PopupMenuBarButton.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2007-2024 by Bastian Spiegel. 
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See 
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "ui" toolkit.
// ----
// ---- created: 14May2007
// ---- changed: 15May2007, 29Jan2008, 20Mar2011, 04Oct2024, 05Oct2024
// ----          
// ----
// ----

module MPopupMenuBarButton;

namespace ui;


class PopupMenuBarButton extends Button {

   public PopupMenuBar *popup_menu_bar;
   public PopupMenu *popup_menu;

   public boolean b_keydown_click = false;


   public virtual isTabCycleMember() : boolean {
      return false;
   }

   public virtual onKeyboardFocus() {
      redraw();
      savePreviousKeyboardLayer();
      popup_menu_bar.saveShadeModal();
   }

   public virtual onKeyboardFocusLost(boolean _bQuiet) {
      if(!_bQuiet)
         redraw();
   }

   protected method savePreviousKeyboardLayer() {
      // // trace "xxx PopupMenuBarButton::savePreviousKeyboardLayer: l="+#(UI.previous_keyboard_layer);
      popup_menu_bar.setPreviousKeyboardLayer(UI.previous_keyboard_layer);
   }

   public method onUIActivate() {
      // // trace "xxx PopupMenuBarButton::onUIActivate";
      popup_menu_bar.focusPreviousKeyboardLayer();
      popup_menu_bar.restoreShadeModal();
   }

   public method onUIDeactivate() {
      // // trace "xxx PopupMenuBarButton::onUIDeactivate";
      popup_menu_bar.focusPreviousKeyboardLayer();
      popup_menu_bar.restoreShadeModal();
   }

   public method onAcceleratorKey(AcceleratorKey _k) {
      // // trace "xxx PopupMenuBarButton::onAcceleratorKey";
      savePreviousKeyboardLayer();
      popup_menu_bar.saveShadeModal();
      focusFirstMenuButton();
   }

   public focusFirstMenuButton() {
      popup_menu_bar.hideAllMenus();
      b_keydown_click = true;
      handleButtonClick(null);
   }

   public virtual onKey(Key _key) : boolean {
      switch(_key.pressed)
      {
         case VKEY_ESCAPE:
            popup_menu_bar.consumeAction(Action.New("", popup_menu)); // "Canceled"
            return true;

         case VKEY_DOWN:
            b_keydown_click = true;
            handleButtonClick(null);
            return true;

         case VKEY_LEFT:
            popup_menu_bar.activatePreviousMenu(this, false);
            return true;

         case VKEY_RIGHT:
            popup_menu_bar.activateNextMenu(this, false);
            return true;
      }

      switch(_key.released)
      {
         case VKEY_DOWN:
         case VKEY_LEFT:
         case VKEY_RIGHT:
            return true; // Do not let the default tabfocus code handle the keypress
      }

      return false;
   }

   public isKeyDownClick() : boolean {
      return = b_keydown_click;
      b_keydown_click = false;
   }

   public virtual onDraw() {
      boolean bRenderPressed = popup_menu.isFloatingLayerVisible() || b_pressed || hasKeyboardFocus();
      // // trace "\nxxx PopupMenuBarButton::onDraw: this="+#(this)+" popup_menu="+#(popup_menu)+" vis="+popup_menu.isFloatingLayerVisible()+" caption="+caption+" bRenderPressed="+bRenderPressed;
      if(bRenderPressed)
      {
         UIRenderer.DrawDefaultControlBackground(0, 0, size_x, size_y);
         UIRenderer.DrawDefaultSunkenBorder(0, 0, size_x, size_y);
         Button::drawTransparentCached(0, 0);
      }
      else
      {
         if(isMouseOver())
         {
            Button::onDraw();
         }
         else
         {
            UIRenderer.DrawDefaultControlBackground(0, 0, size_x, size_y);
            Button::drawTransparentCached(0, 0);
         }
      }
   }
}

