// ----
// ---- file   : TableCellEditorString.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2018-2025 by Bastian Spiegel. 
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See 
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : 
// ----
// ---- created: 02May2010
// ---- changed: 05Mar2018, 06Jun2018, 15May2020, 10Dec2022, 25Mar2023, 14Jan2025
// ----          
// ----          
// ----

module MTableCellEditorString;

namespace ui;


class TableCellEditorString : TableCellEditor {

   TextField *tf;

   public method initStringEditor(String _text) {
      initTableCellEditor();

      setLayout(SuperBorderLayout);

      tf <= new TextField;
      tf.initTextField();
      tf.setFontByName(UIConstants.DEFAULT_FONT_NAME_TEXTFIELD);
      tf.setText(_text);
      tf.setEnableSkipEsc(true);
      tf.setAlignment(Layout.EXPANDX);

      addLayer(deref tf, Layout.CENTER);
   }

   public virtual flWantInitialFocus() : boolean {
      return false;
   }
  
   public virtual preShow() {

      resizeToMinimum();

      // Save keyboard focus
      old_keyboard_focus <= UI.GetKeyboardFocus();
      FloatingLayer::preShow();
      // // UI.SetKeyboardFocus(tf);
      tf.startEditing();
      tf.selectAll();
      UI.SetMouseFocus(tf);
   }

   public method getText() : String {
      return tf.getText();
   }

   public method setVisibleTextLength(int _length) {
      tf.setVisibleTextLength(_length);
   }

   public method setMaxCols(int _maxCols) {
      tf.setMaxTextLength(_maxCols);
   }

   public virtual onKey(Key _key) : boolean {
      // trace "xxx string editor: _key.name="+_key.name;
      if(_key.released == VKEY_ESCAPE)
      {
         hide();
         return true;
      }
      if(VKEY_UP == _key.pressed)
      {
         tf.stopEditing(false/*bProvideAction*/, false/*bReturnKey*/, false/*bQuiet*/);
         handleCellEditing();
         hide();
         table_model.editColumnPreviousRow();
         return true;
      }
      else if(VKEY_DOWN == _key.pressed)
      {
         tf.stopEditing(false/*bProvideAction*/, false/*bReturnKey*/, false/*bQuiet*/);
         handleCellEditing();
         hide();
         table_model.editColumnNextRow();
         return true;
      }
      return false;
   }

   public virtual consumeAction(Action _ac) : boolean {
      String acName <= _ac.getActionName();
      // trace "xxx TableCellEditorString: action=\""+acName+"\".";
      if(TextField.ACTION_TEXTENTERED == acName)
      {
         handleCellEditing();
         hide();
         return true;
      }
      return false;
   }

}
