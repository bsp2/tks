
module MDebugText;

use tksdl;
use tkopengl;


class DebugText {
   explain "A simple utility class to render fixed-size debug text.";

   define int CHAR_SX = 8;
   define int CHAR_SY = 16;

   public static Texture tex;

   public static OnOpen() {
      explain "Call this to make sure that the texture is (re-)loaded.";

      LoadTexture();
   }

   protected static LoadTexture() {
      tex.loadImage("font.png", 0,0,0);
      tex.flags = TEX_MODULATE | TEX_ALPHA;
      tex.expand2n();
      tex.unload();
   }

   public static BindTexture() {
      glEnable(GL_TEXTURE_2D);
      tex.bind();
   }

   public static method Draw(float _x, _y, String msg, int _fg32, int _bg32) { //compile
      explain "Preserve current GL state, setup viewport/projection and render (shadowed) text.";

      glPushAttrib(GL_ALL_ATTRIB_BITS);
      ////glPushClientAttrib(GL_ALL_ATTRIB_BITS);

      zglInit2D(Viewport.width, Viewport.height);
      glLoadIdentity();

      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      glEnable(GL_BLEND);

      glEnable(GL_TEXTURE_2D);
      tex.bind();
     
      if(_bg32)
      {
         zglColorARGB(_bg32);
         DrawScaled3f(_x+1, _y+1, 0, 1.0, 1.0, msg);
      }
      if(_fg32)
      {
         zglColorARGB(_fg32);
         DrawScaled3f(_x, _y, 0, 1.0, 1.0, msg);
      }

      ////glPopClientAttrib();
      glPopAttrib();
   }

   public static method DrawScaled3f(float _x, _y, _z, _sclx, _scly, String msg)  { // compile
      explain "Render text according to current viewport/projection. Assumes that BindTexture() has been called.";

      float uvCharWidth = float(CHAR_SX) / tex.sx;
      float uvCharHeight = float(CHAR_SY) / tex.sy;

      float advx = _sclx * CHAR_SX;
      float advy = _scly * CHAR_SY;

      float cx = 0;
      float cy = 0;
      
      glBegin(GL_QUADS);
      int off = 0;
      loop(msg.length)
      {
         char c = msg.getc(off++);
         
         if(10 == c)
         {
            cx = 0;
            cy += advy;
         }
         else if(13 == c)
         {
            cy += advy;
         }
         else 
         {
            if(c > ' ')
            {
               float ul = (c-33) * float(CHAR_SX) / tex.sx;
               glTexCoord2f(ul,                0                 );
               glVertex3f  (cx + _x,           cy + _y,        _z);

               glTexCoord2f(ul + uvCharWidth,  0                 );
               glVertex3f  (cx + _x + advx,    cy + _y,        _z);

               glTexCoord2f(ul + uvCharWidth,  uvCharHeight      );
               glVertex3f  (cx + _x + advx,    cy + _y + advy, _z);

               glTexCoord2f(ul,                uvCharHeight      );
               glVertex3f  (cx + _x,           cy + _y + advy,      _z);
            }
            cx += advx;
         }
      }
      glEnd();
   }

}
