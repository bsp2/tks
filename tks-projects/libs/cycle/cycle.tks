// ----
// ---- file   : cycle.tks
// ---- author : bsp
// ---- legal  : Distributed under terms of the MIT LICENSE.
// ----
// ---- info   : Modular softsynth / code generator
// ---- note   :    fixed point mode: 16bit (signed 12bit with 4bit headroom)
// ----          floating point mode: 32bit
// ----
// ---- created: 16Aug2020
// ---- changed: 17Aug2020, 18Aug2020, 19Aug2020, 20Aug2020, 21Aug2020, 22Aug2020, 23Aug2020
// ----          24Aug2020, 25Aug2020, 28Aug2020, 30Aug2020, 31Aug2020, 04Sep2020, 06Sep2020
// ----          07Sep2020, 12Sep2020, 13Sep2020, 21Sep2020, 22Sep2020, 24Sep2020, 11Oct2020
// ----          12Oct2020, 13Oct2020, 14Oct2020, 16Oct2020, 30Jul2021, 31Jul2021, 01Aug2021
// ----          12Aug2021, 14Aug2021, 01Sep2021, 16Jan2022, 26Sep2022, 06Jan2023, 24Mar2023
// ----          27Mar2023, 28Mar2023, 30Mar2023, 03Apr2023, 07Apr2023, 09Apr2023, 16Apr2023
// ----          18Apr2023, 19Apr2023, 04May2023, 05May2023, 06May2023, 07May2023, 08May2023
// ----          09May2023, 10May2023, 12May2023, 16May2023, 26May2023, 27May2023, 28May2023
// ----          31May2023, 05Aug2023, 06Aug2023, 08Aug2023, 17Aug2023, 27Aug2023, 11Nov2023
// ----          14Nov2023, 23Nov2023, 24Nov2023, 30Nov2023, 01Dec2023, 07Dec2023, 22Dec2023
// ----          06Jan2024, 08Jan2024, 10Jan2024, 12Jan2024, 13Jan2024, 14Jan2024, 15Jan2024
// ----          17Jan2024, 18Jan2024, 19Jan2024, 20Jan2024, 21Jan2024, 22Jan2024, 27Jan2024
// ----          28Jan2024, 31Jan2024, 02Feb2024, 03Feb2024, 04Feb2024, 05Feb2024, 06Feb2024
// ----          08Feb2024, 09Feb2024, 10Feb2024, 11Feb2024, 12Feb2024, 13Feb2024, 14Feb2024
// ----          15Feb2024, 16Feb2024, 17Feb2024, 18Feb2024, 23Feb2024, 25Feb2024, 16Apr2024
// ----          19Apr2024, 21Apr2024, 22Apr2024, 23Apr2024, 24Apr2024, 25Apr2024, 02Aug2024
// ----          08Aug2024, 10Aug2024, 11Aug2024, 13Aug2024, 21Sep2024, 07Nov2024, 08Nov2024
// ----          09Nov2024, 22Nov2024, 03Dec2024, 04Dec2024, 06Dec2024, 12Dec2024, 13Dec2024
// ----          15Dec2024, 17Dec2024, 19Dec2024, 20Dec2024, 21Dec2024, 22Dec2024, 23Dec2024
// ----          09Jan2025, 10Jan2025, 11Jan2025, 13Jan2025, 15Jan2025, 29Jan2025, 31Jan2025
// ----
// ----
// ----

module MCycle;

boolean b_debug0 = 0;  // setTmpVarContext, zone refs
boolean b_debug1 = 0;  // ops, vpl params, notefreq, xfade, wt_freqs
boolean b_debug2 = 0;  // (ext) mods, input stack, args, vars, plugin params+mods,
boolean b_debug3 = 0;  // lines, templates
// (note) see also: STConfig.b_cycle_tree_debug

// see Cycle::setExportC()
boolean b_export_c = false;
String  export_c_prefix;    // e.g. "mytune_wavexyz_0_myzone" => Calc_mytune_wavexyz_0_myzone(signed char *_wfAddrProc, const signed char *_wfAddrStatic)
boolean b_export_c_no_static;  // workaround for vlink/gcc-compiled-obj "unsupported type 0" issue on macOS/amiga-gcc

// true=plugin emit mode
//  (note) in plugin mode, exported sample data is always stored in 32bit float format
boolean b_plugin;
boolean b_have_plugin_id;  // true=plugin id was set to non-empty string (temporary during parseString())

use namespace st2;


String *short_type;   // either "int" (script) or "short" (C)
String *ushort_type;  // either "int" (script) or "unsigned short" (C)
String *uint_type;    // either "int" (script) or "unsigned int" (C)
String *clamp_fun;    // either "mathClampi" (script) or "clamp" macro (C)

IntArray dither_tbl = [5, -2, 3, 3, 5, 2, 1, 0, -3, 0, -2, 3, -9, 4, -7, -5, 1, -3, 2, 10, -3, 4, 6, 7, 9, -1, 9, -4, 8, 10, 0, 0, 5, 1, -1, -3, 0, 0, -3, 0, 1, -6, -4, 1, 0, 0, 5, -9, -1, -4, 3, 0, -3, 2, 8, 7, 0, -4, 4, 0, -4, -7, -8, -1, 3, -1, 6, 3, 2, 0, -3, 0, 0, 5, -7, -6, 4, -1, 1, -6, 1, -1, -2, 4, -3, -1, 0, 3, -4, 1, 3, 1, -2, 6, 3, -8, 6, -1, 7, -2, 2, -5, -12, -2, -7, 2, -2, 4, -5, 4, -2, 0, -2, 1, 3, 4, 0, -4, 4, 2, 1, -5, 3, 1, 5, 2, 0, 0, -1, -3, -2, 8, 6, -1, 0, 2, -5, 3, -4, -3, -4, 2, -2, 1, -1, -1, -3, -1, 1, 5, 0, -6, -2, -4, 3, -7, 0, -12, 4, -4, 0, 8, 5, 6, -2, 0, -14, 6, 3, 1, 0, 0, 1, 2, 4, 2, 0, 2, 2, 9, -4, 9, 2, -1, 2, 1, 4, -5, -7, -1, 2, 4, 9, 1, 2, 3, 4, -7, -1, 4, 2, 7, -8, -1, 0, 2, 0, 10, 0, 3, -1, -1, -3, 6, 3, 5, 0, -5, 0, -4, 4, 0, 0, -1, -9, -3, -7, -3, 4, 6, -1, 1, -9, -1, -2, -5, -4, 3, -3, 1, 0, -7, -6, 0, 0, 0, -5, -2, -1, -5, 2, -2, -6, -1, -7, -6];


// <class.png>
class CyDefs {
   // (note) 13bit precision (+-8192) does not seem to have a noticeable advantage over 11bit (+-2048)
   //         it reduces the headroom from (-16..16) to (-4..4) and the downshifts will take 2 more cycles (on 68k)
   // (todo) decide whether to go with 11 or 13 bit  ==> [23Aug2020] 11 bit

   define float FX_ONE  = 2048.0;
   define int   FX_SHR  = 11;
   define int   FX_FRAC = 2047;

   define exception CyError                   : Error;
   define exception CyParseError              : CyError;
   define exception CyUnknownModuleError      : CyParseError;
   define exception CyVarNotFoundError        : CyParseError;
   define exception CyArgNotFoundError        : CyParseError;
   define exception CyParamNotFoundError      : CyParseError;
   define exception CyInputNotFoundError      : CyParseError;
   define exception CyNoInputError            : CyParseError;
   define exception CyLUTNotFoundError        : CyParseError;
   define exception CyCurveNotFoundError      : CyParseError;
   define exception CyZoneNotFoundError       : CyParseError;
   define exception CyStackUnderflowError     : CyError;
   define exception CyVoicePluginError        : CyError;
   define exception CyPluginExportError       : CyError;
   define exception CyUninitializedLUTError   : CyParseError;
   define exception CyMacroNameError          : CyParseError;
   define exception CyMacroOverflowError      : CyParseError;
   define exception CyMacroNoValuesError      : CyParseError;
   define exception CyMacroNotFoundError      : CyParseError;
   define exception CyMacroFieldNotFoundError : CyParseError;
   define exception CyIncompleteArrayParam    : CyError;
   define exception CyMapNameError            : CyParseError;
   define exception CyMapOverflowError        : CyParseError;
   define exception CyMapNoValuesError        : CyParseError;
   define exception CyMapNotFoundError        : CyParseError;
   define exception CyMapFieldNotFoundError   : CyParseError;
   define exception CyMapKeyAlreadyExists     : CyParseError;
   define exception CyTmpNameError            : CyParseError;
   define exception CyTmpVarNotFoundError     : CyParseError;
   define exception CyIncludeNotFoundError    : CyParseError;

   define int OP_AUTO    =  0;
   define int OP_NONE    =  1;
   define int OP_SKIP    =  2;
   define int OP_REP     =  3;  // replace / assign
   define int OP_ADD     =  4;
   define int OP_ADD_SR  =  5;
   define int OP_SUB     =  6;
   define int OP_RSUB    =  7;
   define int OP_MUL     =  8;
   define int OP_MUL_SR  =  9;  // arg must be positive
   define int OP_AND     = 10;
   define int OP_OR      = 11;
   define int OP_EOR     = 12;
   define int OP_LAND    = 13;
   define int OP_LOR     = 14;
   define int OP_LEOR    = 15;
   define int OP_LNAND   = 16;
   define int OP_LNOR    = 17;
   define int OP_LNEOR   = 18;
   define int OP_MIN     = 19;
   define int OP_MAX     = 20;
   define int OP_ABSMIN  = 21;
   define int OP_ABSMAX  = 22;
   define int OP_AM      = 23;  // arithmetic         mean  (a+b)/2
   define int OP_QM      = 24;  // quadratic          mean  sqrt(a*a+b*b)
   define int OP_QMU     = 25;  // unipolar quadratic mean  sqrt(a'*a'+b'*b')  with a'=(a*0.5+0.5) and b'=(b*0.5*0.5)  (rescaled to -1..1)
   define int OP_HM      = 26;  // harmonic           mean  2 / ((1/a)+(1/b)) = (2*a*b)/(a+b)
   define int OP_HMU     = 27;  // unipolar harmonic  mean  2*(((a+1)*(b+1)) / (a+b+2))-1  (rescaled to -1..1)
   define int OP_GM      = 28;  // geometric          mean  sign(a*b)*sqrt(abs(a*b))
   define int OP_GMU     = 29;  // unipolar geometric mean  sign(a'*b')*sqrt(abs(a'*b')) with a'=(a*0.5+0.5) and b'=(b*0.5*0.5)  (rescaled to -1..1)

   static ParseOp(String _s) : int {
      if(b_debug1)
         trace "xxx try ParseOp("+_s+")";
      switch(_s)
      {
         default:
            return -1;
         case "A":   return OP_AUTO;
         case ".":   return OP_NONE;
         case "_":   return OP_SKIP;
         case "=":   return OP_REP;
         case "+":   return OP_ADD;
         case "+sr": return OP_ADD_SR;
         case "-":   return OP_SUB;
         case "r-":  return OP_RSUB;
         case "*":   return OP_MUL;
         case "*sr": return OP_MUL_SR;
         case "&":   return OP_AND;
         case "|":   return OP_OR;
         case "^":   return OP_EOR;
         case "&&":  return OP_LAND;
         case "||":  return OP_LOR;
         case "^^":  return OP_LEOR;
         case "!&":  return OP_LNAND;
         case "!|":  return OP_LNOR;
         case "!^":  return OP_LNEOR;
         case "m":   return OP_MIN;
         case "x":   return OP_MAX;
         case "M":   return OP_ABSMIN;
         case "X":   return OP_ABSMAX;
         case "am":  return OP_AM;
         case "qm":  return OP_QM;
         case "QM":  return OP_QMU;
         case "hm":  return OP_HM;
         case "HM":  return OP_HMU;
         case "gm":  return OP_GM;
         case "GM":  return OP_GMU;
      }
   }

   static OpToString(int _op) : String {
      switch(_op)
      {
         default: return "?";
         case OP_AUTO:   return "A";
         case OP_NONE:   return ".";
         case OP_SKIP:   return "_";
         case OP_REP:    return "=";
         case OP_ADD:    return "+";
         case OP_ADD_SR: return "+sr";
         case OP_SUB:    return "-";
         case OP_RSUB:   return "r-";
         case OP_MUL:    return "*";
         case OP_MUL_SR: return "*sr";
         case OP_AND:    return "&";
         case OP_OR:     return "|";
         case OP_EOR:    return "^";
         case OP_LAND:   return "&&";
         case OP_LOR:    return "||";
         case OP_LEOR:   return "^^";
         case OP_LNAND:  return "!&";
         case OP_LNOR:   return "!|";
         case OP_LNEOR:  return "!^";
         case OP_MIN:    return "m";
         case OP_MAX:    return "x";
         case OP_ABSMIN: return "M";
         case OP_ABSMAX: return "X";
         case OP_AM:     return "am";
         case OP_QM:     return "qm";
         case OP_QMU:    return "QM";
         case OP_HM:     return "hm";
         case OP_HMU:    return "HM";
         case OP_GM:     return "gm";
         case OP_GMU:    return "GM";
      }
   }

   // <method.png>
   public static IfRisingEdgeFloat(String _sVar, String _sVarLast) : String {
      return "if("+_sVar+" > 0.001f && "+_sVarLast+" <= 0.001f)\n";
   }

   // <method.png>
   public static IfRisingEdgeInt(String _sVar, String _sVarLast) : String {
      return "if("+_sVar+" > "+int(FX_ONE * 0.001f)+" && "+_sVarLast+" <= "+int(FX_ONE * 0.001f)+")\n";
   }

   // <method.png>
   public static IfFallingEdgeFloat(String _sVar, String _sVarLast) : String {
      return "if("+_sVar+" <= 0.001f && "+_sVarLast+" > 0.001f)\n";
   }

   // <method.png>
   public static IfFallingEdgeInt(String _sVar, String _sVarLast) : String {
      return "if("+_sVar+" <= "+int(FX_ONE * 0.001f)+" && "+_sVarLast+" > "+int(FX_ONE * 0.001f)+")\n";
   }

   // <function.png>
   public static FloatToString(float f) {
      local String s = f;
      if( !(s & ".") && !(s & "e") && !(s & "E") )
         s.append(".0");  // e.g. "0f" is not allowed in "C"
      s.append("f");
      return deref s;
   }

}


// <class.png>
class CyTmpVar {
   String  name;     // e.g. "tmp85"
   String  comment;  // e.g. "sin_tmp" ('suffix' arg to allocTmpVar())
   String  context;  // e.g. "Calc" (function name)
   boolean b_used;   // true while tmp var is in use. false when it can be reallocated
}


// <class.png>
class CyArrayDecl {
   CyPluginParam *param;  // param used to control the variation index (0..1 => 0..num_variations)
   int            copy_curve_idx;   // -1 or curve index (initial array data. copied when plugin is instantiated)
   int            size;
   int            num_variations;
   float          storage_min;
   float          storage_max;
   float          display_min;
   float          display_max;
   int            display_prec;  // number of fractional digital (editor hint)

   // (optional) per-element names and display ranges
   StringArray element_names;      // get_array_param_element_name()
   FloatArray  element_dpy_reset;  // get_array_param_element_reset()
   FloatArray  element_dpy_min;    // get_array_param_element_value_range()
   FloatArray  element_dpy_max;    // get_array_param_element_value_range()
   FloatArray  element_dpy_prec;   // get_array_param_element_value_range()


   public method init() {
      storage_min  = 0.0f;
      storage_max  = 1.0f;
      display_min  = 0.0f;
      display_max  = 1.0f;
      display_prec = 5;
   }

   public method getSharedArrayName() : String {
      return "array_"+param.id;
   }

   public method getVoiceArrayName() : String {
      return "eff_array_"+param.id;
   }

   public method getLastVoiceVarIdxName() : String {
      return "last_varidx_"+param.id;
   }

   public method getSharedArrayForcedIdxName() : String {
      return "forced_varidx_"+param.id;
   }

   public method addElementInfo(int _elementIdx, String _elementName, float _elementDpyReset, float _elementDpyMin, float _elementDpyMax, int _elementDpyPrec) {
      if(_elementIdx < size)
      {
         if(_elementIdx == element_names.numElements-1)
         {
            element_names    .add(_elementName);
            element_dpy_reset.add(_elementDpyReset);
            element_dpy_min  .add(_elementDpyMin);
            element_dpy_max  .add(_elementDpyMax);
            element_dpy_prec .add(_elementDpyPrec);
         }
         else
         {
            // out-of-sequence (potentially leaving previous elements undeclared)
            element_names    .realloc(_elementIdx + 1);
            element_dpy_reset.realloc(_elementIdx + 1);
            element_dpy_min  .realloc(_elementIdx + 1);
            element_dpy_max  .realloc(_elementIdx + 1);
            element_names    .useAll();
            element_dpy_reset.useAll();
            element_dpy_min  .useAll();
            element_dpy_max  .useAll();
            element_names    [_elementIdx] = _elementName;
            element_dpy_reset[_elementIdx] = _elementDpyReset;
            element_dpy_min  [_elementIdx] = _elementDpyMin;
            element_dpy_max  [_elementIdx] = _elementDpyMax;
            element_dpy_prec [_elementIdx] = _elementDpyPrec;
         }
      }
      else
      {
         trace "[~~~] CyArrayDecl::addElementInfo: elementIdx="+_elementIdx+" exceeds array size ("+size+")";
      }
   }

   // <method_get.png>
   public method haveElementInfos() : boolean {
      return !element_names.isEmpty();
   }

   // <method_find.png>
   public method findElementIdxByName(String _elementName) : int {
      return element_names.indexOfObject(_elementName, 0);
   }

   // <method_get.png>
   public method getElementName(int _elementIdx) : String {
      return element_names.get(_elementIdx);
   }

}


// <class.png>
class CyPluginWaveformRef {
   // used in voice-plugin mode (embedded waveforms)
   Sample   *sample;
   StSample *[] zones;  // for debug info (source comment)

   public method init(Sample _sample, StSample _zone) {
      sample <= _sample;
      addUniqueZoneRef(_zone);
   }

   public method addUniqueZoneRef(StSample _zone) {
      if(-1 == zones.indexOfPointer(_zone, 0))
         zones.add(_zone);
   }

   public method getExportedSampleVarName() : String {
      return "loc_smp_"+Utils.ConvertToVarName(sample.unique_name);
   }

   public method getExportedZoneVarName(StSample _zone) : String {
      return getExportedSampleVarName()+"_zone"+sample.getZoneIdx(_zone);
   }

   public method emitSampleData(String _buf) {
      // Waveform
      StWaveform wf <= sample.waveform;
      int numFrames = wf.getNumFrames();
      _buf.append("static const float "+getExportedSampleVarName()+"["+numFrames+"] = {");
      FloatArray smpDat <= wf.sampleData;
      int i = 0;
      loop(numFrames)
      {
         if(0 == (i & 7))
            _buf.append("\n   ");
         if(i > 0)
            _buf.append(", ");
         _buf.append(CyDefs.FloatToString(smpDat.get(i++)));
      }
      _buf.append("\n};\n");

      // Zone refs
      StSample *s;
      int numSampleZones = sample.getNumZones();
      int refIdx = 0;
      foreach s in zones
      {
         _buf.append("static const float *"+getExportedZoneVarName(s)+" = "+getExportedSampleVarName()+" + "+s.minOffset+";  // ref "+(refIdx+1)+"/"+zones.numElements+", zone "+(sample.getZoneIdx(s)+1)+"/"+numSampleZones+" #frames="+(s.maxOffset - s.minOffset)+"\n");
      }
   }
}


// <class.png>
class CyPort : CyDefs {
   CyModule *parent_mod;
   int       idx;
   String    id;
   int       indent;

   // (todo) always a single-element array ?? (linked via seq_next instead)
   // (todo) change to "first_module" ?
   CyModule *[] modules;

   public method addModule(CyModule _mod) {
      modules.add(#(deref _mod));
   }

   public method debugPrintTree(local int _level) {
      local CyModule *mod;
      foreach mod in modules
      {
         mod.debugPrintTree(_level + 1);
      }
   }

   public method isConnected() : boolean {
      return !modules.isEmpty();
   }

}


// <class.png>
class CyInput : CyPort {
   float def_value;
   float min_value;
   float max_value;

   String *ext_def_value;  // CyModuleExt


   // <method_get.png>
   public method isConstVal() : boolean {
      if(0 == modules.numElements)
         return true;
      else if(1 == modules.numElements)
      {
         CyModule mod <= modules.get(0);
         if(null == mod.seq_next)
         {
            if(OP_AUTO == mod.op && mod.isConstVal())
               return true;
         }
      }
   }

   // <method_get.png>
   public method getConstVal() : float {
      if(0 == modules.numElements)
         return def_value;
      else if((1 == modules.numElements) && (null == modules.get(0).seq_next))
         return modules.get(0).getConstVal();
      // (note) fold const..
      return -999999.0f;
   }

   // <method_get.png>
   public method isConst0() : boolean {
      return (0.0f == getConstVal());
   }

   // <method_get.png>
   public method isConst1() : boolean {
      return (1.0f == getConstVal());
   }

   // <method.png>
   public method emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(modules.isEmpty())
         _out.append(_sDstVar+" = "+def_value+";\n");
      else
      {
         local CyModule *mod;
         local int modNr = 1;
         local int modNum = modules.numElements;
         foreach mod in modules
         {
            _out.append("\n// ---- mod=\""+parent_mod.getString()+"\" input \""+id+"\" seq "+modNr+"/"+modNum+"\n");
            mod.emitFloatSequence(_script, _out, _sDstVar);
            modNr++;
         }
      }
   }

   // <method.png>
   public method emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(modules.isEmpty())
         _out.append(_sDstVar+" = "+int(def_value*FX_ONE)+";\n");
      else
      {
         local CyModule *mod;
         local int modNr = 1;
         local int modNum = modules.numElements;
         foreach mod in modules
         {
            _out.append("\n// ---- mod=\""+parent_mod.getString()+"\" input \""+id+"\" seq "+modNr+"/"+modNum+"\n");
            mod.emitIntSequence(_script, _out, _sDstVar);
            modNr++;
         }
      }
   }
}


// <class.png>
class CyOutput : CyPort {
}


// <class.png>
class CyValue {
   String id;
   int idx;

   float def_value;
   float cur_value;
   float min_value;
   float max_value;

   String *group_name;    // args and params
   String *section_name;  // args and params

   boolean b_smooth;  // vars in plugin mode


   public method init() {
      min_value = 0;
      max_value = 1;
   }

   public method getRandomValue() : float {
      return rand(max_value - min_value) + min_value;
   }
}


// <class.png>
class CyArg : CyValue {
   FloatArray  preset_values;
   StringArray preset_names;
   boolean b_local;  // 1=hide from arg list in UI (UI module args)

   public method addPreset(float _value, String _name) {
      // trace "xxx CyArg::addPreset: value="+_value+" name=\""+_name+"\"";
      preset_values.add(_value);
      preset_names .add(_name);
   }

   public method getNumPresets() : int {
      return preset_names.numElements;
   }

   // public method scalePresetValuesToMinMaxRange() {
   //    int i = 0;
   //    loop(preset_values.numElements)
   //    {
   //       float f = preset_values.get(i);
   //       f *= (max_value - min_value) + min_value;
   //       preset_values[i] = f;
   //       i++;
   //    }
   // }

}


// <class.png>
class CyVar : CyValue {

   public method getBaseId() : String {
      return id;
   }

   public method getVarString(boolean _bPlugin, boolean _bExportC) : String {
      if("x" == id)
         return "x";
      else if(_bPlugin)
         return "voice->var_"+id+export_c_prefix;
      else if(_bExportC)
         return "var_"+id+export_c_prefix;
      else
         return "var_"+id;
   }

   public method getScaleAddString() : String {
      float scl = max_value - min_value;
      if(min_value != 0.0)
      {
         if(scl != 1.0)
            return " * "+CyDefs.FloatToString(scl)+" "+((min_value < 0.0f) ? ("- "+CyDefs.FloatToString(-min_value)) : ("+ "+CyDefs.FloatToString(min_value)));
         else
            return " "+((min_value < 0.0f) ? ("- "+CyDefs.FloatToString(-min_value)) : ("+ "+CyDefs.FloatToString(min_value)));
      }
      else
      {
         if(scl != 1.0)
            return " * "+CyDefs.FloatToString(scl);
         else
            return "";
      }
   }
}


// <class.png>
class CyPluginParam : CyVar {

   FloatArray  preset_values;
   StringArray preset_names;

   public virtual getBaseId() : String {
      if(id <= "p_")
         return id.substring(2, 999);
      else
         return id;
   }

   public method addPreset(float _value, String _name) {
      // trace "xxx CyPluginParam::addPreset: value="+_value+" name=\""+_name+"\"";
      preset_values.add(_value);
      preset_names .add(_name);
   }

   public method getNumPresets() : int {
      return preset_names.numElements;
   }

   public method emitPresetValues(String _buf) {
      int i = 0;
      loop(preset_values.numElements)
      {
         if(i > 0)
            _buf.append(", ");
         _buf.append(CyDefs.FloatToString(preset_values.get(i++)));
      }
   }

   public method emitPresetNames(String _buf) {
      int i = 0;
      loop(preset_values.numElements)
      {
         if(i > 0)
            _buf.append(", ");
         _buf.append("\""+preset_names.get(i++)+"\"");
      }
   }

}


// <class.png>
class CyPluginMod : CyVar {
   boolean b_smooth;  // true=interpolate modulation over processing block.  false=don't (e.g. flanger phase)

   public virtual init() {
      CyVar::init();
      b_smooth = true;
   }

   public virtual getBaseId() : String {
      if(id <= "m_")
         return id.substring(2, 999);
      else
         return id;
   }
}


// <class.png>
class CyMacro {
   String      id;            // e.g. "m_osc_mix"
   StringArray field_names;   // e.g. ["sin", "tri", "saw", "pul"]
   FloatArray  field_values;  // field_names.numElements * numSets elements

   public method calcPermutations(FloatArray _values) {
      // called during parse()
      int numFields = field_names.numElements;
      int numPermValues = _values.numElements;
      int totalNumMacroRows = mathPowerf(numPermValues, numFields);
      int rowIdx = 0;
      loop(totalNumMacroRows)
      {
         int fieldIdx = 0;
         loop(numFields)
         {
            int permIdx = ( rowIdx / int(mathPowerf(numPermValues, fieldIdx)) ) % numPermValues;
            field_values.add(_values[permIdx]);
            fieldIdx++;
         }
         rowIdx++;
      }
   }

   public method getNumMacroRows() : int {
      return field_values.numElements / field_names.numElements;
   }

   public method getNumMacroValues() : int {
      return field_values.numElements;
   }

   public method getNumMacroFields() : int {
      return field_names.numElements;
   }

   public method emitFieldValuesFloat(String _out) {
      int numFields = field_names.numElements;
      int numRows = field_values.numElements / numFields;
      int i = 0;
      local Integer rowIdx = 0;
      loop(numRows)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         loop(numFields)
         {
            _out.append(CyDefs.FloatToString(field_values[i++]));
            _out.append(", ");
         }
         _out.append("\n");
         rowIdx++;
      }
   }

   public method emitFieldValuesInt(String _out) {
      local Integer rowIdx = 0;
      int numFields = field_names.numElements;
      int numRows = field_values.numElements / numFields;
      int i = 0;
      local Short v;
      loop(numRows)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         loop(numFields)
         {
            v = int(CyDefs.FX_ONE * field_values[i++]);
            _out.append(String(v));
            _out.append(", ");
         }
         _out.append("\n");
         rowIdx++;
      }
   }
}


// <class.png>
class CyMap {
   String      id;            // e.g. "mykeymap"
   StringArray field_names;   // e.g. ["freq", "vol", "cutoff"]
   FloatArray  row_keys;
   FloatArray  field_values;  // field_names.numElements * num_rows elements
   int         num_rows;
   float       row_key_min;
   float       row_key_max;

   public method initMap() {
      row_key_min =  999999.0f;
      row_key_max = -999999.0f;
   }

   public method getNumMapRows() : int {
      return num_rows;
   }

   public method getNumMapValues() : int {
      return field_values.numElements;
   }

   public method getNumMapFields() : int {
      return field_names.numElements;
   }

   public method addRowKey(float _f) : boolean {
      if(-1 != row_keys.indexOf(_f, 0))
         return false;
      row_keys.add(_f);
      if(_f < row_key_min)
         row_key_min = _f;
      if(_f > row_key_max)
         row_key_max = _f;
      return true;
   }

   public method emitFieldValuesFloat(String _out) {
      int numFields = field_names.numElements;
      int i = 0;
      local Integer rowIdx = 0;
      loop(num_rows)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         loop(numFields)
         {
            _out.append(CyDefs.FloatToString(field_values[i++]));
            _out.append(", ");
         }
         _out.append("\n");
         rowIdx++;
      }
   }

   public method emitFieldValuesInt(String _out) {
      local Integer rowIdx = 0;
      int numFields = field_names.numElements;
      int i = 0;
      local Short v;
      loop(num_rows)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         loop(numFields)
         {
            v = int(CyDefs.FX_ONE * field_values[i++]);
            _out.append(String(v));
            _out.append(", ");
         }
         _out.append("\n");
         rowIdx++;
      }
   }

   public method emitRowKeysFloat(String _out) {
      int i = 0;
      local Integer rowIdx = 0;
      loop(num_rows)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         _out.append(CyDefs.FloatToString(row_keys[i++]));
         _out.append(",\n");
         rowIdx++;
      }
   }

   public method emitRowKeysInt(String _out) {
      int i = 0;
      local Integer rowIdx = 0;
      loop(num_rows)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         _out.append(String(int(row_keys[i++] * CyDefs.FX_ONE)));
         _out.append(",\n");
         rowIdx++;
      }
   }

   public method emitRowKeysDeltaLinFloat(String _out) {
      int i = 0;
      local Integer rowIdx = 0;
      loop(num_rows - 1)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         _out.append(CyDefs.FloatToString(1.0f / (row_keys[i + 1] - row_keys[i])));
         _out.append(",\n");
         rowIdx++;
         i++;
      }
   }

   public method emitRowKeysDeltaLinInt(String _out) {
      int i = 0;
      local Integer rowIdx = 0;
      loop(num_rows - 1)
      {
         _out.append("   /*"+rowIdx.printf("%5d")+" */ ");
         _out.append(String(int(CyDefs.FX_ONE / (row_keys[i + 1] - row_keys[i]))));
         _out.append(",\n");
         rowIdx++;
         i++;
      }
   }

}


// <class.png>
class CyLUT {
   String  id;
   int     lut_w;  // PoT. voice:2..1024 (exp 1..10) shared:2..16384 (exp 1..14)
   boolean b_voice;  // true=recalc at note on (first prepare_block) OR wavetable cycle start, false=recalc when voice is initialized
   // (note) corresponding pre-calc section must be named "lut_<id>"
   boolean b_have_init;  // true=init section was declared for this LUT. false=skip LUT and return 0
   boolean b_inv;  // inverse lookup flag

   public method init() {
      lut_w     = 64;
      b_voice   = true;
      b_inv     = false;
   }

   public method getLUTString(boolean _bPlugin) : String {
      return _bPlugin ? b_voice ? ("voice->lut_"+id) : ("shared->lut_"+id) : ("lut_"+id+export_c_prefix);
   }
}


// <class.png>
class CyExtModConfig : CyDefs {
   String id;
   String def_value;  // arbitrary c code (literal, constant name, expr, ..)

   StringArray *const_names;  // see CyModuleExt.getInputConstants()
   StringArray *const_values;

   public method mapConstValue(String _sValue) : String {
      if(b_debug2)
         trace "xxx CyExtModConfig::mapConstValue: id="+id+" sValue=\""+_sValue+"\" const_names="+#(const_names);
      local String r = _sValue;
      if(null != const_names)
      {
         int idx = const_names.indexOfObject(_sValue, 0);
         if(idx >= 0)
         {
            r = const_values[idx];
            if(b_debug2)
               trace "xxx CyExtModConfig::mapConstValue:    => idx="+idx+" r=\""+r+"\"";
         }
      }
      return deref r;
   }
}


// <class.png>
class CyExtModInput : CyDefs {
   String id;
   float def_value;
}


// <class.png>
class CyExtMod : CyDefs {
   String      id;              // e.g. "xamp"
   StringArray a_pre;           // code lines before #include
   StringArray a_static;        // module-static code lines
   StringArray a_init;          // init code lines
   StringArray a_new;           // voice_new() code lines
   StringArray a_delete;        // voice_delete() code lines
   StringArray a_voice;         // voice struct code lines
   StringArray a_noteon;        // note-on code lines
   StringArray a_prepare;       // prepare block
   StringArray a_prepare_first; // prepare block (after note-on)
   StringArray a_prepare_next;  // prepare next block
   StringArray a_emit;          // instance code lines

   CyExtModConfig *[] config_items;
   CyExtModInput  *[] inputs;

   public method addPre(String _s) {
      a_pre.add(_s);
   }

   public method addStatic(String _s) {
      a_static.add(_s);
   }

   public method addInit(String _s) {
      a_init.add(_s);
   }

   public method addNew(String _s) {
      a_new.add(_s);
   }

   public method addDelete(String _s) {
      a_delete.add(_s);
   }

   public method addVoice(String _s) {
      a_voice.add(_s);
   }

   public method addNoteOn(String _s) {
      a_noteon.add(_s);
   }

   public method addPrepare(String _s) {
      a_prepare.add(_s);
   }

   public method addPrepareFirst(String _s) {
      a_prepare_first.add(_s);
   }

   public method addPrepareNext(String _s) {
      a_prepare_next.add(_s);
   }

   public method addEmit(String _s) {
      a_emit.add(_s);
   }

   public method addConfig(CyScript _script, StringArray _words) {
      CyExtModConfig cfg <= new CyExtModConfig;
      cfg.id        = _words.get(0);
      cfg.def_value = _words.get(1);
      int wIdx = 2;
      local StringArray aVal;
      local StringArray aName;
      if(b_debug2) trace "xxx CyExtMod::addConfig: cfg.id="+cfg.id+" words="+#(_words);
      while((wIdx + 2) < _words.numElements)
      {
         // parse constval=constname tuples
         //  e.g. in >>@cycle_config   mode 0  0=lpf 1=hpf<<
         if("=" == _words.get(wIdx + 1))
         {
            String constVal  = _words.get(wIdx + 0);  // should be a float
            String constName = _words.get(wIdx + 2);
            aVal .add(constVal);
            aName.add(constName);
            if(b_debug2) trace "xxx CyExtMod::addConfig:   cfg.id="+cfg.id+" "+constVal+"="+constName;
            wIdx += 3;
         }
         else
            throw CyParseError _script.getSrcLoc()+": expected '=' while parsing xinc @cycle_config constant";
      }
      if(!aVal.isEmpty())
      {
         cfg.const_names  <= deref aName;
         cfg.const_values <= deref aVal;
      }
      if(b_debug2) trace "xxx CyExtMod::addConfig:    cfg.const_names="+#(cfg.const_names);
      config_items.add(#(deref cfg));
   }

   public method findConfigItemById(String _id) : CyExtModConfig {
      CyExtModConfig *cfg;
      foreach cfg in config_items
      {
         if(cfg.id == _id)
            return cfg;
      }
      return null;
   }

   public method addInput(String _id, float _defVal) {
      CyExtModInput inp <= new CyExtModInput;
      inp.id = _id;
      inp.def_value = _defVal;
      inputs.add(#(deref inp));
   }
}


// <class.png>
class CyTemplate : CyDefs {
   String      id;         // e.g. "myosc"
   StringArray lines;
   StringArray var_names;  // %myvar%
   StringArray var_defs;   // default values / strings

   String parent_buffer;  // CyParseContext::name
   int parent_line_idx;   // start of template definition in parent_buffer

   protected int indent_offset;

   public method initTemplate(String _id) {
      id = _id;
   }

   public method addVar(String _name, String _def) {
      var_names.add(_name);
      var_defs .add(_def);
   }

   public method addLine(String _line) {
      if(lines.isEmpty())
      {
         // first line determines indentation offset
         indent_offset = _line.numCharsAt(' ', 0);
         // trace "xxx CyTemplate: indent_offset="+indent_offset+" first line=\""+_line+"\"";
      }
      lines.add(_line.substring(indent_offset, -1));
   }

   public method addEmptyLine() {
      lines.add("");
   }

   public method getVarNameByIdx(int _idx) : String {
      return var_names.get(_idx);
   }

   public method findVarNameIdx(String _s) : int {
      return var_names.indexOfObject(_s, 0);
   }

   public method getInstanceLines(CyScript    _script,
                                  int         _indent,
                                  StringArray _varNames,
                                  StringArray _varValues,
                                  String      _tmplInstanceId  // e.g. "myosc1"
                                  ) : StringArray {
      local StringArray r;
      local String *sVar;
      local HashTable htVars;

      // Load default values
      int varIdx = 0;
      foreach sVar in var_names
      {
         if("id" != sVar)
            htVars[sVar] = var_defs[varIdx];
         varIdx++;
      }

      // Load actual values
      varIdx = 0;
      foreach sVar in _varNames
      {
         if("id" != sVar && !htVars.exists(sVar))
            throw CyTmpVarNotFoundError _script.getSrcLoc()+": tmp \""+id+"\" has no var named \""+sVar+"\"";

         htVars[sVar] = _varValues[varIdx++];
      }

      _script.next_template_var_idx++;

      String *line;
      sVar <= new String;
      int lineNr = 1;
      // trace "xxx getInstanceLines: orig lines="+lines;
      foreach line in lines
      {
         String sLine; sLine.empty();
         sLine.appendRepeat(" ", _indent);
         sLine.append(line);
         int idxS = 0;
         while(idxS >= 0)
         {
            idxS = sLine.indexOfChar('%', idxS);
            if(idxS >= 0)
            {
               int idxE = sLine.indexOfChar('%', idxS+1);
               if(idxE >= 0)
               {
                  if(idxE == (idxS+1))
                  {
                     // %%  (instance id)
                     sLine.replaceRegion(idxS, idxE+1, /*"_"+*/_tmplInstanceId);////"_"+_script.next_template_var_idx);
                  }
                  else
                  {
                     sLine.substring(idxS+1, idxE-idxS-1) => sVar;
                     if(!htVars.exists(sVar))
                        throw CyTmpVarNotFoundError _script.getSrcLoc()+": tmp \""+id+"\" var \""+sVar+"\" not found (in template line "+lineNr+")";
                     sLine.replaceRegion(idxS, idxE+1, htVars[sVar]);
                  }
               }
            }
         }
         if(b_debug3)
            trace "xxx tmpl inst  line="+sLine;
         r.add(sLine);
      } // foreach line
      return deref r;
   }

}


// <class.png>
class CyTemplateInstance : CyDefs {
   String class_id;      // CyTemplate.id  (e.g. "sineosc")
   String instance_id;   // instance id (e.g. "osc1")

   public method init(String _classId, String _instanceId) {
      class_id    = _classId;
      instance_id = _instanceId;
   }
}


// <class.png>
class CyModule : CyDefs {
   // (note) first input is default input (e.g. "sin 1.5" sets freq to baseFreq*1.5)
   CyScript *parent_script;
   CyInput  *inputs  [];
   int       op;
   int       indent;
   CyModule *seq_parent;
   CyModule *seq_right;
   CyModule *seq_next;

   protected HashTable *input_aliases;  // e.g. CyModuleRmp "ms" => "millisec". see findInputById()


   // <method_init.png>
   public method init() {
      op = OP_AUTO;
   }

   // <method_exit.png>
   public method exit() {
   }

   // <method_get.png>
   public method getString() : String {
      return (this.yacMetaClassName().replace("CyModule","").toLower());
   }

   // <method_get.png>
   public method validate() : boolean {
      return true;
   }

   // <method.png>
   public method debugPrintTree(local int _level) {
      local CyModule c <= this;
      local String s;
      s.appendRepeat(" ", _level*2);
      while(null != c)
      {
         trace s+CyDefs.OpToString(c.op)+" "+c.getString();//+" (level "+_level+")";
         local CyInput *inp;
         foreach inp in c.inputs
         {
            if!(inp.modules.isEmpty())
            {
               trace s+"    "+inp.id+":";
               inp.debugPrintTree(_level+2);
            }
         }
         if(null != c.seq_right)
            c.seq_right.debugPrintTree(_level+1);
         c <= c.seq_next;
      }
   }

   // <method_add.png>
   public method addInput(String _id, float _def, float _min, float _max) : CyInput {
      local CyInput inp;
      inp.idx = inputs.numElements;
      inp.id = _id;
      inp.def_value = _def;
      inp.min_value = _min;
      inp.max_value = _max;
      inp.parent_mod <= this;
      inputs.add(#(deref inp));
      return inp;
   }

   // <method_add.png>
   protected method addInputAlias(String _aliasId, String _id) {
      if(null == input_aliases)
         input_aliases <= new HashTable;
      input_aliases[_aliasId] = Object(_id);
   }

   // <method_find.png>
   public method findInputById(String _id) : CyInput {
      CyInput *inp;

      String *inputId;
      if(null != input_aliases && input_aliases.exists(_id))
         inputId <= input_aliases[_id];
      else
         inputId <= _id;

      foreach inp in inputs
         if(inp.id == inputId)
            return inp;

      return null;
   }

   // <method_get.png>
   public method getInputByIndex(int _idx) : CyInput {
      return inputs.get(_idx);
   }

   // <method_get.png>
   public method getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      return false;
   }

   // <method_find.png>
   public method findInputConstant(String _inputId, String _s) : float {
      // -999999 = not found, constant value otherwise
      local StringArray constNames;
      local FloatArray  constValues;
      if(getInputConstants(_inputId, constNames, constValues))
      {
         int idx = constNames.indexOfObject(_s, 0);
         if(idx >= 0)
         {
            return constValues.get(idx);
         }
      }
      return -999999;
   }

   // // <method_set.png>
   // public method setDefaultInputMod(CyModule _mod) : boolean {
   //    CyInput inp <= inputs.get(0);
   //    if(null != inp)
   //    {
   //       inp.addModule(deref _mod);
   //       return true;
   //    }
   //    return false;
   // }

   // <method_get.png>
   public method isConstVal() : boolean {
      return false;
   }

   // <method_get.png>
   public method getConstVal() : float {
      return -999999.0f;
   }

   // <method_get.png>
   public method isConst0() : boolean {
      return (0.0f == getConstVal());
   }

   // <method_get.png>
   public method isConst1() : boolean {
      return (1.0f == getConstVal());
   }

   // <method_get.png>
   public method doEmitRight() : boolean {
      // overridden by CyModuleRep
      return true;
   }

   // <method.png>
   public method emitFloatTree(CyScript _script, local String _out, local String _sDstVar) {
      if(OP_SKIP == op)
         return;

      local String *sRHS;
      local String *sVarTmp;

      local boolean bHaveSubtree = (null != seq_right) && doEmitRight();
      local boolean bConst = isConstVal();

      if(/*!bHaveSubtree &&*/ ([OP_AUTO,OP_REP].contains(op)))
      {
         // replace previous output
         sRHS <= _sDstVar;
      }
      else
      {
         // need tmp var ?
         if(!bConst || OP_NONE == op || bHaveSubtree)
         {
            sVarTmp <= _script.allocTmpVar(_out, "seq");
            sRHS <= sVarTmp;

            // // // if(OP_NONE == op)
            // // // {
               // initial sub-tree input is previous output
               //  (note) new output will be discarded when op=OP_NONE
               _out.append(sVarTmp+" = "+_sDstVar+";\n");
            // // // }
         }
      }

      if(!bConst || bHaveSubtree)
      {
         // trace "[trc] CyModule::emitFloatTree: call emitFloat this="+#(this)+" sRHS=\""+sRHS+"\" sDstVar=\""+_sDstVar+"\"";
         emitFloat(_script, _out, sRHS);

         if(bHaveSubtree)
            seq_right.emitFloatSequence(_script, _out, sRHS);
      }
      else
      {
         // rhs is constant
         sRHS <= FloatToString(getConstVal());
      }

      switch(op)
      {
         default:
         case OP_AUTO:
         case OP_REP:
            if(@(sRHS) != @(_sDstVar))
               _out.append(_sDstVar+" = "+sRHS+";\n");
            break;

         case OP_NONE:
            // ignore output
            _out.append("// (ignore last output via \'.\')\n");
            break;

         case OP_ADD:
            _out.append(_sDstVar+" += "+sRHS+";\n");
            break;

         case OP_ADD_SR:
            if(b_plugin)
            {
               if((null == seq_right) && isConstVal())
               {
                  _out.append(_sDstVar+" += "+_script.allocAddSRConstVarFloat(getConstVal())+";\n");
               }
               else
               {
                  _out.append(_sDstVar+" += "+sRHS+" * voice->sr_factor;\n");
                  _script.b_use_sr_factor = true;
               }
            }
            else
            {
               if(_script.oversample_factor > 1)
                  _out.append(_sDstVar+" += "+sRHS+" * "+FloatToString(1.0f / _script.oversample_factor)+";\n");
               else
                  _out.append(_sDstVar+" += "+sRHS+";\n");
            }
            break;

         case OP_SUB:
            _out.append(_sDstVar+" -= "+sRHS+";\n");
            break;

         case OP_RSUB:
            _out.append(_sDstVar+" = "+sRHS+" - "+_sDstVar+";\n");
            break;

         case OP_MUL:
            _out.append(_sDstVar+" *= "+sRHS+";\n");
            break;

         case OP_MUL_SR:
            if(b_plugin)
            {
               // trace "xxx OP_MUL_SR: sDstVar=\""+_sDstVar+"\" sRHS=\""+sRHS+"\" seq_right="+(null != seq_right)+" isConstVal="+isConstVal();
               if(null == seq_right && isConstVal())
               {
                  _out.append(_sDstVar+" *= "+_script.allocMulSRConstVarFloat(getConstVal())+";\n");
               }
               else
               {
                  _out.append(_sDstVar+" *= powf("+sRHS+", voice->sr_factor);\n");
                  _script.b_use_sr_factor = true;
               }
            }
            else
            {
               if(null == seq_right && isConstVal())
               {
                  if(_script.oversample_factor > 1)
                     _out.append(_sDstVar+" *= "+FloatToString(mathPowerf(getConstVal(), (1.0f / _script.oversample_factor)))+";\n");
                  else
                     _out.append(_sDstVar+" *= "+FloatToString(getConstVal())+";\n");
               }
               else
               {
                  if(_script.oversample_factor > 1)
                     _out.append(_sDstVar+" *= mathPowerf("+sRHS+", "+FloatToString(1.0f / _script.oversample_factor)+");\n");
                  else
                     _out.append(_sDstVar+" *= "+sRHS+";\n");
               }
            }
            break;

         case OP_AND:
            _out.append(_sDstVar+" = (((int)("+_sDstVar+" * "+int(FX_ONE)+") & int("+sRHS+" * "+int(FX_ONE)+"))) * (1.0f / "+FX_ONE+");\n");
            break;

         case OP_OR:
            _out.append(_sDstVar+" = (((int)("+_sDstVar+" * "+int(FX_ONE)+") | int("+sRHS+" * "+int(FX_ONE)+"))) * (1.0f / "+FX_ONE+");\n");
            break;

         case OP_EOR:
            _out.append(_sDstVar+" = (((int)("+_sDstVar+" * "+int(FX_ONE)+") ^ int("+sRHS+" * "+int(FX_ONE)+"))) * (1.0f / "+FX_ONE+");\n");
            break;

         case OP_LAND:
            _out.append(_sDstVar+" = (float)( ("+_sDstVar+" > 0.0f) & ("+sRHS+" > 0.0f) );\n");
            break;

         case OP_LOR:
            _out.append(_sDstVar+" = (float)( ("+_sDstVar+" > 0.0f) || ("+sRHS+" > 0.0f) );\n");
            break;

         case OP_LEOR:
            _out.append(_sDstVar+" = (float)( ("+_sDstVar+" > 0.0f) ^ ("+sRHS+" > 0.0f) );\n");
            break;

         case OP_LNAND:
            _out.append(_sDstVar+" = (float) !(("+_sDstVar+" > 0.0f) & ("+sRHS+" > 0.0f));\n");
            break;

         case OP_LNOR:
            _out.append(_sDstVar+" = (float) !(("+_sDstVar+" > 0.0f) || ("+sRHS+" > 0.0f));\n");
            break;

         case OP_LNEOR:
            _out.append(_sDstVar+" = (float) !(("+_sDstVar+" > 0.0f) ^ ("+sRHS+" > 0.0f));\n");
            break;

         case OP_MIN:
            _out.append(_sDstVar+" = mathMinf("+_sDstVar+", "+sRHS+");\n");
            break;

         case OP_MAX:
            _out.append(_sDstVar+" = mathMaxf("+_sDstVar+", "+sRHS+");\n");
            break;

         case OP_ABSMIN:
            _out.append(_sDstVar+" = mathAbsMinf("+_sDstVar+", "+sRHS+");\n");
            break;

         case OP_ABSMAX:
            _out.append(_sDstVar+" = mathAbsMaxf("+_sDstVar+", "+sRHS+");\n");
            break;

         case OP_AM:
            _out.append(_sDstVar+" = ("+_sDstVar+" + "+sRHS+") * 0.5f;\n");
            break;

         case OP_QM:
            _out.append(_sDstVar+" = sqrt("+_sDstVar+"*"+_sDstVar+" + "+sRHS+"*"+sRHS+");\n");
            break;

         case OP_QMU:
            _out.append(_sDstVar+" = ("+_sDstVar+" * 0.5f) + 0.5f;\n");
            _out.append(_sDstVar+" = sqrt("+_sDstVar+"*"+_sDstVar+" + ("+sRHS+"*0.5f+0.5f)*("+sRHS+"*0.5f+0.5f)) * 2.0f - 1.0f;\n");
            break;

         case OP_HM:
            // _out.append(_sDstVar+"  = (0.0f != "+_sDstVar+") ? (1.0f / "+_sDstVar+") : 99999.0f;\n");
            // _out.append(_sDstVar+" += (0.0f != "+sRHS+") ? (1.0f / "+sRHS+") : 99999.0f;\n");
            // _out.append(_sDstVar+"  = (0.0f != "+_sDstVar+") ? (2.0f / "+_sDstVar+") : 0.0f;\n");
            _out.append(_sDstVar+" = (0.0f != ("+_sDstVar+"+"+sRHS+")) ? ((2.0f * ("+_sDstVar+"*"+sRHS+")) / ("+_sDstVar+" + "+sRHS+")) : 0.0f;\n");
            break;

         case OP_HMU:
            // 2*a*b / (a+b)   rescale -1..1 => 0..1
            //  =>
            //    (2*(0.5*a+0.5)*(0.5*b+0.5) / ((0.5*a+0.5)+(0.5*b+0.5))
            // = (2*(0.5*a+0.5)*(0.5*b+0.5) / (0.5 * ((a+1)+(b+1)))
            // = 4 * ( ((0.5*a+0.5)*(0.5*b+0.5)) / ((a+1)+(b+1)) )
            // = 4 * ( (0.25 * ((a+1)*(b+1))) / ((a+1)+(b+1)) )
            // = ((a+1)*(b+1)) / (a+b+2)
            // ; rescale to -1..1
            //   ((2.0 * ((a+1)*(b+1))) / (a+b+2)) - 1.0
            // = (((a+2)*(b+1)) / (a+b+2)) - 1.0
            _out.append(_sDstVar+" = (0.0f != ("+_sDstVar+"+"+sRHS+"+2.0f)) ? (2.0f * ((("+_sDstVar+"+1.0f)*("+sRHS+"+1.0f)) / ("+_sDstVar+"+"+sRHS+"+2.0f)) - 1.0f) : 0.0f;\n");
            break;

         case OP_GM:
            _out.append(_sDstVar+" *= "+sRHS+";\n");
            _out.append(_sDstVar+" = ((("+_sDstVar+") < 0.0f)?-1.0f:1.0f) * sqrt(abs("+_sDstVar+"));\n");
            break;

         case OP_GMU:
            _out.append(_sDstVar+" = ("+_sDstVar+" * 0.5f) + 0.5f;\n");
            _out.append(_sDstVar+" *= ("+sRHS+" * 0.5f) + 0.5f;\n");
            _out.append(_sDstVar+" = ((("+_sDstVar+") < 0.0f)?-2.0f:2.0f) * sqrt(abs("+_sDstVar+")) - 1.0f;\n");
            break;
      }

      if(null != sVarTmp)
         _script.freeTmpVar(sVarTmp);
   }

   // <method.png>
   public method emitIntTree(CyScript _script, local String _out, local String _sDstVar) {
      if(OP_SKIP == op)
         return;

      local String *sRHS;
      local String *sVarTmp;

      local boolean bHaveSubtree = (null != seq_right) && doEmitRight();
      local boolean bConst = isConstVal();

      // if(1)
      // {
      //    trace "xxx emitIntTree: tree=";
      //    debugPrintTree(0/*level*/);
      // }

      if(/*!bHaveSubtree &&*/ ([OP_AUTO,OP_REP].contains(op)))
      {
         // replace previous output
         sRHS <= _sDstVar;
      }
      else
      {
         // need tmp var ?
         if(!bConst || OP_NONE == op || bHaveSubtree)
         {
            sVarTmp <= _script.allocTmpVarInt(_out, "seq");
            sRHS <= sVarTmp;

            // // // if(OP_NONE == op)
            // // // {
               // initial sub-tree input is previous output
               //  (note) new output will be discarded when op=OP_NONE
               _out.append(sVarTmp+" = "+_sDstVar+";\n");
            // // // }
         }
      }

      if(!bConst || bHaveSubtree)
      {
         // trace "[trc] CyModule::emitIntTree: call emitInt this="+#(this)+" sRHS=\""+sRHS+"\" sDstVar=\""+_sDstVar+"\"";
         emitInt(_script, _out, sRHS);

         if(bHaveSubtree)
            seq_right.emitIntSequence(_script, _out, sRHS);
      }
      else
      {
         // rhs is constant
         sRHS <= String(int(FX_ONE * getConstVal()));
      }

      // // if( ((null == seq_right) || !doEmitRight()) && ([OP_AUTO,OP_REP].contains(op)))
      // //    sVar <= _sDstVar;
      // // else
      // // {
      // //    sVarTmp <= _script.allocTmpVarInt(_out, "seq");
      // //    sVar <= sVarTmp;
      // // }
      // // if(OP_NONE == op)
      // //    _out.append(sVar+" = "+_sDstVar+";\n");
      // // emitInt(_script, _out, sVar);

      // // local boolean bConstHint;
      // // local float fConstHint;

      // // if( (null != seq_right) && doEmitRight() )
      // //    seq_right.emitIntSequence(_script, _out, sVar);
      // // else
      // // {
      // //    bConstHint = isConstVal();
      // //    if(bConstHint)
      // //       fConstHint = getConstVal();
      // // }

      switch(op)
      {
         default:
         case OP_AUTO:
         case OP_REP:
            if(@(sRHS) != @(_sDstVar))
               _out.append(_sDstVar+" = "+sRHS+";\n");
            break;

         case OP_NONE:
            // ignore output
            _out.append("// (ignore last output via \'.\')\n");
            break;

         case OP_ADD:
            _out.append(_sDstVar+" += "+sRHS+";\n");
            break;

         case OP_ADD_SR:
            if(b_plugin)
            {
               if((null == seq_right) && isConstVal())
               {
                  _out.append(_sDstVar+" += "+_script.allocAddSRConstVarInt(getConstVal())+";\n");
               }
               else
               {
                  _out.append(_sDstVar+" += Dmulsw_shr("+sRHS+", voice->sr_factor_int);\n");
                  _script.b_use_sr_factor_int = true;
               }
            }
            else
            {
               if(_script.oversample_factor > 1)
                  _out.append(_sDstVar+" += "+sRHS+" >> "+_script.oversample_factor+";\n");
               else
                  _out.append(_sDstVar+" += "+sRHS+";\n");
            }
            break;

         case OP_SUB:
            _out.append(_sDstVar+" -= "+sRHS+";\n");
            break;

         case OP_RSUB:
            _out.append(_sDstVar+" = "+sRHS+" - "+_sDstVar+";\n");
            break;

         case OP_MUL:
            boolean bMulDone = false;
            if((null == seq_right) && bConst)
            {
               // Replace power of two mul by shift:
               local float fConstHint = getConstVal();
               if(0.0078125 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" >> 7;\n");
                  bMulDone = true;
               }
               else if(0.015625 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" >> 6;\n");
                  bMulDone = true;
               }
               else if(0.03125 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" >> 5;\n");
                  bMulDone = true;
               }
               else if(0.0625 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" >> 4;\n");
                  bMulDone = true;
               }
               else if(0.125 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" >> 3;\n");
                  bMulDone = true;
               }
               else if(0.25 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" >> 2;\n");
                  bMulDone = true;
               }
               else if(0.5 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" >> 1;\n");
                  bMulDone = true;
               }
               else if(1.0 == fConstHint)
               {
                  bMulDone = true;
               }
               else if(2.0 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" << 1;\n");
                  bMulDone = true;
               }
               else if(4.0 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" << 2;\n");
                  bMulDone = true;
               }
               else if(8.0 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" << 3;\n");
                  bMulDone = true;
               }
               else if(16.0 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" << 4;\n");
                  bMulDone = true;
               }
               else if(32.0 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" << 5;\n");
                  bMulDone = true;
               }
               else if(64.0 == fConstHint)
               {
                  _out.append(_sDstVar+" = "+_sDstVar+" << 6;\n");
                  bMulDone = true;
               }
            }
            // trace "xxx int OP_MUL bMulDone="+bMulDone;
            if(!bMulDone)
            {
               if(b_export_c)
                  _out.append(_sDstVar+" = Dmulsw_shr("+_sDstVar+", "+sRHS+");\n");
               else
                  _out.append(_sDstVar+" = ("+_sDstVar+" * "+sRHS+") >> "+FX_SHR+";\n");
            }
            break;

         case OP_MUL_SR:
            if(b_plugin)
            {
               if((null == seq_right) && isConstVal())
               {
                  _out.append(_sDstVar+" = Dmulsw_shr("+_sDstVar+", "+_script.allocMulSRConstVarInt(FX_ONE * getConstVal())+");\n");
               }
               else
               {
                  _out.append(_sDstVar+" = (short)("+_sDstVar+" * powf((float)"+sRHS+", voice->sr_factor));\n");
                  _script.b_use_sr_factor = true;
               }
            }
            else
            {
               if(_script.oversample_factor > 1)
               {
                  if(b_export_c)
                     _out.append(_sDstVar+" = Dmulsw_shr("+_sDstVar+", ("+short_type+")powf((float)"+sRHS+", "+FloatToString(1.0f / _script.oversample_factor)+"));\n");
                  else
                     _out.append(_sDstVar+" = Dmulsw_shr("+_sDstVar+", ("+short_type+")mathPowerf((float)"+sRHS+", "+FloatToString(1.0f / _script.oversample_factor)+"));\n");
               }
               else
                  _out.append(_sDstVar+" *= "+sRHS+";\n");
            }
            break;

         case OP_AND:
            _out.append(_sDstVar+" = "+_sDstVar+" & "+sRHS+";\n");
            break;

         case OP_OR:
            _out.append(_sDstVar+" = "+_sDstVar+" | "+sRHS+";\n");
            break;

         case OP_EOR:
            _out.append(_sDstVar+" = "+_sDstVar+" ^ "+sRHS+";\n");
            break;

         case OP_LAND:
            _out.append(_sDstVar+" = (("+_sDstVar+" > 0) & ("+sRHS+" > 0)) << "+FX_SHR+";\n");
            break;

         case OP_LOR:
            _out.append(_sDstVar+" = (("+_sDstVar+" > 0) | ("+sRHS+" > 0)) << "+FX_SHR+";\n");
            break;

         case OP_LEOR:
            _out.append(_sDstVar+" = (("+_sDstVar+" > 0) ^ ("+sRHS+" > 0)) << "+FX_SHR+";\n");
            break;

         case OP_LNAND:
            _out.append(_sDstVar+" = !(("+_sDstVar+" > 0) & ("+sRHS+" > 0)) << "+FX_SHR+";\n");
            break;

         case OP_LNOR:
            _out.append(_sDstVar+" = !(("+_sDstVar+" > 0) | ("+sRHS+" > 0)) << "+FX_SHR+";\n");
            break;

         case OP_LNEOR:
            _out.append(_sDstVar+" = !(("+_sDstVar+" > 0) ^ ("+sRHS+" > 0)) << "+FX_SHR+";\n");
            break;

         case OP_MIN:
            _out.append(_sDstVar+" = ("+_sDstVar+" < "+sRHS+") ? "+_sDstVar+" : "+sRHS+";\n");
            break;

         case OP_MAX:
            _out.append(_sDstVar+" = ("+_sDstVar+" > "+sRHS+") ? "+_sDstVar+" : "+sRHS+";\n");
            break;

         case OP_ABSMIN:
            _out.append(_sDstVar+" = ("+_sDstVar+" < 0) ? -"+_sDstVar+" : "+_sDstVar+";\n");
            _out.append(sRHS+" = ("+sRHS+" < 0) ? -"+sRHS+" : "+sRHS+";\n");
            _out.append(_sDstVar+" = ("+_sDstVar+" < "+sRHS+") ? "+_sDstVar+" : "+sRHS+";\n");
            break;

         case OP_ABSMAX:
            // (note) ideally: (int) abs(x) = (x + (x >> 31)) ^ (x >> 31)
            _out.append(_sDstVar+" = ("+_sDstVar+" < 0) ? -"+_sDstVar+" : "+_sDstVar+";\n");
            _out.append(sRHS+" = ("+sRHS+" < 0) ? -"+sRHS+" : "+sRHS+";\n");
            _out.append(_sDstVar+" = ("+_sDstVar+" > "+sRHS+") ? "+_sDstVar+" : "+sRHS+";\n");
            break;

         case OP_AM:
         case OP_QM:  // n/a in int mode => revert to float arithmetic mean
         case OP_QMU:
         case OP_HM:
         case OP_HMU:
         case OP_GM:
         case OP_GMU:
            _out.append(_sDstVar+" = ("+_sDstVar+" + "+sRHS+") >> 1;\n");
            break;
      }

      if(null != sVarTmp)
         _script.freeTmpVarInt(sVarTmp);
   }

   // <method.png>
   public method emitFloatSequence(CyScript _script, local String _out, local String _sDstVar) {
      local CyModule c <= this;
      while(null != c)
      {
         _out.append("\n// -- mod=\""+c.getString()+"\" dstVar="+_sDstVar+"\n");

         c.emitFloatTree(_script, _out, _sDstVar);

         c <= c.seq_next;
      }
   }

   // <method.png>
   public method emitIntSequence(CyScript _script, local String _out, local String _sDstVar) {
      local CyModule c <= this;
      while(null != c)
      {
         _out.append("\n// -- mod=\""+c.getString()+"\" dstVar="+_sDstVar+"\n");

         c.emitIntTree(_script, _out, _sDstVar);

         c <= c.seq_next;
      }
   }

   // <method.png>
   public method emitFloat(CyScript _script, local String _out, local String _sDstVar) {
   }

   // <method.png>
   public method emitInt(CyScript _script, local String _out, local String _sDstVar) {
   }

   // <method.png>
   public method emitFloatFallback(CyScript _script, local String _out, local String _sDstVar) {
      local String sVar <= _script.allocTmpVar(_out, "f2i");
      _out.append(sVar+" = (float)("+_sDstVar+") * "+FloatToString(1.0f / FX_ONE)+";  // FloatFallback: I2F\n");
      emitFloat(_script, _out, sVar);
      _out.append(_sDstVar+" = (int)("+sVar+" * "+FX_ONE+");  // FloatFallback: F2I\n");
      parent_script.b_use_float_fallback = true;
      _script.freeTmpVar(sVar);
   }

   // <method.png>
   public method emitIntFallback(CyScript _script, local String _out, local String _sDstVar) {
      local String sVar <= _script.allocTmpVarInt(_out, "i2f");
      _out.append(sVar+" = (int)("+_sDstVar+" * "+FX_ONE+");  // IntFallback: F2I\n");
      emitInt(_script, _out, sVar);
      _out.append(_sDstVar+" = "+sVar+" / ((float)("+FX_ONE+"));  // IntFallback: I2F\n");
      _script.freeTmpVarInt(sVar);
   }
}


// <class.png>
class CyModulePre : CyModule {
   // 'dummy' module that simply returns the previous output (no-op).
   //
   //   (note) must be the first module in a template that reads previous output via an operator, e.g.
   //
   //      def myrev              def myrev
   //        + ~mydly        =>     pre
   //        # not working          + ~mydly
   //
   //   (note) this is currently required due to a parser-issue which may be proper-fixed later
   //
}


// <class.png>
class CyModuleExt : CyModule {
   CyExtMod *ext_mod;

   // <method_get.png>
   public method getString() : String {
      return ext_mod.id;
   }

   // <method_init.png>
   public method initExtFrom(CyExtMod _extMod) {
      CyModule::init();

      ext_mod <= _extMod;

      CyExtModInput *inp;
      foreach inp in ext_mod.inputs
      {
         addInput(inp.id, inp.def_value, 0.0, 1.0);
      }

      CyExtModConfig *cfg;
      foreach cfg in ext_mod.config_items
      {
         CyInput inCfg <= addInput(cfg.id, 0.0f, 0.0f, 1.0f);  // must be const
         // trace "xxx add inCfg id=\""+cfg.id+"\"";
         inCfg.ext_def_value <= cfg.mapConstValue(cfg.def_value);
      }
   }

   // <method_get.png>
   public virtual getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      CyExtModConfig *cfg;
      foreach cfg in ext_mod.config_items
      {
         if(cfg.id == _input)
         {
            if(null != cfg.const_names)
            {
               _retNames  = cfg.const_names;
               _retValues = cfg.const_values;
               return true;
            }
         }
      }
      return false;
   }

   // <method.png>
   protected method emitCodeLines(local String _sOut, local String _sLinePrefix, local StringArray _aLines, local String _sInstance, local String _sVarIOOrNull, local HashTable _htInputVars) {
      local String *sLine;
      CyInput *inp;
      foreach sLine in _aLines
      {
         local String s = sLine;  // create a copy (don't replace vars in template)
         local int idxS = 0;
         for(;;)
         {
            idxS = s.indexOf("%cy", idxS);
            if(idxS >= 0)
            {
               local int idxE = s.indexOfChar('%', idxS+1);
               if(idxE >= 0)
               {
                  local String sVarName <= s.substring(idxS+1, idxE-idxS-1);
                  idxE++;
                  switch(sVarName)
                  {
                     default:
                        if(sVarName <= "cycf_")
                        {
                           sVarName.substring(5, 99);
                           CyExtModConfig cfg <= ext_mod.findConfigItemById(sVarName);
                           if(null != cfg)
                              s.replaceRegion(idxS, idxE, (_sInstance+"_cfg_"+sVarName).toUpper());
                           else
                              trace "[~~~] CyModuleExt::emitCodeLines: unknown config item \""+sVarName+"\"";  // should this be reachable??
                        }
                        else if(sVarName <= "cyin_")
                        {
                           if(null != _htInputVars)
                           {
                              sVarName.substring(5, 99);
                              inp <= findInputById(sVarName);
                              if(null != inp)
                              {
                                 // trace "xxx in:  1 s=\""+s+"\"";
                                 s.replaceRegion(idxS, idxE, _htInputVars.get(inp.id));
                                 // trace "xxx in:  2 s=\""+s+"\"";
                              }
                              else
                                 trace "[~~~] CyModuleExt::emitCodeLines: unknown input \""+sVarName+"\"";  // should this be reachable??
                           }
                           else
                              throw CyError "input not allowed here";
                        }
                        else
                           trace "[~~~] CyModuleExt::emitCodeLines: unknown var \"%"+sVarName+"%\", skipping..";
                        idxS++;
                        break;

                     case "cymod":
                        s.replaceRegion(idxS, idxE, ext_mod.id);
                        break;

                     case "cyid":
                        s.replaceRegion(idxS, idxE, _sInstance);
                        break;

                     case "cyio":
                        s.replaceRegion(idxS, idxE, _sVarIOOrNull);
                        break;

                     case "cycf":
                        // (todo)
                        idxS++;
                        break;

                     case "cyin":
                        idxS = idxE+1;
                        break;
                  }
               }
            } // if idxS >= 0
            else
            {
               _sOut.append(_sLinePrefix);
               _sOut.append(s);
               _sOut.append("\n");
               break;
            }
         } // for(;;)
      } // foreach code line
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      // _out.append(_sDstVar+" = abs("+_sDstVar+");\n");

      if(!b_plugin)
      {
         _out.append("// skipping ext mod \""+ext_mod.id+"\"");
         return;
      }

      String sExtPre          <= parent_script.s_ext_pre;
      String sExtStatic       <= parent_script.s_ext_static;
      String sExtInit         <= parent_script.s_ext_init;
      String sExtNew          <= parent_script.s_ext_new;
      String sExtDelete       <= parent_script.s_ext_delete;
      String sExtNoteOn       <= parent_script.s_ext_noteon;
      String sExtVoice        <= parent_script.s_ext_voice;
      String sExtPrepare      <= parent_script.s_ext_prepare;
      String sExtPrepareFirst <= parent_script.s_ext_prepare_first;
      String sExtPrepareNext  <= parent_script.s_ext_prepare_next;

      local String sLinePrefix;
      local String sInstance <= ext_mod.id+"_"+(parent_script.next_ext_instance_nr++);
      // trace "xxx parent_script.next_ext_instance_nr="+parent_script.next_ext_instance_nr;

      // pre
      sLinePrefix = "";
      emitCodeLines(sExtPre, sLinePrefix, ext_mod.a_pre, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // static
      sLinePrefix = "";
      emitCodeLines(sExtStatic, sLinePrefix, ext_mod.a_static, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // init
      sLinePrefix = "   ";
      emitCodeLines(sExtInit, sLinePrefix, ext_mod.a_init, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // new
      sLinePrefix = "   ";
      emitCodeLines(sExtNew, sLinePrefix, ext_mod.a_new, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // delete
      sLinePrefix = "   ";
      emitCodeLines(sExtDelete, sLinePrefix, ext_mod.a_delete, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // note-on
      sLinePrefix = "      ";
      emitCodeLines(sExtNoteOn, sLinePrefix, ext_mod.a_noteon, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // voice
      sLinePrefix = "   ";
      emitCodeLines(sExtVoice, sLinePrefix, ext_mod.a_voice, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // prepare
      sLinePrefix = "   ";
      emitCodeLines(sExtPrepare, sLinePrefix, ext_mod.a_prepare, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // prepare_first
      sLinePrefix = "      ";
      emitCodeLines(sExtPrepareFirst, sLinePrefix, ext_mod.a_prepare_first, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // prepare_next
      sLinePrefix = "      ";
      emitCodeLines(sExtPrepareNext, sLinePrefix, ext_mod.a_prepare_next, sInstance, null/*sVarIO*/, null/*htInputVars*/);

      // inputs
      CyInput *inp;
      local String *sVarInp;
      local StringArray aVarInp;
      local HashTable htInputVars;
      foreach inp in inputs
      {
         if(null != ext_mod.findConfigItemById(inp.id))
         {
            // const
            // trace "xxx cfg="+inp.id+" isConnected="+inp.isConnected()+" constVal="+inp.getConstVal();
            if(inp.isConnected())
               sExtStatic.append("#define "+((sInstance+"_cfg_"+inp.id).toUpper())+" "+FloatToString(inp.getConstVal())+"\n");
            else
               sExtStatic.append("#define "+((sInstance+"_cfg_"+inp.id).toUpper())+" "+inp.ext_def_value+"\n");
         }
         else
         {
            // dynamic
            // trace "xxx CyModuleExt: alloc dynamic tmp var \""+(sInstance+"_in_"+inp.id)+"\"";
            sVarInp <= _script.allocTmpVar(_out, sInstance+"_in_"+inp.id);
            // trace "xxx sVarInp=\""+sVarInp+"\"";
            inp.emitFloat(_script, _out, sVarInp);
            aVarInp.add(sVarInp);
            htInputVars[inp.id] = deref sVarInp;
         }
      }

      // emit
      sLinePrefix = "";
      emitCodeLines(_out, sLinePrefix, ext_mod.a_emit, sInstance, _sDstVar/*sVarIO*/, htInputVars);

      // free input tmp vars
      foreach sVarInp in aVarInp
      {
         // trace "xxx CyModuleExt: free dynamic tmp var \""+sVarInp+"\"";
         _script.freeTmpVar(sVarInp);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleExt<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }

}


// <class.png>
class CyModuleTemplateCall : CyModule {
   // "init mytemplateinstance"
   // "prepare mytemplateinstance"
   // "calc mytemplateinstance"
   CyTemplateInstance *template_instance;
   CyLane *lane;

   // <method_get.png>
   public virtual getString() : String {
      return "call "+lane.id;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      // trace "xxx CyModuleTemplateCall::emitFloat: lane.id=\""+lane.id+"\" parent_script="+#(parent_script);

      local String buf;
      local int modIdx = 0;
      if(STConfig.b_cycle_tree_debug)
      {
         // trace "[trc] CyModuleTemplateCall::emitFloat: lane.id="+lane.id+" tree=";
         lane.debugPrintTree(0/*level*/);
      }

      local CyModule *mod;
      foreach mod in lane.modules
      {
         buf.append("// ........ template lane \""+lane.id+"\" modIdx="+modIdx+" mod="+mod.getString()+"\n");
         mod.emitFloatSequence(parent_script, buf, _sDstVar);
         modIdx++;
      }

      _out.append(buf);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // trace "xxx CyModuleTemplateCall::emitInt: lane.id=\""+lane.id+"\" parent_script="+#(parent_script);

      local String buf;
      local int modIdx = 0;
      if(STConfig.b_cycle_tree_debug)
      {
         trace "[trc] CyModuleTemplateCall::emitInt: lane.id="+lane.id+" tree=";
         lane.debugPrintTree(0/*level*/);
      }

      local CyModule *mod;
      foreach mod in lane.modules
      {
         buf.append("// ........ template lane \""+lane.id+"\" modIdx="+modIdx+" mod="+mod.getString()+"\n");
         mod.emitIntSequence(parent_script, buf, _sDstVar);
         modIdx++;
      }

      _out.append(buf);
   }
}


// <class.png>
class CyModuleOscSync : CyModule {
   // base class for vsync-able oscillators

   // <method_get.png>
   public virtual getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      switch(_input)
      {
         case "window":
            _retNames  = ["off", "none", "sin", "hs", "tri", "hse1", "hse2", "hse3", "hse4", "hse5"];
            _retValues = [ 0,     0,      1 ,    2,    3,     4,     5,      6,      7,      8     ];
            return true;
      }
      return false;
   }

   // <method.png>
   protected method emitWinHalfSineExp(String _sOut, String _sWin, String _sVarPhaseWin, String _sTbl) {
      _sOut.append(_sWin+" = "+_sTbl+"[(unsigned short)(8192 * "+_sVarPhaseWin+")&8191u];\n");
      parent_script.b_use_sine_tbl = true;
      parent_script.b_use_win_hse  = true;
   }

   // <method.png>
   protected method emitWinHalfSineExpScript(String _sOut, String _sWin, String _sVarPhaseWin, String _sTbl) {
      _sOut.append(_sWin+" = "+_sTbl+"[int(8192 * "+_sVarPhaseWin+")&8191];\n");
      parent_script.b_use_sine_tbl = true;
      parent_script.b_use_win_hse  = true;
   }

   // <method.png>
   protected method emitSyncWindow(local CyScript _script, local CyInput inWindow, int windowType, local String sOut, local String sVarPhaseWin, local String _sDstVar) {
      local String sWin <= _script.allocTmpVar(sOut, "window");
      if(-1 == windowType)
      {
         // custom window function, input is window phase
         sOut.append(sWin+" = "+sVarPhaseWin+";\n");
         inWindow.emitFloat(_script, sOut, sWin);
      }
      else if(b_export_c)
      {
         switch(windowType)
         {
            default:
            case 1:  // sine-sqr
               parent_script.b_use_sine_tbl = true;
               sOut.append(sWin+" = cycle_sine_tbl_f[(unsigned short)(16384 * "+sVarPhaseWin+")&16383u];\n");
               sOut.append(sWin+" *= "+sWin+";\n");
               break;

            case 2:  // half-sine
               parent_script.b_use_sine_tbl = true;
               sOut.append(sWin+" = cycle_sine_tbl_f[(unsigned short)(8192 * "+sVarPhaseWin+")&8191u];\n");
               break;

            case 3:  // tri
               sOut.append(sWin+" = "+sVarPhaseWin+" * 2.0f;\n");
               sOut.append("if("+sWin+" > 1.0f) "+sWin+" = 2.0f - "+sWin+";\n");
               break;

            case 4:  // half-sine exp 1.36
               emitWinHalfSineExp(sOut, sWin, sVarPhaseWin, "cycle_win_hse_1_36");
               parent_script.b_use_win_hse_1_36 = true;
               break;

            case 5:  // half-sine exp 2
               emitWinHalfSineExp(sOut, sWin, sVarPhaseWin, "cycle_win_hse_2");
               parent_script.b_use_win_hse_2 = true;
               break;

            case 6:  // half-sine exp 3
               emitWinHalfSineExp(sOut, sWin, sVarPhaseWin, "cycle_win_hse_3");
               parent_script.b_use_win_hse_3 = true;
               break;

            case 7:  // half-sine exp 5
               emitWinHalfSineExp(sOut, sWin, sVarPhaseWin, "cycle_win_hse_5");
               parent_script.b_use_win_hse_5 = true;
               break;

            case 8:  // half-sine exp 7
               emitWinHalfSineExp(sOut, sWin, sVarPhaseWin, "cycle_win_hse_7");
               parent_script.b_use_win_hse_7 = true;
               break;
         }
      }
      else
      {
         // emit script source
         switch(windowType)
         {
            default:
            case 1:  // sine-sqr
               sOut.append(sWin+" = sin(2PI * "+sVarPhaseWin+");\n");
               sOut.append(sWin+" *= "+sWin+";\n");
               break;

            case 2:  // half-sine
               sOut.append(sWin+" = sin(PI * "+sVarPhaseWin+");\n");
               break;

            case 3:  // tri
               sOut.append(sWin+" = "+sVarPhaseWin+" * 2.0f;\n");
               sOut.append("if("+sWin+" > 1.0f) "+sWin+" = 2.0f - "+sWin+";\n");
               break;

            case 4:  // half-sine exp 1.36
               emitWinHalfSineExpScript(sOut, sWin, sVarPhaseWin, "cycle_win_hse_1_36");
               parent_script.b_use_win_hse_1_36 = true;
               break;

            case 5:  // half-sine exp 2
               emitWinHalfSineExpScript(sOut, sWin, sVarPhaseWin, "cycle_win_hse_2");
               parent_script.b_use_win_hse_2 = true;
               break;

            case 6:  // half-sine exp 3
               emitWinHalfSineExpScript(sOut, sWin, sVarPhaseWin, "cycle_win_hse_3");
               parent_script.b_use_win_hse_3 = true;
               break;

            case 7:  // half-sine exp 5
               emitWinHalfSineExpScript(sOut, sWin, sVarPhaseWin, "cycle_win_hse_5");
               parent_script.b_use_win_hse_5 = true;
               break;

            case 8:  // half-sine exp 7
               emitWinHalfSineExpScript(sOut, sWin, sVarPhaseWin, "cycle_win_hse_7");
               parent_script.b_use_win_hse_7 = true;
               break;
         }
      }
      sOut.append(_sDstVar+" *= "+sWin+";\n");
      _script.freeTmpVar(sWin);
   }
}


// <class.png>
class CyModuleAbs : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         _out.append("{\n");
         _out.append("   stplugin_fi_t t; t.f = "+_sDstVar+";\n");
         _out.append("   t.u &= 0x7FFFffffu;\n");
         _out.append("   "+_sDstVar+" = t.f;\n");
         _out.append("}\n");
      }
      else
      {
         _out.append(_sDstVar+" = abs("+_sDstVar+");\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = ("+_sDstVar+" < 0) ? -"+_sDstVar+" : "+_sDstVar+";\n");
   }
}


// <class.png>
class CyModuleADSR : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("gate",    0.0,   0.0, 1.0);  // rising edge: restart envelope, falling edge: start release phase
      addInput("a",       0.5,   0.0, 1.0);
      addInput("as",     -1.0,  -4.0, 4.0);  // attack shape
      addInput("d",       0.6,   0.0, 1.0);
      addInput("ds",      2.0,  -4.0, 4.0);  // decay shape
      addInput("s",       0.4,   0.0, 1.0);  // sustain level
      addInput("r",       0.6,   0.0, 1.0);
      addInput("rs",      2.0,  -4.0, 4.0);  // release shape
      addInput("reset",   0.0,   0.0, 1.0);  // 1=reset envelope level when note is start ('digital')
      addInput("scl",     0.001, 0.0, 1.0);  // envelope time scaling (e.g. 0.01=suitable for "prepare" (1000Hz rate), 0.001=suitable for audio rate)
      addInput("mode",    0.0,   0.0, 1.0);  // 0=v2 (level based rate shaping)   1=v1 (LLE curve based level shaping)
      addInput("restart", 0.0,   0.0, 1.0);  // rising edge: restart envelope
      addInput("vel",     1,     0,   1  );  // 1=multiply output level by incoming gate level. 0=ignore gate level
      addInput("onend",   0.0, 0,     1  );  // run arbitrary statement block when end of envelope is reached

      addInputAlias("g",  "gate");
      addInputAlias("m",  "mode");
      addInputAlias("v",  "vel");
      addInputAlias("oe", "onend");

      addInputAlias("ashape",  "as");
      addInputAlias("dshape",  "ds");
      addInputAlias("rshape",  "rs");
   }

   // <method.png>
   public method emitFloat_v1(CyScript _script, local String _out, local String _sDstVar) {
      // (note) "mode=1" (alternative)
      // (note) previous output is gate signal
      local CyInput inA       <= findInputById("a");       // segment 0
      local CyInput inAShape  <= findInputById("as");      // segment 0 shape (LLE)
      local CyInput inD       <= findInputById("d");       // segment 1
      local CyInput inDShape  <= findInputById("ds");      // segment 1 shape (LLE)
      local CyInput inS       <= findInputById("s");       // segment 2
      local CyInput inR       <= findInputById("r");       // segment 3
      local CyInput inRShape  <= findInputById("rs");      // segment 3 shape (LLE)
      local CyInput inReset   <= findInputById("reset");   // const
      local CyInput inScl     <= findInputById("scl");     // envelope time scaling
      local CyInput inRestart <= findInputById("restart"); // rising edge restarts envelope
      local CyInput inVel     <= findInputById("vel");     //
      local CyInput inOnEnd   <= findInputById("onend");   //

      local boolean bConstAShape = (inAShape.isConstVal());
      local boolean bConstDShape = (inDShape.isConstVal());
      local boolean bConstRShape = (inRShape.isConstVal());
      local boolean bReset       = (inReset.getConstVal() >= 0.5f);
      local boolean bRestart     = inRestart.isConnected();
      local boolean bVel         = (inVel.getConstVal() >= 0.5f);

      local String sInit;
      local String sVarLastGate   <= _script.allocTmpVarInitVoice(sInit, "adsrv1_last_gate", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarInitVoice(sInit, "adsrv1_last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLevelInt   <= _script.allocTmpVarInitVoice(sInit, "adsrv1_levelint", 0, false/*bCycleReset*/, false/*bVoiceReset*/);  // unshaped level
      local String sVarLevel      <= _script.allocTmpVarInitVoice(sInit, "adsrv1_level", 0, false/*bCycleReset*/, false/*bVoiceReset*/);
      if(bVel)
         local String sVarVel <= _script.allocTmpVarInitVoice(sInit, "adsrv1_vel", 0, false/*bCycleReset*/, false/*bVoiceReset*/);
      local String sVarLastSusLvl <= _script.allocTmpVarInitVoice(sInit, "adsrv1_last_sus_level", 0, false/*bCycleReset*/, false/*bVoiceReset*/);
      local String sVarLastAtkLvl <= _script.allocTmpVarInitVoice(sInit, "adsrv1_last_atk_level", 0, false/*bCycleReset*/, false/*bVoiceReset*/);
      local String sVarSegIdx     <= _script.allocTmpVarIntInitVoice(sInit, "adsrv1_segidx", 4/*done,wait for gate*/, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String sVarRate   <= _script.allocTmpVar(_out, "adsrv1_rate");
      local String sVarSusLvl <= _script.allocTmpVar(_out, "adsrv1_suslvl");

      local String sVarDeltaH <= _script.allocTmpVar(_out, "adsrv1_delta_h");
      local String sVarDeltaN <= _script.allocTmpVar(_out, "adsrv1_delta_n");

      local String *sScl;
      local String  sVarScl;
      sScl <= _script.evalAddSRInput(inScl, _out, sVarScl);
      // // if(inScl.isConstVal())
      // // {
      // //    if(b_plugin)
      // //    {
      // //       sScl <= _script.allocAddSRConstVarFloat(inScl.getConstVal());
      // //    }
      // //    else
      // //    {
      // //       sScl <= FloatToString(inScl.getConstVal() * (1.0f / _script.oversample_factor));
      // //    }
      // // }
      // // else
      // // {
      // //    sVarScl <= _script.allocTmpVar(_out, "adsrv1_scl");
      // //    inScl.emitFloat(_script, _out, sVarScl);
      // //    if(b_plugin)
      // //    {
      // //       _out.append(sVarScl+" *= voice->sr_factor;\n");
      // //       _script.b_use_sr_factor = true;
      // //    }
      // //    else
      // //    {
      // //       if(_script.oversample_factor > 1)
      // //          _out.append(sVarScl+" *= "+FloatToString(1.0f / _script.oversample_factor)+"/*oversample_factor*/;\n");
      // //    }
      // //    sScl <= sVarScl;
      // // }

      inS.emitFloat(_script, _out, sVarSusLvl);

      _out.append(IfRisingEdgeFloat(_sDstVar, sVarLastGate));
      _out.append("{\n");
      // Restart envelope
      if(bVel)
         _out.append("   "+sVarVel+" = "+_sDstVar+";\n");
      if(bReset)
      {
         _out.append("   "+sVarLevelInt+" = 0.0f;\n");
         _out.append("   "+sVarLevel+" = 0.0f;\n");
      }
      // (todo) map sVarLevel back to sVarLevel using attack shape (?) (or apply curve to rates instead of levels)
      _out.append("   "+sVarLastAtkLvl+" = "+sVarLevelInt+";\n");
      _out.append("   "+sVarSegIdx+" = 0;\n");
      _out.append("   "+sVarLastGate+" = 1.0f;\n");
      _out.append("}\n");
      _out.append("else "+IfFallingEdgeFloat(_sDstVar, sVarLastGate));
      // Enter release phase
      _out.append("{\n");
      _out.append("   "+sVarSegIdx+" = 3;\n");
      _out.append("   "+sVarLastGate+" = 0.0f;\n");
      _out.append("   "+sVarLevelInt+" = "+sVarLevel+";\n");
      _out.append("   "+sVarLastSusLvl+" = "+sVarLevel+";\n");  // used by release segment
      _out.append("}\n");

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVar(_out, "adsrv1_restart");
         inRestart.emitFloat(_script, _out, sVarRestart);
         // Rising edge ?
         _out.append(IfRisingEdgeFloat(sVarRestart, sVarLastRestart));
         // // _out.append("if("+sVarRestart+" > 0.5f && "+sVarLastRestart+" < 0.5f)\n");
         _out.append("{\n");
         // Restart envelope
         if(bVel)
            _out.append("   "+sVarVel+" = "+sVarRestart+";\n");
         if(bReset)
         {
            // (todo) map sVarLevel back to sVarLevel using attack shape (?) (or apply curve to rates instead of levels)
            _out.append("   "+sVarLevelInt+" = 0.0f;\n");
            _out.append("   "+sVarLevel+" = 0.0f;\n");
         }
         _out.append("   "+sVarLastAtkLvl+" = "+sVarLevelInt+";\n");
         _out.append("   "+sVarSegIdx+" = 0;\n");
         _out.append("   "+sVarLastGate+" = 1.0f;\n");
         _out.append("}\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
         _script.freeTmpVar(sVarRestart);
      }

      local String sIndent;

      // Segment switch
      _out.append("switch("+sVarSegIdx+")\n");
      _out.append("{\n");
      _out.append("   case 0: // a\n");
      sIndent.empty();
      inA.emitFloat(_script, sIndent, sVarRate);
      CyScript.AppendIndentedLines(_out, sIndent, 6);
      _out.append("      "+sVarLevelInt+" += "+sVarRate+" * "+sScl+";\n");
      _out.append("      if("+sVarLevelInt+" >= 1.0f)\n");
      _out.append("      {\n");
      _out.append("         "+sVarLevel+" = 1.0f;\n");
      _out.append("         "+sVarLevelInt+" = 1.0f;\n");
      _out.append("         "+sVarSegIdx+"++;\n");
      _out.append("      }\n");
      _out.append("      else\n");
      _out.append("      {\n");
      if( !bConstAShape || (0.0f != inAShape.getConstVal()) )
      {
         // Apply decay shape
         parent_script.b_use_lle = true;
         _out.append("         "+sVarDeltaH+" = ("+sVarLevelInt+" - "+sVarLastAtkLvl+");\n");
         _out.append("         "+sVarDeltaN+" = (1.0f != "+sVarLastAtkLvl+") ? ("+sVarDeltaH+" / (1.0f - "+sVarLastAtkLvl+")) : "+sVarDeltaH+";\n");
         if(bConstDShape)
         {
            _out.append("         "+sVarDeltaN+" = mathLogLinExpf("+sVarDeltaN+", "+FloatToString(inAShape.getConstVal())+");\n");
         }
         else
         {
            local String sVarAShapeC <= _script.allocTmpVar(_out, "adsrv1_ashape_c");
            sIndent.empty();
            inAShape.emitFloat(_script, sIndent, sVarAShapeC);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            _out.append("         "+sVarDeltaN+" = mathLogLinExpf("+sVarDeltaN+", "+sVarAShapeC+");\n");
            _script.freeTmpVar(sVarAShapeC);
         }
         _out.append("         "+sVarLevel+" = "+sVarLastAtkLvl+" + "+sVarDeltaN+" * "+sVarDeltaH+";\n");

         // // Apply attack shape
         // parent_script.b_use_lle = true;
         // if(bConstAShape)
         // {
         //    _out.append("         "+sVarLevel+" = mathLogLinExpf("+sVarLevelInt+", "+FloatToString(inAShape.getConstVal())+");\n");
         // }
         // else
         // {
         //    local String sVarAShapeC <= _script.allocTmpVar(_out, "ashape_c");
         //    sIndent.empty();
         //    inAShape.emitFloat(_script, sIndent, sVarAShapeC);
         //    CyScript.AppendIndentedLines(_out, sIndent, 9);
         //    _out.append("         "+sVarLevel+" = mathLogLinExpf("+sVarLevelInt+", "+sVarAShapeC+");\n");
         //    _script.freeTmpVar(sVarAShapeC);
         // }
      }
      else
      {
         // Linear
         _out.append("   "+sVarLevel+" = "+sVarLevelInt+";\n");
      }
      _out.append("      }\n");
      _out.append("      break;\n");
      _out.append("\n");
      _out.append("   case 1: // d\n");
      sIndent.empty();
      inD.emitFloat(_script, sIndent, sVarRate);
      CyScript.AppendIndentedLines(_out, sIndent, 6);
      _out.append("      "+sVarLevelInt+" -= "+sVarRate+" * "+sScl+";\n");
      _out.append("      if("+sVarLevelInt+" <= "+sVarSusLvl+")\n");
      _out.append("      {\n");
      _out.append("         "+sVarLevel+" = "+sVarSusLvl+";\n");
      _out.append("         "+sVarLevelInt+" = "+sVarSusLvl+";\n");
      _out.append("         "+sVarSegIdx+"++;\n");
      _out.append("      }\n");
      _out.append("      else\n");
      _out.append("      {\n");
      if( !bConstDShape || (0.0f != inDShape.getConstVal()) )
      {
         // Apply decay shape
         parent_script.b_use_lle = true;
         _out.append("         "+sVarDeltaH+" = ("+sVarLevelInt+" - "+sVarSusLvl+");\n");
         _out.append("         "+sVarDeltaN+" = (1.0f != "+sVarSusLvl+") ? ("+sVarDeltaH+" / (1.0f - "+sVarSusLvl+")) : "+sVarDeltaH+";\n");
         if(bConstDShape)
         {
            _out.append("         "+sVarDeltaN+" = mathLogLinExpf("+sVarDeltaN+", "+FloatToString(inDShape.getConstVal())+");\n");
         }
         else
         {
            local String sVarDShapeC <= _script.allocTmpVar(_out, "adsrv1_dshape_c");
            sIndent.empty();
            inDShape.emitFloat(_script, sIndent, sVarDShapeC);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            _out.append("         "+sVarDeltaN+" = mathLogLinExpf("+sVarDeltaN+", "+sVarDShapeC+");\n");
            _script.freeTmpVar(sVarDShapeC);
         }
         _out.append("         "+sVarLevel+" = "+sVarSusLvl+" + "+sVarDeltaN+" * "+sVarDeltaH+";\n");
      }
      else
      {
         // Linear
         _out.append("   "+sVarLevel+" = "+sVarLevelInt+";\n");
      }
      _out.append("      }\n");
      _out.append("      break;\n");
      _out.append("\n");
      _out.append("   case 2: // s\n");
      // Wait for note off
      // // _out.append("      "+sVarLastSusLvl+" = "+sVarSusLvl+";\n");
      _out.append("      "+sVarLevel+" = "+sVarSusLvl+";\n");
      _out.append("      break;\n");
      _out.append("\n");
      _out.append("   case 3: // r\n");
      sIndent.empty();
      inR.emitFloat(_script, sIndent, sVarRate);
      CyScript.AppendIndentedLines(_out, sIndent, 6);
      _out.append("      "+sVarLevelInt+" -= "+sVarRate+" * "+sScl+";\n");
      _out.append("      if("+sVarLevelInt+" <= 0.0f)\n");
      _out.append("      {\n");
      _out.append("         "+sVarLevel+" = 0.0f;\n");
      _out.append("         "+sVarLevelInt+" = 0.0f;\n");
      _out.append("         "+sVarSegIdx+"++;\n");

      if(inOnEnd.isConnected())
      {
         local String sVarTmpOnEnd <= _script.allocTmpVar(_out, "adsrv1_tmp_onend");
         sIndent.empty();
         inOnEnd.emitFloat(_script, sIndent, sVarTmpOnEnd);
         CyScript.AppendIndentedLines(_out, sIndent, 9);
         _script.freeTmpVar(sVarTmpOnEnd);
      }

      _out.append("      }\n");
      if( !bConstRShape || (0.0f != inRShape.getConstVal()) )
      {
         // Apply release shape
         parent_script.b_use_lle = true;
         _out.append("         "+sVarDeltaH+" = ("+sVarLevelInt+"/* - 0.0f*/);\n");
         _out.append("         "+sVarDeltaN+" = (0.0f != "+sVarLastSusLvl+") ? ("+sVarDeltaH+" / "+sVarLastSusLvl+") : "+sVarDeltaH+";\n");
         if(bConstRShape)
         {
            _out.append("         "+sVarDeltaN+" = mathLogLinExpf("+sVarDeltaN+", "+FloatToString(inRShape.getConstVal())+");\n");
         }
         else
         {
            local String sVarRShapeC <= _script.allocTmpVar(_out, "adsrv1_rshape_c");
            sIndent.empty();
            inRShape.emitFloat(_script, sIndent, sVarRShapeC);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            if(0 && b_export_c)
            {
               _out.append("printf(\"xxx 1 sVarDeltaN=%f sVarRShapeC=%f sVarDeltaH=%f\\n\", "+sVarDeltaN+", "+sVarRShapeC+", "+sVarDeltaH+");\n");
            }
            _out.append("         "+sVarDeltaN+" = mathLogLinExpf("+sVarDeltaN+", "+sVarRShapeC+");\n");
            if(0 && b_export_c)
            {
               _out.append("printf(\"xxx 2 sVarDeltaN=%f sVarRShapeC=%f\\n\", "+sVarDeltaN+", "+sVarRShapeC+");\n");
            }
            _script.freeTmpVar(sVarRShapeC);
         }
         _out.append("         "+sVarLevel+" = "+sVarDeltaN+" * "+sVarDeltaH+";\n");
      }
      else
      {
         // Linear
         _out.append("   "+sVarLevel+" = "+sVarLevelInt+";\n");
      }
      _out.append("      break;\n");
      _out.append("\n");
      _out.append("   default:\n");
      _out.append("   case 4: // <end>\n");
      _out.append("      break;\n");
      _out.append("}\n");
      if(0 && b_export_c)
      {
         _out.append("printf(\"xxx segIdx=%d gate=%f lastGate=%f lastSusLvl=%f levelInt=%f level=%f\\n\", "+sVarSegIdx+", "+_sDstVar+", "+sVarLastGate+", "+sVarLastSusLvl+", "+sVarLevelInt+", "+sVarLevel+");\n");
         _script.b_use_trc = true;
      }
      if(bVel)
         _out.append(_sDstVar+" = "+sVarLevel+" * "+sVarVel+";\n");
      else
         _out.append(_sDstVar+" = "+sVarLevel+";\n");

      if(!sVarScl.isBlank())
         _script.freeTmpVar(sVarScl);

      _script.freeTmpVar(sVarRate);
      _script.freeTmpVar(sVarSusLvl);
      _script.freeTmpVar(sVarDeltaH);
      _script.freeTmpVar(sVarDeltaN);
   }

   // <method.png>
   public method emitFloat_v2(CyScript _script, local String _out, local String _sDstVar) {
      // (note) "mode=0" / default
      // (note) level based rate shaping

      // (note) previous output is gate signal
      local CyInput inA       <= findInputById("a");       // segment 0
      local CyInput inAShape  <= findInputById("as");      // segment 0 shape (>0: multiply, <0: divide)
      local CyInput inD       <= findInputById("d");       // segment 1
      local CyInput inDShape  <= findInputById("ds");      // segment 1 shape
      local CyInput inS       <= findInputById("s");       // segment 2
      local CyInput inR       <= findInputById("r");       // segment 3
      local CyInput inRShape  <= findInputById("rs");      // segment 3 shape
      local CyInput inReset   <= findInputById("reset");   // const
      local CyInput inScl     <= findInputById("scl");     // const
      local CyInput inRestart <= findInputById("restart"); // rising edge restarts envelope
      local CyInput inVel     <= findInputById("vel");     //
      local CyInput inOnEnd   <= findInputById("onend");   //

      local boolean bConstAShape = (inAShape.isConstVal());
      local boolean bConstDShape = (inDShape.isConstVal());
      local boolean bConstRShape = (inRShape.isConstVal());
      local boolean bReset       = (inReset.getConstVal() >= 0.5);
      local boolean bVel         = (inVel.getConstVal() >= 0.5f);

      local boolean bRestart = inRestart.isConnected();

      local String sInit;
      local String sVarLastGate   <= _script.allocTmpVarInitVoice(sInit, "adsrv2_last_gate", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarInitVoice(sInit, "adsrv2_last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLevel      <= _script.allocTmpVarInitVoice(sInit, "adsrv2_level", 0, false/*bCycleReset*/, false/*bVoiceReset*/);
      local String sVarSegIdx     <= _script.allocTmpVarIntInitVoice(sInit, "adsrv2_segidx", 4/*done,wait for gate*/, true/*bCycleReset*/, true/*bVoiceReset*/);
      if(bVel)
         local String sVarVel <= _script.allocTmpVarInitVoice(sInit, "adsrv2_vel", 0, false/*bCycleReset*/, false/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String sVarRate   <= _script.allocTmpVar(_out, "adsrv2_rate");
      local String sVarSusLvl <= _script.allocTmpVar(_out, "adsrv2_suslvl");

      local String sVarShape <= _script.allocTmpVar(_out, "adsrv2_shape");
      local String *sShape;

      local String *sScl;
      local String  sVarScl;
      sScl <= _script.evalAddSRInput(inScl, _out, sVarScl);

      inS.emitFloat(_script, _out, sVarSusLvl);

      _out.append(IfRisingEdgeFloat(_sDstVar, sVarLastGate));
      _out.append("{\n");
      // Restart envelope
      if(bVel)
         _out.append("   "+sVarVel+" = "+_sDstVar+";\n");
      if(bReset)
         _out.append("   "+sVarLevel+" = 0.0f;\n");
      _out.append("   "+sVarSegIdx+" = 0;\n");
      _out.append("   "+sVarLastGate+" = 1.0f;\n");
      _out.append("}\n");
      _out.append("else "+IfFallingEdgeFloat(_sDstVar, sVarLastGate));
      // Enter release phase
      _out.append("{\n");
      _out.append("   "+sVarSegIdx+" = 3;\n");
      _out.append("   "+sVarLastGate+" = 0.0f;\n");
      _out.append("}\n");

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVar(_out, "adsrv2_restart");
         inRestart.emitFloat(_script, _out, sVarRestart);
         // Rising edge ?
         _out.append(IfRisingEdgeFloat(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         // Restart envelope
         if(bVel)
            _out.append("   "+sVarVel+" = "+sVarRestart+";\n");
         if(bReset)
            _out.append("   "+sVarLevel+" = 0.0f;\n");
         _out.append("   "+sVarSegIdx+" = 0;\n");
         _out.append("   "+sVarLastGate+" = 1.0f;\n");
         _out.append("}\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
         _script.freeTmpVar(sVarRestart);
      }

      local String sIndent;

      // Segment switch
      _out.append("switch("+sVarSegIdx+")\n");
      _out.append("{\n");

      // ---- Attack ----
      _out.append("   case 0: // a\n");
      sIndent.empty();
      inA.emitFloat(_script, sIndent, sVarRate);
      CyScript.AppendIndentedLines(_out, sIndent, 6);
      if(0 && b_plugin)
      {
         _out.append("      printf(\"xxx rate=%f\\n\", "+sVarRate+");\n");
         _script.b_use_trc = true;
      }
      _out.append("      if("+sVarRate+" < 1.0f)\n");
      _out.append("      {\n");
      if( !bConstAShape || (0.0f != inAShape.getConstVal()) )
      {
         // Attack shape
         if(bConstAShape)
         {
            sShape <= String(inAShape.getConstVal());
         }
         else
         {
            sIndent.empty();
            inAShape.emitFloat(_script, sIndent, sVarShape);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            sShape <= sVarShape;
         }
         _out.append("         if("+sShape+" > 0.0f)\n");
         _out.append("         {\n");
         _out.append("            "+sVarRate+" *= 0.001f + mathPowerf("+sVarLevel+", "+sShape+");\n");
         _out.append("         }\n");
         _out.append("         else if("+sShape+" < 0.0f)\n");
         _out.append("         {\n");
         _out.append("            "+sVarRate+" *= 1.0f / (0.001f + mathPowerf("+sVarLevel+", -("+sShape+")));\n");
         _out.append("         }\n");
         _script.b_use_pow = true;
      }
      // else Linear
      _out.append("         "+sVarLevel+" += "+sVarRate+" * "+sScl+";\n");
      _out.append("         if("+sVarLevel+" >= 1.0f)\n");
      _out.append("         {\n");
      _out.append("            "+sVarLevel+" = 1.0f;\n");
      _out.append("            "+sVarSegIdx+"++;\n");
      _out.append("         }\n");
      _out.append("      }\n");
      _out.append("      else\n");
      _out.append("      {\n");
      // special case: immediate attack
      _out.append("         "+sVarLevel+" = 1.0f;\n");
      _out.append("         "+sVarSegIdx+"++;\n");
      _out.append("      }\n");
      _out.append("      break;\n");
      _out.append("\n");

      // ---- Decay ----
      _out.append("   case 1: // d\n");
      sIndent.empty();
      inD.emitFloat(_script, sIndent, sVarRate);
      CyScript.AppendIndentedLines(_out, sIndent, 6);
      if( !bConstDShape || (0.0f != inDShape.getConstVal()) )
      {
         // Decay shape
         if(bConstDShape)
         {
            sShape <= String(inDShape.getConstVal());
         }
         else
         {
            sIndent.empty();
            inDShape.emitFloat(_script, sIndent, sVarShape);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            sShape <= sVarShape;
         }
         _out.append("      if("+sShape+" > 0.0f)\n");
         _out.append("      {\n");
         _out.append("         "+sVarRate+" *= 0.001f + mathPowerf("+sVarLevel+", "+sShape+");\n");
         _out.append("      }\n");
         _out.append("      else if("+sShape+" < 0.0f)\n");
         _out.append("      {\n");
         _out.append("         "+sVarRate+" *= 1.0f / (0.001f + mathPowerf("+sVarLevel+", -("+sShape+")));\n");
         _out.append("      }\n");
         _script.b_use_pow = true;
      }
      // else Linear
      _out.append("      "+sVarLevel+" -= "+sVarRate+" * "+sScl+";\n");
      _out.append("      if("+sVarLevel+" <= "+sVarSusLvl+")\n");
      _out.append("      {\n");
      _out.append("         "+sVarLevel+" = "+sVarSusLvl+";\n");
      _out.append("         "+sVarSegIdx+"++;\n");
      _out.append("      }\n");
      _out.append("      break;\n");
      _out.append("\n");
      _out.append("   case 2: // s\n");
      // Wait for note off
      _out.append("      "+sVarLevel+" = "+sVarSusLvl+";\n");
      _out.append("      break;\n");
      _out.append("\n");
      _out.append("   case 3: // r\n");
      sIndent.empty();
      inR.emitFloat(_script, sIndent, sVarRate);
      CyScript.AppendIndentedLines(_out, sIndent, 6);
      if( !bConstRShape || (0.0f != inRShape.getConstVal()) )
      {
         // Release shape
         if(bConstRShape)
         {
            sShape <= String(inRShape.getConstVal());
         }
         else
         {
            sIndent.empty();
            inRShape.emitFloat(_script, sIndent, sVarShape);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            sShape <= sVarShape;
         }
         _out.append("      if("+sShape+" > 0.0f)\n");
         _out.append("      {\n");
         _out.append("         "+sVarRate+" *= 0.001f + mathPowerf("+sVarLevel+", "+sShape+");\n");
         _out.append("      }\n");
         _out.append("      else if("+sShape+" < 0.0f)\n");
         _out.append("      {\n");
         _out.append("         "+sVarRate+" *= 1.0f / (0.001f + mathPowerf("+sVarLevel+", -("+sShape+")));\n");
         _out.append("      }\n");
         _script.b_use_pow = true;
      }
      // else Linear
      _out.append("      "+sVarLevel+" -= "+sVarRate+" * "+sScl+";\n");
      _out.append("      if("+sVarLevel+" <= 0.0f)\n");
      _out.append("      {\n");
      _out.append("         "+sVarLevel+" = 0.0f;\n");
      _out.append("         "+sVarSegIdx+"++;\n");
      if(inOnEnd.isConnected())
      {
         local String sVarTmpOnEnd <= _script.allocTmpVar(_out, "adsrv2_tmp_onend");
         sIndent.empty();
         inOnEnd.emitFloat(_script, sIndent, sVarTmpOnEnd);
         CyScript.AppendIndentedLines(_out, sIndent, 9);
         _script.freeTmpVar(sVarTmpOnEnd);
      }
      _out.append("      }\n");
      _out.append("      break;\n");
      _out.append("\n");
      _out.append("   default:\n");
      _out.append("   case 4: // <end>\n");
      _out.append("      break;\n");
      _out.append("}\n");

      if(0 && b_export_c)
      {
         _out.append("printf(\"xxx segIdx=%d gate=%f lastGate=%f level=%f\\n\", "+sVarSegIdx+", "+_sDstVar+", "+sVarLastGate+", "+sVarLevel+");\n");
         _script.b_use_trc = true;
      }

      if(bVel)
         _out.append(_sDstVar+" = "+sVarLevel+" * "+sVarVel+";\n");
      else
         _out.append(_sDstVar+" = "+sVarLevel+";\n");

      if(!sVarScl.isBlank())
         _script.freeTmpVar(sVarScl);

      _script.freeTmpVar(sVarRate);
      _script.freeTmpVar(sVarSusLvl);
      _script.freeTmpVar(sVarShape);
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inMode <= findInputById("mode");     // const

      if(inMode.getConstVal() >= 0.5f)
         emitFloat_v1(_script, _out, _sDstVar);  // larger, (minor) restart issues, more precise curve handling (shape is independent of rate)
      else
         emitFloat_v2(_script, _out, _sDstVar);  // smaller, no restart level-mapping issues, rate shaping (mutually dependent rate+shape params) [default]
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleADSR<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleApf : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("c",     0.0, -1.0, 1.0);
      addInput("freq",  1.0,  0.0, 1.0);  // normalized frequency

      addInputAlias("f", "freq");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inC    <= findInputById("c");
      local CyInput inFreq <= findInputById("freq");

      local String sInit;
      local String sVarState <= _script.allocTmpVarInit(sInit, "apf_state", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sVarTmp <= _script.allocTmpVar(_out, "apf_tmp");
      local String *sVarC;
      local String *sC;

      if(inFreq.isConnected())
      {
         // ---- float tan_val = tanf(M_PI * normalizedFrequency);
         // ---- c = (1.0f - tan_val) / (1.0f + tan_val);

         if(inFreq.isConstVal())
         {
            // compile time coefficient calculcation
            float fTan = tan(PI * inFreq.getConstVal() * 0.5f);
            sC <= FloatToString( (1.0f - fTan) / (1.0f + fTan) );
         }
         else
         {
            // run time coefficient calculcation
            local String sVarFreq <= _script.allocTmpVar(_out, "apf_freq");  // (note) could use sVarTmp
            inFreq.emitFloat(_script, _out, sVarFreq);
            if(b_export_c)
               _out.append(sVarTmp+" = tanf("+FloatToString(PI * 0.5f)+" * "+sVarFreq+");\n");
            else
               _out.append(sVarTmp+" = tan((PI*0.5f) * "+sVarFreq+");\n");
            _script.freeTmpVar(sVarFreq);

            sVarC <= _script.allocTmpVar(_out, "apf_c");
            _out.append("if(-1.0f != "+sVarTmp+")\n");
            _out.append("   "+sVarC+" = (1.0f - "+sVarTmp+") / (1.0f + "+sVarTmp+");\n");
            _out.append("else\n");
            _out.append("   "+sVarC+" = 1.0f;\n");  // => invalid freq   (1+0.9999)/(1-0.9999)=~20000
            // clip to -1..1
            _out.append("if("+sVarC+" > 1.0f) "+sVarC+" = 1.0f;\n");
            _out.append("else if("+sVarC+" < -1.0f) "+sVarC+" = -1.0f;\n");
            sC <= sVarC;
         }
      }
      else
      {
         // use coefficient instead of frequency input
         if(inC.isConstVal())
         {
            sC <= FloatToString(inC.getConstVal());
         }
         else
         {
            sVarC <= _script.allocTmpVar(_out, "apf_c");
            inC.emitFloat(_script, _out, sVarC);
            // clip to -1..1
            _out.append("if("+sVarC+" > 1.0f) "+sVarC+" = 1.0f;\n");
            _out.append("else if("+sVarC+" < -1.0f) "+sVarC+" = -1.0f;\n");
            sC <= sVarC;
         }
      }

      // ---- float out = state + c * _in;
      // ---- state = _in - c * out;
      _out.append(sVarTmp+" = "+sVarState+" + "+sC+" * "+_sDstVar+";\n");
      _out.append(sVarState+" = "+_sDstVar+" - "+sC+" * "+sVarTmp+";\n");
      _out.append(_sDstVar+" = "+sVarTmp+";\n");

      if(null != sVarC)
         _script.freeTmpVar(sVarC);

      _script.freeTmpVar(sVarTmp);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inC    <= findInputById("c");
      local CyInput inFreq <= findInputById("freq");

      local String sInit;
      local String sVarState <= _script.allocTmpVarIntInit(sInit, "apf_state", 0, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sVarTmp <= _script.allocTmpVarInt(_out, "apf_tmp");
      local String *sVarC;
      local String *sC;

      if(inFreq.isConnected())
      {
         // ---- float tan_val = tanf(M_PI * normalizedFrequency);
         // ---- c = (1.0f - tan_val) / (1.0f + tan_val);

         if(inFreq.isConstVal())
         {
            // compile time coefficient calculcation
            float fTan = tan(PI * inFreq.getConstVal() * 0.5f);
            sC <= String(int(FX_ONE * ( (1.0f - fTan) / (1.0f + fTan) )));
         }
         else
         {
            // run time coefficient calculcation
            trace "[~~~] warning: CyModuleApf<int>: falling back to float (dynamic freq input)..";
            emitFloatFallback(_script, _out, _sDstVar);
            return;
         }
      }
      else
      {
         // use coefficient instead of frequency input
         if(inC.isConstVal())
         {
            sC <= String(int(FX_ONE * inC.getConstVal()));
         }
         else
         {
            sVarC <= _script.allocTmpVar(_out, "apf_c");
            inC.emitInt(_script, _out, sVarC);
            // clip to -1..1
            _out.append("if("+sVarC+" > "+FX_ONE+") "+sVarC+" = "+FX_ONE+";\n");
            _out.append("else if("+sVarC+" < -"+FX_ONE+") "+sVarC+" = -"+FX_ONE+";\n");
            sC <= sVarC;
         }
      }

      // ---- float out = state + c * _in;
      // ---- state = _in - c * out;
      _out.append(sVarTmp+" = "+sVarState+" + Dmulsw_shr("+sC+", "+_sDstVar+");\n");
      _out.append(sVarState+" = "+_sDstVar+" - Dmulsw_shr("+sC+", "+sVarTmp+");\n");
      _out.append(_sDstVar+" = "+sVarTmp+";\n");

      if(null != sVarC)
         _script.freeTmpVarInt(sVarC);

      _script.freeTmpVarInt(sVarTmp);
   }
}


// <class.png>
class CyModuleBit : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("shift", 0.0, 0.0, 1.0);

      addInputAlias("s", "shift");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inShift <= findInputById("shift");
      local String sVarShift <= _script.allocTmpVar(_out, "bit_shift");
      inShift.emitFloat(_script, _out, sVarShift);
      _out.append(_sDstVar+" = ((((int)("+_sDstVar+"*32767)) >> ((int)("+sVarShift+" * 15 + 0.5))) << ((int)("+sVarShift+" * 15 + 0.5))) * (1.0f/32767.0f);\n");
      _script.freeTmpVar(sVarShift);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inShift <= findInputById("shift");

      if(inShift.isConstVal())
      {
         int iShift = int(inShift.getConstVal() * 15);
         _out.append(_sDstVar+" = ("+_sDstVar+" >> "+iShift+") << "+iShift+";\n");
      }
      else
      {
         local String sVarShift <= _script.allocTmpVarInt(_out, "bit_shift");
         inShift.emitInt(_script, _out, sVarShift);
         _out.append(sVarShift+" = "+sVarShift+" >> "+FX_SHR+";\n");
         _out.append(_sDstVar+" = ("+_sDstVar+" >> "+iShift+") << "+iShift+";\n");
         _script.freeTmpVarInt(sVarShift);
      }
   }
}


// <class.png>
class CyModuleBoo : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("amount", 0.0, 0.0, 1.0);
      addInput("sr",     1.0, 0.0, 1.0);

      addInputAlias("amt", "amount");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSR   <= findInputById("sr");
      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String sInit;
      local String sVarLast <= _script.allocTmpVarInit(sInit, "boo_last", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sTmp <= _script.allocTmpVar(_out, "boo_tmp");

      local CyInput inAmount <= findInputById("amount");
      _out.append(sTmp+" = "+sVarLast+";\n");
      _out.append(sVarLast+" = "+_sDstVar+";\n");

      if(inAmount.isConstVal())
      {
         float fAmount = (inAmount.getConstVal() * 16.0f);

         if(bSR)
         {
            if(b_plugin)
               _out.append(_sDstVar+" += ("+_sDstVar+" - "+sTmp+") * "+_script.allocAddSRConstVarFloat(fAmount)+";\n");
            else
               _out.append(_sDstVar+" += ("+_sDstVar+" - "+sTmp+") * "+FloatToString(fAmount / _script.oversample_factor)+";\n");
         }
         else
         {
            _out.append(_sDstVar+" += ("+_sDstVar+" - "+sTmp+") * "+FloatToString(fAmount)+";\n");
         }
      }
      else
      {
         local String sVarAmount <= _script.allocTmpVar(_out, "amount");
         inAmount.emitFloat(_script, _out, sVarAmount);

         if(bSR)
         {
            if(b_plugin)
               _out.append(_sDstVar+" += ("+_sDstVar+" - "+sTmp+") * ("+_script.allocAddSRConstVarFloat(16.0f)+" * "+sVarAmount+");\n");
            else
               _out.append(_sDstVar+" += ("+_sDstVar+" - "+sTmp+") * ("+FloatToString(16.0f / _script.oversample_factor)+" * "+sVarAmount+");\n");
         }
         else
            _out.append(_sDstVar+" += ("+_sDstVar+" - "+sTmp+") * (16.0f * "+sVarAmount+");\n");

         _script.freeTmpVar(sVarAmount);
      }
      _script.freeTmpVar(sTmp);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSR   <= findInputById("sr");
      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);
      if(bSR)
      {
         trace "[~~~] warning: CyModuleBoo<int,sr>: falling back to float..";
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      local String sInit;
      local String sVarLast <= _script.allocTmpVarIntInit(sInit, "boo_last", 0, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sTmp <= _script.allocTmpVarInt(_out, "boo_tmp");

      local CyInput inAmount <= findInputById("amount");
      _out.append(sTmp+" = "+sVarLast+";\n");
      _out.append(sVarLast+" = "+_sDstVar+";\n");
      if(inAmount.isConstVal())
      {
         int iAmount = int(inAmount.getConstVal() * FX_ONE);
         if(b_export_c)
            _out.append(_sDstVar+" += mulsw(((short)("+_sDstVar+" - "+sTmp+")), "+iAmount+") >> ("+FX_SHR+" - 4);\n");
         else
            _out.append(_sDstVar+" += (("+_sDstVar+" - "+sTmp+") * "+iAmount+") >> ("+FX_SHR+" - 4);\n");
      }
      else
      {
         local String sVarAmount <= _script.allocTmpVarInt(_out, "amount");
         inAmount.emitInt(_script, _out, sVarAmount);
         if(b_export_c)
            _out.append(_sDstVar+" += mulsw(((short)("+_sDstVar+" - "+sTmp+")), "+sVarAmount+") >> ("+FX_SHR+" - 4);\n");
         else
            _out.append(_sDstVar+" += (("+_sDstVar+" - "+sTmp+") * "+sVarAmount+") >> ("+FX_SHR+" - 4);\n");
         _script.freeTmpVarInt(sVarAmount);
      }
      _script.freeTmpVarInt(sTmp);
   }
}


// <class.png>
class CyModuleBox : CyModule {
   // simple but fast box filter
   //  (note) 'flt' is an alias for 'box'

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq", 0.5, 0.0, 1.0);
      addInput("sr",   1.0, 0.0, 1.0);  // 1=factor in samplerate (must be const)

      addInputAlias("f", "freq");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inFreq <= findInputById("freq");
      local CyInput inSR   <= findInputById("sr");

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String sInit;
      local String sVarLast <= _script.allocTmpVarInit(sInit, "box_last", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      if(inFreq.isConstVal())
      {
         float fFreq = inFreq.getConstVal();
         fFreq *= fFreq;
         fFreq *= fFreq;
         if(bSR)
         {
            if(b_plugin)
               _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+_script.allocAddSRConstVarFloat(fFreq)+");\n");
            else if(_script.oversample_factor > 1)
               _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+FloatToString(fFreq * (1.0f / _script.oversample_factor))+");\n");
            else
               _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+FloatToString(fFreq)+");\n");
         }
         else
         {
            _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+FloatToString(fFreq)+");\n");
         }
      }
      else
      {
         local String sVarFreq <= _script.allocTmpVar(_out, "freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         _out.append(sVarFreq+" *= "+sVarFreq+";\n");
         _out.append(sVarFreq+" *= "+sVarFreq+";\n");

         if(bSR)
         {
            if(b_plugin)
            {
               _out.append(sVarFreq+" *= "+_script.allocAddSRConstVarFloat(1.0f)+";\n");
               _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+");\n");
            }
            else
            {
               if(_script.oversample_factor > 1)
                  _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+" * "+FloatToString(1.0f / _script.oversample_factor)+");\n");
               else
                  _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+");\n");
            }
         }
         else
         {
            _out.append(_sDstVar+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+");\n");
         }

         _script.freeTmpVar(sVarFreq);
      }
      _out.append(sVarLast+" = "+_sDstVar+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSR   <= findInputById("sr");
      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);
      if(bSR)
      {
         trace "[~~~] warning: CyModuleBox<int,sr>: falling back to float..";
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      local String sInit;
      local String sVarLast <= _script.allocTmpVarIntInit(sInit, "box_last", 0, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local CyInput inFreq <= findInputById("freq");
      if(inFreq.isConstVal())
      {
         float fFreq = inFreq.getConstVal();  // range 0..1
         fFreq *= fFreq;
         fFreq *= fFreq;
         int iFreq = fFreq * 32767;
         if(b_export_c)
            _out.append(_sDstVar+" = "+sVarLast+" + (mulsw(((short)("+_sDstVar+" - "+sVarLast+")), "+iFreq+") >> 15);\n");
         else
            _out.append(_sDstVar+" = "+sVarLast+" + ((("+_sDstVar+" - "+sVarLast+") * "+iFreq+") >> 15);\n");
      }
      else
      {
         local String sVarFreq <= _script.allocTmpVarInt(_out, "freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         // (todo) use x^4 pow table
         if(b_export_c)
         {
            _out.append(sVarFreq+" = mulsw("+sVarFreq+", "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(sVarFreq+" = mulsw("+sVarFreq+", "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(_sDstVar+" = "+sVarLast+" + (mulsw(((short)("+_sDstVar+" - "+sVarLast+")), "+sVarFreq+") >> "+FX_SHR+");\n");
         }
         else
         {
            _out.append(sVarFreq+" = ("+sVarFreq+" * "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(sVarFreq+" = ("+sVarFreq+" * "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(_sDstVar+" = "+sVarLast+" + ((("+_sDstVar+" - "+sVarLast+") * "+sVarFreq+") >> "+FX_SHR+");\n");
         }
         _script.freeTmpVarInt(sVarFreq);
      }
      _out.append(sVarLast+" = "+_sDstVar+";\n");
   }
}


// <class.png>
class CyModuleBts : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("div",  8.0, 1.0, 16.0);
      addInput("mul",  8.0, 1.0, 16.0);

      addInputAlias("d", "div");
      addInputAlias("m", "mul");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inDiv <= findInputById("div");
      local CyInput inMul <= findInputById("mul");

      local String *sDiv;
      local String *sVarDiv;
      if(inDiv.isConstVal())
      {
         sDiv <= FloatToString(inDiv.getConstVal());
      }
      else
      {
         sVarDiv <= _script.allocTmpVar(_out, "div");
         sDiv <= sVarDiv;
         inDiv.emitFloat(_script, _out, sVarDiv);
      }

      local String *sMul;
      local String *sVarMul;
      if(inMul.isConnected())
      {
         if(inMul.isConstVal())
         {
            sMul <= FloatToString(inMul.getConstVal());
         }
         else
         {
            sVarMul <= _script.allocTmpVar(_out, "mul");
            sMul <= sVarMul;
            inMul.emitFloat(_script, _out, sVarMul);
         }
      }
      else
         sMul <= sDiv;

      _out.append(_sDstVar+" = loc_bipolar_to_scale("+_sDstVar+", "+sDiv+", "+sMul+");\n");
      parent_script.b_use_bts = true;
      if(null != sVarDiv)
         _script.freeTmpVar(sVarDiv);
      if(null != sVarMul)
         _script.freeTmpVar(sVarMul);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inDiv <= findInputById("div");
      local CyInput inMul <= findInputById("mul");

      local String *sDivScl;
      if(inDiv.isConstVal())
      {
         sDivScl <= String(int(FX_ONE * (1.0f / inDiv.getConstVal())));
      }
      else
      {
         trace "[~~~] warning: CyModuleBts<int>: 'div' input must be const";
         return;
      }

      local String *sMul;
      local String *sVarMul;
      if(inMul.isConnected())
      {
         if(inMul.isConstVal())
         {
            sMul <= String(int(FX_ONE * inMul.getConstVal()));
         }
         else
         {
            sVarMul <= _script.allocTmpVarInt(_out, "mul");
            sMul <= sVarMul;
            inMul.emitInt(_script, _out, sVarMul);
         }
      }
      else
         sMul <= String(int(FX_ONE * inDiv.getConstVal()));

      _out.append(_sDstVar+" = loc_bipolar_to_scale_int("+_sDstVar+", "+sDivScl+", "+sMul+");\n");
      parent_script.b_use_bts = true;
      parent_script.b_use_bts_int = true;
      if(null != sVarMul)
         _script.freeTmpVarInt(sVarMul);
   }
}


// <class.png>
class CyModuleBpf : CyModule {
   // **reserved**

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq", 0.5, 0.0, 1.0);
      addInput("res",  0.0, 0.0, 1.0);

      addInputAlias("f", "freq");
      addInputAlias("r", "res");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleBpf::emitFloat: **STUB**";
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleBpf::emitInt: **STUB**";
   }
}


// <class.png>
class CyModuleBuf : CyModule {
   // **reserved**

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleBuf::emitFloat: **STUB**";
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleBuf::emitInt: **STUB**";
   }
}


// <class.png>
class CyModuleReadBus : CyModule {
   // 'rbl', 'rbr'
   boolean b_right;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("nri", 0.0, 1,     32  );
      addInput("nrf", 0.0, 0.1,   0.32);
   }

   // <method_get.png>
   public virtual getString() : String {
      return b_right ? "rbr" : "rbl";
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inNrI <= findInputById("nri");
      local CyInput inNrF <= findInputById("nrf");

      if(b_plugin)
      {
         String sVoiceBusIndices <= _script.s_voicebus_indices;
         local String sIndent;
         local String *sBusSamples;
         local String sVarBusNrF <= _script.allocTmpVar(_out, "nrf");
         if(inNrI.isConnected())
         {
            // 0..32
            inNrI.emitFloat(_script, sIndent, sVarBusNrF);
            local String sVarBusNr <= _script.allocTmpVarInt(_out, "nr");
            sIndent.append(sVarBusNr+" = (int)("+sVarBusNrF+");\n");
            CyScript.AppendIndentedLines(sVoiceBusIndices, sIndent, 3);
            sBusSamples <= _script.allocVoiceBus(sVarBusNr, false/*bFloatNr*/);  // appends init code to s_voicebus_indices
            _script.freeTmpVarInt(sVarBusNr);
         }
         else
         {
            // 0.1..0.32 => 0..32
            inNrF.emitFloat(_script, sIndent, sVarBusNrF);
            CyScript.AppendIndentedLines(sVoiceBusIndices, sIndent, 3);
            sBusSamples <= _script.allocVoiceBus(sVarBusNrF, true/*bFloatNr*/);  // appends init code to s_voicebus_indices
         }

         // (note) always a valid ptr (points to "0"-filled buffer if layer does not exist)
         _out.append(_sDstVar+" = "+sBusSamples+"[k"+(b_right?"+1":"")+"];\n");

         _script.freeTmpVar(sVarBusNrF);
      }
      else
      {
         _out.append("/* skip voice bus read (only available in plugin mode) */\n");
         _out.append(_sDstVar+" = 0.0f;\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleReadBus<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleClk : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("hz",      2.0, 0.0,  20000.0);
      addInput("bpm",   125.0, 0.0,  50000.0);
      addInput("div",     1.0, 0.0,     16.0);
      addInput("dur",     5.0, 0.0,  10000.0);  // pulse duty cycle duration in milliseconds
      addInput("force",   1.0, 0,        1.0);  // 1=force momentary "0" output when duty cycle is longer than interval (must be const)
      addInput("restart", 0.0, 0,        1.0);  // rising edge: restart clock counter (e.g. sync ratchet clock to 'master' clock)
      addInput("swing",   0.0, -1,       1.0);  // 0=no swing, -0.5=every 2nd pulse comes 50% earlier, +0.5=every 2nd pulse comes 50% later (must be const)
      addInput("onclk",   1.0, 0.0,      1.0);  // run arbitrary statement block when pulse duty cycle begins. output value (0..1) scales clk output.

      addInputAlias("f",  "force");
      addInputAlias("rs", "restart");
      addInputAlias("sw", "swing");
      addInputAlias("oc", "onclk");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inHz      <= findInputById("hz");     // evaluated on first duty cycle sample frame (if connected)
      local CyInput inBPM     <= findInputById("bpm");    // evaluated on first duty cycle sample frame (if "hz" is not connected)
      local CyInput inDiv     <= findInputById("div");    // evaluated on first duty cycle sample frame
      local CyInput inDurMS   <= findInputById("dur");    // evaluated on first duty cycle sample frame
      local CyInput inForce   <= findInputById("force");
      local CyInput inRestart <= findInputById("restart"); // rising edge restarts envelope
      local CyInput inSwing   <= findInputById("swing");  // evaluated on first duty cycle sample frame
      local CyInput inOnClk   <= findInputById("onclk");

      local boolean bForce = (inForce.getConstVal() >= 0.5f);
      local boolean bRestart = inRestart.isConnected();
      local boolean bSwing   = inSwing.isConnected() || (0.0f != inSwing.getConstVal());
      local boolean bOnClk   = inOnClk.isConnected();

      local String sInit;
      local String sVarLeft     <= _script.allocTmpVarInitVoice(sInit, "clk_fr_left",      0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarDutyLeft <= _script.allocTmpVarInitVoice(sInit, "clk_fr_duty_left", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarInitVoice(sInit, "clk_last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarPulseCount;
      if(bSwing)
         sVarPulseCount <= _script.allocTmpVarIntInitVoice(sInit, "clk_last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarClkScl;
      if(bOnClk)
         sVarClkScl <= _script.allocTmpVarInitVoice(sInit, "clk_scl", 1.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String sIndent;

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVar(_out, "restart");
         inRestart.emitFloat(_script, _out, sVarRestart);
         // Rising edge ?
         _out.append(IfRisingEdgeFloat(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         // Restart clock count
         _out.append("   "+sVarLeft+" = 0.0f;\n");
         _out.append("}\n");
         if(bSwing)
            _out.append("   "+sVarPulseCount+" = 0;\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
         _script.freeTmpVar(sVarRestart);
      }

      _out.append("if("+sVarLeft+" <= 0.0f)\n");
      _out.append("{\n");
      // Emit pulse (begin new duty cycle)
      sIndent.empty();
      // Calc pulse duty cycle duration (#sample frames)
      local String sVarDutyDur <= _script.allocTmpVar(sIndent, "fr_duty_dur");
      _script.calcTmpVarInputMillisecToFrames(sIndent, sVarDutyDur, inDurMS);

      // Calc pulse interval (#sample frames)
      local String sVarInterval <= _script.allocTmpVar(sIndent, "fr_ival");
      if(inHz.isConnected())
      {
         // use Hz
         _script.calcTmpVarInputHzToFrames(sIndent, sVarInterval, inHz);
      }
      else
      {
         // use BPM
         _script.calcTmpVarInputBPMToFrames(sIndent, sVarInterval, inBPM);
      }

      // Apply clock divider
      local String sVarDiv <= _script.allocTmpVar(sIndent, "div");
      inDiv.emitFloat(_script, sIndent, sVarDiv);
      sIndent.append(sVarInterval+" *= "+sVarDiv+";\n");
      sIndent.append(sVarInterval+" -= 1.0f;\n");

      if(bOnClk)
      {
         // Calc clock level multiplier
         inOnClk.emitFloat(_script, sIndent, sVarClkScl);
      }

      CyScript.AppendIndentedLines(_out, sIndent, 3);

      if(bSwing)
      {
         local float fSwing;
         local String *sVarSwing;
         if(inSwing.isConstVal())
         {
            fSwing = inSwing.getConstVal();
            fSwing = mathClampf(fSwing, -1.0f, 1.0f);
         }
         else
         {
            sVarSwing <= _script.allocTmpVar(_out, "swing");
            sIndent.empty();
            inSwing.emitFloat(_script, sIndent, sVarSwing);
            sIndent.append(sVarSwing+" = mathClampf("+sVarSwing+", -1.0f, 1.0f);\n");
            CyScript.AppendIndentedLines(_out, sIndent, 3);
         }

         _out.append("   if(0 == ("+sVarPulseCount+"++ & 1))\n");
         _out.append("   {\n");
         // push or pull 2nd pulse
         if(inSwing.isConstVal())
         {
            local float fSwingPush = 1.0f + 0.5f*fSwing;  // -1..0 => 0.5..1  / 0..1 => 1..1.5
            _out.append("      "+sVarInterval+" *= "+FloatToString(fSwingPush)+";\n");
         }
         else
         {
            _out.append("      "+sVarSwing+" = 1.0f + 0.5f * "+sVarSwing+";\n");
            _out.append("      "+sVarInterval+" *= "+sVarSwing+";\n");
         }
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("   {\n");
         // pull or push 1st pulse
         if(inSwing.isConstVal())
         {
            local float fSwingPull = 1.0f - 0.5f*fSwing;  // -1..0 => 0.5..1  / 0..1 => 1..1.5
            _out.append("      "+sVarInterval+" *= "+FloatToString(fSwingPull)+";\n");
         }
         else
         {
            _out.append("      "+sVarSwing+" = 1.0f - 0.5f * "+sVarSwing+";\n");
            _out.append("      "+sVarInterval+" *= "+sVarSwing+";\n");
         }
         _out.append("   }\n");

         if(null != sVarSwing)
            _script.freeTmpVar(sVarSwing);

      } // if bSwing

      // Clip min interval to 1 sample frame
      _out.append("   if("+sVarInterval+" < 0.0f)\n");
      _out.append("      "+sVarInterval+" = 0.0f;\n");

      _out.append("   "+sVarLeft+" += "+sVarInterval+";\n");
      _out.append("   "+sVarDutyLeft+" = "+sVarDutyDur+";\n");
      if(0 && b_plugin)
      {
         _out.append("printf(\"xxx emit ival=%f div=%f\\n\", "+sVarInterval+", "+sVarDiv+");\n");
         _script.b_use_trc = true;
      }
      _out.append("   "+_sDstVar+" = 1.0f;\n");
      _script.freeTmpVar(sVarInterval);
      _script.freeTmpVar(sVarDutyDur);
      _script.freeTmpVar(sVarDiv);
      _out.append("}\n");
      _out.append("else\n");
      _out.append("{\n");
      // Decrease frames left until next pulse
      _out.append("   "+sVarLeft+" -= 1.0f;\n");
      if(bForce)
      {
         _out.append("   if("+sVarDutyLeft+" > 0.0f)\n");
         _out.append("   {\n");
         // Emit "0" at end of interval when duty cycle is longer than interval (=> force rising edge)
         _out.append("      if("+sVarLeft+" <= 0.0f)\n");  // last frame ?
         _out.append("         "+_sDstVar+" = 0.0f;\n");
         _out.append("      else\n");
         if(bOnClk)
            _out.append("         "+_sDstVar+" = "+sVarClkScl+";\n");
         else
            _out.append("         "+_sDstVar+" = 1.0f;\n");
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("     "+_sDstVar+" = 0.0f;\n");
      }
      else
      {
         // Emit "1" for the entire duration of the duty cycle
         if(bOnClk)
            _out.append("   "+_sDstVar+" = ((float)("+sVarDutyLeft+" > 0.0f)) * "+sVarClkScl+";\n");
         else
            _out.append("   "+_sDstVar+" = (float)("+sVarDutyLeft+" > 0.0f);\n");
      }
      _out.append("   "+sVarDutyLeft+" -= 1.0f;\n");
      _out.append("}\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // // trace "[~~~] warning: CyModuleClk<int>: falling back to float..";

      local CyInput inHz      <= findInputById("hz");     // evaluated on first duty cycle sample frame (if connected)
      local CyInput inBPM     <= findInputById("bpm");    // evaluated on first duty cycle sample frame (if "hz" is not connected)
      local CyInput inDiv     <= findInputById("div");    // evaluated on first duty cycle sample frame
      local CyInput inDurMS   <= findInputById("dur");    // evaluated on first duty cycle sample frame
      local CyInput inForce   <= findInputById("force");
      local CyInput inRestart <= findInputById("restart"); // rising edge restarts envelope
      local CyInput inSwing   <= findInputById("swing");  // evaluated on first duty cycle sample frame
      local CyInput inOnClk   <= findInputById("onclk");

      local boolean bForce = (inForce.getConstVal() >= 0.5f);
      local boolean bRestart = inRestart.isConnected();
      local boolean bSwing   = inSwing.isConnected() || (0.0f != inSwing.getConstVal());
      local boolean bOnClk   = inOnClk.isConnected();

      local String sInit;
      local String sVarLeft     <= _script.allocTmpVarIntInitVoice(sInit, "clk_fr_left",      int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarDutyLeft <= _script.allocTmpVarIntInitVoice(sInit, "clk_fr_duty_left", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarIntInitVoice(sInit, "clk_last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarPulseCount;
      if(bSwing)
         sVarPulseCount <= _script.allocTmpVarIntInitVoice(sInit, "clk_last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarClkScl;
      if(bOnClk)
         sVarClkScl <= _script.allocTmpVarIntInitVoice(sInit, "clk_scl", int(FX_ONE), true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String sIndent;

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVarInt(_out, "restart");
         inRestart.emitInt(_script, _out, sVarRestart);
         // Rising edge ?
         _out.append(IfRisingEdgeInt(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         // Restart clock count
         _out.append("   "+sVarLeft+" = 0;\n");
         _out.append("}\n");
         if(bSwing)
            _out.append("   "+sVarPulseCount+" = 0;\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
         _script.freeTmpVarInt(sVarRestart);
      }

      _out.append("if("+sVarLeft+" <= 0)\n");
      _out.append("{\n");
      // Emit pulse (begin new duty cycle)
      sIndent.empty();
      // Calc pulse duty cycle duration (#sample frames)
      local String sVarDutyDur <= _script.allocTmpVarInt(sIndent, "fr_duty_dur");
      _script.calcTmpVarIntInputMillisecToFrames(sIndent, sVarDutyDur, inDurMS);
      // // sIndent.append("  trace \"sVarDutyDur=\"+"+sVarDutyDur+";\n");

      // Calc pulse interval (#sample frames)
      local String sVarInterval <= _script.allocTmpVarInt(sIndent, "fr_ival");
      if(inHz.isConnected())
      {
         // use Hz
         _script.calcTmpVarIntInputHzToFrames(sIndent, sVarInterval, inHz);
      }
      else
      {
         // use BPM
         _script.calcTmpVarIntInputBPMToFrames(sIndent, sVarInterval, inBPM);
      }

      // Apply clock divider
      local String sVarDiv <= _script.allocTmpVarInt(sIndent, "div");
      inDiv.emitInt(_script, sIndent, sVarDiv);
      sIndent.append(sVarInterval+" = Dmulsw_shr("+sVarInterval+", "+sVarDiv+");\n");
      sIndent.append(sVarInterval+" -= "+int(1)+";\n");

      // // sIndent.append("  trace \"sVarInterval=\"+"+sVarInterval+";\n");

      if(bOnClk)
      {
         // Calc clock level multiplier
         inOnClk.emitInt(_script, sIndent, sVarClkScl);
      }

      CyScript.AppendIndentedLines(_out, sIndent, 3);

      if(bSwing)
      {
         local float fSwing;
         local String *sVarSwing;
         if(inSwing.isConstVal())
         {
            fSwing = inSwing.getConstVal();
            fSwing = mathClampf(fSwing, -1.0f, 1.0f);
         }
         else
         {
            sVarSwing <= _script.allocTmpVarInt(_out, "swing");
            sIndent.empty();
            inSwing.emitInt(_script, sIndent, sVarSwing);
            sIndent.append(sVarSwing+" = mathClampi("+sVarSwing+", "+int(-FX_ONE)+", "+int(FX_ONE)+");\n");
            CyScript.AppendIndentedLines(_out, sIndent, 3);
         }

         _out.append("   if(0 == ("+sVarPulseCount+"++ & 1))\n");
         _out.append("   {\n");
         // push or pull 2nd pulse
         if(inSwing.isConstVal())
         {
            local float fSwingPush = 1.0f + 0.5f*fSwing;  // -1..0 => 0.5..1  / 0..1 => 1..1.5
            _out.append("      "+sVarInterval+" = Dmulsw_shr("+sVarInterval+", "+int(FX_ONE * fSwingPush)+");\n");
         }
         else
         {
            _out.append("      "+sVarSwing+" = "+int(FX_ONE)+" + ("+sVarSwing+" >> 1);\n");
            _out.append("      "+sVarInterval+" = Dmulsw_shr("+sVarInterval+", "+sVarSwing+");\n");
         }
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("   {\n");
         // pull or push 1st pulse
         if(inSwing.isConstVal())
         {
            local float fSwingPull = 1.0f - 0.5f*fSwing;  // -1..0 => 0.5..1  / 0..1 => 1..1.5
            _out.append("      "+sVarInterval+" = Dmulsw_shr("+sVarInterval+", "+int(FX_ONE * fSwingPull)+");\n");
         }
         else
         {
            _out.append("      "+sVarSwing+" = "+int(FX_ONE)+" - ("+sVarSwing+" >> 1);\n");
            _out.append("      "+sVarInterval+" = Dmulsw_shr("+sVarInterval+", "+sVarSwing+");\n");
         }
         _out.append("   }\n");

         if(null != sVarSwing)
            _script.freeTmpVarInt(sVarSwing);

      } // if bSwing

      // Clip min interval to 1 sample frame
      _out.append("   if("+sVarInterval+" < 0)\n");
      _out.append("      "+sVarInterval+" = 0;\n");

      _out.append("   "+sVarLeft+" += "+sVarInterval+";\n");
      _out.append("   "+sVarDutyLeft+" = "+sVarDutyDur+";\n");
      if(0 && b_plugin)
      {
         _out.append("printf(\"xxx emit ival=%f div=%f\\n\", "+sVarInterval+", "+sVarDiv+");\n");
         _script.b_use_trc = true;
      }
      _out.append("   "+_sDstVar+" = "+int(FX_ONE)+";\n");
      _script.freeTmpVarInt(sVarInterval);
      _script.freeTmpVarInt(sVarDutyDur);
      _script.freeTmpVarInt(sVarDiv);
      _out.append("}\n");
      _out.append("else\n");
      _out.append("{\n");
      // Decrease frames left until next pulse
      _out.append("   "+sVarLeft+" -= "+int(1)+";\n");
      // // _out.append("  trace \"sVarLeft=\"+"+sVarLeft+";\n");
      if(bForce)
      {
         _out.append("   if("+sVarDutyLeft+" > 0)\n");
         _out.append("   {\n");
         // Emit "0" at end of interval when duty cycle is longer than interval (=> force rising edge)
         _out.append("      if("+sVarLeft+" <= 0)\n");  // last frame ?
         _out.append("         "+_sDstVar+" = 0;\n");
         _out.append("      else\n");
         if(bOnClk)
            _out.append("         "+_sDstVar+" = "+sVarClkScl+";\n");
         else
            _out.append("         "+_sDstVar+" = "+int(FX_ONE)+";\n");
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("     "+_sDstVar+" = "+int(0)+";\n");
      }
      else
      {
         // Emit "1" for the entire duration of the duty cycle
         if(bOnClk)
            _out.append("   "+_sDstVar+" = ("+sVarDutyLeft+" > 0) ? "+sVarClkScl+" : 0;\n");
         else
            _out.append("   "+_sDstVar+" = ("+sVarDutyLeft+" > 0) ? "+int(FX_ONE)+" : 0;\n");
      }
      // // _out.append("  trace \"sVarDutyLeft=\"+"+sVarDutyLeft+";\n");
      _out.append("  if("+sVarDutyLeft+" > 0) "+sVarDutyLeft+" -= "+int(1)+";\n");
      _out.append("}\n");
   }
}

// <class.png>
class CyModuleClp : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("ceil",   0.999,  0.0, 1.0);  // rename to max ?
      addInput("floor", -0.999, -1.0, 1.0);  // rename to min ?

      addInputAlias("c", "ceil");
      addInputAlias("f", "floor");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inCeil  <= findInputById("ceil");
      local CyInput inFloor <= findInputById("floor");

      if(inCeil.isConstVal() && inFloor.isConstVal())
      {
         float fCeil = inCeil.getConstVal();
         float fFloor;
         if(inFloor.isConnected())
            fFloor = inFloor.getConstVal();
         else
            fFloor = -fCeil;  // old behaviour: clip -ceil..+ceil

         _out.append("if("+_sDstVar+" > "+FloatToString(fCeil)+") "+_sDstVar+" = "+FloatToString(fCeil)+";\n");
         _out.append("else if("+_sDstVar+" < "+FloatToString(fFloor)+") "+_sDstVar+" = "+FloatToString(fFloor)+";\n");
      }
      else
      {
         local String sVarCeil <= _script.allocTmpVar(_out, "ceil");
         inCeil .emitFloat(_script, _out, sVarCeil);
         if(inFloor.isConnected())
         {
            local String sVarFloor <= _script.allocTmpVar(_out, "floor");
            inFloor.emitFloat(_script, _out, sVarFloor);
            _out.append("if("+_sDstVar+" > "+sVarCeil+") "+_sDstVar+" = "+sVarCeil+";\n");
            _out.append("else if("+_sDstVar+" < "+sVarFloor+") "+_sDstVar+" = "+sVarFloor+";\n");
            _script.freeTmpVar(sVarFloor);
         }
         else
         {
            _out.append("if("+_sDstVar+" > "+sVarCeil+") "+_sDstVar+" = "+sVarCeil+";\n");
            _out.append("else if("+_sDstVar+" < -"+sVarCeil+") "+_sDstVar+" = -"+sVarCeil+";\n");
         }
         _script.freeTmpVar(sVarCeil);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inCeil  <= findInputById("ceil");
      local CyInput inFloor <= findInputById("floor");

      if(inCeil.isConstVal() && inFloor.isConstVal())
      {
         int iCeil = inCeil.getConstVal() * FX_ONE;
         int iFloor;

         if(inFloor.isConnected())
            iFloor = inFloor.getConstVal() * FX_ONE;
         else
            iFloor = -iCeil;  // old behaviour: clip -ceil..+ceil

         _out.append("if("+_sDstVar+" > "+iCeil+") "+_sDstVar+" = "+iCeil+";\n");
         _out.append("else if("+_sDstVar+" < "+iFloor+") "+_sDstVar+" = "+iFloor+";\n");
      }
      else
      {
         local String sVarCeil <= _script.allocTmpVarInt(_out, "ceil");
         inCeil.emitInt(_script, _out, sVarCeil);

         if(inFloor.isConnected())
         {
            local String sVarFloor <= _script.allocTmpVarInt(_out, "floor");
            inFloor.emitInt(_script, _out, sVarFloor);

            _out.append("if("+_sDstVar+" > "+sVarCeil+") "+_sDstVar+" = "+sVarCeil+";\n");
            _out.append("else if("+_sDstVar+" < "+sVarFloor+") "+_sDstVar+" = "+sVarFloor+";\n");

            _script.freeTmpVarInt(sVarFloor);
         }
         else
         {
            _out.append("if("+_sDstVar+" > "+sVarCeil+") "+_sDstVar+" = "+sVarCeil+";\n");
            _out.append("else if("+_sDstVar+" < -"+sVarCeil+") "+_sDstVar+" = -"+sVarCeil+";\n");
         }

         _script.freeTmpVarInt(sVarCeil);
      }
   }
}


// <class.png>
class CyModuleCmp : CyModule {
   int cmp_op;

   define int CMP_OP_NONE = -1;
   define int CMP_OP_LT = 0;
   define int CMP_OP_LE = 1;
   define int CMP_OP_EQ = 2;
   define int CMP_OP_NE = 3;
   define int CMP_OP_GE = 4;
   define int CMP_OP_GT = 5;

   static StringArray op_c = [ "<", "<=", "==", "!=", ">=", ">" ];

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("rhs", 0.0f, 0.0f, 1.0f);
      addInput("else", 0.0f, 0.0f, 1.0f);  // when connected, eval when comparison fails

      addInputAlias("r", "rhs");
   }

   // <method_get.png>
   public virtual doEmitRight() : boolean {
      // skip seq_right in emitFloatTree() / emitIntTree()
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inRhs  <= findInputById("rhs");
      local CyInput inElse <= findInputById("else");

      if(inRhs.isConstVal())
      {
         _out.append("if("+_sDstVar+" "+op_c.get(cmp_op)+" "+FloatToString(inRhs.getConstVal())+")\n");
      }
      else
      {
         local String *sVarRhs <= _script.allocTmpVar(_out, "cmp_rhs");
         inRhs.emitFloat(_script, _out, sVarRhs);
         _out.append("if("+_sDstVar+" "+op_c.get(cmp_op)+" "+sVarRhs+")\n");
         _script.freeTmpVar(sVarRhs);
      }

      _out.append("{\n");
      local String sIndent;
      if(null != seq_right)
      {
         seq_right.emitFloatSequence(_script, sIndent, _sDstVar);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
      }
      _out.append("}\n");

      if(inElse.isConnected())
      {
         _out.append("else\n");
         _out.append("{\n");
         sIndent.empty();
         inElse.emitFloat(_script, sIndent, _sDstVar);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("}\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inRhs <= findInputById("rhs");
      local CyInput inElse <= findInputById("else");

      if(inRhs.isConstVal())
      {
         _out.append("if("+_sDstVar+" "+op_c.get(cmp_op)+" "+int(FX_ONE * inRhs.getConstVal())+")\n");
      }
      else
      {
         local String *sVarRhs <= _script.allocTmpVarInt(_out, "cmp_rhs");
         inRhs.emitInt(_script, _out, sVarRhs);
         _out.append("if("+_sDstVar+" "+op_c.get(cmp_op)+" "+sVarRhs+")\n");
         _script.freeTmpVarInt(sVarRhs);
      }

      _out.append("{\n");
      local String sIndent;
      if(null != seq_right)
      {
         seq_right.emitIntSequence(_script, sIndent, _sDstVar);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
      }
      _out.append("}\n");

      if(inElse.isConnected())
      {
         _out.append("else\n");
         _out.append("{\n");
         sIndent.empty();
         inElse.emitInt(_script, sIndent, _sDstVar);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("}\n");
      }
   }
}


// <class.png>
class CyModuleCon : CyModule {
   float const_val;

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method_get.png>
   public virtual getString() : String {
      return String(const_val);
   }

   // <method_get.png>
   public virtual isConstVal() : boolean {
      return true;
   }

   // <method_get.png>
   public virtual getConstVal() : float {
      return const_val;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = "+FloatToString(const_val)+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = "+int(const_val * FX_ONE)+";\n");
   }

}


// <class.png>
class CyModuleDiv : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("a", 1.0, -999999.0, 999999.0);
      addInput("b", 1.0, -999999.0, 999999.0);
   }

   // <method_get.png>
   public virtual isConstVal() : boolean {
      local CyInput inA <= findInputById("a");
      local CyInput inB <= findInputById("b");
      return inA.isConstVal() && inB.isConstVal();
   }

   // <method_get.png>
   public virtual getConstVal() : float {
      local CyInput inA <= findInputById("a");
      local CyInput inB <= findInputById("b");
      float fA = inA.getConstVal();
      float fB = inB.getConstVal();
      return fA / fB;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(isConstVal())
      {
         _out.append(_sDstVar+" = "+FloatToString(getConstVal())+";\n");
      }
      else
      {
         local CyInput inA <= findInputById("a");
         local CyInput inB <= findInputById("b");
         local String sVarA <= _script.allocTmpVar(_out, "div_a");
         local String sVarB <= _script.allocTmpVar(_out, "div_b");
         inA.emitFloat(_script, _out, sVarA);
         inB.emitFloat(_script, _out, sVarB);
         _out.append(_sDstVar +" = (0.0f != "+sVarB+") ? ("+sVarA+" / "+sVarB+") : 0.0f;\n");
         _script.freeTmpVar(sVarA);
         _script.freeTmpVar(sVarB);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(isConstVal())
      {
         _out.append(_sDstVar+" = "+int(FX_ONE*getConstVal())+";\n");
      }
      else
      {
         // // trace "[~~~] warning: CyModuleDiv<int> falling back to float..";

         local CyInput inA <= findInputById("a");
         local CyInput inB <= findInputById("b");
         local String sVarA <= _script.allocTmpVarInt(_out, "div_a");
         local String sVarB <= _script.allocTmpVarInt(_out, "div_b");
         inA.emitInt(_script, _out, sVarA);
         inB.emitInt(_script, _out, sVarB);

         // based on fixedpoint_div.tks (research)
         local String sVarN   <= _script.allocTmpVarInt32(_out, "rcp_n");
         local String sVarD   <= _script.allocTmpVarInt32(_out, "rcp_d");
         local String sVarFi  <= _script.allocTmpVarInt32(_out, "rcp_fi");
         local String sVarSgn <= _script.allocTmpVarInt32(_out, "rcp_sgn");

         _out.append("if("+sVarA+" & 0x8000)\n");
         _out.append("{\n");
         _out.append("   "+sVarSgn+" = 1;\n");
         _out.append("   "+sVarN+" = -"+sVarA+";\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         _out.append("   "+sVarSgn+" = 0;\n");
         _out.append("   "+sVarN+" = "+sVarA+";\n");
         _out.append("}\n");

         _out.append("if("+sVarB+" & 0x8000)\n");
         _out.append("{\n");
         _out.append("   "+sVarSgn+" ^= 1;\n");
         _out.append("   "+sVarD+" = -"+sVarB+";\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         _out.append("   "+sVarD+" = "+sVarB+";\n");
         _out.append("}\n");

         _script.freeTmpVarInt(sVarA);
         _script.freeTmpVarInt(sVarB);

         _out.append("while("+sVarD+" > "+int(FX_ONE)+")\n");
         _out.append("{\n");
         _out.append("   "+sVarN+" = "+sVarN+" >> 1;\n");
         _out.append("   "+sVarD+" = "+sVarD+" >> 1;\n");
         _out.append("}\n");

         int NUM_ITER = 3;
         loop(NUM_ITER)
         {
            _out.append(sVarFi+" = "+int(FX_ONE << 1)+" - "+sVarD+";\n");
            _out.append(sVarN+" = ((int)("+sVarN+" * "+sVarFi+")) >> "+FX_SHR+";\n");
            _out.append(sVarD+" = ((int)("+sVarD+" * "+sVarFi+")) >> "+FX_SHR+";\n");
         }

         if(b_export_c)
            _out.append(_sDstVar+" = (short)("+sVarSgn+" ? -"+sVarN+" : "+sVarN+");\n");
         else
            _out.append(_sDstVar+" = "+sVarSgn+" ? -"+sVarN+" : "+sVarN+";\n");

         _script.freeTmpVarInt32(sVarN);
         _script.freeTmpVarInt32(sVarD);
         _script.freeTmpVarInt32(sVarFi);
         _script.freeTmpVarInt32(sVarSgn);
      }
   }
}


// <class.png>
class CyModuleDly : CyModule {
   define int MAX_DELAY_SIZE = 1024*1024;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("size",     32768, 0,    MAX_DELAY_SIZE);  // def=32768 => 683ms@48kHz
      addInput("len",        0.5, 0.0f, 1.0f);
      addInput("freq",       1.0, 0.0f, 1.0f);
      addInput("feedback",   0.0, 0.0f, 1.0f);
      addInput("lin",        0.0, 0.0f, 1.0f);
      addInput("read",       0.0, 0.0f, 1.0f);  // delay-read processing tree
      addInput("write",      0.0, 0.0f, 1.0f);  // delay-write processing tree

      addInputAlias("s",  "size");
      addInputAlias("n",  "len");
      addInputAlias("f",  "freq");
      addInputAlias("fb", "feedback");
      addInputAlias("l",  "lin");
      addInputAlias("r",  "read");
      addInputAlias("w",  "write");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSize   <= findInputById("size");
      local CyInput inLen    <= findInputById("len");
      local CyInput inFreq   <= findInputById("freq");
      local CyInput inFb     <= findInputById("feedback");
      local CyInput inLin    <= findInputById("lin");
      local CyInput inRead   <= findInputById("read");
      local CyInput inWrite  <= findInputById("write");

      local String sInit;
      local String sVarWriteIdx <= _script.allocTmpVarInt32Init(sInit, "dly_write_idx", 0,
                                                                true/*bCycleReset*/,
                                                                true/*bVoiceReset*/
                                                                );
      _script.appendInit(sInit);

      local int sz = mathClampi(inSize.getConstVal() * _script.oversample_factor, 1, MAX_DELAY_SIZE);
      local String sVarArray <= _script.addArrayVar("dly", sz, false/*bInt*/);

      local boolean bLinear = (inLin.getConstVal() >= 0.5f);

      local String sVarLen <= _script.allocTmpVar(_out, "dly_len");

      if(inFreq.isConnected())
      {
         // tuned delay line mode: convert note speed and freq ratio to delay len
         //   dly test stfx 3:
         //     n:
         //       spd
         //       rcp
         //       * 1/8192
         //       * $m_dly_scl
         //         fma 2 -1
         //         bts 16 16
         //       trc
         if(b_plugin)
         {
            inFreq.emitFloat(_script, _out, sVarLen);  // frequency divider / speed factor
            _out.append("   "+sVarLen+" = "+sVarLen+" / voice->note_speed_cur;\n");  // calc #sample frames
         }
         else if(inFreq.isConstVal())
         {
            _out.append("   "+sVarLen+" = "+FloatToString(inFreq.getConstVal() / _script.note_speed)+";\n");  // calc #sample frames
         }
         else
         {
            inFreq.emitFloat(_script, _out, sVarLen);  // frequency divider / speed factor
            _out.append("   "+sVarLen+" = "+sVarLen+" * "+FloatToString(1.0f / _script.note_speed)+";\n");  // calc #sample frames
         }
      }
      else
      {
         // normalized delay len input
         inLen.emitFloat(_script, _out, sVarLen);
         _out.append(sVarLen+" *= "+sz+";\n");
      }

      // Clip delay length to ringbuffer size
      _out.append(sVarLen+" = ("+sVarLen+" < 1.0f) ? 1.0f : ("+sVarLen+" > "+(sz-1)+") ? "+(sz-1)+" : "+sVarLen+";\n");

      local String sVarCur <= _script.allocTmpVar(_out, "dly_cur");
      local String sVarReadIdxI <= _script.allocTmpVarInt32(_out, "dly_read_idx");
      _out.append(sVarReadIdxI+" = "+sVarWriteIdx+" - (int)"+sVarLen+";\n");
      _out.append("if("+sVarReadIdxI+" < 0)\n");
      _out.append("  "+sVarReadIdxI+" += "+sz+";\n");
      _out.append(sVarCur+" = "+sVarArray+"["+sVarReadIdxI+"];\n");

      if(bLinear)
      {
         // using fractional part of sVarLen to lerp to next older
         local String sVarReadIdxN <= _script.allocTmpVarInt32(_out, "dly_read_idx_n");
         _out.append(sVarReadIdxN+" = "+sVarReadIdxI+" + 1;\n");  // next newer
         _out.append("if("+sVarReadIdxN+" >= "+sz+")\n");
         _out.append("  "+sVarReadIdxN+" -= "+sz+";\n");

         local String sVarN <= _script.allocTmpVar(_out, "dly_n");
         _out.append(sVarN+" = "+sVarArray+"["+sVarReadIdxN+"];\n");

         local String sVarFrac <= _script.allocTmpVar(_out, "dly_read_frac");
         _out.append(sVarFrac+" = "+sVarLen+" - (int)"+sVarLen+";\n");

         _out.append(sVarCur+" = "+sVarN+" + ("+sVarCur+" - "+sVarN+") * "+sVarFrac+";\n");

         _script.freeTmpVar(sVarFrac);
      }
      else
      {
         // nearest (keep sVarCur)
      }
      _script.freeTmpVarInt32(sVarReadIdxI);
      _script.freeTmpVar(sVarLen);

      // delay-read feedback insert
      if(inRead.isConnected())
         inRead.emitFloat(_script, _out, sVarCur);

      if(inFb.isConnected() || (inFb.getConstVal() > 0.0f))
      {
         local String sVarFbAmt <= _script.allocTmpVar(_out, "dly_fb_amt");
         inFb.emitFloat(_script, _out, sVarFbAmt);
         _out.append(_sDstVar+" += "+sVarCur+" * "+sVarFbAmt+";\n");
         _script.freeTmpVar(sVarFbAmt);
      }

      // delay-write feedback insert
      if(inWrite.isConnected())
         inWrite.emitFloat(_script, _out, _sDstVar);

      // Store next value in ring buffer
      _out.append(sVarArray+"["+sVarWriteIdx+"] = "+_sDstVar+";\n");

      _out.append(_sDstVar+" = "+sVarCur+";\n");

      _script.freeTmpVar(sVarCur);

      _out.append("if(++"+sVarWriteIdx+" >= "+sz+")\n");
      _out.append("   "+sVarWriteIdx+" = 0;\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inLin <= findInputById("lin");
      local boolean bLinear = (inLin.getConstVal() >= 0.5f);

      if(b_plugin || bLinear)
      {
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      local CyInput inSize   <= findInputById("size");
      local CyInput inLen    <= findInputById("len");
      local CyInput inFreq   <= findInputById("freq");
      local CyInput inFb     <= findInputById("feedback");
      local CyInput inRead   <= findInputById("read");
      local CyInput inWrite  <= findInputById("write");

      local String sInit;
      local String sVarWriteIdx <= _script.allocTmpVarInt32Init(sInit, "dly_write_idx", 0,
                                                                true/*bCycleReset*/,
                                                                true/*bVoiceReset*/
                                                                );
      _script.appendInit(sInit);

      local int sz = mathClampi(inSize.getConstVal() * _script.oversample_factor, 1, MAX_DELAY_SIZE);
      local String sVarArray <= _script.addArrayVar("dly", sz, true/*bInt*/);

      local String sVarLen <= _script.allocTmpVarInt(_out, "dly_len");

      if(inFreq.isConnected())
      {
         // tuned delay line mode: convert note speed and freq ratio to delay len
         if(inFreq.isConstVal())
         {
            _out.append("   "+sVarLen+" = "+int(inFreq.getConstVal() / _script.note_speed)+";\n");  // calc #sample frames
         }
         else
         {
            inFreq.emitInt(_script, _out, sVarLen);  // frequency divider / speed factor
            _out.append("   "+sVarLen+" = Dmulsw_shr("+sVarLen+", "+int(1.0 / _script.note_speed)+";\n");  // calc #sample frames
         }
      }
      else
      {
         // normalized delay len input
         inLen.emitInt(_script, _out, sVarLen);
         _out.append(sVarLen+" = Dmulsw_shr("+sVarLen+", "+sz+");\n");
      }

      // Clip delay length to ringbuffer size
      _out.append(sVarLen+" = ("+sVarLen+" < 1) ? 1 : ("+sVarLen+" > "+(sz-1)+") ? "+(sz-1)+" : "+sVarLen+";\n");

      local String sVarCur <= _script.allocTmpVarInt(_out, "dly_cur");
      local String sVarReadIdxI <= _script.allocTmpVarInt32(_out, "dly_read_idx");
      _out.append(sVarReadIdxI+" = "+sVarWriteIdx+" - "+sVarLen+";\n");
      _out.append("if("+sVarReadIdxI+" < 0)\n");
      _out.append("  "+sVarReadIdxI+" += "+sz+";\n");
      _out.append(sVarCur+" = "+sVarArray+"["+sVarReadIdxI+"];\n");

      _script.freeTmpVarInt32(sVarReadIdxI);
      _script.freeTmpVarInt(sVarLen);

      // delay-read feedback insert
      if(inRead.isConnected())
         inRead.emitInt(_script, _out, sVarCur);

      if(inFb.isConnected() || (inFb.getConstVal() > 0.0f))
      {
         local String sVarFbAmt <= _script.allocTmpVarInt(_out, "dly_fb_amt");
         inFb.emitInt(_script, _out, sVarFbAmt);
         _out.append(_sDstVar+" += Dmulsw_shr("+sVarCur+", "+sVarFbAmt+");\n");
         _script.freeTmpVarInt(sVarFbAmt);
      }

      // delay-write feedback insert
      if(inWrite.isConnected())
         inWrite.emitInt(_script, _out, _sDstVar);

      // Store next value in ring buffer
      _out.append(sVarArray+"["+sVarWriteIdx+"] = "+_sDstVar+";\n");

      _out.append(_sDstVar+" = "+sVarCur+";\n");

      _script.freeTmpVarInt(sVarCur);

      _out.append("if(++"+sVarWriteIdx+" >= "+sz+")\n");
      _out.append("   "+sVarWriteIdx+" = 0;\n");
   }
}


// <class.png>
class CyModuleDrv : CyModule {
   // **reserved**

   // <method_init.png>
   public method init() {
      CyModule::init();

      addInput("level", 1, 0.0, 128.0);

      addInputAlias("l", "level");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleDrv::emitFloat: **STUB**";
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleDrv::emitInt: **STUB**";
   }
}


// <class.png>
class CyModuleEnv : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("ad",      0.01,   0.0, 1.0);  // attack/decay rate
      addInput("s",       0.5,    0.0, 1.0);  // sustain position (0..1)
      addInput("r",       0.01,   0.0, 1.0);  // release rate
      addInput("loop",    0.0,    0.0, 1.0);  // must be const
      addInput("restart", 0.0,    0.0, 1.0);
      addInput("sr",      1.0,    0.0, 1.0);  // must be const
      addInput("onend",   0.0,    0.0, 1.0);
      addInput("scl",     0.001,  0.0, 1.0);  // rate scaling
      addInput("tuned",   0,      0.0, 1.0);  // ad/s/r independent pitch (requires loop mode to be enabled) (must be const)

      addInputAlias("lp",  "loop");
      addInputAlias("rs",  "restart");
      addInputAlias("oe",  "onend");
      addInputAlias("tun", "tuned");
   }

   // <method_get.png>
   public virtual doEmitRight() : boolean {
      // skip seq_right in emitFloatTree() / emitIntTree()
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      _out.append("// env sDstVar=\""+_sDstVar+"\"\n");

      local CyInput inAD      <= findInputById("ad");
      local CyInput inS       <= findInputById("s");
      local CyInput inR       <= findInputById("r");
      local CyInput inLoop    <= findInputById("loop");
      local CyInput inRestart <= findInputById("restart");  // (todo)
      local CyInput inSR      <= findInputById("sr");
      local CyInput inOnEnd   <= findInputById("onend");
      local CyInput inScl     <= findInputById("scl");
      local CyInput inTuned   <= findInputById("tuned");

      local boolean bLoop  = (inLoop .getConstVal() >= 0.5f);
      local boolean bSR    = !_script.b_lofi && (inSR   .getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);
      local boolean bTuned = (inTuned.getConstVal() >= 0.5f);

      if(bTuned)
         bLoop = true;

      local String sInit;
      local String sVarLastGate  <= _script.allocTmpVarInitVoice(sInit, "env_last_gate",  0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarPos       <= _script.allocTmpVarInitVoice(sInit, "env_pos",        0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarRate      <= _script.allocTmpVarInitVoice(sInit, "env_rate",       0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarHaltPos;
      local String *sVarLastLevel;
      local String *sVarSetLevelScl;
      local String *sVarLevelScl;
      local String *sVarOutScl;
      // local String *sVarLastPos;
      if(!bLoop)
      {
         sVarHaltPos     <= _script.allocTmpVarInitVoice(sInit, "env_halt_pos",   1, true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarLastLevel   <= _script.allocTmpVarInitVoice    (sInit, "env_last_level",    0, true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarSetLevelScl <= _script.allocTmpVarIntInitVoice (sInit, "env_set_level_scl", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarLevelScl    <= _script.allocTmpVarInitVoice    (sInit, "env_level_scl",     1, true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarOutScl      <= _script.allocTmpVarInitVoice    (sInit, "env_out_scl",       1, true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      else
      {
         // sVarLastPos     <= _script.allocTmpVarInitVoice    (sInit, "env_last_pos",      1, true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      _script.appendInit(sInit);

      local String sIndent;

      // Sustain position
      local String sVarSusPos <= _script.allocTmpVar(_out, "env_suspos");
      inS.emitFloat(_script, _out, sVarSusPos);

      local String *sSclAD;
      local String *sSclR;
      local String  sVarRateAD;
      local String  sVarRateR;
      local String  sVarScl;  // used only in loop mode
      local String *sScl;

      if(bLoop)
      {
         if(bTuned)
         {
            // Pitch-independent AD/S/R (audio rate)
            sVarRateAD = _script.allocTmpVar(_out, "env_tuned_ad");
            inAD.emitFloat(_script, _out, sVarRateAD);
            sSclAD <= sVarRateAD;

            sVarRateR  = _script.allocTmpVar(_out, "env_tuned_r");
            inR.emitFloat(_script, _out, sVarRateR);
            sSclR  <= sVarRateR;

            local String sVarSum <= _script.allocTmpVar(_out, "env_sum");
            _out.append(sVarSum+" = "+sVarRateR+" + ("+sVarRateAD+" - "+sVarRateR+") * "+sVarSusPos+";\n");
            _out.append("if(0.0f != "+sVarSum+")\n");
            _out.append("   "+sVarSum+" = 1.0f / "+sVarSum+";\n");

            sScl <= _script.evalAddSRInput(inScl, _out, sVarScl);
            if(sVarScl.isBlank())  // const? (no var allocated)
            {
               sVarScl = _script.allocTmpVar(_out, "env_tuned_scl");
               _out.append(sVarScl+" = "+sScl+" * "+sVarSum+";\n");
               sScl <= sVarScl;
            }
            else
            {
               _out.append(sVarScl+" *= "+sVarSum+";\n");
            }

            _script.freeTmpVar(sVarSum);
         }
         else
         {
            sVarScl = _script.allocTmpVar(_out, "env_loop_scl");
            inScl.emitFloat(_script, _out, sVarScl);
            sSclAD <= _script.evalAddSRInput(inAD, _out, sVarRateAD);
            sSclR  <= _script.evalAddSRInput(inR,  _out, sVarRateR);
            sScl <= sVarScl;
         }
      }

      // Gate
      _out.append(IfRisingEdgeFloat(_sDstVar, sVarLastGate));
      _out.append("{\n");
      // Attack / Decay
      _out.append("   "+sVarPos+" = 0.0f;\n");
      if(!bLoop)
      {
         sIndent.empty();
         sSclAD <= _script.evalAddSRInput(inAD, sIndent, sVarRateAD);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         sIndent.empty();
         inScl.emitFloat(_script, sIndent, sVarRate);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("   "+sVarRate+" *= "+sSclAD+";\n");
         _out.append("   "+sVarHaltPos+" = "+sVarSusPos+";\n");
         _out.append("   "+sVarLevelScl+" = 1.0f;\n");
         _out.append("   "+sVarOutScl+" = 1.0f;\n");
      }
      _out.append("   "+sVarLastGate+" = 1.0f;\n");
      _out.append("}\n");
      if(!bLoop)
      {
         _out.append("else "+IfFallingEdgeFloat(_sDstVar, sVarLastGate));
         _out.append("{\n");
         // Release
         sIndent.empty();
         sSclR <= _script.evalAddSRInput(inR, sIndent, sVarRateR);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         sIndent.empty();
         inScl.emitFloat(_script, sIndent, sVarRate);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("   "+sVarRate+" *= "+sSclR+";\n");
         _out.append("   "+sVarLastGate+" = 0.0f;\n");
         _out.append("   "+sVarSetLevelScl+" = 1;\n");
         _out.append("   "+sVarOutScl+" = "+sVarLastLevel+";\n");
         _out.append("   "+sVarPos+" = "+sVarSusPos+";\n");
         _out.append("   "+sVarHaltPos+" = 1.0f;\n");
         _out.append("}\n");
      }

      // Calc output
      if(null != seq_right)
      {
         _out.append(_sDstVar+" = "+sVarPos+";\n");
         seq_right.emitFloatSequence(_script, _out, _sDstVar);
      }
      else
      {
         trace "[~~~] CyModuleEnv: level subtree is empty, substituting zero.";
         _out.append(_sDstVar+" = 0.0f;\n");
      }

      // Update level scaling (when entering release phase)
      if(!bLoop)
      {
         _out.append("if("+sVarSetLevelScl+")\n");
         _out.append("{\n");
         _out.append("   "+sVarSetLevelScl+" = 0;\n");
         _out.append("   if(0.0f != "+_sDstVar+")\n");
         _out.append("      "+sVarLevelScl+" = (1.0f / "+_sDstVar+");\n");
         _out.append("   else\n");
         _out.append("      "+sVarLevelScl+" = 0.0f;\n");
         _out.append("}\n");

         _out.append(_sDstVar+" *= "+sVarLevelScl+";\n");
         _out.append(sVarLastLevel+" = "+_sDstVar+";\n");
         _out.append(_sDstVar+" *= "+sVarOutScl+";\n");

         _out.append("if("+sVarPos+" < "+sVarHaltPos+")\n");
         _out.append("{\n");
         _out.append("   "+sVarPos+" += "+sVarRate+";\n");
      }
      else
      {
         _out.append("if("+sVarPos+" < "+sVarSusPos+")\n");
         _out.append("  "+sVarRate+" = "+sScl+" * "+sSclAD+";\n");
         _out.append("else\n");
         _out.append("  "+sVarRate+" = "+sScl+" * "+sSclR+";\n");

         _out.append("{\n");

         local String sVarLastPos <= _script.allocTmpVar(_out, "seq_loop_lastpos");
         _out.append("   "+sVarLastPos+" = "+sVarPos+";\n");
         _out.append("   "+sVarPos+" += "+sVarRate+";\n");
         _out.append("   if("+sVarPos+" > "+sVarSusPos+" && "+sVarLastPos+" < "+sVarSusPos+" && (0.0f != "+sSclAD+"))\n");
         _out.append("   {\n");
         _out.append("      "+sVarPos+" = "+sVarSusPos+" + ("+sVarPos+" - "+sVarSusPos+") * "+sScl+" * ("+sSclR+" / "+sSclAD+");\n");
         _out.append("   }\n");
         _script.freeTmpVar(sVarLastPos);
      }

      // Advance
      _out.append("   if("+sVarPos+" >= 1.0f)\n");
      _out.append("   {\n");
      if(bLoop)
      {
         _out.append("      "+sVarPos+" = ffrac_s("+sVarPos+");\n");
      }
      else
      {
         _out.append("      "+sVarPos+" = 1.0f;\n");
      }
      if(inOnEnd.isConnected())
      {
         sIndent.empty();
         local String sVarOnEndTmp <= _script.allocTmpVar(sIndent, "env_onend");
         inOnEnd.emitFloat(_script, sIndent, sVarOnEndTmp);
         CyScript.AppendIndentedLines(_out, sIndent, 6);
         _script.freeTmpVar(sVarOnEndTmp);
      }
      _out.append("   }\n");
      _out.append("}\n");

      if!(sVarRateAD.isBlank())
         _script.freeTmpVar(sVarRateAD);

      if!(sVarRateR.isBlank())
         _script.freeTmpVar(sVarRateR);

      if!(sVarScl.isBlank())
         _script.freeTmpVar(sVarScl);

      _script.freeTmpVar(sVarSusPos);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      _out.append("// env sDstVar=\""+_sDstVar+"\"\n");

      local CyInput inAD      <= findInputById("ad");
      local CyInput inS       <= findInputById("s");
      local CyInput inR       <= findInputById("r");
      local CyInput inLoop    <= findInputById("loop");
      local CyInput inRestart <= findInputById("restart");  // (todo)
      // // local CyInput inSR      <= findInputById("sr");
      local CyInput inOnEnd   <= findInputById("onend");
      local CyInput inScl     <= findInputById("scl");
      local CyInput inTuned   <= findInputById("tuned");

      local boolean bLoop  = (inLoop .getConstVal() >= 0.5f);
      // // local boolean bSR    = !_script.b_lofi && (inSR   .getConstVal() >= 0.5f);
      local boolean bTuned = (inTuned.getConstVal() >= 0.5f);

      if(bTuned)
         bLoop = true;

      local String sInit;
      local String sVarLastGate  <= _script.allocTmpVarIntInitVoice(sInit, "env_last_gate",  0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarPos       <= _script.allocTmpVarIntInitVoice(sInit, "env_pos",        0, true/*bCycleReset*/, true/*bVoiceReset*/);  // 14bit
      local String sVarRate      <= _script.allocTmpVarIntInitVoice(sInit, "env_rate",       0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarHaltPos;  // 14bit
      local String *sVarLastLevel;
      local String *sVarSetLevelScl;
      local String *sVarLevelScl;
      local String *sVarOutScl;
      // local String *sVarLastPos;
      if(!bLoop)
      {
         sVarHaltPos     <= _script.allocTmpVarIntInitVoice(sInit, "env_halt_pos",      (FX_ONE<<3), true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarLastLevel   <= _script.allocTmpVarIntInitVoice(sInit, "env_last_level",    0,           true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarSetLevelScl <= _script.allocTmpVarIntInitVoice(sInit, "env_set_level_scl", 0,           true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarLevelScl    <= _script.allocTmpVarIntInitVoice(sInit, "env_level_scl",     FX_ONE,      true/*bCycleReset*/, true/*bVoiceReset*/);
         sVarOutScl      <= _script.allocTmpVarIntInitVoice(sInit, "env_out_scl",       FX_ONE,      true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      else
      {
         // sVarLastPos     <= _script.allocTmpVarInitVoice    (sInit, "env_last_pos",      1, true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      _script.appendInit(sInit);

      local String sIndent;

      // Sustain position
      local String sVarSusPos <= _script.allocTmpVarInt(_out, "env_suspos");
      inS.emitInt(_script, _out, sVarSusPos);
      _out.append(sVarSusPos+" = "+sVarSusPos+" << 3;\n");  // 11bit => 14bit

      local String *sSclAD;
      local String *sSclR;
      local String  sVarRateAD;
      local String  sVarRateR;
      local String  sVarScl;  // used only in loop mode
      local String *sScl;
      float fScl;

      if(bLoop)
      {
         if(bTuned)
         {
            // Pitch-independent AD/S/R (audio rate)
            sVarRateAD = _script.allocTmpVarInt(_out, "env_tuned_ad");
            inAD.emitFloat(_script, _out, sVarRateAD);
            sSclAD <= sVarRateAD;

            sVarRateR  = _script.allocTmpVarInt(_out, "env_tuned_r");
            inR.emitFloat(_script, _out, sVarRateR);
            sSclR  <= sVarRateR;

            local String sVarSum <= _script.allocTmpVarInt(_out, "env_sum");
            _out.append(sVarSum+" = "+sVarRateR+" + Dmulsw_shr("+sVarRateAD+" - "+sVarRateR+", * "+sVarSusPos+");\n");
            _out.append("if("+int(0)+" != "+sVarSum+")\n");
            _out.append("   "+sVarSum+" = ("+int(FX_ONE<<3)+" / ("+sVarSum+" >> 8));\n");  // (todo) rcp (avoid div)

            sScl <= _script.evalAddSRInputInt(inScl, _out, sVarScl);
            if(sVarScl.isBlank())  // const? (no var allocated)
            {
               sVarScl = _script.allocTmpVarInt(_out, "env_tuned_scl");
               _out.append(sVarScl+" = Dmulsw_shr("+sScl+", "+sVarSum+");\n");
               sScl <= sVarScl;
            }
            else
            {
               _out.append(sVarScl+" = Dmulsw_shr("+sVarScl+", "+sVarSum+");\n");
            }

            _script.freeTmpVarInt(sVarSum);
         }
         else
         {
            sVarScl = _script.allocTmpVarInt(_out, "env_loop_scl");
            if(inScl.isConstVal())
            {
               fScl = inScl.getConstVal();
               _out.append(sVarScl+" = "+int((FX_ONE*8)*fScl)+";\n");  // 14bit
            }
            else
            {
               inScl.emitInt(_script, _out, sVarScl);
            }
            sSclAD <= _script.evalAddSRInputInt(inAD, _out, sVarRateAD);
            sSclR  <= _script.evalAddSRInputInt(inR,  _out, sVarRateR);
            sScl <= sVarScl;
         }
      }

      // Gate
      _out.append(IfRisingEdgeInt(_sDstVar, sVarLastGate));
      _out.append("{\n");
      // Attack / Decay
      _out.append("   "+sVarPos+" = "+int(0)+";\n");
      if(!bLoop)
      {
         sIndent.empty();
         sSclAD <= _script.evalAddSRInputInt(inAD, sIndent, sVarRateAD);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         if(inScl.isConstVal())
         {
            fScl = inScl.getConstVal();
            _out.append("   "+sVarRate+" = Dmulsw_shr("+int((FX_ONE*8)*fScl)+", "+sSclAD+");\n");  // 14bit
         }
         else
         {
            sIndent.empty();
            inScl.emitInt(_script, sIndent, sVarRate);
            CyScript.AppendIndentedLines(_out, sIndent, 3);
            _out.append("   "+sVarRate+" = Dmulsw_shr("+sVarRate+"<<3, "+sSclAD+");\n");  // 14bit
         }
         _out.append("   "+sVarHaltPos+" = "+sVarSusPos+";\n");
         _out.append("   "+sVarLevelScl+" = "+int(FX_ONE)+";\n");
         _out.append("   "+sVarOutScl+" = "+int(FX_ONE)+";\n");
      }
      _out.append("   "+sVarLastGate+" = "+int(FX_ONE)+";\n");
      _out.append("}\n");
      if(!bLoop)
      {
         _out.append("else "+IfFallingEdgeInt(_sDstVar, sVarLastGate));
         _out.append("{\n");
         // Release
         sIndent.empty();
         sSclR <= _script.evalAddSRInputInt(inR, sIndent, sVarRateR);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         if(inScl.isConstVal())
         {
            fScl = inScl.getConstVal();
            _out.append("   "+sVarRate+" = Dmulsw_shr("+int((FX_ONE*8)*fScl)+", "+sSclR+");\n");  // 14bit
         }
         else
         {
            sIndent.empty();
            inScl.emitInt(_script, sIndent, sVarRate);
            CyScript.AppendIndentedLines(_out, sIndent, 3);
            _out.append("   "+sVarRate+" = Dmulsw_shr("+sVarRate+"<<3, "+sSclR+");\n");  // 14bit
         }
         _out.append("   "+sVarLastGate+" = "+int(0)+";\n");
         _out.append("   "+sVarSetLevelScl+" = 1;\n");
         _out.append("   "+sVarOutScl+" = "+sVarLastLevel+";\n");
         _out.append("   "+sVarPos+" = "+sVarSusPos+";\n");
         _out.append("   "+sVarHaltPos+" = "+int(FX_ONE<<3)+";\n");  // 14bit
         _out.append("}\n");
      }

      // Calc output
      if(null != seq_right)
      {
         _out.append(_sDstVar+" = "+sVarPos+" >> 3;\n");  // 14bit => 11bit
         seq_right.emitIntSequence(_script, _out, _sDstVar);
      }
      else
      {
         trace "[~~~] CyModuleEnv<int>: level subtree is empty, substituting zero.";
         _out.append(_sDstVar+" = "+int(0)+";\n");
      }

      // Update level scaling (when entering release phase)
      if(!bLoop)
      {
         _out.append("if("+sVarSetLevelScl+")\n");
         _out.append("{\n");
         _out.append("   "+sVarSetLevelScl+" = 0;\n");
         _out.append("   if(0 != "+_sDstVar+")\n");
         /*
           (2048) / (1.5*2048) = 0.666*2048 =  1365
           lsh(round((2048) / rsh(round(1.5*2048), 8)), 3) = 1368 (~0.66796875)
          */
         // // // _out.append("      "+sVarLevelScl+" = ("+int(FX_ONE)+" / "+_sDstVar+");\n");
         // // _out.append("      "+sVarLevelScl+" = ("+int(FX_ONE << 3)+" / ("+_sDstVar+" >> 8));\n");   // (todo) rcp (avoid div)
         // round((lsh(2048,8)) / rsh(round(0.1*2048), 3)) / 2048.0
         // round((lsh(2048,11)) / rsh(round(0.1*2048), 0)) / 2048.0
         _out.append("      "+sVarLevelScl+" = ("+int(FX_ONE << 11)+" / ("+_sDstVar+" /*>> 0*/));\n");   // (todo) rcp (avoid div)
         _out.append("   else\n");
         _out.append("      "+sVarLevelScl+" = "+int(0)+";\n");
         _out.append("}\n");

         _out.append(_sDstVar+" = Dmulsw_shr("+_sDstVar+", "+sVarLevelScl+");\n");
         _out.append(sVarLastLevel+" = "+_sDstVar+";\n");
         _out.append(_sDstVar+" = Dmulsw_shr("+_sDstVar+", "+sVarOutScl+");\n");

         _out.append("if("+sVarPos+" < "+sVarHaltPos+")\n");
         _out.append("{\n");
         _out.append("   "+sVarPos+" += "+sVarRate+";\n");
      }
      else
      {
         _out.append("if("+sVarPos+" < "+sVarSusPos+")\n");
         _out.append("  "+sVarRate+" = Dmulsw_shr("+sScl+", "+sSclAD+");\n");  // 14bit
         _out.append("else\n");
         _out.append("  "+sVarRate+" = Dmulsw_shr("+sScl+", "+sSclR+");\n");  // 14bit

         _out.append("{\n");

         local String sVarLastPos <= _script.allocTmpVarInt(_out, "seq_loop_lastpos");
         _out.append("   "+sVarLastPos+" = "+sVarPos+";\n");
         _out.append("   "+sVarPos+" += "+sVarRate+";\n");
         _out.append("   if("+sVarPos+" > "+sVarSusPos+" && "+sVarLastPos+" < "+sVarSusPos+" && ("+int(0)+" != "+sSclAD+"))\n");
         _out.append("   {\n");
         _out.append("      "+sVarPos+" = "+sVarSusPos+" + Dmulsw_shr("+sVarPos+" - "+sVarSusPos+", Dmulsw_shr("+sScl+", ("+sSclR+"<<11) / "+sSclAD+"));\n");
         _out.append("   }\n");
         _script.freeTmpVarInt(sVarLastPos);
      }

      // Advance
      _out.append("   if("+sVarPos+" >= "+int(FX_ONE<<3)+")\n");
      _out.append("   {\n");
      if(bLoop)
      {
         _out.append("      "+sVarPos+" = "+sVarPos+" & "+int((FX_ONE<<3)-1)+";\n");
      }
      else
      {
         _out.append("      "+sVarPos+" = "+int(FX_ONE<<3)+";\n");
      }
      if(inOnEnd.isConnected())
      {
         sIndent.empty();
         local String sVarOnEndTmp <= _script.allocTmpVarInt(sIndent, "env_onend");
         inOnEnd.emitInt(_script, sIndent, sVarOnEndTmp);
         CyScript.AppendIndentedLines(_out, sIndent, 6);
         _script.freeTmpVarInt(sVarOnEndTmp);
      }
      _out.append("   }\n");
      _out.append("}\n");

      if!(sVarRateAD.isBlank())
         _script.freeTmpVarInt(sVarRateAD);

      if!(sVarRateR.isBlank())
         _script.freeTmpVarInt(sVarRateR);

      if!(sVarScl.isBlank())
         _script.freeTmpVarInt(sVarScl);

      _script.freeTmpVarInt(sVarSusPos);
   }
}


// <class.png>
class CyModuleEQ3 : CyModule {
   // (note) see also: fx_example/eq3.cpp

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freqlo",  0.5, 0.0, 1.0);
      addInput("freqhi",  0.5, 0.0, 1.0);
      addInput("gainlo",  0.5, 0.0, 1.0);
      addInput("gainmid", 0.5, 0.0, 1.0);
      addInput("gainhi",  0.5, 0.0, 1.0);
      addInput("sr",      1.0, 0.0, 1.0);  // 1=factor in samplerate (must be const)

      addInputAlias("fl", "freqlo");    // fmax (2.0 * 0.089) =  0.178
      addInputAlias("fh", "freqhi");    // fmax (2.0 * 0.291768721876) = 0.583537443752
      addInputAlias("gl", "gainlo");
      addInputAlias("gm", "gainmid");
      addInputAlias("gh", "gainhi");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inFreqLo  <= findInputById("freqlo");
      local CyInput inFreqHi  <= findInputById("freqhi");
      local CyInput inGainLo  <= findInputById("gainlo");
      local CyInput inGainMid <= findInputById("gainmid");
      local CyInput inGainHi  <= findInputById("gainhi");
      local CyInput inSR      <= findInputById("sr");

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String sInit;

      local String sVarState_f1p0 <= _script.allocTmpVarInitVoice(sInit, "eq3_f1p0", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f1p1 <= _script.allocTmpVarInitVoice(sInit, "eq3_f1p1", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f1p2 <= _script.allocTmpVarInitVoice(sInit, "eq3_f1p2", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f1p3 <= _script.allocTmpVarInitVoice(sInit, "eq3_f1p3", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);

      local String sVarState_f2p0 <= _script.allocTmpVarInitVoice(sInit, "eq3_f2p0", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f2p1 <= _script.allocTmpVarInitVoice(sInit, "eq3_f2p1", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f2p2 <= _script.allocTmpVarInitVoice(sInit, "eq3_f2p2", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f2p3 <= _script.allocTmpVarInitVoice(sInit, "eq3_f2p3", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);

      local String sVarState_sdm1 <= _script.allocTmpVarInitVoice(sInit, "eq3_sdm1", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_sdm2 <= _script.allocTmpVarInitVoice(sInit, "eq3_sdm2", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_sdm3 <= _script.allocTmpVarInitVoice(sInit, "eq3_sdm3", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);

      _script.appendInit(sInit);

      local String *sFreqLo;
      local String *sFreqHi;
      local String sVarFreqLo;  // *may* be allocated by evalAddSRInput()
      local String sVarFreqHi;  // *may* be allocated by evalAddSRInput()

      if(bSR)
      {
         sFreqLo <= _script.evalAddSRInput(inFreqLo, _out, sVarFreqLo);
         sFreqHi <= _script.evalAddSRInput(inFreqHi, _out, sVarFreqHi);
      }
      else
      {
         sVarFreqLo <= _script.allocTmpVar(_out, "eq3_freqlo");
         inFreqLo.emitFloat(_script, _out, sVarFreqLo);
         sFreqLo <= sVarFreqLo;

         sVarFreqHi <= _script.allocTmpVar(_out, "eq3_freqhi");
         inFreqHi.emitFloat(_script, _out, sVarFreqHi);
         sFreqHi <= sVarFreqHi;
      }

      local String sVarGainLo <= _script.allocTmpVar(_out, "eq3_gainlo");
      inGainLo.emitFloat(_script, _out, sVarGainLo);

      local String sVarGainMid <= _script.allocTmpVar(_out, "eq3_gainmid");
      inGainMid.emitFloat(_script, _out, sVarGainMid);

      local String sVarGainHi <= _script.allocTmpVar(_out, "eq3_gainhi");
      inGainHi.emitFloat(_script, _out, sVarGainHi);

      local String sVarL <= _script.allocTmpVar(_out, "eq3_l");
      local String sVarM <= _script.allocTmpVar(_out, "eq3_m");
      local String sVarH <= _script.allocTmpVar(_out, "eq3_h");

      // Filter #1 (lowpass)
      _out.append(sVarState_f1p0+" += ("+sFreqLo+" * ("+_sDstVar+" - "+sVarState_f1p0+"));\n");/// + vsa;
      _out.append(sVarState_f1p1+" += ("+sFreqLo+" * ("+sVarState_f1p0+" - "+sVarState_f1p1+"));\n");
      _out.append(sVarState_f1p2+" += ("+sFreqLo+" * ("+sVarState_f1p1+" - "+sVarState_f1p2+"));\n");
      _out.append(sVarState_f1p3+" += ("+sFreqLo+" * ("+sVarState_f1p2+" - "+sVarState_f1p3+"));\n");

      _out.append(sVarL+" = "+sVarState_f1p3+";\n");

      // Filter #2 (highpass)
      _out.append(sVarState_f2p0+" += ("+sFreqHi+" * ("+_sDstVar+" - "+sVarState_f2p0+"));\n");/// + vsa;
      _out.append(sVarState_f2p1+" += ("+sFreqHi+" * ("+sVarState_f2p0+" - "+sVarState_f2p1+"));\n");
      _out.append(sVarState_f2p2+" += ("+sFreqHi+" * ("+sVarState_f2p1+" - "+sVarState_f2p2+"));\n");
      _out.append(sVarState_f2p3+" += ("+sFreqHi+" * ("+sVarState_f2p2+" - "+sVarState_f2p3+"));\n");

      _out.append(sVarH+" = "+sVarState_sdm3+" - "+sVarState_f2p3+";\n");

      // Calculate midrange (signal - (low + high))
      _out.append(sVarM+" = "+sVarState_sdm3+" - ("+sVarH+" + "+sVarL+");\n");

      // Shuffle history buffer
      _out.append(sVarState_sdm3+" = "+sVarState_sdm2+";\n");
      _out.append(sVarState_sdm2+" = "+sVarState_sdm1+";\n");
      _out.append(sVarState_sdm1+" = "+_sDstVar+";\n");

      // Scale and Combine
      _out.append(_sDstVar+" = "+sVarL+"*"+sVarGainLo+" + "+sVarM+"*"+sVarGainMid+" + "+sVarH+"*"+sVarGainHi+";\n");

      if(!sVarFreqLo.isBlank())
         _script.freeTmpVar(sVarFreqLo);

      if(!sVarFreqHi.isBlank())
         _script.freeTmpVar(sVarFreqHi);

      _script.freeTmpVar(sVarGainLo);
      _script.freeTmpVar(sVarGainMid);
      _script.freeTmpVar(sVarGainHi);

      _script.freeTmpVar(sVarL);
      _script.freeTmpVar(sVarM);
      _script.freeTmpVar(sVarH);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inFreqLo  <= findInputById("freqlo");
      local CyInput inFreqHi  <= findInputById("freqhi");
      local CyInput inGainLo  <= findInputById("gainlo");
      local CyInput inGainMid <= findInputById("gainmid");
      local CyInput inGainHi  <= findInputById("gainhi");
      local CyInput inSR      <= findInputById("sr");

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String sInit;

      local String sVarState_f1p0 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f1p0", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f1p1 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f1p1", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f1p2 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f1p2", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f1p3 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f1p3", 0, true/*bCycleReset*/, true/*bVoiceReset*/);

      local String sVarState_f2p0 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f2p0", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f2p1 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f2p1", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f2p2 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f2p2", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_f2p3 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_f2p3", 0, true/*bCycleReset*/, true/*bVoiceReset*/);

      local String sVarState_sdm1 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_sdm1", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_sdm2 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_sdm2", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarState_sdm3 <= _script.allocTmpVarIntInitVoice(sInit, "eq3_sdm3", 0, true/*bCycleReset*/, true/*bVoiceReset*/);

      _script.appendInit(sInit);


      local String *sFreqLo;
      local String *sFreqHi;
      local String sVarFreqLo;  // *may* be allocated by evalAddSRInputInt()
      local String sVarFreqHi;  // *may* be allocated by evalAddSRInputInt()

      if(bSR)
      {
         sFreqLo <= _script.evalAddSRInputInt(inFreqLo, _out, sVarFreqLo);
         sFreqHi <= _script.evalAddSRInputInt(inFreqHi, _out, sVarFreqHi);
      }
      else
      {
         sVarFreqLo <= _script.allocTmpVarInt(_out, "eq3_freqlo");
         inFreqLo.emitInt(_script, _out, sVarFreqLo);
         sFreqLo <= sVarFreqLo;

         sVarFreqHi <= _script.allocTmpVarInt(_out, "eq3_freqhi");
         inFreqHi.emitInt(_script, _out, sVarFreqHi);
         sFreqHi <= sVarFreqHi;
      }

      local String sVarGainLo <= _script.allocTmpVarInt(_out, "eq3_gainlo");
      inGainLo.emitInt(_script, _out, sVarGainLo);

      local String sVarGainMid <= _script.allocTmpVarInt(_out, "eq3_gainmid");
      inGainMid.emitInt(_script, _out, sVarGainMid);

      local String sVarGainHi <= _script.allocTmpVarInt(_out, "eq3_gainhi");
      inGainHi.emitInt(_script, _out, sVarGainHi);

      local String sVarL <= _script.allocTmpVarInt(_out, "eq3_l");
      local String sVarM <= _script.allocTmpVarInt(_out, "eq3_m");
      local String sVarH <= _script.allocTmpVarInt(_out, "eq3_h");

      // Filter #1 (lowpass)
      _out.append(sVarState_f1p0+" += Dmulsw_shr("+sFreqLo+", ("+_sDstVar+" - "+sVarState_f1p0+"));\n");/// + vsa;
      _out.append(sVarState_f1p1+" += Dmulsw_shr("+sFreqLo+", ("+sVarState_f1p0+" - "+sVarState_f1p1+"));\n");
      _out.append(sVarState_f1p2+" += Dmulsw_shr("+sFreqLo+", ("+sVarState_f1p1+" - "+sVarState_f1p2+"));\n");
      _out.append(sVarState_f1p3+" += Dmulsw_shr("+sFreqLo+", ("+sVarState_f1p2+" - "+sVarState_f1p3+"));\n");

      _out.append(sVarL+" = "+sVarState_f1p3+";\n");

      // Filter #2 (highpass)
      _out.append(sVarState_f2p0+" += Dmulsw_shr("+sFreqHi+", ("+_sDstVar+" - "+sVarState_f2p0+"));\n");/// + vsa;
      _out.append(sVarState_f2p1+" += Dmulsw_shr("+sFreqHi+", ("+sVarState_f2p0+" - "+sVarState_f2p1+"));\n");
      _out.append(sVarState_f2p2+" += Dmulsw_shr("+sFreqHi+", ("+sVarState_f2p1+" - "+sVarState_f2p2+"));\n");
      _out.append(sVarState_f2p3+" += Dmulsw_shr("+sFreqHi+", ("+sVarState_f2p2+" - "+sVarState_f2p3+"));\n");

      _out.append(sVarH+" = "+sVarState_sdm3+" - "+sVarState_f2p3+";\n");

      // Calculate midrange (signal - (low + high))
      _out.append(sVarM+" = "+sVarState_sdm3+" - ("+sVarH+" + "+sVarL+");\n");

      // Shuffle history buffer
      _out.append(sVarState_sdm3+" = "+sVarState_sdm2+";\n");
      _out.append(sVarState_sdm2+" = "+sVarState_sdm1+";\n");
      _out.append(sVarState_sdm1+" = "+_sDstVar+";\n");

      // Scale and Combine
      _out.append(_sDstVar+" = Dmulsw_shr("+sVarL+", "+sVarGainLo+") + Dmulsw_shr("+sVarM+", "+sVarGainMid+") + Dmulsw_shr("+sVarH+", "+sVarGainHi+");\n");

      if(!sVarFreqLo.isBlank())
         _script.freeTmpVarInt(sVarFreqLo);

      if(!sVarFreqHi.isBlank())
         _script.freeTmpVarInt(sVarFreqHi);

      _script.freeTmpVarInt(sVarGainLo);
      _script.freeTmpVarInt(sVarGainMid);
      _script.freeTmpVarInt(sVarGainHi);

      _script.freeTmpVarInt(sVarL);
      _script.freeTmpVarInt(sVarM);
      _script.freeTmpVarInt(sVarH);
   }

}



// <class.png>
class CyModuleFld : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("ceil", 1.0,  0.0, 2.0);  // => min=-ceil, max=+ceil
      addInput("min",  0.0, -2.0, 2.0);
      addInput("max",  0.0, -2.0, 2.0);
      addInput("hq",   1.0,  0.0, 1.0);  // const (>=0.5: use mathFoldf())

      addInputAlias("c", "ceil");
      addInputAlias("m", "min");
      addInputAlias("x", "max");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inCeil <= findInputById("ceil");
      local CyInput inMin  <= findInputById("min");
      local CyInput inMax  <= findInputById("max");
      local CyInput inHQ   <= findInputById("hq");

      local boolean bHQ = (inHQ.getConstVal() >= 0.5f);

      local String *sMin;
      local String *sMax;

      if(inMin.isConnected() || inMax.isConnected() ||
         (inMin.isConstVal() && !inMin.isConst0()) ||
         (inMax.isConstVal() && !inMax.isConst0())
         )
      {
         if(inMin.isConstVal() && inMax.isConstVal())
         {
            float fMin = inMin.getConstVal();
            float fMax = inMax.getConstVal();
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathFoldf("+_sDstVar+", "+FloatToString(fMin)+", "+FloatToString(fMax)+");\n");
               parent_script.b_use_foldf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+FloatToString(fMax)+") "+_sDstVar+" = "+FloatToString(2.0f*fMax)+" - "+_sDstVar+";\n");
               _out.append("else if("+_sDstVar+" < "+FloatToString(fMin)+") "+_sDstVar+" = "+FloatToString(2.0f*fMin)+" - "+_sDstVar+";\n");
            }
         }
         else
         {
            sMin <= _script.allocTmpVar(_out, "fld_min");
            sMax <= _script.allocTmpVar(_out, "fld_max");
            inMin.emitFloat(_script, _out, sMin);
            inMax.emitFloat(_script, _out, sMax);
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathFoldf("+_sDstVar+", "+sMin+", "+sMax+");\n");
               parent_script.b_use_foldf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+sMax+") "+_sDstVar+" = (2.0f * "+sMax+") - "+_sDstVar+";\n");
               _out.append("else if("+_sDstVar+" < "+sMin+") "+_sDstVar+" = (2.0f * "+sMin+") - "+_sDstVar+";\n");
            }
            _script.freeTmpVar(sMin);
            _script.freeTmpVar(sMax);
         }
      }
      else
      {
         if(inCeil.isConstVal())
         {
            float fCeil = inCeil.getConstVal();
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathFoldf("+_sDstVar+", "+FloatToString(-fCeil)+", "+FloatToString(fCeil)+");\n");
               parent_script.b_use_foldf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+FloatToString(fCeil)+") "+_sDstVar+" = "+FloatToString(2.0f*fCeil)+" - "+_sDstVar+";\n");
               _out.append("else if("+_sDstVar+" < -("+FloatToString(fCeil)+")) "+_sDstVar+" = "+FloatToString(2.0f*-fCeil)+" - "+_sDstVar+";\n");
            }
         }
         else
         {
            local String sCeil <= _script.allocTmpVar(_out, "ceil");
            inCeil.emitFloat(_script, _out, sCeil);
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathFoldf("+_sDstVar+", -"+sCeil+", "+sCeil+");\n");
               parent_script.b_use_foldf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+sCeil+") "+_sDstVar+" = (2.0f * "+sCeil+") - "+_sDstVar+";\n");
               _out.append("else if("+_sDstVar+" < -("+sCeil+")) "+_sDstVar+" = (-2.0f * "+sCeil+") - "+_sDstVar+";\n");
            }
            _script.freeTmpVar(sCeil);
         }
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inCeil <= findInputById("ceil");
      local CyInput inMin  <= findInputById("min");
      local CyInput inMax  <= findInputById("max");
      local CyInput inHQ   <= findInputById("hq");

      local boolean bHQ = (inHQ.getConstVal() >= 0.5f);

      local String *sMin;
      local String *sMax;

      if(bHQ)
      {
         trace "[~~~] warning: CyModuleFld<int,HQ>: falling back to float..";
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      if(inMin.isConnected() || inMax.isConnected() ||
         (inMin.isConstVal() && !inMin.isConst0()) ||
         (inMax.isConstVal() && !inMax.isConst0())
         )
      {
         if(inMin.isConstVal() && inMax.isConstVal())
         {
            float iMin = inMin.getConstVal() * FX_ONE;
            float iMax = inMax.getConstVal() * FX_ONE;
            _out.append("if("+_sDstVar+" > "+iMax+") "+_sDstVar+" = "+(2*iMax)+" - "+_sDstVar+";\n");
            _out.append("else if("+_sDstVar+" < "+iMin+") "+_sDstVar+" = "+(2*iMin)+" - "+_sDstVar+";\n");
         }
         else
         {
            sMin <= _script.allocTmpVarInt(_out, "fld_min");
            sMax <= _script.allocTmpVarInt(_out, "fld_max");
            inMin.emitInt(_script, _out, sMin);
            inMax.emitInt(_script, _out, sMax);
            _out.append("if("+_sDstVar+" > "+sMax+") "+_sDstVar+" = ("+sMax+" << 1) - "+_sDstVar+";\n");
            _out.append("else if("+_sDstVar+" < "+sMin+") "+_sDstVar+" = ("+sMin+" << 1) - "+_sDstVar+";\n");
            _script.freeTmpVarInt(sMin);
            _script.freeTmpVarInt(sMax);
         }
      }
      else
      {
         if(inCeil.isConstVal())
         {
            int iCeil = inCeil.getConstVal() * FX_ONE;
            _out.append("if("+_sDstVar+" > "+iCeil+") "+_sDstVar+" = "+(2*iCeil)+" - "+_sDstVar+";\n");
            _out.append("else if("+_sDstVar+" < -("+iCeil+")) "+_sDstVar+" = "+(2*-iCeil)+" - "+_sDstVar+";\n");
         }
         else
         {
            local String sVarCeil <= _script.allocTmpVarInt(_out, "ceil");
            inCeil.emitInt(_script, _out, sVarCeil);

            _out.append("if("+_sDstVar+" > "+sVarCeil+") "+_sDstVar+" = (2 * "+sVarCeil+") - "+_sDstVar+";\n");
            _out.append("else if("+_sDstVar+" < -("+sVarCeil+")) "+_sDstVar+" = (-2 * "+sVarCeil+") - "+_sDstVar+";\n");

            _script.freeTmpVarInt(sVarCeil);
         }
      }
   }
}


// <class.png>
class CyModuleFam : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("add",  1.0, -16.0, 16.0);
      addInput("mul",  0.5, -16.0, 16.0);

      addInputAlias("a", "add");
      addInputAlias("m", "mul");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inAdd <= findInputById("add");
      local CyInput inMul <= findInputById("mul");

      local String *sAdd;
      local String *sVarAdd;
      if(inAdd.isConstVal())
      {
         sAdd <= FloatToString(inAdd.getConstVal());
      }
      else
      {
         sVarAdd <= _script.allocTmpVar(_out, "add");
         sAdd <= sVarAdd;
         inAdd.emitFloat(_script, _out, sVarAdd);
      }

      local String *sMul;
      local String *sVarMul;
      if(inMul.isConstVal())
      {
         sMul <= FloatToString(inMul.getConstVal());
      }
      else
      {
         sVarMul <= _script.allocTmpVar(_out, "mul");
         sMul <= sVarMul;
         inMul.emitFloat(_script, _out, sVarMul);
      }

      _out.append(_sDstVar+" = ("+_sDstVar+" + "+sAdd+") * "+sMul+";\n");

      if(null != sVarAdd)
         _script.freeTmpVar(sVarAdd);

      if(null != sVarMul)
         _script.freeTmpVar(sVarMul);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inAdd <= findInputById("add");
      local CyInput inMul <= findInputById("mul");

      local String *sAdd;
      local String *sVarAdd;
      if(inAdd.isConstVal())
      {
         sAdd <= String(int(inAdd.getConstVal() * FX_ONE));
      }
      else
      {
         sVarAdd <= _script.allocTmpVarInt(_out, "add");
         inAdd.emitInt(_script, _out, sVarAdd);
         sAdd <= sVarAdd;
      }

      local String *sMul;
      local String *sVarMul;
      if(inMul.isConstVal())
      {
         sMul <= String(int(inMul.getConstVal() * FX_ONE));
      }
      else
      {
         sVarMul <= _script.allocTmpVarInt(_out, "mul");
         inMul.emitInt(_script, _out, sVarMul);
         sMul <= sVarMul;
      }

      if(b_export_c)
         _out.append(_sDstVar+" = Dmulsw_shr(("+_sDstVar+" + "+sAdd+"), "+sMul+");\n");
      else
         _out.append(_sDstVar+" = (("+_sDstVar+" + "+sAdd+") * "+sMul+") >> "+FX_SHR+";\n");

      if(null != sVarAdd)
         _script.freeTmpVarInt(sVarAdd);

      if(null != sVarMul)
         _script.freeTmpVarInt(sVarMul);
   }
}


// <class.png>
class CyModuleFma : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("mul",  2.0, -16.0, 16.0);
      addInput("add", -1.0, -16.0, 16.0);

      addInputAlias("m", "mul");
      addInputAlias("a", "add");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inMul <= findInputById("mul");
      local CyInput inAdd <= findInputById("add");

      local String *sMul;
      local String *sVarMul;
      if(inMul.isConstVal())
      {
         sMul <= FloatToString(inMul.getConstVal());
      }
      else
      {
         sVarMul <= _script.allocTmpVar(_out, "mul");
         sMul <= sVarMul;
         inMul.emitFloat(_script, _out, sVarMul);
      }

      local String *sAdd;
      local String *sVarAdd;
      if(inAdd.isConstVal())
      {
         sAdd <= FloatToString(inAdd.getConstVal());
      }
      else
      {
         sVarAdd <= _script.allocTmpVar(_out, "add");
         sAdd <= sVarAdd;
         inAdd.emitFloat(_script, _out, sVarAdd);
      }

      _out.append(_sDstVar+" = ("+_sDstVar+" * "+sMul+") + "+sAdd+";\n");

      if(null != sVarMul)
         _script.freeTmpVar(sVarMul);

      if(null != sVarAdd)
         _script.freeTmpVar(sVarAdd);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inMul <= findInputById("mul");
      local CyInput inAdd <= findInputById("add");

      local String *sMul;
      local String *sVarMul;
      if(inMul.isConstVal())
      {
         sMul <= String(int(inMul.getConstVal() * FX_ONE));
      }
      else
      {
         sVarMul <= _script.allocTmpVarInt(_out, "mul");
         inMul.emitInt(_script, _out, sVarMul);
         sMul <= sVarMul;
      }

      local String *sAdd;
      local String *sVarAdd;
      if(inAdd.isConstVal())
      {
         sAdd <= String(int(inAdd.getConstVal() * FX_ONE));
      }
      else
      {
         sVarAdd <= _script.allocTmpVarInt(_out, "add");
         inAdd.emitInt(_script, _out, sVarAdd);
         sAdd <= sVarAdd;
      }

      if(b_export_c)
         _out.append(_sDstVar+" = (mulsw("+_sDstVar+", "+sMul+") >> "+FX_SHR+") + "+sAdd+";\n");
      else
         _out.append(_sDstVar+" = (("+_sDstVar+" * "+sMul+") >> "+FX_SHR+") + "+sAdd+";\n");

      if(null != sVarMul)
         _script.freeTmpVarInt(sVarMul);

      if(null != sVarAdd)
         _script.freeTmpVarInt(sVarAdd);
   }
}


// <class.png>
class CyModuleFrc : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("signed", 0, 0, 1);   // 1= -1.67 => -1.67   0= -0.67 => 0.33
      addInputAlias("s", "signed");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inSigned <= findInputById("signed");
      boolean bSigned = (inSigned.getConstVal() >= 0.5);

      if(bSigned)
      {
         _out.append(_sDstVar+" = "+_sDstVar+" - int("+_sDstVar+");\n");
      }
      else
      {
         _out.append(_sDstVar+" = ffrac_s("+_sDstVar+");\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inSigned <= findInputById("signed");
      boolean bSigned = (inSigned.getConstVal() >= 0.5);

      if(bSigned)
      {
         _out.append(_sDstVar+" = ("+_sDstVar+" < 0) ? -(-"+_sDstVar+" & "+int(FX_ONE-1)+") : ("+_sDstVar+" & "+int(FX_ONE-1)+");\n");
      }
      else
      {
         _out.append(_sDstVar+" = ("+_sDstVar+" & "+int(FX_ONE-1)+");\n");
      }
   }
}


// <class.png>
class CyModuleFsr : CyModule {
   // non-repeating random number generator (linear feedback shift register)

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      // (note) all inputs must be const
      addInput("seed",   0x4489, 0.0,  65535);
      addInput("bits",   1,      0.0,  1.0);
      addInput("cycle",  1,      0,    1);
      addInput("shift1", 7,    -15,    15);
      addInput("shift2", -9,   -15,    15);
      addInput("shift3", 13,   -15,    15);
      addInput("reset",  1,      0,    1);
      addInput("signed", 1,      0,    1);

      addInputAlias("s",   "seed");
      addInputAlias("b",   "bits");
      addInputAlias("sh1", "shift1");
      addInputAlias("sh2", "shift2");
      addInputAlias("sh3", "shift3");
      addInputAlias("rs",  "reset");
      addInputAlias("sgn", "signed");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      emitIntFallback(_script, _out, _sDstVar);
   }

   // <method.png>
   protected static GetShiftString(int _shift) : String {
      if(0 == _shift)
         return "";
      else if(_shift > 0)
         return ">> "+_shift;
      else
         return "<< "+-_shift;
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inSeed   <= findInputById("seed");
      local CyInput inBits   <= findInputById("bits");
      local CyInput inCycle  <= findInputById("cycle");
      local CyInput inShift1 <= findInputById("shift1");
      local CyInput inShift2 <= findInputById("shift2");
      local CyInput inShift3 <= findInputById("shift3");
      local CyInput inReset  <= findInputById("reset");
      local CyInput inSigned <= findInputById("signed");

      int seed = int(inSeed.getConstVal());
      boolean bSigned = (inSigned.getConstVal() >= 0.5);

      int shrBits = FX_SHR + bSigned;
      int bits = int(inBits.getConstVal() * shrBits + 0.5);
      if(bits < 2)
         bits = 2;
      else if(bits > shrBits)
         bits = shrBits;
      int mask = ((1 << bits)-1) << (15 - bits + bSigned);
      // svvvvvvvvvvv----
      // sv--------------
      // xxxxxooooooooooo
      int shift = 16 - (FX_SHR+1);

      int shift1 = mathClampi(inShift1.getConstVal(), -15, 15);
      int shift2 = mathClampi(inShift2.getConstVal(), -15, 15);
      int shift3 = mathClampi(inShift3.getConstVal(), -15, 15);

      local String sInit;
      local String sVarState <= _script.allocTmpVarUInt16Init(sInit, "lfsr_state", seed, true/*bMultiplyInitByVoiceIdx*/,
                                                              !b_plugin && (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                              (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                              );
      local String sVarStateSigned <= _script.allocTmpVarInt16Init(sInit, "lfsr_state_signed", 0,
                                                                   true/*bCycleReset=localvar*/
                                                                   );
      _script.appendInit(sInit);

      _out.append(sVarState+" ^= "+sVarState+" "+GetShiftString(shift1)+";\n"); // def= >> 7
      _out.append(sVarState+" ^= "+sVarState+" "+GetShiftString(shift2)+";\n"); // def= << 9
      _out.append(sVarState+" ^= "+sVarState+" "+GetShiftString(shift3)+";\n"); // def= >> 13
      _out.append(sVarStateSigned+" = ("+sVarState+" & "+mask+");\n");  // reinterpret as signed
      _out.append(_sDstVar+" = "+sVarStateSigned+" >> "+shift+";\n");  // signed shift right (asr)
   }
}


// <class.png>
class CyModuleFwr : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("bipolar", 0, 0, 1);   // 1=rescale to -1..1 range
      addInput("neg",     0, 0, 1);   // 1=flip sign of result

      addInputAlias("b", "bipolar");
      addInputAlias("n", "neg");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inBipolar <= findInputById("bipolar");
      local CyInput inNeg     <= findInputById("neg");

      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);
      local boolean bNeg     = (inNeg    .getConstVal() >= 0.5f);

      if(b_plugin)
      {
         if(bNeg)
         {
            _out.append("{\n");
            _out.append("   stplugin_fi_t t; t.f = "+_sDstVar+";\n");
            _out.append("   t.u |= 0x80000000u;\n");
            if(bBipolar)
               _out.append("   "+_sDstVar+" = t.f * 2.0f + 1.0f;\n");
            _out.append("}\n");
         }
         else
         {
            _out.append("{\n");
            _out.append("   stplugin_fi_t t; t.f = "+_sDstVar+";\n");
            _out.append("   t.u &= 0x7FFFffffu;\n");
            if(bBipolar)
               _out.append("   "+_sDstVar+" = t.f * 2.0f - 1.0f;\n");
            _out.append("}\n");
         }
      }
      else
      {
         _out.append("if("+_sDstVar+" < 0.0f) "+_sDstVar+" = -"+_sDstVar+";\n");
         if(bBipolar)
            _out.append(_sDstVar+" = "+_sDstVar+" * 2.0f - 1.0f;\n");
      }

   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inBipolar <= findInputById("bipolar");
      local CyInput inNeg     <= findInputById("neg");

      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);
      local boolean bNeg     = (inNeg    .getConstVal() >= 0.5f);

      if(bNeg)
      {
         _out.append("if("+_sDstVar+" >= 0) "+_sDstVar+" = -"+_sDstVar+";\n");
         if(bBipolar)
            _out.append(_sDstVar+" = ("+_sDstVar+" << 1) + "+FX_ONE+";\n");
      }
      else
      {
         _out.append("if("+_sDstVar+" < 0) "+_sDstVar+" = -"+_sDstVar+";\n");
         if(bBipolar)
            _out.append(_sDstVar+" = ("+_sDstVar+" << 1) - "+FX_ONE+";\n");
      }
   }
}


// <class.png>
class CyModuleHbx : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq", 0.5, 0.0, 1.0);
      addInput("sr",   1.0, 0.0, 1.0);

      addInputAlias("f", "freq");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inFreq <= findInputById("freq");
      local CyInput inSR   <= findInputById("sr");

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String sInit;
      local String sVarLast <= _script.allocTmpVarInit(sInit, "hbx_last", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      if(inFreq.isConstVal())
      {
         float fFreq = inFreq.getConstVal();
         fFreq *= fFreq;
         fFreq *= fFreq;

         if(bSR)
         {
            if(b_plugin)
               _out.append(sVarLast+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+_script.allocAddSRConstVarFloat(fFreq)+");\n");
            else
               _out.append(sVarLast+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+FloatToString(fFreq / _script.oversample_factor)+");\n");
         }
         else
         {
            _out.append(sVarLast+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+FloatToString(fFreq)+");\n");
         }

      }
      else
      {
         local String sVarFreq <= _script.allocTmpVar(_out, "freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         _out.append(sVarFreq+" *= "+sVarFreq+";\n");
         _out.append(sVarFreq+" *= "+sVarFreq+";\n");

         if(bSR)
         {
            if(b_plugin)
            {
               _out.append(sVarLast+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+" * voice->sr_factor);\n");
               _script.b_use_sr_factor = true;
            }
            else
            {
               if(_script.oversample_factor > 1)
                  _out.append(sVarLast+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+" * "+FloatToString(1.0f / _script.oversample_factor)+");\n");
               else
                  _out.append(sVarLast+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+");\n");
            }
         }
         else
         {
            _out.append(sVarLast+" = mathLerpf("+sVarLast+", "+_sDstVar+", "+sVarFreq+");\n");
         }

         _script.freeTmpVar(sVarFreq);
      }

      _out.append(_sDstVar+" = "+_sDstVar+" - "+sVarLast+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSR <= findInputById("sr");
      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);
      if(bSR)
      {
         trace "[~~~] warning: CyModuleHbx<int,sr>: falling back to float..";
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      local String sInit;
      local String sVarLast <= _script.allocTmpVarIntInit(sInit, "hbx_last", 0, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local CyInput inFreq <= findInputById("freq");
      if(inFreq.isConstVal())
      {
         float fFreq = inFreq.getConstVal();  // range 0..1
         fFreq *= fFreq;
         fFreq *= fFreq;
         int iFreq = fFreq * 32767;
         if(b_export_c)
            _out.append(sVarLast+" = "+sVarLast+" + (mulsw(((short)("+_sDstVar+" - "+sVarLast+")), "+iFreq+") >> 15);\n");
         else
            _out.append(sVarLast+" = "+sVarLast+" + ((("+_sDstVar+" - "+sVarLast+") * "+iFreq+") >> 15);\n");
         _out.append(_sDstVar+" = "+_sDstVar+" - "+sVarLast+";\n");
      }
      else
      {
         local String sVarFreq <= _script.allocTmpVar(_out, "freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         // (todo) use x^4 pow table
         if(b_export_c)
         {
            _out.append(sVarFreq+" = mulsw("+sVarFreq+", "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(sVarFreq+" = mulsw("+sVarFreq+", "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(sVarLast+" = "+sVarLast+" + (mulsw((short)("+_sDstVar+" - "+sVarLast+"), "+sVarFreq+") >> "+FX_SHR+");\n");
         }
         else
         {
            _out.append(sVarFreq+" = ("+sVarFreq+" * "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(sVarFreq+" = ("+sVarFreq+" * "+sVarFreq+") >> "+FX_SHR+";\n");
            _out.append(sVarLast+" = "+sVarLast+" + ((("+_sDstVar+" - "+sVarLast+") * "+sVarFreq+") >> "+FX_SHR+");\n");
         }
         _out.append(_sDstVar+" = "+_sDstVar+" - "+sVarLast+";\n");
         _script.freeTmpVar(sVarFreq);
      }
   }
}


// <class.png>
class CyModuleHld : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("rate",     1.0, 0.0, 1.0);
      addInput("sr",       1.0, 0.0, 1.0);  // 1=(over)samplerate-independent rate (def=1). must be const
      addInput("onsample", 0.0, 0.0, 1.0);  // evaluated when a new sample is taken (input is sample, output is new sample)

      addInputAlias("r",  "rate");
      addInputAlias("os", "onsample");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inRate     <= findInputById("rate");
      local CyInput inSR       <= findInputById("sr");
      local CyInput inOnSample <= findInputById("onsample");

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local float fRate;
      local boolean bConstRate = inRate.isConstVal();
      if(bConstRate)
      {
         fRate = inRate.getConstVal();
         if(fRate > 1.0)
            fRate = 1.0;
      }

      local String sInit;
      local String sVarCnt <= _script.allocTmpVarInit(sInit, "hld_cnt", 1.0f, true/*bCycleReset*/);
      local String sVarSmp <= _script.allocTmpVarInit(sInit, "hld_smp", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sIndent;

      _out.append("if("+sVarCnt+" >= 1.0f)\n");
      _out.append("{\n");
      if(inOnSample.isConnected())
      {
         local String sVarSmpTmp <= _script.allocTmpVar(_out, "hld_onsample");
         sIndent.empty();
         sIndent.append(sVarSmpTmp+" = "+_sDstVar+";\n");
         inOnSample.emitFloat(_script, sIndent, sVarSmpTmp);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("    "+sVarSmp+" = "+sVarSmpTmp+";\n");
         _script.freeTmpVar(sVarSmpTmp);
      }
      else
      {
         _out.append("    "+sVarSmp+" = "+_sDstVar+";\n");
      }
      _out.append("    "+sVarCnt+" -= 1.0f;\n");
      _out.append("}\n");
      _out.append(_sDstVar+" = "+sVarSmp+";\n");

      if(bConstRate)
      {
         if(bSR)
         {
            if(b_plugin)
               _out.append(sVarCnt+" += "+_script.allocAddSRConstVarFloat(fRate)+";\n");
            else
               _out.append(sVarCnt+" += "+FloatToString(fRate / _script.oversample_factor)+";\n");
         }
         else
         {
            _out.append(sVarCnt+" += "+FloatToString(fRate)+";\n");
         }
      }
      else
      {
         // (note) patch programmer must ensure that rate does not exceed 1.0
         local String sVarRate <= _script.allocTmpVar(_out, "rate");
         inRate.emitFloat(_script, _out, sVarRate);

         if(bSR)
         {
            if(b_plugin)
            {
               _out.append(sVarRate+" *= voice->sr_factor;\n");
               _script.b_use_sr_factor = true;
            }
            else if(_script.oversample_factor > 1)
               _out.append(sVarRate+" *= "+FloatToString(1.0f / _script.oversample_factor)+";\n");
         }

         _out.append(sVarCnt+" += "+sVarRate+";\n");

         _script.freeTmpVar(sVarRate);
      }

   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inRate     <= findInputById("rate");
      // local CyInput inSR       <= findInputById("sr");
      local CyInput inOnSample <= findInputById("onsample");

      local CyInput inSR <= findInputById("sr");
      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);
      if(bSR)
      {
         trace "[~~~] warning: CyModuleHld<int,sr>: falling back to float..";
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      local float fRate;
      local boolean bConstRate = inRate.isConstVal();
      if(bConstRate)
      {
         fRate = inRate.getConstVal();
         if(fRate > 1.0)
            fRate = 1.0;
      }

      local String sInit;
      local String sVarCnt <= _script.allocTmpVarIntInit(sInit, "hld_cnt", FX_ONE, true/*bCycleReset*/);
      local String sVarSmp <= _script.allocTmpVarIntInit(sInit, "hld_smp", 0, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sIndent;

      // (todo) use addx on 68k
      _out.append("if(("+sVarCnt+" >> "+FX_SHR+")) { "+sVarSmp+" = "+_sDstVar+"; "+sVarCnt+" -= "+FX_ONE+"; }\n");

      _out.append("{\n");
      if(inOnSample.isConnected())
      {
         local String sVarSmpTmp <= _script.allocTmpVarInt(_out, "hld_onsample");
         sIndent.empty();
         sIndent.append(sVarSmpTmp+" = "+_sDstVar+";\n");
         inOnSample.emitInt(_script, sIndent, sVarSmpTmp);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("    "+sVarSmp+" = "+sVarSmpTmp+";\n");
         _script.freeTmpVarInt(sVarSmpTmp);
      }
      else
      {
         _out.append("    "+sVarSmp+" = "+_sDstVar+";\n");
      }
      _out.append("    "+sVarCnt+" -= 1.0f;\n");
      _out.append("}\n");


      _out.append(_sDstVar+" = "+sVarSmp+";\n");

      if(bConstRate)
         _out.append(sVarCnt+" += "+int(FX_ONE * fRate)+";\n");
      else
      {
         // (note) patch programmer must ensure that rate does not exceed 1.0
         local String sVarRate <= _script.allocTmpVar(_out, "rate");
         inRate.emitInt(_script, _out, sVarRate);
         _out.append(sVarCnt+" += "+sVarRate+";\n");
         _script.freeTmpVar(sVarRate);
      }

   }
}


// <class.png>
class CyModuleHpf : CyModule {

   static FloatArray cfg_coeff = [
      // a0,a1,(a2=a0),b1,b2
      /*  0: freq=127 res=0   */ 0.198638, -0.397276,  0.217248, 0.011799,
      /*  1: freq=127 res=108 */ 0.285045, -0.570091,  0.311751, 0.451933,
      /*  2: freq=122 res=0   */ 0.221789, -0.443577,  0.116223, 0.003377,
      /*  3: freq=122 res=108 */ 0.431689, -0.863378, -0.276828, 0.449928,
      /*  4: freq=115 res=0   */ 0.375898, -0.751796, -0.452421, 0.051171,
      /*  5: freq=115 res=100 */ 0.529386, -1.058773, -0.637156, 0.480390,
      /*  6: freq=110 res=0   */ 0.476518, -0.953036, -0.761211, 0.144861,
      /*  7: freq=110 res=100 */ 0.645083, -1.290165, -1.030484, 0.549847,
      /*  8: freq=100 res=0   */ 0.649103, -1.298205, -1.222676, 0.373734,
      /*  9: freq=100 res=97  */ 0.800386, -1.600773, -1.507640, 0.693905,
      /* 10: freq=90  res=0   */ 0.774850, -1.549700, -1.521022, 0.578377,
      /* 11: freq=90  res=70  */ 0.871657, -1.743314, -1.711053, 0.775574,
      /* 12: freq=77  res=0   */ 0.883493, -1.766985, -1.759772, 0.774199,
      /* 13: freq=77  res=79  */ 0.942483, -1.884966, -1.877271, 0.892662,
                                  ];


   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("cfg", 0, 0.0, (cfg_coeff.numElements/4)-1);

      addInputAlias("c", "cfg");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local String sInit;
      local String sVarZ1 <= _script.allocTmpVarInit(sInit, "hpf_z1", 0.0f, true/*bCycleReset*/);
      local String sVarZ2 <= _script.allocTmpVarInit(sInit, "hpf_z2", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local CyInput inCfg <= findInputById("cfg");
      int cfgIdx = mathClampi(inCfg.getConstVal(), 0, (cfg_coeff.numElements/4)-1) * 4;
      float a0 = cfg_coeff.get(cfgIdx + 0);
      float a1 = cfg_coeff.get(cfgIdx + 1);
      float a2 = a1;
      float b1 = cfg_coeff.get(cfgIdx + 2);
      float b2 = cfg_coeff.get(cfgIdx + 3);

      _out.append("tmp_f = "+_sDstVar+";\n");
      _out.append(_sDstVar+" = tmp_f * "+a0+" + "+sVarZ1+";\n");
      _out.append(sVarZ1+" = tmp_f * "+a1+" + "+sVarZ2+" - "+b1+" * "+_sDstVar+";\n");
      _out.append(sVarZ2+" = tmp_f * "+a2+" - "+b2+" * "+_sDstVar+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local String sInit;
      local String sVarZ1 <= _script.allocTmpVarIntInit(sInit, "hpf_z1", 0.0f, true/*bCycleReset*/);
      local String sVarZ2 <= _script.allocTmpVarIntInit(sInit, "hpf_z2", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local CyInput inCfg <= findInputById("cfg");
      int cfgIdx = mathClampi(inCfg.getConstVal(), 0, (cfg_coeff.numElements/4)-1) * 4;
      int a0 = cfg_coeff.get(cfgIdx + 0) * FX_ONE;
      int a1 = cfg_coeff.get(cfgIdx + 1) * FX_ONE;
      // int a2 = a1;
      int b1 = cfg_coeff.get(cfgIdx + 2) * FX_ONE;
      int b2 = cfg_coeff.get(cfgIdx + 3) * FX_ONE;

      _out.append("tmp_i = "+_sDstVar+";\n");
      if(b_export_c)
      {
         _out.append(_sDstVar+" = (mulsw(tmp_i, "+a0+") >> "+FX_SHR+") + "+sVarZ1+";\n");
         // // _out.append(sVarZ1+" = (mulsw(tmp, "+a1+") >> "+FX_SHR+") + "+sVarZ2+" - (mulsw("+b1+", "+_sDstVar+") >> "+FX_SHR+");\n");
         // // _out.append(sVarZ2+" = (mulsw(tmp, "+a2+") >> "+FX_SHR+") - (mulsw("+b2+", "+_sDstVar+") >> "+FX_SHR+");\n");
         _out.append("tmp2_i = (mulsw(tmp_i, "+a1+") >> "+FX_SHR+");\n");
         _out.append(sVarZ1+" = tmp2_i + "+sVarZ2+" - (mulsw("+b1+", "+_sDstVar+") >> "+FX_SHR+");\n");
         _out.append(sVarZ2+" = tmp2_i - (mulsw("+b2+", "+_sDstVar+") >> "+FX_SHR+");\n");
      }
      else
      {
         _out.append(_sDstVar+" = ((tmp_i * "+a0+") >> "+FX_SHR+") + "+sVarZ1+";\n");
         // // _out.append(sVarZ1+" = ((tmp * "+a1+") >> "+FX_SHR+") + "+sVarZ2+" - (("+b1+" * "+_sDstVar+") >> "+FX_SHR+");\n");
         // // _out.append(sVarZ2+" = ((tmp * "+a2+") >> "+FX_SHR+") - (("+b2+" * "+_sDstVar+") >> "+FX_SHR+");\n");
         _out.append("tmp2_i = ((tmp_i * "+a1+") >> "+FX_SHR+");\n");
         _out.append(sVarZ1+" = tmp2_i + "+sVarZ2+" - (("+b1+" * "+_sDstVar+") >> "+FX_SHR+");\n");
         _out.append(sVarZ2+" = tmp2_i - (("+b2+" * "+_sDstVar+") >> "+FX_SHR+");\n");
      }
   }
}


// <class.png>
class CyModuleHwr : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("bipolar", 0, 0, 1);   // 1=rescale to -1..1 range
      addInput("neg",     0, 0, 1);   // 1=flip sign of result

      addInputAlias("b", "bipolar");
      addInputAlias("n", "neg");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inBipolar <= findInputById("bipolar");
      local CyInput inNeg     <= findInputById("neg");

      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);
      local boolean bNeg     = (inNeg    .getConstVal() >= 0.5f);

      if(bBipolar)
      {
         if(bNeg)
         {
            _out.append(_sDstVar+" = ("+_sDstVar+" < 0.0f) ? 1.0f : ("+_sDstVar+" * -2.0f + 1.0f);\n");
         }
         else
         {
            _out.append(_sDstVar+" = ("+_sDstVar+" < 0.0f) ? -1.0f : ("+_sDstVar+" * 2.0f - 1.0f);\n");
         }
      }
      else
      {
         if(bNeg)
         {
            _out.append(_sDstVar+" = ("+_sDstVar+" < 0.0f) ? 0.0f : -"+_sDstVar+";\n");
         }
         else
         {
            _out.append(_sDstVar+" = ("+_sDstVar+" < 0.0f) ? 0.0f : "+_sDstVar+";\n");
         }
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inBipolar <= findInputById("bipolar");

      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);

      if(bBipolar)
      {
         _out.append(_sDstVar+" = ("+_sDstVar+" < 0) ? -"+FX_ONE+" : (("+_sDstVar+" << 1) - "+FX_ONE+");\n");
      }
      else
      {
         _out.append(_sDstVar+" = ("+_sDstVar+" < 0) ? 0 : "+_sDstVar+";\n");
      }
   }
}


// <class.png>
class CyModuleIf : CyModule {
   // evaluated at compile time

   define int OP_LT = 0;
   define int OP_LE = 1;
   define int OP_EQ = 2;
   define int OP_NE = 3;
   define int OP_GE = 4;
   define int OP_GT = 5;
   int if_op;

   CyArg     *lhs_arg;
   CyModule  *rhs_arg;  // see parseConstOrVar()


   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("then",  0.0, -16.0, 16.0);
      addInput("else",  0.0, -16.0, 16.0);
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inThen <= findInputById("then");
      local CyInput inElse <= findInputById("else");

      float lhsVal = lhs_arg.cur_value;
      float rhsVal = rhs_arg.getConstVal();

      boolean bExec = false;

      switch(if_op)
      {
         case OP_LT:  bExec = (lhsVal <  rhsVal); break;
         case OP_LE:  bExec = (lhsVal <= rhsVal); break;
         case OP_EQ:  bExec = (lhsVal == rhsVal); break;
         case OP_NE:  bExec = (lhsVal != rhsVal); break;
         case OP_GE:  bExec = (lhsVal >= rhsVal); break;
         case OP_GT:  bExec = (lhsVal >  rhsVal); break;
      }

      if(bExec)
      {
         inThen.emitFloat(_script, _out, _sDstVar);
      }
      else if(inElse.isConnected())
      {
         inElse.emitFloat(_script, _out, _sDstVar);
      }

   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inThen <= findInputById("then");
      local CyInput inElse <= findInputById("else");

      float lhsVal = lhs_arg.cur_value;
      float rhsVal = rhs_arg.getConstVal();

      boolean bExec = false;

      switch(if_op)
      {
         case OP_LT:  bExec = (lhsVal <  rhsVal); break;
         case OP_LE:  bExec = (lhsVal <= rhsVal); break;
         case OP_EQ:  bExec = (lhsVal == rhsVal); break;
         case OP_NE:  bExec = (lhsVal != rhsVal); break;
         case OP_GE:  bExec = (lhsVal >= rhsVal); break;
         case OP_GT:  bExec = (lhsVal >  rhsVal); break;
      }

      // _out.append(" // xxx bExec="+bExec+" lhsVal="+lhsVal+" rhsVal="+rhsVal+"\n");

      if(bExec)
      {
         inThen.emitInt(_script, _out, _sDstVar);
      }
      else if(inElse.isConnected())
      {
         inElse.emitInt(_script, _out, _sDstVar);
      }
   }
}


// <class.png>
class CyModuleIpl : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("a",    0.0, 0.0, 1.0);
      addInput("b",    1.0, 0.0, 1.0);
      addInput("t",    1.0, 0.0, 1.0);  // should be in range 0..1
      addInput("win",  0.0, 0.0, 1.0);  // 0=linear, 1=smoothstep, 2=in_quad 3=out_quad 4=in_cubic 5=out_cubic 6=in_quintic 7=out_quintic [def=0]

      addInputAlias("w", "win");
   }

   // <method_get.png>
   public virtual getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      switch(_input)
      {
         case "win":
            _retNames  = ["linear", "smoothstep", "in_quad", "out_quad", "in_cubic", "out_cubic", "in_quintic", "out_quintic"];
            _retValues = [ 0,        1,            2,         3,          4,          5,           6,            7           ];
            return true;
      }
      return false;
   }

   // <method.png>
   protected method emitWinFloat(local String _out, local String _sDstVar, local String _sVarA, local String _sVarB, local String _sVarT, local int _win) {
      switch(_win)
      {
         case 1:  // smoothstep
            _out.append(_sVarT+" = "+_sVarT+" * "+_sVarT+" * (3.0f - 2.0f * "+_sVarT+");\n");
            break;

         case 2:  // in_quad
            _out.append(_sVarT+" *= "+_sVarT+";\n");
            break;

         case 3:  // out_quad
            _out.append(_sVarT+"  = 1.0f - "+_sVarT+";\n");
            _out.append(_sVarT+" *= "+_sVarT+";\n");
            _out.append(_sVarT+"  = 1.0f - "+_sVarT+";\n");
            break;

         case 4:  // in_cubic
            _out.append(_sVarT+" *= "+_sVarT+" * "+_sVarT+";\n");
            break;

         case 5:  // out_cubic
            _out.append(_sVarT+"  = 1.0f - "+_sVarT+";\n");
            _out.append(_sVarT+" *= "+_sVarT+" * "+_sVarT+";\n");
            _out.append(_sVarT+"  = 1.0f - "+_sVarT+";\n");
            break;

         case 6:  // in_quintic
            _out.append(_sVarT+" *= "+_sVarT+";\n");
            _out.append(_sVarT+" *= "+_sVarT+";\n");
            break;

         case 7:  // out_quintic
            _out.append(_sVarT+"  = 1.0f - "+_sVarT+";\n");
            _out.append(_sVarT+" *= "+_sVarT+";\n");
            _out.append(_sVarT+" *= "+_sVarT+";\n");
            _out.append(_sVarT+"  = 1.0f - "+_sVarT+";\n");
            break;
      }

      _out.append(_sDstVar+" = "+_sVarA+" + ("+_sVarB+" - "+_sVarA+") * "+_sVarT+";\n");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inA   <= findInputById("a");
      local CyInput inB   <= findInputById("b");
      local CyInput inT   <= findInputById("t");
      local CyInput inWin <= findInputById("win");  // must be const

      local String *sVarA;
      local String *sVarB;
      local String *sVarT;

      local boolean bA = inA.isConnected();
      local boolean bB = inB.isConnected();
      local boolean bT = inT.isConnected();
      // // trace "xxx CyModuleIpl: bA="+bA+" bB="+bB+" bT="+bT;

      if(bA && bB && !bT)
      {
         // previous input is 't'
         sVarA <= _script.allocTmpVar(_out, "a");
         _out.append(sVarA+" = "+_sDstVar+";\n");
         inA.emitFloat(_script, _out, sVarA);

         sVarB <= _script.allocTmpVar(_out, "b");
         _out.append(sVarB+" = "+_sDstVar+";\n");
         inB.emitFloat(_script, _out, sVarB);

         emitWinFloat(_out, _sDstVar,
                      sVarA,
                      sVarB,
                      _sDstVar,
                      int(inWin.getConstVal())
                      );
      }
      else if(bA && !bB)
      {
         // previous input is 'b'
         sVarA <= _script.allocTmpVar(_out, "a");
         _out.append(sVarA+" = "+_sDstVar+";\n");
         inA.emitFloat(_script, _out, sVarA);

         sVarT <= _script.allocTmpVar(_out, "t");
         _out.append(sVarT+" = "+_sDstVar+";\n");
         inT.emitFloat(_script, _out, sVarT);

         emitWinFloat(_out, _sDstVar,
                      sVarA,
                      _sDstVar,
                      sVarT,
                      int(inWin.getConstVal())
                      );
      }
      else if(!bA && bB)
      {
         // previous input is 'a'
         sVarB <= _script.allocTmpVar(_out, "b");
         _out.append(sVarB+" = "+_sDstVar+";\n");
         inB.emitFloat(_script, _out, sVarB);

         sVarT <= _script.allocTmpVar(_out, "t");
         _out.append(sVarT+" = "+_sDstVar+";\n");
         inT.emitFloat(_script, _out, sVarT);

         emitWinFloat(_out, _sDstVar,
                      _sDstVar,
                      sVarB,
                      sVarT,
                      int(inWin.getConstVal())
                      );
      }
      else // // if(inA.isConnected() && inB.isConnected() && inT.isConnected())
      {
         // previous input is ignored
         sVarA <= _script.allocTmpVar(_out, "a");
         _out.append(sVarA+" = "+_sDstVar+";\n");
         inA.emitFloat(_script, _out, sVarA);

         sVarB <= _script.allocTmpVar(_out, "b");
         _out.append(sVarB+" = "+_sDstVar+";\n");
         inB.emitFloat(_script, _out, sVarB);

         sVarT <= _script.allocTmpVar(_out, "t");
         _out.append(sVarT+" = "+_sDstVar+";\n");
         inT.emitFloat(_script, _out, sVarT);

         emitWinFloat(_out, _sDstVar,
                      sVarA,
                      sVarB,
                      sVarT,
                      int(inWin.getConstVal())
                      );
      }

      if(null != sVarA)
         _script.freeTmpVar(sVarA);

      if(null != sVarB)
         _script.freeTmpVar(sVarB);

      if(null != sVarT)
         _script.freeTmpVar(sVarT);
   }

   // <method.png>
   protected method emitWinInt(local String _out, local String _sDstVar, local String _sVarA, local String _sVarB, local String _sVarT, local int _win) {
      switch(_win)
      {
         case 1:  // smoothstep
            // _out.append(_sVarT+" = Dmulsw_shr(Dmulsw_shr("+_sVarT+", "+_sVarT+"), ("+int(FX_ONE*3.0f)+" - Dmulsw_shr("+int(FX_ONE*2.0f)+", "+_sVarT+")));\n");
            _out.append(_sVarT+" = Dmulsw_shr(Dmulsw_shr("+_sVarT+", "+_sVarT+"), ("+int(FX_ONE*3.0f)+" - ("+_sVarT+" << 1)));\n");
            break;

         case 2:  // in_quad
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", "+_sVarT+");\n");
            break;

         case 3:  // out_quad
            _out.append(_sVarT+" = "+int(FX_ONE)+" - "+_sVarT+";\n");
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", "+_sVarT+");\n");
            _out.append(_sVarT+" = "+int(FX_ONE)+" - "+_sVarT+";\n");
            break;

         case 4:  // in_cubic
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", Dmulsw_shr("+_sVarT+", "+_sVarT+"));\n");
            break;

         case 5:  // out_cubic
            _out.append(_sVarT+" = "+int(FX_ONE)+" - "+_sVarT+";\n");
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", Dmulsw_shr("+_sVarT+", "+_sVarT+"));\n");
            _out.append(_sVarT+" = "+int(FX_ONE)+" - "+_sVarT+";\n");
            break;

         case 6:  // in_quintic
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", "+_sVarT+");\n");
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", "+_sVarT+");\n");
            break;

         case 7:  // out_quintic
            _out.append(_sVarT+" = "+int(FX_ONE)+" - "+_sVarT+";\n");
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", "+_sVarT+");\n");
            _out.append(_sVarT+" = Dmulsw_shr("+_sVarT+", "+_sVarT+");\n");
            _out.append(_sVarT+" = "+int(FX_ONE)+" - "+_sVarT+";\n");
            break;
      }

      _out.append(_sDstVar+" = "+_sVarA+" + Dmulsw_shr("+_sVarB+" - "+_sVarA+", "+_sVarT+");\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inA   <= findInputById("a");
      local CyInput inB   <= findInputById("b");
      local CyInput inT   <= findInputById("t");
      local CyInput inWin <= findInputById("win");  // must be const

      local String *sVarA;
      local String *sVarB;
      local String *sVarT;

      local boolean bA = inA.isConnected();
      local boolean bB = inB.isConnected();
      local boolean bT = inT.isConnected();
      // // trace "xxx CyModuleIpl<int>: bA="+bA+" bB="+bB+" bT="+bT;

      if(bA && bB && !bT)
      {
         // previous input is 't'
         sVarA <= _script.allocTmpVarInt(_out, "a");
         _out.append(sVarA+" = "+_sDstVar+";\n");
         inA.emitInt(_script, _out, sVarA);

         sVarB <= _script.allocTmpVarInt(_out, "b");
         _out.append(sVarB+" = "+_sDstVar+";\n");
         inB.emitInt(_script, _out, sVarB);

         emitWinInt(_out, _sDstVar,
                    sVarA,
                    sVarB,
                    _sDstVar,
                    int(inWin.getConstVal())
                    );
      }
      else if(bA && !bB)
      {
         // previous input is 'b'
         sVarA <= _script.allocTmpVarInt(_out, "a");
         _out.append(sVarA+" = "+_sDstVar+";\n");
         inA.emitInt(_script, _out, sVarA);

         sVarT <= _script.allocTmpVarInt(_out, "t");
         _out.append(sVarT+" = "+_sDstVar+";\n");
         inT.emitInt(_script, _out, sVarT);

         emitWinInt(_out, _sDstVar,
                    sVarA,
                    _sDstVar,
                    sVarT,
                    int(inWin.getConstVal())
                    );
      }
      else if(!bA && bB)
      {
         // previous input is 'a'
         sVarB <= _script.allocTmpVarInt(_out, "b");
         _out.append(sVarB+" = "+_sDstVar+";\n");
         inB.emitInt(_script, _out, sVarB);

         sVarT <= _script.allocTmpVarInt(_out, "t");
         _out.append(sVarT+" = "+_sDstVar+";\n");
         inT.emitInt(_script, _out, sVarT);

         emitWinInt(_out, _sDstVar,
                    _sDstVar,
                    sVarB,
                    sVarT,
                    int(inWin.getConstVal())
                    );
      }
      else // if(inA.isConnected() && inB.isConnected() && inT.isConnected())
      {
         // previous input is ignored
         sVarA <= _script.allocTmpVarInt(_out, "a");
         _out.append(sVarA+" = "+_sDstVar+";\n");
         inA.emitInt(_script, _out, sVarA);

         sVarB <= _script.allocTmpVarInt(_out, "b");
         _out.append(sVarB+" = "+_sDstVar+";\n");
         inB.emitInt(_script, _out, sVarB);

         sVarT <= _script.allocTmpVarInt(_out, "t");
         _out.append(sVarT+" = "+_sDstVar+";\n");
         inT.emitInt(_script, _out, sVarT);

         emitWinInt(_out, _sDstVar,
                    sVarA,
                    sVarB,
                    sVarT,
                    int(inWin.getConstVal())
                    );
      }

      if(null != sVarA)
         _script.freeTmpVarInt(sVarA);

      if(null != sVarB)
         _script.freeTmpVarInt(sVarB);

      if(null != sVarT)
         _script.freeTmpVarInt(sVarT);
   }

}

// <class.png>
class CyModuleInt : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method_get.png>
   public virtual doEmitRight() : boolean {
      // skip seq_right in emitFloatTree() / emitIntTree()
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      parent_script.b_use_int_module = true;  // add mulsw etc
      local String sVarOutI <= _script.allocTmpVarInt(_out, "out_i");
      _out.append(sVarOutI+" = (short)("+_sDstVar+" * "+FX_ONE+");\n");  // convert to 16bit fixpoint
      _out.append("{\n");
      local String sIndent;
      seq_right.emitIntSequence(_script, sIndent, sVarOutI);
      CyScript.AppendIndentedLines(_out, sIndent, 3);
      _out.append("}\n");
      _out.append(_sDstVar+" = "+sVarOutI+" * "+(1.0f / FX_ONE)+";\n");  // convert back to float
      _script.freeTmpVarInt(sVarOutI);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      seq_right.emitIntSequence(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleItg : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = (float)(int)"+_sDstVar+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = ("+_sDstVar+" & ~"+int(FX_FRAC)+");\n");
   }
}


// <class.png>
class CyModuleKbd : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("amt",    1.0, -16.0,  16.0);  // dynamic  (previously called 'kbd')
      addInput("off",    0.0,  -4.0,   4.0);  // dynamic
      addInput("scl",    4.0,   0.0,  16.0);  // dynamic
      addInput("clamp",  1.0,   0.0,   1.0);  // const (1=clamp to 0..1)
      addInput("mode",   0.0,   0.0,   2.0);  // const (0=freq scl mode, 1=exp rate scaling mode, 2=linear rate scaling mode. ignore 'clamp' and 'scl')
      addInput("ctr",   60.0,   0.0, 127.0);  // pitch center note (60=5*12=C-5). must be const. ignored in mode=0

      // deprecated:
      addInput("kbd",    1.0, -16.0,  16.0);  // legacy name for 'amt'

      addInputAlias("a", "amt");
      addInputAlias("o", "off");
      addInputAlias("s", "scl");
      addInputAlias("c", "clamp");
      addInputAlias("m", "mode");
   }

   // <method_get.png>
   public virtual getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      switch(_input)
      {
         case "mode":
            _retNames  = ["freq", "exp", "lin"];
            _retValues = [ 0,      1,     2   ];
            return true;
      }
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local CyInput inAmt   <= findInputById("amt");
         local CyInput inOff   <= findInputById("off");
         local CyInput inScl   <= findInputById("scl");
         local CyInput inClamp <= findInputById("clamp");
         local CyInput inMode  <= findInputById("mode");  // 1=ignore 'clamp' and 'scl'
         local CyInput inCtr   <= findInputById("ctr");
         local CyInput inKbd   <= findInputById("kbd");  // deprecated

         // use legacy input name ?
         if(inKbd.isConnected())
            inAmt <= inKbd;

         local String *sVarAmt;
         local String *sVarOff;
         local String *sVarScl;
         local String *sVarRate;
         float fCtr;

         sVarAmt <= _script.allocTmpVar(_out, "amt");
         inAmt.emitFloat(_script, _out, sVarAmt);

         sVarOff <= _script.allocTmpVar(_out, "off");
         inOff.emitFloat(_script, _out, sVarOff);

         if(inMode.getConstVal() >= 1.5f)
         {
            // ------- mode=2 -------- (linear pitch rate scaling mode. support 'ctr', ignore 'clamp' and 'scl')
            // (note) +1 oct=*2, -1 oct=*0.5, +7 semi=~1.5
            sVarRate <= _script.allocTmpVar(_out, "rate");
            fCtr = inCtr.getConstVal();
            _out.append(sVarRate+"  = (voice->note_cur + ("+sVarOff+" * 12.0f) - "+FloatToString(fCtr)+") * "+sVarAmt+";\n");
            _out.append(_sDstVar+" *= powf(2.0f, "+sVarRate+" * (1.0f / 12.0f));\n");
            _script.freeTmpVar(sVarRate);
         }
         else if(inMode.getConstVal() >= 0.5f)
         {
            // ------- mode=1 -------- (exponential / equal tempered rate scaling mode. support 'ctr', ignore 'clamp' and 'scl')
            sVarRate <= _script.allocTmpVar(_out, "rate");
            fCtr = inCtr.getConstVal();
            // Convert scaled MIDI note (0..127) to frequency (Hz)
            _out.append(sVarRate+" = (voice->note_cur + ("+sVarOff+" * 12.0f) - "+FloatToString(fCtr)+") * "+sVarAmt+" + "+FloatToString(fCtr)+";\n");
            // _out.append("  printf(\"xxx note scaled=%f\\n\", "+sVarRate+");\n");
            _out.append(sVarRate+" = ((440.0f/32.0f)*expf( (("+sVarRate+"-9.0f)/12.0f)*logf(2.0f) ));\n");
            // _out.append("  printf(\"xxx note_cur=%f noteFreq=%f\\n\", voice->note_cur, "+sVarRate+");\n");
            // Divide by center frequency
            float fCtrFreq = (440.0f/32.0f)*exp( ((fCtr-9.0f)/12.0f)*log(2.0f) );
            _out.append(sVarRate+" *= (1.0f / "+FloatToString(fCtrFreq)+");\n");
            // _out.append("  printf(\"xxx noteRate=%f\\n\", "+sVarRate+");\n");
            _out.append(_sDstVar+" *= "+sVarRate+";\n");
            _script.freeTmpVar(sVarRate);
         }
         else
         {
            // ------- mode=0 -------- (exponential / cutoff mode. ignore ctr, hardcoded to 64.0. support 'clamp' and 'scl')
            _out.append(_sDstVar+" *= 127.0f;\n");

            sVarScl <= _script.allocTmpVar(_out, "scl");
            inScl.emitFloat(_script, _out, sVarScl);

            _out.append(_sDstVar+" += (voice->note_cur + ("+sVarOff+" * 12.0f) - 64.0f) * "+sVarAmt+";\n");

            if(inClamp.getConstVal() >= 0.5f)
               _out.append(_sDstVar+" = clamp("+_sDstVar+", 0.0f, 127.0f);\n");

            // _out.append("  printf(\"kbd note_cur=%f out<note>=%f off=%f\\n\", voice->note_cur, "+_sDstVar+", "+sVarOff+");\n");
            _out.append("#ifdef OVERSAMPLE_FACTOR\n");
            _out.append(_sDstVar+" = ((440.0f/32.0f)*expf( (("+_sDstVar+"-9.0f)/12.0f)*logf(2.0f) )) / (voice->sample_rate * OVERSAMPLE_FACTOR);\n");
            _out.append("#else\n");
            _out.append(_sDstVar+" = ((440.0f/32.0f)*expf( (("+_sDstVar+"-9.0f)/12.0f)*logf(2.0f) )) / voice->sample_rate;\n");
            _out.append("#endif\n");
            _out.append(_sDstVar+" *= "+sVarScl+";\n");
            // _out.append("  printf(\"kbd out=%f\\n\", "+_sDstVar+");\n");

            _script.freeTmpVar(sVarScl);
         }

         _script.freeTmpVar(sVarOff);
         _script.freeTmpVar(sVarAmt);
      }
      // else: keep input value
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleKbd<int> falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleLpf : CyModule {
   // https://www.musicdsp.org/en/latest/Filters/185-1-rc-and-c-filter.html
   // // Parameter calculation
   // // cutoff and resonance are from 0 to 127
   //     c = pow(0.5, (128-cutoff)   / 16.0);
   //     r = pow(0.5, (resonance+24) / 16.0);
   // // Loop:
   //     v0 =  (1-r*c)*v0  -  (c)*v1  + (c)*input;
   //     v1 =  (1-r*c)*v1  +  (c)*v0;
   //     output = v1;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq", 0.5, 0.0, 1.0);
      addInput("res",  0.5, 0.0, 1.0);

      addInputAlias("f", "freq");
      addInputAlias("r", "res");
   }

   // <method_get.png>
   public virtual validate() : boolean {
      local CyInput inRes <= findInputById("res");
      return inRes.isConstVal();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local String sInit;
      local String sVarV0 <= _script.allocTmpVarInit(sInit, "lpf_1rc_v0", 0.0f, true/*bCycleReset*/);
      local String sVarV1 <= _script.allocTmpVarInit(sInit, "lpf_1rc_v1", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local CyInput inRes  <= findInputById("res");
      float fRes = inRes.getConstVal();

      local CyInput inFreq <= findInputById("freq");
      local String s1RC;
      if(inFreq.isConstVal())
      {
         float fFreq = inFreq.getConstVal();
         s1RC <= String(1.0 - (fRes * fFreq));
         _out.append(sVarV0+" = "+s1RC+" * "+sVarV0+" - "+fFreq+" * "+sVarV1+" + "+_sDstVar+" * "+fFreq+";\n");
         _out.append(sVarV1+" = "+s1RC+" * "+sVarV1+" + "+fFreq+" * "+sVarV0+";\n");
      }
      else
      {
         local String sVarFreq <= _script.allocTmpVar(_out, "freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         _out.append("tmp_f = (1.0f - "+sVarFreq+" * "+fRes+");\n");
         _out.append(sVarV0+" = tmp_f * "+sVarV0+" - "+sVarFreq+" * "+sVarV1+" + "+_sDstVar+" * "+sVarFreq+";\n");
         _out.append(sVarV1+" = tmp_f * "+sVarV1+" + "+sVarFreq+" * "+sVarV0+";\n");
         _script.freeTmpVar(sVarFreq);
      }
      _out.append(_sDstVar+" = "+sVarV1+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local String sInit;
      local String sVarV0 <= _script.allocTmpVarIntInit(sInit, "lpf_1rc_v0", 0.0f, true/*bCycleReset*/);
      local String sVarV1 <= _script.allocTmpVarIntInit(sInit, "lpf_1rc_v1", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local CyInput inRes  <= findInputById("res");
      float fRes = inRes.getConstVal();

      local CyInput inFreq <= findInputById("freq");
      local String s1RC;
      if(inFreq.isConstVal())
      {
         float fFreq = inFreq.getConstVal();
         s1RC <= String(int((1.0 - (fRes * fFreq)) * FX_ONE));
         int iFreq = fFreq * FX_ONE;
         if(b_export_c)
         {
            _out.append(sVarV0+" = (mulsw("+s1RC+", "+sVarV0+") >> "+FX_SHR+") - (mulsw("+iFreq+", "+sVarV1+") >> "+FX_SHR+") + (mulsw("+_sDstVar+", "+iFreq+") >> "+FX_SHR+");\n");
            _out.append(sVarV1+" = (mulsw("+s1RC+", "+sVarV1+") >> "+FX_SHR+") + (mulsw("+iFreq+", "+sVarV0+") >> "+FX_SHR+");\n");
         }
         else
         {
            _out.append(sVarV0+" = (("+s1RC+" * "+sVarV0+") >> "+FX_SHR+") - (("+iFreq+" * "+sVarV1+") >> "+FX_SHR+") + (("+_sDstVar+" * "+iFreq+") >> "+FX_SHR+");\n");
            _out.append(sVarV1+" = (("+s1RC+" * "+sVarV1+") >> "+FX_SHR+") + (("+iFreq+" * "+sVarV0+") >> "+FX_SHR+");\n");
         }
      }
      else
      {
         local String sVarFreq <= _script.allocTmpVarInt(_out, "freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         int iRes = fRes * FX_ONE;
         if(b_export_c)
         {
            _out.append("tmp_i = ("+FX_ONE+" - (mulsw("+sVarFreq+", "+iRes+") >> "+FX_SHR+"));\n");
            _out.append(sVarV0+" = (mulsw(tmp_i, "+sVarV0+") >> "+FX_SHR+") - (mulsw("+sVarFreq+", "+sVarV1+") >> "+FX_SHR+") + (mulsw("+_sDstVar+", "+sVarFreq+") >> "+FX_SHR+");\n");
            _out.append(sVarV1+" = (mulsw(tmp_i, "+sVarV1+") >> "+FX_SHR+") + (mulsw("+sVarFreq+", "+sVarV0+") >> "+FX_SHR+");\n");
         }
         else
         {
            _out.append("tmp_i = ("+FX_ONE+" - (("+sVarFreq+" * "+iRes+") >> "+FX_SHR+"));\n");
            _out.append(sVarV0+" = ((tmp_i * "+sVarV0+") >> "+FX_SHR+") - (("+sVarFreq+" * "+sVarV1+") >> "+FX_SHR+") + (("+_sDstVar+" * "+sVarFreq+") >> "+FX_SHR+");\n");
            _out.append(sVarV1+" = ((tmp_i * "+sVarV1+") >> "+FX_SHR+") + (("+sVarFreq+" * "+sVarV0+") >> "+FX_SHR+");\n");
         }
         _script.freeTmpVarInt(sVarFreq);
      }
      _out.append(_sDstVar+" = "+sVarV1+";\n");
   }
}


// <class.png>
class CyModuleLUT : CyModule {
   int          curve_idx;  // !=-1: use curve lut
   CyLUT       *lut;        // !=null: use procedural lut instead of curve
   CyArrayDecl *array_decl; // !=null: use voice param array (plugins)

   // ~CyModuleLUT() {
   //    trace "xxx ~CyModuleLUT";
   //    Utils.Backtrace();
   // }

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("clamp",   0, 0.0,  1.0);
      addInput("lin",     0, 0,    1  );
      addInput("scl",     1, 0,   15.0);
      addInput("bipolar", 0, 0,    1  );   // 1=flip sign of index if negative (+flip output sign)
      addInput("in",      0, 0,    1  );   // 1=input values 0..1 map to elements 0..size-1 instead of 0..size

      addInputAlias("c", "clamp");
      addInputAlias("l", "lin");
      addInputAlias("s", "scl");
      addInputAlias("b", "bipolar");
      addInputAlias("i", "in");
   }

   // <method.png>
   protected method emitFloatLUT(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inClamp   <= findInputById("clamp");
      local CyInput inLin     <= findInputById("lin");
      local CyInput inScl     <= findInputById("scl");
      local CyInput inBipolar <= findInputById("bipolar");
      local CyInput inIn      <= findInputById("in");

      local float fScl = inScl.getConstVal();
      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);
      local boolean bIn = (inIn.getConstVal() >= 0.5f);

      local String *sVarBipSign;
      if(bBipolar)
      {
         sVarBipSign <= _script.allocTmpVarInt(_out, "lut_bip_sign");

         _out.append(sVarBipSign+" = ("+_sDstVar+" < 0.0f);\n");
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");
      }

      local int curveSzScl = lut.lut_w - bIn;
      local int curveSzMask = lut.lut_w - 1;

      local String sLUT <= b_plugin ? lut.b_voice ? ("voice->lut_"+lut.id) : ("shared->lut_"+lut.id) : ("lut_"+lut.id);
      local String sUITypeCast <= b_export_c ? "(unsigned int)" : "(int)";

      if(inLin.getConstVal() >= 0.5)
      {
         // Linear filtering
         local String sVarF    <= _script.allocTmpVar   (_out, "lut_f");
         local String sVarIdxA <= _script.allocTmpVarInt(_out, "lut_idx_a");
         local String sVarIdxB <= _script.allocTmpVarInt(_out, "lut_idx_b");
         local String sVarFrac <= _script.allocTmpVar   (_out, "lut_frac");
         local String sVarA    <= _script.allocTmpVar   (_out, "lut_a");
         local String sVarB    <= _script.allocTmpVar   (_out, "lut_b");

         if(inClamp.getConstVal() >= 0.5)
         {
            // Clamp to last value
            if(1.0f != fScl)
               _out.append(sVarF+" = ("+_sDstVar+" * "+(curveSzScl * fScl)+");\n");
            else
               _out.append(sVarF+" = ("+_sDstVar+" * "+curveSzScl+");\n");
            _out.append(sVarFrac+" = "+sVarF+" - (int)"+sVarF+";\n");
            // // _out.append(sVarF+" = "+clamp_fun+"("+sVarF+", 0.0f, (float)"+(curveSzMask-1)+");\n");
            _out.append(sVarIdxA+" = (int)"+sVarF+";\n");
            _out.append("if("+sVarIdxA+" < 0)\n");
            _out.append("{\n");
            _out.append("   "+sVarIdxA+" = 0;\n");
            _out.append("   "+sVarIdxB+" = 0;\n");
            _out.append("   "+sVarFrac+" = 0.0f;\n");
            _out.append("}\n");
            _out.append("else if("+sVarIdxA+" > "+curveSzMask+")\n");
            _out.append("{\n");
            _out.append("   "+sVarIdxA+" = "+curveSzMask+";\n");
            _out.append("   "+sVarIdxB+" = "+curveSzMask+";\n");
            _out.append("}\n");
            _out.append("else\n");
            _out.append("{\n");
            _out.append("   "+sVarIdxB+" = "+sVarIdxA+" + 1;\n");
            _out.append("   if("+sVarIdxB+" > "+curveSzMask+")\n");
            _out.append("      "+sVarIdxB+" = "+curveSzMask+";\n");
            _out.append("}\n");

            _out.append(sVarA+" = "+sLUT+"["+sUITypeCast+""+sVarIdxA+"];\n");
            _out.append(sVarB+" = "+sLUT+"["+sUITypeCast+""+sVarIdxB+"];\n");
            _out.append(_sDstVar+" = "+sVarA+" + ("+sVarB+" - "+sVarA+") * "+sVarFrac+";\n");
         }
         else
         {
            // Wrap-around
            //  (note) LUT size should be a power of two
            if(1.0f != fScl)
               _out.append(sVarF+" = ("+_sDstVar+" * "+(curveSzScl*fScl)+");\n");
            else
               _out.append(sVarF+" = ("+_sDstVar+" * "+curveSzScl+");\n");
            _out.append(sVarIdxA+" = (int)"+sVarF+";\n");
            _out.append(sVarFrac+" = "+sVarF+" - "+sVarIdxA+";\n");

            _out.append(sVarA+" = "+sLUT+"[ ("+sUITypeCast+""+sVarIdxA+")      & "+curveSzMask+"];\n");
            _out.append(sVarB+" = "+sLUT+"[(("+sUITypeCast+""+sVarIdxA+") + 1) & "+curveSzMask+"];\n");
            _out.append(_sDstVar+" = "+sVarA+" + ("+sVarB+" - "+sVarA+") * "+sVarFrac+";\n");
         }

         _script.freeTmpVar(sVarF);
         _script.freeTmpVarInt(sVarIdxA);
         _script.freeTmpVarInt(sVarIdxB);
         _script.freeTmpVar(sVarFrac);
         _script.freeTmpVar(sVarA);
         _script.freeTmpVar(sVarB);
      }
      else
      {
         // Nearest neighbour
         if(inClamp.getConstVal() >= 0.5)
         {
            // Clamp to last value
            if(1.0f != fScl)
               _out.append(_sDstVar+" = (float)"+clamp_fun+"(((int)("+_sDstVar+" * "+(curveSzScl*fScl)+")), 0, "+curveSzMask+");\n");
            else
               _out.append(_sDstVar+" = (float)"+clamp_fun+"(((int)("+_sDstVar+" * "+curveSzScl+")), 0, "+curveSzMask+");\n");
            _out.append(_sDstVar+" = "+sLUT+"["+sUITypeCast+""+_sDstVar+"];\n");
         }
         else
         {
            // Wrap-around
            if(1.0f != fScl)
               _out.append(_sDstVar+" = "+sLUT+"[("+sUITypeCast+"("+_sDstVar+" * "+(curveSzScl*fScl)+")) & "+curveSzMask+"];\n");
            else
               _out.append(_sDstVar+" = "+sLUT+"[("+sUITypeCast+"("+_sDstVar+" * "+curveSzScl+")) & "+curveSzMask+"];\n");
         }
      }

      if(bBipolar)
      {
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");

         _script.freeTmpVarInt(sVarBipSign);
      }
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      if(null == array_decl && null != lut)
      {
         // procedural LUT
         emitFloatLUT(_script, _out, _sDstVar);
         return;
      }

      // curve LUT
      local CyInput inClamp   <= findInputById("clamp");
      local CyInput inLin     <= findInputById("lin");
      local CyInput inScl     <= findInputById("scl");
      local CyInput inBipolar <= findInputById("bipolar");
      local CyInput inIn      <= findInputById("in");

      local float   fScl     = inScl.getConstVal();
      local boolean bLinear  = (inLin    .getConstVal() >= 0.5f);
      local boolean bClamp   = (inClamp  .getConstVal() >= 0.5f);
      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);
      local boolean bIn      = (inIn     .getConstVal() >= 0.5f);

      local String *sVarBipSign;
      if(bBipolar)
      {
         sVarBipSign <= _script.allocTmpVarInt(_out, "lut_bip_sign");

         _out.append(sVarBipSign+" = ("+_sDstVar+" < 0.0f);\n");
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");
      }

      IntArray *ia;

      // [21Sep2024] always use curve_intarrays (align with exported plugin behaviour)
      if(1)///b_export_c)
      {
         local int curveSzScl;
         local int curveSzMask;
         if(null == array_decl)
         {
            ia <= parent_script.getCurveIntArray(curve_idx);
            curveSzScl  = ia.numElements - bIn;
            curveSzMask = ia.numElements - 1;
         }
         else
         {
            if(!b_plugin)
            {
               _out.append("// lut: skip plugin array param \""+array_decl.param.id+"\" in regular C export mode\n");
               _out.append(_sDstVar+" = 0.0f;\n");
               return;
            }
            curveSzScl  = array_decl.size - bIn;
            curveSzMask = array_decl.size - 1;
         }

         local String *sLUT;
         // trace "yyy lut array_decl="+#(array_decl);
         if(b_plugin && null != array_decl)
            sLUT <= "voice->"+array_decl.getVoiceArrayName();
         else
            sLUT <= "curve_"+curve_idx+export_c_prefix/*+export_c_var_prefix*/;

         if(bLinear)
         {
            // Linear filtering
            local String sVarF    <= _script.allocTmpVar   (_out, "lut_f");
            local String sVarIdxA <= _script.allocTmpVarInt(_out, "lut_idx_a");
            local String sVarIdxB <= _script.allocTmpVarInt(_out, "lut_idx_b");
            local String sVarFrac <= _script.allocTmpVar   (_out, "lut_frac");
            local String sVarA    <= _script.allocTmpVar   (_out, "lut_a");
            local String sVarB    <= _script.allocTmpVar   (_out, "lut_b");

            if(bClamp)
            {
               // Clamp to last value
               if(1.0f != fScl)
                  _out.append(sVarF+" = ("+_sDstVar+" * "+(curveSzScl*fScl)+");\n");
               else
                  _out.append(sVarF+" = ("+_sDstVar+" * "+curveSzScl+");\n");
               _out.append(sVarFrac+" = "+sVarF+" - (int)"+sVarF+";\n");
               _out.append(sVarIdxA+" = (int)"+sVarF+";\n");
               _out.append("if("+sVarIdxA+" < 0)\n");
               _out.append("{\n");
               _out.append("   "+sVarIdxA+" = 0;\n");
               _out.append("   "+sVarIdxB+" = 0;\n");
               _out.append("   "+sVarFrac+" = 0.0f;\n");
               _out.append("}\n");
               _out.append("else if("+sVarIdxA+" > "+curveSzMask+")\n");
               _out.append("{\n");
               _out.append("   "+sVarIdxA+" = "+curveSzMask+";\n");
               _out.append("   "+sVarIdxB+" = "+curveSzMask+";\n");
               _out.append("}\n");
               _out.append("else\n");
               _out.append("{\n");
               _out.append("   "+sVarIdxB+" = "+sVarIdxA+" + 1;\n");
               _out.append("   if("+sVarIdxB+" > "+curveSzMask+")\n");
               _out.append("      "+sVarIdxB+" = "+curveSzMask+";\n");
               _out.append("}\n");

               if(b_plugin && null != array_decl)
               {
                  // array param
                  _out.append(sVarA+" = "+sLUT+"[(unsigned int)"+sVarIdxA+"];\n");
                  _out.append(sVarB+" = "+sLUT+"[(unsigned int)"+sVarIdxB+"];\n");
               }
               else
               {
                  _out.append(sVarA+" = "+sLUT+"[("+uint_type+")"+sVarIdxA+"] * (1.0f / "+FX_ONE+");\n");
                  _out.append(sVarB+" = "+sLUT+"[("+uint_type+")"+sVarIdxB+"] * (1.0f / "+FX_ONE+");\n");
               }
               _out.append(_sDstVar+" = "+sVarA+" + ("+sVarB+" - "+sVarA+") * "+sVarFrac+";\n");
            }
            else
            {
               // Wrap-around
               if(1.0f != fScl)
                  _out.append(sVarF+" = ("+_sDstVar+" * "+(curveSzScl*fScl)+");\n");
               else
                  _out.append(sVarF+" = ("+_sDstVar+" * "+curveSzScl+");\n");
               _out.append(sVarIdxA+" = (int)"+sVarF+";\n");
               _out.append(sVarFrac+" = "+sVarF+" - (float)"+sVarIdxA+";\n");

               if(b_plugin && null != array_decl)
               {
                  // array param
                  _out.append(sVarA+" = "+sLUT+"[( (unsigned int)"+sVarIdxA+"      ) & "+curveSzMask+"];\n");
                  _out.append(sVarB+" = "+sLUT+"[(((unsigned int)"+sVarIdxA+") + 1u) & "+curveSzMask+"];\n");
               }
               else
               {
                  _out.append(sVarA+" = "+sLUT+"[( ("+uint_type+")"+sVarIdxA+"      ) & "+curveSzMask+"] * (1.0f / "+FX_ONE+");\n");
                  _out.append(sVarB+" = "+sLUT+"[((("+uint_type+")"+sVarIdxA+") + 1"+(b_export_c?"u":"")+") & "+curveSzMask+"] * (1.0f / "+FX_ONE+");\n");
               }
               _out.append(_sDstVar+" = "+sVarA+" + ("+sVarB+" - "+sVarA+") * "+sVarFrac+";\n");
            }

            _script.freeTmpVar(sVarF);
            _script.freeTmpVarInt(sVarIdxA);
            _script.freeTmpVarInt(sVarIdxB);
            _script.freeTmpVar(sVarFrac);
            _script.freeTmpVar(sVarA);
            _script.freeTmpVar(sVarB);
         }
         else
         {
            // Nearest neighbour
            if(inClamp.getConstVal() >= 0.5)
            {
               // Clamp to last value
               if(1.0f != fScl)
                  _out.append(_sDstVar+" = (float)"+clamp_fun+"(((int)("+_sDstVar+" * "+(curveSzScl*fScl)+")), 0, "+curveSzMask+");\n");
               else
                  _out.append(_sDstVar+" = (float)"+clamp_fun+"(((int)("+_sDstVar+" * "+curveSzScl+")), 0, "+curveSzMask+");\n");
               if(b_plugin && null != array_decl)
               {
                  // array param
                  _out.append(_sDstVar+" = "+sLUT+"[(unsigned int)"+_sDstVar+"];\n");
               }
               else
               {
                  _out.append(_sDstVar+" = "+sLUT+"[("+uint_type+")"+_sDstVar+"] * (1.0f / "+FX_ONE+");\n");
               }
            }
            else
            {
               // Wrap-around
               if(b_plugin && null != array_decl)
               {
                  // array param
                  if(1.0f != fScl)
                     _out.append(_sDstVar+" = "+sLUT+"[((unsigned int)("+_sDstVar+" * "+(curveSzScl*fScl)+")) & "+curveSzMask+"];\n");
                  else
                     _out.append(_sDstVar+" = "+sLUT+"[((unsigned int)("+_sDstVar+" * "+curveSzScl+")) & "+curveSzMask+"];\n");
               }
               else
               {
                  if(1.0f != fScl)
                     _out.append(_sDstVar+" = "+sLUT+"[(("+uint_type+")("+_sDstVar+" * "+(curveSzScl*fScl)+")) & "+curveSzMask+"] * (1.0f / "+FX_ONE+");\n");
                  else
                     _out.append(_sDstVar+" = "+sLUT+"[(("+uint_type+")("+_sDstVar+" * "+curveSzScl+")) & "+curveSzMask+"] * (1.0f / "+FX_ONE+");\n");
               }
            }
         }
      }
      else
      {
         // (todo) unreachable, REMOVE
         if(null != array_decl && !b_plugin)
         {
            _out.append("// lut: skip plugin array param \""+array_decl.param.id+"\" in script mode\n");
            _out.append(_sDstVar+" = 0.0f;\n");
            return;
         }

         // Script preview mode
         if(inClamp.getConstVal() >= 0.5)
         {
            _out.append(_sDstVar+" = mathClampf("+_sDstVar+", 0.0f, 1.0f);\n");
         }

         // [21Sep2024] always use curve_intarrays (align with exported plugin behaviour)
         ia <= parent_script.getCurveIntArray(curve_idx);
         curveSzMask = ia.numElements - 1;
         _out.append(_sDstVar+" = curve_"+curve_idx+".get("+_sDstVar+" * "+curveSzScl+") * (1.0f / "+FX_ONE+");\n");
         // _out.append("trace \"curve_"+curve_idx+"=\"+#(curve_"+curve_idx+")+\" sDstVar=\"+"+_sDstVar+";\n");
      }

      if(bBipolar)
      {
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");

         _script.freeTmpVarInt(sVarBipSign);
      }

   }

   // <method.png>
   protected method emitIntLUT(CyScript _script, local String _out, local String _sDstVar) {

      int curveSzLog = log(lut.lut_w) / log(2);
      local int curveSzMask = lut.lut_w - 1;

      local String sIndexShift;
      if(curveSzLog >= FX_SHR)
         sIndexShift = " << "+(curveSzLog - FX_SHR);  // (note) not recommended (size exceeds FP precision)
      else if(curveSzLog < FX_SHR)
         sIndexShift = " >> "+(FX_SHR - curveSzLog);

      local String sLUT <= "lut_"+lut.id+export_c_prefix;
      // // local String sUITypeCast <= b_export_c ? "(unsigned int)" : "(int)";

      local CyInput inClamp   <= findInputById("clamp");
      local CyInput inLin     <= findInputById("lin");
      local CyInput inScl     <= findInputById("scl");
      local CyInput inBipolar <= findInputById("bipolar");
      local CyInput inIn      <= findInputById("in");
      
      local float   fScl     = inScl.getConstVal();
      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);
      local boolean bIn      = (inIn     .getConstVal() >= 0.5f);

      local String *sVarBipSign;
      if(bBipolar)
      {
         sVarBipSign <= _script.allocTmpVarInt(_out, "lut_bip_sign");

         _out.append(sVarBipSign+" = ("+_sDstVar+" < 0);\n");
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");
      }

      local String sIndex;
      if(bIn)
         sIndex.append("Dmulsw_shr("+_sDstVar+", "+curveSzMask+")");  // 0..1 => 0..size-1
      else
         sIndex.append("("+_sDstVar+sIndexShift+")"); // 0..1 => 0..size

      if(inLin.getConstVal() >= 0.5)
      {
         // Linear filtering
         local String sVarIdx  <= _script.allocTmpVarInt(_out, "lut_idx");
         local String sVarFrac <= _script.allocTmpVarInt(_out, "lut_frac");
         local String sVarR    <= _script.allocTmpVarInt(_out, "lut_r");

         if(inClamp.getConstVal() >= 0.5)
         {
            // Clamp to last value
            _out.append(sVarIdx+" = "+sIndex+";\n");
            if(1.0f != fScl && (curveSzMask >= 2))
            {
               _out.append("if("+sVarIdx+" >= "+(curveSzMask-1)+")\n");
               _out.append("   "+sVarIdx+" = "+(curveSzMask-2)+";\n");
            }
            else
            {
               _out.append("if("+sVarIdx+" >= "+curveSzMask+")\n");
               _out.append("   "+sVarIdx+" = "+(curveSzMask-1)+";\n");
            }
            _out.append("else if("+sVarIdx+" < 0)\n");
            _out.append("   "+sVarIdx+" = 0;\n");
            if(bIn)
               _out.append(sVarFrac+" = Dmulsw("+_sDstVar+", "+curveSzMask+") & "+int(FX_FRAC)+";\n");
            else
               _out.append(sVarFrac+" = ("+_sDstVar+" & "+int((FX_ONE>>curveSzLog)-1)+");\n");
            _out.append(_sDstVar+" = "+sLUT+"["+sVarIdx+"];\n");
            _out.append(sVarR+" = "+sLUT+"[("+sVarIdx+" + 1)];\n");
            // // _out.append("trace \"frac=\"+"+sVarFrac+"+\" (\"+("+sVarFrac+"/float("+(FX_ONE>>curveSzLog)+"))+\")\";\n");
            if(bIn)
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += Dmulsw_shr((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+");\n");
               else
                  _out.append(_sDstVar+" += Dmulsw_shr(("+sVarR+" - "+_sDstVar+"), "+sVarFrac+");\n");
            }
            else
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += mulsw((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+")"+sIndexShift+";\n");
               else
                  _out.append(_sDstVar+" += (("+sVarR+" - "+_sDstVar+") * "+sVarFrac+")"+sIndexShift+";\n");
            }
         }
         else
         {
            // Wrap-around
            _out.append(sVarIdx+" = "+sIndex+";\n");
            if(bIn)
               _out.append(sVarFrac+" = Dmulsw("+_sDstVar+", "+curveSzMask+") & "+int(FX_FRAC)+";\n");
            else
               _out.append(sVarFrac+" = ("+_sDstVar+" & "+int((FX_ONE>>curveSzLog)-1)+");\n");
            _out.append(_sDstVar+" = "+sLUT+"["+sVarIdx+" & "+curveSzMask+"];\n");
            _out.append(sVarR+" = "+sLUT+"[("+sVarIdx+" + 1) & "+curveSzMask+"];\n");
            // // _out.append("trace \"frac=\"+"+sVarFrac+"+\" (\"+("+sVarFrac+"/float("+(FX_ONE>>curveSzLog)+"))+\")\";\n");
            if(bIn)
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += Dmulsw_shr((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+");\n");
               else
                  _out.append(_sDstVar+" += Dmulsw_shr(("+sVarR+" - "+_sDstVar+") * "+sVarFrac+");\n");
            }
            else
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += mulsw((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+")"+sIndexShift+";\n");
               else
                  _out.append(_sDstVar+" += (("+sVarR+" - "+_sDstVar+") * "+sVarFrac+")"+sIndexShift+";\n");
            }
         }

         _script.freeTmpVarInt(sVarIdx);
         _script.freeTmpVarInt(sVarFrac);
         _script.freeTmpVarInt(sVarR);
      }
      else
      {
         // Nearest neighbour
         if(inClamp.getConstVal() >= 0.5)
         {
            // Clamp to last value
            if(1.0f != fScl && (curveSzMask >= 1))
               _out.append(_sDstVar+" = "+clamp_fun+"("+sIndex+", 0, "+(curveSzMask-1)+");\n");
            else
               _out.append(_sDstVar+" = "+clamp_fun+"("+sIndex+", 0, "+curveSzMask+");\n");
            _out.append(_sDstVar+" = "+sLUT+"["+_sDstVar+"];\n");
         }
         else
         {
            // Wrap-around
            _out.append("tmp_i = "+sIndex+";\n");
            _out.append(_sDstVar+" = "+sLUT+"[tmp_i & "+curveSzMask+"];\n");
         }
      }

      if(bBipolar)
      {
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");
         _script.freeTmpVarInt(sVarBipSign);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      // // CyArrayDecl arrayDecl <= parent_script.array_decls.get(curve_idx);

      // // if(null != arrayDecl || null != lut)
      if(null != array_decl || b_plugin)
      {
         trace "[~~~] warning: CyModuleLUT<int>: falling back to float for array param or plugin LUT..";
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      if(null != lut)
      {
         // procedural LUT
         emitIntLUT(_script, _out, _sDstVar);
         return;
      }

      IntArray ia <= parent_script.getCurveIntArray(curve_idx);
      int curveSzLog = log(ia.numElements) / log(2);
      int curveSzMask = ia.numElements - 1;

      local CyInput inClamp   <= findInputById("clamp");
      local CyInput inLin     <= findInputById("lin");
      local CyInput inScl     <= findInputById("scl");
      local CyInput inBipolar <= findInputById("bipolar");
      local CyInput inIn      <= findInputById("in");

      local float   fScl     = inScl.getConstVal();
      local boolean bBipolar = (inBipolar.getConstVal() >= 0.5f);
      local boolean bIn      = (inIn     .getConstVal() >= 0.5f);

      local String sIndexShift;
      if(curveSzLog >= FX_SHR)
         sIndexShift = " << "+(curveSzLog - FX_SHR);  // (note) not recommended (size exceeds FP precision)
      else if(curveSzLog < FX_SHR)
         sIndexShift = " >> "+(FX_SHR - curveSzLog);

      local String *sVarBipSign;
      if(bBipolar)
      {
         sVarBipSign <= _script.allocTmpVarInt(_out, "lut_bip_sign");

         _out.append(sVarBipSign+" = ("+_sDstVar+" < 0);\n");
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");
      }

      local String sIndex;
      if(bIn)
         sIndex.append("Dmulsw_shr("+_sDstVar+", "+curveSzMask+")");  // 0..1 => 0..size-1
      else
         sIndex.append("("+_sDstVar+sIndexShift+")"); // 0..1 => 0..size

      // trace "xxx inClamp.def_value="+inClamp.getConstVal();
      if(inLin.getConstVal() >= 0.5)
      {
         // Linear filtering
         local String sVarIdx  <= _script.allocTmpVarInt(_out, "lut_idx");
         local String sVarFrac <= _script.allocTmpVarInt(_out, "lut_frac");
         local String sVarR    <= _script.allocTmpVarInt(_out, "lut_r");

         if(inClamp.getConstVal() >= 0.5)
         {
            // Clamp to last value
            _out.append(sVarIdx+" = "+sIndex+";\n");
            if(1.0f != fScl && (curveSzMask >= 2))
            {
               _out.append("if("+sVarIdx+" >= "+(curveSzMask-1)+")\n");
               _out.append("   "+sVarIdx+" = "+(curveSzMask-2)+";\n");
            }
            else
            {
               _out.append("if("+sVarIdx+" >= "+curveSzMask+")\n");
               _out.append("   "+sVarIdx+" = "+(curveSzMask-1)+";\n");
            }
            _out.append("else if("+sVarIdx+" < 0)\n");
            _out.append("   "+sVarIdx+" = 0;\n");
            if(bIn)
               _out.append(sVarFrac+" = Dmulsw("+_sDstVar+", "+curveSzMask+") & "+int(FX_FRAC)+";\n");
            else
               _out.append(sVarFrac+" = ("+_sDstVar+" & "+int((FX_ONE>>curveSzLog)-1)+");\n");
            _out.append(_sDstVar+" = curve_"+curve_idx+export_c_prefix/*+export_c_var_prefix*/+"["+sVarIdx+"];\n");
            _out.append(sVarR+" = curve_"+curve_idx+export_c_prefix/*+export_c_var_prefix*/+"[("+sVarIdx+" + 1)];\n");
            // // _out.append("trace \"frac=\"+"+sVarFrac+"+\" (\"+("+sVarFrac+"/float("+(FX_ONE>>curveSzLog)+"))+\")\";\n");
            if(bIn)
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += Dmulsw_shr((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+");\n");
               else
                  _out.append(_sDstVar+" += Dmulsw_shr(("+sVarR+" - "+_sDstVar+"), "+sVarFrac+");\n");
            }
            else
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += mulsw((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+")"+sIndexShift+";\n");
               else
                  _out.append(_sDstVar+" += (("+sVarR+" - "+_sDstVar+") * "+sVarFrac+")"+sIndexShift+";\n");
            }
         }
         else
         {
            // Wrap-around
            _out.append(sVarIdx+" = "+sIndex+";\n");
            if(bIn)
               _out.append(sVarFrac+" = Dmulsw("+_sDstVar+", "+curveSzMask+") & "+int(FX_FRAC)+";\n");
            else
               _out.append(sVarFrac+" = ("+_sDstVar+" & "+int((FX_ONE>>curveSzLog)-1)+");\n");
            _out.append(_sDstVar+" = curve_"+curve_idx+export_c_prefix/*+export_c_var_prefix*/+"["+sVarIdx+" & "+curveSzMask+"];\n");
            _out.append(sVarR+" = curve_"+curve_idx+export_c_prefix/*+export_c_var_prefix*/+"[("+sVarIdx+" + 1) & "+curveSzMask+"];\n");
            // _out.append("trace \"frac=\"+"+sVarFrac+"+\" (\"+("+sVarFrac+"/float("+(FX_ONE>>curveSzLog)+"))+\")\";\n");
            if(bIn)
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += Dmulsw_shr((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+");\n");
               else
                  _out.append(_sDstVar+" += Dmulsw_shr(("+sVarR+" - "+_sDstVar+") * "+sVarFrac+");\n");
            }
            else
            {
               if(b_export_c)
                  _out.append(_sDstVar+" += mulsw((short)("+sVarR+" - "+_sDstVar+"), "+sVarFrac+")"+sIndexShift+";\n");
               else
                  _out.append(_sDstVar+" += (("+sVarR+" - "+_sDstVar+") * "+sVarFrac+")"+sIndexShift+";\n");
            }
         }

         _script.freeTmpVarInt(sVarIdx);
         _script.freeTmpVarInt(sVarFrac);
         _script.freeTmpVarInt(sVarR);
      }
      else
      {
         // Nearest neighbour
         if(inClamp.getConstVal() >= 0.5)
         {
            // Clamp to last value
            if(1.0f != fScl && (curveSzMask >= 1))
               _out.append(_sDstVar+" = "+clamp_fun+"("+sIndex+", 0, "+(curveSzMask-1)+");\n");
            else
               _out.append(_sDstVar+" = "+clamp_fun+"("+sIndex+", 0, "+curveSzMask+");\n");
            _out.append(_sDstVar+" = curve_"+curve_idx+export_c_prefix/*+export_c_var_prefix*/+"["+_sDstVar+"];\n");
         }
         else
         {
            // Wrap-around
            _out.append("tmp_i = "+sIndex+";\n");
            _out.append(_sDstVar+" = curve_"+curve_idx+export_c_prefix/*+export_c_var_prefix*/+"[tmp_i & "+curveSzMask+"];\n");
         }
      }

      if(bBipolar)
      {
         _out.append("if("+sVarBipSign+") "+_sDstVar+" = -"+_sDstVar+";\n");
         _script.freeTmpVarInt(sVarBipSign);
      }

   }
}


// <class.png>
class CyModulePluginArrayParamField : CyModule {
   CyPluginParam *param;
   CyArrayDecl   *array_decl;
   int            element_idx;

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local String sLUT <= "voice->"+array_decl.getVoiceArrayName();
         local String elementName <= array_decl.getElementName(element_idx);
         if(null != elementName)
            _out.append(_sDstVar+" = "+sLUT+"["+element_idx+"/*"+elementName+"*/];\n");
         else
            _out.append(_sDstVar+" = "+sLUT+"["+element_idx+"];\n");
      }
      else
         _out.append(_sDstVar+" = 0.0f;\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModulePluginArrayParamField<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleMkv : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("a",   0.0, 0.0, 1.0);
      addInput("b",   1.0, 0.0, 1.0);
      addInput("r",   0.5, 0.0, 1.0);  // use previous output when not connected
      addInput("ab",  0.5, 0.0, 1.0);
      addInput("ba",  0.5, 0.0, 1.0);
      addInput("onb", 0.5, 0.0, 1.0);
      addInput("ona", 0.5, 0.0, 1.0);
      addInput("act", 1.0, 0.0, 1.0);
   }

   // <method_get.png>
   public virtual validate() : boolean {
      local CyInput inAct <= findInputById("act");
      return inAct.isConstVal();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inA   <= findInputById("a");
      local CyInput inB   <= findInputById("b");
      local CyInput inR   <= findInputById("r");
      local CyInput inAB  <= findInputById("ab");
      local CyInput inBA  <= findInputById("ba");
      local CyInput inOnB <= findInputById("onb");
      local CyInput inOnA <= findInputById("ona");
      local CyInput inAct <= findInputById("act");

      local int act = int(inAct.getConstVal() + 0.5f);
      local boolean bOnB = inOnB.isConnected();
      local boolean bOnA = inOnA.isConnected();

      local String sInit;
      // (note) in act=2 mode (calc A/B only during state transitions), initial state is "floating" => calc+output 'A' (once) until coin toss decides for 'B'
      local String sVarState <= _script.allocTmpVarIntInit(sInit, "mkv_state", (2 == act) ? -1 : 0, true/*bCycleReset*/);
      local String sVarOut   <= _script.allocTmpVarInit(sInit, "mkv_out", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sVarA   <= _script.allocTmpVar(_out, "mkv_a");
      local String sVarB   <= _script.allocTmpVar(_out, "mkv_b");
      local String sVarR   <= _script.allocTmpVar(_out, "mkv_r");
      local String sVarAB  <= _script.allocTmpVar(_out, "mkv_ab");
      local String sVarBA  <= _script.allocTmpVar(_out, "mkv_ba");
      local String *sVarTmp;
      if(bOnB || bOnA)
         sVarTmp <= _script.allocTmpVar(_out, "mkv_tmp");

      local String sCalcA;
      local String sCalcB;
      local String sCalcAB;
      local String sCalcBA;
      local String sIndent;

      if(inR.isConnected())
         inR.emitFloat(_script, _out, sVarR);
      else
         _out.append(sVarR+" = "+_sDstVar+";\n");

      inA.emitFloat(_script, sCalcA, sVarA);
      inB.emitFloat(_script, sCalcB, sVarB);

      inAB.emitFloat(_script, sCalcAB, sVarAB);
      inBA.emitFloat(_script, sCalcBA, sVarBA);

      if(0 == act)
      {
         // Always calc inputs, regardless of current state
         _out.append(sCalcA);
         _out.append(sCalcAB);
         _out.append(sCalcB);
         _out.append(sCalcBA);

         _out.append("if(0/*A*/ == "+sVarState+")\n");
         _out.append("{\n");
         _out.append("   if("+sVarR+" <= "+sVarAB+")\n");
         // Transition from A to B
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 1;\n");
         if(bOnB)
         {
            sIndent.empty();
            inOnB.emitFloat(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("      "+sVarOut+" = "+sVarB+";\n");
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("   {\n");
         _out.append("      "+sVarOut+" = "+sVarA+";\n");  // stay in 'A'
         _out.append("   }\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         _out.append("   if("+sVarR+" <= "+sVarBA+")\n");
         // Transition from B to A
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 0;\n");
         if(bOnA)
         {
            sIndent.empty();
            inOnA.emitFloat(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("      "+sVarOut+" = "+sVarA+";\n");
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("   {\n");
         _out.append("      "+sVarOut+" = "+sVarB+";\n");  // stay in 'B'
         _out.append("   }\n");
         _out.append("}\n");
      }
      else
      {
         local String *sVarStateLast;
         if(1 != act)
         {
            sVarStateLast <= _script.allocTmpVarInt(_out, "mkv_state_last");
            _out.append(sVarStateLast+" = "+sVarState+";\n");
         }

         // Calc probability to change to other state
         _out.append("if("+sVarState+" <= 0/*A*/)\n");
         _out.append("{\n");
         CyScript.AppendIndentedLines(_out, sCalcAB, 3);
         _out.append("   if("+sVarR+" <= "+sVarAB+")\n");
         // Transition from A to B
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 1;\n");
         if(bOnB)
         {
            sIndent.empty();
            inOnB.emitFloat(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("   }\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         CyScript.AppendIndentedLines(_out, sCalcBA, 3);
         _out.append("   if("+sVarR+" <= "+sVarBA+")\n");
         // Transition from B to A
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 0;\n");
         if(bOnA)
         {
            sIndent.empty();
            inOnA.emitFloat(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("   }\n");
         _out.append("}\n");

         if(1 == act)
         {
            // Always calc active input
            _out.append("if(0/*A*/ == "+sVarState+")\n");
            _out.append("{\n");
            CyScript.AppendIndentedLines(_out, sCalcA, 3);
            _out.append("   "+sVarOut+" = "+sVarA+";\n");
            _out.append("}\n");
            _out.append("else\n");
            _out.append("{\n");
            CyScript.AppendIndentedLines(_out, sCalcB, 3);
            _out.append("   "+sVarOut+" = "+sVarB+";\n");
            _out.append("}\n");
         }
         else
         {
            // "act=2": Calc active input only when state changes. Initial output is 'A' unless coin toss changed state to 'B'.
            _out.append("if(("+sVarState+"&3) != "+sVarStateLast+")\n");
            _out.append("{\n");
            _out.append("   if("+sVarState+" <= 0/*A*/)\n");
            _out.append("   {\n");
            CyScript.AppendIndentedLines(_out, sCalcA, 6);
            _out.append("      "+sVarOut+" = "+sVarA+";\n");
            _out.append("      "+sVarState+" = 0/*A*/;\n");
            _out.append("   }\n");
            _out.append("   else\n");
            _out.append("   {\n");
            CyScript.AppendIndentedLines(_out, sCalcB, 6);
            _out.append("      "+sVarOut+" = "+sVarB+";\n");
            _out.append("      "+sVarState+" = 1/*B*/;\n");
            _out.append("   }\n");
            _out.append("}\n");
         }

         if(null != sVarStateLast)
            _script.freeTmpVarInt(sVarStateLast);
      }

      _out.append(_sDstVar+" = "+sVarOut+";\n");

      if(null != sVarTmp)
         _script.freeTmpVar(sVarTmp);

      _script.freeTmpVar(sVarA);
      _script.freeTmpVar(sVarB);
      _script.freeTmpVar(sVarR);
      _script.freeTmpVar(sVarAB);
      _script.freeTmpVar(sVarBA);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // // trace "[~~~] warning: CyModuleMkv<int>: falling back to float..";
      // // emitFloatFallback(_script, _out, _sDstVar);

      local CyInput inA   <= findInputById("a");
      local CyInput inB   <= findInputById("b");
      local CyInput inR   <= findInputById("r");
      local CyInput inAB  <= findInputById("ab");
      local CyInput inBA  <= findInputById("ba");
      local CyInput inOnB <= findInputById("onb");
      local CyInput inOnA <= findInputById("ona");
      local CyInput inAct <= findInputById("act");

      local int act = int(inAct.getConstVal() + 0.5f);
      local boolean bOnB = inOnB.isConnected();
      local boolean bOnA = inOnA.isConnected();

      local String sInit;
      // (note) in act=2 mode (calc A/B only during state transitions), initial state is "floating" => calc+output 'A' (once) until coin toss decides for 'B'
      local String sVarState <= _script.allocTmpVarIntInit(sInit, "mkv_state", (2 == act) ? -1 : 0, true/*bCycleReset*/);
      local String sVarOut   <= _script.allocTmpVarIntInit(sInit, "mkv_out", int(0), true/*bCycleReset*/);
      _script.appendInit(sInit);

      local String sVarA   <= _script.allocTmpVarInt(_out, "mkv_a");
      local String sVarB   <= _script.allocTmpVarInt(_out, "mkv_b");
      local String sVarR   <= _script.allocTmpVarInt(_out, "mkv_r");
      local String sVarAB  <= _script.allocTmpVarInt(_out, "mkv_ab");
      local String sVarBA  <= _script.allocTmpVarInt(_out, "mkv_ba");
      local String *sVarTmp;
      if(bOnB || bOnA)
         sVarTmp <= _script.allocTmpVarInt(_out, "mkv_tmp");

      local String sCalcA;
      local String sCalcB;
      local String sCalcAB;
      local String sCalcBA;
      local String sIndent;

      if(inR.isConnected())
         inR.emitInt(_script, _out, sVarR);
      else
         _out.append(sVarR+" = "+_sDstVar+";\n");

      inA.emitInt(_script, sCalcA, sVarA);
      inB.emitInt(_script, sCalcB, sVarB);

      inAB.emitInt(_script, sCalcAB, sVarAB);
      inBA.emitInt(_script, sCalcBA, sVarBA);

      if(0 == act)
      {
         // Always calc inputs, regardless of current state
         _out.append(sCalcA);
         _out.append(sCalcAB);
         _out.append(sCalcB);
         _out.append(sCalcBA);

         _out.append("if(0/*A*/ == "+sVarState+")\n");
         _out.append("{\n");
         _out.append("   if("+sVarR+" <= "+sVarAB+")\n");
         // Transition from A to B
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 1;\n");
         if(bOnB)
         {
            sIndent.empty();
            inOnB.emitInt(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("      "+sVarOut+" = "+sVarB+";\n");
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("   {\n");
         _out.append("      "+sVarOut+" = "+sVarA+";\n");  // stay in 'A'
         _out.append("   }\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         _out.append("   if("+sVarR+" <= "+sVarBA+")\n");
         // Transition from B to A
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 0;\n");
         if(bOnA)
         {
            sIndent.empty();
            inOnA.emitInt(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("      "+sVarOut+" = "+sVarA+";\n");
         _out.append("   }\n");
         _out.append("   else\n");
         _out.append("   {\n");
         _out.append("      "+sVarOut+" = "+sVarB+";\n");  // stay in 'B'
         _out.append("   }\n");
         _out.append("}\n");
      }
      else
      {
         local String *sVarStateLast;
         if(1 != act)
         {
            sVarStateLast <= _script.allocTmpVarInt(_out, "mkv_state_last");
            _out.append(sVarStateLast+" = "+sVarState+";\n");
         }

         // Calc probability to change to other state
         _out.append("if("+sVarState+" <= 0/*A*/)\n");
         _out.append("{\n");
         CyScript.AppendIndentedLines(_out, sCalcAB, 3);
         _out.append("   if("+sVarR+" <= "+sVarAB+")\n");
         // Transition from A to B
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 1;\n");
         if(bOnB)
         {
            sIndent.empty();
            inOnB.emitInt(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("   }\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         CyScript.AppendIndentedLines(_out, sCalcBA, 3);
         _out.append("   if("+sVarR+" <= "+sVarBA+")\n");
         // Transition from B to A
         _out.append("   {\n");
         _out.append("      "+sVarState+" = 0;\n");
         if(bOnA)
         {
            sIndent.empty();
            inOnA.emitInt(_script, sIndent, sVarTmp);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
         }
         _out.append("   }\n");
         _out.append("}\n");

         if(1 == act)
         {
            // Always calc active input
            _out.append("if(0/*A*/ == "+sVarState+")\n");
            _out.append("{\n");
            CyScript.AppendIndentedLines(_out, sCalcA, 3);
            _out.append("   "+sVarOut+" = "+sVarA+";\n");
            _out.append("}\n");
            _out.append("else\n");
            _out.append("{\n");
            CyScript.AppendIndentedLines(_out, sCalcB, 3);
            _out.append("   "+sVarOut+" = "+sVarB+";\n");
            _out.append("}\n");
         }
         else
         {
            // "act=2": Calc active input only when state changes. Initial output is 'A' unless coin toss changed state to 'B'.
            _out.append("if(("+sVarState+"&3) != "+sVarStateLast+")\n");
            _out.append("{\n");
            _out.append("   if("+sVarState+" <= 0/*A*/)\n");
            _out.append("   {\n");
            CyScript.AppendIndentedLines(_out, sCalcA, 6);
            _out.append("      "+sVarOut+" = "+sVarA+";\n");
            _out.append("      "+sVarState+" = 0/*A*/;\n");
            _out.append("   }\n");
            _out.append("   else\n");
            _out.append("   {\n");
            CyScript.AppendIndentedLines(_out, sCalcB, 6);
            _out.append("      "+sVarOut+" = "+sVarB+";\n");
            _out.append("      "+sVarState+" = 1/*B*/;\n");
            _out.append("   }\n");
            _out.append("}\n");
         }

         if(null != sVarStateLast)
            _script.freeTmpVarInt(sVarStateLast);
      }

      _out.append(_sDstVar+" = "+sVarOut+";\n");

      if(null != sVarTmp)
         _script.freeTmpVarInt(sVarTmp);

      _script.freeTmpVarInt(sVarA);
      _script.freeTmpVarInt(sVarB);
      _script.freeTmpVarInt(sVarR);
      _script.freeTmpVarInt(sVarAB);
      _script.freeTmpVarInt(sVarBA);
   }
}


// <class.png>
class CyModuleNeg : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = -"+_sDstVar+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = -"+_sDstVar+";\n");
   }
}


// <class.png>
class CyModuleNos : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("seed",  0x3d9fb971, 0.0,  2147483648);
      addInput("cycle", 0,          0,    1);  // [05May2023] default val changed from 1 to 0
      addInput("reset", 1,          0,    1);

      addInputAlias("s",  "seed");
      addInputAlias("cy", "cycle");
      addInputAlias("rs", "reset");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inSeed  <= findInputById("seed");
      local CyInput inCycle <= findInputById("cycle");
      local CyInput inReset <= findInputById("reset");

      int seed1 = 0x4489abcdu ^ int(inSeed.getConstVal());
      int seed2 = 0xdeadbeefu ^ int(inSeed.getConstVal());

      local String sInit;
      local String sVarSeed1 <= _script.allocTmpVarInt32Init(sInit, "nos_seed1", seed1,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );
      local String sVarSeed2 <= _script.allocTmpVarInt32Init(sInit, "nos_seed2", seed2,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );
      _script.appendInit(sInit);

      local String sVarFb <= _script.allocTmpVarInt(_out, "nos_fb");

      _out.append(sVarFb+" = "+sVarSeed1+" & 1;\n");
      _out.append(sVarSeed1+" >>= 1;\n");
      _out.append("if(0 != "+sVarFb+")\n");
      _out.append("    "+sVarSeed1+" ^= 0xB4BCD35C;\n");

      _out.append(sVarFb+" = "+sVarSeed2+" & 1;\n");
      _out.append(sVarSeed2+" >>= 1;\n");
      _out.append("if(0 != "+sVarFb+")\n");
      _out.append("    "+sVarSeed2+" ^= 0x7A5BC2E3;\n");

      _out.append(_sDstVar+" = ((("+sVarSeed1+" ^ "+sVarSeed2+") & 0xFFFF) - 0x8000) * (1.0 / 32767.0);\n");

      _script.freeTmpVarInt(sVarFb);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inSeed <= findInputById("seed");
      local CyInput inCycle <= findInputById("cycle");
      local CyInput inReset <= findInputById("reset");

      int seed1 = 0x4489abcdu ^ int(inSeed.getConstVal());
      int seed2 = 0xdeadbeefu ^ int(inSeed.getConstVal());

      local String sInit;
      local String sVarSeed1 <= _script.allocTmpVarInt32Init(sInit, "nos_seed1", seed1,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );
      local String sVarSeed2 <= _script.allocTmpVarInt32Init(sInit, "nos_seed2", seed2,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );
      _script.appendInit(sInit);

      local String sVarFb <= _script.allocTmpVarInt(_out, "nos_fb");

      _out.append(sVarFb+" = "+sVarSeed1+" & 1;\n");
      _out.append(sVarSeed1+" >>= 1;\n");
      _out.append("if(0 != "+sVarFb+")\n");
      _out.append("    "+sVarSeed1+" ^= 0xB4BCD35C;\n");

      _out.append(sVarFb+" = "+sVarSeed2+" & 1;\n");
      _out.append(sVarSeed2+" >>= 1;\n");
      _out.append("if(0 != "+sVarFb+")\n");
      _out.append("    "+sVarSeed2+" ^= 0x7A5BC2E3;\n");

      if(11 == FX_SHR)
         _out.append(_sDstVar+" = (((("+sVarSeed1+" ^ "+sVarSeed2+") ) & 0xFFF) - 0x800);\n");
      else
         _out.append(_sDstVar+" = (((("+sVarSeed1+" ^ "+sVarSeed2+") ) & 0x3FFF) - 0x2000);\n");

      _script.freeTmpVarInt(sVarFb);
   }
}


// <class.png>
class CyModuleNot : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = ("+_sDstVar+" > 0.0f) ? 0.0f : 1.0f;\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = ("+_sDstVar+" > 0) ? 0 : "+FX_ONE+";\n");
   }
}


// <class.png>
class CyModuleNth : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("every",   1, 1,    32);  // every "n"th pulse (must be const)
      addInput("shift",   0, 0,    32);  // pulse count shift (must be const)  (e.g. -1=start with second pulse)
      addInput("restart", 0, 0,    32);  // restart pulse count
      addInput("onclk",   1, 0,     1);  // run arbitrary statement block when clk duty cycle begins. output value (0..1) scales pulse level.

      addInputAlias("e",  "every");
      addInputAlias("s",  "shift");
      addInputAlias("rs", "restart");
      addInputAlias("oc", "onclk");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inEvery   <= findInputById("every");
      local CyInput inShift   <= findInputById("shift");
      local CyInput inRestart <= findInputById("restart");
      local CyInput inOnClk   <= findInputById("onclk");

      local boolean bRestart = inRestart.isConnected();
      local boolean bOnClk   = inOnClk.isConnected();

      local int iEvery = (int)(inEvery.getConstVal() + 0.5);
      if(iEvery < 1)
         iEvery = 1;
      local int iShift = (int)(inShift.getConstVal() + 0.5);

      local String sInit;
      local String sVarCount <= _script.allocTmpVarIntInitVoice(sInit, "nth_step", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLast  <= _script.allocTmpVarInitVoice(sInit, "nth_last", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarInitVoice(sInit, "nth_last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarClkScl;
      if(bOnClk)
         sVarClkScl <= _script.allocTmpVarInitVoice(sInit, "nth_scl", 1.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarOut <= _script.allocTmpVarInitVoice(sInit, "nth_out", 0, true/*bCycleReset*/, true/*bVoiceReset*/);  // sample&hold
      _script.appendInit(sInit);

      local String sIndent;

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVar(_out, "restart");
         inRestart.emitFloat(_script, _out, sVarRestart);
         _out.append(IfRisingEdgeFloat(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         _out.append("   "+sVarCount+" = 0;\n");
         _out.append("}\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
      }

      _out.append(IfRisingEdgeFloat(_sDstVar, sVarLast));
      _out.append("{\n");
      int iMask = [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536].contains(iEvery) ? (iEvery - 1) : 0;
      if(1 == iEvery)
         _out.append("   if(1)\n");////0 == (("+sVarCount+"++ + "+iShift+") /* % 1 */))\n");
      else if(iMask)
         _out.append("   if(0 == (("+sVarCount+"++ + "+iShift+") & "+iMask+"))\n");
      else
         _out.append("   if(0 == (("+sVarCount+"++ + "+iShift+") % "+iEvery+"))\n");
      _out.append("   {\n");
      if(bOnClk)
      {
         // Calc clock level multiplier
         sIndent.empty();
         inOnClk.emitFloat(_script, sIndent, sVarClkScl);
         CyScript.AppendIndentedLines(_out, sIndent, 6);
         _out.append("      "+sVarOut+" = "+_sDstVar+" * "+sVarClkScl+";\n");
      }
      else
         _out.append("      "+sVarOut+" = "+_sDstVar+";\n");
      _out.append("   }\n");
      _out.append("}\n");
      _out.append("else "+IfFallingEdgeFloat(_sDstVar, sVarLast));
      _out.append("{\n");
      _out.append("   "+sVarOut+" = "+_sDstVar+";\n");
      _out.append("}\n");
      // Track signal
      _out.append(sVarLast+" = "+_sDstVar+";\n");

      // Output sample&hold
      _out.append(_sDstVar+" = "+sVarOut+";\n");

   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // // // (todo) implement 'nth' emitInt()
      // // trace "[~~~] warning: CyModuleNth<int> falling back to float..";
      // // emitFloatFallback(_script, _out, _sDstVar);

      local CyInput inEvery   <= findInputById("every");
      local CyInput inShift   <= findInputById("shift");
      local CyInput inRestart <= findInputById("restart");
      local CyInput inOnClk   <= findInputById("onclk");

      local boolean bRestart = inRestart.isConnected();
      local boolean bOnClk   = inOnClk.isConnected();

      local int iEvery = (int)(inEvery.getConstVal() + 0.5);
      if(iEvery < 1)
         iEvery = 1;
      local int iShift = (int)(inShift.getConstVal() + 0.5);

      local String sInit;
      local String sVarCount <= _script.allocTmpVarIntInitVoice(sInit, "nth_step", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLast  <= _script.allocTmpVarIntInitVoice(sInit, "nth_last", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarIntInitVoice(sInit, "nth_last_restart", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarClkScl;
      if(bOnClk)
         sVarClkScl <= _script.allocTmpVarIntInitVoice(sInit, "nth_scl", int(FX_ONE), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarOut <= _script.allocTmpVarIntInitVoice(sInit, "nth_out", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);  // sample&hold
      _script.appendInit(sInit);

      local String sIndent;

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVarInt(_out, "restart");
         inRestart.emitInt(_script, _out, sVarRestart);
         _out.append(IfRisingEdgeInt(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         _out.append("   "+sVarCount+" = 0;\n");
         _out.append("}\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
      }

      _out.append(IfRisingEdgeInt(_sDstVar, sVarLast));
      _out.append("{\n");
      int iMask = [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536].contains(iEvery) ? (iEvery - 1) : 0;
      if(1 == iEvery)
         _out.append("   if(1)\n");////0 == (("+sVarCount+"++ + "+iShift+") /* % 1 */))\n");
      else if(iMask)
         _out.append("   if(0 == (("+sVarCount+"++ + "+iShift+") & "+iMask+"))\n");
      else
         _out.append("   if(0 == (("+sVarCount+"++ + "+iShift+") % "+iEvery+"))\n");
      _out.append("   {\n");
      if(bOnClk)
      {
         // Calc clock level multiplier
         sIndent.empty();
         inOnClk.emitInt(_script, sIndent, sVarClkScl);
         CyScript.AppendIndentedLines(_out, sIndent, 6);
         _out.append("      "+sVarOut+" = Dmulsw_shr("+_sDstVar+", "+sVarClkScl+");\n");
      }
      else
         _out.append("      "+sVarOut+" = "+_sDstVar+";\n");
      _out.append("   }\n");
      _out.append("}\n");
      _out.append("else "+IfFallingEdgeInt(_sDstVar, sVarLast));
      _out.append("{\n");
      _out.append("   "+sVarOut+" = "+_sDstVar+";\n");
      _out.append("}\n");
      // Track signal
      _out.append(sVarLast+" = "+_sDstVar+";\n");

      // Output sample&hold
      _out.append(_sDstVar+" = "+sVarOut+";\n");
   }

}


// <class.png>
class CyModuleWriteBus : CyModule {
   // 'wbl', 'wbr'
   boolean b_right;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("nri", 0.0, 1,    32  );
      addInput("nrf", 0.0, 0.1,  0.32);
   }

   // <method_get.png>
   public virtual getString() : String {
      return b_right ? "wbr" : "wbl";
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inNrI <= findInputById("nri");
      local CyInput inNrF <= findInputById("nrf");

      if(b_plugin)
      {
         String sVoiceBusIndices <= _script.s_voicebus_indices;
         local String sIndent;
         local String *sBusSamples;
         local String sVarBusNrF <= _script.allocTmpVar(_out, "nrf");
         if(inNrI.isConnected())
         {
            // 0..32
            inNrI.emitFloat(_script, sIndent, sVarBusNrF);
            local String sVarBusNr <= _script.allocTmpVarInt(_out, "nr");
            sIndent.append(sVarBusNr+" = (int)("+sVarBusNrF+");\n");
            CyScript.AppendIndentedLines(sVoiceBusIndices, sIndent, 3);
            sBusSamples <= _script.allocVoiceBus(sVarBusNr, false/*bFloatNr*/);  // appends init code to s_voicebus_indices
            _script.freeTmpVarInt(sVarBusNr);
         }
         else
         {
            // 0.1..0.32 => 0..32
            inNrF.emitFloat(_script, sIndent, sVarBusNrF);
            CyScript.AppendIndentedLines(sVoiceBusIndices, sIndent, 3);
            sBusSamples <= _script.allocVoiceBus(sVarBusNrF, true/*bFloatNr*/);  // appends init code to s_voicebus_indices
         }

         // (note) always a valid ptr (points to "0"-filled buffer if layer does not exist)
         _out.append(sBusSamples+"[k"+(b_right?"+1":"")+"] = "+_sDstVar+";\n");

         _script.freeTmpVar(sVarBusNrF);
      }
      else
      {
         _out.append("/* skip voice write (only available in plugin mode) */\n");
         _out.append(_sDstVar+" = 0.0f;\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleWriteBus<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModulePan : CyModule {
   boolean b_right;   // 0=pal  1=par  

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("pos", 0.0, -1.0, 1.0);

      addInputAlias("p", "pos");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inPos <= findInputById("pos");

      local String sVarPos <= _script.allocTmpVar(_out, "pan_pos");
      inPos.emitFloat(_script, _out, sVarPos);

      if(b_right)
         _out.append(_sDstVar+" = ("+sVarPos+" > 0.0f) ? 1.0f : (1.0f + "+sVarPos+");\n");
      else
         _out.append(_sDstVar+" = ("+sVarPos+" < 0.0f) ? 1.0f : (1.0f - "+sVarPos+");\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inPos <= findInputById("pos");

      local String sVarPos <= _script.allocTmpVarInt(_out, "pan_pos");
      inPos.emitInt(_script, _out, sVarPos);

      if(b_right)
         _out.append(_sDstVar+" = ("+sVarPos+" > 0) ? "+FX_ONE+" : ("+FX_ONE+" + "+sVarPos+");\n");
      else
         _out.append(_sDstVar+" = ("+sVarPos+" < 0) ? "+FX_ONE+" : ("+FX_ONE+" - "+sVarPos+");\n");
   }
}


// <class.png>
class CyModulePha : CyModuleOscSync {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq",     1.0, 0.25, 4.0);
      addInput("phase",    0.0, 0.0,  1.0);
      addInput("vsync",    1.0, 0.01, 4.0);
      addInput("cycle",    1.0, 0.0,  1.0);
      addInput("reset",    1.0, 0.0,  1.0);
      addInput("window",   0.0, 0.0,  3.0);  // 0=off, 1=sine, 2=half-sine, 3=tri, 4=hse1_36, 5=hse2, 6=hse3, 7=hse5, 8=hse7
      addInput("fixed",    0.0, 0.0,  1.0);
      addInput("phasemod", 0.0, 0.0,  1.0);  // post vsync
      addInput("pd",       0.0, 0.0,  1.0);  // phase distortion subtree. input is phase (0..1), output is new phase (0..1)

      // // addInputAlias("rate", "freq");
      addInputAlias("f",   "freq");
      addInputAlias("ph",  "phase");
      addInputAlias("vs",  "vsync");
      addInputAlias("cy",  "cycle");
      addInputAlias("win", "window");
      addInputAlias("fx",  "fixed");
      addInputAlias("pm",  "phasemod");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inWindow   <= findInputById("window");
      local CyInput inPhaseMod <= findInputById("phasemod");
      local CyInput inPD       <= findInputById("pd");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);
      local boolean bWindow = (inWindow.getConstVal() >= 1.0f);
      local int windowType;
      if(inWindow.isConstVal())
      {
         windowType = int(inWindow.getConstVal() + 0.5f);
         bWindow = (windowType > 0);
      }
      else
         windowType = -1;

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarInitVoice(sInit, "pha_phase", fPhaseInit,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );

      local String *sVarPhaseWin;
      if(bWindow)
      {
         sVarPhaseWin <= _script.allocTmpVarInitVoice(sInit, "win_phase", 0.0f,
                                                      (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                      (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                      );
      }

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarInit(sInit, "pha_speed",
                                                 inFreq.getConstVal() * _script.note_speed_fixed,
                                                 false/*bCycleReset*/
                                                 );
         else
            sVarSpeed <= _script.allocTmpVarInit(sInit, "pha_speed",
                                                 inFreq.getConstVal() * _script.note_speed,
                                                 false/*bCycleReset*/
                                                 );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVar(sInit, "pha_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVar(_out, "pha_freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = voice->note_speed_fixed * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = voice->note_speed_cur * "+sVarFreq+";\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed_fixed)+" * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed)+" * "+sVarFreq+";\n");
         }
         _script.freeTmpVar(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVar(sOut, "pha_tmp");
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVar(_out, "phase");
         inPhase.emitFloat(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + "+sVarTmpPhase+")");
      }
      sOut.append(");\n");  // end "pha_tmp = (..)"  (phase)

      local String *sVSync;
      if(inVSync.isConstVal())
      {
         local float fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
            sVSync <= FloatToString(fVSync);
      }
      else
      {
         sVarVSync <= _script.allocTmpVar(_out, "vsync");
         sVSync <= sVarVSync;
         inVSync.emitFloat(_script, _out, sVarVSync);
      }
      // // if(null != sVSync)
      if((null != sVSync) && !bWindow)
         sOut.append(sTmp+" = "+sTmp+" * "+sVSync+";\n");

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVar(sOut, "phasemod");
         inPhaseMod.emitFloat(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += "+sVarTmpPhaseMod+";\n");
      }

      sOut.append(_sDstVar+" = ffrac_s("+sTmp+");\n");

      if(inPD.isConnected())
      {
         inPD.emitFloat(_script, sOut, _sDstVar);
      }

      if(bWindow)
      {
         emitSyncWindow(_script, inWindow, windowType, sOut, sVarPhaseWin, _sDstVar);
      }

      if(!bSpeed0)
      {
         if(bWindow && (null != sVSync))
         {
            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+" * "+sVSync+");\n");
            sOut.append("tmp_f = "+sVarPhaseWin+";\n");
            sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");
            sOut.append("if(tmp_f > "+sVarPhaseWin+") "+sVarPhase+" = "+sVarPhaseWin+" * "+sVSync+"; \n");
         }
         else
         {
            if(bWindow)
               sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");

            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+");\n");
         }
      }
      // // sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+");\n");

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVar(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVar(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVar(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVar(sVarTmpPhaseMod);

      _script.freeTmpVar(sTmp);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      // local CyInput inWindow   <= findInputById("window");
      local CyInput inPhaseMod <= findInputById("phasemod");

      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarIntInitVoice(sInit, "pha_phase",
                                                                int(fPhaseInit*16384),
                                                                (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                                (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                                );

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "pha_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed_fixed),
                                                    false/*bCycleReset*/
                                                    );
         else
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "pha_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed),
                                                    false/*bCycleReset*/
                                                    );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVarInt(sInit, "pha_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVarInt(_out, "pha_freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_fixed * 16384), "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_cur * 16384), "+sVarFreq+");\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed_fixed * 16384)+", "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed * 16384)+", "+sVarFreq+");\n");
         }
         _script.freeTmpVarInt(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVarInt(_out, "pha_tmp");
      local String *sVarTmpPhase;
      local String *sVarTmpPhaseMod;
      local String *sVarVSync;

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVarInt(_out, "phase");
         inPhase.emitInt(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + ("+sVarTmpPhase+" << 3))");  // *8 to scale from FX_ONE (2048) to 16384
      }
      sOut.append(");\n");  // end "tmp = (..)"  (phase)

      float fVSync = 1.0;
      if(inVSync.isConstVal())
      {
         fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
         {
            if(b_export_c)
               sOut.append(sTmp+" = mulsw("+sTmp+", "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
            else
               sOut.append(sTmp+" = ("+sTmp+" * "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
         }
      }
      else
      {
         fVSync = -1.0f;
         sVarVSync <= _script.allocTmpVarInt(_out, "vsync");
         inVSync.emitInt(_script, _out, sVarVSync);
         if(b_export_c)
            sOut.append(sTmp+" = mulsw("+sTmp+", "+sVarVSync+") >> "+FX_SHR+";\n");
         else
            sOut.append(sTmp+" = ("+sTmp+" * "+sVarVSync+") >> "+FX_SHR+";\n");
      }

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVarInt(sOut, "phasemod");
         inPhaseMod.emitInt(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += ("+sVarTmpPhaseMod+" << 3);\n");  // *8 to scale from FX_ONE (2048) to 16384
      }

      sOut.append(sTmp+" = "+sTmp+" & 0x3FFF;\n");  // frac()

      sOut.append(_sDstVar+" = "+sTmp+" >> (14 - "+FX_SHR+");\n");  // shift down to 12 bits

      sOut.append(sVarPhase+" += "+sVarSpeed+";\n");

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVarInt(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVarInt(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVarInt(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVarInt(sVarTmpPhaseMod);

      _script.freeTmpVarInt(sTmp);
   }

}


// <class.png>
class CyModuleP2s : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("exp",  7.0, 1.0, 16.0);
      addInput("scl",  0.0, 0.0, 1.0);
      addInput("kbd",  0.0, -16.0, 16.0);
      addInput("off",  0.0, -4.0, 4.0);
      addInput("sr",   1, 0, 1);          // 1=use oversample_factor  0=don't  (must be const)

      addInputAlias("e", "exp");
      addInputAlias("s", "scl");
      addInputAlias("k", "kbd");
      addInputAlias("o", "off");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inExp  <= findInputById("exp");
      local CyInput inScl  <= findInputById("scl");
      local CyInput inKbd  <= findInputById("kbd");
      local CyInput inOff  <= findInputById("off");

      local String *sVarKbd;
      local String *sVarOff;

      if(inExp.isConstVal())
      {
         float fExp = inExp.getConstVal();

         local String *sScl;
         if(inScl.getConstVal() > 0.0f)
         {
            sScl <= FloatToString(inScl.getConstVal());
         }
         else
         {
            sScl <= FloatToString(1.0f / (mathPowerf(2.0f, fExp) - 1.0f));
         }

         // if(b_plugin)
         //    _out.append("  printf(\"p2s mod=%f\\n\", "+_sDstVar+");\n");

         if(b_plugin && inKbd.isConnected())
         {
            _out.append(_sDstVar+" *= "+FloatToString(mathPowerf(2.0f, fExp) - 1.0f)+";\n");

            // (todo) assumes that sScl=1/127, need to scale if it is not
            sVarKbd <= _script.allocTmpVar(_out, "kbd");
            inKbd.emitFloat(_script, _out, sVarKbd);
            sVarOff <= _script.allocTmpVar(_out, "off");
            inOff.emitFloat(_script, _out, sVarOff);
            _out.append(_sDstVar+" += (voice->note_cur + ("+sVarOff+" * 12.0f) - 64.0f) * "+sVarKbd+";\n");

            if(b_plugin)
            {
               // _out.append("  printf(\"p2s note_cur=%f out<note>=%f off=%f\\n\", voice->note_cur, "+_sDstVar+", "+sVarOff+");\n");
               _out.append("#ifdef OVERSAMPLE_FACTOR\n");
               _out.append(_sDstVar+" = ((440.0f/32.0f)*expf( (("+_sDstVar+"-9.0f)/12.0f)*logf(2.0f) )) / (voice->sample_rate * OVERSAMPLE_FACTOR);\n");
               _out.append("#else\n");
               _out.append(_sDstVar+" = ((440.0f/32.0f)*expf( (("+_sDstVar+"-9.0f)/12.0f)*logf(2.0f) )) / voice->sample_rate;\n");
               _out.append("#endif\n");
               // _out.append("  printf(\"p2s out=%f\\n\", "+_sDstVar+");\n");
            }

            _script.freeTmpVar(sVarKbd);
            _script.freeTmpVar(sVarOff);
         }
         else
         {
            _out.append(_sDstVar+"  = (mathPowerf(2.0f, "+_sDstVar+" * "+FloatToString(fExp)+") - 1.0f);\n");
            _out.append(_sDstVar+" *= "+sScl+";\n");
         }

         parent_script.b_use_pow = true;
      }
      else
      {
         local String sVarExp <= _script.allocTmpVar(_out, "exp");
         inExp.emitFloat(_script, _out, sVarExp);

         if(b_plugin && inKbd.isConnected())
         {
            _out.append(_sDstVar+" *= (mathPowerf(2.0f, "+sVarExp+") - 1.0f);\n");
            // (todo) assumes that exp=7, need to scale if it is not
            sVarKbd <= _script.allocTmpVar(_out, "kbd");
            inKbd.emitFloat(_script, _out, sVarKbd);
            sVarOff <= _script.allocTmpVar(_out, "off");
            inOff.emitFloat(_script, _out, sVarOff);
            _out.append(_sDstVar+" += (voice->note_cur + ("+sVarOff+" * 12.0f) - 64.0f) * "+sVarKbd+";\n");

            _out.append("#ifdef OVERSAMPLE_FACTOR\n");
            _out.append(_sDstVar+" = ((440.0f/32.0f)*expf( (("+_sDstVar+"-9.0f)/12.0f)*logf(2.0f) )) / (voice->sample_rate * OVERSAMPLE_FACTOR);\n");
            _out.append("#else\n");
            _out.append(_sDstVar+" = ((440.0f/32.0f)*expf( (("+_sDstVar+"-9.0f)/12.0f)*logf(2.0f) )) / voice->sample_rate;\n");
            _out.append("#endif\n");

            _script.freeTmpVar(sVarKbd);
            _script.freeTmpVar(sVarOff);
         }
         else
         {
            // (todo) check if sExp is != 0 ?
            _out.append(_sDstVar+" = (mathPowerf(2.0f, "+_sDstVar+" * "+sVarExp+") - 1.0f);\n");
            _out.append(_sDstVar+" /= mathPowerf(2.0f, "+sVarExp+") - 1.0f;\n");
         }

         _script.freeTmpVar(sVarExp);

         parent_script.b_use_pow = true;
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleP2s<int> falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModulePow : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("exp",   2.0, 2.0, 3.0);
      addInput("base",  2.0, 0.0, 16.0);  // when not connected, use previous output

      addInputAlias("e", "exp");
      addInputAlias("b", "base");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inExp  <= findInputById("exp");
      local CyInput inBase <= findInputById("base");
      local boolean bBase = inBase.isConnected();
      if(!bBase && inExp.isConstVal())
      {
         float fExp = inExp.getConstVal();
         if(2.0f == fExp)
         {
            // (note) behaviour differs from generic case (pow(-2,2)=+4)
            _out.append(_sDstVar+" = "+_sDstVar+" * "+_sDstVar+";\n");
         }
         else if(3.0f == fExp)
         {
            // (note) behaviour differs from generic case (pow(-2,3)=+8)
            _out.append(_sDstVar+" = "+_sDstVar+" * "+_sDstVar+" * "+_sDstVar+";\n");
         }
         else
         {
            // generic case: -2^4=-16
            _out.append(_sDstVar+" = mathPowerf("+_sDstVar+", "+FloatToString(fExp)+");\n");
            parent_script.b_use_pow = true;
         }
      }
      else
      {
         local String *sVarBase;
         local String *sBase;
         if(bBase)
         {
            sVarBase <= _script.allocTmpVar(_out, "base");
            inBase.emitFloat(_script, _out, sVarBase);
            sBase <= sVarBase;
         }
         else
         {
            sBase <= _sDstVar;  // use previous output
         }

         if(!bBase || inExp.isConnected())
         {
            local String sVarExp <= _script.allocTmpVar(_out, "exp");
            inExp.emitFloat(_script, _out, sVarExp);
            _out.append(_sDstVar+" = mathPowerf("+sBase+", "+sVarExp+");\n");
            _script.freeTmpVar(sVarExp);
         }
         else
         {
            _out.append(_sDstVar+" = mathPowerf("+sBase+", "+_sDstVar+");\n");
         }
         if(bBase)
            _script.freeTmpVar(sVarBase);
         parent_script.b_use_pow = true;
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inExp  <= findInputById("exp");
      local CyInput inBase <= findInputById("base");
      local boolean bBase = inBase.isConnected();
      if(!bBase && inExp.isConstVal())
      {
         int iExp = (inExp.getConstVal()+ 0.5);
         if(2 == iExp)
         {
            if(b_export_c)
            {
               _out.append(_sDstVar+" = mulsw("+_sDstVar+", "+_sDstVar+") >> "+FX_SHR+";\n");
            }
            else
            {
               _out.append(_sDstVar+" = ("+_sDstVar+" * "+_sDstVar+") >> "+FX_SHR+";\n");
            }
         }
         else if(3 == iExp)
         {
            if(b_export_c)
            {
               _out.append("tmp_i = mulsw("+_sDstVar+", "+_sDstVar+") >> "+FX_SHR+";\n");
               _out.append(_sDstVar+" = mulsw("+_sDstVar+", tmp_i) >> "+FX_SHR+";\n");
            }
            else
            {
               _out.append("tmp_i = ("+_sDstVar+" * "+_sDstVar+") >> "+FX_SHR+";\n");
               _out.append(_sDstVar+" = ("+_sDstVar+" * tmp_i) >> "+FX_SHR+";\n");
            }
         }
         else
         {
            trace "[~~~] warning: CyModulePow<int> does not support arbitrary constant exponents, falling back to float..";
            emitFloatFallback(_script, _out, _sDstVar);
         }
      }
      else
      {
         trace "[~~~] warning: CyModulePow<int> does not support dynamic exponents or base, falling back to float..";
         emitFloatFallback(_script, _out, _sDstVar);
      }
   }
}


// <class.png>
class CyModulePul : CyModuleOscSync {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq",     1.0, 0.25, 4.0);
      addInput("phase",    0.0, 0.0,  1.0);
      addInput("width",    0.5, 0.0,  1.0);
      addInput("vsync",    1.0, 0.01, 4.0);
      addInput("cycle",    1.0, 0.0,  1.0);
      addInput("reset",    1.0, 0.0,  1.0);
      addInput("fixed",    0.0, 0.0,  1.0);
      addInput("window",   0.0, 0.0,  3.0);  // 0=off, 1=sine, 2=half-sine, 3=tri, 4=hse1_36, 5=hse2, 6=hse3, 7=hse5, 8=hse7
      addInput("phasemod", 0.0, 0.0,  1.0);  // post vsync
      addInput("pd",       0.0, 0.0,  1.0);  // phase distortion subtree. input is phase (0..1), output is new phase (0..1)

      addInputAlias("f",   "freq");
      addInputAlias("ph",  "phase");
      addInputAlias("w",   "width");
      addInputAlias("vs",  "vsync");
      addInputAlias("cy",  "cycle");
      addInputAlias("rs",  "reset");
      addInputAlias("fx",  "fixed");
      addInputAlias("win", "window");
      addInputAlias("pm",  "phasemod");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inWidth    <= findInputById("width");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inWindow   <= findInputById("window");
      local CyInput inPhaseMod <= findInputById("phasemod");
      local CyInput inPD       <= findInputById("pd");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);
      local boolean bWindow = inWindow.isConnected();
      local int windowType;
      if(inWindow.isConstVal())
      {
         windowType = int(inWindow.getConstVal() + 0.5f);
         bWindow = (windowType > 0);
      }
      else
         windowType = -1;

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarInitVoice(sInit, "pul_phase", fPhaseInit,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );

      local String *sVarPhaseWin;
      if(bWindow)
      {
         sVarPhaseWin <= _script.allocTmpVarInitVoice(sInit, "win_phase", 0.0f,
                                                      (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                      (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                      );
      }

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarInit(sInit, "pul_speed",
                                                 inFreq.getConstVal() * _script.note_speed_fixed,
                                                 false/*bCycleReset*/
                                                 );
         else
            sVarSpeed <= _script.allocTmpVarInit(sInit, "pul_speed",
                                                 inFreq.getConstVal() * _script.note_speed,
                                                 false/*bCycleReset*/
                                                 );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVar(sInit, "pul_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVar(_out, "pul_freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = voice->note_speed_fixed * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = voice->note_speed_cur * "+sVarFreq+";\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed_fixed)+" * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed)+" * "+sVarFreq+";\n");
         }
         _script.freeTmpVar(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVar(_out, "pul_tmp");
      local String *sVarWidth;
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVar(_out, "phase");
         inPhase.emitFloat(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + "+sVarTmpPhase+")");
      }
      sOut.append(");\n");  // end "pul_tmp = frac(..)"  (phase)

      local String *sVSync;
      if(inVSync.isConstVal())
      {
         local float fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
            sVSync <= FloatToString(fVSync);
      }
      else
      {
         sVarVSync <= _script.allocTmpVar(_out, "vsync");
         sVSync <= sVarVSync;
         inVSync.emitFloat(_script, _out, sVarVSync);
      }
      if((null != sVSync) && !bWindow)
         sOut.append(sTmp+" = "+sTmp+" * "+sVSync+";\n");

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVar(sOut, "phasemod");
         inPhaseMod.emitFloat(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += "+sVarTmpPhaseMod+";\n");
      }

      sOut.append(sTmp+" = ffrac_s("+sTmp+");\n");

      if(inPD.isConnected())
      {
         inPD.emitFloat(_script, sOut, sTmp);
      }

      if(inWidth.isConstVal())
      {
         sOut.append(_sDstVar+" = ("+sTmp+" >= "+inWidth.getConstVal()+") ? 1.0f : -1.0f;\n");
      }
      else
      {
         sVarWidth <= _script.allocTmpVar(_out, "width");
         inWidth.emitFloat(_script, _out, sVarWidth);
         sOut.append(_sDstVar+" = ("+sTmp+" >= "+sVarWidth+") ? 1.0f : -1.0f;\n");
      }

      if(bWindow)
      {
         emitSyncWindow(_script, inWindow, windowType, sOut, sVarPhaseWin, _sDstVar);
      }

      if(!bSpeed0)
      {
         if(bWindow && (null != sVSync))
         {
            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+" * "+sVSync+");\n");
            sOut.append("tmp_f = "+sVarPhaseWin+";\n");
            sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");
            sOut.append("if(tmp_f > "+sVarPhaseWin+") "+sVarPhase+" = "+sVarPhaseWin+" * "+sVSync+"; \n");
         }
         else
         {
            if(bWindow)
               sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");

            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+");\n");
         }
      }

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVar(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVar(sVarTmpPhase);

      if(null != sVarWidth)
         _script.freeTmpVar(sVarWidth);

      if(null != sVarVSync)
         _script.freeTmpVar(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVar(sVarTmpPhaseMod);

      _script.freeTmpVar(sTmp);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inWidth    <= findInputById("width");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inPhaseMod <= findInputById("phasemod");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarIntInitVoice(sInit, "pul_phase",
                                                                fPhaseInit*16384,
                                                                (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                                (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                                );

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin || inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "pul_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed_fixed),
                                                    false/*bCycleReset*/
                                                    );
         else
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "pul_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed),
                                                    false/*bCycleReset*/
                                                    );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVarInt(sInit, "pul_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVarInt(_out, "pul_freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_fixed * 16384), "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_cur * 16384), "+sVarFreq+");\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed_fixed * 16384)+", "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed * 16384)+", "+sVarFreq+");\n");
         }
         _script.freeTmpVarInt(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVarInt(_out, "pul_tmp");
      local String *sVarTmpPhase;
      local String *sVarWidth;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVarInt(_out, "phase");
         inPhase.emitInt(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + ("+sVarTmpPhase+" << 3))");  // *8 to scale from FX_ONE (2048) to 16384
      }
      sOut.append(");\n");

      float fVSync = 1.0;
      if(inVSync.isConstVal())
      {
         fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
         {
            if(b_export_c)
               sOut.append(sTmp+" = mulsw("+sTmp+", "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
            else
               sOut.append(sTmp+" = ("+sTmp+" * "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
         }
      }
      else
      {
         fVSync = -1.0f;
         sVarVSync <= _script.allocTmpVarInt(_out, "vsync");
         inVSync.emitInt(_script, _out, sVarVSync);
         if(b_export_c)
            sOut.append(sTmp+" = mulsw("+sTmp+", "+sVarVSync+") >> "+FX_SHR+";\n");
         else
            sOut.append(sTmp+" = ("+sTmp+" * "+sVarVSync+") >> "+FX_SHR+";\n");
      }

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVarInt(sOut, "phasemod");
         inPhaseMod.emitInt(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += ("+sVarTmpPhaseMod+" << 3);\n");  // *8 to scale from FX_ONE (2048) to 16384
      }

      sOut.append(sTmp+" = "+sTmp+" & 0x3FFF;\n");  // frac()

      if(inWidth.isConstVal())
      {
         sOut.append(_sDstVar+" = ("+sTmp+" >= "+int(inWidth.getConstVal()*16384)+") ? "+int(FX_ONE)+" : "+int(-FX_ONE)+";\n");
      }
      else
      {
         sVarWidth <= _script.allocTmpVarInt(_out, "width");
         inWidth.emitInt(_script, _out, sVarWidth);
         sOut.append(sTmp+" = ("+sTmp+" >> (14 - "+FX_SHR+"));\n");
         sOut.append(_sDstVar+" = ("+sTmp+" >= "+sVarWidth+") ? "+int(FX_ONE)+" : "+int(-FX_ONE)+";\n");
      }

      if(!bSpeed0)
      {
         sOut.append(sVarPhase+" = ("+sVarPhase+" + "+sVarSpeed+") & 0x3FFF;\n");
      }

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVarInt(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVarInt(sVarTmpPhase);

      if(null != sVarWidth)
         _script.freeTmpVarInt(sVarWidth);

      if(null != sVarVSync)
         _script.freeTmpVarInt(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVar(sVarTmpPhaseMod);

      _script.freeTmpVarInt(sTmp);
   }

}


// <class.png>
class CyModuleQua : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("num", 32.0, 1.0, 1024.0);

      addInputAlias("n", "num");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inNum <= findInputById("num");

      local String *sNum;
      if(inNum.isConstVal())
      {
         float fNum = inNum.getConstVal();
         if(fNum > 0.0f)
         {
            if(1.0f == fNum)
            {
               _out.append(_sDstVar+" = (int)"+_sDstVar+";\n");
            }
            else
            {
               sNum <= FloatToString(fNum);
               _out.append(_sDstVar+" = ((int)("+_sDstVar+" * "+sNum+") / "+sNum+");\n");
            }
         }
         else
         {
            _out.append(_sDstVar+" = 0.0f; /* fNum="+fNum+" */\n");
         }
      }
      else
      {
         sNum <= _script.allocTmpVar(_out, "num");
         inNum.emitFloat(_script, _out, sNum);
         _out.append(_sDstVar+" = ("+sNum+" > 0.0f) ? ((int)("+_sDstVar+" * "+sNum+") / "+sNum+") : 0.0f;\n");
         _script.freeTmpVar(sNum);
      }

   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inNum <= findInputById("num");

      if(inNum.isConstVal())
      {
         float fNum = inNum.getConstVal();
         int iLog = log(fNum) / log(2);
         if((1 << iLog) == fNum)
         {
            int iShift = FX_SHR - iLog;
            _out.append(_sDstVar+" = ("+_sDstVar+" >> "+iShift+") << "+iShift+";\n");
            return;
         }
      }

      trace "[~~~] warning: CyModuleQua<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleRcp : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      _out.append("if(0.0f != "+_sDstVar+")\n");
      _out.append("   "+_sDstVar+" = 1.0f / "+_sDstVar+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // // trace "[~~~] warning: CyModuleRcp<int>: falling back to float..";
      // // emitFloatFallback(_script, _out, _sDstVar);

      if(0)
      {
         _out.append("if(0 != "+_sDstVar+")\n");
         _out.append("   "+_sDstVar+" = "+int(FX_ONE<<3)+" / ("+_sDstVar+" >> 8);\n");
      }
      else
      {
         // based on fixedpoint_div.tks (research)
         local String sVarN   <= _script.allocTmpVarInt32(_out, "rcp_n");
         local String sVarD   <= _script.allocTmpVarInt32(_out, "rcp_d");
         local String sVarFi  <= _script.allocTmpVarInt32(_out, "rcp_fi");
         local String sVarSgn <= _script.allocTmpVarInt32(_out, "rcp_sgn");

         _out.append(sVarN+" = "+int(FX_ONE)+";\n");

         _out.append("if("+_sDstVar+" & 0x8000)\n");
         _out.append("{\n");
         _out.append("   "+sVarSgn+" = 1;\n");
         _out.append("   "+sVarD+" = -"+_sDstVar+";\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         _out.append("   "+sVarSgn+" = 0;\n");
         _out.append("   "+sVarD+" = "+_sDstVar+";\n");
         _out.append("}\n");

         _out.append("while("+sVarD+" > "+int(FX_ONE)+")\n");
         _out.append("{\n");
         _out.append("   "+sVarN+" = "+sVarN+" >> 1;\n");
         _out.append("   "+sVarD+" = "+sVarD+" >> 1;\n");
         _out.append("}\n");

         int NUM_ITER = 2;
         loop(NUM_ITER)
         {
            _out.append(sVarFi+" = "+int(FX_ONE << 1)+" - "+sVarD+";\n");
            _out.append(sVarN+" = ((int)("+sVarN+" * "+sVarFi+")) >> "+FX_SHR+";\n");
            _out.append(sVarD+" = ((int)("+sVarD+" * "+sVarFi+")) >> "+FX_SHR+";\n");
         }

         if(b_export_c)
            _out.append(_sDstVar+" = (short)("+sVarSgn+" ? -"+sVarN+" : "+sVarN+");\n");
         else
            _out.append(_sDstVar+" = "+sVarSgn+" ? -"+sVarN+" : "+sVarN+";\n");

         _script.freeTmpVarInt32(sVarN);
         _script.freeTmpVarInt32(sVarD);
         _script.freeTmpVarInt32(sVarFi);
         _script.freeTmpVarInt32(sVarSgn);
      }
   }
}


// <class.png>
class CyModuleRdl : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         _out.append(_sDstVar+" = inL;\n");
         _script.b_stereo = true;
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         _out.append(_sDstVar+" = inL * "+FX_ONE+";\n");
         _script.b_stereo = true;
      }
   }
}


// <class.png>
class CyModuleRdr : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         _out.append(_sDstVar+" = inR;\n");
         _script.b_stereo = true;
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         _out.append(_sDstVar+" = inR * "+FX_ONE+";\n");
         _script.b_stereo = true;
      }
   }
}


// <class.png>
class CyModuleWrl : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("value", 0.0, -16, 16.0);
      addInput("amp",   0.0, -1, 1);

      addInputAlias("v", "value");
      addInputAlias("a", "amp");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local CyInput inValue <= findInputById("value");
         local CyInput inAmp   <= findInputById("amp");

         local String *sVarAmp;
         if(inAmp.isConnected())
         {
            sVarAmp <= _script.allocTmpVar(_out, "wrl_amp");
            inAmp.emitFloat(_script, _out, sVarAmp);
         }

         if(inValue.isConnected())
         {
            local String sVarValue <= _script.allocTmpVar(_out, "wrl_value");
            inValue.emitFloat(_script, _out, sVarValue);

            if(null != sVarAmp)
               _out.append("outL = "+sVarValue+" * "+sVarAmp+";\n");
            else
               _out.append("outL = "+sVarValue+";\n");

            _script.freeTmpVar(sVarValue);
         }
         else
         {
            if(null != sVarAmp)
               _out.append("outL = "+_sDstVar+" * "+sVarAmp+";\n");
            else
               _out.append("outL = "+_sDstVar+";\n");
         }

         if(null != sVarAmp)
            _script.freeTmpVar(sVarAmp);

         _script.b_stereo = true;
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local CyInput inValue <= findInputById("value");
         local CyInput inAmp   <= findInputById("amp");

         local String *sVarAmp;
         if(inAmp.isConnected())
         {
            sVarAmp <= _script.allocTmpVarInt(_out, "wrl_amp");
            inAmp.emitInt(_script, _out, sVarAmp);
         }

         if(inValue.isConnected())
         {
            local String sVarValue <= _script.allocTmpVar(_out, "wrr_value");
            inValue.emitInt(_script, _out, sVarValue);

            if(null != sVarAmp)
               _out.append("outL = "+sVarValue+" * "+sVarAmp+" * "+FloatToString(1.0f / FX_ONE)+";\n");
            else
               _out.append("outL = "+sVarValue+" * "+FloatToString(1.0f / FX_ONE)+";\n");

            _script.freeTmpVar(sVarValue);
         }
         else
         {
            if(null != sVarAmp)
               _out.append("outL = ("+_sDstVar+" * "+sVarAmp+" * "+FloatToString(1.0f / FX_ONE)+");\n");
            else
               _out.append("outL = ("+_sDstVar+" * "+FloatToString(1.0f / FX_ONE)+");\n");
         }

         if(null != sVarAmp)
            _script.freeTmpVarInt(sVarAmp);

         _script.b_stereo = true;
      }
   }
}


// <class.png>
class CyModuleWrp : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("ceil", 1.0,  0.0, 2.0);  // => min=-ceil, max=+ceil
      addInput("min",  0.0, -2.0, 2.0);
      addInput("max",  0.0, -2.0, 2.0);
      addInput("hq",   1.0,  0.0, 1.0);  // const (>=0.5: use mathWrapf())

      addInputAlias("c", "ceil");
      addInputAlias("m", "min");
      addInputAlias("x", "max");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inCeil <= findInputById("ceil");
      local CyInput inMin  <= findInputById("min");
      local CyInput inMax  <= findInputById("max");
      local CyInput inHQ   <= findInputById("hq");

      local boolean bHQ = (inHQ.getConstVal() >= 0.5f);

      local String *sMin;
      local String *sMax;

      if(inMin.isConnected() || inMax.isConnected() ||
         (inMin.isConstVal() && !inMin.isConst0()) ||
         (inMax.isConstVal() && !inMax.isConst0())
         )
      {
         if(inMin.isConstVal() && inMax.isConstVal())
         {
            float fMin = inMin.getConstVal();
            float fMax = inMax.getConstVal();
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathWrapf("+_sDstVar+", "+FloatToString(fMin)+", "+FloatToString(fMax)+");\n");
               parent_script.b_use_wrapf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+FloatToString(fMax)+") "+_sDstVar+" = "+_sDstVar+" - "+FloatToString(fMax - fMin)+";\n");
               _out.append("else if("+_sDstVar+" < "+FloatToString(fMin)+") "+_sDstVar+" = "+_sDstVar+" + "+FloatToString(fMax - fMin)+";\n");
            }
         }
         else
         {
            sMin <= _script.allocTmpVar(_out, "wrp_min");
            sMax <= _script.allocTmpVar(_out, "wrp_max");
            inMin.emitFloat(_script, _out, sMin);
            inMax.emitFloat(_script, _out, sMax);
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathWrapf("+_sDstVar+", "+sMin+", "+sMax+");\n");
               parent_script.b_use_wrapf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+sMax+") "+_sDstVar+" = "+_sDstVar+" - ("+sMax+" - "+sMin+");\n");
               _out.append("else if("+_sDstVar+" < "+sMin+") "+_sDstVar+" = "+_sDstVar+" + ("+sMax+" - "+sMin+");\n");
            }
            _script.freeTmpVar(sMin);
            _script.freeTmpVar(sMax);
         }
      }
      else
      {
         if(inCeil.isConstVal())
         {
            float fCeil = inCeil.getConstVal();
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathWrapf("+_sDstVar+", "+FloatToString(-fCeil)+", "+FloatToString(fCeil)+");\n");
               parent_script.b_use_wrapf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+FloatToString(fCeil)+") "+_sDstVar+" = "+_sDstVar+" - "+FloatToString(2.0f*fCeil)+";\n");
               _out.append("else if("+_sDstVar+" < -("+FloatToString(fCeil)+")) "+_sDstVar+" = "+_sDstVar+" + "+FloatToString(2.0f*fCeil)+";\n");
            }
         }
         else
         {
            local String sCeil <= _script.allocTmpVar(_out, "ceil");
            inCeil.emitFloat(_script, _out, sCeil);
            if(bHQ)
            {
               _out.append(_sDstVar+" = mathWrapf("+_sDstVar+", -"+sCeil+", "+sCeil+");\n");
               parent_script.b_use_wrapf = true;
            }
            else
            {
               _out.append("if("+_sDstVar+" > "+sCeil+") "+_sDstVar+" = "+_sDstVar+" - (2.0f * "+sCeil+");\n");
               _out.append("else if("+_sDstVar+" < -("+sCeil+")) "+_sDstVar+" = "+_sDstVar+" + (2.0f * "+sCeil+");\n");
            }
            _script.freeTmpVar(sCeil);
         }
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inCeil <= findInputById("ceil");
      local CyInput inMin  <= findInputById("min");
      local CyInput inMax  <= findInputById("max");
      local CyInput inHQ   <= findInputById("hq");

      local boolean bHQ = (inHQ.getConstVal() >= 0.5f);

      local String *sMin;
      local String *sMax;

      if(bHQ)
      {
         trace "[~~~] warning: CyModuleWrp<int,HQ>: falling back to float..";
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      if(inMin.isConnected() || inMax.isConnected() ||
         (inMin.isConstVal() && !inMin.isConst0()) ||
         (inMax.isConstVal() && !inMax.isConst0())
         )
      {
         if(inMin.isConstVal() && inMax.isConstVal())
         {
            float iMin = inMin.getConstVal() * FX_ONE;
            float iMax = inMax.getConstVal() * FX_ONE;

            _out.append("if("+_sDstVar+" > "+iMax+") "+_sDstVar+" = "+_sDstVar+" - "+(iMax - iMin)+";\n");
            _out.append("else if("+_sDstVar+" < "+iMin+") "+_sDstVar+" = "+_sDstVar+" + "+(iMax - iMin)+";\n");
         }
         else
         {
            sMin <= _script.allocTmpVarInt(_out, "wrp_min");
            sMax <= _script.allocTmpVarInt(_out, "wrp_max");
            inMin.emitInt(_script, _out, sMin);
            inMax.emitInt(_script, _out, sMax);
            _out.append("if("+_sDstVar+" > "+sMax+") "+_sDstVar+" = "+_sDstVar+" - ("+sMax+" - "+sMin+");\n");
            _out.append("else if("+_sDstVar+" < "+sMin+") "+_sDstVar+" = "+_sDstVar+" + ("+sMax+" - "+sMin+");\n");
            _script.freeTmpVarInt(sMin);
            _script.freeTmpVarInt(sMax);
         }
      }
      else
      {
         if(inCeil.isConstVal())
         {
            int iCeil = inCeil.getConstVal() * FX_ONE;
            _out.append("if("+_sDstVar+" > "+iCeil+") "+_sDstVar+" = "+_sDstVar+" - "+(2*iCeil)+";\n");
            _out.append("else if("+_sDstVar+" < -("+iCeil+")) "+_sDstVar+" = "+_sDstVar+" + "+(2*-iCeil)+";\n");
         }
         else
         {
            local String sVarCeil <= _script.allocTmpVarInt(_out, "ceil");
            inCeil.emitInt(_script, _out, sVarCeil);

            _out.append("if("+_sDstVar+" > "+sVarCeil+") "+_sDstVar+" = "+_sDstVar+" - (2 * "+sVarCeil+");\n");
            _out.append("else if("+_sDstVar+" < -("+sVarCeil+")) "+_sDstVar+" = "+_sDstVar+" + (2 * "+sVarCeil+");\n");

            _script.freeTmpVarInt(sVarCeil);
         }
      }
   }
}


// <class.png>
class CyModuleWrr : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("value", 0.0, -16, 16.0);
      addInput("amp",   0.0, -1, 1);

      addInputAlias("v", "value");
      addInputAlias("a", "amp");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local CyInput inValue <= findInputById("value");
         local CyInput inAmp   <= findInputById("amp");

         local String *sVarAmp;
         if(inAmp.isConnected())
         {
            sVarAmp <= _script.allocTmpVar(_out, "wrr_amp");
            inAmp.emitFloat(_script, _out, sVarAmp);
         }

         if(inValue.isConnected())
         {
            local String sVarValue <= _script.allocTmpVar(_out, "wrr_value");
            inValue.emitFloat(_script, _out, sVarValue);

            if(null != sVarAmp)
               _out.append("outR = "+sVarValue+" * "+sVarAmp+";\n");
            else
               _out.append("outR = "+sVarValue+";\n");

            _script.freeTmpVar(sVarValue);
         }
         else
         {
            if(null != sVarAmp)
               _out.append("outR = "+_sDstVar+" * "+sVarAmp+";\n");
            else
               _out.append("outR = "+_sDstVar+";\n");
         }

         if(null != sVarAmp)
            _script.freeTmpVar(sVarAmp);

         _script.b_stereo = true;
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local CyInput inValue <= findInputById("value");
         local CyInput inAmp   <= findInputById("amp");

         local String *sVarAmp;
         if(inAmp.isConnected())
         {
            sVarAmp <= _script.allocTmpVarInt(_out, "wrr_amp");
            inAmp.emitInt(_script, _out, sVarAmp);
         }

         if(inValue.isConnected())
         {
            local String sVarValue <= _script.allocTmpVar(_out, "wrr_value");
            inValue.emitInt(_script, _out, sVarValue);

            if(null != sVarAmp)
               _out.append("outR = "+sVarValue+" * "+sVarAmp+" * "+FloatToString(1.0f / FX_ONE)+";\n");
            else
               _out.append("outR = "+sVarValue+" * "+FloatToString(1.0f / FX_ONE)+";\n");

            _script.freeTmpVar(sVarValue);
         }
         else
         {
            if(null != sVarAmp)
               _out.append("outR = ("+_sDstVar+" * "+sVarAmp+" * "+FloatToString(1.0f / FX_ONE)+");\n");
            else
               _out.append("outR = ("+_sDstVar+" * "+FloatToString(1.0f / FX_ONE)+");\n");
         }

         if(null != sVarAmp)
            _script.freeTmpVarInt(sVarAmp);

         _script.b_stereo = true;
      }
   }
}


// <class.png>
class CyModuleRep : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("num",    1.0,   0.0,  1023.0);

      addInputAlias("n", "num");
   }

   // <method_get.png>
   public virtual doEmitRight() : boolean {
      // skip seq_right in emitFloatTree() / emitIntTree()
      return false;
   }

   // <method_get.png>
   public virtual validate() : boolean {
      local CyInput inNum <= findInputById("num");
      if(!inNum.isConstVal())
      {
         trace "[---] CyModuleRep: \"num\" must be constant";
         return false;
      }
      return true;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inNum <= findInputById("num");
      float fNum = inNum.getConstVal();
      int iNum = mathClampi(fNum+0.5, 0, 1023);
      // trace "xxx CyModuleRep: sDstVar="+_sDstVar;
      loop(iNum)
      {
         seq_right.emitFloatSequence(_script, _out, _sDstVar);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inNum <= findInputById("num");
      float fNum = inNum.getConstVal();
      int iNum = mathClampi(fNum+0.5, 0, 1023);
      loop(iNum)
      {
         seq_right.emitIntSequence(_script, _out, _sDstVar);
      }
   }
}


// <class.png>
class CyModuleLog : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("base", 0.0, 0.0,  1023.0);

      addInputAlias("b", "base");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inBase <= findInputById("base");
      local String sLog <= "mathLogf";
      parent_script.b_use_log = true;
      if(inBase.isConstVal())
      {
         float fBase = inBase.getConstVal();
         if(fBase > 0.0f)
            _out.append(_sDstVar+" = "+sLog+"("+_sDstVar+") / "+sLog+"("+FloatToString(fBase)+");\n");
         else
            _out.append(_sDstVar+" = "+sLog+"("+_sDstVar+");\n");
      }
      else
      {
         local String sVarBase <= _script.allocTmpVar(_out, "base");
         inBase.emitFloat(_script, _out, sVarBase);

         if(b_export_c)
            _out.append(_sDstVar+" = "+sLog+"("+_sDstVar+") / "+sLog+"("+sVarBase+");\n");
         else
            _out.append(_sDstVar+" = "+sLog+"("+_sDstVar+") / "+sLog+"("+sVarBase+");\n");

         _script.freeTmpVar(sVarBase);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleLle : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("c", 0.0, -10.0, 10.0);
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inC <= findInputById("c");
      if(inC.isConstVal())
      {
         float fC = inC.getConstVal();
         _out.append(_sDstVar+" = mathLogLinExpf("+_sDstVar+", "+FloatToString(fC)+");\n");
      }
      else
      {
         local String sVarC <= _script.allocTmpVar(_out, "c");
         inC.emitFloat(_script, _out, sVarC);
         _out.append(_sDstVar+" = mathLogLinExpf("+_sDstVar+", "+sVarC+");\n");
         _script.freeTmpVar(sVarC);
      }
      parent_script.b_use_lle = true;
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleLop : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("num",    1.0,   0.0,  1023.0);

      addInputAlias("n", "num");
   }

   // <method_get.png>
   public virtual doEmitRight() : boolean {
      // skip seq_right in emitFloatTree() / emitIntTree()
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local String *sNum;
      local String *sVarNum;
      local CyInput inNum <= findInputById("num");
      if(inNum.isConstVal())
      {
         float fNum = inNum.getConstVal();
         sNum <= String(int(fNum+0.5));
      }
      else
      {
         sVarNum <= _script.allocTmpVar(_out, "num");
         inNum.emitFloat(_script, _out, sVarNum);
         sNum <= sVarNum;
      }

      local String sVarI <= _script.allocTmpVarInt(_out, "i");
      _out.append("for("+sVarI+" = 0; "+sVarI+" < (((int)"+sNum+")&1023); "+sVarI+"++)\n");  // limit max number of iterations to 1023
      _out.append("{\n");
      seq_right.emitFloatSequence(_script, _out, _sDstVar);
      _out.append("}\n");
      _script.freeTmpVarInt(sVarI);

      if(null != sVarNum)
         _script.freeTmpVar(sVarNum);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local String *sNum;
      local String *sVarNum;
      local CyInput inNum <= findInputById("num");
      if(inNum.isConstVal())
      {
         float fNum = inNum.getConstVal();
         sNum <= String(int(fNum+0.5));
      }
      else
      {
         // (todo) should be allocTmpVarInt() followed by fixedpoint=>int conversion
         sVarNum <= _script.allocTmpVar(_out, "num");
         inNum.emitFloat(_script, _out, sVarNum);
         sNum <= sVarNum;
      }

      local String sVarI <= _script.allocTmpVarInt(_out, "i");
      _out.append("for("+sVarI+" = 0; "+sVarI+" < (((int)"+sNum+")&1023); "+sVarI+"++)\n");  // limit max number of iterations to 1023
      _out.append("{\n");
      seq_right.emitIntSequence(_script, _out, _sDstVar);
      _out.append("}\n");
      _script.freeTmpVarInt(sVarI);
   }
}


// <class.png>
class CyModuleEdge : CyModule {
   define int MODE_RISE = 0;
   define int MODE_FALL = 1;
   int mode;

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method_get.png>
   public virtual doEmitRight() : boolean {
      // skip seq_right in emitFloatTree() / emitIntTree()
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local String sInit;
      local String sVarLastIn <= _script.allocTmpVarInitVoice(sInit, (MODE_RISE == mode) ? "red_last" : "fed_last", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      if(MODE_RISE == mode)
         _out.append("if("+sVarLastIn+" <= 0.0f && "+_sDstVar+" > 0.0f)\n");
      else
         _out.append("if("+sVarLastIn+" > 0.0f && "+_sDstVar+" <= 0.0f)\n");
      _out.append("{\n");
      if(null != seq_right)
      {
         local String sIndent;
         local String sVarTmp <= _script.allocTmpVar(sIndent, (MODE_RISE == mode) ? "onrise" : "onfall");
         seq_right.emitFloatSequence(_script, sIndent, sVarTmp);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _script.freeTmpVar(sVarTmp);
      }
      _out.append("   "+sVarLastIn+" = "+_sDstVar+";\n");
      _out.append("   "+_sDstVar+" = 1.0f;\n");
      _out.append("}\n");
      _out.append("else\n");
      _out.append("{\n");
      _out.append("   "+sVarLastIn+" = "+_sDstVar+";\n");
      _out.append("   "+_sDstVar+" = 0.0f;\n");
      _out.append("}\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local String sInit;
      local String sVarLastIn <= _script.allocTmpVarIntInitVoice(sInit, (MODE_RISE == mode) ? "red_last" : "fed_last", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      if(MODE_RISE == mode)
         _out.append("if("+sVarLastIn+" <= 0 && "+_sDstVar+" > 0)\n");
      else
         _out.append("if("+sVarLastIn+" > 0 && "+_sDstVar+" <= 0)\n");
      _out.append("{\n");
      if(null != seq_right)
      {
         local String sIndent;
         local String sVarTmp <= _script.allocTmpVarInt(sIndent, (MODE_RISE == mode) ? "onrise" : "onfall");
         seq_right.emitIntSequence(_script, sIndent, sVarTmp);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _script.freeTmpVarInt(sVarTmp);
      }
      _out.append("   "+sVarLastIn+" = "+_sDstVar+";\n");
      _out.append("   "+_sDstVar+" = "+FX_ONE+";\n");
      _out.append("}\n");
      _out.append("else\n");
      _out.append("{\n");
      _out.append("   "+sVarLastIn+" = "+_sDstVar+";\n");
      _out.append("   "+_sDstVar+" = 0;\n");
      _out.append("}\n");
   }

}


// <class.png>
class CyModuleFix : CyModule {
   // replace NaN/inf by 0

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_export_c)
      {
         _out.append("{\n");
         _out.append("   union {\n");
         _out.append("      unsigned int u;\n");
         _out.append("      float        f;\n");
         _out.append("   } fi;\n");
         _out.append("   fi.f = "+_sDstVar+";\n");
         _out.append("   if(0x7F800000u == (fi.u & 0x7F800000u))\n");  // NaN or inf ? (exp bits all 1)
         _out.append("     "+_sDstVar+" = 0.0f;\n");
         _out.append("}\n");
      }
   }
}


// <class.png>
class CyModuleRev : CyModule {
   // **reserved**

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      // addInput("freq",  1.0, 0.25, 4.0);
      // addInput("phase", 0.0, 0.0,  1.0);
      // addInput("width", 0.0, 0.0,  1.0);
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleRev::emitFloat: **STUB**";
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] CyModuleRev::emitInt: **STUB**";
   }
}


// <class.png>
class CyModuleRmp : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("millisec", 200.0, 0.0,  4000.0);
      addInput("start",    1.0,   0.0,  1.0);
      addInput("end",      0.0,   0.0,  1.0);
      addInput("cycle",    1,     0,    1);

      addInputAlias("ms", "millisec");
      addInputAlias("s",  "start");
      addInputAlias("e",  "end");
      addInputAlias("cy", "cycle");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local String sInit;
      local CyInput inMillisec <= findInputById("millisec");
      local CyInput inStart    <= findInputById("start");
      local CyInput inEnd      <= findInputById("end");
      local CyInput inCycle    <= findInputById("cycle");

      float fMillisec = inMillisec.getConstVal();
      float fStart    = inStart.getConstVal();
      float fEnd      = inEnd.getConstVal();

      boolean bCycleReset = (inCycle.getConstVal() >= 0.5f);
      local String sCur <= _script.allocTmpVarInit(sInit, "rmp_cur", fStart, bCycleReset);

      sInit.append("// start="+fStart+" end="+fEnd+" #frames="+(_script.millisecToFrames(fMillisec, bCycleReset))+":\n");
      local String sStep <= _script.allocTmpVarInit(sInit, "rmp_step", ((fEnd - fStart) / _script.millisecToFrames(fMillisec, bCycleReset)), false/*bCycleReset*/);

      _script.appendInit(sInit);

      _out.append(_sDstVar+" = "+sCur+";\n");
      if(fStart > fEnd)
      {
         _out.append(sCur+" = mathMaxf("+sCur+"+"+sStep+", "+fEnd+");\n");
         // _out.append("trace "+sCur+";\n");
      }
      else
      {
         _out.append(sCur+" = mathMinf("+sCur+"+"+sStep+", "+fEnd+");\n");
      }

   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local String sInit;
      local CyInput inMillisec <= findInputById("millisec");
      local CyInput inStart    <= findInputById("start");
      local CyInput inEnd      <= findInputById("end");
      local CyInput inCycle    <= findInputById("cycle");

      float fMillisec = inMillisec.getConstVal();
      float fStart    = inStart.getConstVal();
      float fEnd      = inEnd.getConstVal();

      // (note) 18bit precision  (increase??)

      boolean bCycleReset = (inCycle.getConstVal() >= 0.5f);
      local String sCur <= _script.allocTmpVarInt32Init(sInit, "rmp_cur", (fStart * (128*2048)), bCycleReset, true/*bVoiceReset*/);

      sInit.append("// start="+fStart+" end="+fEnd+" #frames="+(_script.millisecToFrames(fMillisec, bCycleReset))+":\n");
      local String sStep <= _script.allocTmpVarIntInit(sInit, "rmp_step", ((fEnd - fStart) / _script.millisecToFrames(fMillisec, bCycleReset))*(128*2048), false/*bCycleReset*/);

      _script.appendInit(sInit);

      _out.append(_sDstVar+" = ("+sCur+" >> (18-"+FX_SHR+"));\n");
      _out.append(sCur+" += "+sStep+";\n");
      if(fStart > fEnd)
      {
         _out.append("if("+sCur+" < "+int(fEnd*(128*2048))+") "+sCur+" = "+int(fEnd*(128*2048))+";\n");
         // _out.append("trace "+sCur+";\n");
      }
      else
      {
         _out.append("if("+sCur+" > "+int(fEnd*(128*2048))+") "+sCur+" = "+int(fEnd*(128*2048))+";\n");
      }

   }
}


// <class.png>
class CyModuleRms : CyModule {
   define int MAX_HISTORY_SIZE = 4096;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("size",     16, 0,    MAX_HISTORY_SIZE);  // history size [const]
      addInput("win",      0,  0,    1);                 // window type (0/1) [const]
      addInput("exp",      0,  0,    8);                 // window exponent [const]

      addInputAlias("s",  "size");
      addInputAlias("w",  "win");
      addInputAlias("e",  "exp");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSize   <= findInputById("size");
      local CyInput inWin    <= findInputById("win");
      local CyInput inWinExp <= findInputById("exp");

      local boolean bWin = (inWin.getConstVal() >= 0.5f);
      local float fWinExp = inWinExp.getConstVal();

      local String sInit;
      local String sVarWriteIdx <= _script.allocTmpVarInt32Init(sInit, "rms_write_idx", 0,
                                                                true/*bCycleReset*/,
                                                                true/*bVoiceReset*/
                                                                );
      local String sVarSum <= _script.allocTmpVarInitVoice(sInit, "rms_sum", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);

      local int sz = mathClampi(inSize.getConstVal(), 1, MAX_HISTORY_SIZE);
      local String sVarArray <= _script.addArrayVar("rms_history", sz, false/*bInt*/);

      local String *sVarWinTbl;
      if(bWin)
      {
         sVarWinTbl <= _script.addArrayVar("rms_win", sz, false/*bInt*/);
         local String sVarI <= _script.allocTmpVarInt32Init(sInit, "rms_init_i", 0,
                                                            false/*bCycleReset*/,
                                                            false/*bVoiceReset*/
                                                            );
         local String sVarWeight <= _script.allocTmpVarInit(sInit, "rms_init_weight", 0.0f, false/*bCycleReset*/);
         local String sVarWeightSum <= _script.allocTmpVarInit(sInit, "rms_init_sum", 0.0f, false/*bCycleReset*/);
         sInit.append(sVarWeightSum+" = 0.0f;\n");
         sInit.append("for("+sVarI+" = 0; "+sVarI+" < "+sz+"; "+sVarI+"++)\n");
         sInit.append("{\n");
         sInit.append("   "+sVarWeight+" = "+(b_export_c?"sinf":"sin")+"("+sVarI+" * "+FloatToString(3.14159265359f / sz)+");\n");
         if(fWinExp > 0.0f)
         {
            sInit.append("   "+sVarWeight+" = "+(b_export_c?"powf":"pow")+"("+sVarWeight+", "+fWinExp+");\n");
            // sInit.append("   "+sVarWeight+" = 1.0f - powf(1.0f - "+sVarWeight+", "+fWinExp+");\n");
         }
         // sInit.append("   trace \"xxx rms weight[\"+"+sVarI+"+\"]=\"+"+sVarWeight+";\n");
         sInit.append("   "+sVarWeightSum+" += "+sVarWeight+";\n");
         sInit.append("   "+sVarWinTbl+"["+sVarI+"] = "+sVarWeight+";\n");
         sInit.append("}\n");
         // Normalize weights
         sInit.append("for("+sVarI+" = 0; "+sVarI+" < "+sz+"; "+sVarI+"++)\n");
         sInit.append("{\n");
         sInit.append("   "+sVarWinTbl+"["+sVarI+"] = "+sVarWinTbl+"["+sVarI+"] / "+sVarWeightSum+";\n");
         sInit.append("}\n");
      }

      _script.appendInit(sInit);

      // Square input value
      _out.append(_sDstVar+" = "+_sDstVar+" * "+_sDstVar+";\n");

      if(bWin)
      {
         // Store next value in ring buffer
         _out.append(sVarArray+"["+sVarWriteIdx+"] = "+_sDstVar+";\n");

         // Calc weighted sum
         local String sVarIdxPrev <= _script.allocTmpVarInt32(_out, "rms_idx_prev");
         _out.append(sVarIdxPrev+" = "+sVarWriteIdx+" - "+(sz - 1)+";\n");
         _out.append(sVarSum+" = 0.0f;\n");
         _out.append("for("+sVarI+" = 0; "+sVarI+" < "+sz+"; "+sVarI+"++)\n");
         _out.append("{\n");
         _out.append("   if("+sVarIdxPrev+" < 0)\n");
         _out.append("      "+sVarSum+" += "+sVarArray+"["+sVarIdxPrev+" + "+sz+"] * "+sVarWinTbl+"["+sVarI+"];\n");
         _out.append("   else\n");
         _out.append("      "+sVarSum+" += "+sVarArray+"["+sVarIdxPrev+"] * "+sVarWinTbl+"["+sVarI+"];\n");
         _out.append("   "+sVarIdxPrev+"++;\n");
         _out.append("}\n");
         _script.freeTmpVarInt32(sVarIdxPrev);
         _out.append(_sDstVar+" = "+sVarSum+";\n");
      }
      else
      {
         // Sub oldest from sum
         _out.append(sVarSum+" -= "+sVarArray+"["+sVarWriteIdx+"];\n");

         // Store next value in ring buffer and add to sum
         _out.append(sVarSum+" += "+_sDstVar+";\n");
         _out.append(sVarArray+"["+sVarWriteIdx+"] = "+_sDstVar+";\n");

         // Divide by size
         _out.append(_sDstVar+" = "+sVarSum+" * "+FloatToString(1.0f / sz)+";\n");
      }

      // Square root
      // // _out.append("if("+_sDstVar+" > 0.0f)\n");
      _out.append(_sDstVar+" = sqrtf("+_sDstVar+");\n");

      _out.append("if(++"+sVarWriteIdx+" >= "+sz+")\n");
      _out.append("   "+sVarWriteIdx+" = 0;\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleRms<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleSaw : CyModuleOscSync {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq",     1.0, 0.25, 4.0);
      addInput("phase",    0.0, 0.0,  1.0);
      addInput("vsync",    1.0, 0.01, 4.0);
      addInput("cycle",    1.0, 0.0,  1.0);
      addInput("reset",    1.0, 0.0,  1.0);
      addInput("fixed",    0.0, 0.0,  1.0);
      addInput("window",   0.0, 0.0,  3.0);  // 0=off, 1=sine, 2=half-sine, 3=tri, 4=hse1_36, 5=hse2, 6=hse3, 7=hse5, 8=hse7
      addInput("phasemod", 0.0, 0.0,  1.0);  // post vsync
      addInput("pd",       0.0, 0.0,  1.0);  // phase distortion subtree. input is phase (0..1), output is new phase (0..1)

      addInputAlias("f",   "freq");
      addInputAlias("ph",  "phase");
      addInputAlias("vs",  "vsync");
      addInputAlias("cy",  "cycle");
      addInputAlias("rs",  "reset");
      addInputAlias("fx",  "fixed");
      addInputAlias("win", "window");
      addInputAlias("pm",  "phasemod");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inWindow   <= findInputById("window");
      local CyInput inPhaseMod <= findInputById("phasemod");
      local CyInput inPD       <= findInputById("pd");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);
      local boolean bWindow = inWindow.isConnected();
      local int windowType;
      if(inWindow.isConstVal())
      {
         windowType = int(inWindow.getConstVal() + 0.5f);
         bWindow = (windowType > 0);
      }
      else
         windowType = -1;

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarInitVoice(sInit, "saw_phase", fPhaseInit,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );

      local String *sVarPhaseWin;
      if(bWindow)
      {
         sVarPhaseWin <= _script.allocTmpVarInitVoice(sInit, "win_phase", 0.0f,
                                                      (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                      (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                      );
      }

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarInit(sInit, "saw_speed",
                                                 inFreq.getConstVal() * _script.note_speed_fixed,
                                                 false/*bCycleReset*/
                                                 );
         else
            sVarSpeed <= _script.allocTmpVarInit(sInit, "saw_speed",
                                                 inFreq.getConstVal() * _script.note_speed,
                                                 false/*bCycleReset*/
                                                 );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVar(sInit, "saw_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVar(_out, "saw_freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = voice->note_speed_fixed * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = voice->note_speed_cur * "+sVarFreq+";\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed_fixed)+" * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed)+" * "+sVarFreq+";\n");
         }
         _script.freeTmpVar(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVar(_out, "saw_tmp");
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVar(_out, "phase");
         inPhase.emitFloat(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + "+sVarTmpPhase+")");
      }
      sOut.append(");\n");  // end "saw_tmp = frac(..)"  (phase)

      local String *sVSync;
      if(inVSync.isConstVal())
      {
         local float fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
            sVSync <= FloatToString(fVSync);
      }
      else
      {
         sVarVSync <= _script.allocTmpVar(_out, "vsync");
         sVSync <= sVarVSync;
         inVSync.emitFloat(_script, _out, sVarVSync);
      }
      if((null != sVSync) && !bWindow)
         sOut.append(sTmp+" = "+sTmp+" * "+sVSync+";\n");

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVar(sOut, "phasemod");
         inPhaseMod.emitFloat(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += "+sVarTmpPhaseMod+";\n");
      }

      sOut.append(sTmp+" = ffrac_s("+sTmp+");\n");

      if(inPD.isConnected())
      {
         inPD.emitFloat(_script, sOut, sTmp);
      }

      sOut.append(_sDstVar+" = 1.0f - ("+sTmp+" * 2.0f);\n");

      if(bWindow)
      {
         emitSyncWindow(_script, inWindow, windowType, sOut, sVarPhaseWin, _sDstVar);
      }

      if(!bSpeed0)
      {
         if(bWindow && (null != sVSync))
         {
            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+" * "+sVSync+");\n");
            sOut.append("tmp_f = "+sVarPhaseWin+";\n");
            sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");
            sOut.append("if(tmp_f > "+sVarPhaseWin+") "+sVarPhase+" = "+sVarPhaseWin+" * "+sVSync+"; \n");
         }
         else
         {
            if(bWindow)
               sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");

            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+");\n");
         }
      }

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVar(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVar(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVar(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVar(sVarTmpPhaseMod);

      _script.freeTmpVar(sTmp);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inPhaseMod <= findInputById("phasemod");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarIntInitVoice(sInit, "saw_phase",
                                                                int(fPhaseInit*16384),
                                                                (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                                (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                                );

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin || inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "saw_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed_fixed),
                                                    false/*bCycleReset*/
                                                    );
         else
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "saw_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed),
                                                    false/*bCycleReset*/
                                                    );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVarInt(sInit, "saw_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      if(!inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVarInt(_out, "saw_freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_fixed * 16384), "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_cur * 16384), "+sVarFreq+");\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed_fixed * 16384)+", "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed * 16384)+", "+sVarFreq+");\n");
         }
         _script.freeTmpVarInt(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVarInt(_out, "saw_tmp");
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVarInt(_out, "phase");
         inPhase.emitInt(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + ("+sVarTmpPhase+" << 3))");  // *8 to scale from FX_ONE (2048) to 16384
      }
      sOut.append(");\n");

      float fVSync = 1.0;
      if(inVSync.isConstVal())
      {
         fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
         {
            if(b_export_c)
               sOut.append(sTmp+" = mulsw("+sTmp+", "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
            else
               sOut.append(sTmp+" = ("+sTmp+" * "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
         }
      }
      else
      {
         fVSync = -1.0f;
         sVarVSync <= _script.allocTmpVarInt(_out, "vsync");
         inVSync.emitInt(_script, _out, sVarVSync);
         if(b_export_c)
            sOut.append(sTmp+" = mulsw("+sTmp+", "+sVarVSync+") >> "+FX_SHR+";\n");
         else
            sOut.append(sTmp+" = ("+sTmp+" * "+sVarVSync+") >> "+FX_SHR+";\n");
      }

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVarInt(sOut, "phasemod");
         inPhaseMod.emitInt(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += ("+sVarTmpPhaseMod+" << 3);\n");  // *8 to scale from FX_ONE (2048) to 16384
      }

      sOut.append(sTmp+" = "+sTmp+" & 0x3FFF;\n");  // frac()

      sOut.append(_sDstVar+" = "+int(FX_ONE)+" - ("+sTmp+" >> (14 - "+FX_SHR+"-1));\n");

      if(!bSpeed0)
         sOut.append(sVarPhase+" = ("+sVarPhase+" + "+sVarSpeed+") & 0x3FFF;\n");

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVarInt(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVarInt(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVarInt(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVar(sVarTmpPhaseMod);

      _script.freeTmpVarInt(sTmp);
   }

}


// <class.png>
class CyModuleSin : CyModuleOscSync {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq",     1.0, 0.25, 4.0);
      addInput("phase",    0.0, 0.0,  1.0);
      addInput("vsync",    1.0, 0.01, 4.0);
      addInput("cycle",    1.0, 0.0,  1.0);
      addInput("reset",    1.0, 0.0,  1.0);
      addInput("fixed",    0.0, 0.0,  1.0);
      addInput("window",   0.0, 0.0,  8.0);  // 0=off, 1=sine, 2=half-sine, 3=tri, 4=hse1_36, 5=hse2, 6=hse3, 7=hse5, 8=hse7
      addInput("phasemod", 0.0, 0.0,  1.0);  // post vsync
      addInput("pd",       0.0, 0.0,  1.0);  // phase distortion subtree. input is phase (0..1), output is new phase (0..1)

      addInputAlias("f",   "freq");
      addInputAlias("ph",  "phase");
      addInputAlias("vs",  "vsync");
      addInputAlias("cy",  "cycle");
      addInputAlias("rs",  "reset");
      addInputAlias("fx",  "fixed");
      addInputAlias("win", "window");
      addInputAlias("pm",  "phasemod");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inWindow   <= findInputById("window");
      local CyInput inPhaseMod <= findInputById("phasemod");
      local CyInput inPD       <= findInputById("pd");

      local boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed  = (inFixed.getConstVal() >= 0.5f);
      local boolean bWindow = inWindow.isConnected();
      local int windowType;
      if(inWindow.isConstVal())
      {
         windowType = int(inWindow.getConstVal() + 0.5f);
         bWindow = (windowType > 0);
      }
      else
         windowType = -1;

      // trace "xxx Sin::emitFloat: windowType="+windowType+" bWindow="+bWindow;

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarInitVoice(sInit, "sin_phase", fPhaseInit,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );

      local String *sVarPhaseWin;
      if(bWindow)
      {
         sVarPhaseWin <= _script.allocTmpVarInitVoice(sInit, "win_phase", 0.0f,
                                                      (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                      (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                      );
      }

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         // trace "xxx float sin note_speed="+_script.note_speed+" inFreq="+inFreq.getConstVal();
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarInit(sInit, "sin_speed",
                                                 inFreq.getConstVal() * _script.note_speed_fixed,
                                                 false/*bCycleReset*/
                                                 );
         else
            sVarSpeed <= _script.allocTmpVarInit(sInit, "sin_speed",
                                                 inFreq.getConstVal() * _script.note_speed,
                                                 false/*bCycleReset*/
                                                 );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVar(sInit, "sin_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVar(_out, "sin_freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = voice->note_speed_fixed * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = voice->note_speed_cur * "+sVarFreq+";\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed_fixed)+" * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed)+" * "+sVarFreq+";\n");
         }
         _script.freeTmpVar(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVar(_out, "sin_tmp");
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVar(_out, "phase");
         inPhase.emitFloat(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + "+sVarTmpPhase+")");
      }
      sOut.append(");\n");  // end sin_tmp = (..)

      local String *sVSync;
      if(inVSync.isConstVal())
      {
         local float fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
            sVSync <= FloatToString(fVSync);
      }
      else
      {
         sVarVSync <= _script.allocTmpVar(_out, "vsync");
         sVSync <= sVarVSync;
         inVSync.emitFloat(_script, _out, sVarVSync);
      }
      if((null != sVSync) && !bWindow)
         sOut.append(sTmp+" = "+sTmp+" * "+sVSync+";\n");

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVar(sOut, "phasemod");
         inPhaseMod.emitFloat(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += "+sVarTmpPhaseMod+";\n");
      }

      sOut.append(sTmp+" = ffrac_s("+sTmp+");\n");

      if(inPD.isConnected())
      {
         inPD.emitFloat(_script, sOut, sTmp);
      }

      if(b_export_c)
      {
         parent_script.b_use_sine_tbl = true;
         sOut.append(_sDstVar+" = cycle_sine_tbl_f[(unsigned short)(16384 * "+sTmp+")&16383u];\n");
      }
      else
         sOut.append(_sDstVar+" = sin(2PI * "+sTmp+");\n");

      if(bWindow)
      {
         emitSyncWindow(_script, inWindow, windowType, sOut, sVarPhaseWin, _sDstVar);
      }

      if(!bSpeed0)
      {
         if(bWindow && (null != sVSync))
         {
            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+" * "+sVSync+");\n");
            sOut.append("tmp_f = "+sVarPhaseWin+";\n");
            sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");
            sOut.append("if(tmp_f > "+sVarPhaseWin+") "+sVarPhase+" = "+sVarPhaseWin+" * "+sVSync+"; \n");
         }
         else
         {
            if(bWindow)
               sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");

            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+");\n");
         }
      }
      else if(bWindow)
      {
         if(bWindow)
            sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");
      }

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVar(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVar(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVar(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVar(sVarTmpPhaseMod);

      _script.freeTmpVar(sTmp);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inPhaseMod <= findInputById("phasemod");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarIntInitVoice(sInit, "sin_phase", int(fPhaseInit*16384),
                                                                (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                                (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                                );

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         // trace "xxx int sin note_speed="+_script.note_speed+" inFreq="+inFreq.getConstVal();
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "sin_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed_fixed),
                                                    false/*bCycleReset*/
                                                    );
         else
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "sin_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed),
                                                    false/*bCycleReset*/
                                                    );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVarInt(sInit, "sin_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVarInt(_out, "sin_freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_fixed * 16384), "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_cur * 16384), "+sVarFreq+");\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed_fixed * 16384)+", "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed * 16384)+", "+sVarFreq+");\n");
         }
         _script.freeTmpVarInt(sVarFreq);
         // trace "xxx sin speed="+_script.note_speed+" int="+int(_script.note_speed * 16384);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVarInt(_out, "sin_tmp");
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVarInt(_out, "phase");
         inPhase.emitInt(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + ("+sVarTmpPhase+" << 3))");  // *8 to scale from FX_ONE (2048) to 16384
      }
      sOut.append(");\n");

      float fVSync = 1.0;
      if(inVSync.isConstVal())
      {
         fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
         {
            if(b_export_c)
               sOut.append(sTmp+" = mulsw("+sTmp+", "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
            else
               sOut.append(sTmp+" = ("+sTmp+" * "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
         }
      }
      else
      {
         fVSync = -1.0f;
         sVarVSync <= _script.allocTmpVarInt(_out, "vsync");
         inVSync.emitInt(_script, _out, sVarVSync);
         if(b_export_c)
            sOut.append(sTmp+" = mulsw("+sTmp+", "+sVarVSync+") >> "+FX_SHR+";\n");
         else
            sOut.append(sTmp+" = ("+sTmp+" * "+sVarVSync+") >> "+FX_SHR+";\n");
      }

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVarInt(sOut, "phasemod");
         inPhaseMod.emitInt(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += ("+sVarTmpPhaseMod+" << 3);\n");  // *8 to scale from FX_ONE (2048) to 16384
      }

      sOut.append(sTmp+" = "+sTmp+" & 0x3FFF;\n");  // frac()

      parent_script.b_use_sine_tbl_i = true;
      sOut.append(_sDstVar+" = cycle_sine_tbl_i["+sTmp+"];\n");

      if(!bSpeed0)
         sOut.append(sVarPhase+" = ("+sVarPhase+" + "+sVarSpeed+") & 0x3FFF;\n");

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVarInt(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVarInt(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVarInt(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVarInt(sVarTmpPhaseMod);

      _script.freeTmpVarInt(sTmp);
   }
}


// <class.png>
class CyModuleSlw : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("up",    0.3, 0.0, 1.0);  // should be in range 0..1
      addInput("down",  0.1, 0.0, 1.0);  // should be in range 0..1
      addInput("a",     0.0, 0.0, 1.0);
      addInput("b",     1.0, 0.0, 1.0);
      addInput("sr",    1.0, 0.0, 1.0);  // 1=factor in samplerate (must be const)

      addInputAlias("u", "up");
      addInputAlias("d", "down");
   }

   // <method.png>
   protected method emitSlewFloat(String _out, String _sDstVar,
                                  String _sVarA, String _sVarB,
                                  String _sSclUp, String _sSclDown
                                  ) {
      _out.append("if("+_sVarA+" < "+_sVarB+")\n");
      _out.append("   "+_sDstVar+" = "+_sVarA+" + ("+_sVarB+" - "+_sVarA+") * "+_sSclUp+";\n");
      _out.append("else\n");
      _out.append("   "+_sDstVar+" = "+_sVarA+" + ("+_sVarB+" - "+_sVarA+") * "+_sSclDown+";\n");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inUp   <= findInputById("up");
      local CyInput inDown <= findInputById("down");
      local CyInput inA    <= findInputById("a");
      local CyInput inB    <= findInputById("b");
      local CyInput inSR   <= findInputById("sr");

      local String *sVarA;
      local String *sVarB;

      local boolean bA = inA.isConnected();
      local boolean bB = inB.isConnected();

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String *sVarLastOut;
      if(!bA && !bB)
      {
         local String sInit;
         sVarLastOut <= _script.allocTmpVarInitVoice(sInit, "slw_last", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
         _script.appendInit(sInit);
      }

      local String *sSclUp;
      local String *sSclDown;
      local String sVarUp;   // *may* be allocated by evalAddSRInput()
      local String sVarDown;

      // 'up' factor
      if(bSR)
      {
         sSclUp   <= _script.evalAddSRInput(inUp,   _out, sVarUp  );
         sSclDown <= _script.evalAddSRInput(inDown, _out, sVarDown);
      }
      else
      {
         sVarUp = _script.allocTmpVar(_out, "up");
         inUp  .emitFloat(_script, _out, sVarUp);
         sSclUp <= sVarUp;

         sVarDown = _script.allocTmpVar(_out, "down");
         inDown.emitFloat(_script, _out, sVarDown);
         sSclDown <= sVarDown;
      }

      if(bA && !bB)
      {
         // previous input is 'b'
         sVarA <= _script.allocTmpVar(_out, "a");
         inA.emitFloat(_script, _out, sVarA);

         emitSlewFloat(_out, _sDstVar,
                       sVarA,
                       _sDstVar,
                       sSclUp,
                       sSclDown
                       );
      }
      else if(!bA && bB)
      {
         // previous input is 'a'
         sVarB <= _script.allocTmpVar(_out, "b");
         inB.emitFloat(_script, _out, sVarB);

         emitSlewFloat(_out, _sDstVar,
                       _sDstVar,
                       sVarB,
                       sSclUp,
                       sSclDown
                       );
      }
      else if(bA && bB)
      {
         // previous input is ignored
         sVarA <= _script.allocTmpVar(_out, "a");
         inA.emitFloat(_script, _out, sVarA);

         sVarB <= _script.allocTmpVar(_out, "b");
         inB.emitFloat(_script, _out, sVarB);

         emitSlewFloat(_out, _sDstVar,
                       sVarA,
                       sVarB,
                       sSclUp,
                       sSclDown
                       );
      }
      else
      {
         // neither 'a' or 'b' are connected => previous input is 'b', 'a' is last seen output
         emitSlewFloat(_out, _sDstVar,
                       sVarLastOut,
                       _sDstVar,
                       sSclUp,
                       sSclDown
                       );
         _out.append(sVarLastOut+" = "+_sDstVar+";\n");
      }

      if(null != sVarA)
         _script.freeTmpVar(sVarA);

      if(null != sVarB)
         _script.freeTmpVar(sVarB);

      if(!sVarUp.isBlank())
         _script.freeTmpVar(sVarUp);

      if(!sVarDown.isBlank())
         _script.freeTmpVar(sVarDown);
   }

   // <method.png>
   protected method emitSlewInt(String _out, String _sDstVar,
                                String _sVarA, String _sVarB,
                                String _sSclUp, String _sSclDown
                                ) {
      _out.append("if("+_sVarA+" < "+_sVarB+")\n");
      _out.append("   "+_sDstVar+" = "+_sVarA+" + Dmulsw_shr("+_sVarB+" - "+_sVarA+", "+_sSclUp+");\n");
      _out.append("else\n");
      _out.append("   "+_sDstVar+" = "+_sVarA+" + Dmulsw_shr("+_sVarB+" - "+_sVarA+", "+_sSclDown+");\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inUp   <= findInputById("up");
      local CyInput inDown <= findInputById("down");
      local CyInput inA    <= findInputById("a");
      local CyInput inB    <= findInputById("b");
      local CyInput inSR   <= findInputById("sr");

      local String *sVarA;
      local String *sVarB;

      local boolean bA = inA.isConnected();
      local boolean bB = inB.isConnected();

      // // local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);

      local String *sVarLastOut;
      if(!bA && !bB)
      {
         local String sInit;
         sVarLastOut <= _script.allocTmpVarIntInitVoice(sInit, "slw_last", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
         _script.appendInit(sInit);
      }

      local String *sSclUp;
      local String *sSclDown;
      local String sVarUp;   // *may* be allocated by evalAddSRInput()
      local String sVarDown;

      // 'up' factor
      // // if(bSR)
      // // {
      // //    sSclUp   <= _script.evalAddSRInput(inUp,   _out, sVarUp  );
      // //    sSclDown <= _script.evalAddSRInput(inDown, _out, sVarDown);
      // // }
      // // else
      // // {
         sVarUp = _script.allocTmpVarInt(_out, "up");
         inUp  .emitInt(_script, _out, sVarUp);
         sSclUp <= sVarUp;

         sVarDown = _script.allocTmpVarInt(_out, "down");
         inDown.emitInt(_script, _out, sVarDown);
         sSclDown <= sVarDown;
      // // }

      if(bA && !bB)
      {
         // previous input is 'b'
         sVarA <= _script.allocTmpVarInt(_out, "a");
         inA.emitInt(_script, _out, sVarA);

         emitSlewInt(_out, _sDstVar,
                     sVarA,
                     _sDstVar,
                     sSclUp,
                     sSclDown
                     );
      }
      else if(!bA && bB)
      {
         // previous input is 'a'
         sVarB <= _script.allocTmpVarInt(_out, "b");
         inB.emitInt(_script, _out, sVarB);

         emitSlewInt(_out, _sDstVar,
                     _sDstVar,
                     sVarB,
                     sSclUp,
                     sSclDown
                     );
      }
      else if(bA && bB)
      {
         // previous input is ignored
         sVarA <= _script.allocTmpVarInt(_out, "a");
         inA.emitInt(_script, _out, sVarA);

         sVarB <= _script.allocTmpVarInt(_out, "b");
         inB.emitInt(_script, _out, sVarB);

         emitSlewInt(_out, _sDstVar,
                     sVarA,
                     sVarB,
                     sSclUp,
                     sSclDown
                     );
      }
      else
      {
         // neither 'a' or 'b' are connected => previous input is 'b', 'a' is last seen output
         emitSlewInt(_out, _sDstVar,
                     sVarLastOut,
                     _sDstVar,
                     sSclUp,
                     sSclDown
                     );
         _out.append(sVarLastOut+" = "+_sDstVar+";\n");
      }

      if(null != sVarA)
         _script.freeTmpVarInt(sVarA);

      if(null != sVarB)
         _script.freeTmpVarInt(sVarB);

      if(!sVarUp.isBlank())
         _script.freeTmpVarInt(sVarUp);

      if(!sVarDown.isBlank())
         _script.freeTmpVarInt(sVarDown);
   }

}


// <class.png>
class CyModuleSpd : CyModule {
   // note speed

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      // (note) note_speed_cur already has oversample_factor factored in
      if(b_plugin)
      {
         // // _out.append(_sDstVar+" = voice->note_speed_cur * voice->sr_factor;\n");
         // // _script.b_use_sr_factor = true;
         _out.append(_sDstVar+" = voice->note_speed_cur;\n");
      }
      else
      {
         // // _out.append(_sDstVar+" = "+FloatToString(1.0f / _script.oversample_factor)+";\n");
         _out.append(_sDstVar+" = 1.0f;\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // (note) note_speed_cur already has oversample_factor factored in
      if(b_plugin)
      {
         // // _out.append(_sDstVar+" = ("+short_type+")(voice->note_speed_cur * voice->sr_factor * "+FX_ONE+");\n");
         // // _script.b_use_sr_factor = true;
         _out.append(_sDstVar+" = ("+short_type+")(voice->note_speed_cur * "+FX_ONE+");\n");
      }
      else
      {
         // // _out.append(_sDstVar+" = "+int(FX_ONE / _script.oversample_factor)+";\n");
         _out.append(_sDstVar+" = "+int(FX_ONE)+";\n");
      }
   }
}


// <class.png>
class CyModuleSpr : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("spd",   0.1, 0.0, 1.0);
      addInput("dcy",   0.8, 0.0, 1.0);
      addInput("sr",    1.0, 0.0, 1.0);  // 1=factor in samplerate (must be const)

      addInputAlias("s", "spd");
      addInputAlias("d", "dcy");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSpd  <= findInputById("spd");
      local CyInput inDcy  <= findInputById("dcy");
      local CyInput inSR   <= findInputById("sr");

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String sInit;
      local String sVarCurSpd <= _script.allocTmpVarInitVoice(sInit, "spr_cur_spd", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarCurOut <= _script.allocTmpVarInitVoice(sInit, "spr_cur_out", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String *sSpd;
      local String *sDcy;
      local String sVarSpd;  // *may* be allocated by evalAddSRInput()
      local String sVarDcy;  // *may* be allocated by evalMulSRInput()

      if(bSR)
      {
         sSpd <= _script.evalAddSRInput(inSpd, _out, sVarSpd);
         sDcy <= _script.evalMulSRInput(inDcy, _out, sVarDcy);
      }
      else
      {
         sVarSpd = _script.allocTmpVar(_out, "spd");
         inSpd.emitFloat(_script, _out, sVarSpd);
         sSpd <= sVarSpd;

         sVarDcy = _script.allocTmpVar(_out, "dcy");
         inDcy.emitFloat(_script, _out, sVarDcy);
         sDcy <= sVarDcy;
      }

      _out.append(sVarCurSpd+" += ("+_sDstVar+" - "+sVarCurOut+") * "+sSpd+";\n");
      _out.append(sVarCurOut+" += "+sVarCurSpd+";\n");
      _out.append(sVarCurSpd+" *= "+sDcy+";\n");

      _out.append(_sDstVar+" = "+sVarCurOut+";\n");

      if(!sVarSpd.isBlank())
         _script.freeTmpVar(sVarSpd);

      if(!sVarDcy.isBlank())
         _script.freeTmpVar(sVarDcy);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // // // (todo) implement integer version
      // // trace "[~~~] warning: CyModuleSpr<int>: falling back to float..";
      // // emitFloatFallback(_script, _out, _sDstVar);

      local CyInput inSpd  <= findInputById("spd");
      local CyInput inDcy  <= findInputById("dcy");
      local CyInput inSR   <= findInputById("sr");

      // // local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);

      local String sInit;
      local String sVarCurSpd <= _script.allocTmpVarIntInitVoice(sInit, "spr_cur_spd", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarCurOut <= _script.allocTmpVarIntInitVoice(sInit, "spr_cur_out", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String *sSpd;
      local String *sDcy;
      local String sVarSpd;  // // *may* be allocated by evalAddSRInput()
      local String sVarDcy;  // // *may* be allocated by evalMulSRInput()

      // // if(bSR)
      // // {
      // //    sSpd <= _script.evalAddSRInput(inSpd, _out, sVarSpd);
      // //    sDcy <= _script.evalMulSRInput(inDcy, _out, sVarDcy);
      // // }
      // // else
      // // {
         sVarSpd = _script.allocTmpVarInt(_out, "spd");
         inSpd.emitInt(_script, _out, sVarSpd);
         sSpd <= sVarSpd;

         sVarDcy = _script.allocTmpVarInt(_out, "dcy");
         inDcy.emitInt(_script, _out, sVarDcy);
         sDcy <= sVarDcy;
      // // }

      _out.append(sVarCurSpd+" += Dmulsw_shr("+_sDstVar+" - "+sVarCurOut+", "+sSpd+");\n");
      _out.append(sVarCurOut+" += "+sVarCurSpd+";\n");
      _out.append(sVarCurSpd+"  = Dmulsw_shr("+sVarCurSpd+", "+sDcy+");\n");

      _out.append(_sDstVar+" = "+sVarCurOut+";\n");

      if(!sVarSpd.isBlank())
         _script.freeTmpVarInt(sVarSpd);

      if(!sVarDcy.isBlank())
         _script.freeTmpVarInt(sVarDcy);
   }

}


// <class.png>
class CyModuleSsl : CyModule {
   int seq_indices;  // 4bit per slice, LSB=first slice, e.g. "01234567" => 0x76543210

   // frac mode "0 point": ignore fractional bits, simply recombine waveforms (fastest)
   // frac mode "1 phase": fractional bits determine source region start offset shift ("phase" mod 1/8 sin)
   // frac mode "2 lerp":  fractional bits are used to lerp sine source region to cosine wave
   // frac mode "3 shift": fractional bits are used to shift source region (dc offset + reflect/fold)
   // frac mode "4 ang":   fractional bits determine source region start offset shift ("phase" +- 2PI)
   // frac mode "5 amp":   fractional bits are used to amplify source region


   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq",     1.0, 0.25, 4.0);
      addInput("phase",    0.0, 0.0,  1.0);
      addInput("mode",     0.0, 0.0,  5.0);
      addInput("mod",      0.0, 0.0,  1.0);
      addInput("seq",      0.0, 0.0,  1.0);
      addInput("modmask",  1.0, 0.0,  1.0);
      addInput("zeromask", 0.0, 0.0,  1.0);
      addInput("seqmod",   0.0, 0.0,  4.0);

      addInputAlias("f",   "freq");
      addInputAlias("ph",  "phase");
      addInputAlias("m",   "mode");
      addInputAlias("s",   "seq");
      addInputAlias("mm",  "modmask");
      addInputAlias("zm",  "zeromask");
      addInputAlias("sm",  "seqmod");
   }

   // <method_get.png>
   public virtual getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      switch(_input)
      {
         case "mode":
            _retNames  = ["point", "phase", "lerp", "shift", "ang", "amp"];
            _retValues = [0,       1,       2,      3,        4,    5];
            return true;
      }
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inMode     <= findInputById("mode");
      local CyInput inMod      <= findInputById("mod");
      local CyInput inSeq      <= findInputById("seq");
      local CyInput inModMask  <= findInputById("modmask");
      local CyInput inZeroMask <= findInputById("zeromask");
      local CyInput inSeqMod   <= findInputById("seqmod");

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarInit(sInit, "ssl_phase", fPhaseInit, true/*bCycleReset*/);
      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         sVarSpeed <= _script.allocTmpVarInit(sInit, "ssl_speed",
                                              inFreq.getConstVal() * _script.note_speed,
                                              false/*bCycleReset*/
                                              );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVar(sInit, "ssl_speed");
         sVarSpeed <= sVarTmpSpeed;
      }
      _script.appendInit(sInit);

      local String sOut;
      local String sTmp <= _script.allocTmpVar(sOut, "ssl_tmp");

      // Calc current phase / update frequency modulation
      sOut.append(sTmp+" = ffrac_s(");
      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVar(_out, "freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         if(b_plugin)
            _out.append(sVarSpeed+" = voice->note_speed_cur * "+sVarFreq+";\n");
         else
            _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed)+" * "+sVarFreq+";\n");
         _script.freeTmpVar(sVarFreq);
      }

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         local String sPhase <= _script.allocTmpVar(_out, "phase");
         inPhase.emitFloat(_script, _out, sPhase);
         sOut.append("("+sVarPhase+" + "+sPhase+")");
         _script.freeTmpVar(sPhase);
      }
      sOut.append(");\n");

      // Divide target cycle/wave into 8 slices
      sOut.append(sTmp+" = "+sTmp+" * 8.0f;\n");

      local String sSlice <= _script.allocTmpVarInt(_out, "ssl_slice");
      sOut.append(sSlice+" = int("+sTmp+");\n");

      // Modulation
      local String sVarModA <= _script.allocTmpVar(sOut, "ssl_slice_mod_a");
      inMod.emitFloat(_script, sOut, sVarModA);

      local String sSeq;
      if(inSeq.isConst0())
         sSeq = seq_indices;
      else if(inSeq.isConstVal())
      {
         // seq=01234567 => 111110101100011010001000 = 16434824 = #fac688
         // => 0.979591904854
         local int iSeq = inSeq.getConstVal() * #ffffff;  // 8*3 bits
         iSeq = (iSeq&7) | (((iSeq>>3)&7)<<4) | (((iSeq>>6)&7)<<8) | (((iSeq>>9)&7)<<12) | (((iSeq>>12)&7)<<16) | (((iSeq>>15)&7)<<20) | (((iSeq>>18)&7)<<24) | (((iSeq>>21)&7)<<28);
         sSeq = iSeq;
      }
      else
      {
         // should not be reachable (seq input must be const)
         sSeq = seq_indices;
      }

      if(inSeqMod.isConnected() && !inSeqMod.isConst0())
      {
         local String sVarSeqModF <= _script.allocTmpVar(sOut, "ssl_seq_modf");
         inSeqMod.emitFloat(_script, sOut, sVarSeqModF);
         local String sVarSeqMod <= _script.allocTmpVarInt(sOut, "ssl_seq_mod");
         sOut.append(sVarSeqMod+" = ("+sVarSeqModF+" * "+FX_ONE+");\n");
         local String sVarSeq <= _script.allocTmpVarInt32Init(sInit, "ssl_seq", 0, false/*bCycleReset*/, true/*bVoiceReset*/);
         sOut.append(sVarSeq+" = "+sSeq+" + (("+sVarSeqMod+" << 16) | "+sVarSeqMod+");\n");
         sSeq = sVarSeq;
         _script.freeTmpVar(sVarSeqModF);
      }

      // Get source region index (phase angle) for current slice
      local String sVarIndexA <= _script.allocTmpVar(sOut, "ssl_slice_index_a");
      sOut.append(sVarIndexA+" = (("+sSeq+">>("+sSlice+"<<2))&7);\n");
      // sOut.append("trace \"slice=\"+int(\"+sTmp+\")+\" region=\"+"+sVarIndexA+"+\" rphase=\"+frac(\"+sTmp+"\")+\" mod=\"+"+sVarModA+";\n");
      local String sVarPhaseA <= _script.allocTmpVar(sOut, "ssl_slice_phase_a");

      int mode = inMode.isConstVal() ? (int(inMode.getConstVal())&7) : 0;

      local String sModMask;
      local String *sVarModMask;
      boolean bModAll;
      if(inModMask.isConstVal())
      {
         sModMask = int(inModMask.getConstVal() * FX_ONE) & 255;
         bModAll = (sModMask == "255");
      }
      else
      {
         local String sVarModMaskF <= _script.allocTmpVar(sOut, "ssl_modmask_f");
         inModMask.emitFloat(_script, sOut, sVarModMaskF);
         sVarModMask <= _script.allocTmpVarInt(sOut, "ssl_modmask");
         sOut.append(sVarModMask+" = int("+sVarModMaskF+" * "+FX_ONE+") & 255;\n");
         sModMask = sVarModMask;
         bModAll = false;
         _script.freeTmpVar(sVarModMaskF);
      }

      local String sZeroMask;
      local String *sVarZeroMask;
      boolean bZeroNone;
      if(inZeroMask.isConstVal())
      {
         sZeroMask = int(inZeroMask.getConstVal() * FX_ONE) & 255;
         bZeroNone = (sZeroMask == "0");
      }
      else
      {
         local String sVarZeroMaskF <= _script.allocTmpVar(sOut, "ssl_zeromask_f");
         inZeroMask.emitFloat(_script, sOut, sVarZeroMaskF);
         sVarZeroMask <= _script.allocTmpVarInt(sOut, "ssl_zeromask");
         sOut.append(sVarZeroMask+" = int("+sVarZeroMaskF+" * "+FX_ONE+") & 255;\n");
         sZeroMask = sVarZeroMask;
         bZeroNone = false;
         _script.freeTmpVar(sVarZeroMaskF);
      }

      switch(mode)
      {
         default:
         case 0:  // point
            if(!bZeroNone)
            {
               sOut.append(sSlice+" = 1 << "+sSlice+";\n");
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0.0f;\n");
               sOut.append("else\n");
               sOut.append("{\n");
               sOut.append("   "+sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+");\n");
               if(b_export_c)
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+");\n");
               else
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f));\n");
               sOut.append("}\n");
            }
            else
            {
               sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+");\n");
               if(b_export_c)
                  sOut.append(_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+");\n");
               else
                  sOut.append(_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f));\n");
            }
            break;

         case 1:  // phase
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
            sOut.append("   "+_sDstVar+" = 0.0f;\n");
            sOut.append("else\n");
            sOut.append("{\n");
            trace "xxx ssl: mode=phase bModAll="+bModAll+" sModMask="+sModMask+" sSlice="+sSlice;
            if(!bModAll)
            {
               sOut.append("   if("+sModMask+" & "+sSlice+")\n");
               sOut.append("      "+sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+" + "+sVarModA+");\n");
               sOut.append("   else\n");
               sOut.append("      "+sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+");\n");
            }
            else
            {
               sOut.append("   "+sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+" + "+sVarModA+");\n");
            }
            if(b_export_c)
               sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+");\n");
            else
               sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f));\n");
            sOut.append("}\n");
            break;

         case 2:  // lerp to cosine or sin-90Â° (negative mod)
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
            sOut.append("   "+_sDstVar+" = 0.0f;\n");
            sOut.append("else\n");
            sOut.append("{\n");
            sOut.append("   "+sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+");\n");
            if(b_export_c)
               sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+");\n");
            else
               sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f));\n");
            if(!bModAll)
            {
               sOut.append("   if("+sModMask+" & "+sSlice+")\n");
               sOut.append("   {\n");
               if(b_export_c)
               {
                  sOut.append("      if("+sVarModA+" >= 0.0f)\n");
                  sOut.append("         "+_sDstVar+" += (cosf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+") - "+_sDstVar+") * "+sVarModA+";\n");
                  sOut.append("      else\n");
                  sOut.append("         "+_sDstVar+" += (sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+" - "+FloatToString(2PI/4)+") - "+_sDstVar+") * -"+sVarModA+";\n");
               }
               else
               {
                  sOut.append("      if("+sVarModA+" >= 0.0f)\n");
                  sOut.append("         "+_sDstVar+" += (cos("+sVarPhaseA+" * (2PI/8.0f)) - "+_sDstVar+") * "+sVarModA+";\n");
                  sOut.append("      else\n");
                  sOut.append("         "+_sDstVar+" += (sin("+sVarPhaseA+" * (2PI/8.0f) - (2PI/4)) - "+_sDstVar+") * -"+sVarModA+";\n");
               }
               sOut.append("   }\n");
            }
            else
            {
               if(b_export_c)
               {
                  sOut.append("   if("+sVarModA+" >= 0.0f)\n");
                  sOut.append("      "+_sDstVar+" += (cosf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+") - "+_sDstVar+") * "+sVarModA+";\n");
                  sOut.append("   else\n");
                  sOut.append("      "+_sDstVar+" += (sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+" - "+FloatToString(2PI/4)+") - "+_sDstVar+") * -"+sVarModA+";\n");
               }
               else
               {
                  sOut.append("   if("+sVarModA+" >= 0.0f)\n");
                  sOut.append("      "+_sDstVar+" += (cos("+sVarPhaseA+" * (2PI/8.0f)) - "+_sDstVar+") * "+sVarModA+";\n");
                  sOut.append("   else\n");
                  sOut.append("      "+_sDstVar+" += (sin("+sVarPhaseA+" * (2PI/8.0f) - (2PI/4)) - "+_sDstVar+") * -"+sVarModA+";\n");
               }
            }
            sOut.append("}\n");
            break;

         case 3:  // shift
            sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+");\n");
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            if(!bModAll)
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0.0f;\n");
               sOut.append("else if("+sModMask+" & "+sSlice+")\n");
               sOut.append("{\n");
               if(b_export_c)
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+") +"+sVarModA+";\n");
               else
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f)) +"+sVarModA+";\n");
               sOut.append("   if("+_sDstVar+" > 1.0f) "+_sDstVar+" = 2.0f - "+_sDstVar+";\n");
               sOut.append("   else if("+_sDstVar+" < -1.0f) "+_sDstVar+" = -(2.0f + "+_sDstVar+");\n");
               sOut.append("}\n");
               sOut.append("else\n");
               sOut.append("{\n");
               if(b_export_c)
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+");\n");
               else
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f));\n");
               sOut.append("}\n");
            }
            else
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0.0f;\n");
               sOut.append("else\n");
               sOut.append("{\n");
               if(b_export_c)
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+") +"+sVarModA+";\n");
               else
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f)) +"+sVarModA+";\n");
               sOut.append("   if("+_sDstVar+" > 1.0f) "+_sDstVar+" = 2.0f - "+_sDstVar+";\n");
               sOut.append("   else if("+_sDstVar+" < -1.0f) "+_sDstVar+" = -(2.0f + "+_sDstVar+");\n");
               sOut.append("}\n");
            }
            break;

         case 4:  // ang
            sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+");\n");
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            if(!bModAll)
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0.0f;\n");
               sOut.append("else if("+sModMask+" & "+sSlice+")\n");
               if(b_export_c)
               {
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+" + "+sVarModA+" * "+FloatToString(2PI)+");\n");
                  sOut.append("else\n");
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+");\n");
               }
               else
               {
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f) + "+sVarModA+" * 2PI);\n");
                  sOut.append("else\n");
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f));\n");
               }
            }
            else
            {
               if(!bZeroNone)
               {
                  sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
                  sOut.append("   "+_sDstVar+" = 0.0f;\n");
                  sOut.append("else\n");
                  if(b_export_c)
                     sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+" + "+sVarModA+" * "+FloatToString(2PI)+");\n");
                  else
                     sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f) + "+sVarModA+" * 2PI);\n");
               }
               else
               {
                  if(b_export_c)
                     sOut.append(_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+" + "+sVarModA+" * "+FloatToString(2PI)+");\n");
                  else
                     sOut.append(_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f) + "+sVarModA+" * 2PI);\n");
               }
            }
            break;

         case 5:  // amp
            sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ffrac_s("+sTmp+");\n");
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            if(!bModAll)
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0.0f;\n");
               sOut.append("else if("+sModMask+" & "+sSlice+")\n");
               if(b_export_c)
               {
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+") * "+sVarModA+";\n");
                  sOut.append("else\n");
                  sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+");\n");
               }
               else
               {
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f)) * "+sVarModA+";\n");
                  sOut.append("else\n");
                  sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f));\n");
               }
            }
            else
            {
               if(!bZeroNone)
               {
                  sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
                  sOut.append("   "+_sDstVar+" = 0.0f;\n");
                  sOut.append("else\n");
                  if(b_export_c)
                     sOut.append("   "+_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+") * "+sVarModA+";\n");
                  else
                     sOut.append("   "+_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f)) * "+sVarModA+";\n");
               }
               else
               {
                  if(b_export_c)
                     sOut.append(_sDstVar+" = sinf("+sVarPhaseA+" * "+FloatToString(2PI/8.0f)+") * "+sVarModA+";\n");
                  else
                     sOut.append(_sDstVar+" = sin("+sVarPhaseA+" * (2PI/8.0f)) * "+sVarModA+";\n");
               }
            }
            break;
      }

      // Accumulate phase
      // // sOut.append(sVarPhase+" += "+sVarSpeed+";\n");
      sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+");\n");

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVar(sVarTmpSpeed);

      _script.freeTmpVar(sTmp);

      _script.freeTmpVarInt(sSlice);
      _script.freeTmpVar(sVarModA);

      _script.freeTmpVar(sVarIndexA);
      _script.freeTmpVar(sVarPhaseA);

      if(null != sVarModMask)
         _script.freeTmpVarInt(sVarModMask);

      if(null != sVarZeroMask)
         _script.freeTmpVarInt(sVarZeroMask);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inMode     <= findInputById("mode");
      local CyInput inMod      <= findInputById("mod");
      local CyInput inSeq      <= findInputById("seq");
      local CyInput inModMask  <= findInputById("modmask");
      local CyInput inZeroMask <= findInputById("zeromask");
      local CyInput inSeqMod   <= findInputById("seqmod");

      // (note) sine table sz is 16384

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarIntInit(sInit, "ssl_phase", int(fPhaseInit*16384), true/*bCycleReset*/);
      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         sVarSpeed <= _script.allocTmpVarIntInit(sInit, "ssl_speed",
                                                 int(inFreq.getConstVal() * 16384 * _script.note_speed),
                                                 false/*bCycleReset*/
                                                 );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVarInt(sInit, "ssl_speed");
         sVarSpeed <= sVarTmpSpeed;
      }
      _script.appendInit(sInit);

      local String sOut;
      local String sTmp <= _script.allocTmpVarInt(sOut, "ssl_tmp");

      // Calc current phase / update frequency modulation
      sOut.append(sTmp+" = (");
      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVarInt(_out, "freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         if(b_plugin)
            _out.append(sVarSpeed+" = short(voice->note_speed_cur * "+sVarFreq+");\n");
         else
            _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed * 16384)+", "+sVarFreq+");\n");
         _script.freeTmpVarInt(sVarFreq);
      }

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         local String sPhase <= _script.allocTmpVarInt(_out, "phase");
         inPhase.emitInt(_script, _out, sPhase);
         sOut.append("("+sVarPhase+" + ("+sPhase+" << 3))");  // *8 to scale from FX_ONE (2048) to 16384
         _script.freeTmpVarInt(sPhase);
      }
      sOut.append(" & 16383);\n");

      // Divide target cycle/wave into 8 slices
      // // sOut.append(sTmp+" = Dfrac("+sTmp+") << 3;\n");
      //  (note) sTmp already in range 0..16383 (0..7.9999)

      local String sSlice <= _script.allocTmpVarInt(_out, "ssl_slice");
      sOut.append(sSlice+" = "+sTmp+" >> "+FX_SHR+";\n");  // => 0..7

      // Modulation
      local String sVarModA <= _script.allocTmpVarInt(sOut, "ssl_slice_mod_a");
      inMod.emitInt(_script, sOut, sVarModA);

      local String sSeq;
      if(inSeq.isConst0())
         sSeq = seq_indices;
      else if(inSeq.isConstVal())
      {
         // seq=01234567 => 111110101100011010001000 = 16434824 = #fac688
         // => 0.979591904854
         local int iSeq = inSeq.getConstVal() * #ffffff;  // 8*3 bits
         iSeq = (iSeq&7) | (((iSeq>>3)&7)<<4) | (((iSeq>>6)&7)<<8) | (((iSeq>>9)&7)<<12) | (((iSeq>>12)&7)<<16) | (((iSeq>>15)&7)<<20) | (((iSeq>>18)&7)<<24) | (((iSeq>>21)&7)<<28);
         sSeq = iSeq;
      }
      else
      {
         // should not be reachable (seq input must be const)
         sSeq = seq_indices;
      }

      if(inSeqMod.isConnected() && !inSeqMod.isConst0())
      {
         local String sVarSeqMod <= _script.allocTmpVarInt(sOut, "ssl_seq_mod");
         inSeqMod.emitInt(_script, sOut, sVarSeqMod);
         local String sVarSeq <= _script.allocTmpVarInt32Init(sInit, "ssl_seq", 0, false/*bCycleReset*/, true/*bVoiceRest*/);
         sOut.append(sVarSeq+" = "+sSeq+" + (("+sVarSeqMod+" << 16) | "+sVarSeqMod+");\n");
         sSeq = sVarSeq;
         _script.freeTmpVarInt(sVarSeqMod);
      }

      // sOut.append("trace \"sSeq=\"+"+sSeq+";\n");

      // Get source region index (phase angle) for current slice
      local String sVarIndexA <= _script.allocTmpVarInt(sOut, "ssl_slice_index_a");
      sOut.append(sVarIndexA+" = (("+sSeq+">>("+sSlice+"<<2))&7) << "+FX_SHR+";\n");
      // sOut.append("trace \"slice=\"+int(\"+sTmp+\")+\" region=\"+"+sVarIndexA+"+\" rphase=\"+frac(\"+sTmp+"\")+\" mod=\"+"+sVarModA+";\n");
      local String sVarPhaseA <= _script.allocTmpVarInt(sOut, "ssl_slice_phase_a");

      int mode = inMode.isConstVal() ? (int(inMode.getConstVal())&7) : 0;

      local String sModMask;
      local String *sVarModMask;
      boolean bModAll;
      if(inModMask.isConstVal())
      {
         sModMask = int(inModMask.getConstVal() * FX_ONE) & 255;
         // trace "xxx sModMask="+sModMask+" constVal="+inModMask.getConstVal();
         bModAll = (sModMask == "255");
      }
      else
      {
         sVarModMask <= _script.allocTmpVarInt(sOut, "ssl_modmask");
         inModMask.emitInt(_script, sOut, sVarModMask);
         sOut.append(sVarModMask+" = ("+sVarModMask+" & 255);\n");
         sModMask = sVarModMask;
         bModAll = false;
      }

      local String sZeroMask;
      local String *sVarZeroMask;
      boolean bZeroNone;
      if(inZeroMask.isConstVal())
      {
         sZeroMask = int(inZeroMask.getConstVal() * FX_ONE) & 255;
         bZeroNone = (sZeroMask == "0");
      }
      else
      {
         sVarZeroMask <= _script.allocTmpVarInt(sOut, "ssl_zeromask");
         inZeroMask.emitInt(_script, sOut, sVarZeroMask);
         sOut.append(sVarZeroMask+" = ("+sVarZeroMask+" & 255);\n");
         sZeroMask = sVarZeroMask;
         bZeroNone = false;
      }

      switch(mode)
      {
         default:
         case 0:  // point
            if(!bZeroNone)
            {
               sOut.append(sSlice+" = 1 << "+sSlice+";\n");
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0;\n");
               sOut.append("else\n");
               sOut.append("{\n");
               sOut.append("   "+sVarPhaseA+" = "+sVarIndexA+" + ("+sTmp+" & "+FX_FRAC+");\n");  // 0.0..7.99999 (16383)
               sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383];\n");
               sOut.append("}\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            else
            {
               sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ("+sTmp+" & "+FX_FRAC+");\n");
               // sOut.append("trace \"phase=\"+"+sVarPhase+"+\" speed=\"+"+sVarSpeed+";\n");
               // sOut.append("trace \"index=\"+"+sVarIndexA+"+\" slicePhase=\"+Dfrac_u("+sTmp+");\n");
               sOut.append(_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383];\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            break;

         case 1:  // phase
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
            sOut.append("   "+_sDstVar+" = 0;\n");
            sOut.append("else\n");
            sOut.append("{\n");
            if(!bModAll)
            {
               sOut.append("   if("+sModMask+" & "+sSlice+")\n");
               sOut.append("      "+sVarPhaseA+" = "+sVarIndexA+" + (("+sTmp+" + "+sVarModA+") & "+FX_FRAC+");\n");
               sOut.append("   else\n");
               sOut.append("      "+sVarPhaseA+" = "+sVarIndexA+" + ("+sTmp+" & "+FX_FRAC+");\n");
            }
            else
            {
               sOut.append("   "+sVarPhaseA+" = "+sVarIndexA+" + (("+sTmp+" + "+sVarModA+") & "+FX_FRAC+");\n");
            }
            sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383];\n");
            sOut.append("}\n");
            parent_script.b_use_sine_tbl_i = true;
            break;

         case 2:  // lerp to cosine or sin-90Â° (negative mod)
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
            sOut.append("   "+_sDstVar+" = 0;\n");
            sOut.append("else\n");
            sOut.append("{\n");
            sOut.append("   "+sVarPhaseA+" = "+sVarIndexA+" + ("+sTmp+" & "+FX_FRAC+");\n");
            sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383];\n");
            parent_script.b_use_sine_tbl_i = true;
            if(!bModAll)
            {
               sOut.append("   if("+sModMask+" & "+sSlice+")\n");
               sOut.append("   {\n");
               sOut.append("      if("+sVarModA+" >= 0)\n");
               sOut.append("         "+_sDstVar+" += Dmulsw_shr(cycle_sine_tbl_i[(4096 + "+sVarPhaseA+")&16383] - "+_sDstVar+", "+sVarModA+");\n"); // cos
               sOut.append("      else\n");
               sOut.append("         "+_sDstVar+" += Dmulsw_shr(cycle_sine_tbl_i[("+sVarPhaseA+" - 4096)&16383] - "+_sDstVar+", -"+sVarModA+");\n");
               sOut.append("   }\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            else
            {
               sOut.append("   if("+sVarModA+" >= 0)\n");
               sOut.append("      "+_sDstVar+" += Dmulsw_shr(cycle_sine_tbl_i[(4096 + "+sVarPhaseA+")&16383] - "+_sDstVar+", "+sVarModA+");\n");
               sOut.append("   else\n");
               sOut.append("      "+_sDstVar+" += Dmulsw_shr(cycle_sine_tbl_i[("+sVarPhaseA+" - 4096)&16383] - "+_sDstVar+", -"+sVarModA+");\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            sOut.append("}\n");
            break;

         case 3:  // shift
            sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ("+sTmp+" & "+FX_FRAC+");\n");
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            if(!bModAll)
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0;\n");
               sOut.append("else if("+sModMask+" & "+sSlice+")\n");
               sOut.append("{\n");
               sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383] +"+sVarModA+";\n");
               sOut.append("   if("+_sDstVar+" > "+FX_ONE+") "+_sDstVar+" = "+(FX_ONE*2)+" - "+_sDstVar+";\n");
               sOut.append("   else if("+_sDstVar+" < -"+FX_ONE+") "+_sDstVar+" = -("+(FX_ONE*2)+" + "+_sDstVar+");\n");
               sOut.append("}\n");
               sOut.append("else\n");
               sOut.append("{\n");
               sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383];\n");
               sOut.append("}\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            else
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0;\n");
               sOut.append("else\n");
               sOut.append("{\n");
               sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383] +"+sVarModA+";\n");
               sOut.append("   if("+_sDstVar+" > "+FX_ONE+") "+_sDstVar+" = "+(FX_ONE*2)+" - "+_sDstVar+";\n");
               sOut.append("   else if("+_sDstVar+" < -"+FX_ONE+") "+_sDstVar+" = -("+(FX_ONE*2)+" + "+_sDstVar+");\n");
               sOut.append("}\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            break;

         case 4:  // ang
            sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ("+sTmp+" & "+FX_FRAC+");\n");
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            if(!bModAll)
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0;\n");
               sOut.append("else if("+sModMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i[("+sVarPhaseA+" + ("+sVarModA+" << 3)) & 16383];\n");
               sOut.append("else\n");
               sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383];\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            else
            {
               if(!bZeroNone)
               {
                  sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
                  sOut.append("   "+_sDstVar+" = 0;\n");
                  sOut.append("else\n");
                  sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i[("+sVarPhaseA+" + ("+sVarModA+" << 3)) & 16383];\n");
               }
               else
               {
                  sOut.append(_sDstVar+" = cycle_sine_tbl_i[("+sVarPhaseA+" + ("+sVarModA+" << 3)) & 16383];\n");
               }
               parent_script.b_use_sine_tbl_i = true;
            }
            break;

         case 5:  // amp
            sOut.append(sVarPhaseA+" = "+sVarIndexA+" + ("+sTmp+" & "+FX_FRAC+");\n");
            sOut.append(sSlice+" = 1 << "+sSlice+";\n");
            if(!bModAll)
            {
               sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = 0;\n");
               sOut.append("else if("+sModMask+" & "+sSlice+")\n");
               sOut.append("   "+_sDstVar+" = Dmulsw_shr(cycle_sine_tbl_i["+sVarPhaseA+" & 16383], "+sVarModA+");\n");
               sOut.append("else\n");
               sOut.append("   "+_sDstVar+" = cycle_sine_tbl_i["+sVarPhaseA+" & 16383];\n");
               parent_script.b_use_sine_tbl_i = true;
            }
            else
            {
               if(!bZeroNone)
               {
                  sOut.append("if("+sZeroMask+" & "+sSlice+")\n");
                  sOut.append("   "+_sDstVar+" = 0;\n");
                  sOut.append("else\n");
                  sOut.append("   "+_sDstVar+" = Dmulsw_shr(cycle_sine_tbl_i["+sVarPhaseA+" & 16383], "+sVarModA+");\n");
                  parent_script.b_use_sine_tbl_i = true;
               }
               else
               {
                  sOut.append(_sDstVar+" = Dmulsw_shr(cycle_sine_tbl_i["+sVarPhaseA+" & 16383], "+sVarModA+");\n");
                  parent_script.b_use_sine_tbl_i = true;
               }
            }
            break;
      }

      // Accumulate phase
      sOut.append(sVarPhase+" += "+sVarSpeed+";\n");

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVarInt(sVarTmpSpeed);

      _script.freeTmpVarInt(sVarIndexA);

      if(null != sVarModMask)
         _script.freeTmpVarInt(sVarModMask);

      if(null != sVarZeroMask)
         _script.freeTmpVarInt(sVarZeroMask);
   }
}


// <class.png>
class CyModuleSlf : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("rate", 0.985, 0.0, 1.0);

      addInputAlias("r", "rate");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inRate <= findInputById("rate");
      local float fRate;
      local boolean bConstRate = inRate.isConstVal();
      if(bConstRate)
      {
         fRate = inRate.getConstVal();
         if(fRate > 1.0)
            fRate = 1.0;
      }

      local String sInit;
      local String sVarPos <= _script.allocTmpVarInit(sInit, "slf_pos", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      if(b_export_c)
      {
         _out.append(_sDstVar+" = winLinear(_d, "+sVarPos+");\n");
      }
      else
      {
         _out.append(_sDstVar+" = _d.winLinear("+sVarPos+");\n");
      }

      if(bConstRate)
         _out.append(sVarPos+" += "+fRate+";\n");
      else
      {
         // (note) patch programmer must ensure that rate does not exceed 1.0
         local String sVarRate <= _script.allocTmpVar(_out, "rate");
         inRate.emitFloat(_script, _out, sVarRate);
         _out.append(sVarPos+" += "+sVarRate+";\n");
         _script.freeTmpVar(sVarRate);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inRate <= findInputById("rate");
      local float fRate;
      local boolean bConstRate = inRate.isConstVal();
      if(bConstRate)
      {
         fRate = inRate.getConstVal();
         if(fRate > 1.0)
            fRate = 1.0;
      }

      local String sInit;
      local String *sVarPos;

      // (note) could use inline assembly and addx for 68k / "C" version
      if(bConstRate)
      {
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "slf_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
         _script.appendInit(sInit);

         if(b_export_c)
            _out.append(_sDstVar+" = ((short)_d["+sVarPos+" >> 16]) << "+(FX_SHR - 7)+";\n");
         else
            _out.append(_sDstVar+" = _d.get("+sVarPos+" >> 16) * "+int(FX_ONE)+";\n");
         _out.append(sVarPos+" += "+int(fRate*65536.0)+";\n");
      }
      else
      {
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "slf_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);  // short
         _script.appendInit(sInit);

         // (note) position precision reduced from 16 to 11 bit
         // (note) patch programmer must ensure that rate does not exceed 1.0
         local String sVarRate <= _script.allocTmpVarInt(_out, "rate");
         inRate.emitInt(_script, _out, sVarRate);
         _out.append(sVarPos+" += "+sVarRate+";\n");

         if(b_export_c)
            _out.append(_sDstVar+" = ((short)_d["+sVarPos+" >> "+FX_SHR+"]) << "+(FX_SHR - 7)+";\n");
         else
            _out.append(_sDstVar+" = _d.get("+sVarPos+" >> "+FX_SHR+") * "+int(FX_ONE)+";\n");
         _out.append(sVarPos+" += "+sVarRate+";\n");

         _script.freeTmpVarInt(sVarRate);
      }
   }
}


// // // <class.png>
// // class CyModuleSub : CyModule {
// //    // discard sub-tree (but keep its side effects, e.g. var stores)

// //    // <method_init.png>
// //    public virtual init() {
// //       CyModule::init();
// //    }

// //    // <method_get.png>
// //    public virtual doEmitRight() : boolean {
// //       // skip seq_right in emitFloatTree() / emitIntTree()
// //       return false;
// //    }

// //    // <method.png>
// //    public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
// //       if(null != seq_right)
// //       {
// //          local String sVarTmp <= _script.allocTmpVarInt(sIndent, "sub_discard");
// //          seq_right.emitFloatSequence(_script, sIndent, sVarTmp);
// //          if(b_export_c)
// //             _out.append("(void)"+sVarTmp+";\n");
// //          _script.freeTmpVar(sVarTmp);
// //       }
// //    }

// //    // <method.png>
// //    public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
// //       if(null != seq_right)
// //       {
// //          local String sVarTmp <= _script.allocTmpVarInt(sIndent, "sub_discard");
// //          seq_right.emitIntSequence(_script, sIndent, sVarTmp);
// //          if(b_export_c)
// //             _out.append("(void)"+sVarTmp+";\n");
// //          _script.freeTmpVarInt(sVarTmp);
// //       }
// //    }

// // }


// <class.png>
class CyModuleSvf : CyModule {
   // (note) see https://www.musicdsp.org/en/latest/Filters/142-state-variable-filter-chamberlin-version.html
   //           // Input/Output
   //               I - input sample
   //               L - lowpass output sample
   //               B - bandpass output sample
   //               H - highpass output sample
   //               N - notch output sample
   //               F1 - Frequency control parameter
   //               Q1 - Q control parameter
   //               D1 - delay associated with bandpass output
   //               D2 - delay associated with low-pass output
   //
   //           // parameters:
   //               Q1 = 1/Q
   //               // where Q1 goes from 2 to 0, ie Q goes from .5 to infinity
   //
   //               // simple frequency tuning with error towards nyquist
   //               // F is the filter's center frequency, and Fs is the sampling rate
   //               F1 = 2*pi*F/Fs
   //
   //               // ideal tuning:
   //               F1 = 2 * sin( pi * F / Fs )
   //
   //           // algorithm
   //               // loop
   //               L = D2 + F1 * D1
   //               H = I - L - Q1*D1
   //               B = F1 * H + D1
   //               N = H + L
   //
   //               // store delays
   //               D1 = B
   //               D2 = L
   //
   //           // outputs
   //           L,H,B,N

   //
   // (note) "mode" and "res" have to be constants in this version
   //

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq",    0.5, 0.0, 1.0);
      addInput("res",     1.0, 0.0, 1.0);  // 1=none, 0=max
      addInput("mode",    0.0, 0.0, 3.0);  // 0=lpf, 1=hpf, 2=bpf, 3=notch/brf
      addInput("postlpf", 0.0, 0.0, 1.0);  // post-lpf/pre-hpf insert
      addInput("posthpf", 0.0, 0.0, 1.0);  // post-hpf/pre-bpf insert
      addInput("postbpf", 0.0, 0.0, 1.0);  // post-bpf/pre-lpf insert
      addInput("sr",      1.0, 0.0, 1.0);

      addInputAlias("f",   "freq");
      addInputAlias("r",   "res");
      addInputAlias("m",   "mode");
      addInputAlias("pl",  "postlpf");
      addInputAlias("ph",  "posthpf");
      addInputAlias("pb",  "postbpf");
   }

   // <method_get.png>
   public virtual getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      switch(_input)
      {
         case "mode":
            _retNames  = ["lpf", "hpf", "bpf", "notch", "brf"];
            _retValues = [0,     1,     2,     3,       3];
            return true;
      }
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inFreq    <= findInputById("freq");
      local CyInput inRes     <= findInputById("res");
      local CyInput inMode    <= findInputById("mode");
      local CyInput inPostLPF <= findInputById("postlpf");
      local CyInput inPostHPF <= findInputById("posthpf");
      local CyInput inPostBPF <= findInputById("postbpf");
      local CyInput inSR      <= findInputById("sr");

      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);

      local String sInit;
      local String sVarLPF <= _script.allocTmpVarInit(sInit, "svf_lp", 0.0f, true/*bCycleReset*/);
      local String sVarHPF <= _script.allocTmpVarInit(sInit, "svf_hp", 0.0f, true/*bCycleReset*/);
      local String sVarBPF <= _script.allocTmpVarInit(sInit, "svf_bp", 0.0f, true/*bCycleReset*/);
      _script.appendInit(sInit);

      int iMode = (inMode.getConstVal()+0.5f);

      local String *sRes;
      local String *sVarRes;
      if(inRes.isConstVal())
      {
         sRes <= FloatToString(inRes.getConstVal());
      }
      else
      {
         sVarRes <= _script.allocTmpVar(_out, "res");
         inRes.emitFloat(_script, _out, sVarRes);
         sRes <= sVarRes;
      }

      local String *sFreq;
      local String sVarFreq;
      if(bSR)
      {
         sFreq <= _script.evalAddSRInput(inFreq, _out, sVarFreq);
      }
      else
      {
         if(inFreq.isConstVal())
         {
            float fFreq = inFreq.getConstVal();
            sFreq <= FloatToString(fFreq);
         }
         else
         {
            sVarFreq = _script.allocTmpVar(_out, "freq");
            inFreq.emitFloat(_script, _out, sVarFreq);
            sFreq <= sVarFreq;
         }
      }

      _out.append(sVarLPF+" = "+sVarLPF+" + ("+sVarBPF+" * "+sFreq+");\n");
      if(inPostLPF.isConnected())
         inPostLPF.emitFloat(_script, _out, sVarLPF);
      _out.append(sVarHPF+" = "+_sDstVar+" - "+sVarLPF+" - ("+sVarBPF+" * "+sRes+");\n");
      if(inPostHPF.isConnected())
         inPostHPF.emitFloat(_script, _out, sVarHPF);
      _out.append(sVarBPF+" = "+sVarBPF+" + ("+sVarHPF+" * "+sFreq+");\n");
      if(inPostBPF.isConnected())
         inPostBPF.emitFloat(_script, _out, sVarBPF);

      switch(iMode)
      {
         default:
         case 0:
            _out.append(_sDstVar+" = "+sVarLPF+";\n");
            break;

         case 1:
            _out.append(_sDstVar+" = "+sVarHPF+";\n");
            break;

         case 2:
            _out.append(_sDstVar+" = "+sVarBPF+";\n");
            break;

         case 3:
            _out.append(_sDstVar+" = "+sVarHPF+" + "+sVarBPF+";\n");
            break;
      }

      if(!sVarFreq.isBlank())
         _script.freeTmpVar(sVarFreq);

      if(null != sVarRes)
         _script.freeTmpVar(sVarRes);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inSR   <= findInputById("sr");
      local boolean bSR = !_script.b_lofi && (inSR.getConstVal() >= 0.5f);
      bSR = bSR && (b_plugin || _script.oversample_factor > 1);
      if(bSR)
      {
         trace "[~~~] warning: CyModuleSVF<int>: sr=1, falling back to float..";
         return emitFloatFallback(_script, _out, _sDstVar);
      }

      local CyInput inFreq <= findInputById("freq");
      local CyInput inRes  <= findInputById("res");
      local CyInput inMode <= findInputById("mode");

      local String sInit;
      local String sVarLPF <= _script.allocTmpVarIntInit(sInit, "svf_lp", 0, true/*bCycleReset*/);
      local String sVarHPF <= _script.allocTmpVarIntInit(sInit, "svf_hp", 0, true/*bCycleReset*/);
      local String sVarBPF <= _script.allocTmpVarIntInit(sInit, "svf_bp", 0, true/*bCycleReset*/);

      _script.appendInit(sInit);

      int iMode = (inMode.getConstVal()+0.5f);

      local String *sRes;
      local String *sVarRes;
      if(inRes.isConstVal())
      {
         sRes <= String(int(inRes.getConstVal() * FX_ONE));
      }
      else
      {
         sVarRes <= _script.allocTmpVarInt(_out, "res");
         inRes.emitInt(_script, _out, sVarRes);
         sRes <= sVarRes;
      }

      local String *sFreq;
      local String *sVarFreq;
      if(inFreq.isConstVal())
      {
         float fFreq = inFreq.getConstVal();
         sFreq <= String(int(fFreq * FX_ONE));
      }
      else
      {
         sVarFreq <= _script.allocTmpVarInt(_out, "freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         sFreq <= sVarFreq;
      }

      if(b_export_c)
      {
         _out.append(sVarLPF+" = "+sVarLPF+" + (mulsw("+sVarBPF+", "+sFreq+") >> "+FX_SHR+");\n");
         _out.append(sVarHPF+" = "+_sDstVar+" - "+sVarLPF+" - (mulsw("+sVarBPF+", "+sRes+") >> "+FX_SHR+");\n");
         _out.append(sVarBPF+" = "+sVarBPF+" + (mulsw("+sVarHPF+", "+sFreq+") >> "+FX_SHR+");\n");
      }
      else
      {
         _out.append(sVarLPF+" = "+sVarLPF+" + (("+sVarBPF+" * "+sFreq+") >> "+FX_SHR+");\n");
         _out.append(sVarHPF+" = "+_sDstVar+" - "+sVarLPF+" - (("+sVarBPF+" * "+sRes+") >> "+FX_SHR+");\n");
         _out.append(sVarBPF+" = "+sVarBPF+" + (("+sVarHPF+" * "+sFreq+") >> "+FX_SHR+");\n");
      }
      switch(iMode)
      {
         default:
         case 0:
            _out.append(_sDstVar+" = "+sVarLPF+";\n");
            break;

         case 1:
            _out.append(_sDstVar+" = "+sVarHPF+";\n");
            break;

         case 2:
            _out.append(_sDstVar+" = "+sVarBPF+";\n");
            break;

         case 3:
            _out.append(_sDstVar+" = "+sVarHPF+" + "+sVarBPF+";\n");
            break;
      }

      if(null != sVarFreq)
         _script.freeTmpVarInt(sVarFreq);

      if(null != sVarRes)
         _script.freeTmpVarInt(sVarRes);
   }
}


// <class.png>
class CyModuleTrc : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("c", 1, 0, 1);  // 1=trace changed values only  0=trace all (must be const)
      addInput("z", 1, 0, 1);  // 1=trace 0 values, 0=skip. def=0 (must be const)
      addInput("e", 0, 0, 1);  // >0: trace every nth value (must be const)
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inC <= findInputById("c");
      local CyInput inZ <= findInputById("z");
      local CyInput inE <= findInputById("e");

      local String *sCond;
      local String *sVarCond;
      local String *sVarLast;
      local String *sVarCount;

      local boolean bC = (inC.getConstVal() >= 0.5f);
      local boolean bZ = (inZ.getConstVal()  < 0.5f);
      local boolean bE = (inE.getConstVal() >= 1.5f);

      local String sInit;
      if(bC || bZ || bE)
      {
         sVarCond <= _script.allocTmpVarInt(_out, "trc_cond");
      }
      if(bC)
      {
         sVarLast <= _script.allocTmpVarInitVoice(sInit, "trc_last", -15.23f, true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      if(bE)
      {
         sVarCount <= _script.allocTmpVarIntInitVoice(sInit, "trc_count", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      _script.appendInit(sInit);

      if(bC)
      {
         sCond <= sVarCond;
         _out.append("if("+_sDstVar+" != "+sVarLast+")\n");
         _out.append("{\n");
         _out.append("   "+sVarCond+" = 1;\n");
         _out.append("   "+sVarLast+" = "+_sDstVar+";\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         _out.append("   "+sVarCond+" = 0;\n");
         _out.append("}\n");
      }

      if(bZ)
      {
         if(null == sCond)
         {
            sCond <= sVarCond;
            _out.append(sVarCond+" = (0.0f != "+_sDstVar+");\n");
         }
         else
         {
            _out.append(sVarCond+" = "+sVarCond+" && (0.0f != "+_sDstVar+");\n");
         }
      }

      if(bE)
      {
         if(null == sCond)
         {
            sCond <= sVarCond;
            _out.append(sVarCond+" = (0 == "+sVarCount+");\n");
         }
         else
         {
            _out.append(sVarCond+" = "+sVarCond+" && (0 == "+sVarCount+");\n");
         }
         _out.append("if(++"+sVarCount+" >= "+int(inE.getConstVal()+0.5f)+")\n");
         _out.append("   "+sVarCount+" = 0;\n");
      }

      parent_script.b_use_trc = true;
      if(null != sCond)
         _out.append("if("+sCond+") ");
      if(b_export_c)
         _out.append("printf(\""+_sDstVar+"=%f\\n\", "+_sDstVar+");\n");
      else
         _out.append("trace \""+_sDstVar+"=\"+"+_sDstVar+";\n");

      if(null != sVarCond)
         _script.freeTmpVarInt(sVarCond);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inC <= findInputById("c");
      local CyInput inZ <= findInputById("z");
      local CyInput inE <= findInputById("e");

      local String *sCond;
      local String *sVarCond;
      local String *sVarLast;
      local String *sVarCount;

      local boolean bC = (inC.getConstVal() >= 0.5f);
      local boolean bZ = (inZ.getConstVal()  < 0.5f);
      local boolean bE = (inE.getConstVal() >= 1.5f);

      local String sInit;
      if(bC || bZ || bE)
      {
         sVarCond <= _script.allocTmpVarInt(_out, "trc_cond");
      }
      if(bC)
      {
         sVarLast <= _script.allocTmpVarIntInitVoice(sInit, "trc_last", -32123, true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      if(bE)
      {
         sVarCount <= _script.allocTmpVarIntInitVoice(sInit, "trc_count", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      _script.appendInit(sInit);

      if(bC)
      {
         sCond <= sVarCond;
         _out.append("if("+_sDstVar+" != "+sVarLast+")\n");
         _out.append("{\n");
         _out.append("   "+sVarCond+" = 1;\n");
         _out.append("   "+sVarLast+" = "+_sDstVar+";\n");
         _out.append("}\n");
         _out.append("else\n");
         _out.append("{\n");
         _out.append("   "+sVarCond+" = 0;\n");
         _out.append("}\n");
      }

      if(bZ)
      {
         if(null == sCond)
         {
            sCond <= sVarCond;
            _out.append(sVarCond+" = (0 != "+_sDstVar+");\n");
         }
         else
         {
            _out.append(sVarCond+" = "+sVarCond+" && (0 != "+_sDstVar+");\n");
         }
      }

      if(bE)
      {
         if(null == sCond)
         {
            sCond <= sVarCond;
            _out.append(sVarCond+" = (0 == "+sVarCount+");\n");
         }
         else
         {
            _out.append(sVarCond+" = "+sVarCond+" && (0 == "+sVarCount+");\n");
         }
         _out.append("if(++"+sVarCount+" >= "+int(inE.getConstVal()+0.5f)+")\n");
         _out.append("   "+sVarCount+" = 0;\n");
      }

      parent_script.b_use_trc = true;
      if(null != sCond)
         _out.append("if("+sCond+") ");
      if(b_export_c)
         _out.append("printf(\""+_sDstVar+"=%f\\n\", ("+_sDstVar+" / ((float)"+FX_ONE+")));\n");
      else
         _out.append("trace \""+_sDstVar+"=\"+("+_sDstVar+" / float("+FX_ONE+"));\n");

      if(null != sVarCond)
         _script.freeTmpVarInt(sVarCond);
   }
}


// <class.png>
class CyModuleTri : CyModuleOscSync {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("freq",     1.0, 0.25, 4.0);
      addInput("phase",    0.0, 0.0,  1.0);
      addInput("vsync",    1.0, 0.01, 4.0);
      addInput("cycle",    1.0, 0.0,  1.0);
      addInput("reset",    1.0, 0.0,  1.0);
      addInput("fixed",    0.0, 0.0,  1.0);
      addInput("window",   0.0, 0.0,  3.0);  // 0=off, 1=sine, 2=half-sine, 3=tri, 4=hse1_36, 5=hse2, 6=hse3, 7=hse5, 8=hse7
      addInput("phasemod", 0.0, 0.0,  1.0);  // post vsync
      addInput("pd",       0.0, 0.0,  1.0);  // phase distortion subtree. input is phase (0..1), output is new phase (0..1)

      addInputAlias("f",   "freq");
      addInputAlias("ph",  "phase");
      addInputAlias("vs",  "vsync");
      addInputAlias("cy",  "cycle");
      addInputAlias("rs",  "reset");
      addInputAlias("fx",  "fixed");
      addInputAlias("win", "window");
      addInputAlias("pm",  "phasemod");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inWindow   <= findInputById("window");
      local CyInput inPhaseMod <= findInputById("phasemod");
      local CyInput inPD       <= findInputById("pd");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);
      local boolean bWindow = inWindow.isConnected();
      local int windowType;
      if(inWindow.isConstVal())
      {
         windowType = int(inWindow.getConstVal() + 0.5f);
         bWindow = (windowType > 0);
      }
      else
         windowType = -1;

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarInitVoice(sInit, "tri_phase", fPhaseInit,
                                                             (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                             (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                             );

      local String *sVarPhaseWin;
      if(bWindow)
      {
         sVarPhaseWin <= _script.allocTmpVarInitVoice(sInit, "win_phase", 0.0f,
                                                      (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                      (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                      );
      }

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarInit(sInit, "tri_speed",
                                                 inFreq.getConstVal() * _script.note_speed_fixed,
                                                 false/*bCycleReset*/
                                                 );
         else
            sVarSpeed <= _script.allocTmpVarInit(sInit, "tri_speed",
                                                 inFreq.getConstVal() * _script.note_speed,
                                                 false/*bCycleReset*/
                                                 );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVar(sInit, "tri_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVar(_out, "tri_freq");
         inFreq.emitFloat(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = voice->note_speed_fixed * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = voice->note_speed_cur * "+sVarFreq+";\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed_fixed)+" * "+sVarFreq+";\n");
            else
               _out.append(sVarSpeed+" = "+FloatToString(_script.note_speed)+" * "+sVarFreq+";\n");
         }
         _script.freeTmpVar(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVar(_out, "tri_tmp");
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVar(_out, "phase");
         inPhase.emitFloat(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + "+sVarTmpPhase+")");
      }
      sOut.append(");\n");

      local String *sVSync;
      if(inVSync.isConstVal())
      {
         local float fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
            sVSync <= FloatToString(fVSync);
      }
      else
      {
         sVarVSync <= _script.allocTmpVar(_out, "vsync");
         inVSync.emitFloat(_script, _out, sVarVSync);
         sVSync <= sVarVSync;
      }
      if((null != sVSync) && !bWindow)
         sOut.append(sTmp+" = "+sTmp+" * "+sVSync+";\n");

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVar(sOut, "phasemod");
         inPhaseMod.emitFloat(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += "+sVarTmpPhaseMod+";\n");
      }

      sOut.append(sTmp+" = ffrac_s("+sTmp+");\n");

      if(inPD.isConnected())
      {
         inPD.emitFloat(_script, sOut, sTmp);
      }

      sOut.append(_sDstVar+" = ("+sTmp+" < 0.5f) ? (-1.0f + "+sTmp+" * 4.0f) : (1.0f - ("+sTmp+" - 0.5f)*4);\n");

      if(bWindow)
      {
         emitSyncWindow(_script, inWindow, windowType, sOut, sVarPhaseWin, _sDstVar);
      }

      if(!bSpeed0)
      {
         if(bWindow && (null != sVSync))
         {
            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+" * "+sVSync+");\n");
            sOut.append("tmp_f = "+sVarPhaseWin+";\n");
            sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");
            sOut.append("if(tmp_f > "+sVarPhaseWin+") "+sVarPhase+" = "+sVarPhaseWin+" * "+sVSync+"; \n");
         }
         else
         {
            if(bWindow)
               sOut.append(sVarPhaseWin+" = ffrac_s("+sVarPhaseWin+" + "+sVarSpeed+");\n");

            sOut.append(sVarPhase+" = ffrac_s("+sVarPhase+" + "+sVarSpeed+");\n");
         }
      }

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVar(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVar(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVar(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVar(sVarTmpPhaseMod);

      _script.freeTmpVar(sTmp);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inFreq     <= findInputById("freq");
      local CyInput inPhase    <= findInputById("phase");
      local CyInput inVSync    <= findInputById("vsync");
      local CyInput inCycle    <= findInputById("cycle");
      local CyInput inReset    <= findInputById("reset");
      local CyInput inFixed    <= findInputById("fixed");
      local CyInput inPhaseMod <= findInputById("phasemod");

      boolean bSpeed0 = (inFreq.isConstVal() && inFreq.isConst0());
      local boolean bFixed = (inFixed.getConstVal() >= 0.5f);

      local String sInit;
      local float fPhaseInit;
      if(inPhase.isConstVal())
         fPhaseInit = inPhase.getConstVal();
      else
         fPhaseInit = 0.0f;
      local String sVarPhase <= _script.allocTmpVarIntInitVoice(sInit, "tri_phase", int(fPhaseInit*16384),
                                                                (inCycle.getConstVal() >= 0.5f)/*bCycleReset*/,
                                                                (inReset.getConstVal() >= 0.5f)/*bVoiceReset*/
                                                                );

      _script.appendInit(sInit);

      sInit.empty();
      local String *sVarSpeed;
      local String *sVarTmpSpeed;
      if(!b_plugin && inFreq.isConstVal())
      {
         if(bFixed)
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "tri_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed_fixed),
                                                    false/*bCycleReset*/
                                                    );
         else
            sVarSpeed <= _script.allocTmpVarIntInit(sInit, "tri_speed",
                                                    int(inFreq.getConstVal() * 16384 * _script.note_speed),
                                                    false/*bCycleReset*/
                                                    );
      }
      else
      {
         sVarTmpSpeed <= _script.allocTmpVarInt(sInit, "tri_speed");
         sVarSpeed <= sVarTmpSpeed;
      }

      _script.appendInit(sInit);

      if(b_plugin || !inFreq.isConstVal())
      {
         // update speed
         local String sVarFreq <= _script.allocTmpVarInt(_out, "tri_freq");
         inFreq.emitInt(_script, _out, sVarFreq);
         if(b_plugin)
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_fixed * 16384), "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr((short)(voice->note_speed_cur * 16384), "+sVarFreq+");\n");
         }
         else
         {
            if(bFixed)
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed_fixed * 16384)+", "+sVarFreq+");\n");
            else
               _out.append(sVarSpeed+" = Dmulsw_shr("+int(_script.note_speed * 16384)+", "+sVarFreq+");\n");
         }
         _script.freeTmpVarInt(sVarFreq);
      }

      // (note) nested output
      local String sOut;
      local String sTmp <= _script.allocTmpVarInt(_out, "tri_tmp");
      local String *sVarTmpPhase;
      local String *sVarVSync;
      local String *sVarTmpPhaseMod;

      // trace "xxx inFreq.isConst1()="+inFreq.isConst1()+" #modules="+inFreq.modules.numElements;

      sOut.append(sTmp+" = (");

      if(inPhase.isConstVal())
      {
         sOut.append(sVarPhase);
      }
      else
      {
         sVarTmpPhase <= _script.allocTmpVarInt(_out, "phase");
         inPhase.emitInt(_script, _out, sVarTmpPhase);
         sOut.append("("+sVarPhase+" + ("+sVarTmpPhase+" << 3))");  // *8 to scale from FX_ONE (2048) to 16384
      }
      sOut.append(");\n");

      float fVSync = 1.0;
      if(inVSync.isConstVal())
      {
         fVSync = inVSync.getConstVal();
         if(1.0 != fVSync)
         {
            if(b_export_c)
               sOut.append(sTmp+" = mulsw("+sTmp+", "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
            else
               sOut.append(sTmp+" = ("+sTmp+" * "+int(fVSync * FX_ONE)+") >> "+FX_SHR+";\n");
         }
      }
      else
      {
         fVSync = -1.0f;
         sVarVSync <= _script.allocTmpVarInt(_out, "vsync");
         inVSync.emitInt(_script, _out, sVarVSync);
         if(b_export_c)
            sOut.append(sTmp+" = mulsw("+sTmp+", "+sVarVSync+") >> "+FX_SHR+";\n");
         else
            sOut.append(sTmp+" = ("+sTmp+" * "+sVarVSync+") >> "+FX_SHR+";\n");
      }

      // Post VSync phase modulation
      if(inPhaseMod.isConnected())
      {
         sVarTmpPhaseMod <= _script.allocTmpVarInt(sOut, "phasemod");
         inPhaseMod.emitInt(_script, sOut, sVarTmpPhaseMod);
         sOut.append(sTmp+" += ("+sVarTmpPhaseMod+" << 3);\n");  // *8 to scale from FX_ONE (2048) to 16384
      }

      sOut.append(sTmp+" = "+sTmp+" & 0x3FFF;\n");  // frac()

      // 1 - (tmp-0.5)*4
      // 1 - (4*tmp -2)
      // 1 - 4*tmp +2
      // 3 - 4*tmp
      if(11 == FX_SHR)
         sOut.append(_sDstVar+" = ("+sTmp+" < 8192) ? (("+sTmp+" >> 1) - "+int(FX_ONE)+") : (("+int(FX_ONE)+"*3) - ("+sTmp+" >> 1));\n");
      else
         sOut.append(_sDstVar+" = ("+sTmp+" < 8192) ? (("+sTmp+" << 1) - "+int(FX_ONE)+") : (("+int(FX_ONE)+"*3) - ("+sTmp+" << 1));\n");

      if(!bSpeed0)
      {
         sOut.append(sVarPhase+" = ("+sVarPhase+" + "+sVarSpeed+") & 0x3FFF;\n");
      }

      _out.append(sOut);

      if(null != sVarTmpSpeed)
         _script.freeTmpVarInt(sVarTmpSpeed);

      if(null != sVarTmpPhase)
         _script.freeTmpVarInt(sVarTmpPhase);

      if(null != sVarVSync)
         _script.freeTmpVarInt(sVarVSync);

      if(null != sVarTmpPhaseMod)
         _script.freeTmpVarInt(sVarTmpPhaseMod);

      _script.freeTmpVarInt(sTmp);
   }
}


// <class.png>
class CyModuleSeq : CyModule {
   boolean b_tsq;  // 1=tsq mode  0=vsq mode
   int pat_bits;  // bit0=step0
   int pat_len;   // 1..32

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("dur",     5.0, 0.0,  10000.0);  // pulse duty cycle duration in milliseconds (tsq mode)
      addInput("restart", 0.0, 0,        1.0);  // rising edge: restart clock counter (e.g. sync ratchet clock to 'master' clock)
      addInput("shift",   0,   0,        1.0);  // shift play position (0..1 => 0..seq_len)
      addInput("gate",    0.0, 0,        1.0);  // rising edge: emit current step
      addInput("clk",     0.0, 0,        1.0);  // rising edge: advance to next step (evaluated after 'gate')
      addInput("cg",      0.0, 0,        1.0);  // (clock+gate) rising edge: emit current step and advance to next step (evaluated after 'gate')
      addInput("loop",    1,   0,        1.0);  // 1=repeat pattern infinitely  0=stop replay when seq_len is reached.  (must be const)
      addInput("len",     0.0, 0.0,     32.0);  // sequence length. 0=pat_len. must be const.
      addInput("step",    0.0, 0.0,      1.0);  // evaluated when new step value is needed. input is step index (0..n). output is step value (0..1).
      addInput("stepth",  0.0, 0.0,      1.0);  // gate=1 when 'step' subtree result is >'stepth' threshold. def=0.0. must be const.
      addInput("ontrig",  1.0, 0.0,      1.0);  // run arbitrary statement block when trig pulse duty cycle begins. output value (0..1) scales seq output.
      addInput("onend",   0.0, 0,        1  );  // run arbitrary statement block when end of pattern (or first step in loop mode) is reached during clock tick

      addInputAlias("d",   "dur");
      addInputAlias("rs",  "restart");
      addInputAlias("sh",  "shift");
      addInputAlias("g",   "gate");
      addInputAlias("c",   "clk");
      addInputAlias("lp",  "loop");
      addInputAlias("l",   "len");
      addInputAlias("s",   "step");
      addInputAlias("sth", "stepth");
      addInputAlias("ot",  "ontrig");
      addInputAlias("oe",  "onend");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inDurMS   <= findInputById("dur");
      local CyInput inRestart <= findInputById("restart");
      local CyInput inShift   <= findInputById("shift");
      local CyInput inGate    <= findInputById("gate");
      local CyInput inClk     <= findInputById("clk");
      local CyInput inClkGate <= findInputById("cg");
      local CyInput inLoop    <= findInputById("loop");
      local CyInput inLen     <= findInputById("len");
      local CyInput inStep    <= findInputById("step");
      local CyInput inStepTh  <= findInputById("stepth");
      local CyInput inOnTrig  <= findInputById("ontrig");
      local CyInput inOnEnd   <= findInputById("onend");

      local boolean bRestart = inRestart.isConnected();
      local boolean bShift   = inShift  .isConnected();
      local boolean bGate    = inGate   .isConnected();
      local boolean bClk     = inClk    .isConnected();
      local boolean bClkGate = inClkGate.isConnected();
      local boolean bLoop    = (inLoop.getConstVal() >= 0.5);
      local boolean bOnTrig  = inOnTrig.isConnected();

      local String varPrefix <= b_tsq ? "tsq_" : "vsq_";

      local int seqLen = -1;
      if(inLen.isConnected() && inLen.isConstVal())
         seqLen = inLen.getConstVal();
      if(seqLen <= 0 || seqLen > 32)
         seqLen = pat_len;

      local float fStepValThreshold = 0.0f;  // gate=1 when "step" subtree result is >threshold
      if(inStepTh.isConnected() && inStepTh.isConstVal())
         fStepValThreshold = inStepTh.getConstVal();

      local String sInit;
      local String sVarStepIdx <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"step", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarDutyLeft;
      local String *sVarOut;
      if(b_tsq)
         sVarDutyLeft <= _script.allocTmpVarInitVoice(sInit, varPrefix+"fr_duty_left", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      else
         sVarOut <= _script.allocTmpVarInitVoice(sInit, varPrefix+"out", 0.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarInitVoice(sInit, varPrefix+"last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLastGate <= _script.allocTmpVarInitVoice(sInit, varPrefix+"last_gate", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLastClk <= _script.allocTmpVarInitVoice(sInit, varPrefix+"last_clk", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastClkGate;
      if(bClkGate)
         sVarLastClkGate <= _script.allocTmpVarInitVoice(sInit, varPrefix+"last_clkgate", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarScl;
      if(bOnTrig)
         sVarScl <= _script.allocTmpVarInitVoice(sInit, varPrefix+"scl", 1.0f, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String *sVarShift;
      local String *sVarStepVal;

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVar(_out, varPrefix+"restart");
         inRestart.emitFloat(_script, _out, sVarRestart);
         // Rising edge ?
         _out.append(IfRisingEdgeFloat(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         // Restart sequence
         _out.append("   "+sVarStepIdx+" = 0;\n");
         if(b_tsq)
            _out.append("   "+sVarDutyLeft+" = 0.0f;\n");
         _out.append("}\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
         _script.freeTmpVar(sVarRestart);
      }

      local String sVarGate <= _script.allocTmpVar(_out, varPrefix+"gate");
      local String sVarClk  <= _script.allocTmpVar(_out, varPrefix+"clk");

      if!(bGate || bClk || bClkGate)
      {
         // Read clock+gate from previous output value
         _out.append(sVarGate+" = "+_sDstVar+";\n");
         _out.append(sVarClk+" = "+_sDstVar+";\n");
      }
      else
      {
         _out.append(sVarGate+" = 0.0f;\n");
         _out.append(sVarClk+" = 0.0f;\n");

         if(bGate)
            inGate.emitFloat(_script, _out, sVarGate);

         if(bClk)
            inClk.emitFloat(_script, _out, sVarClk);

         if(bClkGate)
         {
            // or'd with clk/gate inputs
            local String sVarClkGate <= _script.allocTmpVar(_out, varPrefix+"clkgate");
            inClkGate.emitFloat(_script, _out, sVarClkGate);
            _out.append(sVarGate+" += "+sVarClkGate+";\n");
            _out.append(sVarClk+" += "+sVarClkGate+";\n");
         }
      }

      local String sIndent;

      // Gate Rising edge ?
      _out.append(IfRisingEdgeFloat(sVarGate, sVarLastGate));
      _out.append("{\n");
      // Emit step
      sIndent.empty();
      local String *sVarDutyDur;
      if(b_tsq)
      {
         // Calc pulse duty cycle duration (#sample frames)
         sVarDutyDur <= _script.allocTmpVar(sIndent, varPrefix+"fr_duty_dur");
         _script.calcTmpVarInputMillisecToFrames(sIndent, sVarDutyDur, inDurMS);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
      }
      local String sVarCurIdx <= _script.allocTmpVarInt(_out, varPrefix+"idx");
      if(bShift)
      {
         sIndent.empty();
         sVarShift <= _script.allocTmpVar(sIndent, varPrefix+"shift");
         inShift.emitFloat(_script, sIndent, sVarShift);
         sIndent.append(sVarCurIdx+" = ("+sVarStepIdx+" + (int)("+sVarShift+" * "+seqLen+")) % "+seqLen+";\n");
         CyScript.AppendIndentedLines(_out, sIndent, 3);
      }
      else
      {
         _out.append("   "+sVarCurIdx+" = "+sVarStepIdx+";\n");
      }
      if(!bLoop)
      {
         // Begin step duty cycle if sequence has not finished, yet
         _out.append("   if("+sVarStepIdx+" < "+seqLen+")\n");
         _out.append("   {\n");
         if(inStep.isConnected())
         {
            sVarStepVal <= _script.allocTmpVar(_out, varPrefix+"stepval");
            sIndent.empty();
            // input is step index (0..31)
            _out.append("      "+sVarStepVal+" = (float)"+sVarStepIdx+";\n");
            inStep.emitFloat(_script, sIndent, sVarStepVal);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            if(b_tsq)
               _out.append("      if("+sVarStepVal+" > "+FloatToString(fStepValThreshold)+")\n");
            else
               _out.append("         "+sVarOut+" = "+sVarStepVal+";\n");
         }
         else
         {
            if(b_tsq)
               _out.append("      if("+pat_bits+" & (1 << "+sVarCurIdx+"))\n");
            else
               _out.append("         "+sVarOut+" = ("+pat_bits+" & (1 << "+sVarCurIdx+")) ? 1.0f : 0.0f;\n");
         }
         _out.append("      {\n");
         if(bOnTrig)
         {
            // Calc pulse level multiplier
            sIndent.empty();
            inOnTrig.emitFloat(_script, sIndent, sVarScl);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            if(!b_tsq)
               _out.append("         "+sVarOut+" *= "+sVarScl+";\n");
         }
         if(b_tsq)
            _out.append("         "+sVarDutyLeft+" = "+sVarDutyDur+";\n");
         _out.append("      }\n");
         _out.append("   }\n");
      }
      else
      {
         // Begin step duty cycle
         _out.append("   if("+sVarStepIdx+" < "+seqLen+")\n");
         _out.append("   {\n");
         if(inStep.isConnected())
         {
            sVarStepVal <= _script.allocTmpVar(_out, varPrefix+"stepval");
            sIndent.empty();
            // input is step index (0..31)
            _out.append("      "+sVarStepVal+" = (float)"+sVarStepIdx+";\n");
            inStep.emitFloat(_script, sIndent, sVarStepVal);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            if(b_tsq)
               _out.append("      if("+sVarStepVal+" > "+FloatToString(fStepValThreshold)+")\n");
            else
               _out.append("         "+sVarOut+" = "+sVarStepVal+";\n");
         }
         else
         {
            if(b_tsq)
               _out.append("      if("+pat_bits+" & (1 << "+sVarCurIdx+"))\n");
            else
               _out.append("         "+sVarOut+" = ("+pat_bits+" & (1 << "+sVarCurIdx+")) ? 1.0f : 0.0f;\n");
         }
         _out.append("      {\n");
         if(bOnTrig)
         {
            // Calc pulse level multiplier
            sIndent.empty();
            inOnTrig.emitFloat(_script, sIndent, sVarScl);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            if(!b_tsq)
               _out.append("         "+sVarOut+" *= "+sVarScl+";\n");
         }
         if(b_tsq)
            _out.append("         "+sVarDutyLeft+" = "+sVarDutyDur+";\n");
         _out.append("      }\n");
         _out.append("   }\n");
      }
      _out.append("}\n");
      _script.freeTmpVarInt(sVarCurIdx);

      // Clk Rising edge ?
      _out.append(IfRisingEdgeFloat(sVarClk, sVarLastClk));
      _out.append("{\n");
      // Advance
      if(!bLoop)
      {
         // Stop at end of pattern
         _out.append("   if("+sVarStepIdx+" < "+seqLen+")\n");
         _out.append("   {\n");
         _out.append("      "+sVarStepIdx+"++;\n");

         if(inOnEnd.isConnected())
         {
            _out.append("      if("+sVarStepIdx+" == "+seqLen+")\n");
            _out.append("      {\n");
            sIndent.empty();
            local String sVarEnd1 <= _script.allocTmpVar(sIndent, varPrefix+"endoneshot");
            inOnEnd.emitFloat(_script, sIndent, sVarEnd1);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            _out.append("      }\n");
         }

         _out.append("   }\n");
      }
      else
      {
         // Repeat pattern
         _out.append("   "+sVarStepIdx+" = ("+sVarStepIdx+" + 1) % "+seqLen+";\n");

         if(inOnEnd.isConnected())
         {
            _out.append("   if(0 == "+sVarStepIdx+")\n");
            _out.append("   {\n");
            sIndent.empty();
            local String sVarEnd2 <= _script.allocTmpVar(sIndent, varPrefix+"endrep");
            inOnEnd.emitFloat(_script, sIndent, sVarEnd2);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            _out.append("   }\n");
         }
      }
      _out.append("}\n");

      // Track gate signal
      _out.append(sVarLastGate+" = "+sVarGate+";\n");
      _script.freeTmpVar(sVarGate);

      // Track clk signal
      _out.append(sVarLastClk+" = "+sVarClk+";\n");
      _script.freeTmpVar(sVarClk);

      if(b_tsq)
      {
         // Emit duty pulse (or 0)
         if(bOnTrig)
            _out.append(_sDstVar+" = ((float)("+sVarDutyLeft+" > 0.0f)) * "+sVarScl+";\n");
         else
            _out.append(_sDstVar+" = (float)("+sVarDutyLeft+" > 0.0f);\n");
         _out.append(sVarDutyLeft+" -= 1.0f;\n");
      }
      else
      {
         // Emit (sample&hold) last step value
         _out.append(_sDstVar+" = "+sVarOut+";\n");
      }

      if(null != sVarShift)
         _script.freeTmpVar(sVarShift);

      if(null != sVarStepVal)
         _script.freeTmpVar(sVarStepVal);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // // trace "[~~~] warning: CyModuleSeq<int>: falling back to float..";
      // // emitFloatFallback(_script, _out, _sDstVar);

      local CyInput inDurMS   <= findInputById("dur");
      local CyInput inRestart <= findInputById("restart");
      local CyInput inShift   <= findInputById("shift");
      local CyInput inGate    <= findInputById("gate");
      local CyInput inClk     <= findInputById("clk");
      local CyInput inClkGate <= findInputById("cg");
      local CyInput inLoop    <= findInputById("loop");
      local CyInput inLen     <= findInputById("len");
      local CyInput inStep    <= findInputById("step");
      local CyInput inStepTh  <= findInputById("stepth");
      local CyInput inOnTrig  <= findInputById("ontrig");
      local CyInput inOnEnd   <= findInputById("onend");

      local boolean bRestart = inRestart.isConnected();
      local boolean bShift   = inShift  .isConnected();
      local boolean bGate    = inGate   .isConnected();
      local boolean bClk     = inClk    .isConnected();
      local boolean bClkGate = inClkGate.isConnected();
      local boolean bLoop    = (inLoop.getConstVal() >= 0.5);
      local boolean bOnTrig  = inOnTrig.isConnected();

      local String varPrefix <= b_tsq ? "tsq_" : "vsq_";

      local int seqLen = -1;
      if(inLen.isConnected() && inLen.isConstVal())
         seqLen = inLen.getConstVal();
      if(seqLen <= 0 || seqLen > 32)
         seqLen = pat_len;

      local float fStepValThreshold = 0.0f;  // gate=1 when "step" subtree result is >threshold
      if(inStepTh.isConnected() && inStepTh.isConstVal())
         fStepValThreshold = inStepTh.getConstVal();

      local String sInit;
      local String sVarStepIdx <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"step", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarDutyLeft;
      local String *sVarOut;
      if(b_tsq)
         sVarDutyLeft <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"fr_duty_left", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      else
         sVarOut <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"out", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLastGate <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"last_gate", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarLastClk <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"last_clk", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarLastClkGate;
      if(bClkGate)
         sVarLastClkGate <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"last_clkgate", int(0), true/*bCycleReset*/, true/*bVoiceReset*/);
      local String *sVarScl;
      if(bOnTrig)
         sVarScl <= _script.allocTmpVarIntInitVoice(sInit, varPrefix+"scl", int(FX_ONE), true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String *sVarShift;
      local String *sVarStepVal;

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVarInt(_out, varPrefix+"restart");
         inRestart.emitInt(_script, _out, sVarRestart);
         // Rising edge ?
         _out.append(IfRisingEdgeInt(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         // Restart sequence
         _out.append("   "+sVarStepIdx+" = 0;\n");
         if(b_tsq)
            _out.append("   "+sVarDutyLeft+" = 0;\n");
         _out.append("}\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
         _script.freeTmpVarInt(sVarRestart);
      }

      local String sVarGate <= _script.allocTmpVarInt(_out, varPrefix+"gate");
      local String sVarClk  <= _script.allocTmpVarInt(_out, varPrefix+"clk");

      if!(bGate || bClk || bClkGate)
      {
         // Read clock+gate from previous output value
         _out.append(sVarGate+" = "+_sDstVar+";\n");
         _out.append(sVarClk+" = "+_sDstVar+";\n");
      }
      else
      {
         _out.append(sVarGate+" = "+int(0)+";\n");
         _out.append(sVarClk+" = "+int(0)+";\n");

         if(bGate)
            inGate.emitInt(_script, _out, sVarGate);

         if(bClk)
            inClk.emitInt(_script, _out, sVarClk);

         if(bClkGate)
         {
            // or'd with clk/gate inputs
            local String sVarClkGate <= _script.allocTmpVarInt(_out, varPrefix+"clkgate");
            inClkGate.emitInt(_script, _out, sVarClkGate);
            _out.append(sVarGate+" += "+sVarClkGate+";\n");
            _out.append(sVarClk+" += "+sVarClkGate+";\n");
         }
      }

      local String sIndent;

      // Gate Rising edge ?
      _out.append(IfRisingEdgeInt(sVarGate, sVarLastGate));
      _out.append("{\n");
      // Emit step
      sIndent.empty();
      local String *sVarDutyDur;
      if(b_tsq)
      {
         // Calc pulse duty cycle duration (#sample frames)
         sVarDutyDur <= _script.allocTmpVarInt(sIndent, varPrefix+"fr_duty_dur");
         _script.calcTmpVarInputMillisecToFrames(sIndent, sVarDutyDur, inDurMS);  // frames as integer, not fixed point
         CyScript.AppendIndentedLines(_out, sIndent, 3);
      }
      local String sVarCurIdx <= _script.allocTmpVarInt(_out, varPrefix+"idx");
      if(bShift)
      {
         sIndent.empty();
         sVarShift <= _script.allocTmpVarInt(sIndent, varPrefix+"shift");
         inShift.emitInt(_script, sIndent, sVarShift);
         sIndent.append(sVarCurIdx+" = ("+sVarStepIdx+" + (int)("+sVarShift+" * "+seqLen+")) % "+seqLen+";\n");  // (todo) avoid modulo (div)
         CyScript.AppendIndentedLines(_out, sIndent, 3);
      }
      else
      {
         _out.append("   "+sVarCurIdx+" = "+sVarStepIdx+";\n");
      }
      if(!bLoop)
      {
         // Begin step duty cycle if sequence has not finished, yet
         _out.append("   if("+sVarStepIdx+" < "+seqLen+")\n");
         _out.append("   {\n");
         if(inStep.isConnected())
         {
            sVarStepVal <= _script.allocTmpVarInt(_out, varPrefix+"stepval");
            sIndent.empty();
            // input is step index (0..31)  (note: 0..15 due to 'short' range)
            _out.append("      "+sVarStepVal+" = "+sVarStepIdx+" << "+FX_SHR+";\n");
            inStep.emitInt(_script, sIndent, sVarStepVal);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            if(b_tsq)
               _out.append("      if("+sVarStepVal+" > "+int(FX_ONE * fStepValThreshold)+")\n");
            else
               _out.append("         "+sVarOut+" = "+sVarStepVal+";\n");
         }
         else
         {
            if(b_tsq)
               _out.append("      if("+pat_bits+" & (1 << "+sVarCurIdx+"))\n");
            else
               _out.append("         "+sVarOut+" = ("+pat_bits+" & (1 << "+sVarCurIdx+")) ? "+int(FX_ONE)+" : "+int(0)+";\n");
         }
         _out.append("      {\n");
         if(bOnTrig)
         {
            // Calc pulse level multiplier
            sIndent.empty();
            inOnTrig.emitInt(_script, sIndent, sVarScl);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            if(!b_tsq)
               _out.append("         "+sVarOut+" = Dmulsw_shr("+sVarOut+", "+sVarScl+");\n");
         }
         if(b_tsq)
            _out.append("         "+sVarDutyLeft+" = "+sVarDutyDur+";\n");
         _out.append("      }\n");
         _out.append("   }\n");
      }
      else
      {
         // Begin step duty cycle
         _out.append("   if("+sVarStepIdx+" < "+seqLen+")\n");
         _out.append("   {\n");
         if(inStep.isConnected())
         {
            sVarStepVal <= _script.allocTmpVarInt(_out, varPrefix+"stepval");
            sIndent.empty();
            // input is step index (0..31)  (note: 0..15 due to 'short' range)
            _out.append("      "+sVarStepVal+" = "+sVarStepIdx+" << "+FX_SHR+";\n");
            inStep.emitInt(_script, sIndent, sVarStepVal);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            if(b_tsq)
               _out.append("      if("+sVarStepVal+" > "+int(FX_ONE * fStepValThreshold)+")\n");
            else
               _out.append("         "+sVarOut+" = "+sVarStepVal+";\n");
         }
         else
         {
            if(b_tsq)
               _out.append("      if("+pat_bits+" & (1 << "+sVarCurIdx+"))\n");
            else
               _out.append("         "+sVarOut+" = ("+pat_bits+" & (1 << "+sVarCurIdx+")) ? "+int(FX_ONE)+" : "+int(0)+";\n");
         }
         _out.append("      {\n");
         if(bOnTrig)
         {
            // Calc pulse level multiplier
            sIndent.empty();
            inOnTrig.emitInt(_script, sIndent, sVarScl);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            if(!b_tsq)
               _out.append("         "+sVarOut+" = Dmulsw_shr("+sVarOut+", "+sVarScl+");\n");
         }
         if(b_tsq)
            _out.append("         "+sVarDutyLeft+" = "+sVarDutyDur+";\n");
         _out.append("      }\n");
         _out.append("   }\n");
      }
      _out.append("}\n");
      _script.freeTmpVarInt(sVarCurIdx);

      // Clk Rising edge ?
      _out.append(IfRisingEdgeInt(sVarClk, sVarLastClk));
      _out.append("{\n");
      // Advance
      if(!bLoop)
      {
         // Stop at end of pattern
         _out.append("   if("+sVarStepIdx+" < "+seqLen+")\n");
         _out.append("   {\n");
         _out.append("      "+sVarStepIdx+"++;\n");

         if(inOnEnd.isConnected())
         {
            _out.append("      if("+sVarStepIdx+" == "+seqLen+")\n");
            _out.append("      {\n");
            sIndent.empty();
            local String sVarEnd1 <= _script.allocTmpVarInt(sIndent, varPrefix+"endoneshot");
            inOnEnd.emitInt(_script, sIndent, sVarEnd1);
            CyScript.AppendIndentedLines(_out, sIndent, 9);
            _out.append("      }\n");
         }

         _out.append("   }\n");
      }
      else
      {
         // Repeat pattern
         _out.append("   "+sVarStepIdx+" = ("+sVarStepIdx+" + 1) % "+seqLen+";\n");  // (todo) avoid modulo (div)

         if(inOnEnd.isConnected())
         {
            _out.append("   if(0 == "+sVarStepIdx+")\n");
            _out.append("   {\n");
            sIndent.empty();
            local String sVarEnd2 <= _script.allocTmpVarInt(sIndent, varPrefix+"endrep");
            inOnEnd.emitInt(_script, sIndent, sVarEnd2);
            CyScript.AppendIndentedLines(_out, sIndent, 6);
            _out.append("   }\n");
         }
      }
      _out.append("}\n");

      // Track gate signal
      _out.append(sVarLastGate+" = "+sVarGate+";\n");
      _script.freeTmpVarInt(sVarGate);

      // Track clk signal
      _out.append(sVarLastClk+" = "+sVarClk+";\n");
      _script.freeTmpVarInt(sVarClk);

      if(b_tsq)
      {
         // Emit duty pulse (or 0)
         if(bOnTrig)
            _out.append(_sDstVar+" = ("+sVarDutyLeft+" > 0)) ? "+sVarScl+" : "+int(0)+";\n");
         else
            _out.append(_sDstVar+" = ("+sVarDutyLeft+" > 0) ? "+int(FX_ONE)+" : "+int(0)+";\n");
         _out.append(sVarDutyLeft+" -= 1;\n");
      }
      else
      {
         // Emit (sample&hold) last step value
         _out.append(_sDstVar+" = "+sVarOut+";\n");
      }

      if(null != sVarShift)
         _script.freeTmpVarInt(sVarShift);

      if(null != sVarStepVal)
         _script.freeTmpVarInt(sVarStepVal);
   }
}

// <class.png>
class CyModuleArg : CyModule {
   CyArg *arg_ref;

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method_get.png>
   public virtual getString() : String {
      return "$"+(arg_ref.id.toUpper());
   }

   // <method_get.png>
   public virtual isConstVal() : boolean {
      return true;
   }

   // <method_get.png>
   public virtual getConstVal() : float {
      // // trace "xxx CyModuleArg::getConstVal: id="+arg_ref.id+" val="+arg_ref.def_value;
      return arg_ref.cur_value;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = "+FloatToString(arg_ref.cur_value)+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      _out.append(_sDstVar+" = "+int(arg_ref.cur_value * FX_ONE)+";\n");
   }
}


// <class.png>
class CyModuleVar : CyModule {
   CyVar *var_ref;

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method_get.png>
   public virtual getString() : String {
      return "$"+var_ref.id;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if("x" == var_ref.id)
      {
         _out.append(_sDstVar+" = x;\n");
      }
      else if(b_plugin)
      {
         // var is float
         _out.append(_sDstVar+" = voice->var_"+var_ref.id+export_c_prefix+";\n");
      }
      else if(parent_script.b_lofi)
      {
         // in emitFloatFallback() => var is int => convert to float
         if(b_export_c)
            _out.append(_sDstVar+" = var_"+var_ref.id+export_c_prefix+" * "+(1.0f / FX_ONE)+";\n");
         else
            _out.append(_sDstVar+" = var_"+var_ref.id+" * "+(1.0f / FX_ONE)+";\n");
      }
      else
      {
         // hifi/float mode => var is float
         _out.append(_sDstVar+" = var_"+var_ref.id+";\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if("x" == var_ref.id)
      {
         if(!parent_script.b_lofi)
         {
            // 'x' is actually a float => convert
            trace "[~~~] warning: CyModuleVar<int>: falling back to float for lut x..";
            emitFloatFallback(_script, _out, _sDstVar);
         }
         else
         {
            _out.append(_sDstVar+" = x;\n");
         }
      }
      else if(b_plugin)
      {
         // within "int" sub-tree => convert from float
         //  (note) plugins are always emitted in "hifi" / float mode (i.e. all vars are floats)
         _out.append(_sDstVar+" = (short)(voice->var_"+var_ref.id+export_c_prefix+" * "+FX_ONE+");\n");
      }
      else if(parent_script.b_lofi)
      {
         // emitting in lofi/int mode => var is int
         _out.append(_sDstVar+" = var_"+var_ref.id+export_c_prefix+";\n");
      }
      else
      {
         // emitting in hifi/float mode => var is float => convert to int
         _out.append(_sDstVar+" = (short)(var_"+var_ref.id+export_c_prefix+" * "+FX_ONE+");\n");
      }
   }
}


// <class.png>
class CyModuleVel : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
         _out.append(_sDstVar+" = voice->velocity;\n");
      else
         _out.append(_sDstVar+" = 1.0f;\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
         _out.append(_sDstVar+" = voice->velocity * "+FX_ONE+";\n");
      else
         _out.append(_sDstVar+" = "+FX_ONE+";\n");
   }
}


// <class.png>
class CyModuleMac : CyModule {
   CyMacro *macro_ref;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("pos", 0.0f, 0.0f, 1.0f);

      addInputAlias("p", "pos");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inPos <= findInputById("pos");

      int numMacroRows   = macro_ref.getNumMacroRows();
      int numMacroFields = macro_ref.getNumMacroFields();
      int numMacroValues = macro_ref.getNumMacroValues();

      local String sVarPos <= _script.allocTmpVar(_out, "mac_pos");
      inPos.emitFloat(_script, _out, sVarPos);
      _out.append(sVarPos+" = ffrac_s("+sVarPos+") * "+numMacroRows+";\n");

      local String sVarAmt <= _script.allocTmpVar(_out, "mac_amt");
      _out.append(sVarAmt+" = ffrac_s("+sVarPos+");\n");

      local String sVarIdx  <= _script.allocTmpVarInt32(_out, "idx");
      _out.append(sVarIdx+" = int("+sVarPos+") * "+numMacroFields+";\n");

      local String sVarIdxN <= _script.allocTmpVarInt32(_out, "mac_idx_n");
      float l2 = log(numMacroValues) / log(2.0);
      if(l2 == int(l2))
         _out.append(sVarIdxN+" = ("+sVarIdx+" + "+numMacroFields+") & "+(numMacroValues-1)+";\n");
      else
         _out.append(sVarIdxN+" = ("+sVarIdx+" + "+numMacroFields+") % "+numMacroValues+";\n");

      // Lerp fields
      StringArray fieldNames <= macro_ref.field_names;
      local String *sMacroVarName;
      local String sMacroValuesName <= "macrovalues_"+macro_ref.id;
      int fieldIdx = 0;
      loop(numMacroFields)
      {
         sMacroVarName <= (b_plugin?"voice->":"")+"macrovar_"+macro_ref.id+"_"+fieldNames.get(fieldIdx)+export_c_prefix;
         _out.append(sMacroVarName+" = mathLerpf("+sMacroValuesName+"["+sVarIdx+" + "+fieldIdx+"], "+sMacroValuesName+"["+sVarIdxN+" + "+fieldIdx+"], "+sVarAmt+");\n");
         fieldIdx++;
      }

      _script.freeTmpVar(sVarPos);
      _script.freeTmpVar(sVarAmt);

      _script.freeTmpVarInt32(sVarIdx);
      _script.freeTmpVarInt32(sVarIdxN);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(parent_script.b_use_int_module)
      {
         // within "int" sub-tree, macro vars are actually floats
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }
      local CyInput inPos <= findInputById("pos");

      int numMacroRows   = macro_ref.getNumMacroRows();
      int numMacroFields = macro_ref.getNumMacroFields();
      int numMacroValues = macro_ref.getNumMacroValues();

      local String sVarPos <= _script.allocTmpVarInt(_out, "mac_pos");
      inPos.emitInt(_script, _out, sVarPos);
      _out.append(sVarPos+" = ("+sVarPos+" & "+FX_FRAC+") * "+numMacroRows+";\n");

      local String sVarAmt <= _script.allocTmpVarInt(_out, "mac_amt");
      _out.append(sVarAmt+" = ("+sVarPos+" & "+FX_FRAC+");\n");

      local String sVarIdx  <= _script.allocTmpVarInt32(_out, "mac_idx");
      _out.append(sVarIdx+" = ("+sVarPos+" >> "+FX_SHR+") * "+numMacroFields+";\n");

      local String sVarIdxN <= _script.allocTmpVarInt32(_out, "mac_idx_n");
      float l2 = log(numMacroValues) / log(2.0);
      if(l2 == int(l2))
         _out.append(sVarIdxN+" = ("+sVarIdx+" + "+numMacroFields+") & "+(numMacroValues-1)+";\n");
      else
         _out.append(sVarIdxN+" = ("+sVarIdx+" + "+numMacroFields+") % "+numMacroValues+";\n");

      // Lerp fields
      StringArray fieldNames <= macro_ref.field_names;
      local String *sMacroVarName;
      local String sMacroValuesName <= "macrovalues_"+macro_ref.id;
      int fieldIdx = 0;
      loop(numMacroFields)
      {
         sMacroVarName <= (b_plugin?"voice->":"")+"macrovar_"+macro_ref.id+"_"+fieldNames.get(fieldIdx)+export_c_prefix;
         _out.append(sMacroVarName+" = "+sMacroValuesName+"["+sVarIdx+"] + ");
         if(b_export_c)
            _out.append("((mulsw("+sMacroValuesName+"["+sVarIdxN+" + "+fieldIdx+"] - "+sMacroValuesName+"["+sVarIdx+" + "+fieldIdx+"], "+sVarAmt+") >> "+FX_SHR+");\n");
         else
            _out.append("((("+sMacroValuesName+"["+sVarIdxN+" + "+fieldIdx+"] - "+sMacroValuesName+"["+sVarIdx+" + "+fieldIdx+"]) * "+sVarAmt+") >> "+FX_SHR+");\n");
         fieldIdx++;
      }

      _script.freeTmpVarInt32(sVarIdx);
      _script.freeTmpVarInt32(sVarIdxN);

      _script.freeTmpVarInt(sVarPos);
      _script.freeTmpVarInt(sVarAmt);
   }
}


// <class.png>
class CyModuleMacroVar : CyModule {
   String macro_id;
   String field_name;

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method_get.png>
   public virtual getString() : String {
      return macro_id+"."+field_name;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         _out.append(_sDstVar+" = voice->macrovar_"+macro_id+"_"+field_name+";\n");
      }
      else
      {
         if(b_export_c)
            _out.append(_sDstVar+" = macrovar_"+macro_id+"_"+field_name+export_c_prefix+";\n");
         else
            _out.append(_sDstVar+" = macrovar_"+macro_id+"_"+field_name+";\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(parent_script.b_use_int_module)
      {
         // within "int" sub-tree, macro vars are actually floats
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }
      // (note) simply copy value as-is (contains no float-specific ops)
      emitFloat(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleMap : CyModule {
   // read value from map (previous output value is row key)
   CyMap *map_ref;
   int    field_idx;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("mode", 0.0f, 0.0f, 1.0f);  // 0=nearest 1=match 2=up 3=down 4=ipl/lin  (must be const)
      addInput("def",  0.0f, 0.0f, 1.0f);  // default value (when connected, use this when no row key fits)
      addInput("ipld", 0.0f, 0.0f, 1.0f);  // when connected, distort linear key interpolation (in=0..1, out=0..1) (float only)

      addInputAlias("m", "mode");
   }

   // <method_get.png>
   public virtual getInputConstants(String _input, StringArray _retNames, FloatArray _retValues) : boolean {
      switch(_input)
      {
         case "mode":
            _retNames  = ["nearest", "match", "up", "down", "ipl", "lin"];
            _retValues = [ 0,         1,       2,    3 ,     4      4   ];
            return true;
      }
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inMode <= findInputById("mode");
      local CyInput inDef  <= findInputById("def");
      local CyInput inIpld <= findInputById("ipld");

      local int     iMode = inMode.getConstVal();
      local boolean bDef  = inDef.isConnected();

      local int numMapRows   = map_ref.getNumMapRows();
      local int numMapFields = map_ref.getNumMapFields();
      local int numMapValues = map_ref.getNumMapValues();

      if(0 == numMapRows)
      {
         trace "[~~~] CyModuleMap<float>: map \""+map_ref.id+"\" has no rows";
         return;
      }

      local StringArray fieldNames       <= map_ref.field_names;
      local String      sMapValuesName   <= "mapvalues_"+map_ref.id;
      local String      sMapKeysName     <= "mapkeys_"+map_ref.id;
      local String      sMapDeltaLinName <= "mapdeltalin_"+map_ref.id;

      local String sVarIdx      <= _script.allocTmpVarInt(_out, "idx");
      local String sVarFieldIdx <= _script.allocTmpVarInt(_out, "field_idx");

      local String sIndent;

      _out.append(sVarIdx+" = "+map_ref.num_rows+";\n");

      switch(iMode)
      {
         default:
         case 0:  // nearest
            if(numMapRows < 2)
               _out.append(_sDstVar+" = "+sMapValuesName+"["+field_idx+"/*"+fieldNames.get(field_idx)+"*/];\n");
            else
            {
               _out.append("if("+_sDstVar+" > "+FloatToString(map_ref.row_key_min)+")\n");
               _out.append("{\n");
               _out.append("   if("+_sDstVar+" < "+FloatToString(map_ref.row_key_max)+")\n");
               _out.append("   {\n");
               _out.append("      "+sVarFieldIdx+" = "+(((numMapRows-2) * numMapFields) + field_idx)+"/*"+fieldNames.get(field_idx)+"*/;\n");
               _out.append("      for("+sVarIdx+" = "+(numMapRows-2)+"; "+sVarIdx+" >= 0; "+sVarIdx+"--)\n");
               _out.append("      {\n");
               _out.append("         if("+_sDstVar+" > "+sMapKeysName+"["+sVarIdx+"])\n");
               _out.append("         {\n");
               _out.append("            if( ("+sMapKeysName+"["+sVarIdx+" + 1] - "+_sDstVar+") > ("+_sDstVar+" - "+sMapKeysName+"["+sVarIdx+"]) )\n");
               _out.append("            {\n");
               _out.append("               "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
               _out.append("            }\n");
               _out.append("            else\n");
               _out.append("            {\n");
               _out.append("               "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+" + "+numMapFields+"];\n");
               _out.append("            }\n");
               _out.append("         }\n");
               _out.append("         "+sVarFieldIdx+" -= "+numMapFields+";\n");
               _out.append("      }\n");
               _out.append("   }\n");
               _out.append("   else\n");
               _out.append("   {\n");
               _out.append("      "+_sDstVar+" = "+sMapValuesName+"["+((numMapRows-1) * numMapFields)+" + "+field_idx+"/*"+fieldNames.get(field_idx)+"*/];\n");  // clamp to max
               _out.append("   }\n");
               _out.append("}\n");
               _out.append("else\n");
               _out.append("{\n");
               _out.append("   "+_sDstVar+" = "+sMapValuesName+"["+field_idx+"/*"+fieldNames.get(field_idx)+"*/];\n");  // clamp to min
               _out.append("}\n");
            }
            break;

         case 1:  // match
            _out.append(sVarFieldIdx+" = "+field_idx+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("if("+_sDstVar+" >= "+FloatToString(map_ref.row_key_min)+" && "+_sDstVar+" <= "+FloatToString(map_ref.row_key_max)+")\n");
            _out.append("{\n");
            _out.append("   for("+sVarIdx+" = 0; "+sVarIdx+" < "+numMapRows+"; "+sVarIdx+"++)\n");
            _out.append("   {\n");
            if(b_plugin)
               _out.append("      if(Dstplugin_fltequal("+sMapKeysName+"["+sVarIdx+"], "+_sDstVar+"))\n");
            else
               _out.append("      if("+sMapKeysName+"["+sVarIdx+"] == "+_sDstVar+")\n");
            _out.append("      {\n");
            _out.append("         "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("      "+sVarFieldIdx+" += "+numMapFields+";\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: does not match any map key
            break;

         case 2:  // up
            _out.append(sVarIdx+" = "+map_ref.num_rows+";\n");
            _out.append(sVarFieldIdx+" = "+field_idx+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("if("+_sDstVar+" <= "+FloatToString(map_ref.row_key_min)+")\n");  // before first ?
            _out.append("{\n");  // round up to first
            _out.append("   "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n"); // round up to first
            if(bDef)
               _out.append("   "+sVarIdx+" = 0;\n");  // don't emit def
            _out.append("}\n");
            _out.append("else if("+_sDstVar+" <= "+FloatToString(map_ref.row_key_max)+")\n");
            _out.append("{\n");
            _out.append("   for("+sVarIdx+" = 1; "+sVarIdx+" < "+numMapRows+"; "+sVarIdx+"++)\n");
            _out.append("   {\n");
            _out.append("      "+sVarFieldIdx+" += "+numMapFields+";\n");
            _out.append("      if("+_sDstVar+" <= "+sMapKeysName+"["+sVarIdx+"])\n");
            _out.append("      {\n");
            _out.append("         "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: above row_key_max
            break;

         case 3:  // down
            _out.append("if("+_sDstVar+" >= "+FloatToString(map_ref.row_key_min)+")\n");
            _out.append("{\n");
            _out.append("   "+sVarFieldIdx+" = "+(((numMapRows-1) * numMapFields)+field_idx)+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("   for("+sVarIdx+" = "+(numMapRows -1)+"; "+sVarIdx+" >= 0; "+sVarIdx+"--)\n");
            _out.append("   {\n");
            _out.append("      if("+_sDstVar+" >= "+sMapKeysName+"["+sVarIdx+"])\n");
            _out.append("      {\n");
            _out.append("         "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("      "+sVarFieldIdx+" -= "+numMapFields+";\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: below row_key_min
            if(bDef)
            {
               _out.append("else\n");
               _out.append("   "+sVarIdx+" = "+map_ref.num_rows+";\n");
            }
            break;

         case 4:  // ipl/lin
            _out.append("if("+_sDstVar+" >= "+FloatToString(map_ref.row_key_min)+")\n");
            _out.append("{\n");
            _out.append("   "+sVarFieldIdx+" = "+(((numMapRows-1) * numMapFields)+field_idx)+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("   for("+sVarIdx+" = "+(numMapRows -1)+"; "+sVarIdx+" >= 0; "+sVarIdx+"--)\n");
            _out.append("   {\n");
            _out.append("      if("+_sDstVar+" >= "+sMapKeysName+"["+sVarIdx+"])\n");
            _out.append("      {\n");
            sIndent.empty();
            local String sVarN <= _script.allocTmpVar(sIndent, "map_n");
            _out.append("         "+sIndent);
            _out.append("         "+sVarN+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         if(("+sVarIdx+" + 1) < "+numMapRows+")\n");
            _out.append("         {\n");
            if(inIpld.isConnected())
            {
               // // local String sVarIpld <= _script.allocTmpVar(sIndent, "map_ipld");
               _out.append("            "+_sDstVar+" = (("+_sDstVar+" - "+sMapKeysName+"["+sVarIdx+"]) * "+sMapDeltaLinName+"["+sVarIdx+"]);\n");
               sIndent.empty();
               inIpld.emitFloat(_script, sIndent, _sDstVar);
               CyScript.AppendIndentedLines(_out, sIndent, 12);
               _out.append("            "+_sDstVar+" = "+sVarN+" + ("+sMapValuesName+"["+sVarFieldIdx+" + "+numMapFields+"] - "+sVarN+") * "+_sDstVar+";\n");
            }
            else
            {
               // linear
               _out.append("            "+_sDstVar+" = "+sVarN+" + ("+sMapValuesName+"["+sVarFieldIdx+" + "+numMapFields+"] - "+sVarN+") * (("+_sDstVar+" - "+sMapKeysName+"["+sVarIdx+"]) * "+sMapDeltaLinName+"["+sVarIdx+"]);\n");
            }
            _script.freeTmpVar(sVarN);
            _out.append("         }\n");
            _out.append("         else\n");
            _out.append("            "+_sDstVar+" = "+sVarN+";\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("      "+sVarFieldIdx+" -= "+numMapFields+";\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: below row_key_min
            if(bDef)
            {
               _out.append("else\n");
               _out.append("   "+sVarIdx+" = "+map_ref.num_rows+";\n");
            }
            break;
      } // switch mode

      if(bDef)
      {
         _out.append("if("+sVarIdx+" == "+map_ref.num_rows+")\n");
         _out.append("{\n");
         sIndent.empty();
         inDef.emitFloat(_script, sIndent, _sDstVar);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("}\n");
      }

      _script.freeTmpVarInt(sVarIdx);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(parent_script.b_use_int_module)
      {
         // within "int" sub-tree, map vars are actually floats
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      local CyInput inMode <= findInputById("mode");
      local CyInput inDef  <= findInputById("def");

      local int     iMode = inMode.getConstVal();
      local boolean bDef  = inDef.isConnected();

      local int numMapRows   = map_ref.getNumMapRows();
      local int numMapFields = map_ref.getNumMapFields();
      local int numMapValues = map_ref.getNumMapValues();

      if(0 == numMapRows)
      {
         trace "[~~~] CyModuleMap<int>: map \""+map_ref.id+"\" has no rows";
         return;
      }

      local StringArray fieldNames       <= map_ref.field_names;
      local String      sMapValuesName   <= "mapvalues_"+map_ref.id;
      local String      sMapKeysName     <= "mapkeys_"+map_ref.id;
      local String      sMapDeltaLinName <= "mapdeltalin_"+map_ref.id;

      local String sVarIdx      <= _script.allocTmpVarInt(_out, "idx");
      local String sVarFieldIdx <= _script.allocTmpVarInt(_out, "field_idx");

      local String sIndent;

      _out.append(sVarIdx+" = "+map_ref.num_rows+";\n");

      switch(iMode)
      {
         default:
         case 1:  // match
            _out.append(sVarFieldIdx+" = "+field_idx+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("if("+_sDstVar+" >= "+int(FX_ONE * map_ref.row_key_min)+" && "+_sDstVar+" <= "+int(FX_ONE * map_ref.row_key_max)+")\n");
            _out.append("{\n");
            _out.append("   for("+sVarIdx+" = 0; "+sVarIdx+" < "+numMapRows+"; "+sVarIdx+"++)\n");
            _out.append("   {\n");
            _out.append("      if("+sMapKeysName+"["+sVarIdx+"] == "+_sDstVar+")\n");
            _out.append("      {\n");
            _out.append("         "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("      "+sVarFieldIdx+" += "+numMapFields+";\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: does not match any map key
            break;

         case 2:  // up
            _out.append(sVarIdx+" = "+map_ref.num_rows+";\n");
            _out.append(sVarFieldIdx+" = "+field_idx+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("if("+_sDstVar+" <= "+int(FX_ONE * map_ref.row_key_min)+")\n");  // before first ?
            _out.append("{\n");  // round up to first
            _out.append("   "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n"); // round up to first
            if(bDef)
               _out.append("   "+sVarIdx+" = 0;\n");  // don't emit def
            _out.append("}\n");
            _out.append("else if("+_sDstVar+" <= "+int(FX_ONE * map_ref.row_key_max)+")\n");
            _out.append("{\n");
            _out.append("   for("+sVarIdx+" = 1; "+sVarIdx+" < "+numMapRows+"; "+sVarIdx+"++)\n");
            _out.append("   {\n");
            _out.append("      "+sVarFieldIdx+" += "+numMapFields+";\n");
            _out.append("      if("+_sDstVar+" <= "+sMapKeysName+"["+sVarIdx+"])\n");
            _out.append("      {\n");
            _out.append("         "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: above row_key_max
            break;

         case 3:  // down
            _out.append("if("+_sDstVar+" >= "+int(FX_ONE * map_ref.row_key_min)+")\n");
            _out.append("{\n");
            _out.append("   "+sVarFieldIdx+" = "+(((numMapRows-1) * numMapFields)+field_idx)+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("   for("+sVarIdx+" = "+(numMapRows -1)+"; "+sVarIdx+" >= 0; "+sVarIdx+"--)\n");
            _out.append("   {\n");
            _out.append("      if("+_sDstVar+" >= "+sMapKeysName+"["+sVarIdx+"])\n");
            _out.append("      {\n");
            _out.append("         "+_sDstVar+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("      "+sVarFieldIdx+" -= "+numMapFields+";\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: below row_key_min
            if(bDef)
            {
               _out.append("else\n");
               _out.append("   "+sVarIdx+" = "+map_ref.num_rows+";\n");
            }
            break;

         case 4:  // lin
            _out.append("if("+_sDstVar+" >= "+int(FX_ONE * map_ref.row_key_min)+")\n");
            _out.append("{\n");
            _out.append("   "+sVarFieldIdx+" = "+(((numMapRows-1) * numMapFields)+field_idx)+"/*"+fieldNames.get(field_idx)+"*/;\n");
            _out.append("   for("+sVarIdx+" = "+(numMapRows -1)+"; "+sVarIdx+" >= 0; "+sVarIdx+"--)\n");
            _out.append("   {\n");
            _out.append("      if("+_sDstVar+" >= "+sMapKeysName+"["+sVarIdx+"])\n");
            _out.append("      {\n");
            sIndent.empty();
            local String sVarN <= _script.allocTmpVarInt(sIndent, "map_n");
            _out.append("         "+sIndent);
            _out.append("         "+sVarN+" = "+sMapValuesName+"["+sVarFieldIdx+"];\n");
            _out.append("         if(("+sVarIdx+" + 1) < "+numMapRows+")\n");
            _out.append("         {\n");
            _out.append("            "+_sDstVar+" = "+sVarN+" + Dmulsw_shr("+sMapValuesName+"["+sVarFieldIdx+" + "+numMapFields+"] - "+sVarN+", Dmulsw_shr(("+_sDstVar+" - "+sMapKeysName+"["+sVarIdx+"]), "+sMapDeltaLinName+"["+sVarIdx+"]));\n");
            _script.freeTmpVarInt(sVarN);
            _out.append("         }\n");
            _out.append("         else\n");
            _out.append("            "+_sDstVar+" = "+sVarN+";\n");
            _out.append("         break;\n");
            _out.append("      }\n");
            _out.append("      "+sVarFieldIdx+" -= "+numMapFields+";\n");
            _out.append("   }\n");
            _out.append("}\n");
            // else: below row_key_min
            if(bDef)
            {
               _out.append("else\n");
               _out.append("   "+sVarIdx+" = "+map_ref.num_rows+";\n");
            }
            break;
      } // switch mode

      if(bDef)
      {
         _out.append("if("+sVarIdx+" == "+map_ref.num_rows+")\n");
         _out.append("{\n");
         sIndent.empty();
         inDef.emitInt(_script, sIndent, _sDstVar);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("}\n");
      }

      _script.freeTmpVarInt(sVarIdx);
   }
}


// <class.png>
class CyModuleNote : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
         _out.append(_sDstVar+" = voice->note_cur;\n");
      else
         _out.append(_sDstVar+" = 60.0f;\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
         _out.append(_sDstVar+" = voice->note_cur * "+FX_ONE+";\n");  // overflows after first octave
      else
         _out.append(_sDstVar+" = "+((60 * FX_ONE) & 65535)+";\n");
   }
}


// <class.png>
class CyModulePluginParam : CyModuleVar {

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local String sBaseId <= var_ref.getBaseId();
         _out.append(_sDstVar+" = shared->params[PARAM_"+(sBaseId.toUpper())+"]"+var_ref.getScaleAddString()+";\n");
      }
      else
      {
         if(b_export_c)
            _out.append(_sDstVar+" = param_"+var_ref.id+export_c_prefix+";\n");
         else
            _out.append(_sDstVar+" = param_"+var_ref.id+";\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // (plugin-)params are always floats
      emitFloatFallback(_script, _out, _sDstVar);
      // // // _out.append(_sDstVar+" = param_"+var_ref.id+export_c_prefix+";\n");
   }

}


// <class.png>
class CyModulePluginMod : CyModuleVar {

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         local String sBaseId <= var_ref.getBaseId();
         _out.append(_sDstVar+" = voice->mod_"+sBaseId+"_cur;\n");
      }
      else
      {
         if(b_export_c)
            _out.append(_sDstVar+" = mod_"+var_ref.id+export_c_prefix+";\n");
         else
            _out.append(_sDstVar+" = mod_"+var_ref.id+";\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // (plugin-)mods are always floats
      emitFloatFallback(_script, _out, _sDstVar);
      // // // _out.append(_sDstVar+" = mod_"+var_ref.id+export_c_prefix+";\n");
   }

}


// <class.png>
class CyModuleSta : CyModule {
   CyLUT  *lut_ref;
   float   index_mul;
   float   index_add;
   CyVar  *var_ref;
   float   var_mul;
   float   var_add;

   // <method_get.png>
   public virtual getString() : String {
      return "sta "+lut_ref.id+" "+index_mul+" "+index_add+" "+var_ref.id+" "+var_mul+" "+var_add;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local String sLUT <= lut_ref.getLUTString(b_plugin);
      local String sUITypeCast <= b_export_c ? "(unsigned int)" : "(int)";
      local String sVar <= var_ref.getVarString(b_plugin, b_export_c);

      local String sIndexExpr;
      if(index_mul != 1.0f)
         sIndexExpr.append(" * "+FloatToString(index_mul));
      if(index_add != 0.0f)
         sIndexExpr.append(" + "+FloatToString(index_add));

      local String sVarExpr;
      if(var_mul != 1.0f)
         sVarExpr.append(" * "+FloatToString(var_mul));
      if(var_add != 0.0f)
         sVarExpr.append(" + "+FloatToString(var_add));

      _out.append(sLUT+"[("+sUITypeCast+"(("+_sDstVar+sIndexExpr+") * "+(lut_ref.lut_w/*-1*/)+")) & "+(lut_ref.lut_w-1)+"] = "+sVar+sVarExpr+";\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local String sLUT <= lut_ref.getLUTString(b_plugin);
      local String sUITypeCast <= b_export_c ? "(unsigned int)" : "(int)";
      local String sVar <= var_ref.getVarString(b_plugin, b_export_c);

      local String *sIdx;
      local String sVal;
      int lutSzMask = lut_ref.lut_w - 1;
      if(parent_script.b_use_int_module)
      {
         // within "int" sub-tree, vars and luts are actually floats

         // (todo) combine index_mul/lut_ref.lut_w factors when index_add=0
         sIdx <= "("+_sDstVar;
         if(1.0f != index_mul)
            sIdx.append(" * "+FloatToString(index_mul));
         if(0.0f != index_add)
            sIdx.append(" + "+FloatToString(index_add));
         sIdx.append(")");

         sVal = sVar;
         if(1.0f != var_mul)
            sVal.append(" * "+FloatToString(var_mul));
         if(0.0f != var_add)
            sVal.append(" + "+FloatToString(var_add));

         _out.append(sLUT+"[("+sUITypeCast+"("+sIdx+" * "+lut_ref.lut_w/*-1*/+")) & "+lutSzMask+"] = "+sVal+";\n");
      }
      else
      {
         // (todo) combine index_mul/lut_ref.lut_w factors when index_add=0
         sIdx <= "(";
         sIdx.append("Dmulsw_shr("+_sDstVar+", "+int(index_mul * FX_ONE)+")");
         sIdx.append(" + "+int(index_add * FX_ONE));
         sIdx.append(")");

         if(1.0f != var_mul)
            sVal.append("Dmulsw_shr("+sVar+", "+int(var_mul * FX_ONE)+")");
         else
            sVal.append(sVar);
         if(0.0f != var_add)
            sVal.append(" + "+int(var_add * FX_ONE));

         _out.append(sLUT+"[("+sUITypeCast+"(("+sIdx+" * "+lut_ref.lut_w/*-1*/+") >> "+FX_SHR+")) & "+lutSzMask+"] = "+sVal+";\n");
      }
   }
}


// <class.png>
class CyModuleSto : CyModule {
   CyVar *var_ref;

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method_get.png>
   public virtual getString() : String {
      return "sto "+var_ref.id;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_plugin)
      {
         if(var_ref.b_smooth)
            _out.append("voice->var_"+var_ref.id+"_next"+export_c_prefix+" = "+_sDstVar+";\n");
         else
            _out.append("voice->var_"+var_ref.id+export_c_prefix+" = "+_sDstVar+";\n");
      }
      else
      {
         if(b_export_c)
            _out.append("var_"+var_ref.id+export_c_prefix+" = "+_sDstVar+";\n");
         else
            _out.append("var_"+var_ref.id+" = "+_sDstVar+";\n");
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(parent_script.b_use_int_module)
      {
         // within "int" sub-tree, vars are actually floats
         _out.append("var_"+var_ref.id+export_c_prefix+" = "+_sDstVar+" * "+(1.0f / FX_ONE)+";\n");
      }
      else
         _out.append("var_"+var_ref.id+export_c_prefix+" = "+_sDstVar+";\n");
   }
}


// <class.png>
class CyModuleInc : CyModule {
   define int MODE_SET = 0;
   define int MODE_INC = 1;
   define int MODE_DEC = 2;
   define int MODE_MUL = 3;
   define int MODE_NOT = 4;
   CyVar *var_ref;
   int mode;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      switch(mode)
      {
         case MODE_SET:
            addInput("value",  1.0, -16, 16.0);
            addInputAlias("v", "value");
            break;

         case MODE_INC:
         case MODE_DEC:
            addInput("delta",  1.0, -16, 16.0);
            addInputAlias("d", "delta");
            break;

         case MODE_MUL:
            addInput("factor", 1.0, -16, 16.0);
            addInputAlias("f", "factor");
            break;
      }
   }

   // <method_get.png>
   public virtual getString() : String {
      switch(mode)
      {
         case MODE_SET:
            return "set "+var_ref.id;

         case MODE_INC:
            return "inc "+var_ref.id;

         case MODE_DEC:
            return "dec "+var_ref.id;

         case MODE_MUL:
            return "mul "+var_ref.id;

         case MODE_NOT:
            return "dec "+var_ref.id;
      }
   }

   // <method_get.png>
   public method getModeString() : String {
      switch(mode)
      {
         case MODE_SET:
            return "set";

         case MODE_INC:
            return "inc";

         case MODE_DEC:
            return "dec";

         case MODE_MUL:
            return "mul";

         case MODE_NOT:
            return "not";
      }
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      if(MODE_NOT == mode)
      {
         local String *sNotVarDst;
         local String *sNotVarSrc;
         if(b_plugin)
         {
            if(var_ref.b_smooth)
            {
               sNotVarDst <= "voice->var_"+var_ref.id+"_next"+export_c_prefix;
               sNotVarSrc <= "voice->var_"+var_ref.id+export_c_prefix;
            }
            else
            {
               sNotVarDst <= "voice->var_"+var_ref.id+export_c_prefix;
               sNotVarSrc <= sNotVarDst;
            }
         }
         else
         {
            if(b_export_c)
               sNotVarDst <= "var_"+var_ref.id+export_c_prefix;
            else
               sNotVarDst <= "var_"+var_ref.id;
            sNotVarSrc <= sNotVarDst;
         }

         _out.append(sNotVarDst+" = ("+sNotVarSrc+" > 0.0f) ? 0.0f : 1.0f;\n");
         return;
      }

      local String *sOp;
      switch(mode)
      {
         case MODE_SET:
            sOp <= "=";
            break;

         case MODE_INC:
            sOp <= "+=";
            break;

         case MODE_DEC:
            sOp <= "-=";
            break;

         case MODE_MUL:
            sOp <= "*=";
            break;
      }

      local CyInput inDelta <= findInputById( (MODE_SET == mode) ? "value" : (MODE_MUL == mode) ? "factor" : "delta" );

      local String *sVarDstPlugin;
      local String *sVarSrcPlugin;
      if(b_plugin)
      {
         if(var_ref.b_smooth)
         {
            sVarDstPlugin <= "voice->var_"+var_ref.id+"_next"+export_c_prefix;
            sVarSrcPlugin <= "voice->var_"+var_ref.id+export_c_prefix;
         }
         else
         {
            sVarDstPlugin <= "voice->var_"+var_ref.id+export_c_prefix;
            sVarSrcPlugin <= sVarDstPlugin;
         }
      }

      if(!inDelta.isConnected())
      {
         // Set variable to previous output value
         if(b_plugin)
         {
            if(var_ref.b_smooth)
            {
               switch(mode)
               {
                  case MODE_SET:
                     _out.append(sVarDstPlugin+" = "+_sDstVar+";\n");
                     break;

                  case MODE_INC:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" + "+_sDstVar+";\n");
                     break;

                  case MODE_DEC:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" - "+_sDstVar+";\n");
                     break;

                  case MODE_MUL:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" * "+_sDstVar+";\n");
                     break;
               }
            }
            else
            {
               _out.append(sVarDstPlugin+" "+sOp+" "+_sDstVar+";\n");
            }
         }
         else
         {
            if(b_export_c)
               _out.append("var_"+var_ref.id+export_c_prefix+" "+sOp+" "+_sDstVar+";\n");
            else
               _out.append("var_"+var_ref.id+" "+sOp+" "+_sDstVar+";\n");
         }
      }
      else if(inDelta.isConstVal())
      {
         float fDelta = inDelta.getConstVal();
         if(b_plugin)
         {
            if(var_ref.b_smooth)
            {
               switch(mode)
               {
                  case MODE_SET:
                     _out.append(sVarDstPlugin+" = "+_sDstVar+";\n");
                     break;

                  case MODE_INC:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" + "+_sDstVar+";\n");
                     break;

                  case MODE_DEC:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" - "+_sDstVar+";\n");
                     break;

                  case MODE_MUL:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" * "+_sDstVar+";\n");
                     break;
               }
            }
            else
            {
               _out.append(sVarDstPlugin+" "+sOp+" "+fDelta+";\n");
            }
         }
         else
         {
            if(b_export_c)
               _out.append("var_"+var_ref.id+export_c_prefix+" "+sOp+" "+fDelta+";\n");
            else
               _out.append("var_"+var_ref.id+" "+sOp+" "+fDelta+";\n");
         }
      }
      else
      {
         local String sVarDelta <= _script.allocTmpVar(_out, "delta");
         _out.append(sVarDelta+" = "+_sDstVar+";\n");
         inDelta.emitFloat(_script, _out, sVarDelta);
         if(b_plugin)
         {
            if(var_ref.b_smooth)
            {
               switch(mode)
               {
                  case MODE_SET:
                     _out.append(sVarDstPlugin+" = "+sVarDelta+";\n");
                     break;

                  case MODE_INC:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" + "+sVarDelta+";\n");
                     break;

                  case MODE_DEC:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" - "+sVarDelta+";\n");
                     break;

                  case MODE_MUL:
                     _out.append(sVarDstPlugin+" = "+sVarSrcPlugin+" * "+sVarDelta+";\n");
                     break;
               }
            }
            else
            {
               _out.append(sVarDstPlugin+" "+sOp+" "+sVarDelta+";\n");
            }
         }
         else
         {
            if(b_export_c)
               _out.append("var_"+var_ref.id+export_c_prefix+" "+sOp+" "+sVarDelta+";\n");
            else
               _out.append("var_"+var_ref.id+" "+sOp+" "+sVarDelta+";\n");
         }
         _script.freeTmpVar(sVarDelta);
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      if(parent_script.b_use_int_module)
      {
         // within "int" sub-tree, vars are actually floats
         emitFloatFallback(_script, _out, _sDstVar);
         return;
      }

      // special case: "not <var>"
      if(MODE_NOT == mode)
      {
         local String *sNotVar;
         if(b_export_c)
            sNotVar <= "var_"+var_ref.id+export_c_prefix;
         else
            sNotVar <= "var_"+var_ref.id;

         _out.append(sNotVar+" = ("+sNotVar+" > 0) ? 0 : "+FX_ONE+";\n");
         return;
      }

      // new output = previous output combined with rhs value
      String *sOp;
      switch(mode)
      {
         case MODE_SET:
            sOp <= "=";
            break;

         case MODE_INC:
            sOp <= "+=";
            break;

         case MODE_DEC:
            sOp <= "-=";
            break;

         // case MODE_MUL:
         //    sOp <= "*=";
         //    break;
      }

      local CyInput inDelta <= findInputById( (MODE_SET == mode) ? "value" : (MODE_MUL == mode) ? "factor" : "delta" );

      if(!inDelta.isConnected())
      {
         // Set variable to previous output value
         if(MODE_MUL == mode)
            _out.append("var_"+var_ref.id+export_c_prefix+" = Dmuls_shr(var_"+var_ref.id+export_c_prefix+", "+_sDstVar+");\n");
         else
            _out.append("var_"+var_ref.id+export_c_prefix+" "+sOp+" "+_sDstVar+";\n");
      }
      else if(inDelta.isConstVal())
      {
         float fDelta = inDelta.getConstVal();
         if(MODE_MUL == mode)
            _out.append("var_"+var_ref.id+export_c_prefix+" = Dmuls_shr(var_"+var_ref.id+export_c_prefix+", "+int(FX_ONE * fDelta)+");\n");
         else
            _out.append("var_"+var_ref.id+export_c_prefix+" "+sOp+" "+int(FX_ONE * fDelta)+";\n");
      }
      else
      {
         local String sVarDelta <= _script.allocTmpVarInt(_out, "delta");
         _out.append(sVarDelta+" = "+_sDstVar+";\n");
         inDelta.emitInt(_script, _out, sVarDelta);
         if(MODE_MUL == mode)
            _out.append("var_"+var_ref.id+export_c_prefix+" = Dmuls_shr(var_"+var_ref.id+export_c_prefix+", "+sVarDelta+");\n");
         else
            _out.append("var_"+var_ref.id+export_c_prefix+" "+sOp+" "+sVarDelta+";\n");
         _script.freeTmpVarInt(sVarDelta);
      }
   }
}


// <class.png>
class CyModuleTan : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_export_c)
         _out.append(_sDstVar+" = tanf("+_sDstVar+");\n");
      else
         _out.append(_sDstVar+" = tan("+_sDstVar+");\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleTan<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleTanh : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      if(b_export_c)
         _out.append(_sDstVar+" = tanhf("+_sDstVar+");\n");
      else
         _out.append(_sDstVar+" = tanh("+_sDstVar+");\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      trace "[~~~] warning: CyModuleTanh<int>: falling back to float..";
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleZlp : CyModule {
   int zone_idx;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("rate",  1.0, 0.125, 15.0);
      addInput("phase", 0.0, 0.0,   1.0);
      addInput("div",   0.0, 0.0,   256.0);  // set repeatlen to zonelen/div. must be const.
      addInput("sub",   0.0, 0.0,   256.0);  // multiply repeatlen * sub and add to start offset. requires 'div'. const or dynamic.
      addInput("lin",   0,   0,     1);      // const

      addInputAlias("r",  "rate");
      addInputAlias("ph", "phase");
      addInputAlias("d",  "div");
      addInputAlias("s",  "sub");
      addInputAlias("l",  "lin");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      StSample s <= _script.findZoneSampleByIndex(zone_idx);
      if(null == s)
         return false;
      int numSmpFrames = s.lastLoopLen;  // should be a power of two

      local String *sSmpDat;
      if(b_plugin)
      {
         Sample parentSample <= _script.findZoneParentSampleByIndex(zone_idx);
         CyPluginWaveformRef waveRef <= _script.addUniquePluginWaveformRef(parentSample, s);
         sSmpDat <= waveRef.getExportedZoneVarName(s);
      }
      else
      {
         sSmpDat <= "zone_smp_"+zone_idx;
      }

      local String sInit;
      local String *sVarPos;
      local String *sVarSubOff;
      local int subOff = 0;  // absolute frame offset added via 'sub' input (when connected)
      int repSmpFrames = numSmpFrames;

      local CyInput inRate <= findInputById("rate");
      local float fRate;
      local boolean bConstRate = inRate.isConstVal();
      if(bConstRate)
         fRate = inRate.getConstVal();

      local CyInput inPhase <= findInputById("phase");
      local boolean bConstPhase = inPhase.isConstVal();
      if(bConstPhase)
      {
         float fPhase = mathWrapf(inPhase.getConstVal(), 0, 1.0f);
         fPhase *= numSmpFrames;
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "zlp_pos", int(fPhase * 65536), true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      else
      {
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "zlp_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      }

      local CyInput inDiv <= findInputById("div");
      local String *sSubOff;
      if(inDiv.isConnected())
      {
         trace "[trc] Cycle::CyModuleZlp<float>: numSmpFrames="+numSmpFrames+" div="+int(inDiv.getConstVal())+" => repSmpFrames="+repSmpFrames;
         repSmpFrames = numSmpFrames / int(inDiv.getConstVal());
         if(repSmpFrames > numSmpFrames)
            repSmpFrames = numSmpFrames;

         local CyInput inSub <= findInputById("sub");
         if(inSub.isConstVal())
         {
            subOff = int(inSub.getConstVal() * repSmpFrames);
            if( (subOff + repSmpFrames) > numSmpFrames )
               subOff = (numSmpFrames - repSmpFrames);
            if(subOff < 0)
               subOff = 0;
         }
         else
         {
            local String sVarSubOffF <= _script.allocTmpVar(_out, "zlp_sub_off_f");
            inSub.emitFloat(_script, _out, sVarSubOffF);
            sVarSubOff <= _script.allocTmpVarInt32(_out, "zlp_sub_off");
            _out.append(sVarSubOff+" = (int)("+sVarSubOffF+" * "+repSmpFrames+");\n");
            _out.append("if(("+sVarSubOff+" + "+repSmpFrames+") > "+numSmpFrames+")\n");
            _out.append("   "+sVarSubOff+" = "+(numSmpFrames - repSmpFrames)+";\n");
            _out.append("else if("+sVarSubOff+" < 0)\n");
            _out.append("   "+sVarSubOff+" = 0;\n");
            sSubOff <= sVarSubOff;
            _script.freeTmpVar(sVarSubOffF);
         }
      }
      if(null == sSubOff)
         sSubOff <= String(subOff);

      // trace "xxx zlp: repSmpFrames="+repSmpFrames;

      int repLenMask = mathClampi(repSmpFrames - 1, 0, 65535);

      _script.appendInit(sInit);

      local CyInput inLin <= findInputById("lin");
      boolean bLinear = (inLin.getConstVal() >= 0.5);
      local String *sVarNext;
      if(bLinear)
         sVarNext <= _script.allocTmpVar(_out, "zlp_smp_next");

      if(bConstPhase)
      {
         // Constant phase
         if(bLinear)
         {
            // Linear filtering
            if(b_export_c)
            {
               _out.append(sVarNext+" = "+sSmpDat+"["+sSubOff+"+((("+sVarPos+" >> 16) + 1) & "+repLenMask+")];\n");
               _out.append(_sDstVar+" = "+sSmpDat+"["+sSubOff+"+( ("+sVarPos+" >> 16)      & "+repLenMask+")];\n");
            }
            else
            {
               _out.append(sVarNext+" = "+sSmpDat+".get("+sSubOff+"+((("+sVarPos+" >> 16) + 1) & "+repLenMask+"));\n");
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+( ("+sVarPos+" >> 16)      & "+repLenMask+"));\n");
            }

            _out.append(_sDstVar+" = "+_sDstVar+" + ("+sVarNext+" - "+_sDstVar+") * (("+sVarPos+" & 65535) * (1.0f / 65536.0f));\n");
         }
         else
         {
            // Nearest neighbour
            if(b_export_c)
               _out.append(_sDstVar+" = "+sSmpDat+"["+sSubOff+"+(("+sVarPos+" >> 16) & "+repLenMask+")];\n");
            else
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+(("+sVarPos+" >> 16) & "+repLenMask+"));\n");
         }
      }
      else
      {
         // Dynamic phase
         local String sVarPhase <= _script.allocTmpVar(_out, "phase");
         inPhase.emitFloat(_script, _out, sVarPhase);
         if(bLinear)
         {
            // Linear filtering
            if(b_export_c)
            {
               _out.append(sVarNext+" = "+sSmpDat+"["+sSubOff+"+(((("+sVarPos+" + ("+sVarPhase+" * "+(65536 * repSmpFrames)+")) >> 16) + 1) & "+repLenMask+")];\n");
               _out.append(_sDstVar+" = "+sSmpDat+"["+sSubOff+"+( (("+sVarPos+" + ("+sVarPhase+" * "+(65536 * repSmpFrames)+")) >> 16)      & "+repLenMask+")];\n");
            }
            else
            {
               _out.append(sVarNext+" = "+sSmpDat+".get("+sSubOff+"+(((("+sVarPos+" + ("+sVarPhase+" * "+(65536 * repSmpFrames)+")) >> 16) + 1) & "+repLenMask+"));\n");
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+( (("+sVarPos+" + ("+sVarPhase+" * "+(65536 * repSmpFrames)+")) >> 16)      & "+repLenMask+"));\n");
            }
            _out.append(_sDstVar+" = "+_sDstVar+" + ("+sVarNext+" - "+_sDstVar+") * (("+sVarPos+" & 65535) * (1.0f / 65536.0f));\n");
         }
         else
         {
            // Nearest neighbour
            if(b_export_c)
               _out.append(_sDstVar+" = "+sSmpDat+"["+sSubOff+"+((("+sVarPos+" + ("+sVarPhase+" * "+(65536 * repSmpFrames)+")) >> 16) & "+repLenMask+")];\n");
            else
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+((("+sVarPos+" + ("+sVarPhase+" * "+(65536 * repSmpFrames)+")) >> 16) & "+repLenMask+"));\n");
         }
         _script.freeTmpVar(sVarPhase);
      }

      if(bConstRate)
         _out.append(sVarPos+" += "+int(fRate*65536)+";\n");
      else
      {
         local String sVarRate <= _script.allocTmpVar(_out, "rate");
         inRate.emitFloat(_script, _out, sVarRate);
         _out.append(sVarPos+" += int("+sVarRate+" * 65536);\n");
         _script.freeTmpVar(sVarRate);
      }

      if(null != sVarSubOff)
         _script.freeTmpVarInt32(sVarSubOff);

      if(null != sVarNext)
         _script.freeTmpVar(sVarNext);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      StSample s <= _script.findZoneSampleByIndex(zone_idx);
      if(null == s)
         return false;
      int numSmpFrames = s.lastLoopLen;  // should be a power of two

      local String *sSmpDat;
      if(b_plugin)
      {
         Sample parentSample <= _script.findZoneParentSampleByIndex(zone_idx);
         _script.addUniquePluginWaveformRef(parentSample, s);
         CyPluginWaveformRef waveRef <= _script.addUniquePluginWaveformRef(parentSample, s);
         sSmpDat <= waveRef.getExportedZoneVarName(s);
      }
      else
      {
         sSmpDat <= "zone_smp_"+zone_idx;
      }

      local String sInit;
      local String *sVarPos;
      local String *sVarSubOff;
      local int subOff;  // absolute frame offset added via 'sub' input (when connected)
      int repSmpFrames = numSmpFrames;

      local CyInput inRate <= findInputById("rate");
      local float fRate;
      boolean bConstRate = inRate.isConstVal();
      if(bConstRate)
         fRate = inRate.getConstVal();

      local CyInput inPhase <= findInputById("phase");
      local boolean bConstPhase = inPhase.isConstVal();
      if(bConstPhase)
      {
         float fPhase = mathWrapf(inPhase.getConstVal(), 0, 1.0f);
         fPhase *= numSmpFrames;
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "zlp_pos", int(fPhase * 65536), true/*bCycleReset*/, true/*bVoiceReset*/);
      }
      else
      {
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "zlp_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      }

      local CyInput inDiv <= findInputById("div");
      local String *sSubOff;
      if(inDiv.isConnected())
      {
         repSmpFrames = numSmpFrames / int(inDiv.getConstVal());
         trace "[trc] Cycle::CyModuleZlp<int>: numSmpFrames="+numSmpFrames+" div="+int(inDiv.getConstVal())+" => repSmpFrames="+repSmpFrames;
         if(repSmpFrames > numSmpFrames)
            repSmpFrames = numSmpFrames;

         local CyInput inSub <= findInputById("sub");
         if(inSub.isConstVal())
         {
            subOff = int(inSub.getConstVal() * repSmpFrames);
            if( (subOff + repSmpFrames) > numSmpFrames )
               subOff = (numSmpFrames - repSmpFrames);
            if(subOff < 0)
               subOff = 0;
         }
         else
         {
            local String sVarSubOffX <= _script.allocTmpVarInt(_out, "zlp_sub_off_x");
            inSub.emitInt(_script, _out, sVarSubOffX);
            sVarSubOff <= _script.allocTmpVarInt32(_out, "zlp_sub_off");
            _out.append(sVarSubOff+" = Dmulsw_shr("+sVarSubOffX+", "+repSmpFrames+");\n");
            _out.append("if(("+sVarSubOff+" + "+repSmpFrames+") > "+numSmpFrames+")\n");
            _out.append("   "+sVarSubOff+" = "+(numSmpFrames - repSmpFrames)+";\n");
            _out.append("else if("+sVarSubOff+" < 0)\n");
            _out.append("   "+sVarSubOff+" = 0;\n");
            sSubOff <= sVarSubOff;
            _script.freeTmpVarInt(sVarSubOffX);
         }
      }
      if(null == sSubOff)
         sSubOff <= String(subOff);

      int repLenMask = mathClampi(repSmpFrames - 1, 0, 65535);

      _script.appendInit(sInit);

      local CyInput inLin <= findInputById("lin");
      boolean bLinear = (inLin.getConstVal() >= 0.5);
      local String *sVarNext;
      if(bLinear)
         sVarNext <= _script.allocTmpVarInt(_out, "zone_smp_next");

      if(bConstPhase)
      {
         if(b_export_c)
         {
            if(bLinear)
            {
               // Linear filtering
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float samples to fixpoint
                  _out.append(sVarNext+" = (short)("+sSmpDat+"["+sSubOff+"+((("+sVarPos+" >> 16) + 1) & "+repLenMask+")] * "+int(FX_ONE)+");\n");
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"["+sSubOff+"+( ("+sVarPos+" >> 16)      & "+repLenMask+")] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit samples to fixpoint
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sSubOff+"+((("+sVarPos+" >> 16) + 1) & "+repLenMask+")]) << "+(FX_SHR -7)+";\n");
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sSubOff+"+( ("+sVarPos+" >> 16)      & "+repLenMask+")]) << "+(FX_SHR -7)+";\n");
               }
               _out.append(_sDstVar+" = "+_sDstVar+" + (mulsw("+sVarNext+" - "+_sDstVar+", ("+sVarPos+" >> "+(16 - FX_SHR)+")) >> "+FX_SHR+");\n");
            }
            else
            {
               // Nearest neighbour
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float sample to fixpoint
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"["+sSubOff+"+(("+sVarPos+" >> 16) & "+repLenMask+")] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit sample to fixpoint
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sSubOff+"+("+sVarPos+" >> 16)]) << "+(FX_SHR -7)+";\n");
               }
            }
         }
         else
         {
            // Script mode
            if(bLinear)
            {
               // Linear filtering
               _out.append(sVarNext+" = "+sSmpDat+".get("+sSubOff+"+((("+sVarPos+" >> 16) + 1) & "+repLenMask+")) * "+int(FX_ONE)+";\n");
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+( ("+sVarPos+" >> 16)      & "+repLenMask+")) * "+int(FX_ONE)+";\n");
               _out.append(_sDstVar+" = "+_sDstVar+" + ("+sVarNext+" - "+_sDstVar+") * (("+sVarPos+" & 65535) * (1.0f / 65536.0f));\n");
            }
            else
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+(("+sVarPos+" >> 16) & "+repLenMask+")) * "+int(FX_ONE)+";\n");
         }
      }
      else
      {
         // Dynamic phase
         local String sVarPhase <= _script.allocTmpVarInt(_out, "phase");
         inPhase.emitInt(_script, _out, sVarPhase);
         // (todo) optimize for POT smpSz (eliminate 32bit multiplication)
         if(b_export_c)
         {
            if(bLinear)
            {
               // Linear filtering
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float samples to fixpoint
                  _out.append(sVarNext+" = (short)("+sSmpDat+"["+sSubOff+"+(((("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16) + 1) & "+repLenMask+")] * "+int(FX_ONE)+");\n");
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"["+sSubOff+"+( (("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16)      & "+repLenMask+")] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit samples to fixpoint
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sSubOff+"+(((("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16) + 1) & "+repLenMask+")]) << "+(FX_SHR -7)+";\n");
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sSubOff+"+( (("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16) & "+repLenMask+")]) << "+(FX_SHR -7)+";\n");
               }
               _out.append(_sDstVar+" = "+_sDstVar+" + (mulsw("+sVarNext+" - "+_sDstVar+", ("+sVarPos+" >> "+(16 - FX_SHR)+")) >> "+FX_SHR+");\n");
            }
            else
            {
               // Nearest neighbour
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float sample to fixpoint
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"["+sSubOff+"+((("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16) & "+repLenMask+")] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit sample to fixpoint
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sSubOff+"+((("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16) & "+repLenMask+")]) << "+(FX_SHR -7)+";\n");
               }
            }
         }
         else
         {
            // Script mode
            if(bLinear)
            {
               // Linear filtering
               _out.append(sVarNext+" = "+sSmpDat+".get("+sSubOff+"+(((("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16) + 1) & "+repLenMask+")) * "+int(FX_ONE)+";\n");
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+( (("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16)      & "+repLenMask+")) * "+int(FX_ONE)+";\n");
               _out.append(_sDstVar+" = "+_sDstVar+" + ("+sVarNext+" - "+_sDstVar+") * (("+sVarPos+" & 65535) * (1.0f / 65536.0f));\n");
            }
            else
            {
               // Nearest neighbour
               _out.append(_sDstVar+" = "+sSmpDat+".get("+sSubOff+"+((("+sVarPos+" + ("+sVarPhase+" * "+((65536 >> FX_SHR) * repSmpFrames)+")) >> 16) & "+repLenMask+")) * "+int(FX_ONE)+";\n");
            }
         }
         _script.freeTmpVarInt(sVarPhase);
      }

      if(bConstRate)
         _out.append(sVarPos+" += "+int(fRate*65536)+";\n");
      else
      {
         local String sVarRate <= _script.allocTmpVarInt(_out, "rate");
         inRate.emitInt(_script, _out, sVarRate);
         _out.append(sVarPos+" += ("+sVarRate+" << "+(16 - FX_SHR)+");\n");
         _script.freeTmpVarInt(sVarRate);
      }

      if(null != sVarSubOff)
         _script.freeTmpVarInt32(sVarSubOff);

      if(null != sVarNext)
         _script.freeTmpVarInt(sVarNext);
   }
}


// <class.png>
class CyModuleZon : CyModule {
   int zone_idx;

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("rate",    1.0,    0.0,  15.0);   // const
      addInput("lin",     0,      0,    1);      // const
      addInput("and",     0,      0,    65535);  // const
      addInput("andf",    0,      0,    15);     // dynamic
      addInput("restart", 1.0,  0.0,    1.0);    // rising edge: restart sample (+start in 'suspended'/'end of sample' state)
      addInput("pos",     0.0,    0,    1.0);    // normalized restart pos (0..1) (evaluated during 'restart')
      addInput("freq",    1.0,    0.0,  1.0);    // scales rate (when connected)
      addInput("clamp",   1.0,    0.0,  1.0);    // clamp source offset (in integer mode) (always clamp in float mode)

      addInputAlias("r",  "rate");
      addInputAlias("l",  "lin");
      addInputAlias("a",  "and");
      addInputAlias("af", "andf");
      addInputAlias("rs", "restart");
      addInputAlias("p",  "pos");
      addInputAlias("f",  "freq");
      addInputAlias("c",  "clamp");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inRate    <= findInputById("rate");
      local CyInput inLin     <= findInputById("lin");
      local CyInput inAnd     <= findInputById("and");
      local CyInput inAndF    <= findInputById("andf");
      local CyInput inRestart <= findInputById("restart"); // rising edge restarts sample
      local CyInput inPos     <= findInputById("pos");     // restart position (0..1)
      local CyInput inFreq    <= findInputById("freq");    // scales 'rate' by current note speed

      boolean bLinear = (inLin.getConstVal() >= 0.5);
      boolean bRestart = true;////inRestart.isConnected();  // (note) always eval 'pos' when playback starts

      StSample s <= _script.findZoneSampleByIndex(zone_idx);
      if(null == s)
         return false;

      int numSmpFrames = s.lastLoopLen;

      local String *sSmpDat;
      if(b_plugin)
      {
         Sample parentSample <= _script.findZoneParentSampleByIndex(zone_idx);
         _script.addUniquePluginWaveformRef(parentSample, s);
         CyPluginWaveformRef waveRef <= _script.addUniquePluginWaveformRef(parentSample, s);
         sSmpDat <= waveRef.getExportedZoneVarName(s);
      }
      else
      {
         sSmpDat <= "zone_smp_"+zone_idx;
      }

      local float fRate = inRate.isConstVal() ? inRate.getConstVal() : 1.0f/*not allowed*/;
      fRate = mathClampf(fRate, 0.0f, 15.0f);

      // trace "xxx zon: fRate="+fRate;

      local String sVarRate <= _script.allocTmpVar(_out, "rate");
      if(inFreq.isConnected())
      {
         // (note) 'freq' should have note_speed already factored in (e.g. output from 'kbd')
         // // local String sVarFreq <= _script.allocTmpVar(_out, "freq");
         inFreq.emitFloat(_script, _out, sVarRate);
         if(1.0f != fRate)
            _out.append(sVarRate+" *= "+FloatToString(fRate)+";\n");
         _out.append("if("+sVarRate+" < 0.0f)\n");
         _out.append("   "+sVarRate+" = 0.0f;\n");
         // // _out.append("else\n");
         // // if(b_plugin)
         // //    _out.append("   "+sVarRate+" *= voice->note_speed_cur;\n");
         // // else
         // //    _out.append("   "+sVarRate+" *= "+_script.note_speed+";\n");
         // // _script.freeTmpVar(sVarFreq);
      }
      else
      {
         // no 'freq' modulation
         fRate /= parent_script.oversample_factor;
         _out.append(sVarRate+" = "+FloatToString(fRate)+";\n");
         // trace "xxx const fRate="+fRate;
      }
      local String sInit;
      local String sVarPos <= _script.allocTmpVarInit(sInit, "zon_pos",
                                                      inRestart.isConnected() ? (numSmpFrames-2) : 0.0f,
                                                      true/*bCycleReset*/
                                                      );
      local String *sVarLastRestart;
      if(bRestart)
         sVarLastRestart <= _script.allocTmpVarInitVoice(sInit, "last_restart", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      local String sIndent;

      if(bRestart)
      {
         local String sVarRestart <= _script.allocTmpVar(_out, "restart");
         inRestart.emitFloat(_script, _out, sVarRestart);
         // Rising edge ?
         if(0 && b_plugin)
         {
            _out.append("printf(\"xxx zon sVarRestart=%f sVarLastRestart=%f\\n\", "+sVarRestart+", "+sVarLastRestart+");\n");
            _script.b_use_trc = true;
         }
         // // _out.append("if("+sVarRestart+" > 0.5f && "+sVarLastRestart+" < 0.5f)\n");
         _out.append(IfRisingEdgeFloat(sVarRestart, sVarLastRestart));
         _out.append("{\n");
         // Restart sample
         sIndent.empty();
         inPos.emitFloat(_script, sIndent, sVarPos);
         CyScript.AppendIndentedLines(_out, sIndent, 3);
         _out.append("   "+sVarPos+" = "+sVarPos+" * "+numSmpFrames+";\n");
         if(bLinear)
         {
            // linear filter, need one extra sample frame
            _out.append("   if( ((("+uint_type+")("+sVarPos+")) + 1) >= "+numSmpFrames+" )\n");
            _out.append("      "+sVarPos+" = (float)("+numSmpFrames+" - 1);\n");
         }
         else
         {
            // nearest neighbour
            _out.append("   if( (("+uint_type+")("+sVarPos+")) >= "+numSmpFrames+" )\n");
            _out.append("      "+sVarPos+" = (float)("+numSmpFrames+" - 1);\n");
         }
         if(0 && b_plugin)
         {
            sIndent.append("printf(\"xxx zon restart pos=%f\\n\", "+sVarPos+");\n");
            _script.b_use_trc = true;
         }
         _out.append("}\n");
         // Track signal
         _out.append(sVarLastRestart+" = "+sVarRestart+";\n");
      }

      local String *sAnd;
      local String *sVarAnd;
      local boolean bAnd = false;
      if(inAndF.isConnected())
      {
         if(inAndF.isConstVal())
         {
            sAnd <= String(int(inAndF.getConstVal() * FX_ONE));  // 0..1=>0..2048  /  0..15.9995117188 => 0..32767
            bAnd = true;
         }
         else
         {
            local String sVarAndF <= _script.allocTmpVar(_out, "zone_smp_andf");
            inAndF.emitFloat(_script, _out, sVarAndF);
            sVarAnd <= _script.allocTmpVarInt(_out, "zone_smp_and");
            _out.append(sVarAnd+" = int("+sVarAndF+" * FX_ONE);\n");
            sAnd <= sVarAnd;
            bAnd = true;
            _script.freeTmpVar(sVarAndF);
         }
      }
      else
      {
         local int iAnd = (inAnd.isConstVal() ? inAnd.getConstVal() : 0);
         sAnd <= String(iAnd);
         bAnd = (iAnd > 0);
      }

      if(bLinear)
      {
         // Linear filtering
         if(bAnd)
         {
            local String sVarNext <= _script.allocTmpVar(_out, "zone_smp_next");
            if(b_export_c)
            {
               if(b_plugin || parent_script.b_use_int_module)
               {
                  _out.append(sVarNext+" = "+sSmpDat+"[(int("+sVarPos+") + 1) & "+sAnd+"];\n");
                  _out.append(_sDstVar+" = "+sSmpDat+"[(int("+sVarPos+")      & "+sAnd+"];\n");
               }
               else
               {
                  _out.append(sVarNext+" = zone_smp_"+zone_idx+export_c_prefix+"[(int("+sVarPos+") + 1) & "+sAnd+"];\n");
                  _out.append(_sDstVar+" = zone_smp_"+zone_idx+export_c_prefix+"[(int("+sVarPos+")      & "+sAnd+"];\n");
               }
            }
            else
            {
               _out.append(sVarNext+" = zone_smp_"+zone_idx+".get((int("+sVarPos+") + 1) & "+sAnd+");\n");
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".get(int("+sVarPos+")       & "+sAnd+");\n");
            }
            _out.append(_sDstVar+" = "+_sDstVar+" + ("+sVarNext+" - "+_sDstVar+") * frac("+sVarPos+");\n");
            _script.freeTmpVar(sVarNext);
         }
         else
         {
            if(b_export_c)
            {
               if(b_plugin)
                  _out.append(_sDstVar+" = winLinear("+sSmpDat+", "+sVarPos+");\n");
               else
                  _out.append(_sDstVar+" = winLinear(zone_smp_"+zone_idx+export_c_prefix+", "+sVarPos+");\n");
            }
            else
            {
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".winLinear("+sVarPos+");\n");
            }
         }
      }
      else
      {
         // Nearest neighbour (no interpolation)
         if(bAnd)
         {
            if(b_export_c)
            {
               if(b_plugin)
                  _out.append(_sDstVar+" = "+sSmpDat+"[(int)("+sVarPos+") & "+sAnd+"];\n");
               else
                  _out.append(_sDstVar+" = zone_smp_"+zone_idx+export_c_prefix+"[(int)("+sVarPos+") & "+sAnd+"];\n");
            }
            else
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".get(int("+sVarPos+") & "+sAnd+");\n");
         }
         else
         {
            if(b_export_c)
            {
               if(b_plugin)
                  _out.append(_sDstVar+" = "+sSmpDat+"[(int)("+sVarPos+")];\n");
               else
                  _out.append(_sDstVar+" = zone_smp_"+zone_idx+export_c_prefix+"[(int)("+sVarPos+")];\n");
            }
            else
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".get(int("+sVarPos+"));\n");
         }
      }

      // clamp to end of sample
      //  (note) float codepath is never taken on 68k => sacrifice (a little) speed for safety
      if(bLinear)
      {
         // linear filter, need one extra sample frame
         _out.append("if( ((("+uint_type+")("+sVarPos+" + "+sVarRate+")) + 1) < "+numSmpFrames+" )\n");
         _out.append("   "+sVarPos+" += "+sVarRate+";\n");
      }
      else
      {
         // nearest neighbour
         _out.append("if( (("+uint_type+")("+sVarPos+" + "+sVarRate+")) < "+numSmpFrames+" )\n");
         _out.append("   "+sVarPos+" += "+sVarRate+";\n");
      }

      if(null != sVarAnd)
         _script.freeTmpVarInt(sVarAnd);

      if(null != sVarRate)
         _script.freeTmpVar(sVarRate);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inRate <= findInputById("rate");
      local CyInput inLin  <= findInputById("lin");
      local CyInput inAnd  <= findInputById("and");
      local CyInput inAndF <= findInputById("andf");
      local CyInput inClamp = findInputById("clamp");

      StSample s <= _script.findZoneSampleByIndex(zone_idx);
      if(null == s)
         return false;

      int numSmpFrames = s.lastLoopLen;

      local String *sSmpDat;
      if(b_plugin)
      {
         Sample parentSample <= _script.findZoneParentSampleByIndex(zone_idx);
         _script.addUniquePluginWaveformRef(parentSample, s);
         CyPluginWaveformRef waveRef <= _script.addUniquePluginWaveformRef(parentSample, s);
         sSmpDat <= waveRef.getExportedZoneVarName(s);
      }
      else
      {
         sSmpDat <= "zone_smp_"+zone_idx;
      }

      local float fRate = mathClampf(inRate.getConstVal(), 0.0f, 15.0f);
      fRate /= parent_script.oversample_factor;
      local String sInit;
      local String sVarPos <= _script.allocTmpVarInt32Init(sInit, "zon_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      boolean bClamp = (inClamp.getConstVal() >= 0.5f);

      local String *sAnd;
      local String *sVarAnd;
      local boolean bAnd = false;
      if(inAndF.isConnected())
      {
         if(inAndF.isConstVal())
         {
            sAnd <= String(int(inAndF.getConstVal() * FX_ONE));  // 0..1=>0..2048  /  0..15.9995117188 => 0..32767
            bAnd = true;
         }
         else
         {
            sVarAnd <= _script.allocTmpVarInt(_out, "zone_smp_and");
            inAndF.emitInt(_script, _out, sVarAnd);
            sAnd <= sVarAnd;
            bAnd = true;
         }
      }
      else
      {
         local int iAnd = (inAnd.isConstVal() ? inAnd.getConstVal() : 0);
         sAnd <= String(iAnd);
         bAnd = (iAnd > 0);
      }

      if(inLin.getConstVal() >= 0.5)
      {
         // Linear filtering
         local String sVarNext <= _script.allocTmpVarInt(_out, "zone_smp_next");
         if(bAnd)
         {
            if(b_export_c)
            {
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float sample to fixpoint
                  _out.append(sVarNext+" = (short)("+sSmpDat+"[(("+sVarPos+" >> 16)+1) & "+sAnd+"] * "+int(FX_ONE)+");\n");
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"[ ("+sVarPos+" >> 16)    & "+sAnd+"] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit sample to fixpoint
                  _out.append(sVarNext+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"[(("+sVarPos+" >> 16)+1) & "+sAnd+"]) << "+(FX_SHR -7)+";\n");
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"[ ("+sVarPos+" >> 16)    & "+sAnd+"]) << "+(FX_SHR -7)+";\n");
               }
            }
            else
            {
               _out.append(sVarNext+" = zone_smp_"+zone_idx+".get((("+sVarPos+" >> 16)+1) & "+sAnd+") * "+int(FX_ONE)+";\n");
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".get( ("+sVarPos+" >> 16)    & "+sAnd+") * "+int(FX_ONE)+";\n");
            }
         }
         else
         {
            // no and'ing
            if(b_export_c)
            {
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float samples to fixpoint
                  _out.append(sVarNext+" = (short)("+sSmpDat+"[("+sVarPos+" >> 16)+1] * "+int(FX_ONE)+");\n");
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"[ "+sVarPos+" >> 16   ] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit samples to fixpoint
                  _out.append(sVarNext+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"[("+sVarPos+" >> 16)+1]) << "+(FX_SHR -7)+";\n");
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"[ "+sVarPos+" >> 16   ]) << "+(FX_SHR -7)+";\n");
               }
            }
            else
            {
               _out.append(sVarNext+" = zone_smp_"+zone_idx+".get(("+sVarPos+" >> 16)+1) * "+int(FX_ONE)+";\n");
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".get( "+sVarPos+" >> 16)    * "+int(FX_ONE)+";\n");
            }
         }
         _out.append(_sDstVar+" = "+_sDstVar+" + Dmulsw_shr(("+sVarNext+" - "+_sDstVar+"), ("+sVarPos+"&65535)>>("+(16-FX_SHR)/*5*/+"));\n");
         _script.freeTmpVarInt(sVarNext);
      }
      else
      {
         // Nearest neighbour (no interpolation)
         if(bAnd)
         {
            if(b_export_c)
            {
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float sample to fixpoint
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"[("+sVarPos+" >> 16) & "+sAnd+"] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit sample to fixpoint
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"[("+sVarPos+" >> 16) & "+sAnd+"]) << "+(FX_SHR -7)+";\n");
               }
            }
            else
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".get(("+sVarPos+" >> 16) & "+sAnd+") * "+int(FX_ONE)+";\n");
         }
         else
         {
            if(b_export_c)
            {
               if(b_plugin || parent_script.b_use_int_module)
               {
                  // convert 32bit float sample to fixpoint
                  _out.append(_sDstVar+" = (short)("+sSmpDat+"["+sVarPos+" >> 16] * "+int(FX_ONE)+");\n");
               }
               else
               {
                  // convert signed 8bit sample to fixpoint
                  _out.append(_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sVarPos+" >> 16]) << "+(FX_SHR -7)+";\n");
               }
            }
            else
               _out.append(_sDstVar+" = zone_smp_"+zone_idx+".get("+sVarPos+" >> 16) * "+int(FX_ONE)+";\n");
         }
      }

      if(b_export_c && (b_plugin || parent_script.b_use_int_module || bClamp))
      {
         // clamp to end of sample
         if(inLin.getConstVal() >= 0.5)
         {
            // linear filter, need one extra sample frame
            _out.append("if( (((unsigned int)("+sVarPos+" + "+int(fRate*65536.0)+") >> 16) + 1) < "+numSmpFrames+" )\n");
            _out.append("   "+sVarPos+" += "+int(fRate*65536.0)+";\n");
         }
         else
         {
            // nearest neighbour
            _out.append("if( ((unsigned int)("+sVarPos+" + "+int(fRate*65536.0)+") >> 16) < "+numSmpFrames+" )\n");
            _out.append("   "+sVarPos+" += "+int(fRate*65536.0)+";\n");
         }
      }
      else
      {
         // (note) in (non-plugin) sample-generator mode (e.g. for 68k), sacrifice the sample range check for speed.
         // (note) in script mode, the array lookup method (get()) performs a boundary check
         _out.append(sVarPos+" += "+int(fRate*65536.0)+";\n");
      }

      // _out.append("trace "+_sDstVar+";\n");

      if(null != sVarAnd)
         _script.freeTmpVarInt(sVarAnd);
   }
}


// <class.png>
class CyModuleZsq : CyModule {
   int zone_idx;
   int pat_bits;  // bit0=step0

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("note",   16.0,   1.0,   256.0);  // note length (16=16th, 32=32th, ..)
      addInput("bpm",     0.0,   0.0,  1000.0);
      addInput("swing",   0.0,  -0.5,     0.5);
      addInput("rate",    1.0,   0.125,   8.0);
      addInput("lin",     0,     0,       1  );  // const
      addInput("div",     0,     0,     256.0);  // const (divide zone len into "n" regions). 0=div mode off
      addInput("off",     0,     0,       1.0);  // 0..1 => 0..(num_div-1) => start

      addInputAlias("n",  "note");
      addInputAlias("sw", "swing");
      addInputAlias("r",  "rate");
      addInputAlias("l",  "lin");
      addInputAlias("d",  "div");
      addInputAlias("o",  "off");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inNote  <= findInputById("note");
      local float fNote = inNote.getConstVal();
      local float f16th = 16.0 / fNote;

      local CyInput inBPM   <= findInputById("bpm");
      local float fBPM = inBPM.getConstVal();
      if(fBPM < 10.0f)
         fBPM = current_project.bpm;

      local CyInput inRate  <= findInputById("rate");
      local float fRate = inRate.getConstVal();

      local CyInput inSwing <= findInputById("swing");
      local float fSwing = inSwing.getConstVal();

      local CyInput inLin   <= findInputById("lin");
      local boolean bLinear = (inLin.getConstVal() >= 0.5f);

      local CyInput inDiv   <= findInputById("div");
      local int numDiv = int(inDiv.getConstVal() + 0.5);
      local boolean bDiv = (numDiv >= 2);

      local CyInput inOff   <= findInputById("off");

      StSample s <= _script.findZoneSampleByIndex(zone_idx);
      if(null == s)
         return false;

      local int srcNumFrames;
      if(bDiv)
      {
         srcNumFrames = s.lastLoopLen / numDiv;
      }
      else
      {
         srcNumFrames = s.lastLoopLen;
      }
      local int numSmpFrames = srcNumFrames / fRate;

      local float stepMS = ( (1000 * 60 * 0.25) * f16th ) / fBPM;
      local int numStepFrames = (_script.sample_rate * stepMS) / 1000.0;

      local int numStepFramesSwing0;
      local int numStepFramesSwing1;
      if(0.0f != fSwing)
      {
         numStepFramesSwing0 = (numStepFrames * fSwing);
         numStepFramesSwing1 = numStepFrames - numStepFramesSwing0;
         numStepFramesSwing0 += numStepFrames;
      }

      local String sInit;
      local String sVarZoneSmpIdx  <= _script.allocTmpVarInt32Init(sInit, "zsq_zonesmpidx",  999999,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarStepSmpLeft <= _script.allocTmpVarInt32Init(sInit, "zsq_stepsmpleft", 0,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarPatBits     <= _script.allocTmpVarInt32Init(sInit, "zsq_patbits",     pat_bits,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarStepBit     <= _script.allocTmpVarInt32Init(sInit, "zsq_stepbit",     1,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarPos;
      if( (1.0f != fRate) || bDiv )
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "zsq_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      local String sVarSwingIdx;
      if(0.0f != fSwing)
         sVarSwingIdx <= _script.allocTmpVarInt32Init(sInit, "zsq_swingidx", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      // Next step ? (restart sample when pattern step bit is set)
      _out.append("if("+sVarStepSmpLeft+"-- <= 0) {\n   if("+sVarPatBits+" & "+sVarStepBit+") { "+sVarZoneSmpIdx+" = 0;");
      if( (1.0f != fRate) || bDiv )
      {
         if(bDiv)
         {
            local String sVarDivOff <= _script.allocTmpVar(_out, "zsq_divoff");
            inOff.emitFloat(_script, _out, sVarDivOff);
            _out.append(" "+sVarPos+" = (int)("+sVarDivOff+" * "+(numDiv-1)+" + 0.5f);");
            _out.append(" if("+sVarPos+" > "+(numDiv-1)+") "+sVarPos+" = "+(int((numDiv-1)*srcNumFrames) << 11)+"; else if("+sVarPos+" < 0) "+sVarPos+" = 0; else "+sVarPos+" = ((int)("+sVarPos+" * "+srcNumFrames+")) << 11;");
            _script.freeTmpVar(sVarDivOff);
         }
         else
         {
            _out.append(" "+sVarPos+" = 0;");
         }
      }
      _out.append(" }\n");
      if(0.0f != fSwing)
      {
         _out.append("   if("+sVarSwingIdx+") "+sVarStepSmpLeft+" = "+numStepFramesSwing1+";\n");
         _out.append("   else "+sVarStepSmpLeft+" = "+numStepFramesSwing0+";\n");
         _out.append("   "+sVarSwingIdx+" ^= 1;\n");
      }
      else
         _out.append("   "+sVarStepSmpLeft+" = "+numStepFrames+";\n");
      _out.append("   "+sVarStepBit+" <<= 1;\n");
      _out.append("}\n");

      // Read next sample
      _out.append("if("+sVarZoneSmpIdx+" < "+numSmpFrames+") {\n");
      if( (1.0f != fRate) || bDiv )
      {
         if(bLinear)
         {
            if(b_export_c)
            {
               _out.append("   "+_sDstVar+" = winLinear(zone_smp_"+zone_idx+export_c_prefix+", "+sVarPos+" * (1.0f / 2048.0f));\n");
            }
            else
            {
               _out.append("   "+_sDstVar+" = zone_smp_"+zone_idx+".winLinear("+sVarPos+" * (1.0f / 2048.0f));\n");
            }
         }
         else
         {
            if(b_export_c)
            {
               _out.append("   "+_sDstVar+" = zone_smp_"+zone_idx+"["+sVarPos+" >> 11];\n");
            }
            else
            {
               _out.append("   "+_sDstVar+" = zone_smp_"+zone_idx+".get("+sVarPos+" >> 11);\n");
            }
         }
         _out.append("   "+sVarPos+" += "+int(fRate * 2048)+";\n");
         _out.append("   "+sVarZoneSmpIdx+"++;\n");
      }
      else
      {
         _out.append("   "+_sDstVar+" = zone_smp_"+zone_idx+".get("+sVarZoneSmpIdx+"++);\n");
      }
      _out.append("}\n");
      _out.append("else "+_sDstVar+" = 0.0f;\n");
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      local CyInput inNote  <= findInputById("note");
      local float fNote = inNote.getConstVal();
      local float f16th = 16.0 / fNote;

      local CyInput inBPM   <= findInputById("bpm");
      local float fBPM = inBPM.getConstVal();
      if(fBPM < 10.0f)
         fBPM = current_project.bpm;

      local CyInput inRate  <= findInputById("rate");
      local float fRate = inRate.getConstVal();

      local CyInput inSwing <= findInputById("swing");
      local float fSwing = inSwing.getConstVal();

      local CyInput inLin   <= findInputById("lin");
      local boolean bLinear = (inLin.getConstVal() >= 0.5f);

      local CyInput inDiv   <= findInputById("div");
      local int numDiv = int(inDiv.getConstVal() + 0.5);
      local boolean bDiv = (numDiv >= 2);

      local CyInput inOff   <= findInputById("off");

      StSample s <= _script.findZoneSampleByIndex(zone_idx);
      if(null == s)
         return false;

      local int srcNumFrames;
      if(bDiv)
      {
         srcNumFrames = s.lastLoopLen / numDiv;
      }
      else
      {
         srcNumFrames = s.lastLoopLen;
      }
      local int numSmpFrames = srcNumFrames / fRate;

      local float stepMS = ( (1000 * 60 * 0.25) * f16th ) / fBPM;
      local int numStepFrames = (_script.sample_rate * stepMS) / 1000.0;

      local int numStepFramesSwing0;
      local int numStepFramesSwing1;
      if(0.0f != fSwing)
      {
         numStepFramesSwing0 = (numStepFrames * fSwing);
         numStepFramesSwing1 = numStepFrames - numStepFramesSwing0;
         numStepFramesSwing0 += numStepFrames;
      }

      local String sInit;
      local String sVarZoneSmpIdx  <= _script.allocTmpVarInt32Init(sInit, "zsq_zonesmpidx",  999999,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarStepSmpLeft <= _script.allocTmpVarInt32Init(sInit, "zsq_stepsmpleft", 0,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarPatBits     <= _script.allocTmpVarInt32Init(sInit, "zsq_patbits",     pat_bits,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarStepBit     <= _script.allocTmpVarInt32Init(sInit, "zsq_stepbit",     1,
                                                                   true/*bCycleReset*/, true/*bVoiceReset*/
                                                                   );
      local String sVarPos;
      if( (1.0f != fRate) || bDiv )
      {
         sVarPos <= _script.allocTmpVarInt32Init(sInit, "zsq_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);

         if(bDiv)
         {
            local String sVarDivOff <= _script.allocTmpVarInt(_out, "zsq_divoff");
            inOff.emitInt(_script, _out, sVarDivOff);
            _out.append(" "+sVarPos+" = (Dmulsw("+sVarDivOff+" * "+(numDiv-1)+") + 1024/*0.5*/) >> "+FX_SHR+";");
            _out.append(" if("+sVarPos+" > "+(numDiv-1)+") "+sVarPos+" = "+(int((numDiv-1)*srcNumFrames) << 11)+"; else if("+sVarPos+" < 0) "+sVarPos+" = 0; else "+sVarPos+" = ((int)("+sVarPos+" * "+srcNumFrames+")) << 11;");
            _script.freeTmpVarInt(sVarDivOff);
         }
         // // else
         // // {
         // //    sVarPos <= _script.allocTmpVarInt32Init(sInit, "zsq_pos", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
         // // }
      }
      local String sVarSwingIdx;
      if(0.0f != fSwing)
         sVarSwingIdx <= _script.allocTmpVarInt32Init(sInit, "zsq_swingidx", 0, true/*bCycleReset*/, true/*bVoiceReset*/);
      _script.appendInit(sInit);

      // Next step ? (restart sample when pattern step bit is set)
      _out.append("if("+sVarStepSmpLeft+"-- <= 0) {\n   if("+sVarPatBits+" & "+sVarStepBit+") { "+sVarZoneSmpIdx+" = 0;");
      if( (1.0f != fRate) || bDiv )
      {
         _out.append(" "+sVarPos+" = 0;");
      }
      _out.append(" } ");
      if(0.0f != fSwing)
      {
         _out.append("   if("+sVarSwingIdx+") "+sVarStepSmpLeft+" = "+numStepFramesSwing1+";\n");
         _out.append("   else "+sVarStepSmpLeft+" = "+numStepFramesSwing0+";\n");
         _out.append("   "+sVarSwingIdx+" ^= 1;\n");
      }
      else
         _out.append("   "+sVarStepSmpLeft+" = "+numStepFrames+";\n");
      _out.append("   "+sVarStepBit+" <<= 1;\n");
      _out.append("}\n");

      // Read next sample
      _out.append("if("+sVarZoneSmpIdx+" < "+numSmpFrames+") {\n");
      if( (1.0f != fRate) || bDiv )
      {
         if(bLinear)
         {
            local String sVarNext <= _script.allocTmpVarInt(_out, "zsq_smp_next");
            if(b_export_c)
            {
               _out.append("   "+sVarNext+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"[("+sVarPos+" >> 11)+1]) << "+(FX_SHR -7)+";\n");
               _out.append("   "+_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sVarPos+" >> 11]) << "+(FX_SHR -7)+";\n");
            }
            else
            {
               _out.append("   "+sVarNext+" = zone_smp_"+zone_idx+".get(("+sVarPos+" >> 11)+1) * "+int(FX_ONE)+";\n");
               _out.append("   "+_sDstVar+" = zone_smp_"+zone_idx+".get("+sVarPos+" >> 11) * "+int(FX_ONE)+";\n");
            }
            _out.append("   "+_sDstVar+" = "+_sDstVar+" + Dmulsw_shr(("+sVarNext+" - "+_sDstVar+"), ("+sVarPos+"&2047));\n");
            _script.freeTmpVarInt(sVarNext);
         }
         else
         {
            _out.append("   "+_sDstVar+" = zone_smp_"+zone_idx+".get("+sVarPos+" >> 11) * "+int(FX_ONE)+";\n");
         }
         _out.append("   "+sVarPos+" += "+int(fRate * 2048)+";\n");
         _out.append("   "+sVarZoneSmpIdx+"++;\n");
      }
      else
      {
         if(b_export_c)
            _out.append("   "+_sDstVar+" = ((short)zone_smp_"+zone_idx+export_c_prefix+"["+sVarZoneSmpIdx+"++]) << "+(FX_SHR -7)+";\n");
         else
            _out.append("   "+_sDstVar+" = zone_smp_"+zone_idx+".get("+sVarZoneSmpIdx+"++) * "+int(FX_ONE)+";\n");
      }
      _out.append("}\n");
      _out.append("else "+_sDstVar+" = 0;\n");
   }

}


// <class.png>
class CyModuleVpl : CyModule {
   int vpl_idx;
   float sample_rate;  // copied from CyScript
   String plugin_id;  // e.g. "bsp eq3"
   StPluginInfo   *info;
   StPluginShared *shared;
   StPluginVoice  *voice;
   HashTable param_values;
   HashTable param_arg_refs;
   IntArray input_to_mod_map;


   // <method_init.png>
   public virtual init() {
      CyModule::init();
      input_to_mod_map.allocAndFill(8, -1);
   }

   // <method_exit.png>
   public virtual exit() {
      unloadVoicePlugin();
   }

   // <method.png>
   public method unloadVoicePlugin() {
      voice  <= null;
      shared <= null;
      info   <= null;
   }

   // <method.png>
   public method reloadVoicePlugin() {
      loadPluginAndSetParamsAndCreateInputs(sample_rate, false/*bCreateInputs*/);
   }

   // <method_set.png>
   public method setParamByName(String _name, float _val) {
      // while parsing module
      // trace "xxx vpl::setParamByName: name=\""+_name+"\" val="+_val;
      _val = mathClampf(_val, 0.0f, 1.0f);
      param_values[_name] = _val;
   }

   // <method_set.png>
   public method setParamByArg(String _name, CyArg _arg) {
      // while parsing module
      // trace "xxx vpl::setParamByArg: name=\""+_name+"\" arg.id="+_arg.id;
      param_arg_refs[_name] = _arg;
   }

   // <method_find.png>
   protected method findParamIdxByName(String _paramName) : int {
      if(null != info)
      {
         int numParams = info.numParams;
         int paramIdx = 0;
         loop(numParams)
         {
            String curName <= info.getParamName(paramIdx);
            if(curName.compareIgnoreCase(_paramName))
            {
               return paramIdx;
            }
            paramIdx++;
         }
      }
      return -1;
   }

   // <method.png>
   public method loadParams() {
      if(null != shared)
      {
         int paramIdx;

         // Load params
         String *key;
         foreach key in param_values
         {
            paramIdx = findParamIdxByName(key);
            if(paramIdx >= 0)
            {
               if(b_debug1)
                  Global.Debug("CyModuleVpl: set param \""+key+"\" (idx="+paramIdx+") to "+param_values[key]);
               shared.setParamValue(paramIdx, mathClampf(param_values[key], 0.0f, 1.0f));
            }
         }

         foreach key in param_arg_refs
         {
            paramIdx = findParamIdxByName(key);
            CyArg arg <= param_arg_refs[key];
            if(b_debug1)
               Global.Debug("CyModuleVpl: set param \""+key+"\" (idx="+paramIdx+") to arg.id="+arg.id+" arg.val="+arg.cur_value);
            shared.setParamValue(paramIdx, arg.cur_value);
         }
      }
   }

   // <method_set.png>
   public method loadPluginAndSetParamsAndCreateInputs(float _sampleRate, boolean _bCreateInputs) {
      sample_rate = _sampleRate;
      info <= VoicePlugins.FindVoicePluginInfoById(plugin_id);
      Global.Debug("CyModuleVpl::loadPluginAndSetParamsAndCreateInputs: plugin_id=\""+plugin_id+"\" info="+#(info));
      if(null != info)
      {
         shared <= info.createSharedInstance();
         if(null != shared)
         {
            shared <= info.createSharedInstance();
            if(null != shared)
            {
               voice <= shared.createVoiceInstance(_sampleRate, 0/*voiceIdx*/);
               if(null != voice)
               {
                  // Debug print params
                  int paramIdx;
                  if(0)
                  {
                     paramIdx = 0;
                     loop(info.numParams)
                     {
                        Global.Debug("CyModuleVpl: plugin_id=\""+plugin_id+"\" param["+paramIdx+"].name=\""+info.getParamName(paramIdx)+"\"");
                        paramIdx++;
                     }
                  }

                  // Create inputs
                  if(_bCreateInputs)
                  {
                     int numMods = info.numMods;
                     int modIdx = 0;
                     loop(numMods)
                     {
                        String modName <= info.getModName(modIdx);
                        if((null != modName) && !modName.isBlank() && (modName != "-"))
                        {
                           input_to_mod_map[inputs.numElements] = modIdx;
                           addInput(modName, 0.0f/*def*/, -10.0f/*min*/, 10.0f/*max*/);
                           if(b_debug1)
                              Global.Debug("CyModuleVpl: plugin_id=\""+plugin_id+"\" addInput(modName=\""+modName+"\")");
                        }
                        modIdx++;
                     }
                  }

                  // Succeeded
                  return true;
               }
               else
                  trace "[---] CyModuleVpl::loadPluginByID: failed to create voice instance (plugin_id=\""+plugin_id+"\")";
            }
            else
               trace "[---] CyModuleVpl::loadPluginByID: failed to create shared instance (plugin_id=\""+plugin_id+"\")";
         }
         else
            trace "[---] CyModuleVpl::loadPluginByID: failed to create shared instance (plugin_id=\""+plugin_id+"\")";
      }
      else
      {
         trace "[---] CyModuleVpl::loadPluginByID: failed to resolve id \""+plugin_id+"\"";
      }

      // Failed
      return false;
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {
      // _out.append(_sDstVar+" = abs("+_sDstVar+");\n");
      if(b_export_c)
      {
         _out.append("// (todo) implement voice plugins in C code generator\n");
      }
      else
      {
         if(null != info)
         {
            _out.append("vpl_iobuf[0] = "+_sDstVar+";  // plugin_id=\""+plugin_id+"\"\n");
            _out.append("vpl_iobuf[1] = "+_sDstVar+";\n");
            local int inputIdx = 0;
            loop(input_to_mod_map.numElements)
            {
               local int modIdx = input_to_mod_map.get(inputIdx);
               local CyInput inMod <= getInputByIndex(inputIdx);
               if(null != inMod)
               {
                  if(!inMod.isConstVal()) // is connected ?
                  {
                     local String sVarModVal <= _script.allocTmpVar(_out, "mod"+modIdx);
                     inMod.emitFloat(_script, _out, sVarModVal);
                     _out.append("vpl_voice_"+vpl_idx+".setModValue("+modIdx+"/*modIdx*/, "+sVarModVal+", 0/*frameOff*/);\n");
                     _script.freeTmpVar(sVarModVal);
                  }
               }
               inputIdx++;
            }

            _out.append("vpl_voice_"+vpl_idx+".processReplace(vpl_iobuf, 1/*numFrames*/);\n");
            _out.append(_sDstVar+" = vpl_iobuf[0];  // plugin_id=\""+plugin_id+"\"\n");
         }
         else
         {
            _out.append("// error: CyModuleVpl voice instance is NULL (id=\""+plugin_id+"\")\n");
         }
      }
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {
      // convert to float, process, convert back to int
      emitFloatFallback(_script, _out, _sDstVar);
   }
}


// <class.png>
class CyModuleXfd : CyModule {

   // <method_init.png>
   public virtual init() {
      CyModule::init();

      addInput("b",      0.0, -1.0, 1.0);
      addInput("amount", 0.0, -1.0, 1.0);

      addInputAlias("amt", "amount");
   }

   // <method.png>
   public virtual emitFloat(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inB      <= findInputById("b");
      local CyInput inAmount <= findInputById("amount");

      local String sVarB <= _script.allocTmpVar(_out, "b");
      inB.emitFloat(_script, _out, sVarB);

      local String sVarAmount <= _script.allocTmpVar(_out, "amount");
      inAmount.emitFloat(_script, _out, sVarAmount);

      local String sVarAmountA <= _script.allocTmpVar(_out, "amount_a");
      local String sVarAmountB <= _script.allocTmpVar(_out, "amount_b");

      _out.append(sVarAmountA+" = ("+sVarAmount+" < 0.0f) ? 1.0f : (1.0f - "+sVarAmount+");\n");
      _out.append(sVarAmountB+" = ("+sVarAmount+" > 0.0f) ? 1.0f : (1.0f + "+sVarAmount+");\n");

      _out.append(_sDstVar+" = "+_sDstVar+"*"+sVarAmountA+" + "+sVarB+"*"+sVarAmountB+";\n");

      _script.freeTmpVar(sVarB);
      _script.freeTmpVar(sVarAmount);
      _script.freeTmpVar(sVarAmountA);
      _script.freeTmpVar(sVarAmountB);
   }

   // <method.png>
   public virtual emitInt(CyScript _script, local String _out, local String _sDstVar) {

      local CyInput inB      <= findInputById("b");
      local CyInput inAmount <= findInputById("amount");

      local String sVarB <= _script.allocTmpVarInt(_out, "b");
      inB.emitInt(_script, _out, sVarB);

      local String sVarAmount <= _script.allocTmpVarInt(_out, "amount");
      inAmount.emitInt(_script, _out, sVarAmount);

      local String sVarAmountA <= _script.allocTmpVarInt(_out, "amount_a");
      local String sVarAmountB <= _script.allocTmpVarInt(_out, "amount_b");

      _out.append(sVarAmountA+" = ("+sVarAmount+" < 0) ? "+FX_ONE+" : ("+FX_ONE+" - "+sVarAmount+");\n");
      _out.append(sVarAmountB+" = ("+sVarAmount+" > 0) ? "+FX_ONE+" : ("+FX_ONE+" + "+sVarAmount+");\n");

      if(b_export_c)
         _out.append(_sDstVar+" = (mulsw("+_sDstVar+", "+sVarAmountA+") >> "+FX_SHR+") + (mulsw("+sVarB+", "+sVarAmountB+") >> "+FX_SHR+");\n");
      else
         _out.append(_sDstVar+" = (("+_sDstVar+" * "+sVarAmountA+") >> "+FX_SHR+") + (("+sVarB+" * "+sVarAmountB+") >> "+FX_SHR+");\n");

      _script.freeTmpVarInt(sVarB);
      _script.freeTmpVarInt(sVarAmount);
      _script.freeTmpVarInt(sVarAmountA);
      _script.freeTmpVarInt(sVarAmountB);
   }
}



// <class.png>
class CyLane : CyPort {
   // (note) reserved / "special" lane names: "init", "prepare", "lut_*"
   // (note) lanes with ids prefixed by an underscore ('_') will not be automatically emitted
   // (note) all other lanes will be emitted as audio lanes (multiple audio lanes will be summed)
   CyLUT   *inv_lut_ref;  // inverse LUT written to by lut_init lane via 'sta' (or null). will be filled with -16 in lane prologue.
   boolean  b_end;        // true=last mod was 'end' => skip output write in "lut_init" lanes (script must write via 'sta' instead)

   // <method_exit.png>
   public method exit() {
      CyModule *mod;
      foreach mod in modules
      {
         mod.exit();
      }
   }

   // <method_get.png>
   public method isAudioLane() : boolean {
      return
         id != "init" && id != "wt_init" && id != "prepare" && !(id <= "lut_") && !(id <= "_");
   }

   // <method.png>
   public method findLastMod() : CyModule {
      CyModule *mod;
      mod <= modules.first;
      if(null != mod)
      {
         while(null != mod.seq_next)
            mod <= mod.seq_next;
      }
      return mod;
   }
}


// <class.png>
class CyParseContext {
   String      name;  // e.g. '3:buf .mytemplateinc'
   StringArray lines;
   int         line_offset; // !=0 during template instantiation ("set"/"value:" prologue lines) (added to cur_line_idx)
   String      var_prefix;  // !="" during template instantiation (prefix vars with template instance id to make them unique)

   CyTemplate *template_or_null;
   String     *template_instance_id;  // "mytemplclassid_myinstanceid" or "[1..n]"(auto-assigned)

   CyLane     *restore_lane;
   CyModule   *restore_mod;
   CyInput    *restore_input;

   int          cur_line_idx;
   String      *cur_line;
   StringArray *cur_words;

   CyInput *[]  input_stack;


   public method initParseContext(String      _name,
                                  StringArray _lines,
                                  int         _lineIdx,
                                  CyTemplate  _templateOrNull,
                                  String      _templateInstanceIdOrNull,  // null or deletable string
                                  CyLane      _restoreLane,
                                  CyModule    _restoreMod,
                                  CyInput     _restoreInput
                                  ) {
      name   = _name;
      lines <= deref _lines;

      template_or_null     <= _templateOrNull;
      template_instance_id <= deref _templateInstanceIdOrNull;

      restore_lane  <= _restoreLane;
      restore_mod   <= _restoreMod;
      restore_input <= _restoreInput;

      if(b_debug3)
         trace "xxx initParseContext: lineIdx="+_lineIdx+" restoreLane="+#(_restoreLane)+" restore_lane.id="+((null != restore_lane)?restore_lane.id:"n/a")+" restoreMod="+#(_restoreMod)+" restore_input="+#(restore_input);

      cur_line_idx  = _lineIdx;
   }

   public method getSrcLoc() : String {
      // trace "xxx getSrcLoc: this="+#(this)+" name=\""+name+"\" cur_line_idx="+cur_line_idx+" line_offset="+line_offset;
      if(!name.isBlank())
         return name+":"+(cur_line_idx+1+line_offset);
      return (cur_line_idx+1+line_offset);
   }

   public method getBufferName() : String {
      // e.g. name='3:buf .mytemplateinc'
      int idxInc = name.indexOf(":buf ", 0);
      if(idxInc >= 0)
         return name.substring(idxInc+5, 999);  // => '.mytemplateinc'
      return "main";
   }

   public method beginLine(int _lineOffset) : boolean {
      cur_line <= lines.get(cur_line_idx + _lineOffset);
      if(b_debug3)
         trace "xxx beginLine: cur_line=\""+cur_line+"\"";
      if(null != cur_line)
      {
         local String lineTrim <= cur_line.trim();
         // // int idxAsn = lineTrim.indexOfChar('=', 0);
         int idxRem = lineTrim.indexOfChar('#', 0);
         // // if(idxRem >= 0 && (idxAsn > idxRem || -1 == idxAsn))  // allow e.g. rate=D#3/C-3
         if(idxRem >= 0 &&
            (0 == idxRem || (' ' == lineTrim.getc(idxRem-1))) &&
            !('=' == lineTrim.getc(idxRem-2) &&
              ('0' <= lineTrim.getc(idxRem+1) <= '9')
              )
            ) // allow e.g. rate=D#3/C-3 but treat #0.12 as comment
            lineTrim.substring(0, idxRem);
         if(lineTrim.isBlank())
            return false;
         cur_words <= lineTrim.tokenize(" \t=~<>()[]{}*+&|^,;:");
      }
      else
      {
         cur_words <= null;
      }
      if(b_debug3)
         trace "xxx beginLine: cur_words="+#(cur_words);
      return (null != cur_words);
   }

   public method nextLine() {
      cur_line_idx++;
      if(b_debug3)
         trace "xxx nextLine (=> cur_line_idx="+cur_line_idx+" #lines="+lines.numElements+")";
   }

   public method prevLine() {
      cur_line_idx--;
   }

   public method getLineNr() : int {
      return cur_line_idx + 1;
   }

   public method done() : boolean {
      // trace "xxx done: lines="+#(lines);
      return (cur_line_idx >= lines.numElements);
   }
}


// <class.png>
class CyScript : CyDefs {

   define int MAX_XFADE_FRAMES = 4096;

   define int MAX_OVERSAMPLE_FACTOR = 32;

   define int MAX_OVERRIDE_WT_W        =  256;
   define int MAX_OVERRIDE_WT_H        =  256;
   define int MAX_OVERRIDE_WT_CYCLELEN = (1024*1024);

   define int MAX_MACRO_ROWS = 16384;

   // plugin array params
   define int MAX_ARRAY_PARAM_SIZE       = 256;
   define int MAX_ARRAY_PARAM_VARIATIONS =  32;

   Sample     *parent_sample;
   CyclePatch *parent_patch;

   float sample_rate;
   float base_freq;
   float base_oct;  // -2..2
   float note_freq;
   float note_speed;
   float note_speed_fixed;  // ref freq is 261.63Hz (middle C)
   int   total_num_frames;  // total target zone size (all cycles in wt mode)
   int   num_frames;   // cyclelen in wavetable mode, total num samples otherwise (w/o oversample_factor)
   int   num_skip_frames;  //  (w/o oversample_factor)
   int   wt_w;         // 0=wt mode off
   int   wt_h;
   FloatArray wt_freqs;  // rate modifiers (1.0=base note)
   int   override_wt_cyclelen;  // 0=no override, >0: override target zone wavetable setting (8..8192)
   int   override_wt_w;         // 0=auto
   int   override_wt_h;         // 0=auto
   float xfade_percent;  // 0=use xfade_num_frames, >0: calc xfade_frames from percentage (last loop off-first loop off)=100%
   int   xfade_frames;
   int   dither_mode;  // 0=off, 1=noise-shaping, 2=scaled noise-shaping

   float oversample_factor;
   int   oversample_quality;

   StringArray a_inc_done;  // tracks 'inc' files/buffers (include once)

   String tmp_var_context;  // currently active allocation context for allocTmpVar() / allocTmpVarInt() / allocTmpVarInt32()
   CyTmpVar *[] tmp_vars_float;
   CyTmpVar *[] tmp_vars_int;
   CyTmpVar *[] tmp_vars_int32;
   String s_tmp_var_decl;

   CyArg              *[] args;   // constants, can be set externally via UI
   CyVar              *[] vars;   // general purpose registers
   CyLane             *[] lanes;
   CyMacro            *[] macros;
   CyMap              *[] maps;
   CyTemplate         *[] templates;
   CyTemplateInstance *[] template_instances;
   int num_audio_lanes;

   int num_array_vars;

   CyPluginParam *[] plugin_params;   // plugin emit mode: shared params
   CyPluginMod   *[] plugin_mods;     // plugin emit mode: voice mods

   CyPluginWaveformRef *[] plugin_waveform_refs;

   // The aliases are synced with the (parent) CyclePatch.last_curve_aliases.
   // When auto-enumerating curves (i.e. when curve idx arg is skipped or -1),
   //  the CyclePatch.last_curve_aliases are used to find previously mapped curves (=> keep user-edited data).
   StringArray     curve_aliases;
   IntArray    *[] curve_intarrays;  // lo-fi mode (int)

   CyLUT *[] luts;
   CyModuleLUT *[] a_mod_lut;  // refs (optimizeCurveIndices())

   CyArrayDecl *[] array_decls;      // used for (plugin) array params

   StringArray    zone_ids;         // FQID, e.g. bd_smp.bd_zone_1
   StringArray    zone_refs;        // zone id
   StringArray    zone_smp_refs;    // ""=cur sample, sample name otherwise
   FloatArray *[] zone_floatarrays;

   CyModuleVpl *[] vpl_modules;  // refs

   // temporary parser state:
   CyLane      *cur_lane;
   CyModule    *cur_mod;
   CyInput     *cur_input;
   CyMacro     *cur_macro;
   CyArrayDecl *cur_arraydecl;
   CyMap       *cur_map;
   CyTemplate  *cur_template;
   int          macro_state;
   int          macro_indent;
   int          global_indent;
   int          map_state;
   int          map_indent;
   int          template_indent;
   CyUIModule  *cur_ui_module_def;  // currently parsed UI module. resets in popParseContext()
   CyUIPatch   *cur_ui_patch;       // currently parsed UI patch. resets in popParseContext()

   CyUIModule *[] ui_modules;
   CyUIPatch     *ui_patch;

   CyParseContext *[] parse_context_stack;      // context stack
   CyParseContext    *cur_parse_context;        // ref to TOS
   StringArray       *words;                    // ref to cur_parse_context.words (after beginLine())
   CyInput *[]       *input_stack;              // ref to cur_parse_context.input_stack

   // temporary emit state:
   boolean b_lofi;

   boolean b_mirror;  // true=calc half of the waveform, and mirror to the second half

   int next_tmp_var_idx;
   int next_template_var_idx;

   String s_var_decl;
   String s_init;
   String s_global_reset;  // global var resets (w/o var decl)
   String s_cycle_reset;   // per-cycle var resets (+var decl)
   String s_alloc_reset;   // voice allocation reset (plugin mode) (sames as global reset in sample-gen mode)

   // in plugin mode (sample-rate independent add/mul)
   boolean b_use_sr_factor;
   boolean b_use_sr_factor_int;
   String  s_sr_decl;       // sample rate dependent constants
   String  s_sr_changed;    // recalc sr dependent constants
   FloatArray add_sr_constants;
   FloatArray mul_sr_constants;
   IntArray add_sr_constants_int;
   IntArray mul_sr_constants_int;

   int next_voicebus_id;
   String s_voicebus_indices;
   String s_voicebus_ptrs;

   static IntArray int_sine_tbl;

   static FloatArray float_xfade_buf;
   static IntArray   int_xfade_buf;

   String plugin_id;        // "id" keyword
   String plugin_name;      // "name" keyword
   String plugin_author;    // "author" keyword
   String plugin_category;  // "category" keyword, see plugin.h (e.g. "ringmod", "waveshaper", "filter", ..)

   boolean b_stereo;  // 1=rdl/rdr/wrl/wrr were used (plugins only)

   boolean b_use_sine_tbl;
   boolean b_use_sine_tbl_i;
   boolean b_use_win_hse;
   boolean b_use_win_hse_1_36;
   boolean b_use_win_hse_2;
   boolean b_use_win_hse_3;
   boolean b_use_win_hse_5;
   boolean b_use_win_hse_7;
   boolean b_use_log;             // true=emit mathLogf() in exported "C" code
   boolean b_use_pow;             // true=emit mathPowerf() in exported "C" code
   boolean b_use_lle;             // true=emit mathLogLineExpf() in exported "C" code
   boolean b_use_wrapf;           // true=emit mathWrapf() in exported "C" code
   boolean b_use_foldf;           // true=emit mathFoldf() in exported "C" code
   boolean b_use_bts;             // true=emit loc_bipolar_to_scale() in exported "C" code
   boolean b_use_bts_int;         // true=emit loc_bipolar_to_scale_int() in exported "C" code
   boolean b_use_int_module;      // true=emit mulsw/.. functions for "int" subtree(s)
   boolean b_use_float_fallback;  // true=emit float utility functions in integer mode
   boolean b_use_trc;             // true=include stdio.h in C code (printf)

   boolean b_in_float_fallback;  // true=currently in emitFloatFallback() (=> convert int vars to float)

   String s_ext_inc;
   CyExtMod *[] ext_mods;
   int next_ext_instance_nr;
   String s_ext_pre;
   String s_ext_static;
   String s_ext_init;
   String s_ext_new;     // voice_new()
   String s_ext_delete;  // voice_delete()
   String s_ext_noteon;
   String s_ext_voice;
   String s_ext_prepare;
   String s_ext_prepare_first;
   String s_ext_prepare_next;


   // <method.png>
   public method init(Sample _sample, CyclePatch _patch) {
      parent_sample <= _sample;
      parent_patch  <= _patch;

      sample_rate = 48000.0;
      base_freq   = 261.63; // c-5
      base_oct    = 0.0;

      curve_aliases.alloc(CyclePatch.TOTAL_NUM_CURVES);
      curve_aliases.useAll();

      curve_intarrays.alloc(CyclePatch.TOTAL_NUM_CURVES);
      curve_intarrays.useAll();

      // Lazy-init sine table
      if(int_sine_tbl.isEmpty())
      {
         calcIntSineTbl();

         int_xfade_buf.allocAndFill(MAX_XFADE_FRAMES * MAX_OVERSAMPLE_FACTOR, 0);
         float_xfade_buf.allocAndFill(MAX_XFADE_FRAMES * MAX_OVERSAMPLE_FACTOR, 0);
      }

      oversample_factor = 1.0;
      oversample_quality = 4;

      dither_mode = 0;

      num_audio_lanes = 0;
   }

   // <method_exit.png>
   public method exit() {
      unloadVoicePlugins();
   }

   // <method.png>
   public method unloadVoicePlugins() {
      CyModuleVpl *modVpl;
      // trace "xxx unloadVoicePlugins: vpl_modules="+#(vpl_modules);
      foreach modVpl in vpl_modules
      {
         modVpl.unloadVoicePlugin();
      }
   }

   // <method.png>
   public method reloadVoicePlugins() {
      CyModuleVpl *modVpl;
      // trace "xxx reloadVoicePlugins: vpl_modules="+#(vpl_modules);
      foreach modVpl in vpl_modules
      {
         modVpl.reloadVoicePlugin();
      }
   }

   // // <method.png>
   // protected method calcIntSineTbl_float() {
   //    int_sine_tbl.alloc(16384);
   //    float a = 0;
   //    float w = 2PI / 16384.0;
   //    loop(16384)
   //    {
   //       int_sine_tbl.add(sin(a) * (FX_ONE-1));
   //       a += w;
   //    }
   // }

   // <method.png>
   define int QCOS_BITS = 16;
   define int QCOS_ONE  = (1 << QCOS_BITS);
   define int QCOS_MASK = (QCOS_ONE - 1);
   protected method calcIntSineTbl() {
      // (note) same as in TSR "C" implementation
      int_sine_tbl.alloc(16384);
      int_sine_tbl.useAll();
      local IntArray qcos; // quarter cos tbl
      qcos.visit(int_sine_tbl, 4096, 4096);

      // calc quarter cos tbl
      int k = 0;
      for(int a = 0; a < (QCOS_ONE/4); a += (QCOS_ONE/16384)/*4*/)  // 4096 elements
      {
         int x = a - ((int)(QCOS_ONE * 0.25 + 0.5)) + ((a + ((int)(QCOS_ONE * 0.25 + 0.5)))&~QCOS_MASK);
         x = ((x * ((x<0?-x:x) - ((int)(QCOS_ONE * 0.5 + 0.5)))) >> QCOS_BITS) << 4;
         x += (((((int)(QCOS_ONE * 0.225 + 0.5)) * x) >> QCOS_BITS) * ((x<0?-x:x) - QCOS_ONE)) >> QCOS_BITS;
         qcos[k++] = ((short)(x >> (QCOS_BITS - 11)));
         // printf("xxx cos=%f\n",(s[-1]/2048.0f));
      }

      // 0Â°..90Â° (rev qtbl)
      int j = 4096;
      k = 0;
      loop(4096)
         int_sine_tbl[k++] = qcos[--j];

      // 90..180Â° = cos tbl
      k += 4096;

      // 180Â°..360Â° (y-flip first half of tbl)
      j = 0;
      loop(8192)
         int_sine_tbl[k++] = -int_sine_tbl[j++];

      if(0)
      {
         for(int i = 0; i < 16384; i++)
            trace "xxx sine["+i+"]="+(int_sine_tbl[i]/2048.0f);
      }
   }

   // <method.png>
   public static AppendIndentedLines(String _d, String _s, int _indent) {
      local StringArray lines <= _s.splitChar('\n');
      local String *line;
      foreach line in lines
      {
         _d.appendRepeat(" ", _indent);
         _d.append(line);
         _d.append("\n");
      }
   }

   // <method.png>
   protected method updateNoteFreq() {
      note_freq = base_freq * mathPowerf(2, base_oct);
      note_speed       = note_freq / (sample_rate * oversample_factor);
      note_speed_fixed = 261.63f   / (sample_rate * oversample_factor);
      if(b_debug1)
         trace "xxx Cycle::updateNoteFreq: note_freq="+note_freq+" base_freq="+base_freq+" base_oct="+base_oct;
   }

   // <method.png>
   public method debugPrintTree() {
      CyLane *lane;
      int level = 0;
      foreach lane in lanes
      {
         trace "<"+lane.id+":";
         lane.debugPrintTree(level);
      }
   }

   // <method.png>
   protected method pushParseContext(String      _name,
                                     boolean     _bIncLineIdx,
                                     StringArray _lines,
                                     int         _lineIdx,
                                     CyTemplate  _templateOrNull,
                                     String      _templateInstanceIdOrNull  // null or deletable string
                                     ) {
      // trace "xxx enter pushParseContext. backtrace:";
      // Utils.Backtrace();

      if(null != cur_parse_context)
      {
         if(_bIncLineIdx)
            cur_parse_context.cur_line_idx++;
      }
      cur_parse_context <= new CyParseContext;
      cur_parse_context.initParseContext(deref _name,
                                         deref _lines,
                                         _lineIdx,
                                         _templateOrNull,
                                         deref _templateInstanceIdOrNull,
                                         cur_lane,
                                         cur_mod,
                                         cur_input
                                         );
      parse_context_stack.add(#(deref cur_parse_context));
      // trace "xxx push parse_context_stack="+#(parse_context_stack);
      input_stack <= cur_parse_context.input_stack;
      if(0 || b_debug3)
      {
         trace "xxx pushParseContext bIncLineIdx="+_bIncLineIdx+" newCtx="+#(cur_parse_context)+" name=\""+_name+"\" lineIdx="+_lineIdx+" _templateOrNull="+#(_templateOrNull)+" input_stack="+#(input_stack)+" cur_input.id="+((null != cur_input)?cur_input.id:"n/a")+" cur_lane="+#(cur_lane)+" cur_lane.id="+((null !=cur_lane)?cur_lane.id:"n/a")+" cur_mod="+#(cur_mod)+" cur_input="+#(cur_input);
         // Utils.Backtrace();
      }
      // // // words <= new StringArray; // xxx
      // // // words[0]= "";

      // // // cur_input <= null;
   }

   // <method.png>
   protected method finishUIPatchAndUnset() {
      if(null != cur_ui_patch)
      {
         String sUIPatchBuffer <= parent_patch.getOrCreateSourceBufferRef(cur_ui_patch.getPatchBufferName());
         cur_ui_patch.emitPatchBuffer(sUIPatchBuffer);
         cur_ui_patch <= null;
      }
   }

   // <method.png>
   protected method popParseContext(boolean _bKeepLineIdx) {
      if(b_debug3)
      {
         trace "xxx popParseContext cur="+#(cur_parse_context)+" line_idx="+cur_parse_context.cur_line_idx+" parse_context_stack="+#(parse_context_stack)+" num="+parse_context_stack.numElements;
         // Utils.Backtrace();
      }
      StringArray oldLines <= cur_parse_context.lines;
      if(b_debug3)
         trace "xxx    restore_lane="+#(cur_parse_context.restore_lane);
      cur_lane  <= cur_parse_context.restore_lane;
      cur_mod   <= cur_parse_context.restore_mod;
      cur_input <= cur_parse_context.restore_input;
      // trace "xxx       restore cur_lane="+#(cur_lane);
      // trace "xxx       restore cur_input="+#(cur_input)+" cur_input.id="+((null != cur_input)?cur_input.id:"n/a");

      cur_ui_module_def <= null;
      finishUIPatchAndUnset();

      if(parse_context_stack.numElements > 1)
      {
         int lineIdx = cur_parse_context.cur_line_idx;
         parse_context_stack.numElements--;
         cur_parse_context <= parse_context_stack.last;
         input_stack <= cur_parse_context.input_stack;
         // // cur_lane  <= cur_parse_context.restore_lane;
         // // cur_mod   <= cur_parse_context.restore_mod;
         // // cur_input <= cur_parse_context.restore_input;
         if(b_debug3)
         {
            trace "xxx       restore cur_parse_context="+#(cur_parse_context);
            trace "xxx       restore cur_lane="+#(cur_lane)+" cur_lane.id="+((null !=cur_lane)?cur_lane.id:"n/a")+" cur_mod="+#(cur_mod)+" cur_input="+#(cur_input);
            trace "xxx       restore cur_mod="+#(cur_mod);
         }
         if(null != cur_mod)
         {
            if(b_debug3)
               trace "xxx           cur_mod.seq_next="+#(cur_mod.seq_next);
            while(cur_mod.seq_next)
               cur_mod <= cur_mod.seq_next;
         }
         if(b_debug3)
         {
            trace "xxx       restore cur_input="+#(cur_input);
            trace "xxx       restore input_stack="+#(input_stack);
         }
         words <= cur_parse_context.cur_words;
         if(b_debug3)
            trace "xxx       restore words="+#(words);
         if(_bKeepLineIdx || @(cur_parse_context.lines) == @(oldLines))
         {
            cur_parse_context.cur_line_idx = lineIdx;
            if(b_debug3)
               trace "          continue at line_idx="+cur_parse_context.cur_line_idx;
         }
         cur_parse_context.beginLine(0);
         words <= cur_parse_context.cur_words;
         return;
      }
      cur_parse_context <= null;
      input_stack       <= null;
      cur_lane          <= null;
      cur_mod           <= null;
      cur_input         <= null;
      words             <= null;
      if(b_debug3)
         trace "xxx       restore cur_parse_context=<null>";
   }

   // <method_get.png>
   public method getSrcLoc() : String {
      return cur_parse_context.getSrcLoc();
   }

   // <method.png>
   protected method pushInput() {
      if(b_debug2)
         trace "xxx pushInput: input_stack="+#(input_stack)+" cur_input.id="+cur_input.id+" cur_input.indent="+cur_input.indent;
      input_stack.add(cur_input);
   }

   // <method.png>
   protected method popInput() {
      if(b_debug2)
         trace "xxx popInput: cur_input="+#(cur_input)+" cur_input.id="+cur_input.id+" input_stack="+#(input_stack);
      // // boolean bUpdateRestore = (@(cur_input) == @(cur_parse_context.restore_input));

      if(input_stack.numElements > 1)
      {
         input_stack.numElements--;
         cur_input <= input_stack.last;
      }
      else if(input_stack.numElements > 0)
      {
         input_stack.empty();
         cur_input <= null;
      }
      // if(input_stack.numElements > 0)
      //    cur_input <= null;
      else
         throw CyStackUnderflowError getSrcLoc()+": stack is empty";

      // // if(bUpdateRestore)
      // //    cur_parse_context.restore_input <= cur_input;
   }

   // <method_add.png>
   protected method parseValue(CyValue v, boolean _bAllowGroupOrSection) : int {
      // returns new wIdx
      v.id = words[1].toLower();

      int numWords = words.numElements;
      int wIdx = 2;

      if("=" == words.get(wIdx))
         wIdx++;

      if("=" != words.get(wIdx+1))
      {
         if(wIdx < numWords)
         {
            v.def_value = ParseFloat(words[wIdx]);
            v.cur_value = v.def_value;
            if(b_debug2) trace "xxx value \""+v.id+"\" def="+v.def_value;
            wIdx++;
         }
         else if(this instanceof CyArg)
            throw CyParseError getSrcLoc()+": error parsing default value";
      }

      boolean bHaveMin = false;
      boolean bHaveMax = false;

      while(wIdx < numWords)
      {
         // trace "xxx value w=\""+words.get(wIdx)+"\"";
         switch(words[wIdx])
         {
            default:
               if(!bHaveMin)
               {
                  v.min_value = ParseFloat(words[wIdx++]);
                  bHaveMin = true;
               }
               else if(!bHaveMax)
               {
                  v.max_value = ParseFloat(words[wIdx++]);
                  bHaveMax = true;
               }
               else
                  throw CyParseError getSrcLoc()+": invalid attrib \""+words[wIdx-1]+"\"";
               break;

            case "min":
               if(((wIdx+2) < numWords) && ("=" == words[wIdx+1]))
               {
                  v.min_value = ParseFloat(words[wIdx+2]);
                  // trace "xxx value \""+v.id+"\" min="+v.min_value;
                  wIdx += 3;
                  bHaveMin = true;
               }
               else
               {
                  throw CyParseError getSrcLoc()+": error parsing \"min\" attrib";
               }
               break;

            case "max":
               if(((wIdx+2) < numWords) && ("=" == words[wIdx+1]))
               {
                  v.max_value = ParseFloat(words[wIdx+2]);
                  // trace "xxx var \""+v.id+"\" max="+v.max_value;
                  wIdx += 3;
                  bHaveMax = true;
               }
               else
               {
                  throw CyParseError getSrcLoc()+": error parsing \"min\" attrib";
               }
               break;

            case "group":
               if(((wIdx+2) < numWords) && ("=" == words[wIdx+1]))
               {
                  if(!_bAllowGroupOrSection)
                  {
                     throw CyParseError getSrcLoc()+": \"group\" attrib not allowed here";
                  }
                  v.group_name <= Object(words[wIdx+2]);
                  wIdx += 3;
               }
               else
               {
                  throw CyParseError getSrcLoc()+": error parsing \"group\" attrib";
               }
               break;

            case "section":
            case "sec":
               if(((wIdx+2) < numWords) && ("=" == words[wIdx+1]))
               {
                  if(!_bAllowGroupOrSection)
                  {
                     throw CyParseError getSrcLoc()+": \"section\" attrib not allowed here";
                  }
                  v.section_name <= Object(words[wIdx+2]);
                  wIdx += 3;
               }
               else
               {
                  throw CyParseError getSrcLoc()+": error parsing \"section\" attrib";
               }
               break;

            case "smooth":
               if(((wIdx+2) < numWords) && ("=" == words[wIdx+1]))
               {
                  v.b_smooth = int(words[wIdx+2]);
                  wIdx += 3;
               }
               else
               {
                  throw CyParseError getSrcLoc()+": error parsing \"smooth\" attrib";
               }
               break;
         }
      }

      if(!bHaveMin)
         v.min_value = v.def_value < 0 ? v.def_value : 0;

      if(!bHaveMax)
         v.max_value = v.def_value > 1 ? v.def_value : 1;

      return wIdx;
   }

   // <method_add.png>
   protected method addArg(boolean _bLocal) : CyArg {
      local CyArg a;
      a.init();
      a.b_local = _bLocal;
      args.add(#(deref a));
      parseValue(a, true/*bAllowGroupOrSection*/);
      if(b_debug2) trace "xxx addArg id=\""+a.id+"\"";
      return a;
   }
   
   // <method_parse.png>
   protected method parseArgValues() {
      // arg_values <arg_name> {<value>=<name>}
      if(words.numElements > 1)
      {
         // Param id
         CyArg arg <= findArgById(words.get(1));
         if(null != arg)
         {
            // parse value=name tuples
            int argValWordIdx = 2;
            while(argValWordIdx < (words.numElements-2))
            {
               arg.addPreset(float(words.get(argValWordIdx+0)),
                             words.get(argValWordIdx+2)
                             );
               argValWordIdx += 3;
            }
            // arg.scalePresetValuesToMinMaxRange();
            Global.Debug2("Cycle: arg \'"+words.get(1)+"\' has "+arg.getNumPresets()+" preset value(s)");
         }
         else
            throw CyArgNotFoundError getSrcLoc()+": undeclared arg \""+words.get(1)+"\"";
      }
   }

   // <method_find.png>
   protected method findArgById(String _id) : CyArg {
      CyArg *a;
      foreach a in args
      {
         // trace "xxx findArg: v.id=\""+v.id+"\" id=\""+_id+"\"";
         if(a.id == _id)
            return a;
      }
      return null;
   }

   // <method_add.png>
   protected method addVar() : CyVar {
      local CyVar v;
      vars.add(#(deref v));
      parseValue(v, false/*bAllowGroupOrSection*/);
      if(null != cur_lane)
         v.id = cur_lane.id+"__"+v.id;
      v.id = cur_parse_context.var_prefix+v.id;
      if(b_debug2) trace "xxx addVar id=\""+v.id+"\"";
      return v;
   }

   // <method_add.png>
   protected method addVarInternal(String _id) : CyVar {
      local CyVar v;
      vars.add(#(deref v));
      v.id = _id;
      if(b_debug2) trace "xxx addVarInternal id=\""+v.id+"\"";
      return v;
   }

   // <method_remove.png>
   protected method removeVarInternal(String _id) {
      CyVar v <= findVarById(_id);
      if(null != v)
      {
         vars.remove(v);
      }
   }

   // <method_find.png>
   protected method findVarById(String _id) : CyVar {
      CyVar *v;
      foreach v in vars
      {
         // trace "xxx findVar: v.id=\""+v.id+"\" id=\""+_id+"\"";
         if(v.id == _id)
            return v;
      }
      return null;
   }

   // <method_find.png>
   protected method findLaneOrGlobalVarById(String _id) : CyVar {
      // read or write access (e.g. "$myvar")
      local CyVar *v;
      if(null != cur_lane)
      {
         if(cur_parse_context.var_prefix != "")
            v <= findVarById(cur_parse_context.var_prefix+cur_lane.id+"__"+_id);
         else
            v <= findVarById(cur_lane.id+"__"+_id);
      }
      else if(cur_parse_context.var_prefix != "")
         v <= findVarById(cur_parse_context.var_prefix+_id);
      if(null == v && (null != cur_parse_context.template_instance_id))
      {
         CyTemplateInstance tmplInstance <= findTemplateInstanceById(cur_parse_context.template_instance_id);
         if(null != tmplInstance)
            v <= findVarById("__ti_"+tmplInstance.class_id+"_"+tmplInstance.instance_id+"_"+_id);
      }
      if(null == v)
         v <= findVarById(_id);
      return v;
   }

   // <method_find.png>
   protected method findStoreLaneOrGlobalVarById(String _id) : CyVar {
      // write access (e.g. "sto somevar" or "sto mytemplinst.somevar")
      int idxDot = _id.indexOfChar('.', 0);
      if(-1 != idxDot)
      {
         // templateid.somevar
         local String objName <= Utils.ConvertToVarName(_id.substring(0, idxDot));
         local String fieldName <= Utils.ConvertToVarName(_id.substring(idxDot+1, 999));
         CyTemplateInstance tmplInstance <= findTemplateInstanceById(objName);
         if(null != tmplInstance)
            return findVarById("__ti_"+tmplInstance.class_id+"_"+tmplInstance.instance_id+"_"+fieldName);
         else
            return null;
      }
      return findLaneOrGlobalVarById(_id);
   }

   // <method_add.png>
   protected method addPluginParam(String _prefixOrNull, Integer retWIdx) : CyPluginParam {
      local CyPluginParam p;
      p.idx = plugin_params.numElements;
      plugin_params.add(#(deref p));
      retWIdx = parseValue(p, true/*bAllowGroupOrSection*/);
      if(null != _prefixOrNull)
         p.id = _prefixOrNull + p.id;
      if(b_debug2) trace "xxx addPluginParam id=\""+p.id+"\"";
      return p;
   }

   // <method_parse.png>
   protected method parseParamValues() {
      // param_values <param_name> {<value>=<name>}
      if(words.numElements > 1)
      {
         // Param id
         CyPluginParam p <= findPluginParamById(words.get(1));
         if(null != p)
         {
            // parse value=name tuples
            int paramValWordIdx = 2;
            while(paramValWordIdx < (words.numElements-2))
            {
               p.addPreset(float(words.get(paramValWordIdx+0)),
                           words.get(paramValWordIdx+2)
                           );
               paramValWordIdx += 3;
            }
            Global.Debug2("Cycle: param \'"+words.get(1)+"\' has "+p.getNumPresets()+" preset value(s)");
         }
         else
            throw CyParamNotFoundError getSrcLoc()+": undeclared param \""+words.get(1)+"\"";
      }
   }

   // <method_find.png>
   protected method findPluginParamById(String _id) : CyPluginParam {
      CyPluginParam *v;
      foreach v in plugin_params
      {
         // trace "xxx findVar: v.id=\""+v.id+"\" id=\""+_id+"\"";
         if(v.id == _id)
            return v;
      }
      return null;
   }

   // <method_find.png>
   protected method findPluginParamByBaseId(String _baseId) : CyPluginParam {
      CyPluginParam *v;
      foreach v in plugin_params
      {
         if(v.getBaseId() == _baseId)
            return v;
      }
      return null;
   }

   // <method_add.png>
   protected method addPluginMod(Integer retWIdx) : CyPluginMod {
      local CyPluginMod p;
      p.init();
      plugin_mods.add(#(deref p));
      retWIdx = parseValue(p, false/*bAllowGroupOrSection*/);
      if(b_debug2) trace "xxx addPluginMod id=\""+p.id+"\"";
      return p;
   }

   // <method_find.png>
   protected method findPluginModById(String _id) : CyPluginMod {
      CyPluginMod *v;
      foreach v in plugin_mods
      {
         // trace "xxx findVar: v.id=\""+v.id+"\" id=\""+_id+"\"";
         if(v.id == _id)
            return v;
      }
      return null;
   }

   // <method_find.png>
   protected method findMacroById(String _id) : CyMacro {
      // trace "xxx findMacroById(id=\""+_id+"\")";
      CyMacro *m;
      foreach m in macros
      {
         if(m.id == _id)
            return m;
      }
      return null;
   }

   // <method_find.png>
   protected method findMapById(String _id) : CyMap {
      CyMap *m;
      foreach m in maps
      {
         if(m.id == _id)
            return m;
      }
      return null;
   }

   // // // <method_parse.png>
   // // protected method parseArrayParam(String _paramName, int wIdx) {
   // // }

   // <method_find.png>
   public method findTemplateById(String _id) : CyTemplate {
      // (note) also called by CyclePatch::findBufferNameForTemplate()
      CyTemplate *t;
      foreach t in templates
      {
         if(t.id == _id)
            return t;
      }
      return null;
   }

   // <method_find.png>
   protected method findTemplateInstanceById(String _id) : CyTemplateInstance {
      // find by unique instance id
      CyTemplateInstance *t;
      foreach t in template_instances
      {
         if(t.instance_id == _id)
            return t;
      }
      return null;
   }

   // <method_parse.png>
   protected method parseCurveArrayParam(int    _copyCurveIdxOrMinus1,
                                         String _curveAliasOrNull,
                                         String _paramNameOrNull,
                                         int    wIdx
                                         ) : CyArrayDecl {
      int numWords = words.numElements;
      local CyArrayDecl ad;
      ad.init();
      ad.copy_curve_idx = _copyCurveIdxOrMinus1;
      // trace "yyy parseCurveArrayParam: _copyCurveIdxOrMinus1="+_copyCurveIdxOrMinus1+" _curveAliasOrNull="+_curveAliasOrNull;
      // // // array_decls[_curveIdx] = deref ad;
      array_decls.add(#(deref ad));

      local CyPluginParam *p;
      if(null != _paramNameOrNull)
      {
         p <= findPluginParamById(_paramNameOrNull);
         if(null != p)
            ad.param <= p;
         else
            throw CyParamNotFoundError getSrcLoc()+": array copyCurveIdx="+_copyCurveIdxOrMinus1+" undeclared ctl param \""+_paramNameOrNull+"\"";
      }

      boolean bHaveDpyMin = false;
      boolean bHaveDpyMax = false;

      for(;;)
      {
         if( (wIdx+2) < numWords )
         {
            String sKey <= words.get(wIdx++);
            if("=" != words.get(wIdx++))
               throw CyParseError getSrcLoc()+": expected '=' in attrib assignment (key=\""+sKey+"\")";
            String sVal <= words.get(wIdx++);
            switch(sKey)
            {
               default:
                  throw CyParseError getSrcLoc()+": invalid attrib \""+sKey+"\" (val=\""+sVal+"\")";

               case "size":
               case "s":
                  // trace "xxx CyScript::parseCurveArrayParam: array size=\""+sVal+"\"";
                  int arrayParamSize = int(sVal);
                  if(1 <= arrayParamSize <= MAX_ARRAY_PARAM_SIZE)
                  {
                     ad.size = arrayParamSize;
                  }
                  else
                     throw CyParseError getSrcLoc()+": invalid size="+arrayParamSize+" (must be 1.."+MAX_ARRAY_PARAM_SIZE+")";
                  break;

               case "var":
               case "v":
                  // trace "xxx CyScript::parseCurveArrayParam: numVar="+sVal;
                  int arrayParamNumVar = int(sVal);
                  if(1 <= arrayParamNumVar <= MAX_ARRAY_PARAM_VARIATIONS)
                  {
                     ad.num_variations = arrayParamNumVar;
                  }
                  else
                     throw CyParseError getSrcLoc()+": invalid var="+arrayParamNumVar+" (must be 1.."+MAX_ARRAY_PARAM_VARIATIONS+")";
                  break;

               case "param":
               case "p":
                  // Global.Debug2("CyScript::parseCurveArrayParam: array param curveAlias=\""+_curveAliasOrNull+"\" param=\""+sVal+"\"");
                  if(null == _paramNameOrNull)
                  {
                     p <= findPluginParamById(sVal);
                     if(null != p)
                     {
                        ad.param <= p;
                     }
                     else
                        throw CyParamNotFoundError getSrcLoc()+": curve \""+_curveAliasOrNull+"\" undeclared ctl param \""+sVal+"\"";
                  }
                  else
                     throw CyParseError getSrcLoc()+": array param name already set";
                  break;

               case "min":
                  ad.storage_min = float(sVal);
                  if(ad.storage_min < -1.0f || ad.storage_min > 1.0f)
                     throw CyParseError getSrcLoc()+": invalid storage min=\""+sVal+"\" (must be in range -1..1)";
                  break;

               case "max":
                  ad.storage_max = float(sVal);
                  if(ad.storage_max < -1.0f || ad.storage_max > 1.0f)
                     throw CyParseError getSrcLoc()+": invalid storage max=\""+sVal+"\" (must be in range -1..1)";
                  break;

               case "dpyMin":
               case "dmin":
                  // trace "xxx cycle: dpyMin sVal=\""+sVal+"\"";
                  ad.display_min = float(sVal);
                  bHaveDpyMin = true;
                  break;

               case "dpyMax":
               case "dmax":
                  ad.display_max = float(sVal);
                  bHaveDpyMax = true;
                  break;

               case "dpyPrec":
               case "dprec":
                  ad.display_prec = int(sVal);
                  if(ad.display_prec < 0 || ad.display_prec > 7)
                     throw CyParseError getSrcLoc()+": invalid dpyPrec=\""+sVal+"\" (must be in range 0..7)";
                  break;

            }

         }
         else
            break;
      } // read extended array param attribs

      if(ad.storage_min == ad.storage_max)
         throw CyParseError getSrcLoc()+": invalid storage range (min==max=="+ad.storage_min+")";

      // trace "xxx ad.storage_min="+ad.storage_min;
      // trace "xxx ad.storage_max="+ad.storage_max;
      // trace "xxx ad.display_min="+ad.display_min;
      // trace "xxx ad.display_max="+ad.display_max;

      if(!bHaveDpyMin)
         ad.display_min = ad.storage_min;

      if(!bHaveDpyMax)
         ad.display_max = ad.storage_max;

      if(ad.display_min == ad.display_max)
         throw CyParseError getSrcLoc()+": invalid display range (dpyMin==dpyMax=="+ad.display_min+")";

      if(0 == ad.size || null == ad.param || 0 == ad.num_variations)
      {
         if(null == _curveAliasOrNull)
            throw CyIncompleteArrayParam getSrcLoc()+": (curve) array param \""+_paramNameOrNull+"\" 'size' or 'var' attrib missing";
         else
            throw CyIncompleteArrayParam getSrcLoc()+": (curve) array \""+_curveAliasOrNull+"\" 'size', 'param' or 'var' attrib missing";
      }

      return ad;
   }

   // <method_parse.png>
   protected method addCurveAlias(boolean _bLocal) : CyArrayDecl {
      // returns null or CyArrayDecl instance (when curve is associated with array param)
      //   (note) throws an exception if an error occured
      int numWords = words.numElements;
      int wIdx = 1;
      if(wIdx < numWords)
      {
         String sCurveIdx <= words.get(wIdx);
         int curveIdx = -1;
         if(sCurveIdx.checkIntConversion())
         {
            if(_bLocal)
               throw CyParseError getSrcLoc()+": abs lcurve index not allowed";
            curveIdx = sCurveIdx;
            if!(0 <= curveIdx < CyclePatch.NUM_USER_CURVES)
               throw CyParseError getSrcLoc()+": curve index "+curveIdx+" out of bounds (max="+CyclePatch.NUM_USER_CURVES+")";
            parent_patch.reserveCurveIndex(curveIdx);
            wIdx++;
         }
         if(wIdx < numWords)
         {
            String curveAlias <= words.get(wIdx++);

            if(curveIdx < 0)
            {
               // auto-enumerate curve
               // trace "xxx addCurveAlias: bLocal="+_bLocal+" alias="+curveAlias+" cur_parse_context.template_instance_id="+cur_parse_context.template_instance_id;
               curveIdx = parent_patch.allocCurveIndex(curveAlias, _bLocal);
               if(curveIdx < 0)
                  throw CyParseError getSrcLoc()+": failed to allocate index for curve alias=\""+curveAlias+"\"";
            }

            // trace "xxx addCurveAlias: id="+curveAlias+" idx="+curveIdx;

            curve_aliases[curveIdx] = curveAlias;

            if(wIdx < numWords)
            {
               // Curve is associated with (plugin) array param, parse extended attribs (param/size/var/dpyMin/..)
               return parseCurveArrayParam(curveIdx, curveAlias, null/*paramName*/, wIdx);
            }
         }
         else
            throw CyParseError getSrcLoc()+": expected curve idx or curve id/alias";
      }
   }

   // <method_parse.png>
   protected method addArrayDecl() : CyArrayDecl {
      int numWords = words.numElements;
      int wIdx = 1;
      if(wIdx < numWords)
      {
         int curveIdx = -1;
         String sCopyCurveIdx <= words.get(wIdx);
         if(sCopyCurveIdx.checkIntConversion())
         {
            curveIdx = sCopyCurveIdx;
            if!(-1 <= curveIdx < CyclePatch.NUM_USER_CURVES)
               throw CyParseError getSrcLoc()+": invalid copy curve idx \""+sCopyCurveIdx+"\" (must be -1 or 0.."+(CyclePatch.NUM_USER_CURVES-1)+")";
            wIdx++;
         }
         if(wIdx < numWords)
         {
            local String paramName <= words[wIdx++];
            if(curveIdx >= 0)
               curve_aliases[curveIdx] = paramName+" init";

            // Parse (plugin) array param extended attribs (param/size/var/dpyMin/..)
            return parseCurveArrayParam(curveIdx, null/*curveAlias*/, paramName, wIdx);
         }
      }
      else
         throw CyParseError getSrcLoc()+": expected param id";
   }

   // <method_parse.png>
   protected method parseArrayDeclElement() {
      // <elementIdx> <name> <dpyReset> <dpyMin> <dpyMax> <dpyPrec>
      int wIdx = 0;
      int elementIdx = words.get(0);

      if(elementIdx < cur_arraydecl.size)
      {
         int numWords = words.numElements;
         if(++wIdx < numWords)
         {
            local String elementName <= words.get(wIdx);

            float elementDpyReset = 0.0f;
            float dpyMin = cur_arraydecl.display_min;
            float dpyMax = cur_arraydecl.display_max;
            float elementDpyMin   = dpyMin;
            float elementDpyMax   = dpyMax;
            int   elementDpyPrec  = cur_arraydecl.display_prec;
            if(++wIdx < numWords)
            {
               elementDpyReset = words.get(wIdx);

               if(1 || dpyMin <= elementDpyReset <= dpyMax)
               {
                  if(++wIdx < numWords)
                  {
                     elementDpyMin = words.get(wIdx);

                     if(1 || dpyMin <= elementDpyMin <= dpyMax)
                     {
                        if(++wIdx < numWords)
                        {
                           elementDpyMax = words.get(wIdx);

                           if(1 || dpyMin <= elementDpyMin <= dpyMax)
                           {
                              if(++wIdx < numWords)
                              {
                                 elementDpyPrec = words.get(wIdx);

                                 if(0 <= elementDpyPrec <= 7)
                                 {
                                    // ok
                                 }
                                 else
                                    throw CyParseError getSrcLoc()+": element dpyPrec="+elementDpyPrec+" range is 0..7";
                              }
                           }
                           else
                              throw CyParseError getSrcLoc()+": element dpyMax="+elementDpyMax+" exceeds array display range ("+dpyMin+".."+dpyMax+")";
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": element dpyMin="+elementDpyMin+" exceeds array display range ("+dpyMin+".."+dpyMax+")";
                  }
               }
               else
                  throw CyParseError getSrcLoc()+": element dpyReset="+elementDpyReset+" exceeds array display range ("+dpyMin+".."+dpyMax+")";
            }

            cur_arraydecl.addElementInfo(elementIdx, elementName, elementDpyReset, elementDpyMin, elementDpyMax, elementDpyPrec);
         }
         else
            throw CyParseError getSrcLoc()+": missing element name";
      }
      else
         throw CyParseError getSrcLoc()+": elementIdx="+elementIdx+" exceeds array param size="+cur_arraydecl.size;
   }

   // <method_find.png>
   public method findArrayDeclByPluginParam(CyPluginParam _p) : CyArrayDecl {
      CyArrayDecl *arrayDecl;
      foreach arrayDecl in array_decls
      {
         if(@(arrayDecl.param) == @(_p))
            return arrayDecl;
      }
      return null;
   }

   // <method_find.png>
   public method findArrayDeclByPluginParamId(String _paramId) : CyArrayDecl {
      CyArrayDecl *arrayDecl;
      foreach arrayDecl in array_decls
      {
         // trace "yyy findArrayDeclByPluginParamId: arrayDecl.param.id=\""+(arrayDecl.param.id)+"\" _paramId=\""+_paramId+"\"";
         if(arrayDecl.param.id == _paramId)
            return arrayDecl;
      }
      return null;
   }

   // <method_find.png>
   public method findArrayDeclByCopyCurveIdx(int _copyCurveIdx) : CyArrayDecl {
      // [deprecated] (used by some old patches. update them to use array param id instead then remove this)
      CyArrayDecl *arrayDecl;
      foreach arrayDecl in array_decls
      {
         if(arrayDecl.copy_curve_idx == _copyCurveIdx)
            return arrayDecl;
      }
      return null;
   }

   // <method_find.png>
   public method findCurveAliasByIndex(int _idx) : String {
      return curve_aliases.get(_idx);
   }

   // <method_find.png>
   public method findCurveIndexByAlias(String _id) : int {
      return curve_aliases.indexOfObject(_id, 0);
   }

   // <method_get.png>
   public method isCurveUsed(int _idx) : boolean {
      return !curve_aliases.get(_idx).isBlank();
   }

   // <method_set.png>
   public method setCurveTable(int _idx, IntArray _ia) {
      curve_intarrays[_idx] = _ia;
   }

   // <method_add.png>
   protected method addLUT() {
      int numWords = words.numElements;
      int wIdx = 1;

      if(wIdx < numWords)
      {
         String sLutId = Utils.ConvertToVarName(words.get(wIdx++));
         if(null != findLUTById(sLutId))
         {
            // e.g. when declared by template which is instantiated multiple times
            trace "[dbg] CyScript::addLUT:"+getSrcLoc()+": LUT \""+sLutId+"\" already declared,, skipping..";
            return;
         }
         CyLUT lut <= new CyLUT;
         lut.init();
         lut.id = sLutId;
         luts.add(#(deref lut));
         // trace "xxx addLUT: declare lut.id="+lut.id;

         // parse (optional) lut mode (voice or shared)
         if(wIdx < numWords)
         {
            String sType <= words.get(wIdx++);
            switch(sType)
            {
               default:
                  if(sType.checkIntConversion())
                  {
                     // "lut <name> <size>"  shortform  (skip <type> / set to 'shared')
                     lut.b_voice = false;
                     wIdx--;
                     break;
                  }
                  throw CyParseError getSrcLoc()+": LUT mode be be 'voice' or 'shared' (have=\""+words.get(wIdx-1)+"\")";

               case "voice":  // [default]
               case "wt":
                  if(isPlugin())
                     lut.b_voice = true;
                  else
                  {
                     trace "[~~~] CyScript: "+getSrcLoc()+": ignoring 'voice' LUT mode outside of plugin mode";
                     lut.b_voice = false;
                  }
                  break;

               case "shared":
                  lut.b_voice = false;
                  break;
            }

            // parse (optional) lut width
            if(wIdx < numWords)
            {
               int lutW = words.get(wIdx++);
               float l2 = (log(lutW) / log(2.0));
               if(l2 == int(l2 + 0.5))
               {
                  if(lutW <= lut.b_voice ? 1024 : 16384)
                  {
                     lut.lut_w = lutW;

                     // parse (optional) "inverse lookup" flag
                     if(wIdx < numWords)
                     {
                        if("inv" == words.get(wIdx++))
                        {
                           lut.b_inv = true;
                        }
                        else
                           throw CyParseError getSrcLoc()+": expected \"inv\" flag";
                     }
                  }
                  else
                     throw CyParseError getSrcLoc()+": "+(lut.b_voice?"voice":"shared")+" LUT width must be <= "+(lut.b_voice?1024:16384);
               }
               else
                  throw CyParseError getSrcLoc()+": LUT width must be a power of two";
            }
         }
      }
      else
         throw CyParseError getSrcLoc()+": expected LUT id";
   }

   // <method_find.png>
   public method findLUTById(String _id) : CyLUT {
      CyLUT *lut;
      foreach lut in luts
      {
         // trace "xxx findLUTById: lut.id=\""+lut.id+"\" id=\""+_id+"\"";
         if(lut.id == _id)
            return lut;
      }
      return null;
   }

   // <method_add.png>
   protected method addZoneRef() {
      int numWords = words.numElements;
      int wIdx = 1;
      if(wIdx < numWords)
      {
         String zoneId <= words.get(wIdx);
         int zoneIdx;
         if((1 == zoneId.numChars) && (zoneId.checkIntConversion()))
         {
            zoneIdx = zoneId;
            if(zoneIdx != zone_ids.numElements)
               throw CyParseError getSrcLoc()+": non-sequential zone idx="+zoneIdx+" (should be "+zone_ids.numElements+")";
            if(++wIdx < numWords)
            {
               zoneId <= words.get(wIdx);
            }
            else
               throw CyParseError getSrcLoc()+": expected zone id after zone index";
         }
         else
         {
            // automatic zone idx
            zoneIdx = zone_ids.numElements;
         }

         zone_ids[zoneIdx] = zoneId;
         int idxDot = zoneId.indexOfChar('.', 0);
         if(-1 != idxDot)
         {
            zone_smp_refs[zoneIdx] = zoneId.substring(0, idxDot);
            zoneId.substring(idxDot+1,-1);
         }
         else
            zone_smp_refs[zoneIdx] = "";
         zone_refs[zoneIdx] = zoneId;
      }
      else
         throw CyParseError getSrcLoc()+": expected zone id";
   }

   // <method_parse.png>
   static ParseNoteOrFloatRatio(String _s) : float {
      StringArray midiNotes <= MIDI.midi_notes;
      local StringArray aNote <= _s.splitChar('/');
      // trace "xxx ParseNoteOrFloatRatio s="+_s;
      if(aNote.numElements > 1)
      {
         int idxNote1 = midiNotes.indexOfObject(aNote.get(0).trim().toUpper(), 0);
         if(idxNote1 >= 0)
         {
            // note ratio, e.g. C-4/G-5
            int idxNote2 = midiNotes.indexOfObject(aNote.get(1).trim().toUpper(), 0);
            float fNote1 = Audio.NoteToFreq(idxNote1);
            float fNote2 = Audio.NoteToFreq(idxNote2);
            if(b_debug2)
               trace "xxx note ratio idx1="+idxNote1+" idx2="+idxNote2+" f1="+fNote1+" f2="+fNote2+" => ratio="+(fNote1 / fNote2);
            return (fNote1 / fNote2);
         }
         else
         {
            // generic float ratio, e.g. 16574/64
            return float(aNote.get(0).trim()) / float(aNote.get(1).trim());
         }
      }
      else
         return 1.0;
   }

   // <method_parse.png>
   static ParseFloat(String _s) : float {
      if(-1 != _s.indexOfChar('/', 0))
         return ParseNoteOrFloatRatio(_s);
      return _s;
   }

   // <method_parse.png>
   static ParseNoteFreq(String _s) : float {
      // "C-3"
      // or "C-3+0.1"
      // or "C-3-0.1"
      StringArray midiNotes <= MIDI.midi_notes;
      if(b_debug2)
         trace "xxx ParseNoteFreq: s=\""+_s+"\"";
      int idxFine = _s.lastIndexOf("-");
      if(idxFine < 2)
         idxFine = _s.lastIndexOf("+");
      float fine = 0;
      if(-1 != idxFine)
      {
         fine = _s.substring(idxFine+1, -1);
         _s.substring(0, idxFine);
         if(b_debug2)
            trace "xxx idxFine="+idxFine+" fine="+fine+" new_s=\""+_s+"\"";
      }
      int idxNote = midiNotes.indexOfObject(_s.toUpper(), 0);
      if(-1 != idxNote)
      {
         float fNote = Audio.NoteToFreq(idxNote + fine);
         if(b_debug2)
            trace "xxx ParseNoteFreq: s=\""+_s+"\" idxNote="+idxNote+" fNote="+fNote;
         return fNote;
      }
      else
         return 0;
   }

   // <method_parse.png>
   protected method parseConstOrVar(String type, CyModule _modOrNull, CyInput _inputOrNull) : CyModule {
      local CyModuleCon *modCon;

      // ratio
      int conv = type.checkConversions();
      boolean bIsFloatOrInt = (YAC_TYPE_FLOAT == conv || YAC_TYPE_INT == conv);
      if(-1 != type.indexOfChar('/', 0))
      {
         // note ratio, e.g. "d#3/c-3"
         modCon <= new CyModuleCon;
         modCon.parent_script <= this;
         modCon.const_val      = ParseNoteOrFloatRatio(type);
         return deref modCon;
      }
      else if('$' == type.getc(0))
      {
         String varId <= type.substring(1,-1);
         varId.toLower();

         // arg
         CyArg arg <= findArgById(varId);
         if(null != arg)
         {
            local CyModuleArg modArg <= new CyModuleArg;
            modArg.parent_script <= this;
            modArg.arg_ref       <= arg;
            return deref modArg;
         }

         // Plugin param
         CyPluginParam pluginParam <= findPluginParamById(varId);
         if(null != pluginParam)
         {
            local CyModulePluginParam modParam <= new CyModulePluginParam;
            modParam.parent_script <= this;
            modParam.var_ref       <= pluginParam;
            return deref modParam;
         }

         // Plugin mod
         CyPluginMod pluginMod <= findPluginModById(varId);
         if(null == pluginMod)
            pluginMod <= findPluginModById("m_"+varId);
         if(null != pluginMod)
         {
            local CyModulePluginMod modMod <= new CyModulePluginMod;
            modMod.parent_script <= this;
            modMod.var_ref       <= pluginMod;
            return deref modMod;
         }

         // variable
         local CyModuleVar modVar <= new CyModuleVar;
         modVar.parent_script <= this;
         modVar.var_ref       <= findLaneOrGlobalVarById(varId);
         if(null != modVar.var_ref)
            return deref modVar;
         if(!bIsFloatOrInt)
            throw CyVarNotFoundError getSrcLoc()+": undeclared arg or var \""+varId+"\"";
      }

      if(bIsFloatOrInt)
      {
         // constant
         modCon <= new CyModuleCon;
         modCon.parent_script <= this;
         modCon.const_val      = float(type);
         return deref modCon;
      }
      else
      {
         // constant name
         if(null != _modOrNull && null != _inputOrNull)
         {
            float constVal = _modOrNull.findInputConstant(_inputOrNull.id, type);
            if(-999999 != constVal)
            {
               // e.g. "svf mode=hpf"
               modCon <= new CyModuleCon;
               modCon.parent_script <= this;
               modCon.const_val      = constVal;
               return deref modCon;
            }
         }

         // macro or map field or template var or plugin array param element
         int idxDot = type.indexOfChar('.', 0);
         if(-1 != idxDot)
         {
            local String objName <= Utils.ConvertToVarName(type.substring(0, idxDot));
            // trace "xxx typeDot=\""+type+"\" idxDot="+idxDot+" objName=\""+objName+"\"";
            local String fieldName <= Utils.ConvertToVarName(type.substring(idxDot+1, 999));

            CyMacro m   <= findMacroById(objName);
            CyMap   map <= findMapById(objName);
            CyTemplateInstance tmplInstance <= findTemplateInstanceById(objName);

            if(null != m)
            {
               StringArray macroFieldNames <= m.field_names;
               if(macroFieldNames.containsObject(fieldName))
               {
                  local CyModuleMacroVar modMacroVar <= new CyModuleMacroVar;
                  modMacroVar.parent_script <= this;
                  modMacroVar.macro_id   = objName;
                  modMacroVar.field_name = fieldName;
                  return deref modMacroVar;
               }
               else
                  throw CyMacroFieldNotFoundError getSrcLoc()+": macro has no field named \""+fieldName+"\"";
            }
            else if(null != map)
            {
               StringArray mapFieldNames <= map.field_names;
               int mapFieldIdx = mapFieldNames.indexOfObject(fieldName, 0);
               if(mapFieldIdx >= 0)
               {
                  local CyModuleMap modMap <= new CyModuleMap;
                  modMap.parent_script <= this;
                  modMap.map_ref       <= map;
                  modMap.field_idx      = mapFieldIdx;
                  return deref modMap;
               }
               else
                  throw CyMapFieldNotFoundError getSrcLoc()+": map has no field named \""+fieldName+"\"";
            }
            else if(null != tmplInstance)
            {
               // mytemplateinstance.somevar
               local CyModuleVar templateVar <= new CyModuleVar;
               templateVar.parent_script <= this;
               templateVar.var_ref       <= findLaneOrGlobalVarById("__ti_"+tmplInstance.class_id+"_"+tmplInstance.instance_id+"_"+fieldName);
               if(null == templateVar.var_ref)
                  throw CyVarNotFoundError getSrcLoc()+": template class \""+tmplInstance.class_id+"\" instance \""+tmplInstance.instance_id+"\" has no var \""+fieldName+"\"";
               return deref templateVar;
            }
            else
            {
               local CyPluginParam p <= findPluginParamById(objName);
               if(null != p)
               {
                  local CyArrayDecl arrayDecl <= findArrayDeclByPluginParam(p);
                  if(null != arrayDecl)
                  {
                     int elementIdx = arrayDecl.findElementIdxByName(fieldName);
                     if(elementIdx >= 0)
                     {
                        local CyModulePluginArrayParamField modArrayField <= new CyModulePluginArrayParamField;
                        modArrayField.init();
                        modArrayField.param <= p;
                        modArrayField.array_decl <= arrayDecl;
                        modArrayField.element_idx = elementIdx;
                        return deref modArrayField;
                     }
                     else
                        throw CyMacroNotFoundError getSrcLoc()+": array param \""+objName+"\" has no element named \""+fieldName+"\"";
                  }
                  else
                     throw CyMacroNotFoundError getSrcLoc()+": \""+objName+"\" is not an array param";
               }
            }
            throw CyMacroNotFoundError getSrcLoc()+": undeclared macro or param or template instance \""+objName+"\"";
         }

      }

      if("vel" == type)
      {
         local CyModuleVel modVel <= new CyModuleVel;
         modVel.parent_script <= this;
         return deref modVel;
      }

      if("note" == type)
      {
         local CyModuleNote modNote <= new CyModuleNote;
         modNote.parent_script <= this;
         return deref modNote;
      }

      return null;
   }

   // <method_parse.png>
   protected method parseZoneIdx(Integer _wIdx) : int {
      if(_wIdx < words.numElements)
      {
         String zoneId <= words[_wIdx++];
         int zoneIdx;
         if((1 == zoneId.numChars) && zoneId.checkIntConversion())
         {
            zoneIdx = zoneId;
            if(zoneIdx >= zone_ids.numElements)
            {
               throw CyZoneNotFoundError getSrcLoc()+": zon: invalid zone idx "+zoneIdx+" (max="+(zone_ids.numElements-1)+")";
            }
         }
         else
            zoneIdx = zone_ids.indexOfObject(zoneId, 0);
         if(zoneIdx >= 0)
         {
            return zoneIdx;
         }
         else
            throw CyZoneNotFoundError getSrcLoc()+": zon: zone \""+words.get(_wIdx-1)+"\" not found";
      }
      else
         throw CyParseError getSrcLoc()+": zon: expected zone id";
   }

   // <method_add.png>
   protected method newMod(int _typeWordIdx, int _indent, String _opOrNull) {
      if(b_debug2)
         trace "xxx newMod typeWordIdx="+_typeWordIdx+" words="+#(words)+" cur_lane="+#(cur_lane)+" cur_lane.id="+((null !=cur_lane)?cur_lane.id:"n/a");
      int numWords = words.numElements;
      Integer wIdx = _typeWordIdx;
      String type <= words.get(wIdx++);

      local CyModule *mod;
      CyModuleVpl      *modVpl;
      CyModule         *modArg;
      CyModuleSto      *modSto;
      CyModuleInc      *modInc;
      CyModuleCmp      *modCmp;
      CyModuleEdge     *modEdge;
      CyModuleSeq      *modSeq;
      CyModuleExt      *modExt;
      CyModuleVar      *modVar;
      CyModulePan      *modPan;
      CyModuleReadBus  *modReadBus;
      CyModuleWriteBus *modWriteBus;
      String *sWord;
      String *sConstOrVar;
      CyLUT *lut;
      int patBits;
      int stepBit;
      int stepIdx;
      local String *tmpContextName;

      switch(type)
      {
         default:
            if(type <= "x")
            {
               mod <= parseExtMod(type);
               if(null != mod)
                  break;
            }
            if(null != type)
               mod <= parseConstOrVar(type, null/*mod*/, null/*input*/);
            else
               throw CyParseError getSrcLoc()+": expected module type";
            if(null != mod)
               break;
            else
               throw CyUnknownModuleError getSrcLoc()+": unknown module type \""+type+"\"";

         case "abs":  mod <= new CyModuleAbs;  break;
         case "adsr": mod <= new CyModuleADSR; break;
         case "apf":  mod <= new CyModuleApf;  break;
         case "bit":  mod <= new CyModuleBit;  break;
         case "boo":  mod <= new CyModuleBoo;  break;
         case "bpf":  mod <= new CyModuleBpf;  break;  // reserved, use svf instead
         case "bts":  mod <= new CyModuleBts;  break;  // loc_bipolar_to_scale()
         case "buf":  mod <= new CyModuleBuf;  break;  // reserved
         case "bus":  mod <= new CyModuleReadBus;  break; // **deprecated** (=> use 'rbl'/'rbr' instead)
         case "clk":  mod <= new CyModuleClk;  break;
         case "clp":  mod <= new CyModuleClp;  break;
         case "cmp":  mod <= new CyModuleCmp;  modCmp <= mod; modCmp.cmp_op = CyModuleCmp.CMP_OP_NONE; break;  // must be followed by <,<=,==,!=,>=,>
         case "clt":  mod <= new CyModuleCmp;  modCmp <= mod; modCmp.cmp_op = CyModuleCmp.CMP_OP_LT; break;
         case "cle":  mod <= new CyModuleCmp;  modCmp <= mod; modCmp.cmp_op = CyModuleCmp.CMP_OP_LE; break;
         case "ceq":  mod <= new CyModuleCmp;  modCmp <= mod; modCmp.cmp_op = CyModuleCmp.CMP_OP_EQ; break;
         case "cne":  mod <= new CyModuleCmp;  modCmp <= mod; modCmp.cmp_op = CyModuleCmp.CMP_OP_NE; break;
         case "cge":  mod <= new CyModuleCmp;  modCmp <= mod; modCmp.cmp_op = CyModuleCmp.CMP_OP_GE; break;
         case "cgt":  mod <= new CyModuleCmp;  modCmp <= mod; modCmp.cmp_op = CyModuleCmp.CMP_OP_GT; break;
         case "con":  mod <= new CyModuleCon;  break;
         case "dec":  mod <= new CyModuleInc;  modInc <= mod; modInc.mode = CyModuleInc.MODE_DEC; break;
         case "div":  mod <= new CyModuleDiv;  break;
         case "dly":  mod <= new CyModuleDly;  break;  // reserved
         case "drv":  mod <= new CyModuleDrv;  break;  // reserved
         case "env":  mod <= new CyModuleEnv;  break;
         case "eq3":  mod <= new CyModuleEQ3;  break;
         case "fed":  mod <= new CyModuleEdge;  modEdge <= mod; modEdge.mode = CyModuleEdge.MODE_FALL; break;
         case "fix":  mod <= new CyModuleFix;  break;
         case "fld":  mod <= new CyModuleFld;  break;
         case "box":
         case "flt":  mod <= new CyModuleBox;  break;
         case "fam":  mod <= new CyModuleFam;  break;
         case "fma":  mod <= new CyModuleFma;  break;
         case "frc":  mod <= new CyModuleFrc;  break;
         case "fsr":  mod <= new CyModuleFsr;  break;
         case "fwr":  mod <= new CyModuleFwr;  break;
         case "hbx":  mod <= new CyModuleHbx;  break;  // v - box(v)  (simple highpass)
         case "hld":  mod <= new CyModuleHld;  break;
         case "hpf":  mod <= new CyModuleHpf;  break;
         case "hwr":  mod <= new CyModuleHwr;  break;
         case "if":   mod <= new CyModuleIf;   break;
         case "inc":  mod <= new CyModuleInc;  modInc <= mod; modInc.mode = CyModuleInc.MODE_INC; break;
         case "int":  mod <= new CyModuleInt;  break;  // emit subtree in 16bit integer mode
         case "ipl":  mod <= new CyModuleIpl;  break;
         case "itg":  mod <= new CyModuleItg;  break;  // get integral part of float (discard fractional part)
         case "kbd":  mod <= new CyModuleKbd;  break;
         case "lle":  mod <= new CyModuleLle;  break;
         case "log":  mod <= new CyModuleLog;  break;
         case "lop":  mod <= new CyModuleLop;  break;  // dynamic loop
         case "lpf":  mod <= new CyModuleLpf;  break;
         case "lut":  mod <= new CyModuleLUT;  break;
         case "mac":  mod <= new CyModuleMac;  break;  // macro interpolation
         case "map":  mod <= new CyModuleMap;  break;  // remap value through non-contiguous table
         case "mkv":  mod <= new CyModuleMkv;  break;  // Markov chain
         case "mul":  mod <= new CyModuleInc;  modInc <= mod; modInc.mode = CyModuleInc.MODE_MUL; break;
         case "neg":  mod <= new CyModuleNeg;  break;
         case "nos":  mod <= new CyModuleNos;  break;
         case "not":
            if(wIdx < words.numElements)  // var name follows ?
            {
               mod <= new CyModuleInc;
               modInc <= mod; modInc.mode = CyModuleInc.MODE_NOT;
            }
            else
            {
               mod <= new CyModuleNot;
            }
            break;
         case "note": mod <= new CyModuleNote; break;  // plugins only
         case "nth":  mod <= new CyModuleNth;  break;
         case "out":  mod <= new CyModuleWriteBus; break;  // voice bus output (plugins only)  **deprecated** (=> use 'wbl'/'wbr' instead)
         case "pal":  mod <= new CyModulePan;  break;
         case "par":  mod <= new CyModulePan;  modPan <= mod; modPan.b_right = true; break;
         case "pha":  mod <= new CyModulePha;  break;  // emits 0..2047 in int mode, 0..0.999999 in float mode
         case "p2s":  mod <= new CyModuleP2s;  break;
         case "pow":  mod <= new CyModulePow;  break;
         case "pre":  mod <= new CyModulePre;  break;
         case "pul":  mod <= new CyModulePul;  break;
         case "qua":  mod <= new CyModuleQua;  break;
         case "rbl":  mod <= new CyModuleReadBus;  break;
         case "rbr":  mod <= new CyModuleReadBus;  modReadBus <= mod; modReadBus.b_right = true; break;
         case "red":  mod <= new CyModuleEdge;  modEdge <= mod; modEdge.mode = CyModuleEdge.MODE_RISE; break;
         case "rcp":  mod <= new CyModuleRcp;  break;  // reciprocal (float)
         case "rdl":  mod <= new CyModuleRdl;  break;  // read left input
         case "rdr":  mod <= new CyModuleRdr;  break;  // read right input
         case "rep":  mod <= new CyModuleRep;  break;  // unrolled loop
         case "rev":  mod <= new CyModuleRev;  break;
         case "rmp":  mod <= new CyModuleRmp;  break;
         case "rms":  mod <= new CyModuleRms;  break;
         case "saw":  mod <= new CyModuleSaw;  break;
         case "set":  mod <= new CyModuleInc;  modInc <= mod; modInc.mode = CyModuleInc.MODE_SET; break;
         case "sin":  mod <= new CyModuleSin;  break;
         case "slf":
                      if(b_plugin && b_have_plugin_id)
                         throw CyPluginExportError getSrcLoc()+": \"slf\" not allowed in plugins";
                      mod <= new CyModuleSlf;  break;
         case "smp":  break;
         case "spd":  mod <= new CyModuleSpd;  break;  // note speed (plugins) (1.0 in sample calc mode)
         case "slw":  mod <= new CyModuleSlw;  break;  // slew
         case "spr":  mod <= new CyModuleSpr;  break;  // spring
         case "ssl":
                      // // // if(b_plugin && b_have_plugin_id)
                      // // //    throw CyPluginExportError getSrcLoc()+": \"ssl\" not allowed in plugins";
                      mod <= new CyModuleSsl;  break;
         case "sta":  mod <= new CyModuleSta;  break;
         case "sto":  mod <= new CyModuleSto;  break;
         // case "sub":  mod <= new CyModuleSub;  break;  // discard sub-tree
         case "svf":  mod <= new CyModuleSvf;  break;
         case "sat":
         case "tanh": mod <= new CyModuleTanh; break;
         case "tan":  mod <= new CyModuleTan; break;
         case "tmp":
         case "~":
            // template instantiation (inside lane)
            if(words.numElements >= (_typeWordIdx + 2))
            {
               local String templateId <= Utils.ConvertToVarName(words[_typeWordIdx + 1]);
               CyTemplate tmpl <= findTemplateById(templateId);
               if(null != tmpl)
               {
                  // (note) "dly test 6"  (~dly template instantiation after nested seq)
                  popInputsAfterIndent(_indent);
                  while((null != cur_mod) && (_indent < cur_mod.indent))
                  {
                     // trace "xxx    find prev level cur_mod="+cur_mod.getString()+" cur_mod.indent="+cur_mod.indent+" cur_mod.seq_parent="+#(cur_mod.seq_parent);
                     cur_mod <= cur_mod.seq_parent;
                     // trace "xxx      cur_mod.seq_parent.seq_parent="+((null != cur_mod)?#(cur_mod.seq_parent):"n/a");
                  }

                  local StringArray tmplVars <= new StringArray;
                  local StringArray tmplValues <= new StringArray;
                  local String tmplInstanceId <= String(next_template_var_idx + 1);  // default instance-id

                  local CyTemplateInstance tmplInstance <= new CyTemplateInstance;
                  template_instances.add(#(deref tmplInstance));
                  tmplInstance.init(tmpl.id, tmplInstanceId);

                  // Parse variables ("myvar=somestring")
                  wIdx = _typeWordIdx + 2;
                  int varIdx = 0;
                  while(wIdx < words.numElements)
                  {
                     if("=" == words.get(wIdx+1))
                     {
                        tmplVars  .add(words.get(wIdx));
                        tmplValues.add(words.get(wIdx+2));

                        // Override template instance id ?
                        // trace "xxx template sVarName="+tmplVars.last+" value=\""+tmplValues.last+"\"";
                        if("id" == tmplVars.last)
                        {
                           tmplInstanceId <= Object(tmplValues.last);  // "myinstance"
                           tmplInstance.init(tmpl.id, tmplValues.last);
                        }

                        varIdx = tmpl.findVarNameIdx(tmplVars.last) + 1;

                        wIdx += 3;
                     }
                     else
                     {
                        String sVarName <= tmpl.getVarNameByIdx(varIdx++);
                        if(null != sVarName)
                        {
                           tmplVars  .add(sVarName);
                           tmplValues.add(words[wIdx++]);
                        }
                        else
                           throw CyParseError getSrcLoc()+": template \""+tmpl.id+"\" has no var at index "+(varIdx-1);
                     }
                  }

                  local String tmplInstanceVarPrefix <= "__ti_"+tmpl.id+"_"+tmplInstanceId;  // without trailing '_'
                  // trace "xxx tmplInstanceId=\""+tmplInstanceId+"\"";
                  // trace "xxx tmplInstanceVarPrefix=\""+tmplInstanceVarPrefix+"\"";

                  //  vst _ti_<nr>
                  //    value:
                  //      <template code>
                  local CyVar tmplVar;
                  tmplVar.init();
                  tmplVar.id = tmplInstanceVarPrefix;  // (note) inc'd by getInstanceLines()
                  vars.add(#(deref tmplVar));

                  local StringArray tmplLines <= tmpl.getInstanceLines(this,
                                                                       _indent + 4,
                                                                       deref tmplVars,
                                                                       deref tmplValues,
                                                                       tmplInstanceId
                                                                       );
                  local String sIndent;
                  sIndent.appendRepeat(" ", _indent);
                  tmplLines.insert(0, sIndent+"set "+tmplVar.id);  // (note) initial 'value' input is previous output value
                  tmplLines.insert(1, sIndent+"  value:");
                  tmplLines.add(sIndent+((null != _opOrNull)?(_opOrNull+" "):"")+"$"+tmplVar.id);  // Read template result
                  // trace "xxx tmplLines="+tmplLines;

                  // // //
                  // // mod <= new CyModuleVar;
                  // // mod.init();
                  // // modVar <= mod;
                  // // modVar.var_ref <= tmplVar;

                  if(b_debug3)
                     trace "xxx templ inst, call pushParseContext cur_lane="+#(cur_lane)+" cur_lane.id="+((null != cur_lane)?cur_lane.id:"n/a")+" cur_input="+#(cur_input)+" cur_input.id="+((null != cur_input)?cur_input.id:"n/a");

                  // // tmpContextName <= cur_parse_context.getLineNr()+":tmp "+tmpl.id;  // pre 13Dec2024
                  if(tmpl.parent_buffer == "main")
                  {
                     // invocation + template declaration in main source
                     tmpContextName <= cur_parse_context.getLineNr()+":buf main";
                  }
                  else
                  {
                     // template declaration in other buffer
                     tmpContextName <= cur_parse_context.getLineNr()+":buf "+tmpl.parent_buffer;
                  }

                  pushParseContext(deref tmpContextName,
                                   true/*bIncLineIdx*/,
                                   deref tmplLines,
                                   -1/*lineIdx*/, // nextLine() is called before beginLine()
                                   tmpl,
                                   deref tmplInstanceId
                                   );
                  cur_parse_context.line_offset =
                     -2  // skip "set" / "value:" prologue lines in exception messages
                     + tmpl.parent_line_idx + 1  // add line start offset of template definition and skip 'def' line
                     ;
                  cur_parse_context.var_prefix = tmplVar.id+"_";
               }
               else
                  throw CyTmpNameError getSrcLoc()+": undeclared template \""+templateId+"\"";
            }
            else
               throw CyTmpNameError getSrcLoc()+": expected template name";
            break;
         case "trc":  mod <= new CyModuleTrc;  break;
         case "tri":  mod <= new CyModuleTri;  break;
         case "tsq":
            mod <= new CyModuleSeq;
            modSeq <= mod;
            modSeq.b_tsq = true;
            break;
         case "vel":  mod <= new CyModuleVel;  break;
         case "vpl":  mod <= new CyModuleVpl;  break;
         case "vsq":
            mod <= new CyModuleSeq;
            modSeq <= mod;
            modSeq.b_tsq = false;
            break;
         case "vst":
            if(words.numElements > 1)
            {
               mod <= new CyModuleInc;
               modInc <= mod;
               modInc.mode = CyModuleInc.MODE_SET;
               modInc.init();
               modInc.var_ref <= addVar();
            }
            else
               throw CyParseError getSrcLoc()+": missing var name";
            break;
         case "wbl":  mod <= new CyModuleWriteBus; break;  // voice bus output (plugins only)
         case "wbr":  mod <= new CyModuleWriteBus; modWriteBus <= mod; modWriteBus.b_right = true; break;
         case "wrl":  mod <= new CyModuleWrl;  break;  // write left input
         case "wrp":  mod <= new CyModuleWrp;  break;
         case "wrr":  mod <= new CyModuleWrr;  break;  // write right input
         case "xfd":  mod <= new CyModuleXfd;  break;
         case "zlp":  mod <= new CyModuleZlp;  break;
         case "zon":  mod <= new CyModuleZon;  break;
         case "zsq":  mod <= new CyModuleZsq;  break;
         case "init":
         case "prepare":
         case "calc":
            mod <= new CyModuleTemplateCall; break;

         // // // case "var":
         // // //    mod <= new CyModuleVar;
         // // //    break;
      }
      if(null != mod)
      {
         mod.init();

         if(mod instanceof CyModuleTemplateCall)
         {
            if(wIdx < words.numElements)
            {
               String templInstanceId <= words[wIdx++];
               CyModuleTemplateCall modTemplCall <= mod;
               // // // modTemplCall.parent_script <= this;
               modTemplCall.template_instance <= findTemplateInstanceById(templInstanceId);
               // trace "xxx templInstanceId=\""+templInstanceId+"\" => modTemplCall.template_instance="+#(modTemplCall.template_instance);
               if(null != modTemplCall.template_instance)
               {
                  Lane templLane <= findLaneById("_"+words[wIdx-2]+"_"+templInstanceId);  // e.g. "_init_mytemplinst"
                  if(null != templLane)
                  {
                     modTemplCall.lane <= templLane;
                  }
                  else
                     throw ParseError getSrcLoc()+": undeclared template instance \""+templInstanceId+"\" lane \""+words[wIdx-2]+"\"";
               }
               else
                  throw ParseError getSrcLoc()+": undeclared template instance \""+templInstanceId+"\"";
            }
            else
               throw ParseError getSrcLoc()+": template call \""+words[wIdx-1]+"\": missing template instance id";
         }
         else if(mod instanceof CyModuleCmp)
         {
            if(CyModuleCmp.CMP_OP_NONE == modCmp.cmp_op)
            {
               if(wIdx < words.numElements)
               {
                  switch(words[wIdx++])
                  {
                     default:
                        throw CyParseError getSrcLoc()+": cmp: invalid relational operator \""+words[wIdx-1]+"\"";

                     case "<":
                        modCmp.cmp_op = CyModuleCmp.CMP_OP_LT;
                        break;

                     case "<=":
                        modCmp.cmp_op = CyModuleCmp.CMP_OP_LE;
                        break;

                     case "==":
                        modCmp.cmp_op = CyModuleCmp.CMP_OP_EQ;
                        break;

                     case "!=":
                        modCmp.cmp_op = CyModuleCmp.CMP_OP_NE;
                        break;

                     case ">=":
                        modCmp.cmp_op = CyModuleCmp.CMP_OP_GE;
                        break;

                     case ">":
                        modCmp.cmp_op = CyModuleCmp.CMP_OP_GT;
                        break;
                  }
               }
               else
                  throw CyParseError getSrcLoc()+": cmp: expected relational operator";
            }
            // else: op already set (clt,ceq,..)
         }
         else if(mod instanceof CyModuleIf)
         {
            CyModuleIf modIf <= mod;
            // if <arg> [<,<=,==,!=,>=,>] <constant>
            if(wIdx < words.numElements)
            {
               // trace "xxx sIfArg=\""+words[wIdx]+"\"";
               CyArg ifArg <= findArgById(words[wIdx++]);
               if(null != ifArg)
               {
                  modIf.lhs_arg <= ifArg;

                  if(wIdx < words.numElements)
                  {
                     // trace "xxx sIfOp=\""+words[wIdx]+"\"";
                     switch(words[wIdx++])
                     {
                        default:
                           throw CyParseError getSrcLoc()+": if: invalid relational operator \""+words[wIdx-1]+"\"";

                        case "<":
                           modIf.if_op = CyModuleIf.OP_LT;
                           break;

                        // // case "<=":
                        // //    modIf.if_op = CyModuleIf.OP_LE;
                        // //    break;

                        case "=":
                           modIf.if_op = CyModuleIf.OP_EQ;
                           break;

                        case "!":
                           modIf.if_op = CyModuleIf.OP_NE;
                           break;

                        // // case ">=":
                        // //    modIf.if_op = CyModuleIf.OP_GE;
                        // //    break;

                        case ">":
                           modIf.if_op = CyModuleIf.OP_GT;
                           break;
                     }

                     if(wIdx < words.numElements)
                     {
                        if("=" == words[wIdx])
                        {
                           wIdx++;
                           switch(modIf.if_op)
                           {
                              case CyModuleIf.OP_LT:
                                 modIf.if_op = CyModuleIf.OP_LE;
                                 break;

                              case CyModuleIf.OP_EQ:
                                 modIf.if_op = CyModuleIf.OP_EQ;
                                 break;

                              case CyModuleIf.OP_NE:
                                 modIf.if_op = CyModuleIf.OP_NE;
                                 break;

                              case CyModuleIf.OP_GT:
                                 modIf.if_op = CyModuleIf.OP_GE;
                                 break;
                           }
                        }
                     }

                     if(wIdx < words.numElements)
                     {
                        // trace "xxx sIfRHS=\""+words[wIdx]+"\"";
                        sConstOrVar <= words[wIdx++];
                        modArg <= parseConstOrVar(sConstOrVar, null/*mod*/, null/*input*/);
                        if(null != modArg)
                        {
                           // trace "xxx ifRHSArg="+#(modArg);
                           modIf.rhs_arg <= deref modArg;
                        }
                        else
                           throw CyParseError getSrcLoc()+": if: error parsing RHS arg/const \""+sConstOrVar+"\"";
                     }
                     else
                        throw CyParseError getSrcLoc()+": if: expected RHS arg/const";
                  }
                  else
                     throw CyParseError getSrcLoc()+": if: expected relational operator (<,<=,==,!=,>=,>)";
               }
               else
                  throw CyArgNotFoundError getSrcLoc()+": if: arg \""+words[wIdx-1]+"\" not found";
            }
            else
               throw CyParseError getSrcLoc()+": if: expected arg name";
         }
         else if(mod instanceof CyModuleSta)
         {
            // sta <lut_id> <index_mul> <index_add> <src_var> [<var_mul> <var_add>]
            // OR
            // sta <lut_id> <src_var> [<var_mul> <var_add>]
            if(wIdx < words.numElements)
            {
               lut <= findLUTById(Utils.ConvertToVarName(words[wIdx]));
               if(null != lut)
               {
                  wIdx++;
                  if(wIdx < words.numElements)
                  {
                     float fStaIndexMul = 1.0f;
                     float fStaIndexAdd = 0.0f;
                     float fStaVarMul = 1.0f;
                     float fStaVarAdd = 0.0f;

                     sWord <= words[wIdx];
                     if(sWord.checkFloatConversion())
                     {
                        // <index_mul> <index_add>
                        wIdx++;
                        fStaIndexMul = sWord;

                        if(wIdx < words.numElements)
                           fStaIndexAdd = words[wIdx++];
                        else
                           throw CyParseError getSrcLoc()+": sta: expected <index_add> constant at word index "+wIdx;
                     }

                     if(wIdx < words.numElements)
                     {
                        CyVar vSta <= findLaneOrGlobalVarById(words[wIdx]);
                        if(null != vSta)
                        {
                           if(++wIdx < words.numElements)
                           {
                              // optional: <var_mul>
                              fStaVarMul = words[wIdx++];
                              if(wIdx < words.numElements)
                              {
                                 // optional: <var_add>
                                 fStaVarAdd = words[wIdx];
                              }
                           }

                           CyModuleSta modSta <= mod;
                           modSta.lut_ref  <= lut;
                           modSta.index_mul = fStaIndexMul;
                           modSta.index_add = fStaIndexAdd;
                           modSta.var_ref  <= vSta;
                           modSta.var_mul   = fStaVarMul;
                           modSta.var_add   = fStaVarAdd;
                           if(lut.b_inv)
                              cur_lane.inv_lut_ref <= lut;
                           return deref mod;
                        }
                        else
                           throw CyVarNotFoundError getSrcLoc()+": sta: source var \""+words.get(wIdx)+"\" not found";
                     }
                     else
                        throw CyParseError getSrcLoc()+": sta: expected <var> at word index "+wIdx;
                  }
                  else
                     throw CyParseError getSrcLoc()+": sta: expected <index_mul> constant or <var> at word index "+wIdx;
               }
               else
                  throw CyLUTNotFoundError getSrcLoc()+": sta: LUT \""+words.get(wIdx)+"\" not found";
            }
            else
               throw CyParseError getSrcLoc()+": sta: expected LUT id at word index "+wIdx;
         }
         else if(mod instanceof CyModuleSto)
         {
            if(wIdx < words.numElements)
            {
               CyVar vSto <= findStoreLaneOrGlobalVarById(words[wIdx]);
               if(null != vSto)
               {
                  modSto <= mod;
                  modSto.var_ref <= vSto;
                  return deref mod;
               }
               else
                  throw CyVarNotFoundError getSrcLoc()+": sto: var \""+words[wIdx]+"\" not found";
            }
            else
               throw CyParseError getSrcLoc()+": sto: expected var name";
         }
         else if(mod instanceof CyModuleInc)
         {
            if(wIdx < words.numElements)
            {
               CyVar vInc <= findStoreLaneOrGlobalVarById(words[wIdx++]);
               if(null != vInc)
               {
                  modInc <= mod;
                  modInc.var_ref <= vInc;
               }
               else
                  throw CyVarNotFoundError getSrcLoc()+": "+modInc.getModeString()+": var \""+words[wIdx-1]+"\" not found";
            }
            else
               throw CyParseError getSrcLoc()+": "+modInc.getModeString()+": expected var name";
         }
         else if(mod instanceof CyModuleMac)
         {
            if(wIdx < words.numElements)
            {
               CyMacro macro <= findMacroById(words[wIdx++]);
               if(null != macro)
               {
                  CyModuleMac modMac <= mod;
                  modMac.macro_ref <= macro;
               }
               else
                  throw CyMacroNotFoundError getSrcLoc()+": mac: macro \""+words[wIdx-1]+"\" not found";
            }
            else
               throw CyParseError getSrcLoc()+": mac: expected macro name";
         }
         else if(mod instanceof CyModuleMap)
         {
            if(wIdx < words.numElements)
            {
               local StringArray aMapWords <= words[wIdx++].splitChar('.');
               if(aMapWords.numElements > 1)
               {
                  CyMap map <= findMapById(aMapWords.get(0));
                  if(null != map)
                  {
                     CyModuleMap modMap <= mod;
                     modMap.parent_script <= this;
                     modMap.map_ref       <= map;

                     StringArray mapFieldNames <= map.field_names;
                     int mapFieldIdx = mapFieldNames.indexOfObject(aMapWords.get(1), 0);
                     if(mapFieldIdx >= 0)
                     {
                        modMap.field_idx = mapFieldIdx;
                     }
                     else
                        throw CyMapFieldNotFoundError getSrcLoc()+": map field \""+aMapWords.get(1)+"\" not found";
                  }
                  else
                     throw CyMapNotFoundError getSrcLoc()+": map \""+aMapWords.get(0)+"\" not found";
               }
               else
                  throw CyParseError getSrcLoc()+": expected map.field name";
            }
            else
               throw CyParseError getSrcLoc()+": expected map name";
         }
         else if(mod instanceof CyModuleLUT)
         {
            if(wIdx < words.numElements)
            {
               CyModuleLUT modLut <= mod;
               a_mod_lut.add(modLut);
               String sLutId <= words[wIdx];
               // // trace "xxx CyScript::newMod: new CyModuleLUT  sLutId=\""+sLutId+"\" => modLut="+#(modLut);
               lut <= findLUTById(Utils.ConvertToVarName(sLutId));
               // trace "xxx findLUTById("+Utils.ConvertToVarName(sLutId)+") => lut="+#(lut);
               if(null != lut)
               {
                  modLut.lut <= lut;
                  modLut.curve_idx = -1;

                  if(!lut.b_have_init && !lut.b_inv)
                     throw CyUninitializedLUTError getSrcLoc()+": lut: init section \"<lut_"+lut.id+":\" missing for procedural LUT";
               }
               else
               {
                  modLut.array_decl <= findArrayDeclByPluginParamId(sLutId);
                  // // trace "yyy sLutId=\""+sLutId+"\" => modLut.array_decl="+#(modLut.array_decl);

                  if(null == modLut.array_decl)
                  {
                     int curveIdx = findCurveIndexByAlias(sLutId);

                     // [21Dec2024] find array param decl by curve (see "debug param array simple" test plugin)
                     modLut.array_decl <= findArrayDeclByCopyCurveIdx(curveIdx);

                     // trace "xxx CyScript::newMod: findCurveIndexByAlias(sLutId=\""+sLutId+"\") => curveIdx="+curveIdx;
                     if(curveIdx >= 0)
                     {
                        modLut.curve_idx = curveIdx;
                     }
                     else
                     {
                        throw CyCurveNotFoundError getSrcLoc()+": lut: undeclared curve alias, procedural LUT id or plugin array param id \""+sLutId+"\"";
                     }
                  }
               }
               wIdx++;
            }
            else
               throw CyParseError getSrcLoc()+": lut: expected curve id, procedural LUT id, or array param id";
            if(b_debug2)
               trace "xxx end lut wIdx="+wIdx;
         }
         else if(mod instanceof CyModuleSsl)
         {
            CyModuleSsl modSsl <= mod;
            // parse slice indices
            if(wIdx < words.numElements)
            {
               // up to 8*4bit. loop when seq is shorter than 8.
               String idxSeq <= words[wIdx++];
               int idxSeqLen = idxSeq.numChars;
               int idxSeqBits = 0;
               int idxSeqShift = 0;
               int idxSeqIdx = 0;
               loop(8)
               {
                  idxSeqBits |= int(idxSeq.getc(idxSeqIdx++ % idxSeqLen) - '0') << idxSeqShift;
                  idxSeqShift += 4;
               }
               modSsl.seq_indices = idxSeqBits;
            }
            else
               throw CyParseError getSrcLoc()+": ssl: expected index seq (e.g. 01234567)";
         }
         else if(mod instanceof CyModuleSeq)
         {
            modSeq <= mod;

            if(wIdx < words.numElements)
            {
               // Parse step pattern, e.g. "x...x..."
               String seqPat <= words[wIdx++];
               // // boolean bTSQLut = false;
               patBits = 0;
               stepBit = 1;
               stepIdx = 0;
               loop(seqPat.numChars)
               {
                  switch(seqPat.getc(stepIdx++))
                  {
                     // // default:
                     // //    // not a step pattern, interpret as LUT reference
                     // //    bTSQLut = true;
                     // //    break;

                     case ".":
                     case "-":
                        break;

                     case 'x':
                     case 'X':
                        patBits |= stepBit;
                        break;
                  }
                  // // if(bTSQLut)
                  // //    break;
                  stepBit = stepBit << 1;
               }
               // // if(!bTSQLut)
               // // {
                  modSeq.pat_bits = patBits;
                  modSeq.pat_len  = seqPat.numChars;
               // // }
               // // else
               // // {
               // //    // 'tsqPat' string is reference to LUT
               // //    lut <= findLUTById(Utils.ConvertToVarName(tsqPat));
               // //    if(null != lut)
               // //    {
               // //    }
               // // }
            }
            else
               throw CyParseError getSrcLoc()+": seq: expected step pattern";
         }
         else if(mod instanceof CyModuleZlp)
         {
            // // if(b_plugin && b_have_plugin_id)
            // //    throw CyPluginExportError getSrcLoc()+": \"zlp\" not allowed in plugins";
            CyModuleZlp modZlp <= mod;
            modZlp.zone_idx = parseZoneIdx(wIdx);  // updates wIdx
         }
         else if(mod instanceof CyModuleZon)
         {
            // // if(b_plugin && b_have_plugin_id)
            // //    throw CyPluginExportError getSrcLoc()+": \"zon\" not allowed in plugins";
            CyModuleZon modZon <= mod;
            modZon.zone_idx = parseZoneIdx(wIdx);  // updates wIdx
         }
         else if(mod instanceof CyModuleZsq)
         {
            if(b_plugin && b_have_plugin_id)
               throw CyPluginExportError getSrcLoc()+": \"zsq\" not allowed in plugins";

            CyModuleZsq modZsq <= mod;
            modZsq.zone_idx = parseZoneIdx(wIdx);  // updates wIdx

            if(wIdx < words.numElements)
            {
               // Parse step pattern, e.g. "x...x..."
               String zsqPat <= words[wIdx++];
               patBits = 0;
               stepBit = 1;
               stepIdx = 0;
               loop(zsqPat.numChars)
               {
                  switch(zsqPat.getc(stepIdx++))
                  {
                     case 'x':
                     case 'X':
                        patBits |= stepBit;
                        break;
                  }
                  stepBit = stepBit << 1;
               }
               modZsq.pat_bits = patBits;
            }
            else
               throw CyParseError getSrcLoc()+": zsq: expected step pattern";
         }
         else if(mod instanceof CyModuleVpl)
         {
            if(b_plugin && b_have_plugin_id)
               throw CyPluginExportError getSrcLoc()+": \"vpl\" not allowed in plugins";

            modVpl <= mod;

            // Parse plugin id
            if(wIdx < numWords)
            {
               modVpl.plugin_id = words.get(wIdx++);

               // Parse params (key=value pairs)
               while(wIdx < numWords)
               {
                  String vplParamKey <= words.get(wIdx++);
                  if(wIdx < numWords)
                  {
                     String vplAssign <= words.get(wIdx++);
                     if(vplAssign == "=")
                     {
                        if(wIdx < numWords)
                        {
                           String vplParamVal <= words.get(wIdx++);
                           if(vplParamVal <= "$")
                           {
                              String vplArgName <= vplParamVal.substring(1, 999);
                              CyArg vplArg <= findArgById(vplArgName);
                              if(null != vplArg)
                              {
                                 modVpl.setParamByArg(vplParamKey, vplArg);
                              }
                              else
                              {
                                 throw CyArgNotFoundError getSrcLoc()+": vpl: arg \""+vplArgName+"\" not found";
                              }
                           }
                           else
                              modVpl.setParamByName(vplParamKey, vplParamVal);
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": vpl: expected \'=\' after plugin parameter name";
                  }
               }

               if(!modVpl.loadPluginAndSetParamsAndCreateInputs(sample_rate * oversample_factor, true/*bCreateInputs*/))
                  throw CyVoicePluginError getSrcLoc()+": vpl: failed to instantiate plugin \""+modVpl.plugin_id+"\"";
            }
            else
               throw CyParseError getSrcLoc()+": vpl: expected plugin id";
         }

         // Parse remaining words (if any)
         int inpIdx = 0;
         CyInput *inp;
         if(b_debug2)
            trace "xxx parse remaining words "+#(words)+" wIdx="+wIdx;
         while(wIdx < numWords)
         {
            if("=" != words.get(wIdx+1))
            {
               // parse default input const value or var
               // e.g. "sin 1.5" or "sin $osc2ratio"
               sConstOrVar <= words.get(wIdx);
               inp <= mod.getInputByIndex(inpIdx++);
               // // if(!mod.setDefaultInputMod(deref modArg))
               if(null != inp)
               {
                  modArg <= parseConstOrVar(sConstOrVar, mod, inp);
                  if(null != modArg)
                  {
                     inp.addModule(deref modArg);
                  }
                  else
                     throw CyParseError getSrcLoc()+": error parsing default input constant or var \""+sConstOrVar+"\"";
                  wIdx++;
               }
               else
                  throw CyError getSrcLoc()+": "+mod.getString()+" has no input #"+(inpIdx+1)+" (cannot assign \""+sConstOrVar+"\")";
            }
            else
            {
               // Parse input=value|var pair
               String inpId <= words.get(wIdx++);

               inp <= mod.findInputById(inpId);
               if(b_debug2)
                  trace "xxx inpId="+inpId+" inp="+#(inp);

               // trace "xxx mod="+#(mod)+" inpId="+inpId+" inp="+#(inp);

               if(null == inp)
                  throw CyInputNotFoundError getSrcLoc()+": \""+mod.getString()+"\" has no input \""+inpId+"\"";

               if("=" != words.get(wIdx++))
                  throw CyParseError getSrcLoc()+": expected \'=\' in input assignment";

               if(wIdx < numWords)
               {
                  sConstOrVar <= words.get(wIdx++);

                  boolean bTryArg = true;
                  if(mod instanceof CyModuleExt)
                  {
                     modExt <= mod;
                     CyExtModConfig cfg <= modExt.ext_mod.findConfigItemById(inpId);
                     if(null != cfg)
                     {
                        // trace "xxx ext sConstOrVar=\""+sConstOrVar+"\" sConstOrVar.checkConversions()="+sConstOrVar.checkConversions();
                        if(sConstOrVar <= "$")
                        {
                           modArg <= parseConstOrVar(sConstOrVar, mod, inp);
                           inp.addModule(deref modArg);
                        }
                        else
                        {
                           // arbitrary string (e.g. enum)
                           inp.ext_def_value <= Object(cfg.mapConstValue(sConstOrVar));
                        }
                        bTryArg = false;
                        inpIdx = inp.idx;
                     }
                  }

                  if(bTryArg)
                  {
                     modArg <= parseConstOrVar(sConstOrVar, mod, inp);
                     if(null != modArg)
                     {
                        if(b_debug2)
                           trace "xxx inp="+inp.id+" sConstOrVar="+sConstOrVar;
                        inp.addModule(deref modArg);
                        inpIdx = inp.idx;
                     }
                     else
                        throw CyParseError getSrcLoc()+": error parsing input \""+inpId+"\" const or var \""+sConstOrVar+"\"";
                  }
               }
               else
                  throw CyParseError getSrcLoc()+": expected const or var after \'=\' in input assignment";
            }
         } // if wIdx < numWords

         if(mod instanceof CyModuleVpl)
         {
            modVpl <= mod;
            modVpl.vpl_idx = vpl_modules.numElements;
            vpl_modules.add(modVpl);
         }

         if(!mod.validate())
            throw CyParseError getSrcLoc()+": "+mod.getString()+": validation failed";

         return deref mod;
      } // if null != mod
      return null;
   }

   // <method_add.png>
   protected method addLane(int _indent, boolean _bAllowUnderscore, int _wordIdxId) {

      // trace "xxx addLane: indent="+_indent+" words="+words;

      // "<mylane:" or "init:" / "prepare:" / "calc:"
      //  (note) wordIdxId is usually 1 (skip "<"), except for "init:" / "prepare:" / "calc:" template lanes (wordIdxId=0)
      //  (note) when wordIdxId is 0, the lane id will be prefixed with an underscore to prevent it from being emitted as an audio lane
      if(words.numElements >= (_wordIdxId+2))
      {
         if(":" == words[_wordIdxId+1])
         {
            if(b_debug2) trace "xxx srcLoc="+getSrcLoc()+" addLane id="+words[_wordIdxId]+" cur_template="+#(cur_template);
            // // CyLane *o;
            // // foreach o in lanes
            // // {
            // //    trace "xxx addLane: existing o.id="+o.id;
            // //    if(o.id == words[1])
            // //       throw CyParseError getSrcLoc()+": lane \""+words[1]+" already exists";
            // // }
            local String sLaneId =
               (0 == _wordIdxId)
               ? ("_"+words[0]+((null != cur_parse_context.template_instance_id)?("_"+cur_parse_context.template_instance_id):""))
               : words[_wordIdxId]
               ;
            if(!_bAllowUnderscore && sLaneId <= "_")
               throw CyParseError getSrcLoc()+": lane id=\""+sLaneId+"\" must not start with '_'";

            local CyLane lane <= findLaneById(sLaneId);
            if(null == lane)
            {
               // New lane
               lane <= new CyLane;
               lane.id = sLaneId;
               lanes.add(#(deref lane));
            }
            else
            {
               // Continue existing lane (if not a LUT init lane)
               if(sLaneId <= "lut_")
               {
                  throw CyParseError getSrcLoc()+": LUT init lane id=\""+sLaneId+"\" already declared";
               }
            }

            // trace "xxx addLane: pushParseContext lane.id=\""+lane.id+"\" template="+#(cur_parse_context.template_or_null);

            int curContextLineOffset = cur_parse_context.line_offset;
            pushParseContext(cur_parse_context.name,
                             false/*bIncLineIdx*/,
                             cur_parse_context.lines,
                             cur_parse_context.cur_line_idx, //  + 1
                             cur_parse_context.template_or_null,
                             cur_parse_context.template_instance_id
                             );
            cur_parse_context.line_offset = curContextLineOffset;

            // (note) lane vars are prefixed elsewhere (todo: use var_prefix instead??)
            // // cur_parse_context.var_prefix = "lane_"+lane.id+"_";
            // // trace "xxx addLane: new parsecontext.var_prefix=\""+cur_parse_context.var_prefix+"\"";

            if(lane.id <= "lut_")
            {
               String sLutId <= lane.id.replace("lut_", "");
               CyLUT lut <= findLUTById(sLutId);
               if(null != lut)
               {
                  lut.b_have_init = true;
               }
               else
               {
                  trace "[~~~] warning: ignoring LUT init section for undeclared LUT \""+sLutId+"\"";
               }
            }

            cur_lane <= lane;
            cur_lane.indent = _indent + 1;
            cur_input <= null;
            // // input_stack.empty();  // pushParseContext() already created a new stack
            if(lane.isAudioLane())
               num_audio_lanes++;
         }
      }
   }

   // <method_add.png>
   protected method addTemplateLane(int _indent, boolean _bAllowUnderscore, int _wordIdxId) {
      // "<mylane%%:" or "init:" / "prepare" / "calc:" within template code
      if(b_debug3)
         trace "xxx begin templ lane indent="+_indent+" cur_lane="+#(cur_lane);
      addLane(_indent, _bAllowUnderscore, _wordIdxId);
      // // cur_input <= null;  // ?
      // // cur_lane  <= null;  // ?
      // // cur_mod   <= null;
   }

   // <method_parse.png>
   protected method parseWtFreqs() {
      wt_freqs.empty();
      int wIdx = 1;
      updateNoteFreq();
      while(wIdx < words.numElements)
      {
         String sNote <= words[wIdx];
         float fRate = ParseNoteFreq(sNote) / note_freq;
         if(b_debug2)
            trace "xxx wIdx="+wIdx+" fRate="+fRate+" note_freq="+note_freq;
         wt_freqs.add(fRate);
         wIdx++;
      }
   }

   // <method.png>
   protected method parseAndValidateCategory(String _s) : String {
      local String s <= _s.toLower();
      if(["unknown", "ringmod", "waveshaper", "filter", "eq", "compressor", "limiter", "enhance", "dac", "lofi", "gate", "amp", "pan", "pitch", "chorus", "flanger", "delay", "reverb", "transient", "convolver", "mixer", "comparator", "utility", "osc"].containsObject(s))
         return deref s;
      throw CyParseError getSrcLoc()+": invalid plugin category \""+s+"\"";
   }

   // <method_parse.png>
   protected method parseInc() {
      if(words.numElements > 1)
      {
         local String sFile <= words.get(1).trim();

         if(!a_inc_done.containsObject(sFile))
         {
            a_inc_done.add(sFile);

            local String *sBuf;
            local String *aLines;

            if(sFile <= ".")
            {
               // patch-local buffer
               sBuf <= parent_patch.getSourceBufferRef(sFile);
               if(null != sBuf)
               {
                  aLines <= sBuf.splitChar('\n');
                  pushParseContext(cur_parse_context.getLineNr()+":buf "+sFile,
                                   true/*bIncLineIdx*/,
                                   deref aLines,
                                   -1/*lineIdx*/, // nextLine() is called before beginLine()
                                   null/*templateOrNull*/,
                                   null/*templateInstanceIdOrNull*/
                                   );
               }
               else
               {
                  throw CyIncludeNotFoundError getSrcLoc()+": undefined inc buffer \""+sFile+"\"";
               }
            }
            else
            {
               local String sPathName = Utils.ToNativePathName(STConfig.cycle_machine_inc_path+"/"+(sFile.replace(".cy",""))+".cy");
               trace "[trc] CyScript::parseInc: sPathName=\""+sPathName+"\"";
               sBuf <= new String;
               if(sBuf.loadLocal(sPathName, true/*bRemoveCR*/))
               {
                  aLines <= sBuf.splitChar('\n');
                  pushParseContext(cur_parse_context.getLineNr()+":buf "+sFile,
                                   true/*bIncLineIdx*/,
                                   deref aLines,
                                   -1/*lineIdx*/, // nextLine() is called before beginLine()
                                   null/*templateOrNull*/,
                                   null/*templateInstanceIdOrNull*/
                                   );
               }
               else
                  throw CyIncludeNotFoundError getSrcLoc()+": inc file \""+sFile+"\" not found";
            }
         }
         else
         {
            trace "[trc] CyScript::parseInc: skipping previously included file/buffer \""+sFile+"\"..";
         }
      }
   }

   // <method_parse.png>
   protected method parseExtInc() {
      if(words.numElements > 1)
      {
         local String sFile <= words.get(1).trim();
         if!(sFile >= ".h")
            sFile.append(".h");
         local String sPath = Utils.ToNativePathName(STConfig.stfx_xinc.replace("-I", ""));
         local String sPathName <= sPath + "/"+sFile;
         trace "[trc] CyScript::parseExtInc: sPathName=\""+sPathName+"\"";
         local String sBuf;
         if(sBuf.loadLocal(sPathName, true/*bRemoveCR*/))
         {
            if(s_ext_inc.isBlank())
               s_ext_inc.append("\n");
            s_ext_inc.append("#include \""+sFile+"\"\n");
            local StringArray lines <= sBuf.splitChar('\n');
            local String *sLine;
            CyExtMod extMod <= new CyExtMod;
            foreach sLine in lines
            {
               // trace "xxx CyScript::parseExtInc: sLine=\""+sLine+"\"";
               int idxCyS = sLine.indexOf("@cycle_", 0);
               if(idxCyS >= 0)
               {
                  int idxCyE = sLine.indexOfChar(' ', idxCyS+7);
                  if(idxCyE >= 0)
                  {
                     local String sKey <= sLine.substring(idxCyS+7, idxCyE-idxCyS-7);
                     local String sVal <= sLine.substring(idxCyE, 999).trim();
                     // trace "xxx CyScript::parseExtInc: sKey=\""+sKey+"\" sVal=\""+sVal+"\"";
                     local StringArray *sValWords;
                     switch(sKey)
                     {
                        case "mod":
                           if('x' != sVal.getc(0))
                              throw CyParseError "ext mod id must start with 'x' (have \""+sKey+"\")";
                           if(1)
                           {
                              if("xfd" == sVal)
                                 throw CyParseError "ext mod id \"xfd\" clashes with built-in";
                           }
                           extMod.id = sVal;
                           break;

                        case "pre":
                           extMod.addPre(sVal);
                           break;

                        case "static":
                           extMod.addStatic(sVal);
                           break;

                        case "init":
                           extMod.addInit(sVal);
                           break;

                        case "voice":
                           extMod.addVoice(sVal);
                           break;

                        case "new":
                           extMod.addNew(sVal);
                           break;

                        case "delete":
                           extMod.addDelete(sVal);
                           break;

                        case "noteon":
                           extMod.addNoteOn(sVal);
                           break;

                        case "prepare":
                           extMod.addPrepare(sVal);
                           break;

                        case "prepare_first":
                           extMod.addPrepareFirst(sVal);
                           break;

                        case "prepare_next":
                           extMod.addPrepareNext(sVal);
                           break;

                        case "config":
                           ////sValWords <= sVal.splitSpace(true);
                           sValWords <= sVal.tokenize(" \t=~<>()[]{}*+&|^,;:");
                           extMod.addConfig(this/*script*/, sValWords);
                           break;

                        case "input":
                           sValWords <= sVal.splitSpace(true);
                           extMod.addInput(sValWords.get(0)/*id*/, sValWords.get(1)/*defVal*/);
                           break;

                        case "emit":
                           extMod.addEmit(sVal);
                           break;
                     }
                  }
               }
            }
            if!(extMod.id.isBlank())
            {
               ext_mods.add(#(deref extMod));
               trace "[trc] CyScript::parseExtInc: add ext mod \""+extMod.id+"\"";
            }
            else
               throw CyParseError getSrcLoc()+": missing @cycle_mod id in xinc \""+sPathName+"\"";
         }
         else
            throw CyParseError getSrcLoc()+": failed to read xinc \""+sPathName+"\"";
      }
      else
         throw CyParseError getSrcLoc()+": expect include path name";
   }

   // <method_parse.png>
   protected method parseExtMod(String _type) : CyModuleExt {
      CyExtMod *extMod;
      foreach extMod in ext_mods
      {
         if(extMod.id == _type)
         {
            CyModuleExt mod <= new CyModuleExt;
            mod.initExtFrom(extMod);
            return deref mod;
         }
      }
      throw CyParseError getSrcLoc()+": unknown ext mod \""+_type+"\"";
   }

   // <method_parse.png>
   protected method parseNextMacroLine(int indent) {
      // trace "xxx indent="+indent+" macro_indent="+macro_indent+" macro_state="+macro_state+" words[0]=\""+words[0]+"\"";
      boolean bLineDone = false;
      if(indent > macro_indent)
      {
         switch(macro_state)
         {
            case 0:
               // parse field names
               //  macro m_osc_mix
               //   sin   tri  saw   pul   <------
               StringArray macroFieldNames <= cur_macro.field_names;
               int macroFieldNameWordIdx = 0;
               while(macroFieldNameWordIdx < words.numElements)
                  macroFieldNames.add(Utils.ConvertToVarName(words[macroFieldNameWordIdx++]));
               // trace "xxx macro field names="+#(cur_macro.field_names);
               macro_state = 1;
               break;

            case 1:
               // parse field values or "permutate" keyword
               if("permutate" == words[0])
               {
                  // "permutate 1.0 1.02 0.98"
                  local FloatArray permutateValues;
                  permutateValues.empty();
                  int permWordIdx = 1;
                  while(permWordIdx < words.numElements)
                     permutateValues.add(float(words[permWordIdx++]));
                  if(permutateValues.numElements > 0)
                  {
                     int totalNumMacroRows = mathPowerf(permutateValues.numElements, cur_macro.field_names.numElements);
                     if(totalNumMacroRows <= MAX_MACRO_ROWS)
                     {
                        cur_macro.calcPermutations(permutateValues);
                        // end of macro definition
                        cur_macro <= null;
                        macro_state = -1;
                        bLineDone = true;
                     }
                     else
                        throw CyMacroOverflowError getSrcLoc()+": too many macro rows ("+totalNumMacroRows+">"+MAX_MACRO_ROWS+")";
                  }
                  else
                     throw CyMacroNoValuesError getSrcLoc()+": missing permutation values";
               }
               else
               {
                  // parse field values
                  macro_state = 2;
               }
               break;
         }

         if(2 == macro_state)
         {
            // parse next row field values
            //   "1     0     0    0"
            FloatArray macroFieldValues <= cur_macro.field_values;
            int numMacroFieldNames = cur_macro.field_names.numElements;
            int numMacroFieldValues = mathMini(words.numElements, numMacroFieldNames);
            int macroFieldWordIdx = 0;
            while(macroFieldWordIdx < numMacroFieldValues)
               macroFieldValues.add(float(words[macroFieldWordIdx++]));
            while(macroFieldWordIdx++ < numMacroFieldNames)  // pad missing values with 0
               macroFieldValues.add(0.0f);
         }
      }
      else
      {
         // indent decreased => end of macro definition
         cur_macro <= null;
         macro_state = -1;
      }
      return bLineDone;
   }

   // <method_parse.png>
   protected method parseNextMapLine(int _indent) {
      // trace "xxx indent="+indent+" map_indent="+map_indent+" map_state="+map_state+" words[0]=\""+words[0]+"\"";
      if(_indent > map_indent)
      {
         switch(map_state)
         {
            case 0:
               // parse field names
               //  map mykeymap
               //         freq  vol  cutoff
               StringArray mapFieldNames <= cur_map.field_names;
               int mapFieldNameWordIdx = 0;
               while(mapFieldNameWordIdx < words.numElements)
                  mapFieldNames.add(Utils.ConvertToVarName(words[mapFieldNameWordIdx++]));
               // trace "xxx map field names="+#(cur_map.field_names);
               map_state = 1;
               break;

            case 1:
               // parse next row field values
               //   <key> 1     0    0
               if(words.numElements > 0)
               {
                  float mapKey = words[0];
                  if(!cur_map.addRowKey(mapKey))
                     throw CyMapKeyAlreadyExists getSrcLoc()+": map key "+mapKey+" already exists";
                  FloatArray mapFieldValues <= cur_map.field_values;
                  int numMapFieldNames = cur_map.field_names.numElements;
                  int numMapFieldValues = mathMini(words.numElements, numMapFieldNames);
                  int mapFieldWordIdx = 1;
                  // // trace "xxx parse map words="+#(words);
                  while(mapFieldWordIdx <= numMapFieldValues)
                     mapFieldValues.add(ParseFloat(words[mapFieldWordIdx++]));
                  while(mapFieldWordIdx++ <= numMapFieldNames)  // pad missing values with 0
                     mapFieldValues.add(0.0f);
                  // trace "xxx harseNextMapLines: #mapFieldValues="+mapFieldValues.numElements+" (#fields="+numMapFieldNames+")";
                  cur_map.num_rows++;
               }
               break;
         }
      }
      else
      {
         // indent decreased => end of macro definition
         cur_map <= null;
         map_state = -1;
      }
   }

   // <method_parse.png>
   protected method parseNextTemplateLine(int _indent, String _line) {
      // trace "xxx indent="+indent+" map_indent="+map_indent+" map_state="+map_state+" words[0]=\""+words[0]+"\"";
      if(_indent > template_indent)
      {
         cur_template.addLine(_line);
      }
      else
      {
         // indent decreased => end of template definition
         cur_template <= null;
      }
   }

   // <method.png>
   protected method optimizeCurveIndices() {
      // trace "[trc] CyScript::optimizeCurveIndices: ENTER. curve_aliases="+curve_aliases;
      // trace "[trc] CyScript::optimizeCurveIndices:   new_curve_alias_order="+parent_patch.new_curve_alias_order;

      local IntArray remapTbl;
      remapTbl.allocAndFill(CyclePatch.TOTAL_NUM_CURVES, -1);
      IntArray curveAutoAssign <= parent_patch.curve_auto_assign;
      // trace "xxx CyScript::optimizeCurveIndices:   curveAutoAssign="+curveAutoAssign;

      // Fill in allocated indices
      int curveIdx = 0;
      loop(CyclePatch.TOTAL_NUM_CURVES)
      {
         if(maybe != curveAutoAssign[curveIdx])  // in use ?
            remapTbl[curveIdx] = curveIdx;
         curveIdx++;
      }

      // // trace "xxx curveAutoAssign="+curveAutoAssign;

      // Swap / copy curves
      //  (note) updates remapTbl and curve_aliases
      parent_patch.reorderCurves(remapTbl, curve_aliases);

      // Remap 'lut' refs
      CyModuleLUT *modLut;
      // // trace "xxx CyScript: remap lut refs: a_mod_lut="+#(a_mod_lut);
      foreach modLut in a_mod_lut
      {
         if(-1 != modLut.curve_idx)
         {
            // trace "xxx CyScript::optimizeCurveIndices: remap modLut.curve_idx="+modLut.curve_idx+" => "+remapTbl[modLut.curve_idx];
            modLut.curve_idx = remapTbl[modLut.curve_idx];
         }
      }

      // Remap array param copy refs
      CyArrayDecl *ad;
      foreach ad in array_decls
      {
         if(-1 != ad.copy_curve_idx)
            ad.copy_curve_idx = remapTbl[ad.copy_curve_idx];
      }

      // trace "xxx optimizeCurveIndices: LEAVE";
   }

   // <method_get.png>
   public method getCurveIntArray(int _curveIdx) : IntArray {
      return curve_intarrays.get(_curveIdx);
   }

   // <method.png>
   protected method popInputsAfterIndent(int _indent) {
      // called after newMod() (when mod!=null or template instantiation begins)
      while((null != cur_input) && (_indent <= cur_input.indent))
      {
         if(b_debug2) trace "xxx pop indent="+_indent+" cur_input.id="+cur_input.id+" cur_input.indent="+cur_input.indent;
         cur_mod <= cur_input.parent_mod;
         popInput();

         if(b_debug2)
         {
            trace "xxx    => pop new cur_input="+#(cur_input);
            if(null != cur_input)
               trace "xxx    => pop new cur_input.id="+cur_input.id+" cur_input.indent="+cur_input.indent;
         }
         // if(null != cur_input)
         //    cur_mod <= cur_input.parent_mod;
         // else
         //    cur_mod <= null;
      }
   }

   // <method_parse.png>
   public method parseString(String _s) {

      cur_lane      <= null;
      cur_mod       <= null;
      cur_input     <= null;
      cur_macro     <= null;
      cur_arraydecl <= null;
      cur_map       <= null;

      macro_state         = -1;
      macro_indent        = -1;
      map_state           = -1;
      map_indent          = -1;
      template_indent     = -1;
      global_indent       = -1;
      int arrayDeclIndent = -1;

      args.empty();
      vars.empty();
      vpl_modules.empty();
      a_mod_lut.empty();
      s_ext_inc.empty();
      a_inc_done.empty();

      int wIdx;
      local Integer retWIdx;
      local String *templateId;
      int curContextLineOffset;

      pushParseContext("",
                       false/*bIncLineIdx*/,
                       _s.splitChar('\n')/*lines*/,
                       0/*lineIdx*/,
                       null/*templateOrNull*/,
                       null/*templateInstanceIdOrNull*/
                       );
      String *line;
      int op;
      CyModule *mod;
      b_have_plugin_id = false;

      // (Normalized) Wavetable per-cycle vars
      addVarInternal("x"); // => var_x (lut)
      // // addVarInternal("tmp");

      // removed later when patch is a plugin:
      addVarInternal("wt_x"); // => var_wt_x/y
      addVarInternal("wt_y");
      addVarInternal("wt_freq");

      b_mirror = false;

      for(;;)
      {
         // wIdx = 0;  // (todo) remove
         boolean bDone = false;

         // trace "xxx cur_parse_context="+#(cur_parse_context);
         while(cur_parse_context.done())
         {
            if(b_debug3)
               trace "xxx cur_parse_context.done() name="+cur_parse_context.name+" line_idx="+cur_parse_context.cur_line_idx;

            popParseContext(false/*bKeepLineIdx*/);

            // trace "xxx cur_parse_context="+#(cur_parse_context);
            if(null != cur_parse_context)
            {
               // // cur_parse_context.nextLine();
            }
            else
            {
               bDone = true;
               break;
            }
         }

         if(bDone)
            break;

         if(cur_parse_context.beginLine(0/*lineOffset*/))  // false when line is blank or just a comment
         {
            line  <= cur_parse_context.cur_line;
            words <= cur_parse_context.cur_words;
            if(b_debug3)
               trace "xxx parse line >>"+line+"<< cur_lane="+#(cur_lane)+" cur_lane.id="+((null != cur_lane)?cur_lane.id:"n/a")+" cur_template="+#(cur_template)+" templ_inst="+#(cur_parse_context.template_or_null)+" cur_input="+#(cur_input)+" cur_words="+#(words);
            // // wIdx = 0;
            boolean bLineDone = false;
            // // trace "xxx line["+getSrcLoc()+"] words="+#(words);

            if(words.numElements > 0)
            {
               int indent = line.indexOf(words[0], 0);
               if(b_debug2) trace "xxx line_nr="+getSrcLoc()+" indent="+indent+" words="+#(words);

               // trace "xxx line_nr="+getSrcLoc()+" line=<<"+line+">> cur_ui_module_def="+#(cur_ui_module_def)+" cur_ui_patch="+#(cur_ui_patch);

               if(null != cur_ui_module_def)
               {
                  if(line <= "</ui:mod>")
                  {
                     cur_ui_module_def <= null;
                  }
                  else
                  {
                     cur_ui_module_def.parseNextLine(line, indent, words);
                  }
                  bLineDone = true;
               }
               else if(null != cur_ui_patch)
               {
                  if(line <= "</ui:patch>")
                  {
                     finishUIPatchAndUnset();
                  }
                  else
                  {
                     cur_ui_patch.parseNextLine(line, indent, words);
                  }
                  bLineDone = true;
               }
               else if(null != cur_macro)
               {
                  bLineDone = parseNextMacroLine(indent);
               }
               else if(null != cur_map)
               {
                  parseNextMapLine(indent);
               }
               else if(null != cur_template)
               {
                  parseNextTemplateLine(indent, line);
               }
               else if(null != cur_arraydecl)
               {
                  // trace "xxx indent="+indent+" arrayDeclIndent="+arrayDeclIndent+" words[]="+words;
                  if(indent > arrayDeclIndent)
                  {
                     // parse next element info
                     //   "idx name dpyresetval dpymin dpymax"
                     parseArrayDeclElement();
                  }
                  else
                  {
                     // indent decreased => end of macro definition
                     cur_arraydecl <= null;
                  }
               }

               if(b_debug3)
                  trace "xxx "+getSrcLoc()+": line=>>"+line+"<<  indent="+indent+" cur_lane.indent="+((null != cur_lane)?cur_lane.indent:"?")+ " cur_lane.id="+((null !=cur_lane)?cur_lane.id:"n/a")+" cur_mod="+#(cur_mod)+" cur_input="+#(cur_input)+" cur_input.id="+((null != cur_input)?cur_input.id:"n/a");
               if(!bLineDone && null != cur_lane && indent < cur_lane.indent)
               {
                  // if(null != cur_parse_context.template_or_null)
                  // {
                  if(b_debug3)
                     trace "xxx end "+((null != cur_parse_context.template_or_null)?"templ":"")+" lane, indent="+indent+" cur_lane.indent="+cur_lane.indent+" cur_lane.id="+((null !=cur_lane)?cur_lane.id:"n/a")+" cur_input="+#(cur_input)+" input_stack="+#(input_stack);

                  popParseContext(true/*bKeepLineIdx*/);

                  if(null != cur_parse_context)
                     line  <= cur_parse_context.cur_line;
                  // // // cur_lane    <= cur_parse_context.restore_lane;
                  // // // cur_mod     <= cur_parse_context.restore_mod;
                  // // // cur_input   <= cur_parse_context.restore_input;
                  // // // input_stack <= cur_parse_context.input_stack;
                  if(b_debug3)
                     trace "xxx end lane, restore cur_lane="+#(cur_lane)+" cur_lane.id="+((null != cur_lane)?cur_lane.id:"n/a")+" cur_mod="+#(cur_mod)+" cur_input="+#(cur_input)+" input_stack="+#(input_stack);
                  // // }
                  // // else
                  // // {
                  // //    cur_lane <= null;
                  // //    cur_mod  <= null;
                  // // }
               }

               if(b_debug3)
                  trace "xxx words="+#(words);

               if(!bLineDone && null != cur_parse_context.template_or_null && "<" == words[0])
               {
                  addTemplateLane(indent, false/*bAllowUnderscore*/, 1/*wordIdxId*/);
                  cur_input <= null;
                  cur_mod <= null;
                  bLineDone = true;
               }

               // trace "xxx words="+#(words)+" bLineDone="+bLineDone+" template_or_null="+#(cur_parse_context.template_or_null);
               if(!bLineDone && null != cur_parse_context.template_or_null &&
                  (":" == words.last) &&
                  ["init", "prepare", "calc"].containsObject(words[0])
                  )
               {
                  // trace "xxx  addTemplateLane";
                  addTemplateLane(indent, true/*bAllowUnderscore*/, 0/*wordIdxId*/);
                  cur_input <= null;
                  cur_mod <= null;
                  bLineDone = true;
               }

               if(b_debug3) trace "xxx cur_parse_context="+#(cur_parse_context)+" words="+#(words);

               if(!bLineDone && null != cur_parse_context.template_or_null && "global" == words.get(0) && ":" == words[1])
               {
                  if(b_debug3)
                     trace "xxx begin global  input_stack="+#(input_stack)+" cur_input="+#(cur_input);
                  global_indent = indent + 1;
                  curContextLineOffset = cur_parse_context.line_offset;
                  pushParseContext(cur_parse_context.name,
                                   true/*bIncLineIdx*/,
                                   cur_parse_context.lines,
                                   cur_parse_context.cur_line_idx,
                                   cur_parse_context.template_or_null,
                                   cur_parse_context.template_instance_id
                                   );
                  cur_parse_context.line_offset = curContextLineOffset;

                  cur_lane  <= null;
                  cur_mod   <= null;
                  cur_input <= null;
                  bLineDone = true;
                  // // trace "xxx global cur_lane="+#(cur_lane);
               }

               if(!bLineDone && indent < global_indent && null != cur_parse_context.template_or_null)
               {
                  // end of "global:" template section
                  if(b_debug3)
                     trace "xxx end global indent="+indent+" global_indent="+global_indent+" line=>>"+line+"<<";
                  global_indent = -1;
                  popParseContext(false/*bKeepLineIdx*/);
                  // // // if(null != cur_parse_context)
                  // // //    cur_parse_context.prevLine();
                  // // // bLineDone = true;
                  // // trace "xxx end global: before beginLine words="+#(words);
                  if(null != cur_parse_context)
                  {
                     words <= cur_parse_context.cur_words;
                     line  <= cur_parse_context.cur_line;
                  }
                  if(b_debug3)
                     trace "xxx end global cur_parse_context="+#(cur_parse_context)+" input_stack="+#(input_stack)+" cur_input="+#(cur_input)+ "line="+line+" words="+#(words);
               }

               if(!bLineDone && null == cur_macro && null == cur_map && null == cur_template && null == cur_arraydecl)
               {
                  boolean bNotNextCol = (":" != words.get(1));
                  if("<" == words.get(0) && ":" == words.last)
                  {
                     addLane(indent, false/*bAllowUnderscore*/, 1/*wordIdxId*/);

                     cur_input <= null;
                     cur_mod <= cur_lane.findLastMod();  // null after creating new lane, last mod when continuing lane

                     bLineDone = true;
                  }
                  else if(bNotNextCol && ("a" == words.get(0) || "arg" == words.get(0)))
                  {
                     if(words.numElements > 1)
                     {
                        addArg(false/*bLocal*/);
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing var name";
                  }
                  else if(bNotNextCol && ("av" == words[0] || "arg_values" == words[0]))
                  {
                     // arg_values <arg_name> {<value>=<name>}
                     parseArgValues();
                  }
                  else if(bNotNextCol && ("v" == words[0] || "var" == words[0]))
                  {
                     if(words.numElements > 1)
                     {
                        addVar();
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing var name";
                  }
                  else if(bNotNextCol && ("mp" == words[0] || "modparam" == words[0]))
                  {
                     // shortcut for "param" and "mod"
                     //  - auto-prefix "m_" to mod
                     //  - auto-prefix "p_" to param
                     if(words.numElements > 1)
                     {
                        String modParamName <= words.get(1);  // e.g. "amp"
                        CyPluginMod modParamMod <= new CyPluginMod;
                        modParamMod.init();
                        modParamMod.id = "m_"+modParamName;
                        plugin_mods.add(#(deref modParamMod));

                        addPluginParam("p_"/*prefix*/, retWIdx);

                        wIdx = retWIdx;
                        if((wIdx + 2) < words.numElements)
                        {
                           if("smooth" == words.get(wIdx+0) && "=" == words.get(wIdx+1))
                           {
                              modParamMod.b_smooth = int(words.get(wIdx+2));
                           }
                        }

                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin param/mod name";
                  }
                  else if(bNotNextCol && ("p" == words[0] || "param" == words[0]))
                  {
                     if(words.numElements > 1)
                     {
                        if(isPlugin())
                           addPluginParam(null/*prefix*/, retWIdx);
                        else
                           addArg(false/*bLocal*/);
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin param name";
                  }
                  else if(bNotNextCol && ("lp" == words[0] || "lparam" == words[0]))
                  {
                     if(words.numElements > 1)
                     {
                        if(isPlugin())
                           addPluginParam(null/*prefix*/, retWIdx);  // (todo) local/hidden params ?
                        else
                           addArg(true/*bLocal*/);
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin param name";
                  }
                  else if(bNotNextCol && 
                          ("pv" == words[0] || "param_values" == words[0] || 
                           "lpv" == words[0] || "lparam_values" == words[0]
                           )
                          )
                  {
                     // param_values <param_name> {<value>=<name>}
                     if(isPlugin())
                        parseParamValues();
                     else
                        parseArgValues();
                  }
                  else if(bNotNextCol && (("m" == words[0] || "mod" == words[0]) && null == cur_lane))
                  {
                     if(words.numElements > 1)
                     {
                        CyPluginMod pluginMod <= addPluginMod(retWIdx);
                        wIdx = retWIdx;
                        if((wIdx + 2) < words.numElements)
                        {
                           if("smooth" == words.get(wIdx+0) && "=" == words.get(wIdx+1))
                           {
                              pluginMod.b_smooth = int(words.get(wIdx+2));
                           }
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin mod name";
                  }
                  else if((words.numElements > 1) && (":" == words[1]))
                  {
                     // "myinput:"
                     while((null != cur_input) && (indent <= cur_input.indent))
                     {
                        if(b_debug2) trace "xxx pop cur_input.id="+cur_input.id;
                        cur_mod <= cur_input.parent_mod;
                        popInput();
                        if(b_debug2) trace "xxx    => new cur_input="+#(cur_input);
                        // if(null != cur_input)
                        // {
                        //    if(b_debug2) trace "xxx    => new cur_input.id="+cur_input.id;
                        // }
                        // // else
                        // //    cur_mod <= null;
                     }

                     // // Previous level
                     while((null != cur_mod) && (indent < cur_mod.indent))
                     {
                        cur_mod <= cur_mod.seq_parent;
                     }

                     if(b_debug2) trace "xxx input cur_mod="+#(cur_mod);

                     if(null != cur_mod)
                     {
                        // // trace "xxx cur_mod="+#(cur_mod)+" inpId="+words[0];
                        cur_input <= cur_mod.findInputById(words[0]);
                        if(null != cur_input)
                        {
                           cur_input.indent = indent;
                           pushInput();
                           cur_mod <= null;
                        }
                        else
                           throw CyInputNotFoundError getSrcLoc()+": \""+cur_mod.getString()+"\" has no input \""+words[0]+"\"";
                     }
                     else
                        throw CyParseError getSrcLoc()+": input start outside of module";
                  }
                  else if("rate" == words[0])
                  {
                     if(words.numElements > 1)
                     {
                        sample_rate = mathClampf(float(words[1].replace("Hz","")), 1000.0, 176400);
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing sample rate value";
                  }
                  else if("freq" == words[0])
                  {
                     if(words.numElements > 1)
                     {
                        String sFreq <= words[1];
                        float freqNoteIdx = MIDI.midi_notes.indexOfObject(sFreq, 0);
                        if(freqNoteIdx >= 0)
                        {
                           // Note (e.g. C#3)
                           if(words.numElements > 2)
                           {
                              // Finetune
                              freqNoteIdx += float(words[2]);
                           }
                           base_freq = Audio.NoteToFreq(freqNoteIdx);
                        }
                        else if(sFreq & "/")
                        {
                           words <= sFreq.splitChar('/');
                           if(2 == words.numElements)
                           {
                              // <float>/<float>
                              base_freq = float(words[0].trim()) / float(words[1].trim());
                           }
                           else
                              throw CyParseError getSrcLoc()+": error parsing <float>/<float> freq ratio";
                        }
                        else
                        {
                           // Frequency (Hz)
                           base_freq = mathClampf(float(sFreq.replace("Hz","")), 1.0, 22000);
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing base frequency value";
                  }
                  else if("oct" == words[0])
                  {
                     if(words.numElements > 1)
                     {
                        base_oct = mathClampf(float(words[1]), -4.0, 4);
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing base octave value";
                  }
                  else if("dur" == words[0])
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"dur\" not allowed in plugins";

                     if(words.numElements > 1)
                     {
                        if( ("ms" == words.get(2)) || (words[1] & "ms") )
                        {
                           float durMS = words[1].replace("ms","");
                           num_frames = mathClampf((durMS * sample_rate)/1000.0, 16, 1024*1024);
                        }
                        else
                        {
                           num_frames = mathMaxi(0, words[1] * oversample_factor);
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing duration value";
                  }
                  else if("wt_w" == words[0])
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"wt_w\" not allowed in plugins";

                     if(words.numElements > 1)
                     {
                        // (note) 0=auto (width / cyclelen)
                        override_wt_w = mathMaxi(0, words.get(1));
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing wt_w value";
                  }
                  else if("wt_h" == words[0])
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"wt_h\" not allowed in plugins";

                     if(words.numElements > 1)
                     {
                        // (note) 0=auto (1)
                        override_wt_h = mathMaxi(0, words.get(1));
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing wt_h value";
                  }
                  else if("wt_cyclelen" == words[0])
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"wt_cyclelen\" not allowed in plugins";

                     if(words.numElements > 1)
                     {
                        override_wt_cyclelen = mathMaxi(0, words.get(1));
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing wt_cyclelen value";
                  }
                  else if("wt_freqs" == words[0])
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"wt_freqs\" not allowed in plugins";

                     parseWtFreqs();
                  }
                  else if("skip" == words[0])
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"skip\" not allowed in plugins";

                     if(words.numElements > 1)
                     {
                        if( ("ms" == words.get(2)) || (words[1] & "ms") )
                        {
                           float skipMS = words[1].replace("ms","");
                           num_skip_frames = mathClampf((skipMS * sample_rate)/1000.0, 16, 1024*1024);
                        }
                        else
                        {
                           num_skip_frames = mathMaxi(0, words[1]);
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing duration value";
                  }
                  else if("xfade" == words[0] && null == cur_lane)
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"xfade\" not allowed in plugins";

                     if(words.numElements > 1)
                     {
                        if( ("%" == words.get(2)) || (words[1] & "%") )
                        {
                           xfade_percent = words[1].replace("%","");
                           xfade_frames = 0;
                        }
                        else
                        {
                           xfade_frames = mathClampi(words[1], 0, MAX_XFADE_FRAMES);
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing duration value";
                  }
                  else if("mirror" == words[0] && null == cur_lane)
                  {
                     if(b_plugin && b_have_plugin_id)
                        throw CyPluginExportError getSrcLoc()+": \"mirror\" not allowed in plugins";

                     b_mirror = true;
                  }
                  else if("c" == words[0] || "curve" == words[0])
                  {
                     // "curve <curveidx> mycurve"
                     // "curve <curveidx> mycurve param=<param_id> size=<numelements> var=<numvar>"
                     cur_arraydecl <= addCurveAlias(false/*bLocal*/);
                     arrayDeclIndent = indent + 1;
                  }
                  else if("lc" == words[0] || "lcurve" == words[0])
                  {
                     // "lcurve mycurve"
                     // "lcurve mycurve param=<param_id> size=<numelements> var=<numvar>"
                     cur_arraydecl <= addCurveAlias(true/*bLocal*/);
                     arrayDeclIndent = indent + 1;
                  }
                  else if("ap" == words[0] || "array" == words[0])
                  {
                     // "array <curveidx> myarrayparam size=<numelements> var=<numvar>"
                     cur_arraydecl <= addArrayDecl();
                     arrayDeclIndent = indent + 1;
                  }
                  else if("lut" == words[0] && null == cur_lane)
                  {
                     // "lut mylut voice 32"
                     if(b_debug2)
                        trace "xxx parse LUT wIdx="+wIdx;
                     // wIdx = 0;
                     addLUT();
                  }
                  else if("z" == words[0] || "zone" == words[0])
                  {
                     // // if(b_plugin && b_have_plugin_id)
                     // //    throw CyPluginExportError getSrcLoc()+": \"zone\" not allowed in plugins";
                     // "zone myzone"
                     // "zone mysmp.myzone"
                     // "zone 0 myzone"
                     // "zone 0 mysmp.myzone"
                     addZoneRef();
                  }
                  else if("dither" == words[0])
                  {
                     if(words.numElements > 1)
                     {
                        switch(words[1])
                        {
                           case "0":
                           case "n":
                           case "false":
                           case "off":
                              dither_mode = 0;
                              break;

                           case "1":
                              dither_mode = 1;
                              break;

                           case "2":
                           case "scaled":
                              dither_mode = 2;
                              break;

                           case "3":
                           case "y":
                           case "true":
                           case "on":
                              dither_mode = 3;
                              break;

                           case "4":
                              dither_mode = 4;
                              break;

                           case "5":
                              dither_mode = 5;
                              break;

                           case "6":
                              dither_mode = 6;
                              break;

                           case "7":
                              dither_mode = 7;
                              break;

                           case "8":
                              dither_mode = 8;
                              break;
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing 'dither' boolean value";
                  }
                  else if("oversample_factor" == words[0] || "oversample" == words[0])
                  {
                     if(words.numElements > 1)
                     {
                        String sOsFactor <= words[1];
                        if(sOsFactor & "/")
                        {
                           // "1/32"
                           float osNumerator   = sOsFactor.substring(0, sOsFactor.indexOfChar('/', 0));
                           float osDenominator = sOsFactor.substring(sOsFactor.indexOfChar('/', 0)+1, 999);
                           oversample_factor = mathClampf(osNumerator / osDenominator, 1/32.0f, 32.0f);
                        }
                        else
                        {
                           // "32"
                           oversample_factor = mathClampf(float(words[1]), 1/32.0f, 32.0f);
                        }
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing oversample_factor value";
                  }
                  else if("oversample_quality" == words[0])
                  {
                     // // if(b_plugin)
                     // //    throw CyPluginExportError getSrcLoc()+": \"oversample_quality\" not allowed in plugins";

                     if(words.numElements > 1)
                     {
                        oversample_quality = mathClampi(int(words[1]), 0, 10);
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing oversample_quality value";
                  }
                  else if("id" == words[0] && null == cur_lane)
                  {
                     if(words.numElements > 1)
                     {
                        plugin_id = words.get(1).trim();

                        if(plugin_id & "_0x")  // reserved for chksum (sample specific patch plugins)
                           throw CyParseError getSrcLoc()+": invalid plugin id \""+plugin_id+"\"";

                        b_have_plugin_id = !plugin_id.isBlank();
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin id";
                  }
                  else if("name" == words[0] && null == cur_lane)
                  {
                     if(words.numElements > 1)
                     {
                        plugin_name = words.get(1).trim();
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin name";
                  }
                  else if("author" == words[0] && null == cur_lane)
                  {
                     if(words.numElements > 1)
                     {
                        plugin_author = words.get(1).trim();
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin author";
                  }
                  else if( ("category" == words[0]) || ("cat" == words[0]) )
                  {
                     if(words.numElements > 1)
                     {
                        plugin_category = parseAndValidateCategory(words.get(1).trim());  // throws exception if cat is invalid
                     }
                     else
                        throw CyParseError getSrcLoc()+": missing plugin category";
                  }
                  else if(null == cur_lane && ("mac" == words[0] || "macro" == words[0]))
                  {
                     // "mac m_osc_mix"
                     // "macro m_osc_mix"
                     if(words.numElements >= 2)
                     {
                        local String macroId <= Utils.ConvertToVarName(words[1]);
                        if(null == findMacroById(macroId))
                        {
                           cur_macro <= new CyMacro;
                           cur_macro.id = macroId;
                           macros.add(#(deref cur_macro));
                           macro_indent = indent + 1;
                           macro_state = 0;  // parse field names
                        }
                        else
                           throw CyMacroNameError getSrcLoc()+": macro \""+macroId+"\" has already been declared";
                     }
                     else
                        throw CyMacroNameError getSrcLoc()+": expected macro name";
                  }
                  else if(null == cur_lane && "map" == words[0])
                  {
                     // "map mykeymap"
                     if(words.numElements >= 2)
                     {
                        local String mapId <= Utils.ConvertToVarName(words[1]);
                        if(null == findMapById(mapId))
                        {
                           cur_map <= new CyMap;
                           cur_map.initMap();
                           cur_map.id = mapId;
                           maps.add(#(deref cur_map));
                           map_indent = indent + 1;
                           map_state = 0;  // parse field names
                        }
                        else
                           throw CyMapNameError getSrcLoc()+": map \""+mapId+"\" has already been declared";
                     }
                     else
                        throw CyMapNameError getSrcLoc()+": expected map name";
                  }
                  else if(null == cur_lane && "def" == words[0])
                  {
                     // template definition
                     //   "def mytemplate"
                     if(words.numElements >= 2)
                     {
                        templateId <= Utils.ConvertToVarName(words[1]);
                        if(null == findTemplateById(templateId))
                        {
                           cur_template <= new CyTemplate;
                           cur_template.initTemplate(templateId);
                           templates.add(#(deref cur_template));
                           template_indent = indent + 1;
                           cur_template.parent_buffer = cur_parse_context.getBufferName();
                           cur_template.parent_line_idx = cur_parse_context.cur_line_idx;
                           // trace "[trc] Cycle: starting template def in \""+cur_template.parent_buffer+"\", line_idx="+cur_template.parent_line_idx;

                           // Parse variables ("myvar=somestring")
                           wIdx = 2;
                           while((wIdx + 2) < words.numElements)
                           {
                              if("=" == words.get(wIdx+1))
                              {
                                 cur_template.addVar(words.get(wIdx),
                                                     words.get(wIdx+2)
                                                     );
                                 wIdx += 3;
                              }
                              else
                                 throw CyParseError getSrcLoc()+": expected '=' in template var declaration";
                           }
                        }
                        else
                           throw CyTmpNameError getSrcLoc()+": template \""+templateId+"\" has already been declared";
                     }
                     else
                        throw CyTmpNameError getSrcLoc()+": expected template name";
                  }
                  else if(null == cur_lane && ("~" == words[0] || "tmp" == words[0]))
                  {
                     // template instantiation (outside of lane)
                     //   "tmp mytemplate"
                     if(b_debug3)
                        trace "xxx begin templ inst, input_stack="+#(input_stack);
                     if(words.numElements >= 2)
                     {
                        templateId <= Utils.ConvertToVarName(words[1]);
                        CyTemplate tmpl <= findTemplateById(templateId);
                        if(null != tmpl)
                        {
                           local StringArray tmplVars <= new StringArray;
                           local StringArray tmplValues <= new StringArray;
                           local String tmplInstanceId <= String(next_template_var_idx + 1);  // default instance-id

                           local CyTemplateInstance tmplInstance <= new CyTemplateInstance;
                           template_instances.add(#(deref tmplInstance));
                           tmplInstance.init(tmpl.id, tmplInstanceId);

                           // Parse variables ("myvar=somestring")
                           int varIdx = 0;
                           wIdx = 2;
                           while(wIdx < words.numElements)
                           {
                              if("=" == words.get(wIdx+1))
                              {
                                 tmplVars  .add(words.get(wIdx));
                                 tmplValues.add(words.get(wIdx+2));

                                 // Override template instance id ?
                                 // trace "xxx template sVarName="+tmplVars.last+" value=\""+tmplValues.last+"\"";
                                 if("id" == tmplVars.last)
                                 {
                                    tmplInstanceId <= Object(tmplValues.last);  // "myinstance"
                                    tmplInstance.init(tmpl.id, tmplValues.last);
                                 }

                                 varIdx = tmpl.findVarNameIdx(tmplVars.last) + 1;

                                 wIdx += 3;
                              }
                              else
                              {
                                 // No var name, assign to next var
                                 String sVarName <= tmpl.getVarNameByIdx(varIdx++);
                                 if(null != sVarName)
                                 {
                                    tmplVars  .add(sVarName);
                                    tmplValues.add(words[wIdx++]);
                                 }
                                 else
                                    throw CyParseError getSrcLoc()+": template \""+tmpl.id+"\" has no var at index "+(varIdx-1);
                              }
                           }

                           local String tmplInstanceVarPrefix <= "__ti_"+tmpl.id+"_"+tmplInstanceId+"_";

                           local String *tmpContextName;
                           // // tmpContextName <= cur_parse_context.getLineNr()+":tmp "+tmpl.id;  // pre 13Dec2024
                           if(tmpl.parent_buffer == "main")
                           {
                              // invocation + template declaration in main source
                              tmpContextName <= cur_parse_context.getLineNr()+":buf main";
                           }
                           else
                           {
                              // template declaration in other buffer
                              tmpContextName <= cur_parse_context.getLineNr()+":buf "+tmpl.parent_buffer;
                           }

                           pushParseContext(deref tmpContextName,
                                            true/*bIncLineIdx*/,
                                            tmpl.getInstanceLines(this,
                                                                  indent,
                                                                  deref tmplVars,
                                                                  deref tmplValues,
                                                                  tmplInstanceId
                                                                  ),
                                            -1/*lineIdx*/,  // nextLine() is called before beginLine()
                                            tmpl,
                                            deref tmplInstanceId
                                            );
                           // trace "xxx global templ inst: tmpl.parent_line_idx="+tmpl.parent_line_idx+" cur_parse_context="+#(cur_parse_context);
                           cur_parse_context.line_offset =
                              tmpl.parent_line_idx + 1  // add line start offset of template definition and skip 'def' line
                              ;
                           cur_parse_context.var_prefix = tmplInstanceVarPrefix;////"__ti_"+next_template_var_idx+"_";
                        }
                        else
                           throw CyTmpNameError getSrcLoc()+": undeclared template \""+templateId+"\"";
                     }
                     else
                        throw CyTmpNameError getSrcLoc()+": expected template name";
                  }
                  else if("end" == words[0] && null != cur_lane && 1 == words.numElements)  // "end" but not "end:"
                  {
                     // End of lane
                     cur_lane.b_end = true;

                     if(null != cur_parse_context.template_or_null)
                     {
                        // continue in lane which instantiated the template
                        cur_lane    <= cur_parse_context.restore_lane;
                        cur_mod     <= cur_parse_context.restore_mod;
                        cur_input   <= cur_parse_context.restore_input;
                     }
                     else
                     {
                        cur_lane <= null;
                     }
                  }
                  else if("inc" == words[0] && null == cur_lane)
                  {
                     parseInc();
                  }
                  else if("xinc" == words[0] && null == cur_lane)
                  {
                     parseExtInc();
                  }
                  else if(line <= "<ui:mod>")
                  {
                     trace "xxx ++++++++++++++++++++++++++++++ found <ui:mod>";
                     cur_ui_module_def <= new CyUIModule;
                     cur_ui_module_def.initModuleDef();
                     ui_modules.add(#(deref cur_ui_module_def));
                     bLineDone = true;
                  }
                  else if(line <= "<ui:patch>")
                  {
                     ui_patch <= new CyUIPatch;
                     ui_patch.initPatch(ui_modules/*availableModules*/);
                     cur_ui_patch <= ui_patch;
                     bLineDone = true;
                  }
                  else if(!bLineDone)
                  {
                     boolean bTryMod = true;

                     if(words.numElements >= 3)
                     {
                        if(cur_mod instanceof CyModuleVpl)
                        {
                           if("=" == words[1])
                           {
                              // "param" = val
                              CyModuleVpl modVpl <= cur_mod;
                              String vplVal <= words[2];
                              if(vplVal <= "$")
                              {
                                 String vplArgName <= vplVal.substring(1, 999);
                                 CyArg vplArg <= findArgById(vplArgName);
                                 if(null != vplArg)
                                 {
                                    modVpl.setParamByArg(words[0]/*paramName*/, vplArg);
                                 }
                                 else
                                 {
                                    throw CyArgNotFoundError getSrcLoc()+": vpl: arg \""+vplArgName+"\" not found";
                                 }
                              }
                              else
                              {
                                 modVpl.setParamByName(words[0]/*paramName*/, float(vplVal));
                              }
                              bTryMod = false;
                           }
                        }
                     }

                     if(bTryMod)
                     {
                        // Module
                        boolean bOpDone = false;

                        // && sin
                        if(words.numElements >= 2)
                        {
                           op = CyDefs.ParseOp(words[0] + words[1]);  // &&, ||, ^^, !&, !|, !^
                           if(-1 != op)
                           {
                              // <op> <modtype>
                              mod <= newMod(2/*typeWordIdx*/, indent, words[0]+words[1]/*op*/);
                              if(null != mod)
                                 mod.op = op;
                              bOpDone = true;
                           }
                        }

                        // + sin
                        if(!bOpDone)
                        {
                           op = CyDefs.ParseOp(words[0]);
                           if(-1 != op)
                           {
                              // <op> <modtype>
                              mod <= newMod(1/*typeWordIdx*/, indent, words[0]/*op*/);
                              if(null != mod)
                                 mod.op = op;
                              bOpDone = true;
                           }
                        }

                        // sin
                        if(!bOpDone)
                        {
                           // <modtype>
                           mod <= newMod(0/*typeWordIdx*/, indent, null/*op*/);
                        }

                        // (note) can be null in case of template instantiation
                        if(null != mod)
                        {
                           mod.parent_script <= this;
                           mod.indent = indent;
                           if(b_debug2) trace "xxx new mod="+#(mod)+" indent="+indent+" cur_input="+#(cur_input);

                           popInputsAfterIndent(indent);  // update cur_mod / cur_input

                           boolean bModAdded = false;

                           if(b_debug2) trace "xxx cur_mod="+#(cur_mod)+" newmod="+#(mod);

                           if(null != cur_mod)
                           {
                              if(b_debug2) trace "xxx indent="+indent+" cur_mod.indent="+cur_mod.indent;
                              if(indent > cur_mod.indent)
                              {
                                 // Nested
                                 if(b_debug2) trace "xxx ~~~~ add right newMod="+mod.getString()+"("+#(mod)+") indent="+indent+" cur_mod.indent="+cur_mod.indent;
                                 mod.seq_parent <= cur_mod;
                                 if(null != cur_mod.seq_right)
                                 {
                                    // (note) when first "module" in child sequence is a template invocation
                                    // (note) see "debug template seq_right" test patch
                                    trace "!!!!!!!!!!!!!!!!!!!!!!!! cur_mod.seq_right="+#(cur_mod.seq_right)+" !!!!!!!!!!!!!!!!!!!";
                                    CyModule mRightLast <= cur_mod.seq_right;
                                    while(null != mRightLast.seq_next)  // seek last module in sequence
                                       mRightLast <= mRightLast.seq_next;
                                    cur_mod.seq_next <= deref mod;
                                 }
                                 else
                                    cur_mod.seq_right <= deref mod;
                                 cur_mod <= mod;
                                 bModAdded = true;
                              }
                              else if(indent == cur_mod.indent)
                              {
                                 // Same level
                                 if(b_debug2) trace "xxx add next newMod="+mod.getString()+"("+#(mod)+"), indent="+indent+" cur_mod="+#(cur_mod);
                                 cur_mod.seq_next <= deref mod;
                                 mod.seq_parent <= cur_mod.seq_parent;
                                 cur_mod <= mod;
                                 bModAdded = true;
                              }
                              else
                              {
                                 // Previous level
                                 if(b_debug2) trace "xxx add prev level newMod="+mod.getString()+"("+#(mod)+"), indent="+indent+" cur_mod.indent="+((null != cur_mod)?cur_mod.indent:"n/a")+" cur_mod="+#(cur_mod);
                                 while((null != cur_mod) && (indent < cur_mod.indent))
                                 {
                                    // trace "xxx    find prev level cur_mod="+cur_mod.getString()+" cur_mod.indent="+cur_mod.indent+" cur_mod.seq_parent="+#(cur_mod.seq_parent);
                                    cur_mod <= cur_mod.seq_parent;
                                    // trace "xxx      cur_mod.seq_parent.seq_parent="+((null != cur_mod)?#(cur_mod.seq_parent):"n/a");
                                 }

                                 if(null != cur_mod)
                                 {
                                    if(b_debug2) trace "xxx add outer next newMod="+#(mod)+" cur_mod="+#(cur_mod)+" cur_mod.seq_parent="+#(cur_mod.seq_parent);
                                    cur_mod.seq_next <= deref mod;
                                    mod.seq_parent <= cur_mod.seq_parent;
                                    cur_mod <= mod;
                                    bModAdded = true;
                                 }
                              }
                           } // if null != cur_mod

                           if(!bModAdded)
                           {
                              if(null != cur_input)
                              {
                                 cur_input.addModule(deref mod);
                                 cur_mod <= mod;
                              }
                              else if(null != cur_lane)
                              {
                                 cur_lane.addModule(deref mod);
                                 cur_mod <= mod;
                              }
                              else
                              {
                                 throw CyNoInputError getSrcLoc()+": module declared outside of input or lane";
                              }
                           }

                        } // if mod

                     } // if bTryMod
                  }
               } // if !(cur_macro|cur_map|cur_arraydecl)
            } // if #words > 0
         } // if !comment
         else if(null != cur_template)
         {
            cur_template.addEmptyLine();  // [13Dec2024]
         }

         // Next line
         if(b_debug3)
            trace "xxx nextLine srcLoc="+getSrcLoc();
         cur_parse_context.nextLine();

      } // iterate lines

      if(b_have_plugin_id)
      {
         removeVarInternal("wt_x");
         removeVarInternal("wt_y");
         removeVarInternal("wt_freq");
      }

      optimizeCurveIndices();
   }

   // <method_parse.png>
   public method parseFile(String _pathName) : boolean {
      local String s;

      // Load script and parse it
      if(s.loadLocal(_pathName, true/*bRemoveCR*/))
      {
         try
         {
            parseString(s);
            return true;
         }
         catch(CyError e)
         {
            trace "[---] CyScript: caught exception e.name=\""+e.name+"\" e.msg=\""+e.message+"\"";
            trace e.stackTrace;
            return false;
         }
      }
      else
      {
         trace "[---] CyScript: failed to open input file \""+_pathName+"\"";
      }
      return false;
   }

   // <method.png>
   public method setTmpVarContext(String _name) {
      // e.g. "Init", "WT_Init", "Calc", "Calc_Cycle" (function names)
      if(b_debug0) trace "[trc] CyScript::setTmpVarContext(name=\""+_name+"\")";
      tmp_var_context = _name;
      s_tmp_var_decl.empty();
   }

   // <method_find.png>
   protected method allocUnusedTmpVar(PointerArray _vars, String _suffix) : CyTmpVar {
      CyTmpVar *tvar;
      foreach tvar in _vars
      {
         if(!tvar.b_used)
         {
            if(tvar.context == tmp_var_context)
            {
               tvar.comment = _suffix;
               tvar.b_used  = true;
               return tvar;
            }
         }
      }
      return null;
   }

   // <method.png>
   protected method freeTmpVarEx(PointerArray _vars, String _sVar) {
      int idxSuffix = _sVar.indexOf("/*", 0);
      local String *sVar;
      if(idxSuffix >= 0)
         sVar <= _sVar.substring(0, idxSuffix);  // strip /*comment*/
      else
         sVar <= _sVar;
      if(b_plugin)
      {
         int idxVoice = sVar.indexOf("->", 0);
         if(idxVoice >= 0)
            sVar <= sVar.substring(idxVoice+2, 99);  // strip "voice->"
      }

      CyTmpVar *tvar;
      foreach tvar in _vars
      {
         if(tvar.b_used)
         {
            if(tvar.context == tmp_var_context)
            {
               if(tvar.name == sVar)
               {
                  tvar.b_used  = false;
                  tvar.comment = "";
                  return;
               }
            }
         }
      }

      // Should not be reachable
      trace "[!!!] CyScript::freeTmpVarEx: failed to free tmp var \""+_sVar+"\" (context=\""+tmp_var_context+"\")";
      Utils.Backtrace();
   }

   // <method.png>
   public method allocAddSRConstVarFloat(float _f) : String {
      int idx = add_sr_constants.indexOf(_f, 0);
      if(idx < 0)
      {
         idx = add_sr_constants.numElements;
         add_sr_constants.add(_f);
         s_sr_decl.append("   float add_sr_"+idx+";  // "+FloatToString(_f)+"\n");
         s_sr_changed.append("      voice->add_sr_"+idx+" = voice->sr_factor * "+FloatToString(_f)+";\n");
         b_use_sr_factor = true;
      }
      return "voice->add_sr_"+idx;
   }

   // <method.png>
   public method allocAddSRConstVarInt(int _i) : String {
      int idx = add_sr_constants_int.indexOf(_i, 0);
      if(idx < 0)
      {
         idx = add_sr_constants_int.numElements;
         add_sr_constants_int.add(_i);
         s_sr_decl.append("   short add_sr_"+idx+"_i;  // "+_i+" ("+FloatToString(float(_i) / FX_ONE)+")\n");
         s_sr_changed.append("      voice->add_sr_"+idx+"_i = ("+short_type+") (voice->sr_factor * "+_i+");\n");
         b_use_sr_factor = true;
      }
      return "voice->add_sr_"+idx+"_i";
   }

   // <method.png>
   public method allocMulSRConstVarFloat(float _f) : String {
      int idx = mul_sr_constants.indexOf(_f, 0);
      if(idx < 0)
      {
         idx = mul_sr_constants.numElements;
         mul_sr_constants.add(_f);
         s_sr_decl.append("   float mul_sr_"+idx+";  // "+FloatToString(_f)+"\n");
         s_sr_changed.append("      voice->mul_sr_"+idx+" = powf("+FloatToString(_f)+", voice->sr_factor);\n");
         b_use_sr_factor = true;
      }
      return "voice->mul_sr_"+idx;
   }

   // <method.png>
   public method allocMulSRConstVarInt(int _i) : String {
      int idx = mul_sr_constants_int.indexOf(_i, 0);
      if(idx < 0)
      {
         idx = mul_sr_constants_int.numElements;
         mul_sr_constants_int.add(_i);
         s_sr_decl.append("   short mul_sr_"+idx+"_i;  // "+_i+" ("+FloatToString(_i / FX_ONE)+")\n");
         s_sr_changed.append("      voice->mul_sr_"+idx+"_i = (short)powf((float)"+_i+", voice->sr_factor);\n");
         b_use_sr_factor = true;
      }
      else
      {
         return "voice->mul_sr_"+idx+"_i";
      }
   }

   // <method.png>
   public method evalAddSRInput(local CyInput _in, local String _out, local String _tmpVar) : String {
      // evaluate sample-rate independent input used for weighted add (e.g. CyModuleSlw)
      //   (note) 'tmpVar' may be initially empty and will be allocated on demand (must be freed by caller)
      //   (note) returns const val or (allocated) tmpVar
      local String *sScl;
      if(_in.isConstVal())
      {
         if(b_plugin)
         {
            sScl <= allocAddSRConstVarFloat(_in.getConstVal());
         }
         else
         {
            sScl <= FloatToString(_in.getConstVal() * (1.0f / oversample_factor));
         }
      }
      else
      {
         _tmpVar = allocTmpVar(_out, "addsr_"+_in.id);
         _in.emitFloat(this, _out, _tmpVar);

         if(b_plugin)
         {
            _out.append(_tmpVar+" *= voice->sr_factor;\n");
            b_use_sr_factor = true;
         }
         else
         {
            if(oversample_factor > 1)
               _out.append(_tmpVar+" *= "+FloatToString(1.0f / oversample_factor)+"/*oversample_factor*/;\n");
         }
         sScl <= deref _tmpVar;
      }
      return deref sScl;
   }

   // <method.png>
   public method evalAddSRInputInt(local CyInput _in, local String _out, local String _tmpVar) : String {
      // evaluate sample-rate independent input used for weighted add (e.g. CyModuleSlw)
      //   (note) 'tmpVar' may be initially empty and will be allocated on demand (must be freed by caller)
      //   (note) not actually supported in integer lo-fi mode (fxn is just used for compatibility purposes)
      //   (note) returns const val or (allocated) tmpVar
      local String *sScl;
      if(_in.isConstVal())
      {
         sScl <= String(int(FX_ONE * (_in.getConstVal() * (1.0f / oversample_factor))));
      }
      else
      {
         _tmpVar = allocTmpVar(_out, "addsr_"+_in.id);
         _in.emitInt(this, _out, _tmpVar);

         if(oversample_factor > 1)
            _out.append(_tmpVar+" = Dmulsw_shr("+_tmpVar+", "+int(FX_ONE * (1.0f / oversample_factor))+"/*oversample_factor*/);\n");

         sScl <= deref _tmpVar;
      }
      return deref sScl;
   }

   // <method.png>
   public method evalMulSRInput(local CyInput _in, local String _out, local String _tmpVar) : String {
      // evaluate sample-rate independent input used for weighted mul (e.g. CyModuleSpr)
      //   (note) 'tmpVar' may be initially empty and will be allocated on demand (must be freed by caller)
      local String *sScl;
      if(_in.isConstVal())
      {
         // trace "xxx evalMulSRInput: isConstVal";
         if(b_plugin)
            sScl <= allocMulSRConstVarFloat(_in.getConstVal());
         else if(oversample_factor > 1)
            sScl <= FloatToString(mathPowerf(_in.getConstVal(), (1.0f / oversample_factor)));
         else
            sScl <= FloatToString(_in.getConstVal());
         // trace "xxx evalMuLSRInput: sScl=\""+sScl+"\"";
      }
      else
      {
         _tmpVar = allocTmpVar(_out, "mulsr_"+_in.id);
         _in.emitFloat(this, _out, _tmpVar);
         trace "xxx tmpVar=\""+_tmpVar+"\"";

         if(b_plugin)
         {
            _out.append(_tmpVar+" = powf("+_tmpVar+", voice->sr_factor);\n");
            b_use_sr_factor = true;
         }
         else
         {
            _out.append(_tmpVar+" = mathPowerf("+_tmpVar+", "+FloatToString(1.0f / oversample_factor)+");\n");
         }
         sScl <= deref _tmpVar;
      }
      return deref sScl;
   }

   // <method.png>
   public method allocTmpVar(String _out, String _suffix) : String {
      local String sVar;

      // Try to re-use previously freed tmp var (from same tmp_var_context)
      CyTmpVar tvar <= allocUnusedTmpVar(tmp_vars_float, _suffix);
      boolean bAllocVar = (null == tvar);
      if(bAllocVar)
      {
         // Allocate new tmp var
         tvar <= new CyTmpVar;
         tvar.name    = "tmp"+String(++next_tmp_var_idx);
         tvar.comment = _suffix;
         tvar.context = tmp_var_context;
         tvar.b_used  = true;
         tmp_vars_float.add(#(deref tvar));
      }

      if(bAllocVar)
      {
         if(b_plugin)
            s_var_decl.append("   float "+tvar.name+";\n");
         else
            _out.append("float "+tvar.name+";\n");
      }

      if(null != _suffix)
         sVar <= tvar.name+"/*"+_suffix+"*/";
      else
         sVar <= tvar.name;

      if(b_plugin)
         return "voice->"+sVar;
      else
         return deref sVar;
   }

   // <method.png>
   public method calcTmpVarInputMillisecToFrames(local String _out, local String _sVar, local CyInput _inMS) : String {
      _inMS.emitFloat(this, _out, _sVar);
      if(b_plugin)
      {
         _out.append("#ifdef OVERSAMPLE_FACTOR\n");
         _out.append(_sVar+" = "+_sVar+" * ((voice->sample_rate * OVERSAMPLE_FACTOR) * (1.0f / 1000.0f));\n");
         _out.append("#else // OVERSAMPLE_FACTOR\n");
         _out.append(_sVar+" = "+_sVar+" * (voice->sample_rate * (1.0f / 1000.0f));\n");
         _out.append("#endif // OVERSAMPLE_FACTOR\n");
      }
      else
         _out.append(_sVar+" = "+_sVar+" * "+FloatToString((sample_rate * oversample_factor) * (1.0f / 1000.0f))+";\n");
      // Clip minimum duration to 1 sample frame
      _out.append("if("+_sVar+" < 1.0f)\n");
      _out.append("   "+_sVar+" = 1.0f;\n");
   }

   // <method.png>
   public method calcTmpVarIntInputMillisecToFrames(local String _out, local String _sVar, local CyInput _inMS) : String {
      if(_inMS.isConstVal())
      {
         float fMS = _inMS.getConstVal();
         _out.append(_sVar+" = ("+int(fMS)+" * "+int(sample_rate * (4.0f / 1000.0f))+") >> 2;\n");
      }
      else
      {
         _inMS.emitInt(this, _out, _sVar);
         _out.append(_sVar+" = (("+_sVar+">>("+(FX_SHR-2)+") * "+int(sample_rate * (4.0f / 1000.0f))+") >> 4;\n");
      }
      // Clip minimum duration to 1 sample frame
      _out.append("if("+_sVar+" < "+int(1)+")\n");
      _out.append("   "+_sVar+" = "+int(1)+";\n");
   }

   // <method.png>
   public method calcTmpVarInputHzToFrames(local String _out, local String _sVar, local CyInput _inHz) {
      // eval input and convert Hz to sample frames
      // (todo) const opt (although: compiler will do that, anyway)
      _inHz.emitFloat(this, _out, _sVar);
      _out.append("if("+_sVar+" > 0.0f)\n");
      _out.append("{\n");
      if(b_plugin)
      {
         _out.append("#ifdef OVERSAMPLE_FACTOR\n");
         _out.append("   "+_sVar+" = (voice->sample_rate * OVERSAMPLE_FACTOR) / "+_sVar+";\n");
         _out.append("#else // OVERSAMPLE_FACTOR\n");
         _out.append("   "+_sVar+" = voice->sample_rate / "+_sVar+";\n");
         _out.append("#endif // OVERSAMPLE_FACTOR\n");
      }
      else
         _out.append("   "+_sVar+" = "+FloatToString(sample_rate * oversample_factor)+" / "+_sVar+";\n");
      _out.append("}\n");
      _out.append("else "+_sVar+" = 1.0f;\n");
   }

   // <method.png>
   public method calcTmpVarIntInputHzToFrames(local String _out, local String _sVar, local CyInput _inHz) {
      // eval input and convert Hz to sample frames
      // (todo) const opt (although: compiler will do that, anyway)
      _inHz.emitInt(this, _out, _sVar);
      _out.append("if("+_sVar+" > 0)\n");
      _out.append("{\n");
      // (todo) rcp (avoid div)
      _out.append("   "+_sVar+" = "+int(sample_rate)+" / "+_sVar+";\n");
      _out.append("}\n");
      _out.append("else "+_sVar+" = 1;\n");
   }

   // <method.png>
   public method calcTmpVarInputBPMToFrames(local String _out, local String _sVar, local CyInput _inBPM) {
      if(_inBPM.isConstVal())
      {
         float fBPM = _inBPM.getConstVal();
         if(fBPM <= 1.0f)
            fBPM = current_project.bpm;
         float fHz  = (fBPM / 60.0f);
         if(b_plugin)
         {
            _out.append("#ifdef OVERSAMPLE_FACTOR\n");
            _out.append(_sVar+" = (voice->sample_rate * OVERSAMPLE_FACTOR) / "+FloatToString(fHz)+";\n");
            _out.append("#else // OVERSAMPLE_FACTOR\n");
            _out.append(_sVar+" = voice->sample_rate / "+FloatToString(fHz)+";\n");
            _out.append("#endif // OVERSAMPLE_FACTOR\n");
         }
         else
         {
            // Script eval or sample-calc C export
            _out.append(_sVar+" = "+FloatToString( (sample_rate * oversample_factor) / fHz )+";\n");
         }
      }
      else
      {
         _inBPM.emitFloat(this, _out, _sVar);
         _out.append("if("+_sVar+" <= 0.0f)\n");
         // host bpm
         _out.append("   "+_sVar+" = (voice->bpm > 0.0f) ? voice->bpm : 125.0f;\n");
         _out.append(_sVar+" *= (1.0f / 60.0f);\n");  // to Hz
         if(b_plugin)
         {
            _out.append("#ifdef OVERSAMPLE_FACTOR\n");
            _out.append(_sVar+" = (voice->sample_rate * OVERSAMPLE_FACTOR) / "+_sVar+";\n");
            _out.append("#else // OVERSAMPLE_FACTOR\n");
            _out.append(_sVar+" = voice->sample_rate / "+_sVar+";\n");
            _out.append("#endif // OVERSAMPLE_FACTOR\n");
         }
         else
         {
            // Script eval or sample-calc C export
            _out.append(_sVar+" = "+FloatToString(sample_rate * oversample_factor)+" / "+_sVar+";\n");
         }
      }
   }

   // <method.png>
   public method calcTmpVarIntInputBPMToFrames(local String _out, local String _sVar, local CyInput _inBPM) {
      // (note) returns integer num frames (not fixed point)
      float fBPM;
      if(_inBPM.isConstVal())
      {
         fBPM = _inBPM.getConstVal();
         if(fBPM <= 1.0f)
            fBPM = current_project.bpm;
         float fHz  = (fBPM / 60.0f);
         // Script eval or sample-calc C export
         _out.append(_sVar+" = "+int((sample_rate * oversample_factor) / fHz)+"; // const BPM. sr="+sample_rate+" fBPM="+fBPM+"\n");
      }
      else
      {
         _inBPM.emitInt(this, _out, _sVar);
         _out.append("if("+_sVar+" <= 0)\n");
         _out.append("   "+_sVar+" = "+int(FX_ONE * 125.0f)+";\n");  // host voice->bpm (not available)
         _out.append(_sVar+" = Dmulsw_shr("+_sVar+", "+int(FX_ONE / 60.0f)+");\n");  // to Hz
         // Script eval or sample-calc C export
         // (todo) rcp (avoid div)
         _out.append(_sVar+" = "+int(sample_rate * oversample_factor)+" / ("+_sVar+" >> "+FX_SHR+");\n");
      }

   }

   // <method.png>
   public method freeTmpVar(String _sVar) {
      freeTmpVarEx(tmp_vars_float, _sVar);
   }

   // <method.png>
   public method allocTmpVarInitVoice(String _out, String _suffix, float _val, boolean _bCycleReset, boolean _bVoiceReset) : String {
      local String *sVar;
      if(null != _suffix)
         sVar <= "tmp"+String(++next_tmp_var_idx)+"_"+_suffix;
      else
         sVar <= "tmp"+String(++next_tmp_var_idx);
      // trace "xxx allocTmpVarInit: suffix=\""+_suffix+"\" sVar=\""+sVar+"\"";
      if(_bCycleReset)
      {
         if(b_plugin)
            s_var_decl.append("   float "+sVar+";\n");
         else
            s_tmp_var_decl.append("   float "+sVar+" = "+FloatToString(_val)+";\n");
         if(b_plugin)
            s_cycle_reset.append("      voice->"+sVar+" = "+FloatToString(_val)+";\n");
         else
            s_cycle_reset.append("   "+sVar+" = "+FloatToString(_val)+";\n");
      }
      else if(!_bVoiceReset)
      {
         if(b_plugin)
            s_var_decl.append("   float "+sVar+";\n");
         else
            s_tmp_var_decl.append("   float "+sVar+" = "+FloatToString(_val)+";\n");
         if(b_plugin)
            s_alloc_reset.append("      voice->"+sVar+" = "+FloatToString(_val)+";\n");
         else
            s_alloc_reset.append("   "+sVar+" = "+FloatToString(_val)+";\n");
      }
      else
      {
         // Global var that spans multiple cycles
         if(!export_c_prefix.isBlank())
            sVar.append("_"+export_c_prefix);
         if(b_plugin)
            s_var_decl.append("   ");
         s_var_decl.append("float "+sVar+";\n");
         if(b_plugin)
            s_global_reset.append("      voice->"+sVar+" = "+FloatToString(_val)+";\n");
         else
            s_global_reset.append("   "+sVar+" = "+FloatToString(_val)+";\n");
      }
      if(b_plugin)
         return "voice->"+sVar;
      else
         return deref sVar;
   }

   // <method.png>
   public method allocTmpVarInit(String _out, String _suffix, float _val, boolean _bCycleReset) : String {
      return allocTmpVarInitVoice(_out, _suffix, _val, _bCycleReset, true/*bVoiceReset*/);
   }

   // <method.png>
   public method allocTmpVarInt(String _out, String _suffix) : String {

      // Try to re-use previously freed tmp var (from same tmp_var_context)
      CyTmpVar tvar <= allocUnusedTmpVar(tmp_vars_int, _suffix);
      boolean bAllocVar = (null == tvar);
      // trace "xxx allocTmpVarInt(suffix=\""+_suffix+"\") bAllocVar="+bAllocVar+" (tvar="+((null != tvar)?tvar.name:"<null>")+")";
      if(bAllocVar)
      {
         // Allocate new tmp var
         tvar <= new CyTmpVar;
         tvar.name    = "tmp"+String(++next_tmp_var_idx);
         tvar.comment = _suffix;
         tvar.context = tmp_var_context;
         tvar.b_used  = true;
         tmp_vars_int.add(#(deref tvar));
      }

      if(bAllocVar)
      {
         if(b_plugin)
            s_var_decl.append("   "+short_type+" "+tvar.name+";\n");
         else
            s_tmp_var_decl.append("   "+short_type+" "+tvar.name+";\n");
      }

      local String *sVar;
      if(null != _suffix)
         sVar <= tvar.name+"/*"+_suffix+"*/";
      else
         sVar <= tvar.name;

      if(b_plugin)
         return "voice->"+sVar;
      else
         return deref sVar;
   }

   // <method.png>
   public method freeTmpVarInt(String _sVar) {
      // trace "xxx freeTmpVarInt(sVar=\""+_sVar+"\")";
      freeTmpVarEx(tmp_vars_int, _sVar);
   }

   // // // <method.png>
   // // public method allocTmpVarInt32(String _out, String _suffix) : String {
   // //    local String *sVar;
   // //    if(null != _suffix)
   // //       sVar <= "tmp"+String(++next_tmp_var_idx)+"_"+_suffix;
   // //    else
   // //       sVar <= "tmp"+String(++next_tmp_var_idx);
   // //    s_tmp_var_decl.append("int "+sVar+";\n");
   // //    return deref sVar;
   // // }

   // <method.png>
   public method allocTmpVarInt32(String _out, String _suffix) : String {

      // Try to re-use previously freed tmp var (from same tmp_var_context)
      CyTmpVar tvar <= allocUnusedTmpVar(tmp_vars_int32, _suffix);
      boolean bAllocVar = (null == tvar);
      // trace "xxx allocTmpVarInt(suffix=\""+_suffix+"\") bAllocVar="+bAllocVar+" (tvar="+((null != tvar)?tvar.name:"<null>")+")";
      if(bAllocVar)
      {
         // Allocate new tmp var
         tvar <= new CyTmpVar;
         tvar.name    = "tmp"+String(++next_tmp_var_idx);
         tvar.comment = _suffix;
         tvar.context = tmp_var_context;
         tvar.b_used  = true;
         tmp_vars_int32.add(#(deref tvar));
      }

      if(bAllocVar)
      {
         if(b_plugin)
            s_var_decl.append("   int "+tvar.name+";\n");
         else
            s_tmp_var_decl.append("   int "+tvar.name+";\n");
      }

      local String *sVar;
      if(null != _suffix)
         sVar <= tvar.name+"/*"+_suffix+"*/";
      else
         sVar <= tvar.name;

      if(b_plugin)
         return "voice->"+sVar;
      else
         return deref sVar;
   }

   // <method.png>
   public method freeTmpVarInt32(String _sVar) {
      // trace "xxx freeTmpVarInt32(sVar=\""+_sVar+"\")";
      freeTmpVarEx(tmp_vars_int32, _sVar);
   }

   // <method.png>
   public method allocTmpVarIntInitVoice(String _out, String _suffix, int _val, boolean _bCycleReset, boolean _bVoiceReset) : String {
      local String *sVar;
      if(null != _suffix)
         sVar <= "tmp"+String(++next_tmp_var_idx)+"_"+_suffix;
      else
         sVar <= "tmp"+String(++next_tmp_var_idx);

      if(_bCycleReset)
      {
         if(b_plugin)
            s_var_decl.append("   "+short_type+" "+sVar+";\n");
         else
            _out.append(short_type+" "+sVar+" = "+_val+";\n");
         if(b_plugin)
            s_cycle_reset.append("      voice->"+sVar+" = "+_val+";\n");
         else
            s_cycle_reset.append("   "+sVar+" = "+_val+";\n");

         // if(b_plugin)
         // {
         //    s_var_decl.append(short_type+" "+sVar+";\n");
         //    s_cycle_reset.append("      voice->"+sVar+" = "+_val+";\n");
         // }
         // else
         // {
         //    _out.append(short_type+" "+sVar+" = "+_val+";\n");
         //    s_cycle_reset.append("   "+sVar+" = "+_val+";\n");
         // }
      }
      else if(!_bVoiceReset)
      {
         if(b_plugin)
            s_var_decl.append("   "+short_type+" "+sVar+";\n");
         else
            _out.append(short_type+" "+sVar+" = "+_val+";\n");
         if(b_plugin)
            s_alloc_reset.append("      voice->"+sVar+" = "+_val+";\n");
         else
            s_alloc_reset.append("   "+sVar+" = "+_val+";\n");
      }
      else
      {
         // Global var that spans multiple cycles
         if(!export_c_prefix.isBlank())
            sVar.append("_"+export_c_prefix);
         if(b_plugin)
            s_var_decl.append("   ");
         s_var_decl.append(short_type+" "+sVar+";\n");
         if(b_plugin)
            s_global_reset.append("      voice->"+sVar+" = "+_val+";\n");
         else
            s_global_reset.append("   "+sVar+" = "+_val+";\n");
      }
      if(b_plugin)
         return "voice->"+sVar;
      else
         return deref sVar;
   }

   // <method.png>
   public method allocTmpVarIntInit(String _out, String _suffix, int _val, boolean _bCycleReset) : String {
      return allocTmpVarIntInitVoice(_out, _suffix, _val, _bCycleReset, true/*bVoiceReset*/);
   }

   // <method.png>
   public method allocTmpVarInt32Init(String _out, String _suffix, int _val, boolean _bCycleReset, boolean _bVoiceReset) : String {
      local String *sVar;
      if(null != _suffix)
         sVar <= "tmp"+String(++next_tmp_var_idx)+"_"+_suffix;
      else
         sVar <= "tmp"+String(++next_tmp_var_idx);
      if(_bCycleReset)
      {
         _out.append("int "+sVar+";\n");
         if(b_plugin)
         {
            s_var_decl.append("   int "+sVar+";\n"); //// = "+_val+";\n");
            s_cycle_reset.append("      voice->"+sVar+" = "+_val+";\n");
            s_alloc_reset.append("      voice->"+sVar+" = "+_val+";\n");
         }
         else
         {
            s_var_decl.append("int "+sVar+";\n");
            s_cycle_reset.append("   "+sVar+" = "+_val+";\n");
            s_alloc_reset.append("      "+sVar+" = "+_val+";\n");
         }
      }
      else if(!_bVoiceReset)
      {
         if(b_plugin)
         {
            s_var_decl.append("   int "+sVar+";\n");
            s_alloc_reset.append("      voice->"+sVar+" = "+_val+";\n");
         }
         else
         {
            s_var_decl.append("int "+sVar+";\n");
            s_alloc_reset.append("   "+sVar+" = "+_val+";\n");
         }
      }
      else
      {
         // Global var that spans multiple cycles
         if(!export_c_prefix.isBlank())
            sVar.append("_"+export_c_prefix);
         if(b_plugin)
         {
            s_var_decl.append("   int "+sVar+";\n");
            s_global_reset.append("      voice->"+sVar+" = "+_val+";\n");
         }
         else
         {
            s_var_decl.append("int "+sVar+";\n");
            s_global_reset.append("   "+sVar+" = "+_val+";\n");
         }
      }
      if(b_plugin)
         return "voice->"+sVar;
      else
         return deref sVar;
   }

   // <method.png>
   public method allocTmpVarUInt16Init(String _out, String _suffix,
                                       int _val, boolean _bMultiplyValByVoiceIdx,
                                       boolean _bCycleReset,
                                       boolean _bVoiceReset
                                       ) : String {
      local String *sVar;
      if(null != _suffix)
         sVar <= "tmp"+String(++next_tmp_var_idx)+"_"+_suffix;
      else
         sVar <= "tmp"+String(++next_tmp_var_idx);
      if(_bCycleReset)
      {
         if(b_plugin)
         {
            s_var_decl.append("   unsigned short "+sVar+";\n");
            s_cycle_reset.append("      voice->"+sVar+" = "+_val+(_bMultiplyValByVoiceIdx?" * (voice->base.voice_idx + 1u)":"")+";\n");
         }
         else
         {
            if(b_export_c)/////!export_c_prefix.isBlank())
               s_tmp_var_decl.append("   unsigned short "+sVar+";\n");
            else
               s_tmp_var_decl.append("   UnsignedShort "+sVar+" = "+_val+";\n");
            s_cycle_reset.append("   "+sVar+" = "+_val+";\n");
         }
      }
      else if(!_bVoiceReset)
      {
         if(b_plugin)
         {
            s_var_decl.append("   unsigned short "+sVar+";\n");
            s_alloc_reset.append("      voice->"+sVar+" = "+_val+(_bMultiplyValByVoiceIdx?" * (_voiceIdx + 1u)":"")+";\n");
         }
         else
         {
            if(b_export_c)/////!export_c_prefix.isBlank())
               s_tmp_var_decl.append("   unsigned short "+sVar+";\n");
            else
               s_tmp_var_decl.append("   UnsignedShort "+sVar+" = "+_val+";\n");
            s_alloc_reset.append("   "+sVar+" = "+_val+";\n");
         }
      }
      else
      {
         // Global var that spans multiple cycles
         if(b_export_c)
         {
            if(!export_c_prefix.isBlank())
               sVar.append("_"+export_c_prefix);
            if(b_plugin)
               s_var_decl.append("   ");
            s_var_decl.append("unsigned short "+sVar+";\n");
         }
         else
            s_var_decl.append("UnsignedShort "+sVar+";\n");
         if(b_plugin)
            s_global_reset.append("   voice->"+sVar+" = "+_val+(_bMultiplyValByVoiceIdx?" * (voice->base.voice_idx + 1u)":"")+";\n");
         else
            s_global_reset.append("   "+sVar+" = "+_val+";\n");
      }
      if(b_plugin)
         return "voice->"+sVar;
      else
         return deref sVar;
   }

   // <method.png>
   public method allocTmpVarInt16Init(String _out, String _suffix, int _val, boolean _bCycleReset) : String {
      local String *sVar;
      if(null != _suffix)
         sVar <= "tmp"+String(++next_tmp_var_idx)+"_"+_suffix;
      else
         sVar <= "tmp"+String(++next_tmp_var_idx);
      if(_bCycleReset)
      {
         if(b_plugin)
         {
            s_var_decl.append("   short "+sVar+";\n");
            s_cycle_reset.append("      voice->"+sVar+" = "+_val+";\n");
         }
         else
         {
            if(b_export_c)/////!export_c_prefix.isBlank())
               s_tmp_var_decl.append("   short "+sVar+";\n");
            else
               s_tmp_var_decl.append("   Short "+sVar+" = "+_val+";\n");
            s_cycle_reset.append("   "+sVar+" = "+_val+";\n");
         }
      }
      else
      {
         // Global var that spans multiple cycles
         if(b_export_c)////!export_c_prefix.isBlank())
         {
            sVar.append("_"+export_c_prefix);
            if(b_plugin)
               s_var_decl.append("   ");
            s_var_decl.append("short "+sVar+";\n");
         }
         else
            s_var_decl.append("Short "+sVar+";\n");
         if(b_plugin)
            s_global_reset.append("      voice->"+sVar+" = "+_val+";\n");
         else
            s_global_reset.append("   "+sVar+" = "+_val+";\n");
      }
      if(b_plugin)
         return "voice->"+sVar;
      return deref sVar;
   }

   // <method.png>
   public method addArrayVar(String _sPrefix, int _size, boolean _bInt) : String {
      // (note) see CyModuleDly
      local String *sVar <= "arr"+(num_array_vars++)+"_"+_sPrefix;
      if(b_export_c)
      {
         sVar <= export_c_prefix+sVar;
         if(b_plugin)
         {
            s_var_decl.append("   "+(_bInt?"short":"float")+" "+sVar+"["+_size+"];\n");
            s_cycle_reset.append("      memset(&voice->"+sVar+", 0, sizeof(voice->"+sVar+"));\n");
         }
         else
         {
            s_var_decl.append((_bInt?"short":"float")+" "+sVar+"["+_size+"];\n");
            s_cycle_reset.append("      memset(&"+sVar+", 0, sizeof("+sVar+"));\n");
         }
      }
      else
      {
         s_var_decl.append((_bInt?"IntArray":"FloatArray")+" "+sVar+"; "+sVar+".allocAndFill("+_size+", 0);\n");
      }
      if(b_plugin)
         return "voice->"+sVar;
      return deref sVar;
   }

   // <method.png>
   public method appendInit(String _s) {
      s_init.append(_s);
   }

   // <method.png>
   public method allocVoiceBus(String _sBusNr, boolean _bFloatNr) : String {
      int busId = next_voicebus_id++;
      local String sSamplesBus <= "samplesBus"+busId;
      s_var_decl.append("   unsigned int voicebus_idx_"+busId+";\n");
      s_voicebus_indices.append("   Dstplugin_voicebus"+(_bFloatNr?"_f":"_i")+"(voice->voicebus_idx_"+busId+", "+_sBusNr+");\n");
      s_voicebus_ptrs.append("   float *"+sSamplesBus+" = voice->base.voice_bus_buffers[voice->voicebus_idx_"+busId+"] + voice->base.voice_bus_read_offset;\n");
      return deref sSamplesBus;
   }

   // <method.png>
   public method millisecToFrames(float _ms, boolean _bCycle) : float {
      if(_ms < 1.0)
      {
         // special case 0=all
         if(_bCycle)
            return num_frames * oversample_factor;        // single cycle
         else
            return total_num_frames * oversample_factor;  // all cycles
      }
      return (sample_rate * oversample_factor * _ms) / 1000.0f;
   }

   // <method_find.png>
   protected method findLaneById(String _id) : CyLane {
      CyLane *lane;
      foreach lane in lanes
      {
         if(lane.id == _id)
            return lane;
      }
      return null;
   }

   // <method.png>
   protected method emitCalcWinHSE(String _sOut) {
      if(b_export_c)
      {
         _sOut.append("\nvoid cycle_calc_win_hse(float *_tbl, float _exp) {\n");
         _sOut.append("   unsigned int a = 0u;\n");
         _sOut.append("   loop(8192)\n");
         _sOut.append("   {\n");
         _sOut.append("      float f = cycle_sine_tbl_f[a];\n");
         _sOut.append("      _tbl[a++] = powf(f, _exp);\n");
         _sOut.append("   }\n");
         _sOut.append("}\n");
      }
      else
      {
         _sOut.append("\nfunction cycle_calc_win_hse(FloatArray _tbl, float _exp) {\n");
         _sOut.append("   float a = 0.0f;\n");
         _sOut.append("   int k = 0;\n");
         _sOut.append("   loop(8192)\n");
         _sOut.append("   {\n");
         _sOut.append("     _tbl[k++] = mathPowerf(sin(a), _exp);\n");
         _sOut.append("     a += (2PI / 16384.0f);\n");
         _sOut.append("   }\n");
         _sOut.append("}\n");
      }
   }

   // <method.png>
   public method emitFloat(String _out, int _loopOffset,
                           String _exportCCallBuf,
                           String _exportCStaticInit,
                           int    _exportCFrameOffset,
                           int    _exportCFrameNum,
                           Sample _exportCSample
                           ) : boolean {

      if(b_plugin && plugin_id.isBlank())
         return false;

      b_export_c_no_static = false;

      boolean bFirstPatch = b_plugin || _out.isBlank();

      b_lofi = false;
      b_stereo = false;

      if(b_export_c && !b_plugin)
         oversample_factor = 1.0;

      if(b_plugin)
         b_use_sr_factor = true;  // always calc voice->sr_factor (e.g. for xinc extensions)

      short_type  <= b_export_c ? "short" : "Short";
      ushort_type <= b_export_c ? "unsigned short" : "int";
      uint_type   <= b_export_c ? "unsigned int" : "int";

      clamp_fun   <= b_export_c ? "clamp" : "mathClampf";

      // (note) _loopOffset is (firstLoopOff - lastLoopOff)
      updateNoteFreq();

      next_ext_instance_nr = 0;
      s_ext_pre   .empty();
      s_ext_static.empty();
      s_ext_init  .empty();
      s_ext_new   .empty();
      s_ext_delete.empty();
      s_ext_noteon.empty();
      s_ext_voice .empty();

      if(b_debug1)
         trace "xxx xfade: loopOffset="+_loopOffset+" num_skip_frames="+num_skip_frames;
      int maxXFadeFrames = _loopOffset + num_skip_frames;
      if(xfade_percent > 0.0)
         xfade_frames = maxXFadeFrames * xfade_percent;
      xfade_frames = mathClampi(xfade_frames, 0, mathMini(maxXFadeFrames, MAX_XFADE_FRAMES));

      next_tmp_var_idx = 0;
      next_template_var_idx = 0;
      s_var_decl.empty();
      s_init.empty();
      s_cycle_reset.empty();

      local String      sInitMain;  // for vpl noteon
      local String      sHeader;
      local String      sStaticInit;
      local String      sPluginParamDefs;
      local String      sPluginParamNames;
      local String      sPluginParamResets;
      local StringArray aPluginParamGroupNames;
      local IntArray    aPluginParamGroupIndices;
      local StringArray aPluginParamSectionNames;
      local IntArray    aPluginParamSectionIndices;
      local String      sPluginModDefs;
      local String      sPluginModNames;
      local String      sPluginModCurIncDecl;
      local String      sPluginVarDecls;
      local String      sPluginVarReset;
      local String      sPluginInitDecl;
      local String      sPluginInitCall;
      local String      sPluginPrepareBlockModVars;
      local String      sPluginPrepareBlockLerp;
      local String      sPluginPrepareBlockInit;
      local String      sPluginPrepareVarFirst;
      local String      sPluginPrepareVarNext;
      local String      sPluginProcessWTInit;
      local String      sPluginProcessCalc;
      local String      sPluginProcessIncCur;
      local String      sPluginCallLUTVoice;
      local String      sCallLUTShared;
      local String      sPluginQueryPresetValues;
      local String      sPluginQueryPresetName;
      local String      sPluginGetArrayParamSize;
      local String      sPluginGetArrayParamNumVariations;
      local String      sPluginGetArrayParamVariationPtr;
      local String      sPluginArrayParamVoiceNoteOn;
      local String      sPluginArrayParamSharedInit;
      local String      sPluginArrayParamPrepareBlock;
      local String      sPluginSetArrayParamEditVariationIdx;
      local String      sPluginGetArrayParamElementValueRange;
      local String      sPluginGetArrayParamElementName;
      local String      sPluginGetArrayParamElementReset;
      local String      sPluginUpdateLUTCases;
      if(b_plugin)
      {
         if(plugin_id.isBlank())
         {
            Global.Error("Missing plugin \"id\"");
         }
         if(plugin_name.isBlank())
         {
            if(Configuration.debugLevel > 1)
               trace "[~~~] CyScript::emitFloat: missing plugin \"name\", using id=\""+plugin_id+"\"";
            plugin_name = plugin_id;
         }
         if(plugin_category.isBlank())
         {
            if(Configuration.debugLevel > 1)
               trace "[~~~] CyScript::emitFloat: missing plugin \"cat\", using default category \"osc\"";
            plugin_category = "osc";
         }

         // // _out.replace("$(ID)", plugin_id);  // => must replace this after C code generation (use C source checksum when this is a patch plugin)
         _out.replace("$(NAME)", Utils.ConvertToVarName(plugin_id));  // safe to use "base" id (w/o chksum suffix)
         _out.replace("$(NAME_LONG)", plugin_name);
         _out.replace("$(NAME_SHORT)", plugin_name);
         _out.replace("$(AUTHOR)", plugin_author);
         // // _out.replace("$(DATE)", Utils.GetCurrentDateString()+" "+(Utils.GetCurrentTimeString().replace("_",":")));  // => must replace this after C code generation or it will change the checksum
      }

      if(!bFirstPatch)
      {
         _out.append("\n\n\n");
      }

      // Info header
      if(!b_plugin)
      {
         if(null != _exportCSample)
            _out.append("//         name: "+_exportCSample.unique_name+" off="+_exportCFrameOffset+" num="+_exportCFrameNum+"\n");
         _out.append("//  sample_rate: "+sample_rate+"\n");
         if(1.0 != oversample_factor)
            _out.append("//   oversample: "+oversample_factor+"\n");
         _out.append("//    note_freq: "+note_freq+"\n");
         _out.append("//      #frames: "+num_frames+"\n");
         if(0 != num_skip_frames)
            _out.append("// #skip_frames: "+num_skip_frames+"\n");
         if(0 != xfade_frames)
            _out.append("//        xfade: "+xfade_frames+"\n");
         _out.append("\n");
         _out.append("\n");
      }

      if(b_export_c && !b_plugin)
         _out.append("$(INC_STDIO)\n");

      // Declare plugin params
      CyPluginParam *pluginParam;
      int pluginParamIdx = 0;
      int paramGroupIdx;
      int paramSectionIdx;
      foreach pluginParam in plugin_params
      {
         // (todo) place in st_plugin_shared_t when b_plugin=true
         if(b_plugin)
         {
            local String sParamBaseId <= pluginParam.getBaseId();
            sPluginParamDefs.append(Utils.AlignString("#define PARAM_"+(sParamBaseId.toUpper())+" ", 33)+pluginParamIdx+"\n");
            sPluginParamNames.append(Utils.AlignString("   \""+sParamBaseId+"\", ", 29)+" // "+pluginParamIdx+": "+(sParamBaseId.toUpper())+"\n");
            sPluginParamResets.append(Utils.AlignString("   "+FloatToString(pluginParam.def_value)+", ", 29)+" // "+pluginParamIdx+": "+(sParamBaseId.toUpper())+"\n");

            if(null != pluginParam.group_name)
            {
               paramGroupIdx = aPluginParamGroupNames.indexOfObject(pluginParam.group_name, 0);
               if(-1 == paramGroupIdx)
               {
                  aPluginParamGroupNames.add(pluginParam.group_name);
                  paramGroupIdx = aPluginParamGroupNames.numElements - 1;
               }
               aPluginParamGroupIndices.add(paramGroupIdx);
            }
            else
            {
               aPluginParamGroupIndices.add(-1);
            }

            if(null != pluginParam.section_name)
            {
               paramSectionIdx = aPluginParamSectionNames.indexOfObject(pluginParam.section_name, 0);
               if(-1 == paramSectionIdx)
               {
                  aPluginParamSectionNames.add(pluginParam.section_name);
                  paramSectionIdx = aPluginParamSectionNames.numElements - 1;
               }
               aPluginParamSectionIndices.add(paramSectionIdx);
            }
            else
            {
               aPluginParamSectionIndices.add(-1);
            }

            // Query preset values and names
            int numPresets = pluginParam.getNumPresets();
            if(numPresets > 0)
            {
               sPluginQueryPresetValues.append("   if(PARAM_"+sParamBaseId.toUpper()+" == _paramIdx)\n");
               sPluginQueryPresetValues.append("   {\n");
               sPluginQueryPresetValues.append("      static const float presetValues_"+pluginParamIdx+"["+numPresets+"] = { ");
               pluginParam.emitPresetValues(sPluginQueryPresetValues);
               sPluginQueryPresetValues.append(" };\n");
               sPluginQueryPresetValues.append("      r = loc_copy_floats(_retValues, _retValuesSize, presetValues_"+pluginParamIdx+", "+numPresets+");\n");
               sPluginQueryPresetValues.append("   }\n");

               sPluginQueryPresetName.append("   if(PARAM_"+sParamBaseId.toUpper()+" == _paramIdx)\n");
               sPluginQueryPresetName.append("   {\n");
               sPluginQueryPresetName.append("      static const char *presetName_"+pluginParamIdx+"["+numPresets+"] = { ");
               pluginParam.emitPresetNames(sPluginQueryPresetName);
               sPluginQueryPresetName.append(" };\n");
               sPluginQueryPresetName.append("      r = loc_copy_chars(_retBuf, _retBufSize, presetName_"+pluginParamIdx+"[_presetIdx]);\n");
               sPluginQueryPresetName.append("   }\n");
            }

            // Next plugin parameter
            pluginParamIdx++;
         }
         else
         {
            if(b_export_c)
               _out.append("static float param_"+pluginParam.id+export_c_prefix+" = "+pluginParam.def_value+";\n");
            else
               _out.append("float param_"+pluginParam.id+" = "+pluginParam.def_value+";\n");
         }
      }
      if(plugin_params.numElements > 0)
         _out.append("\n");
      if(b_plugin)
      {
         sPluginParamDefs.append(Utils.AlignString("#define NUM_PARAMS ", 33)+pluginParamIdx+"\n");
         _out.replace("$(PARAM_DEFS)", sPluginParamDefs);
         _out.replace("$(PARAM_NAMES)", sPluginParamNames);
         _out.replace("$(PARAM_RESETS)", sPluginParamResets);
      }

      // Declare plugin mods
      CyPluginMod *pluginMod;
      int pluginModIdx = 0;
      foreach pluginMod in plugin_mods
      {
         if(b_plugin)
         {
            local String sModBaseId <= pluginMod.getBaseId();
            sPluginModDefs.append(Utils.AlignString("#define MOD_"+(sModBaseId.toUpper())+" ", 33)+pluginModIdx+"\n");
            sPluginModNames.append(Utils.AlignString("   \""+sModBaseId+"\", ", 26)+" // "+pluginModIdx+": "+(sModBaseId.toUpper())+"\n");
            sPluginModCurIncDecl.append("   float mod_"+sModBaseId+"_cur;\n");
            pluginParam <= findPluginParamByBaseId(sModBaseId);
            if(null != pluginParam)
               sPluginPrepareBlockModVars.append("   float "+Utils.AlignString("mod"+sModBaseId, 15)+" = shared->params["+Utils.AlignString("PARAM_"+(sModBaseId.toUpper()), 18)+"]"+Utils.AlignString(pluginParam.getScaleAddString(), 22)+" + voice->mods["+Utils.AlignString("MOD_"+(sModBaseId.toUpper()), 17)+"];\n");
            else
               sPluginPrepareBlockModVars.append("   float "+Utils.AlignString("mod"+sModBaseId, 15)+" = voice->mods["+Utils.AlignString("MOD_"+(sModBaseId.toUpper()), 17)+"];\n");
            sPluginPrepareBlockInit.append(Utils.AlignString("      voice->mod_"+sModBaseId+"_cur ", 34)+"= mod"+sModBaseId+";\n");
            if(pluginMod.b_smooth)
            {
               sPluginModCurIncDecl.append("   float mod_"+sModBaseId+"_inc;\n");
               sPluginPrepareBlockLerp.append(Utils.AlignString("      voice->mod_"+sModBaseId+"_inc ", 34)+"= ("+Utils.AlignString("mod"+sModBaseId, 18)+" - "+Utils.AlignString("voice->mod_"+sModBaseId+"_cur", 29)+") * recBlockSize;\n");
               sPluginPrepareBlockInit.append(Utils.AlignString("      voice->mod_"+sModBaseId+"_inc ", 34)+"= 0.0f;\n");
               sPluginProcessIncCur.append(Utils.AlignString("         voice->mod_"+sModBaseId+"_cur ", 34)+" += voice->mod_"+sModBaseId+"_inc;\n");
            }
            else
            {
               sPluginPrepareBlockLerp.append(Utils.AlignString("      voice->mod_"+sModBaseId+"_cur ", 34)+"= mod"+sModBaseId+";\n");
            }
            pluginModIdx++;
         }
         else
         {
            // (todo) place in st_plugin_voice_t when b_plugin=true
            if(b_export_c)
               _out.append("static float mod_"+pluginMod.id+export_c_prefix+" = "+pluginMod.def_value+";\n");
            else
               _out.append("float mod_"+pluginMod.id+" = "+pluginMod.def_value+";\n");
         }
      }
      if(plugin_mods.numElements > 0)
         _out.append("\n");
      if(b_plugin)
      {
         sPluginModDefs.append(Utils.AlignString("#define NUM_MODS ", 33)+pluginModIdx+"\n");
         _out.replace("$(MOD_DEFS)", sPluginModDefs);
         _out.replace("$(MOD_NAMES)", sPluginModNames);
         _out.replace("$(MOD_CUR_INC_DECL)", sPluginModCurIncDecl);
         _out.replace("$(PREPARE_BLOCK_MOD_VARS)", sPluginPrepareBlockModVars);
         _out.replace("$(PREPARE_BLOCK_LERP)", sPluginPrepareBlockLerp);
         // // _out.replace("$(PROCESS_INC_CUR)", sPluginProcessIncCur);
      }

      // Declare vars
      CyVar *v;
      foreach v in vars
      {
         if(b_plugin)
         {
            sPluginVarDecls.append("   float var_"+v.id+export_c_prefix+";\n");
            sPluginVarReset.append("      voice->var_"+v.id+export_c_prefix+" = "+FloatToString(v.def_value)+";\n");

            if(v.b_smooth)
            {
               sPluginVarDecls.append("   float var_"+v.id+"_next"+export_c_prefix+";\n");
               sPluginVarDecls.append("   float var_"+v.id+"_inc"+export_c_prefix+";\n");
               sPluginVarReset.append("      voice->var_"+v.id+"_next"+export_c_prefix+" = "+FloatToString(v.def_value)+";\n");
               sPluginPrepareVarFirst.append("      voice->var_"+v.id+export_c_prefix+" = voice->var_"+v.id+"_next"+export_c_prefix+";\n");
               sPluginPrepareVarNext .append("      voice->var_"+v.id+"_inc"+export_c_prefix+" = (voice->var_"+v.id+"_next"+export_c_prefix+" - voice->var_"+v.id+export_c_prefix+") * recBlockSize;\n");
               sPluginProcessIncCur.append("         voice->var_"+v.id+export_c_prefix+" += voice->var_"+v.id+"_inc"+export_c_prefix+";\n");
            }
         }
         else
         {
            if(b_export_c)
               _out.append("static float var_"+v.id+export_c_prefix+" = "+FloatToString(v.def_value)+";\n");
            else
               _out.append("float var_"+v.id+" = "+v.def_value+";\n");
         }
      }
      if(!b_plugin && vars.numElements > 0)
         _out.append("\n");

      // Declare macro vars and field values
      if(macros.numElements > 0)
      {
         _out.append("\n");
         if(b_plugin)
            sPluginVarDecls.append("\n");
      }
      CyMacro *macro;
      // // String sMacroValues <= b_plugin ? sHeader : _out;
      String sMacroValues <= sHeader;
      foreach macro in macros
      {
         String *macroFieldName;
         foreach macroFieldName in macro.field_names
         {
            if(b_plugin)
            {
               sPluginVarDecls.append("   float macrovar_"+macro.id+"_"+macroFieldName+";\n");
               sPluginVarReset.append("      voice->macrovar_"+macro.id+"_"+macroFieldName+" = 0;\n");
            }
            else
            {
               if(b_export_c)
               {
                  if(!b_export_c_no_static)
                     _out.append("static ");
                  _out.append("float macrovar_"+macro.id+"_"+macroFieldName+export_c_prefix+" = 0;\n");
               }
               else
                  _out.append("float macrovar_"+macro.id+"_"+macroFieldName+" = 0;\n");
            }
         }

         if(b_export_c)
         {
            // trace "xxx declare macro vars: b_export_c_no_static="+b_export_c_no_static;
            if(!b_export_c_no_static)
               sMacroValues.append("static ");
            sMacroValues.append("const float macrovalues_"+macro.id+"[("+macro.getNumMacroRows()+" * "+macro.getNumMacroFields()+")/*"+macro.getNumMacroValues()+"*/] = {\n");
         }
         else
            sMacroValues.append("FloatArray macrovalues_"+macro.id+" = [\n");
         macro.emitFieldValuesFloat(sMacroValues);
         if(b_export_c)
            sMacroValues.append("};\n\n");
         else
            sMacroValues.append("];\n\n");
      }

      // Declare map vars and field values
      if(maps.numElements > 0)
      {
         _out.append("\n");
         if(b_plugin)
            sPluginVarDecls.append("\n");
      }
      CyMap *map;
      String sMapValues <= sHeader;
      foreach map in maps
      {
         String *mapFieldName;
         foreach mapFieldName in map.field_names
         {
            if(b_plugin)
            {
               sPluginVarDecls.append("   float mapvar_"+map.id+"_"+mapFieldName+";\n");
               sPluginVarReset.append("      voice->mapvar_"+map.id+"_"+mapFieldName+" = 0;\n");
            }
            else
            {
               if(b_export_c)
               {
                  if(!b_export_c_no_static)
                     _out.append("static ");
                  _out.append("float mapvar_"+map.id+"_"+mapFieldName+export_c_prefix+" = 0;\n");
               }
               else
                  _out.append("float mapvar_"+map.id+"_"+mapFieldName+" = 0;\n");
            }
         }

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               sMapValues.append("static ");
            sMapValues.append("const float mapvalues_"+map.id+"[("+map.getNumMapRows()+" * "+map.getNumMapFields()+")/*"+map.getNumMapValues()+"*/] = {\n");
         }
         else
            sMapValues.append("FloatArray mapvalues_"+map.id+" = [\n");
         map.emitFieldValuesFloat(sMapValues);
         if(b_export_c)
            sMapValues.append("};\n\n");
         else
            sMapValues.append("];\n\n");

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               sMapValues.append("static ");
            sMapValues.append("const float mapkeys_"+map.id+"["+map.getNumMapRows()+"] = {\n");
         }
         else
            sMapValues.append("FloatArray mapkeys_"+map.id+" = [\n");
         map.emitRowKeysFloat(sMapValues);
         if(b_export_c)
            sMapValues.append("};\n\n");
         else
            sMapValues.append("];\n\n");

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               sMapValues.append("static ");
            sMapValues.append("const float mapdeltalin_"+map.id+"["+(map.getNumMapRows() - 1)+"] = {\n");
         }
         else
            sMapValues.append("FloatArray mapdeltalin_"+map.id+" = [\n");
         map.emitRowKeysDeltaLinFloat(sMapValues);
         if(b_export_c)
            sMapValues.append("};\n\n");
         else
            sMapValues.append("];\n\n");
      }

      // Tmp var
      if(bFirstPatch)
      {
         if(!b_plugin)
         {
            if(b_export_c)
            {
               _out.append("static float tmp_f;\n");
               _out.append("static float tmp2_f;\n");

               _out.append("static "+short_type+" tmp_i;\n");
               _out.append("static "+short_type+" tmp2_i;\n");
            }
            else
            {
               _out.append("float tmp_f;\n");
               _out.append("float tmp2_f;\n");

               _out.append(short_type+" tmp_i;\n");
               _out.append(short_type+" tmp2_i;\n");
            }

            _out.append("$(HEADER)\n");  // (note) in plugin mode this is already part of the template file
         }

         // // String sHeader <= b_plugin ? sPluginHeader : _out;

         if(b_export_c)
         {
            sHeader.append("#define loop(X)  for(unsigned int i = 0u; i < (X); i++)\n");
            sHeader.append("#define clamp(a,b,c) (((a)<(b))?(b):(((a)>(c))?(c):(a)))\n\n");

            sHeader.append("static inline float mathLerpf(float _a, float _b, float _t) { return _a + (_b - _a) * _t; }\n");

            // sHeader.append("#define mathClampf(a,b,c) (((a)<(b))?(b):(((a)>(c))?(c):(a)))\n");
            sHeader.append("static inline float mathClampf(float a, float b, float c) { return (((a)<(b))?(b):(((a)>(c))?(c):(a))); }\n");
            sHeader.append("static inline float mathMinf(float a, float b) { return (a<b)?a:b; }\n");
            sHeader.append("static inline float mathMaxf(float a, float b) { return (a>b)?a:b; }\n");
            sHeader.append("static inline float mathAbsMaxf(float _x, float _y) { return ( ( (_x<0.0f)?-_x:_x)>((_y<0.0f)?-_y:_y)?_x:_y ); }\n");
            sHeader.append("static inline float mathAbsMinf(float _x, float _y) { return ( ((_x<0.0f)?-_x:_x)<((_y<0.0f)?-_y:_y)?_x:_y ); }\n");
            sHeader.append("static inline float frac(float _x) { return _x - ((int)_x); }\n");

            sHeader.append("\nstatic inline float winLinear(const float *_s, float _index) {\n");
            sHeader.append("   int idx = (int)_index;\n");
            sHeader.append("   float r = _index - (float)idx;\n");
            sHeader.append("   return mathLerpf(_s[idx], _s[idx+1], r);\n");
            sHeader.append("}\n");
         }

         if(!b_export_c)
         {
            // // sHeader.append("$(SCRIPT_STATIC_INIT)");
            _out.append("$(SCRIPT_STATIC_INIT)");  // sStaticInit
         }

         if(b_export_c)
         {
            if(!b_plugin)
            {
               sHeader.append("\nextern float cycle_sine_tbl_f[16384];\n");
               sHeader.append("\nextern "+short_type+" cycle_sine_tbl_i[16384];\n");
               sHeader.append("extern float cycle_xfade_buf["+MAX_XFADE_FRAMES+"];\n");
            }

         }

         // "int" utility functions placeholder
         local String sIntFunctions;
         sHeader.append("$(INT_FUNCTIONS)");

         // used by "ssl" module
         //  (note) e.g. -1.7 => 0.3
         if(b_export_c)
         {
            sHeader.append("\nstatic float ffrac_s(float _f) { int i; if(_f >= 0.0f) { i = (int)_f; return _f - (float)i; } else { i = (int)-_f; return 1.0f - (-_f - (float)i); } }\n");
         }
         else
         {
            sHeader.append("\nfunction ffrac_s(float _f) { return (_f >= 0.0f) ? frac(_f) : (1.0f + frac(_f)); }\n");

            // // if(b_use_bts)
            {
               sHeader.append("\nfunction loc_bipolar_to_scale(float _t, float _div, float _mul) {\n");
               sHeader.append("   // t (-1..1) => /_div .. *_mul\n");
                  sHeader.append("   \n");
               sHeader.append("   float s;\n");
               sHeader.append("\n");
               sHeader.append("   if(_t < 0.0f)\n");
               sHeader.append("   {\n");
               sHeader.append("      s = (1.0f / _div);\n");
               sHeader.append("      s = 1.0f + (s - 1.0f) * -_t;\n");
               sHeader.append("      if(s < 0.0f)\n");
               sHeader.append("         s = 0.0f;\n");
               sHeader.append("   }\n");
               sHeader.append("   else\n");
               sHeader.append("   {\n");
               sHeader.append("      s = _mul;\n");
               sHeader.append("      s = 1.0f + (s - 1.0f) * _t;\n");
               sHeader.append("   }\n");
               sHeader.append("   \n");
               sHeader.append("   return s;\n");
               sHeader.append("}\n");
            }
         }
      }

      local String sDeclLUTShared;
      local String sDeclLUTVoice;

      // Curve vars
      String *curveId;
      IntArray *iaCurve;
      int curveIdx = 0;
      foreach curveId in curve_aliases
      {
         if(!curveId.isBlank())
         {
            if(b_export_c)
            {
               // (note) even though the output is float, curves are stored as signed 16bit fixed point integers
               //         (like in emitInt())
               iaCurve <= curve_intarrays.get(curveIdx);
               sHeader.append("static short curve_"+curveIdx+export_c_prefix/*+export_c_var_prefix*/+"["+iaCurve.numElements+"] = {\n");
               WriteIntArrayData(sHeader, iaCurve);
               // sHeader.append("static const short *cur_curve_"+curveIdx+export_c_prefix+";\n");
               // sHeader.append("static       short *dyn_curve_"+curveIdx+export_c_prefix+" = NULL;\n");

               sPluginUpdateLUTCases.append("      case "+curveIdx+": // \""+curveId+"\"\n");
               sPluginUpdateLUTCases.append("         copySz = Dstplugin_min(_srcNumElements, "+iaCurve.numElements+");\n");
               sPluginUpdateLUTCases.append("         for(unsigned int i = 0u; i < copySz; i++)\n");
               sPluginUpdateLUTCases.append("            curve_"+curveIdx+export_c_prefix+"[i] = (short)(_src[i] * "+FX_ONE+");\n");
               sPluginUpdateLUTCases.append("         break;\n");
            }
            else
            {
               // // _out.append("Envelope *curve_"+curveIdx+";\n");
               _out.append("IntArray *curve_"+curveIdx+";\n");
            }
         }

         // Next curve (lut)
         curveIdx++;
      }

      // Array params
      if(b_export_c && b_plugin)
      {
         CyArrayDecl *arrayDecl;
         foreach arrayDecl in array_decls
         {
            // Array param
            //  - declare (per shared instance) variation arrays
            //  - declare (per voice instance) effective array (interpolated variation arrays)
            //  - implement getter methods for querying size / num variations / variation array data pointer
            pluginParam <= arrayDecl.param;

            sDeclLUTShared.append("   float "+arrayDecl.getSharedArrayName()+"["+arrayDecl.num_variations+"/*var*/]["+arrayDecl.size+"/*size*/];\n");
            sDeclLUTShared.append("   int "+arrayDecl.getSharedArrayForcedIdxName()+";\n");
            sDeclLUTVoice.append("   float "+arrayDecl.getVoiceArrayName()+"["+arrayDecl.size+"/*size*/];\n");
            sDeclLUTVoice.append("   float "+arrayDecl.getLastVoiceVarIdxName()+";\n");

            if(arrayDecl.copy_curve_idx >= 0)
            {
               // Copy const curve LUT to variation 0 when shared instance is created (loc_shared_new())
               curveIdx = arrayDecl.copy_curve_idx;
               iaCurve <= curve_intarrays.get(curveIdx);
               sPluginArrayParamSharedInit.append("\n      // Initialize array param \""+pluginParam.id+"\" (sz="+arrayDecl.size+" #var="+arrayDecl.num_variations+") variation 0 from exported bezier curve data\n");
               sPluginArrayParamSharedInit.append("      {\n");
               sPluginArrayParamSharedInit.append("         const unsigned int copySz = ("+arrayDecl.size+"u/*arrayDecl.size*/ < "+iaCurve.numElements+"u/*curve LUT sz*/) ? "+arrayDecl.size+"u : "+iaCurve.numElements+"u;\n");
               sPluginArrayParamSharedInit.append("         const short *s = curve_"+curveIdx+export_c_prefix+";\n");
               sPluginArrayParamSharedInit.append("         float *d = &ret->"+arrayDecl.getSharedArrayName()+"[0/*varIdx*/][0];\n");
               sPluginArrayParamSharedInit.append("         for(unsigned int i = 0u; i < copySz; i++)\n");
               sPluginArrayParamSharedInit.append("            d[i] = s[i] * (1.0f / 2048.0f);\n");
               sPluginArrayParamSharedInit.append("      }\n");
            }
            sPluginArrayParamSharedInit.append("         ret->"+arrayDecl.getSharedArrayForcedIdxName()+" = -1;\n");

            // Copy variation 0 array to effective per-voice array when voice instance is created (loc_note_on())
            sPluginArrayParamVoiceNoteOn.append("      voice->"+arrayDecl.getLastVoiceVarIdxName()+" = 0.0f;\n");
            sPluginArrayParamVoiceNoteOn.append("      memcpy((void*)voice->"+arrayDecl.getVoiceArrayName()+", (const void*)&shared->"+arrayDecl.getSharedArrayName()+"[0/*varIdx*/][0], sizeof(float) * "+arrayDecl.size+");\n");

            // Lazy-update queued array param variation index (loc_prepare_block())
            sPluginArrayParamPrepareBlock.append("\n   // Update array param \""+pluginParam.id+"\" voice array\n");
            pluginMod <= findPluginModById("m_"+pluginParam.getBaseId());
            String *sQueuedArrayParamVarIdxName;
            if(null != pluginMod)
               sQueuedArrayParamVarIdxName <= "mod"+pluginParam.getBaseId();  // param+mod  (e.g. "p_var" and "m_var")
            else
               sQueuedArrayParamVarIdxName <= "shared->params[PARAM_"+(pluginParam.getBaseId().toUpper())+"]";  // param only

            sPluginArrayParamPrepareBlock.append("   if(shared->"+arrayDecl.getSharedArrayForcedIdxName()+" >= 0 || "+sQueuedArrayParamVarIdxName+" != voice->"+arrayDecl.getLastVoiceVarIdxName()+")\n");
            sPluginArrayParamPrepareBlock.append("   {\n");
            sPluginArrayParamPrepareBlock.append("      float idxF = (shared->"+arrayDecl.getSharedArrayForcedIdxName()+" >= 0) ? ((float)shared->"+arrayDecl.getSharedArrayForcedIdxName()+") : ("+sQueuedArrayParamVarIdxName+" * "+arrayDecl.num_variations+");\n");
            sPluginArrayParamPrepareBlock.append("      float amtB = idxF - ((int)idxF);\n");
            sPluginArrayParamPrepareBlock.append("      unsigned int idxA = (unsigned int)idxF;\n");
            sPluginArrayParamPrepareBlock.append("      if(idxA >= "+arrayDecl.num_variations+"u/*num_variations*/)\n");
            sPluginArrayParamPrepareBlock.append("         idxA = 0u;\n");
            sPluginArrayParamPrepareBlock.append("      unsigned int idxB = idxA + 1u;\n");
            sPluginArrayParamPrepareBlock.append("      if(idxB >= "+arrayDecl.num_variations+"u/*num_variations*/)\n");
            sPluginArrayParamPrepareBlock.append("         idxB = 0u;\n");
            // sPluginArrayParamPrepareBlock.append("      printf(\"xxx idxA=%u idxB=%u amtB=%f\\n\", idxA, idxB, amtB);\n");
            sPluginArrayParamPrepareBlock.append("      const float *sA = &shared->"+arrayDecl.getSharedArrayName()+"[idxA][0];\n");
            sPluginArrayParamPrepareBlock.append("      const float *sB = &shared->"+arrayDecl.getSharedArrayName()+"[idxB][0];\n");
            sPluginArrayParamPrepareBlock.append("      float *d = &voice->"+arrayDecl.getVoiceArrayName()+"[0];\n");
            sPluginArrayParamPrepareBlock.append("      for(unsigned int i = 0u; i < "+arrayDecl.size+"u; i++)\n");
            sPluginArrayParamPrepareBlock.append("         d[i] = sA[i] + (sB[i] - sA[i]) * amtB;\n");
            sPluginArrayParamPrepareBlock.append("      voice->"+arrayDecl.getLastVoiceVarIdxName()+" = (shared->"+arrayDecl.getSharedArrayForcedIdxName()+" >= 0) ? -1.0f : "+sQueuedArrayParamVarIdxName+";\n");
            sPluginArrayParamPrepareBlock.append("   }\n");

            sPluginGetArrayParamSize.append("\n      case "+pluginParam.idx+": // param \""+pluginParam.id+"\"\n");
            sPluginGetArrayParamSize.append("         return "+arrayDecl.size+"u;\n");

            sPluginGetArrayParamNumVariations.append("\n      case "+pluginParam.idx+":  // param \""+pluginParam.id+"\"\n");
            sPluginGetArrayParamNumVariations.append("         return "+arrayDecl.num_variations+"u;\n");

            sPluginGetArrayParamVariationPtr.append("\n      case "+pluginParam.idx+":  // param \""+pluginParam.id+"\"\n");
            sPluginGetArrayParamVariationPtr.append("         return &shared->"+arrayDecl.getSharedArrayName()+"[_variationIdx][0];\n");

            sPluginSetArrayParamEditVariationIdx.append("\n      case "+pluginParam.idx+":  // param \""+pluginParam.id+"\"\n");
            sPluginSetArrayParamEditVariationIdx.append("         shared->"+arrayDecl.getSharedArrayForcedIdxName()+" = _variationIdx;\n");
            sPluginSetArrayParamEditVariationIdx.append("         break;\n");

            if(arrayDecl.haveElementInfos())
            {
               sPluginGetArrayParamElementName.append("\n      case "+pluginParam.idx+":  // param \""+pluginParam.id+"\"\n");
               sPluginGetArrayParamElementName.append("         switch(_elementIdx)\n");
               sPluginGetArrayParamElementName.append("         {\n");
               sPluginGetArrayParamElementName.append("            default:\n");
               sPluginGetArrayParamElementName.append("               break;\n");

               sPluginGetArrayParamElementValueRange.append("\n      case "+pluginParam.idx+":  // param \""+pluginParam.id+"\"\n");
               sPluginGetArrayParamElementValueRange.append("         switch(_elementIdx)\n");
               sPluginGetArrayParamElementValueRange.append("         {\n");
               sPluginGetArrayParamElementValueRange.append("            default:\n");
               sPluginGetArrayParamElementValueRange.append("               if(NULL != _retStorageMin) *_retStorageMin = "+FloatToString(arrayDecl.storage_min)+";\n");
               sPluginGetArrayParamElementValueRange.append("               if(NULL != _retStorageMax) *_retStorageMax = "+FloatToString(arrayDecl.storage_max)+";\n");
               sPluginGetArrayParamElementValueRange.append("               if(NULL != _retDisplayMin) *_retDisplayMin = "+FloatToString(arrayDecl.display_min)+";\n");
               sPluginGetArrayParamElementValueRange.append("               if(NULL != _retDisplayMax) *_retDisplayMax = "+FloatToString(arrayDecl.display_max)+";\n");
               sPluginGetArrayParamElementValueRange.append("               if(NULL != _retDisplayPrecision) *_retDisplayPrecision = "+arrayDecl.display_prec+";\n");
               sPluginGetArrayParamElementValueRange.append("               return 1;\n");

               sPluginGetArrayParamElementReset.append("\n      case "+pluginParam.idx+":  // param \""+pluginParam.id+"\"\n");
               sPluginGetArrayParamElementReset.append("         switch(_elementIdx)\n");
               sPluginGetArrayParamElementReset.append("         {\n");
               sPluginGetArrayParamElementReset.append("            default:\n");
               sPluginGetArrayParamElementReset.append("               break;\n");

               int arrayElementIdx = 0;
               loop(arrayDecl.element_names.getNumElements())
               {
                  String elementName     <= arrayDecl.element_names    .get(arrayElementIdx);
                  float  elementDpyReset  = arrayDecl.element_dpy_reset.get(arrayElementIdx);
                  float  elementDpyMin    = arrayDecl.element_dpy_min  .get(arrayElementIdx);
                  float  elementDpyMax    = arrayDecl.element_dpy_max  .get(arrayElementIdx);
                  int    elementDpyPrec   = arrayDecl.element_dpy_prec .get(arrayElementIdx);

                  if(!elementName.isBlank())
                  {
                     sPluginGetArrayParamElementName .append("\n            case "+arrayElementIdx+":  // element \""+pluginParam.id+"."+elementName+"\"\n");
                     sPluginGetArrayParamElementName .append("               r = \""+elementName+"\";\n");
                     sPluginGetArrayParamElementName .append("               break;\n");

                     sPluginGetArrayParamElementValueRange.append("\n            case "+arrayElementIdx+":  // element \""+pluginParam.id+"."+elementName+"\"\n");
                     sPluginGetArrayParamElementValueRange.append("               if(NULL != _retStorageMin) *_retStorageMin = "+FloatToString(arrayDecl.storage_min)+";\n");
                     sPluginGetArrayParamElementValueRange.append("               if(NULL != _retStorageMax) *_retStorageMax = "+FloatToString(arrayDecl.storage_max)+";\n");
                     sPluginGetArrayParamElementValueRange.append("               if(NULL != _retDisplayMin) *_retDisplayMin = "+FloatToString(elementDpyMin)+";\n");
                     sPluginGetArrayParamElementValueRange.append("               if(NULL != _retDisplayMax) *_retDisplayMax = "+FloatToString(elementDpyMax)+";\n");
                     sPluginGetArrayParamElementValueRange.append("               if(NULL != _retDisplayPrecision) *_retDisplayPrecision = "+elementDpyPrec+";\n");
                     sPluginGetArrayParamElementValueRange.append("               return 1;\n");

                     sPluginGetArrayParamElementReset.append("\n            case "+arrayElementIdx+":  // element \""+pluginParam.id+"."+elementName+"\"\n");
                     sPluginGetArrayParamElementReset.append("               r = "+FloatToString(elementDpyReset)+";\n");
                     sPluginGetArrayParamElementReset.append("               break;\n");
                  }

                  // Next array element
                  arrayElementIdx++;
               }
               sPluginGetArrayParamElementName       .append("         }\n");
               sPluginGetArrayParamElementName       .append("         break;\n");
               sPluginGetArrayParamElementValueRange .append("         }\n");
               sPluginGetArrayParamElementValueRange .append("         break;\n");
               sPluginGetArrayParamElementReset      .append("         }\n");
               sPluginGetArrayParamElementReset      .append("         break;\n");
            }
            else
            {
               // no per-element info, return common storage/display range for all elements (ignore '_elementIdx')
               sPluginGetArrayParamElementValueRange.append("\n      case "+pluginParam.idx+":  // param \""+pluginParam.id+"\"\n");
               sPluginGetArrayParamElementValueRange.append("         if(NULL != _retStorageMin) *_retStorageMin = "+FloatToString(arrayDecl.storage_min)+";\n");
               sPluginGetArrayParamElementValueRange.append("         if(NULL != _retStorageMax) *_retStorageMax = "+FloatToString(arrayDecl.storage_max)+";\n");
               sPluginGetArrayParamElementValueRange.append("         if(NULL != _retDisplayMin) *_retDisplayMin = "+FloatToString(arrayDecl.display_min)+";\n");
               sPluginGetArrayParamElementValueRange.append("         if(NULL != _retDisplayMax) *_retDisplayMax = "+FloatToString(arrayDecl.display_max)+";\n");
               sPluginGetArrayParamElementValueRange.append("         if(NULL != _retDisplayPrecision) *_retDisplayPrecision = "+arrayDecl.display_prec+";\n");
               sPluginGetArrayParamElementValueRange.append("         return 1;\n");
            }
         } // foreach arrayDecl
      } // if b_plugin


      // Zone refs
      if(!b_plugin)
      {
         String *zoneId;
         int zoneIdx = 0;
         foreach zoneId in zone_refs
         {
            if(b_export_c)
            {
               _out.append("const float *zone_smp_"+zoneIdx+export_c_prefix+";\n");

               Sample *zoneSmp;
               String zoneSmpId <= zone_smp_refs.get(zoneIdx);
               if(zoneSmpId.isBlank())
                  zoneSmp <= _exportCSample;
               else
                  zoneSmp <= current_project.findSampleByUniqueName(zoneSmpId);

               if(null != zoneSmp)
               {
                  StSample s <= zoneSmp.findZoneByName(zoneId);
                  if(null == s)
                     s <= zoneSmp.getZoneByIdx(int(zoneId));
                  if(null != s)
                  {
                     _exportCCallBuf.append("   zone_smp_"+zoneIdx+export_c_prefix+" = _wfAddr + "+(s.lastLoopOffset+zoneSmp.export_all_c_wf_off)+";\n");
                  }
                  else
                     throw CyZoneNotFoundError "emitFloat: zone \""+zoneId+"\" not found (zoneSmp=\""+zoneSmp.unique_name+"\")";
               }
               else
                  throw CyZoneNotFoundError "emitFloat: zone \""+zoneSmpId+"."+zoneId+"\" sample not found";
            }
            else
            {
               _out.append("FloatArray zone_smp_"+zoneIdx+";\n");
            }
            zoneIdx++;
         }

         // StVoicePlugin refs
         if(!b_export_c)  // (todo) support voice plugins in C code generators
         {
            if(vpl_modules.numElements > 0)
            {
               if(b_export_c)
                  _out.append("static float vpl_iobuf[2];  // interleaved l/r frame\n");
               else
                  _out.append("FloatArray vpl_iobuf;  // interleaved l/r frame\n");
               int vplIdx = 0;
               CyModuleVpl *modVpl;
               foreach modVpl in vpl_modules
               {
                  _out.append("StPluginVoice *vpl_voice_"+vplIdx+";\n");
                  sInitMain.append("   vpl_voice_"+vplIdx+".noteOn(false/*bGlide*/, 60/*note*/, 1.0/*vel*/);\n");
                  vplIdx++;
               }
            }
         }

         // XFade buf
         int xfadeStartFrameCapture;
         int xfadeStartFrameFade;
         float xfadeStep;
         if(xfade_frames > 0)
         {
            if(!b_export_c)
               _out.append("FloatArray *cycle_xfade_buf;\n");
            // // _out.append("int xfade_start_frame = "+(maxXFadeFrames - xfade_frames)+";\n");
            if(b_debug1)
               trace "xxx xfade: maxXFadeFrames="+maxXFadeFrames;
            xfadeStartFrameCapture = (maxXFadeFrames - xfade_frames) * oversample_factor;
            if(b_debug1)
               trace "xxx xfade: xfadeStartFrameCapture="+xfadeStartFrameCapture;
            xfadeStartFrameFade = mathMaxi(0, num_skip_frames + num_frames - xfade_frames) * oversample_factor;
            if(b_debug1)
               trace "xxx xfade: xfadeStartFrameFade="+xfadeStartFrameFade;
            xfadeStep = (1.0 / (xfade_frames * oversample_factor));
         }

         // Init code placeholder
         _out.append("$(VAR_DECLS)");
         _out.append("\n");

         if(b_export_c)
         {
            // trace "xxx _exportCCallBuf="+#(_exportCCallBuf);
            _exportCCallBuf.append("   "+Utils.AlignString("calc"+export_c_prefix, 45)+"(_wfAddr + "+Utils.AlignStringRight(String(_exportCFrameOffset), 6)+");  // total="+Utils.AlignStringRight(String(_exportCFrameNum),6)+" ("+Utils.AlignStringRight(int(100*_exportCFrameNum*4/1024.0)/100.0, 5)+"k)"+((wt_w>0)?(" wt_"+wt_w+"x"+wt_h+"x"+num_frames):"")+"\n");
         }
      }

      CyLane *lane;
      CyModule *mod;
      int modIdx;
      local String modBuf;
      boolean bHaveInit = false;
      boolean bHaveWTInit = false;
      local String sInitIndent;
      local String sPluginInitFxn;
      local String sInitFxn <= b_plugin ? sPluginInitFxn : _out;
      local String sInitLUT;
      local String sDeclLUT;
      boolean bFirstLutLane;

      CyLane *lutLane;
      String *lutId;
      CyLUT *lut;
      String sLutCalc <= b_plugin ? sInitLUT : _out;

      // Emit shared+voice LUT init lanes
      bFirstLutLane = true;
      foreach lutLane in lanes
      {
         lutId <= lutLane.id.replace("lut_","");
         lut <= findLUTById(lutId);
         if(null != lut)
         {
            sInitLUT.append("\n");

            CyLUT invLUT <= lutLane.inv_lut_ref;
            local String *sInvLUT;
            // if(null != invLUT)
            // {
            //    local String invLUTId <= invLUT.id;
            // }

            String sLutInitFxnName <= lut.b_voice ? ("loc_update_lut_"+lutId) : ("loc_calc_lut_"+lutId);
            if(b_plugin)
            {
               sDeclLUT.append("static void "+sLutInitFxnName+"(st_plugin_voice_t *_voice, float *_d);\n");
               sInitLUT.append("void "+sLutInitFxnName+"(st_plugin_voice_t *_voice, float *_d) {\n");
               sInitLUT.append("   ST_PLUGIN_VOICE_CAST("+Utils.ConvertToVarName(plugin_id)+"_voice_t);\n");
               sInitLUT.append("   ST_PLUGIN_VOICE_SHARED_CAST("+Utils.ConvertToVarName(plugin_id)+"_shared_t);\n");
            }
            else
            {
               if(b_export_c)
               {
                  _out.append("\nstatic float loc_lut_"+lutId+export_c_prefix+"["+lut.lut_w+"];\n");
                  if(null != invLUT && @(invLUT) != @(lut))
                     _out.append("\nstatic float loc_lut_"+invLUT.id+export_c_prefix+"["+invLUT.lut_w+"];\n");
               }
               else
               {
                  _out.append("\nFloatArray lut_"+lutId+"; lut_"+lutId+".alloc("+lut.lut_w+");\n");
                  if(null != invLUT && @(invLUT) != @(lut))
                     _out.append("\nFloatArray lut_"+invLUT.id+"; lut_"+invLUT.id+".alloc("+invLUT.lut_w+");\n");
               }

               if(b_export_c)
                  _out.append("\nstatic void "+sLutInitFxnName+"(float *_d) {\n");
               else
                  _out.append("\nfunction "+sLutInitFxnName+"(FloatArray _d) {\n");
            }

            sLutCalc.append("$(TMPVARDECL)");
            sLutCalc.append("$(INIT)");
            if(!b_plugin)
            {
               sLutCalc.append("$(GLOBAL_RESET)");
               sLutCalc.append("$(CYCLE_RESET)");
            }

            if(b_plugin)
            {
               if(lut.b_voice)
               {
                  if(sDeclLUTVoice.isBlank())
                     sDeclLUTVoice.append("\n");
                  sDeclLUTVoice .append("   float lut_"+lutId+"["+lut.lut_w+"];\n");
                  if(null != invLUT && @(invLUT) != @(lut))
                     sDeclLUTVoice .append("   float lut_"+invLUT.id+"["+invLUT.lut_w+"];\n");
               }
               else
               {
                  // // if(sDeclLUTShared.isBlank())
                     sDeclLUTShared.append("\n");
                  sDeclLUTShared.append("   float lut_"+lutId+"["+lut.lut_w+"];\n");
                  sDeclLUTShared.append("   int b_lut_"+lutId+";\n");
                  if(null != invLUT && @(invLUT) != @(lut))
                  {
                     sDeclLUTShared.append("   float lut_"+invLUT.id+"["+lut.lut_w+"];\n");
                     sDeclLUTShared.append("   int b_lut_"+invLUT.id+";\n");
                  }
               }
            }

            if(null != invLUT)
            {
               // Fill inverse LUT
               invLUT <= lutLane.inv_lut_ref;
               sInvLUT <= b_plugin ? invLUT.b_voice ? ("voice->lut_"+invLUT.id) : ("shared->lut_"+invLUT.id) : ("lut_"+invLUT.id+export_c_prefix);
               sLutCalc.append("   int invLUTIdx = 0;\n");
               if(b_export_c)
               {
                  sLutCalc.append("   loop("+invLUT.lut_w+")\n");
                  sLutCalc.append("   {\n");
                  sLutCalc.append("      "+sInvLUT+"[invLUTIdx++] = -16.0f;\n");
                  sLutCalc.append("   }\n\n");
               }
               else
               {
                  sLutCalc.append("   "+sInvLUT+".useAll();\n");
                  sLutCalc.append("   "+sInvLUT+".fill(-16.0f);\n");
               }
            }

            float lutXStep = 1.0 / (lut.lut_w - 1);
            sLutCalc.append("   float x = 0.0f;\n");
            if(!b_export_c)
            {
               if(null == invLUT || @(invLUT) != @(lut))
                  sLutCalc.append("   lut_"+lutId+".empty();\n");
            }
            sLutCalc.append("   loop("+lut.lut_w+")\n");
            sLutCalc.append("   {\n");
            sLutCalc.append("      float out = x;\n");
            modIdx = 0;
            setTmpVarContext(lutLane.id);
            // // sLutCalc.append("$(TMPVARDECL)");  // [02Aug2024] moved before $(INIT)
            if(STConfig.b_cycle_tree_debug)
            {
               trace "[trc] CyScript::emitFloat: lutLane.id="+lutLane.id+" tree=";
               lutLane.debugPrintTree(0/*level*/);
            }
            foreach mod in lutLane.modules
            {
               modBuf.empty();
               modBuf.append("// -------- lane \""+lutLane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
               mod.emitFloatSequence(this, modBuf, "out");
               AppendIndentedLines(sLutCalc, modBuf, 6);
               modIdx++;
            }
            if(!lutLane.b_end)
            {
               if(b_export_c)
               {
                  sLutCalc.append("      _d[i] = out;\n");
                  // sLutCalc.append("      printf(\"xxx d[%u]=%f  x=%f\\n\", i-1, _d[i-1], x);\n");
               }
               else
                  sLutCalc.append("      _d.add(out);\n");
            }
            sLutCalc.append("\n      // Next x\n");
            sLutCalc.append("      x += "+FloatToString(lutXStep)+";\n");
            sLutCalc.append("   } // loop "+lut.lut_w+"\n");

            if(null != invLUT)
            {
               // Close gaps in inverse LUT
               sLutCalc.append("\n");
               sLutCalc.append("   float invLUTLast = 0.0f;\n");
               sLutCalc.append("   invLUTIdx = 0;\n");
               sLutCalc.append("   loop("+invLUT.lut_w+")\n");
               sLutCalc.append("   {\n");
               sLutCalc.append("      if(-16.0f == "+sInvLUT+"[invLUTIdx])\n");
               sLutCalc.append("         "+sInvLUT+"[invLUTIdx] = invLUTLast;\n");
               sLutCalc.append("      else\n");
               sLutCalc.append("         invLUTLast = "+sInvLUT+"[invLUTIdx];\n");
               sLutCalc.append("      invLUTIdx++;\n");
               sLutCalc.append("   }\n\n");
            }

            sLutCalc.append("} /* end "+sLutInitFxnName+"() */\n");

            if(!b_plugin)
            {
               sInitIndent.empty();
               AppendIndentedLines(sInitIndent, s_init, 3);
               sLutCalc.replace("$(INIT)", sInitIndent);
               s_init.empty();

               s_global_reset.append(s_alloc_reset);
               s_alloc_reset.empty();

               sLutCalc.replace("$(GLOBAL_RESET)", s_global_reset);
               s_global_reset.empty();

               sLutCalc.replace("$(CYCLE_RESET)", s_cycle_reset);
               s_cycle_reset.empty();
            }

            sLutCalc.replace("$(TMPVARDECL)", s_tmp_var_decl);

            // Call shared LUT initializer
            if(!lut.b_voice)
            {
               String sLUTSharedIndent <= b_plugin ? "      " : "   ";

               if(b_plugin)
                  sCallLUTShared.append(sLUTSharedIndent+"if(!shared->b_lut_"+lutId+") { loc_calc_lut_"+lutId+"(&voice->base, shared->lut_"+lutId+"); shared->b_lut_"+lutId+" = 1; }\n");
               else if(b_export_c)
                  sCallLUTShared.append(sLUTSharedIndent+"loc_calc_lut_"+lutId+"(loc_lut_"+lutId+");\n");
               else
                  sCallLUTShared.append(sLUTSharedIndent+"loc_calc_lut_"+lutId+"(lut_"+lutId+");\n");
            }

            bFirstLutLane = false;
         }
      }

      // Emit init lane ("<init")
      lane <= findLaneById("init");
      if(null != lane)
      {
         sInitFxn.append("\n");

         setTmpVarContext("Init");

         if(b_plugin)
         {
            sInitFxn.append("void loc_init"+export_c_prefix+"(st_plugin_voice_t *_voice) {\n");
            sInitFxn.append("   ST_PLUGIN_VOICE_CAST("+Utils.ConvertToVarName(plugin_id)+"_voice_t);\n");
            sInitFxn.append("   ST_PLUGIN_VOICE_SHARED_CAST("+Utils.ConvertToVarName(plugin_id)+"_shared_t);\n");
            sInitFxn.append("\n");
         }
         else if(b_export_c)
            sInitFxn.append("static void init"+export_c_prefix+"(void) {\n");
         else
            sInitFxn.append("function Init() {\n");

         sInitFxn.append("$(TMPVARDECL)");
         sInitFxn.append("$(INIT)");
         if(!b_plugin)
         {
            sInitFxn.append("$(GLOBAL_RESET)");
            sInitFxn.append("$(CYCLE_RESET)");
         }

         sInitFxn.append("   float out = 0.0f;\n");
         // // sInitFxn.append("$(TMPVARDECL)");  // [02Aug2024] moved before $(INIT)
         if(b_export_c)
            sInitFxn.append("   (void)out;\n");  // avoid compiler warning when init lane never reads out
         modIdx = 0;
         if(STConfig.b_cycle_tree_debug)
         {
            trace "[trc] CyScript::emitFloat: lane.id="+lane.id+" tree=";
            lane.debugPrintTree(0/*level*/);
         }
         foreach mod in lane.modules
         {
            modBuf.empty();
            modBuf.append("// -------- lane \""+lane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
            mod.emitFloatSequence(this, modBuf, "out");
            AppendIndentedLines(sInitFxn, modBuf, 3);
            modIdx++;
         }

         // Call shared LUT initializers
         bFirstLutLane = true;
         foreach lutLane in lanes
         {
            lutId <= lutLane.id.replace("lut_","");
            lut <= findLUTById(lutId);
            if(null != lut)
            {
               if(!lut.b_voice)
               {
                  if(bFirstLutLane)
                  {
                     sInitFxn.append("   \n");
                     bFirstLutLane = false;
                  }

                  // // if(b_plugin)
                  // //    sInitFxn.append("   loc_calc_lut_"+lutId+"(&voice->base, shared->lut_"+lutId+");\n");
                  // // else if(b_export_c)
                  // //    sInitFxn.append("   loc_calc_lut_"+lutId+"(loc_lut_"+lutId+");\n");
                  // // else
                  // //    sInitFxn.append("   loc_calc_lut_"+lutId+"(lut_"+lutId+");\n");

                  if(!b_plugin)
                  {
                     if(b_export_c)
                        sInitFxn.append("   loc_calc_lut_"+lutId+"(loc_lut_"+lutId+");\n");
                     else
                        sInitFxn.append("   loc_calc_lut_"+lutId+"(lut_"+lutId+");\n");
                  }
               }
            }
         }

         sInitFxn.replace("$(TMPVARDECL)", s_tmp_var_decl);

         sInitFxn.append("} /* end init */\n");

         if(!b_plugin)
         {
            sInitIndent.empty();
            AppendIndentedLines(sInitIndent, s_init, 3);
            sInitFxn.replace("$(INIT)", sInitIndent);
            s_init.empty();

            s_global_reset.append(s_alloc_reset);
            s_alloc_reset.empty();

            sInitFxn.replace("$(GLOBAL_RESET)", s_global_reset);
            s_global_reset.empty();

            sInitFxn.replace("$(CYCLE_RESET)", s_cycle_reset);
            s_cycle_reset.empty();
         }

         // // sInitFxn.append("\n");

         bHaveInit = true;
      }

      // Emit wavetable init lane ("<wt_init")
      lane <= findLaneById("wt_init");
      if(null == lane)
         lane <= findLaneById("prepare");
      if(null != lane)
      {
         sInitFxn.append("\n");

         setTmpVarContext(lane.id);

         if(b_plugin)
         {
            sInitFxn.append("void loc_prepare(st_plugin_voice_t *_voice) {\n");
            sInitFxn.append("   ST_PLUGIN_VOICE_CAST("+Utils.ConvertToVarName(plugin_id)+"_voice_t);\n");
            sInitFxn.append("   ST_PLUGIN_VOICE_SHARED_CAST("+Utils.ConvertToVarName(plugin_id)+"_shared_t);\n");
            sInitFxn.append("\n");
         }
         else if(b_export_c)
            sInitFxn.append("static void wt_init"+export_c_prefix+"(void) {\n");
         else
            sInitFxn.append("function WT_Init() {\n");

         sInitFxn.append("$(TMPVARDECL)");
         sInitFxn.append("$(INIT)");
         if(!b_plugin)
         {
            sInitFxn.append("$(GLOBAL_RESET)");
            sInitFxn.append("$(CYCLE_RESET)");
         }

         sInitFxn.append("   float out = 0.0f;\n");
         // // sInitFxn.append("$(TMPVARDECL)");  // [02Aug2024] moved before $(INIT)
         if(b_export_c)
            sInitFxn.append("   (void)out;\n");  // avoid compiler warning when prepare lane never reads out

         modIdx = 0;
         if(STConfig.b_cycle_tree_debug)
         {
            trace "[trc] CyScript::emitFloat: lane.id="+lane.id+" tree=";
            lane.debugPrintTree(0/*level*/);
         }
         foreach mod in lane.modules
         {
            modBuf.empty();
            modBuf.append("// -------- lane \""+lane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
            mod.emitFloatSequence(this, modBuf, "out");
            AppendIndentedLines(sInitFxn, modBuf, 3);
            modIdx++;
         }

         // Call per-voice LUT initializers
         bFirstLutLane = true;
         String sLUTVoiceInit <= b_plugin ? sPluginCallLUTVoice : sInitFxn;  // sPluginVarReset
         String sLUTVoiceIndent <= b_plugin ? "      " : "   ";
         foreach lutLane in lanes
         {
            lutId <= lutLane.id.replace("lut_","");
            lut <= findLUTById(lutId);
            if(null != lut)
            {
               if(lut.b_voice)
               {
                  // trace "xxx init voice lutId="+lutId;
                  if(bFirstLutLane)
                  {
                     sLUTVoiceInit.append("   \n");
                     bFirstLutLane = false;
                  }

                  if(b_plugin)
                     sLUTVoiceInit.append(sLUTVoiceIndent+"loc_update_lut_"+lutId+"(&voice->base, voice->lut_"+lutId+");\n");
                  else if(b_export_c)
                     sLUTVoiceInit.append(sLUTVoiceIndent+"loc_update_lut_"+lutId+"(loc_lut_"+lutId+");\n");
                  else
                     sLUTVoiceInit.append(sLUTVoiceIndent+"loc_update_lut_"+lutId+"(lut_"+lutId+");\n");
               }
            }
         }

         sInitFxn.replace("$(TMPVARDECL)", s_tmp_var_decl);

         sInitFxn.append("} /* end "+(b_plugin?"prepare":"wt_init")+" */\n");

         if(!b_plugin)
         {
            sInitIndent.empty();
            AppendIndentedLines(sInitIndent, s_init, 3);
            sInitFxn.replace("$(INIT)", sInitIndent);
            s_init.empty();

            s_global_reset.append(s_alloc_reset);
            s_alloc_reset.empty();

            sInitFxn.replace("$(GLOBAL_RESET)", s_global_reset);
            s_global_reset.empty();

            sInitFxn.replace("$(CYCLE_RESET)", s_cycle_reset);
            s_cycle_reset.empty();
         }

         // // sInitFxn.append("\n");

         if(b_plugin)
            _out.replace("$(CALL_PREPARE)", "      loc_prepare(&voice->base);\n");

         bHaveWTInit = true;
      }
      else
      {
         if(b_plugin)
            _out.replace("$(CALL_PREPARE)", "");
      }

      // Emit lanes
      int laneIdx = -1;
      int audioLaneNr = 0;
      boolean bFirstLane = true;
      String sOut <= b_plugin ? sPluginProcessCalc : _out;
      for(;;)
      {
         lane <= lanes.get(++laneIdx);
         if(null != lane)
         {
            if(lane.isAudioLane())
            {
               audioLaneNr++;

               if(bFirstLane)
               {
                  if(wt_w > 0 && !b_plugin)
                  {
                     setTmpVarContext("Calc_Cycle");

                     if(b_export_c)
                        _out.append("static void calc_cycle"+export_c_prefix+"(float *_d) {\n");
                     else
                        _out.append("\nfunction Calc_Cycle(FloatArray _d) {\n");
                     _out.append("$(TMPVARDECL)");
                     if(!b_plugin)
                     {
                        _out.append("$(INIT)");
                        _out.append("$(CYCLE_RESET)");
                     }
                     // _out.append("trace \"calc_cycle d.num=\"+_d.numElements;\n");
                     if(bHaveWTInit)
                     {
                        if(b_export_c)
                           _out.append("\n   wt_init"+export_c_prefix+"();\n");
                        else
                           _out.append("\n   WT_Init();\n");
                     }
                  }
                  else
                  {
                     setTmpVarContext("Calc");

                     if(!b_plugin)
                     {
                        if(b_export_c)
                           _out.append("static void calc"+export_c_prefix+"(float *_d) {\n");
                        else
                           _out.append("\n\nfunction Calc(FloatArray _d) {\n");
                     }
                     else
                     {
                        sOut.append("      float tmp_f; (void)tmp_f;\n");
                        sOut.append("      float tmp2_f; (void)tmp2_f;\n");
                     }

                     _out.append("$(TMPVARDECL)");

                     sOut.append(sInitMain);

                     if(!b_plugin)
                     {
                        _out.append("$(INIT)");
                        _out.append("$(GLOBAL_RESET)");
                        // // // _out.append("$(CALL_LUT_SHARED)");

                        // <init:
                        if(bHaveInit && !b_plugin)
                        {
                           if(b_export_c)
                              sOut.append("\n   init"+export_c_prefix+"();\n");
                           else
                              _out.append("\n   Init();\n");
                        }

                        // <prepare:
                        if(bHaveWTInit)
                        {
                           if(b_export_c)
                              _out.append("\n   wt_init"+export_c_prefix+"();\n");
                           else
                              _out.append("\n   WT_Init();\n");
                        }

                     }
                  }

                  if(!b_plugin && !bHaveInit)  // [28Dec2024] in plugin mode, lut init is already called in Calc()
                     _out.append("$(CALL_LUT_SHARED)");

                  if(!b_plugin)
                  {
                     sOut.append("   int smpIdx = 0;\n");
                     sOut.append("   int outIdx = 0;\n");
                  }

                  if(!b_plugin)
                  {
                     if(0 != xfade_frames)
                     {
                        _out.append("   int xfadeCaptureLeft = "+(xfade_frames * oversample_factor)+";\n");
                        _out.append("   int xfadeReadIdx = 0;\n");
                        _out.append("   float xfadeCur = 0.0f;\n");
                        _out.append("   int xfadeCaptureIdx = 0;\n");
                     }

                     _out.append("   loop("+int((num_frames/(b_mirror?2:1) + num_skip_frames) * oversample_factor)+")\n   {\n");
                     _out.append("      float out = 0.0f;\n");
                  }

               } // if bFirstLane

               boolean bIndivOut = !bFirstLane && ("out" != lane.id);

               modIdx = 0;
               // (todo) lane.modules always contains 1 element => change to first_module
               if(STConfig.b_cycle_tree_debug)
               {
                  trace "[trc] CyScript::emitFloat: lane.id="+lane.id+" tree=";
                  lane.debugPrintTree(0/*level*/);
               }
               if(bIndivOut)
                  sOut.append("      float out"+audioLaneNr+" = 0.0f;\n");
               foreach mod in lane.modules
               {
                  modBuf.empty();
                  modBuf.append("\n// ========\n");
                  modBuf.append("// ======== lane \""+lane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
                  modBuf.append("// ========\n");
                  mod.emitFloatSequence(this, modBuf, bIndivOut ? ("out"+audioLaneNr) : "out");
                  AppendIndentedLines(sOut, modBuf, 6);
                  modIdx++;
               }

               // sum all lanes
               if(bIndivOut && !lane.modules.isEmpty())
                  sOut.append("      out += out"+audioLaneNr+";  // sum lane "+audioLaneNr+"/"+num_audio_lanes+"\n");

               bFirstLane = false;

            } // if isAudioLane()  (!init lane)


         } // if lane
         else
            break;
      }

      if(!bFirstLane)  // any lanes ?
      {
         _out.replace("$(TMPVARDECL)", s_tmp_var_decl);

         if(!b_plugin)
         {
            if(0 != xfade_frames)
            {
               modBuf.empty();
               modBuf.append("// ------ xfade ("+xfade_frames+" frames) -----\n");
               String sVarXFadeIdx <= (0 != num_skip_frames) ? "smpIdx" : "outIdx";
               modBuf.append("if("+sVarXFadeIdx+" >= "+xfadeStartFrameCapture+")\n{\n");
               modBuf.append("   if(xfadeCaptureLeft > 0)\n");
               modBuf.append("   {\n");
               modBuf.append("      cycle_xfade_buf[xfadeCaptureIdx++] = out;\n");
               modBuf.append("      xfadeCaptureLeft--;\n");
               modBuf.append("   }\n");
               modBuf.append("   else if("+sVarXFadeIdx+" >= "+xfadeStartFrameFade+")\n");
               modBuf.append("   {\n");
               if(b_export_c)
                  modBuf.append("      out = mathLerpf(out, cycle_xfade_buf[xfadeReadIdx++], xfadeCur);\n");
               else
                  modBuf.append("      out = mathLerpf(out, cycle_xfade_buf.get(xfadeReadIdx++), xfadeCur);\n");
               modBuf.append("      xfadeCur += "+xfadeStep+";\n");
               modBuf.append("   }\n");
               modBuf.append("}\n");
               AppendIndentedLines(_out, modBuf, 6);
            }
         }

         sOut.append("\n");

         if(!b_plugin)
         {
            if(0 != num_skip_frames)
            {
               _out.append("      if(smpIdx++ >= "+int(num_skip_frames * oversample_factor)+")\n");
               _out.append("         _d[outIdx++] = out;\n");
            }
            else
               _out.append("      _d[outIdx++] = out;\n");

            _out.append("   } /* end loop frames */\n");

            if(b_mirror)
            {
               _out.append("\n");
               _out.append("   int mirrorSrcIdx = outIdx;\n");
               _out.append("   loop("+((num_frames/2)*oversample_factor)+")\n");
               _out.append("   {\n");
               _out.append("      _d[outIdx++] = -_d[--mirrorSrcIdx];\n");
               _out.append("   }\n");
            }

            _out.append("} /* end calc() */\n");
         }
         else
         {
            sOut.append("      /* end calc */\n");
         }
      }

      if(wt_w > 0 && !b_plugin)
      {
         if(b_debug1)
            trace "xxx wt_freqs="+#(wt_freqs);
         boolean bCycleFreq = (wt_freqs.numElements > 0);
         _out.append("\n// ----- wavetable w="+wt_w+" h="+wt_h+" cyclelen="+num_frames+"\n");
         if(b_export_c)
            _out.append("static void calc"+export_c_prefix+"(float *_d) {\n");
         else
            _out.append("function Calc(FloatArray _d) {\n");
         _out.append("   int off = 0;\n");
         _out.append("   var_wt_y = 0.0f;\n");
         _out.append(sInitMain);
         _out.append("$(CALL_LUT_SHARED)");
         if(bCycleFreq)
         {
            int wtFreqIdx = 0;
            local FloatArray wtFreqs;
            loop(wt_w * wt_h)
            {
               wtFreqs.add(wt_freqs.get(wtFreqIdx++ % wt_freqs.numElements));
            }
            _out.append("   int freqIdx = 0;\n");
            if(b_export_c)
            {
               _out.append("   static const float "+export_c_prefix+"_wtFreqs["+wtFreqs.numElements+"] = {\n   ");
               float wtFreq;
               foreach wtFreq in wtFreqs
                  _out.append(String(wtFreq)+", ");
               _out.append("  };\n");
            }
            else
               _out.append("   FloatArray wtFreq = "+wtFreqs.string+";\n");
         }
         _out.append("$(GLOBAL_RESET)");
         if(bHaveInit)
         {
            if(b_export_c)
               _out.append("\n   init"+export_c_prefix+"();\n");
            else
               _out.append("\n   Init();\n");
         }
         _out.append("   loop("+wt_h+")\n");
         _out.append("   {\n");
         _out.append("      var_wt_x = 0.0f;\n");
         _out.append("      loop("+wt_w+")\n");
         _out.append("      {\n");
         if(b_export_c)
         {
            if(bCycleFreq)
               _out.append("         var_wt_freq"+export_c_prefix+" = wtFreqs[freqIdx++];\n");
            _out.append("         float *d = _d + off;\n");
            _out.append("         calc_cycle"+export_c_prefix+"(d);\n");
         }
         else
         {
            _out.append("         FloatArray d;\n");
            _out.append("         d.visit(_d, off, "+int(num_frames * oversample_factor)+");\n");
            if(bCycleFreq)
               _out.append("         var_wt_freq = wtFreq[freqIdx++];\n");
            _out.append("         Calc_Cycle(d);\n");
         }
         if(wt_w > 1)
            _out.append("         var_wt_x += "+(1.0f / (wt_w-1))+";\n");
         _out.append("         off += "+int(num_frames * oversample_factor)+";\n");
         _out.append("      }\n");
         if(wt_h > 1)
            _out.append("      var_wt_y += "+(1.0f / (wt_h-1))+";\n");
         _out.append("   }\n");
         _out.append("}\n");
      }

      if(b_plugin)
         s_var_decl.append(sPluginVarDecls);
      _out.replace("$(VAR_DECLS)", s_var_decl);

      sInitIndent.empty();
      AppendIndentedLines(sInitIndent, s_init, 3);
      if(b_plugin)
      {
         if(bHaveInit)
         {
            sPluginInitDecl.append("static void loc_init"+export_c_prefix+"(st_plugin_voice_t *_voice);\n");
            sPluginInitCall.append("      loc_init"+export_c_prefix+"(&voice->base);\n");
         }
         if(bHaveWTInit)
         {
            if(b_plugin)
               sPluginInitDecl.append("static void loc_prepare(st_plugin_voice_t *_voice);\n");
            else
               sPluginInitDecl.append("static void loc_wt_init"+export_c_prefix+"(st_plugin_voice_t *_voice);\n");
         }
         _out.replace("$(INIT_DECL)", sPluginInitDecl);
      }

      if(b_plugin)
      {
         if(oversample_factor > 1.0f)
         {
            local String sPluginProcessCalcIndent;
            AppendIndentedLines(sPluginProcessCalcIndent, sPluginProcessCalc, 3);
            _out.replace("$(PROCESS_CALC)", sPluginProcessCalcIndent);
         }
         else
         {
            _out.replace("$(PROCESS_CALC)", sPluginProcessCalc);
         }
         _out.replace("$(VAR_RESET)", sPluginVarReset);
         _out.replace("$(CALL_INIT)", sPluginInitCall);
         _out.replace("$(ALLOC_RESET)", s_alloc_reset);
         _out.replace("$(VOICEBUS_INDICES)", s_voicebus_indices);
         _out.replace("$(VOICEBUS_PTRS)", s_voicebus_ptrs);

         if("osc" == plugin_category)
         {
            _out.replace("$(FLAGS)", "ST_PLUGIN_FLAG_OSC"+((next_voicebus_id>0)?" | ST_PLUGIN_FLAG_XMOD":""));
            _out.replace("$(CAT)", "ST_PLUGIN_CAT_UNKNOWN");
         }
         else
         {
            _out.replace("$(FLAGS)", "ST_PLUGIN_FLAG_FX"+((next_voicebus_id>0)?" | ST_PLUGIN_FLAG_XMOD":""));
            _out.replace("$(CAT)", "ST_PLUGIN_CAT_"+plugin_category.toUpper());
         }

         _out.replace("$(INIT_FXN)", sInitFxn);

         _out.replace("$(LUT_DECL_SHARED)", sDeclLUTShared);
         _out.replace("$(LUT_DECL_VOICE)",  sDeclLUTVoice);
         _out.replace("$(LUT_DECL)", sDeclLUT);
         _out.replace("$(LUT_INIT)", sInitLUT);
         _out.replace("$(PREPARE_BLOCK_INIT)", sPluginPrepareBlockInit);
         // trace "xxx sPluginCallLUTVoice="+sPluginCallLUTVoice;
         _out.replace("$(CALL_LUT_VOICE)", sPluginCallLUTVoice);

         _out.replace("$(EXT_PRE)",            s_ext_pre);
         _out.replace("$(EXT_INC)",            s_ext_inc);
         _out.replace("$(EXT_STATIC)",         s_ext_static);
         _out.replace("$(EXT_INIT)",           s_ext_init);
         _out.replace("$(EXT_NEW)",            s_ext_new);
         _out.replace("$(EXT_DELETE)",         s_ext_delete);
         _out.replace("$(EXT_NOTEON)",         s_ext_noteon);
         _out.replace("$(EXT_VOICE)",          s_ext_voice);
         _out.replace("$(EXT_PREPARE)",        s_ext_prepare);
         _out.replace("$(EXT_PREPARE_FIRST)",  s_ext_prepare_first);
         _out.replace("$(EXT_PREPARE_NEXT)",   s_ext_prepare_next);

         if(b_stereo)
            _out.replace("$(STEREO)", "\n#define STEREO  defined\n");
         else
            _out.replace("$(STEREO)", "");

      } // if b_plugin

      _out.replace("$(INIT)", sInitIndent);
      _out.replace("$(CYCLE_RESET)", s_cycle_reset);
      if(!b_plugin)
         s_global_reset.append(s_alloc_reset);
      _out.replace("$(GLOBAL_RESET)", s_global_reset);

      if(b_export_c)
      {
         if(b_use_sine_tbl || b_use_sine_tbl_i)
         {
            sHeader.append("\n#define USE_CYCLE_SINE_TBL  defined\n");
            sHeader.append("static float cycle_sine_tbl_f[16384];\n");
            if(b_use_sine_tbl_i)
            {
               sHeader.append("\n#define USE_CYCLE_SINE_TBL_I  defined\n");
               sHeader.append("static "+short_type+" cycle_sine_tbl_i[16384];\n");
            }
         }
      }

      if(b_use_win_hse)
      {
         sStaticInit.append("\n");

         if(b_use_win_hse_1_36 &&
            (!b_export_c || b_plugin || !current_project.b_export_all_c_calc_win_hse_1_36_done)
            )
         {
            current_project.b_export_all_c_calc_win_hse_1_36_done = true;
            if(b_export_c)
               sHeader.append("float cycle_win_hse_1_36[8192];\n");
            else
               sHeader.append("FloatArray cycle_win_hse_1_36;\n");
            sStaticInit.append("   cycle_calc_win_hse(cycle_win_hse_1_36, 1.36f);\n");
         }

         if(b_use_win_hse_2 &&
            (!b_export_c || b_plugin || !current_project.b_export_all_c_calc_win_hse_2_done)
            )
         {
            current_project.b_export_all_c_calc_win_hse_2_done = true;
            if(b_export_c)
               sHeader.append("float cycle_win_hse_2[8192];\n");
            else
               sHeader.append("FloatArray cycle_win_hse_2;\n");
            sStaticInit.append("   cycle_calc_win_hse(cycle_win_hse_2, 2.0f);\n");
         }

         if(b_use_win_hse_3 &&
            (!b_export_c || b_plugin || !current_project.b_export_all_c_calc_win_hse_3_done)
            )
         {
            current_project.b_export_all_c_calc_win_hse_3_done = true;
            if(b_export_c)
               sHeader.append("float cycle_win_hse_3[8192];\n");
            else
               sHeader.append("FloatArray cycle_win_hse_3;\n");
            sStaticInit.append("   cycle_calc_win_hse(cycle_win_hse_3, 3.0f);\n");
         }

         if(b_use_win_hse_5 &&
            (!b_export_c || b_plugin || !current_project.b_export_all_c_calc_win_hse_5_done)
            )
         {
            current_project.b_export_all_c_calc_win_hse_5_done = true;
            if(b_export_c)
               sHeader.append("float cycle_win_hse_5[8192];\n");
            else
               sHeader.append("FloatArray cycle_win_hse_5;\n");
            sStaticInit.append("   cycle_calc_win_hse(cycle_win_hse_5, 5.0f);\n");
         }

         if(b_use_win_hse_7 &&
            (!b_export_c || b_plugin || !current_project.b_export_all_c_calc_win_hse_7_done)
            )
         {
            current_project.b_export_all_c_calc_win_hse_7_done = true;
            if(b_export_c)
               sHeader.append("float cycle_win_hse_7[8192];\n");
            else
               sHeader.append("FloatArray cycle_win_hse_7;\n");
            sStaticInit.append("   cycle_calc_win_hse(cycle_win_hse_7, 7.0f);\n");
         }

         if(!b_export_c || b_plugin || !current_project.b_export_all_c_calc_win_hse_done)
         {
            current_project.b_export_all_c_calc_win_hse_done = true;
            emitCalcWinHSE(sHeader);
         }
      }

      if(b_export_c)
      {
         // mathPowerf, mathLogLinExpf, loc_bipolar_to_scale
         if(b_use_pow)
            b_use_log = true;  // mathLogf() called in mathPowerf()
         addFloatUtilityFunctions(sHeader);

         _out.replace("$(OVERSAMPLE_FACTOR)", (oversample_factor > 1.0f) ? ("#define OVERSAMPLE_FACTOR  "+FloatToString(oversample_factor))+"\n" : "");

         _out.replace("$(INC_STDIO)", b_use_trc ? "#include <stdio.h>\n":"");

         if(b_plugin)
         {
            local String sPluginWaveforms;
            emitPluginWaveforms(sPluginWaveforms);
            _out.replace("$(PLUGIN_WAVEFORMS)", sPluginWaveforms);

            _out.replace("$(QUERY_PRESET_VALUES)", sPluginQueryPresetValues);
            _out.replace("$(QUERY_PRESET_NAME)",   sPluginQueryPresetName);

            _out.replace("$(GET_ARRAY_PARAM_SIZE)",                sPluginGetArrayParamSize);
            _out.replace("$(GET_ARRAY_PARAM_NUM_VARIATIONS)",      sPluginGetArrayParamNumVariations);
            _out.replace("$(GET_ARRAY_PARAM_VARIATION_PTR)",       sPluginGetArrayParamVariationPtr);
            _out.replace("$(ARRAY_PARAM_VOICE_NOTE_ON)",           sPluginArrayParamVoiceNoteOn);
            _out.replace("$(ARRAY_PARAM_SHARED_INIT)",             sPluginArrayParamSharedInit);
            _out.replace("$(ARRAY_PARAM_PREPARE_BLOCK)",           sPluginArrayParamPrepareBlock);
            _out.replace("$(SET_ARRAY_PARAM_EDIT_VARIATION_IDX)",  sPluginSetArrayParamEditVariationIdx);
            _out.replace("$(GET_ARRAY_PARAM_ELEMENT_NAME)",        sPluginGetArrayParamElementName);
            _out.replace("$(GET_ARRAY_PARAM_ELEMENT_VALUE_RANGE)", sPluginGetArrayParamElementValueRange);
            _out.replace("$(GET_ARRAY_PARAM_ELEMENT_RESET)",       sPluginGetArrayParamElementReset);
            _out.replace("$(UPDATE_LUT_CASES)",                    sPluginUpdateLUTCases);

            int paramIdx;

            // Parameter groups
            local String sPluginParamGroupName;  // get_param_group_name()
            local String sPluginParamGroupIdx;   // get_param_group_idx()
            if(aPluginParamGroupNames.numElements > 0)
            {
               // Parameter group index => name mapping
               sPluginParamGroupName.append("   static const char *groupNames["+aPluginParamGroupNames.numElements+"] = { ");
               String *paramGroupName;
               paramGroupIdx = 0;
               foreach paramGroupName in aPluginParamGroupNames
               {
                  if(paramGroupIdx > 0)
                     sPluginParamGroupName.append(", ");
                  sPluginParamGroupName.append("\""+paramGroupName+"\"");

                  // Next parameter group
                  paramGroupIdx++;
               }
               sPluginParamGroupName.append(" };\n");
               sPluginParamGroupName.append("   if(_paramGroupIdx < "+aPluginParamGroupNames.numElements+"u)\n");
               sPluginParamGroupName.append("      r = groupNames[_paramGroupIdx];\n");

               // Parameter index => parameter group index mapping
               sPluginParamGroupIdx.append("   static unsigned int groupIndices[NUM_PARAMS] = { ");
               paramIdx = 0;
               foreach paramGroupIdx in aPluginParamGroupIndices
               {
                  if(paramIdx > 0)
                     sPluginParamGroupIdx.append(", ");
                  if(paramGroupIdx < 0)
                     sPluginParamGroupIdx.append("~0u");
                  else
                     sPluginParamGroupIdx.append(String(paramGroupIdx));

                  // Next parameter
                  paramIdx++;
               }
               sPluginParamGroupIdx.append(" };\n");
               sPluginParamGroupIdx.append("   r = groupIndices[_paramIdx];\n");
            }
            _out.replace("$(GET_PARAM_GROUP_NAME)", sPluginParamGroupName);
            _out.replace("$(GET_PARAM_GROUP_IDX)",  sPluginParamGroupIdx);

            // Parameter sections
            local String sPluginParamSectionName;  // get_param_section_name()
            local String sPluginParamSectionIdx;   // get_param_section_idx()
            if(aPluginParamSectionNames.numElements > 0)
            {
               // Parameter section index => name mapping
               sPluginParamSectionName.append("   static const char *sectionNames["+aPluginParamSectionNames.numElements+"] = { ");
               String *paramSectionName;
               paramSectionIdx = 0;
               foreach paramSectionName in aPluginParamSectionNames
               {
                  if(paramSectionIdx > 0)
                     sPluginParamSectionName.append(", ");
                  sPluginParamSectionName.append("\""+paramSectionName+"\"");

                  // Next parameter section
                  paramSectionIdx++;
               }
               sPluginParamSectionName.append(" };\n");
               sPluginParamSectionName.append("   if(_paramSectionIdx < "+aPluginParamSectionNames.numElements+"u)\n");
               sPluginParamSectionName.append("      r = sectionNames[_paramSectionIdx];\n");

               // Parameter index => parameter section index mapping
               sPluginParamSectionIdx.append("   static unsigned int sectionIndices[NUM_PARAMS] = { ");
               paramIdx = 0;
               foreach paramSectionIdx in aPluginParamSectionIndices
               {
                  if(paramIdx > 0)
                     sPluginParamSectionIdx.append(", ");
                  if(paramSectionIdx < 0)
                     sPluginParamSectionIdx.append("~0u");
                  else
                     sPluginParamSectionIdx.append(String(paramSectionIdx));

                  // Next parameter
                  paramIdx++;
               }
               sPluginParamSectionIdx.append(" };\n");
               sPluginParamSectionIdx.append("   r = sectionIndices[_paramIdx];\n");
            }
            _out.replace("$(GET_PARAM_SECTION_NAME)", sPluginParamSectionName);
            _out.replace("$(GET_PARAM_SECTION_IDX)",  sPluginParamSectionIdx);

            if(b_use_sr_factor || b_use_sr_factor_int)
            {
               if(b_use_sr_factor_int)
               {
                  s_sr_decl.insert(0, "   short sr_factor;\n");
                  s_sr_changed.insert(0, "      voice->sr_factor_int = (short)("+FloatToString(FX_ONE * sample_rate / oversample_factor)+" / _sampleRate);\n");
               }

               s_sr_decl.insert(0, "   float sr_factor;\n");
               s_sr_changed.insert(0, "      voice->sr_factor = "+FloatToString(sample_rate / oversample_factor)+" / _sampleRate;\n");
            }

            _out.replace("$(SR_DECLS)", s_sr_decl);
            _out.replace("$(SR_CHANGED)", s_sr_changed);

            _out.replace("$(PREPARE_VAR_FIRST)", sPluginPrepareVarFirst);
            _out.replace("$(PREPARE_VAR_NEXT)",  sPluginPrepareVarNext);

            _out.replace("$(PROCESS_INC_CUR)", sPluginProcessIncCur);

            if(!sStaticInit.isBlank())
            {
               local String sStaticInitIndented;
               CyScript.AppendIndentedLines(sStaticInitIndented, sStaticInit, 3);
               _out.replace("$(STATIC_INIT)", sStaticInitIndented);
            }
            else
            {
               _out.replace("$(STATIC_INIT)", "");
            }
         } // if b_plugin
         else
         {
            _exportCStaticInit.append(sStaticInit);
         }
      } // if b_export_c
      else
      {
         // // sHeader.replace("$(SCRIPT_STATIC_INIT)", sStaticInit);
         _out.replace("$(SCRIPT_STATIC_INIT)", sStaticInit);
      }

      // (lazy-)call shared LUT init functions
      _out.replace("$(CALL_LUT_SHARED)", sCallLUTShared);

      if(b_use_int_module)
      {
         addMulsw(sIntFunctions);  // static inline int mulsw() impl + Dmulsw_shr macro OR script function Dmulsw_shr() (int mode)

         if(b_use_sine_tbl_i && !b_export_c)
            sIntFunctions.append("\nIntArray *cycle_sine_tbl_i;\n");

         if(b_use_bts_int)
         {
            addBipolarToScale_int(sIntFunctions);
         }
      }
      sHeader.replace("$(INT_FUNCTIONS)", sIntFunctions);

      _out.replace("$(HEADER)", sHeader);

      _out.trim();
      _out.append("\n");

      return true;
   }

   // <method.png>
   public method setExportC(String _prefix) { //, String _varPrefix) {
      // for next emitInt() call
      if(null != _prefix)
      {
         b_export_c = true;
         export_c_prefix <= Object(_prefix);
         // // export_c_var_prefix <= Object(_varPrefix);
      }
      else
      {
         b_export_c = false;
         export_c_prefix <= "";
         // // export_c_var_prefix <= "";
      }
   }

   // <method.png>
   public static WriteIntArrayData(String _out, IntArray _ia) {
      int idx = 0;
      loop(_ia.numElements)
      {
         _out.append(_ia[idx]);
         _out.append(", ");
         if(0 == (++idx & 31))
            _out.append("\n");
      }
      _out.append("};\n");
   }

   // <method_find.png>
   public method findZoneSampleByIndex(int _zoneIdx) : StSample {
      String zoneId <= zone_refs.get(_zoneIdx);
      if(null != zoneId)
      {
         Sample *zoneSmp;
         String zoneSmpId <= zone_smp_refs.get(_zoneIdx);
         if(zoneSmpId.isBlank())
            zoneSmp <= parent_sample;
         else
            zoneSmp <= current_project.findSampleByUniqueName(zoneSmpId);

         if(null != zoneSmp)
         {
            StSample s <= zoneSmp.findZoneByName(zoneId);
            if(null == s)
               s <= zoneSmp.getZoneByIdx(int(zoneId));
            return s;
         }
      }
      return null;
   }

   // <method_find.png>
   public method findZoneParentSampleByIndex(int _zoneIdx) : Sample {
      String zoneId <= zone_refs.get(_zoneIdx);
      if(null != zoneId)
      {
         Sample *zoneSmp;
         String zoneSmpId <= zone_smp_refs.get(_zoneIdx);
         if(zoneSmpId.isBlank())
            zoneSmp <= parent_sample;
         else
            zoneSmp <= current_project.findSampleByUniqueName(zoneSmpId);

         if(null != zoneSmp)
            return zoneSmp;
      }
      return null;
   }

   // <method_add.png>
   public method addUniquePluginWaveformRef(Sample _smp, StSample _zone) : CyPluginWaveformRef {
      CyPluginWaveformRef *ref;
      foreach ref in plugin_waveform_refs
      {
         if(@(ref.sample) == @(_smp))
         {
            ref.addUniqueZoneRef(_zone);  // for debug info (source comment)
            return ref;
         }
      }
      // Add new reference
      ref <= new CyPluginWaveformRef;
      ref.init(_smp, _zone);
      plugin_waveform_refs.add(#(deref ref));
      return ref;
   }

   // <method.png>
   public method emitPluginWaveforms(Sample _buf) {
      CyPluginWaveformRef *ref;
      foreach ref in plugin_waveform_refs
         ref.emitSampleData(_buf);
   }

   // <method.png>
   protected method addMulsw(String _out) {
      if(b_export_c)
      {
         // (note) neither vbcc nor gcc generate mulsw for ((short_x * short_y)>>1) pattern
         _out.append("\n"
                     "#ifdef AMIGA\n"
                     "static inline int mulsw(short b,short c) {\n"
                     "   int a;\n"
                     "   asm(\"mulsw %2,%0\":\"=d\"(a): \"0\"(c),\"d\"(b): \"cc\");\n"
                     "   return a;\n"
                     "}\n"
                     "#else\n"
                     "static inline int mulsw(short b,short c) {\n"
                     "  return b * c;\n"
                     "}\n"
                     "#endif // AMIGA\n"
                     "#define Dmulsw_shr(A,B) (mulsw(A, B) >> "+FX_SHR+")\n"
                     // // "#define Dfrac(A) ((A) & "+FX_FRAC+")\n"
                     "\n"
                     );
      }
      else
      {
         _out.append("function Dmulsw(Short A, Short B) { return (A * int(B)); }\n");
         _out.append("function Dmulsw_shr(Short A, Short B) { return (A * int(B)) >> "+FX_SHR+"; }\n");
      }
   }

   // <method.png>
   protected method addFloatUtilityFunctions(String sHeader) {

      if(b_export_c)
      {
         if(b_use_log)
         {
            // (note) based on public domain ln() code by Lingdong Huang <https://gist.github.com/LingDong-/7e4c4cae5cbbc44400a05fba65f06f23>
            sHeader.append("\nstatic float mathLogf(const float _x) {\n");
            sHeader.append("   union {\n");
            sHeader.append("      float f;\n");
            sHeader.append("      unsigned int u;\n");
            sHeader.append("   } bx;\n");
            sHeader.append("   bx.f = _x;\n");
            sHeader.append("   const unsigned int ex = bx.u >> 23;\n");
            sHeader.append("   const signed int t = (signed int)ex - (signed int)127;\n");
            sHeader.append("   const unsigned int s = (t < 0) ? (-t) : t;\n");
            sHeader.append("   bx.u = 1065353216u | (bx.u & 8388607u);\n");
            sHeader.append("   return\n");
            // sHeader.append("#if 0
            // sHeader.append("      /* less accurate */
            // sHeader.append("      -1.49278f + (2.11263f + (-0.729104f + 0.10969f*bx.f)*bx.f)*bx.f\n");
            // sHeader.append("#else
            // sHeader.append("      /* OR more accurate */
            sHeader.append("      -1.7417939f + (2.8212026f + (-1.4699568f + (0.44717955f - 0.056570851f * bx.f)*bx.f)*bx.f)*bx.f\n");
            // sHeader.append("#endif
            sHeader.append("      + 0.6931471806f * t;\n");
            sHeader.append("}\n");
         }

         if(b_use_pow)
         {
            sHeader.append("\nstatic float mathPowerf(float _x, float _y) {\n");
            sHeader.append("   float r;\n");
            sHeader.append("   if(_y != 0.0f)\n");
            sHeader.append("   {\n");
            sHeader.append("      if(_x < 0.0f)\n");
            sHeader.append("      {\n");
            sHeader.append("         r = (float)( -expf(_y*mathLogf(-_x)) );\n");
            sHeader.append("      }\n");
            sHeader.append("      else if(_x > 0.0f)\n");
            sHeader.append("      {\n");
            sHeader.append("         r = (float)( expf(_y*mathLogf(_x)) );\n");
            sHeader.append("      }\n");
            sHeader.append("      else\n");
            sHeader.append("      {\n");
            sHeader.append("         r = 0.0f;\n");
            sHeader.append("      }\n");
            sHeader.append("   }\n");
            sHeader.append("   else\n");
            sHeader.append("   {\n");
            sHeader.append("      r = 1.0f;\n");
            sHeader.append("   }\n");
            sHeader.append("   return Dstplugin_fix_denorm_32(r);\n");
            sHeader.append("}\n");
         }

         if(b_use_lle)
         {
            sHeader.append("\nstatic float mathLogLinExpf(float _f, float _c) {\n");
            sHeader.append("   // c: <0: log\n");
            sHeader.append("   //     0: lin\n");
            sHeader.append("   //    >0: exp\n");
            sHeader.append("   stplugin_fi_t uSign;\n");
            sHeader.append("   uSign.f = _f;\n");
            sHeader.append("   stplugin_fi_t u;\n");
            sHeader.append("   u.f = _f;\n");
            sHeader.append("   u.u &= 0x7fffFFFFu;\n");
            sHeader.append("   u.f = powf(u.f, powf(2.0f, _c));\n");
            sHeader.append("   u.u |= uSign.u & 0x80000000u;\n");
            sHeader.append("   return u.f;\n");
            sHeader.append("}\n");
         }

         if(b_use_wrapf)
         {
            sHeader.append("\nstatic float mathWrapf(float _a, float _b, float _c) {\n");
            sHeader.append("   float b, c;\n");
            sHeader.append("   if(_b < _c)\n");
            sHeader.append("   {\n");
            sHeader.append("      b = _b;\n");
            sHeader.append("      c = _c;\n");
            sHeader.append("   }\n");
            sHeader.append("   else\n");
            sHeader.append("   {\n");
            sHeader.append("      b = _c;\n");
            sHeader.append("      c = _b;\n");
            sHeader.append("   }\n");
            sHeader.append("   float r = (c - b);\n");
            sHeader.append("   if(0.0f != r)\n");
            sHeader.append("   {\n");
            sHeader.append("      if(_a < b)\n");
            sHeader.append("      {\n");
            sHeader.append("         float d = b - _a;\n");
            sHeader.append("         if(d > r)\n");
            sHeader.append("            d = d - r * floorf(d / r);\n");
            sHeader.append("         if(d <= STPLUGIN_FLT_EPSILON)\n");
            sHeader.append("            return b;\n");
            sHeader.append("         return c - d;\n");
            sHeader.append("      }\n");
            sHeader.append("      else\n");
            sHeader.append("      {\n");
            sHeader.append("         float d = _a - b;\n");
            sHeader.append("         if(d >= r)\n");
            sHeader.append("            d = d - r * floorf(d / r);\n");
            sHeader.append("         return b + d;\n");
            sHeader.append("      }\n");
            sHeader.append("   }\n");
            sHeader.append("   // b == c\n");
            sHeader.append("   return _b;\n");
            sHeader.append("}\n");
         }

         if(b_use_foldf)
         {
            sHeader.append("\nstatic float mathFoldf(float _a, float _b, float _c) {\n");
            sHeader.append("   float b, c;\n");
            sHeader.append("   if(_b < _c)\n");
            sHeader.append("   {\n");
            sHeader.append("      b = _b;\n");
            sHeader.append("      c = _c;\n");
            sHeader.append("   }\n");
            sHeader.append("   else\n");
            sHeader.append("   {\n");
            sHeader.append("      b = _c;\n");
            sHeader.append("      c = _b;\n");
            sHeader.append("   }\n");
            sHeader.append("   float r = (c - b);\n");
            sHeader.append("   if(0.0f != r)\n");
            sHeader.append("   {\n");
            sHeader.append("      if(_a < b)\n");
            sHeader.append("      {\n");
            sHeader.append("         float d = b - _a;\n");
            sHeader.append("         if(d < r)\n");
            sHeader.append("         {\n");
            sHeader.append("            return b + d;\n");
            sHeader.append("         }\n");
            sHeader.append("         else\n");
            sHeader.append("         {\n");
            sHeader.append("            const float dr = d / r;\n");
            sHeader.append("            d = d - r * floorf(dr);\n");
            sHeader.append("            const int num = (int)dr;\n");
            sHeader.append("            if(num & 1)\n");
            sHeader.append("               return c - d;\n");
            sHeader.append("            return b + d;\n");
            sHeader.append("         }\n");
            sHeader.append("      }\n");
            sHeader.append("      else if(_a >= c)\n");
            sHeader.append("      {\n");
            sHeader.append("         float d = _a - c;\n");
            sHeader.append("         if(d < r)\n");
            sHeader.append("         {\n");
            sHeader.append("            return c - d;\n");
            sHeader.append("         }\n");
            sHeader.append("         else\n");
            sHeader.append("         {\n");
            sHeader.append("            const float dr = d / r;\n");
            sHeader.append("            d = d - r * floorf(dr);\n");
            sHeader.append("            const int num = (int)dr;\n");
            sHeader.append("            if(num & 1)\n");
            sHeader.append("               return b + d;\n");
            sHeader.append("            return c - d;\n");
            sHeader.append("         }\n");
            sHeader.append("      }\n");
            sHeader.append("      return _a;\n");
            sHeader.append("   }\n");
            sHeader.append("   // b == c\n");
            sHeader.append("   return b;\n");
            sHeader.append("}\n");
         }
      }

      if(b_use_bts)
      {
         if(b_export_c)
         {
            sHeader.append("\nstatic float loc_bipolar_to_scale(const float _t, const float _div, const float _mul) {\n");
            sHeader.append("   // t (-1..1) => /_div .. *_mul\n");
            sHeader.append("   \n");
            sHeader.append("   float s;\n");
            sHeader.append("\n");
            sHeader.append("   if(_t < 0.0f)\n");
            sHeader.append("   {\n");
            sHeader.append("      s = (1.0f / _div);\n");
            sHeader.append("      s = 1.0f + (s - 1.0f) * -_t;\n");
            sHeader.append("      if(s < 0.0f)\n");
            sHeader.append("         s = 0.0f;\n");
            sHeader.append("   }\n");
            sHeader.append("   else\n");
            sHeader.append("   {\n");
            sHeader.append("      s = _mul;\n");
            sHeader.append("      s = 1.0f + (s - 1.0f) * _t;\n");
            sHeader.append("   }\n");
            sHeader.append("   \n");
            sHeader.append("   return s;\n");
            sHeader.append("}\n");
         }
         else
         {
            sHeader.append("\nfunction loc_bipolar_to_scale(float _t, float _div, float _mul) {\n");
            sHeader.append("   // t (-1..1) => /_div .. *_mul\n");
            sHeader.append("   \n");
            sHeader.append("   float s;\n");
            sHeader.append("\n");
            sHeader.append("   if(_t < 0.0f)\n");
            sHeader.append("   {\n");
            sHeader.append("      s = (1.0f / _div);\n");
            sHeader.append("      s = 1.0f + (s - 1.0f) * -_t;\n");
            sHeader.append("      if(s < 0.0f)\n");
            sHeader.append("         s = 0.0f;\n");
            sHeader.append("   }\n");
            sHeader.append("   else\n");
            sHeader.append("   {\n");
            sHeader.append("      s = _mul;\n");
            sHeader.append("      s = 1.0f + (s - 1.0f) * _t;\n");
            sHeader.append("   }\n");
            sHeader.append("   \n");
            sHeader.append("   return s;\n");
            sHeader.append("}\n");
         }
      }
   }

   // <method.png>
   protected method addBipolarToScale_int(String sHeader) {
      if(b_export_c)
      {
         sHeader.append("\n");
         if(!b_export_c_no_static)
            sHeader.append("static ");
         sHeader.append("short loc_bipolar_to_scale_int(const short _t, const short _divScl, const short _mul) {\n");
      }
      else
         sHeader.append("\nfunction loc_bipolar_to_scale_int(Short _t, Short _divScl, Short _mul) {\n");

      sHeader.append("   // t (-1..1) => *_divScl .. *_mul\n");
      sHeader.append("\n");
      sHeader.append("   "+short_type+" s;\n");
      sHeader.append("\n");
      sHeader.append("   if(_t < 0)\n");
      sHeader.append("   {\n");
      sHeader.append("      s = "+int(FX_ONE)+" + Dmulsw_shr(_divScl - "+int(FX_ONE)+", -_t);\n");
      sHeader.append("      if(s < 0)\n");
      sHeader.append("         s = 0;\n");
      sHeader.append("   }\n");
      sHeader.append("   else\n");
      sHeader.append("   {\n");
      sHeader.append("      s = "+int(FX_ONE)+" + Dmulsw_shr(_mul - "+int(FX_ONE)+", _t);\n");
      sHeader.append("   }\n");
      sHeader.append("   \n");
      sHeader.append("   return s;\n");
      sHeader.append("}\n");
   }

   // <method.png>
   public method emitInt(String _out, int _loopOffset,
                         String _exportCCallBuf,
                         String _exportCStaticInit,
                         int    _exportCFrameOffset,
                         int    _exportCFrameNum,
                         Sample _exportCSample
                         ) : boolean {

      if(b_plugin)// && plugin_id.isBlank())
         return false;

      b_export_c_no_static = true;

      b_lofi = true;

      boolean bFirstPatch = _out.isBlank();

      local String sDitherTbl;  // $(DITHER_TBL)

      if(b_export_c)
         oversample_factor = 1.0;

      if(0)
      {
         short_type  <= b_export_c ? "short" : "int";
         ushort_type <= b_export_c ? "unsigned short" : "int";
      }
      else
      {
         short_type  <= b_export_c ? "short" : "Short";
         // ushort_type <= b_export_c ? "unsigned short" : "UnsignedInteger";
         ushort_type <= b_export_c ? "unsigned short" : "int";
      }
      clamp_fun   <= b_export_c ? "clamp" : "mathClampi";

      updateNoteFreq();

      int maxXFadeFrames = _loopOffset + num_skip_frames;
      if(xfade_percent > 0.0)
         xfade_frames = maxXFadeFrames * xfade_percent;
      xfade_frames = mathClampi(xfade_frames, 0, mathMini(maxXFadeFrames, MAX_XFADE_FRAMES));

      next_tmp_var_idx = 0;
      s_var_decl.empty();
      s_init.empty();
      s_cycle_reset.empty();

      local String sInitMain;  // for VPL noteOn
      local String sStaticInit;

      // Tmp var
      if(bFirstPatch)
      {
         if(b_export_c)
         {
            if(b_export_c_no_static)
            {
               _out.append("#define tmp_i "+export_c_prefix+"_tmp_i\n");
               _out.append("#define tmp2_i "+export_c_prefix+"_tmp2_i\n");
            }
            else
            {
               _out.append("static ");
            }
            if(b_export_c_no_static)
            {
               _out.append(short_type+" "+export_c_prefix+"_tmp_i;\n");
               _out.append(short_type+" "+export_c_prefix+"_tmp2_i;\n");
            }
            else
            {
               _out.append(short_type+" tmp_i;\n");
               _out.append(short_type+" tmp2_i;\n");
            }
         }
         else
         {
            _out.append(short_type+" tmp_i;\n");
            _out.append(short_type+" tmp2_i;\n");
         }

         if(b_export_c)
         {
            _out.append("#define loop(x)  for(unsigned short i = 0u; i < (x); i++)\n");
            _out.append("#define clamp(a,b,c) (((a)<(b))?(b):(((a)>(c))?(c):(a)))\n");
         }

         addMulsw(_out);  // static inline int mulsw() impl + Dmulsw_shr macro OR script function Dmulsw_shr()

      } // if bFirstPatch

      // Sine table
      if(b_export_c)
      {
         if(bFirstPatch)
         {
            _out.append("extern short cycle_sine_tbl_i[16384];\n");
            _out.append("extern short cycle_xfade_buf["+MAX_XFADE_FRAMES+"];\n");

            _out.append("$(DITHER_TBL)");
         }

         // (note) only exported once and saved to "sine16384.c"
         if(0)
         {
            _out.append("short cycle_sine_tbl_i[16384] = {\n");
            WriteIntArrayData(_out, int_sine_tbl);
         }

         if(dither_mode > 0)
         {
            if(sDitherTbl.isBlank())
            {
               if(!b_export_c_no_static)
                  sDitherTbl.append("static ");
               sDitherTbl.append("const short dither_tbl[256] = "+(dither_tbl.getString().replaceChar('[','{').replaceChar(']','}'))+";\n");
            }
         }
      }
      else
      {
         _out.append("IntArray *cycle_sine_tbl_i;\n");

         if(dither_mode > 0)
            _out.append("IntArray dither_tbl = "+dither_tbl.getString()+";\n");
      }


      // XFade buf
      int xfadeStartFrameCapture;
      int xfadeStartFrameFade;
      float xfadeStep;
      if(xfade_frames > 0)
      {
         if(b_export_c)
         {
            // (note) declared above ^^
         }
         else
         {
            _out.append("IntArray *cycle_xfade_buf;\n");
         }
         xfadeStartFrameCapture = (maxXFadeFrames - xfade_frames) * oversample_factor;
         xfadeStartFrameFade = mathMaxi(0, num_skip_frames + num_frames - xfade_frames) * oversample_factor;
         xfadeStep = (1.0 / (xfade_frames * oversample_factor));
      }

      // StVoicePlugin refs
      if(vpl_modules.numElements > 0)
      {
         _out.append("FloatArray vpl_iobuf;  // interleaved l/r frame\n");
         int vplIdx = 0;
         CyModuleVpl *modVpl;
         foreach modVpl in vpl_modules
         {
            _out.append("StPluginVoice *vpl_voice_"+vplIdx+";\n");
            sInitMain.append("   vpl_voice_"+vplIdx+".noteOn(false/*bGlide*/, 60/*note*/, 1.0/*vel*/);\n");
            vplIdx++;
         }
      }

      // Info header
      _out.append("\n\n//  sample_rate: "+sample_rate+"\n");
      if(1.0 != oversample_factor)
         _out.append("//   oversample: "+oversample_factor+"\n");
      _out.append("//    note_freq: "+note_freq+"\n");
      _out.append("//      #frames: "+num_frames+"\n");
      if(0 != num_skip_frames)
         _out.append("// #skip_frames: "+num_skip_frames+"\n");
      if(0 != xfade_frames)
         _out.append("//        xfade: "+xfade_frames+"\n");
      _out.append("\n");

      // Curve vars
      String *curveId;
      int curveIdx = 0;
      foreach curveId in curve_aliases
      {
         if(!curveId.isBlank())
         {
            if(b_export_c)
            {
               IntArray ia <= curve_intarrays.get(curveIdx);
               if(!b_export_c_no_static)
                  _out.append("static ");
               _out.append("short curve_"+curveIdx+export_c_prefix/*+export_c_var_prefix*/+"["+ia.numElements+"] = {\n");
               WriteIntArrayData(_out, ia);
            }
            else
            {
               _out.append("IntArray *curve_"+curveIdx+";\n");
            }
         }
         curveIdx++;
      }

      // Zone refs
      String *zoneId;
      int zoneIdx = 0;
      foreach zoneId in zone_refs
      {
         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("const char *zone_smp_"+zoneIdx+export_c_prefix+";\n");

            Sample *zoneSmp;
            String zoneSmpId <= zone_smp_refs.get(zoneIdx);
            if(zoneSmpId.isBlank())
               zoneSmp <= _exportCSample;
            else
               zoneSmp <= current_project.findSampleByUniqueName(zoneSmpId);

            if(null != zoneSmp)
            {
               StSample s <= zoneSmp.findZoneByName(zoneId);
               if(null == s)
                  s <= zoneSmp.getZoneByIdx(int(zoneId));
               if(null != s)
               {
                  if(zoneSmp.b_procedural)
                     _exportCCallBuf.append("   zone_smp_"+zoneIdx+export_c_prefix+" = _wfAddrProc + "+(s.lastLoopOffset+zoneSmp.export_all_c_wf_off)+";\n");
                  else
                     _exportCCallBuf.append("   zone_smp_"+zoneIdx+export_c_prefix+" = _wfAddrStatic + "+(s.lastLoopOffset+zoneSmp.export_all_c_wf_off)+";\n");
               }
               else
                  throw CyZoneNotFoundError "emitInt: zone \""+zoneId+"\" not found (zoneSmp=\""+zoneSmp.unique_name+"\")";
            }
            else
               throw CyZoneNotFoundError "emitInt: zone \""+zoneSmpId+"."+zoneId+"\" sample not found";
         }
         else
         {
            // (note) will be updated when Calc is called
            _out.append("FloatArray zone_smp_"+zoneIdx+";\n");
         }
         zoneIdx++;
      }

      // Declare vars
      CyVar *v;
      foreach v in vars
      {
         if((wt_w > 0) || !(v.id <= "wt_"))
         {
            if(b_export_c && !b_export_c_no_static)
               _out.append("static ");
            _out.append(short_type+" var_"+v.id+export_c_prefix+" = "+int(v.def_value * FX_ONE)+";\n");
         }
      }

      // Declare macro vars and field values <int>
      if(macros.numElements > 0)
         _out.append("\n");
      CyMacro *macro;
      foreach macro in macros
      {
         String *macroFieldName;
         foreach macroFieldName in macro.field_names
         {
            if(b_export_c && !b_export_c_no_static)
               _out.append("static ");
            _out.append(short_type+" macrovar_"+macro.id+"_"+macroFieldName+export_c_prefix+" = 0;\n");
         }

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("const "+short_type+" macrovalues_"+macro.id+"[("+macro.getNumMacroRows()+" * "+macro.getNumMacroFields()+")/*"+macro.getNumMacroValues()+"*/] = {\n");
         }
         else
            _out.append("IntArray macrovalues_"+macro.id+" = [\n");
         macro.emitFieldValuesInt(_out);
         if(b_export_c)
            _out.append("};\n\n");
         else
            _out.append("];\n\n");
      }

      // Declare map vars and field values <int>
      if(maps.numElements > 0)
      {
         _out.append("\n");
         // // if(b_plugin)
         // //    sPluginVarDecls.append("\n");
      }
      CyMap *map;
      foreach map in maps
      {
         String *mapFieldName;
         foreach mapFieldName in map.field_names
         {
            if(b_export_c && !b_export_c_no_static)
               _out.append("static ");
            _out.append(short_type+" mapvar_"+map.id+"_"+mapFieldName+export_c_prefix+" = 0;\n");
         }

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("const "+short_type+" mapvalues_"+map.id+"[("+map.getNumMapRows()+" * "+map.getNumMapFields()+")/*"+map.getNumMapValues()+"*/] = {\n");
         }
         else
            _out.append("IntArray mapvalues_"+map.id+" = [\n");
         map.emitFieldValuesInt(_out);
         if(b_export_c)
            _out.append("};\n\n");
         else
            _out.append("];\n\n");

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("const "+short_type+" mapkeys_"+map.id+"["+map.getNumMapRows()+"] = {\n");
         }
         else
            _out.append("IntArray mapkeys_"+map.id+" = [\n");
         map.emitRowKeysInt(_out);
         if(b_export_c)
            _out.append("};\n\n");
         else
            _out.append("];\n\n");

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("const "+short_type+" mapdeltalin_"+map.id+"["+(map.getNumMapRows() - 1)+"] = {\n");
         }
         else
            _out.append("FloatArray mapdeltalin_"+map.id+" = [\n");
         map.emitRowKeysDeltaLinInt(_out);
         if(b_export_c)
            _out.append("};\n\n");
         else
            _out.append("];\n\n");
      }

      // Declare plugin params
      //  (todo) remove this, plugins are always emitted in hi-fi/float mode
      CyPluginParam *pluginParam;
      foreach pluginParam in plugin_params
      {
         if(b_export_c)
            _out.append("static ");
         _out.append(short_type+" param_"+pluginParam.id+export_c_prefix+" = "+int(FX_ONE * pluginParam.def_value)+";\n");
      }
      if(plugin_params.numElements > 0)
         _out.append("\n");

      // Declare plugin mods
      //  (todo) remove this, plugins are always emitted in hi-fi/float mode
      CyPluginMod *pluginMod;
      foreach pluginMod in plugin_mods
      {
         if(b_export_c)
            _out.append("static ");
         _out.append(short_type+" mod_"+pluginMod.id+export_c_prefix+" = 0;\n");
      }
      if(plugin_mods.numElements > 0)
         _out.append("\n");


      // Init code placeholder
      _out.append("$(VAR_DECLS)");
      // _out.append("\n");

      // Float-fallback utility functions placeholder
      _out.append("$(FLOAT_FUNCTIONS)");
      local String sFloatFunctions;

      if(b_export_c)
      {
         _exportCCallBuf.append("   "+Utils.AlignString("calc"+export_c_prefix, 45)+"(_wfAddrProc + "+Utils.AlignStringRight(String(_exportCFrameOffset), 6)+");  // total="+Utils.AlignStringRight(String(_exportCFrameNum),6)+" ("+Utils.AlignStringRight(int(100*_exportCFrameNum/1024.0)/100.0, 5)+"k)"+((wt_w>0)?(" wt_"+wt_w+"x"+wt_h+"x"+num_frames):"")+"\n");
      }

      CyLane *lane;
      CyModule *mod;
      int modIdx;
      local String modBuf;
      boolean bHaveInit = false;
      boolean bHaveWTInit = false;
      local String sInitIndent;
      local String sInitLUT;
      local String sDeclLUT;
      boolean bFirstLutLane;
      local String sCallLUTShared;

      CyLane *lutLane;
      String *lutId;
      CyLUT *lut;
      String sLutCalc <= _out;

      // Emit shared LUT init lanes
      bFirstLutLane = true;
      foreach lutLane in lanes
      {
         lutId <= lutLane.id.replace("lut_","");
         lut <= findLUTById(lutId);
         if(null != lut)
         {
            sInitLUT.append("\n");

            CyLUT invLUT <= lutLane.inv_lut_ref;
            local String *sInvLUT;

            String sLutInitFxnName <= lut.b_voice ? ("loc_update_lut_"+lutId) : ("loc_calc_lut_"+lutId);
            if(b_export_c)
            {
               _out.append("\nstatic short loc_lut_"+lutId+export_c_prefix+"["+lut.lut_w+"];\n");
               if(null != invLUT && @(invLUT) != @(lut))
                  _out.append("\nstatic short loc_lut_"+invLUT.id+export_c_prefix+"["+invLUT.lut_w+"];\n");
            }
            else
            {
               _out.append("\nIntArray lut_"+lutId+"; lut_"+lutId+export_c_prefix+".alloc("+lut.lut_w+");\n");
               if(null != invLUT && @(invLUT) != @(lut))
                  _out.append("\nIntArray lut_"+invLUT.id+export_c_prefix+"; lut_"+invLUT.id+export_c_prefix+".alloc("+invLUT.lut_w+");\n");
            }

            if(b_export_c)
               _out.append("\nstatic void "+sLutInitFxnName+"(short *_d) {\n");
            else
               _out.append("\nfunction "+sLutInitFxnName+"(IntArray _d) {\n");

            sLutCalc.append("$(INIT)");
            sLutCalc.append("$(GLOBAL_RESET)");
            sLutCalc.append("$(CYCLE_RESET)");

            if(null != invLUT)
            {
               // Fill inverse LUT
               invLUT <= lutLane.inv_lut_ref;
               sInvLUT <= "lut_"+invLUT.id+export_c_prefix;
               sLutCalc.append("   int invLUTIdx = 0;\n");
               if(b_export_c)
               {
                  sLutCalc.append("   loop("+invLUT.lut_w+")\n");
                  sLutCalc.append("   {\n");
                  sLutCalc.append("      "+sInvLUT+"[invLUTIdx++] = -32768;\n");
                  sLutCalc.append("   }\n\n");
               }
               else
               {
                  sLutCalc.append("   "+sInvLUT+".useAll();\n");
                  sLutCalc.append("   "+sInvLUT+".fill(-32768);\n");
               }
            }

            int lutXStep = int( (1 << 30) / (lut.lut_w - 1) );
            // // trace "xxx int lutXStep="+lutXStep;
            sLutCalc.append("   int xx = 0;\n");
            // // // sLutCalc.append("   "+short_type+" x = 0;\n");
            if(!b_export_c)
            {
               if(null == invLUT || @(invLUT) != @(lut))
                  sLutCalc.append("   lut_"+lutId+export_c_prefix+".empty();\n");
            }
            sLutCalc.append("   loop("+lut.lut_w+")\n");
            sLutCalc.append("   {\n");
            sLutCalc.append("$(TMPVARDECL)");
            if(b_export_c)
               sLutCalc.append("      "+short_type+" x = ("+short_type+")(xx >> "+(30 - FX_SHR)+");\n");
            else
               sLutCalc.append("      "+short_type+" x = (xx >> "+(30 - FX_SHR)+");\n");
            sLutCalc.append("      "+short_type+" out = x;\n");
            modIdx = 0;
            setTmpVarContext(lutLane.id);
            if(STConfig.b_cycle_tree_debug)
            {
               trace "[trc] CyScript::emitInt: lutLane.id="+lutLane.id+" tree=";
               lutLane.debugPrintTree(0/*level*/);
            }
            foreach mod in lutLane.modules
            {
               modBuf.empty();
               modBuf.append("// -------- lane \""+lutLane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
               mod.emitIntSequence(this, modBuf, "out");
               AppendIndentedLines(sLutCalc, modBuf, 6);
               modIdx++;
            }
            if(!lutLane.b_end)
            {
               if(b_export_c)
               {
                  sLutCalc.append("      _d[i] = out;\n");
                  // sLutCalc.append("      printf(\"xxx d[%u]=%f  x=%f\\n\", i-1, _d[i-1], x);\n");
               }
               else
                  sLutCalc.append("      _d.add(out);\n");
            }
            sLutCalc.append("\n      // Next x\n");
            sLutCalc.append("      xx += "+lutXStep+";\n");
            sLutCalc.append("   } // loop "+lut.lut_w+"\n");

            if(null != invLUT)
            {
               // Close gaps in inverse LUT
               sLutCalc.append("\n");
               sLutCalc.append("   "+short_type+" invLUTLast = 0;\n");
               sLutCalc.append("   invLUTIdx = 0;\n");
               sLutCalc.append("   loop("+invLUT.lut_w+")\n");
               sLutCalc.append("   {\n");
               sLutCalc.append("      if(-32768 == "+sInvLUT+"[invLUTIdx])\n");
               sLutCalc.append("         "+sInvLUT+"[invLUTIdx] = invLUTLast;\n");
               sLutCalc.append("      else\n");
               sLutCalc.append("         invLUTLast = "+sInvLUT+"[invLUTIdx];\n");
               sLutCalc.append("      invLUTIdx++;\n");
               sLutCalc.append("   }\n\n");
            }

            sLutCalc.replace("$(TMPVARDECL)", s_tmp_var_decl);

            sLutCalc.append("} /* end "+sLutInitFxnName+"() */\n");

            sInitIndent.empty();
            AppendIndentedLines(sInitIndent, s_init, 3);
            sLutCalc.replace("$(INIT)", sInitIndent);
            s_init.empty();

            s_global_reset.append(s_alloc_reset);
            s_alloc_reset.empty();

            sLutCalc.replace("$(GLOBAL_RESET)", s_global_reset);
            s_global_reset.empty();

            sLutCalc.replace("$(CYCLE_RESET)", s_cycle_reset);
            s_cycle_reset.empty();

            // Call shared LUT initializer
            String sLUTSharedIndent <= "   ";
            if(b_export_c)
               sCallLUTShared.append(sLUTSharedIndent+"loc_calc_lut_"+lutId+export_c_prefix+"(loc_lut_"+lutId+");\n");
            else
               sCallLUTShared.append(sLUTSharedIndent+"loc_calc_lut_"+lutId+"(lut_"+lutId+");\n");

            bFirstLutLane = false;

         } // if lut
      } // foreach lutLane

      // Emit init lane ("<init")
      lane <= findLaneById("init");
      if(null != lane)
      {
         if(!b_plugin)
            _out.append("\n");

         setTmpVarContext("Init");

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("void init"+export_c_prefix+"(void) {\n");
         }
         else
            _out.append("function Init() {\n");

         _out.append("$(TMPVARDECL)");

         _out.append("$(INIT)");
         _out.append("$(GLOBAL_RESET)");
         _out.append("$(CYCLE_RESET)");

         _out.append("   "+short_type+" out = 0;\n");

         modIdx = 0;
         if(STConfig.b_cycle_tree_debug)
         {
            trace "[trc] CyScript::emitInt: lane.id="+lane.id+" tree=";
            lane.debugPrintTree(0/*level*/);
         }
         foreach mod in lane.modules
         {
            modBuf.empty();
            modBuf.append("// -------- lane \""+lane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
            mod.emitIntSequence(this, modBuf, "out");
            AppendIndentedLines(_out, modBuf, 3);
            modIdx++;
         }
         _out.append("}\n");

         sInitIndent.empty();
         AppendIndentedLines(sInitIndent, s_init, 3);
         _out.replace("$(INIT)", sInitIndent);
         s_init.empty();

         _out.replace("$(GLOBAL_RESET)", s_global_reset);
         s_global_reset.empty();

         _out.replace("$(CYCLE_RESET)", s_cycle_reset);
         s_cycle_reset.empty();

         _out.replace("$(TMPVARDECL)", s_tmp_var_decl);

         _out.append("\n");

         bHaveInit = true;
      }

      // Emit wavetable init lane ("<wt_init")
      lane <= findLaneById("wt_init");
      if(null == lane)
         lane <= findLaneById("prepare");
      if(null != lane)
      {
         if(!b_plugin)
            _out.append("\n");

         setTmpVarContext(lane.id);

         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("void wt_init"+export_c_prefix+"(void) {\n");
         }
         else
            _out.append("function WT_Init() {\n");

         _out.append("$(TMPVARDECL)");

         _out.append("$(INIT)");
         _out.append("$(GLOBAL_RESET)");
         _out.append("$(CYCLE_RESET)");

         _out.append("   "+short_type+" out = 0;\n");

         modIdx = 0;
         if(STConfig.b_cycle_tree_debug)
         {
            trace "[trc] CyScript::emitInt: lane.id="+lane.id+" tree=";
            lane.debugPrintTree(0/*level*/);
         }
         foreach mod in lane.modules
         {
            modBuf.empty();
            modBuf.append("// -------- lane \""+lane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
            mod.emitIntSequence(this, modBuf, "out");
            AppendIndentedLines(_out, modBuf, 3);
            modIdx++;
         }

         _out.replace("$(TMPVARDECL)", s_tmp_var_decl);

         _out.append("}\n");

         sInitIndent.empty();
         AppendIndentedLines(sInitIndent, s_init, 3);
         _out.replace("$(INIT)", sInitIndent);
         s_init.empty();

         _out.replace("$(GLOBAL_RESET)", s_global_reset);
         s_global_reset.empty();

         _out.replace("$(CYCLE_RESET)", s_cycle_reset);
         s_cycle_reset.empty();

         _out.append("\n");

         bHaveWTInit = true;
      }

      // Emit audio lanes
      int laneIdx = -1;
      int audioLaneNr = 0;
      boolean bFirstLane = true;
      for(;;)
      {
         lane <= lanes.get(++laneIdx);
         if(null != lane)
         {
            if("init" != lane.id && !(lane.id <= "lut_"))
            {
               audioLaneNr++;

               if(bFirstLane)
               {
                  if(wt_w > 0)
                  {
                     setTmpVarContext("Calc_Cycle");

                     if(b_export_c)
                     {
                        if(!b_export_c_no_static)
                           _out.append("static ");
                        _out.append("void calc_cycle"+export_c_prefix+"(char *_d) {\n");
                     }
                     else
                        _out.append("function Calc_Cycle(FloatArray _d) {\n");
                     _out.append("$(TMPVARDECL)");
                     _out.append("$(INIT)\n");
                     _out.append("$(CYCLE_RESET)");

                     if(bHaveWTInit)
                     {
                        if(b_export_c)
                           _out.append("\n   wt_init"+export_c_prefix+"();\n");
                        else
                           _out.append("\n   WT_Init();\n");
                     }
                  }
                  else
                  {
                     setTmpVarContext("Calc");

                     if(b_export_c)
                     {
                        if(!b_export_c_no_static)
                           _out.append("static ");
                        _out.append("void calc"+export_c_prefix+"(char *_d) {\n");
                     }
                     else
                        _out.append("function Calc(FloatArray _d) {\n");
                     _out.append("$(TMPVARDECL)");
                     _out.append(sInitMain);
                     _out.append("$(INIT)");
                     _out.append("$(GLOBAL_RESET)");
                     _out.append("$(CYCLE_RESET)");  // remaining reset code (e.g. zsq patbits)

                     // <init:
                     if(bHaveInit)
                     {
                        if(b_export_c)
                           _out.append("\n   init"+export_c_prefix+"();\n");
                        else
                           _out.append("\n   Init();\n");
                     }

                     // <prepare:
                     if(bHaveWTInit)
                     {
                        if(b_export_c)
                           _out.append("\n   wt_init"+export_c_prefix+"();\n");
                        else
                           _out.append("\n   WT_Init();\n");
                     }
                  }

                  // // if(bHaveInit)
                  // // {
                  // //    if(b_export_c)
                  // //       _out.append("\n   init"+export_c_prefix+"();\n");
                  // //    else
                  // //       _out.append("\n   Init();\n");
                  // // }

                  _out.append(sCallLUTShared);

                  _out.append("   "+ushort_type+" smpIdx = 0;\n");
                  _out.append("   "+ushort_type+" outIdx = 0;\n");

                  if(dither_mode > 0)
                     _out.append("   "+short_type+" err = 0;\n");

                  if(0 != xfade_frames)
                  {
                     _out.append("   "+ushort_type+" xfadeCaptureLeft = "+xfade_frames+";\n");
                     _out.append("   "+ushort_type+" xfadeReadIdx = 0;\n");
                     _out.append("   "+short_type+" xfadeCur = 0;\n");
                     _out.append("   "+ushort_type+" xfadeCaptureIdx = 0;\n");
                  }

                  _out.append("   loop("+int((num_frames/(b_mirror?2:1) + num_skip_frames) * oversample_factor)+")\n   {\n");
                  _out.append("      "+short_type+" out = 0;\n");

               } // if bFirstLane

               boolean bIndivOut = !bFirstLane && ("out" != lane.id);

               modIdx = 0;
               if(STConfig.b_cycle_tree_debug)
               {
                  trace "[trc] CyScript::emitInt: lane.id="+lane.id+" tree=";
                  lane.debugPrintTree(0/*level*/);
               }
               foreach mod in lane.modules
               {
                  modBuf.empty();
                  modBuf.append("\n// ========\n");
                  modBuf.append("// ======== lane \""+lane.id+"\" modIdx="+modIdx+" modString="+mod.getString()+"\n");
                  modBuf.append("// ========\n");
                  if(bIndivOut)
                     modBuf.append(short_type+" out"+audioLaneNr+" = 0;\n");
                  mod.emitIntSequence(this, modBuf, bIndivOut ? ("out"+audioLaneNr) : "out");
                  AppendIndentedLines(_out, modBuf, 6);
                  modIdx++;
               }

               // sum all lanes
               if(bIndivOut && !lane.modules.isEmpty())
                  _out.append("      out += out"+audioLaneNr+";  // sum lane "+audioLaneNr+"/"+num_audio_lanes+"\n");

               bFirstLane = false;
            } // !init lane

         } // if lane
         else
            break;
      }

      if(!bFirstLane)  // any lanes ?
      {
         if(0 != xfade_frames)
         {
            modBuf.empty();
            modBuf.append("// ------ xfade ("+xfade_frames+" frames) -----\n");
            String sVarXFadeIdx <= (0 != num_skip_frames) ? "smpIdx" : "outIdx";
            modBuf.append("if("+sVarXFadeIdx+" >= "+xfadeStartFrameCapture+")\n{\n");
            modBuf.append("   if(xfadeCaptureLeft > 0)\n");
            modBuf.append("   {\n");
            modBuf.append("      cycle_xfade_buf[xfadeCaptureIdx++] = out;\n");
            modBuf.append("      xfadeCaptureLeft--;\n");
            modBuf.append("   }\n");
            modBuf.append("   else if("+sVarXFadeIdx+" >= "+xfadeStartFrameFade+")\n");
            modBuf.append("   {\n");
            if(b_export_c)
               modBuf.append("      out += mulsw((short)(cycle_xfade_buf[xfadeReadIdx++] - out), xfadeCur) >> 14;\n");
            else
               modBuf.append("      out += ((cycle_xfade_buf[xfadeReadIdx++] - out) * xfadeCur) >> 14;\n");
            modBuf.append("      xfadeCur += "+int(xfadeStep * 16384)+";\n");
            modBuf.append("   }\n");
            modBuf.append("}\n");
            AppendIndentedLines(_out, modBuf, 6);
         }

         _out.append("\n");

         _out.replace("$(TMPVARDECL)", s_tmp_var_decl);

         if(dither_mode > 0)
         {
            switch(dither_mode)
            {
               case 1:
                  // dithering    (repetitive mid-freq noise)
                  _out.append("      out += dither_tbl[outIdx & 255];\n");
                  break;

               case 2:
                  // pseudo-randomized dithering (less repetitive than mode 1)    (mid-freq noise)
                  _out.append("      out += dither_tbl[(outIdx + out) & 255];\n");
                  break;

               case 3:
                  // distortion shaping (good)  (high-freq noise)
                  _out.append("      "+short_type+" outIdeal = out;\n");
                  _out.append("      out += err;\n");
                  _out.append("      "+short_type+" outErr = outIdeal - (((out >> 4) << 4));\n");
                  _out.append("      err += outErr;\n");
                  break;

               case 4:
                  // scaled dithering (experimental)
                  _out.append("      "+short_type+" absOut = (out < 0 ? -out : out);\n");
                  _out.append("      out += Dmulsw_shr(dither_tbl[outIdx & 255], "+int(FX_ONE)+" - absOut);\n");
                  break;

               case 5:
                  // pseudo-randomized scaled dithering (less repetitive than mode 4)
                  _out.append("      "+short_type+" absOut = (out < 0 ? -out : out);\n");
                  _out.append("      out += Dmulsw_shr(dither_tbl[(outIdx+out) & 255], "+int(FX_ONE)+" - absOut);\n");
                  break;

               case 6:
                  // adaptive distortion shaping (good but very similar to 3)
                  _out.append("      "+short_type+" outIdeal = out;\n");
                  _out.append("      out += err;\n");
                  _out.append("      "+short_type+" outErr = outIdeal - (((out >> 4) << 4));\n");
                  _out.append("      "+short_type+" absOut = (out < 0 ? -out : out);\n");
                  _out.append("      outErr = Dmulsw_shr(outErr, "+FX_ONE+" - absOut);\n");
                  _out.append("      err += outErr;\n");
                  break;

               case 7:
                  // noise shaping (experimental)
                  _out.append("      out += dither_tbl[(outIdx+out) & 255];\n");
                  _out.append("      "+short_type+" outIdeal = out;\n");
                  _out.append("      out += err;\n");
                  _out.append("      "+short_type+" outErr = outIdeal - (((out >> 4) << 4));\n");
                  _out.append("      err += outErr;\n");
                  break;

               case 8:
                  // adaptive noise shaping  (experimental)  (similar to 3 but less distortion at low volumes)
                  _out.append("      "+short_type+" absOut = (out < 0 ? -out : out);\n");
                  _out.append("      out += Dmulsw_shr(dither_tbl[(outIdx+out) & 255], absOut);\n");
                  _out.append("      "+short_type+" outIdeal = out;\n");
                  _out.append("      out += err;\n");
                  _out.append("      "+short_type+" outErr = outIdeal - (((out >> 4) << 4));\n");
                  _out.append("      err += outErr;\n");
                  break;
            }

            _out.append("      if(out > 2047) out = 2047; else if(out < -2048) out = -2048;\n");
         }

         if(0 != num_skip_frames)
         {
            _out.append("      if(smpIdx++ >= "+int(num_skip_frames * oversample_factor)+")\n");
            if(b_export_c)
               _out.append("         _d[outIdx++] = (char)(out >> ("+FX_SHR+"-7));\n");
            else
               _out.append("         _d[outIdx++] = (out >> ("+FX_SHR+"-7)) * (1.0f / 128.0f);\n");
         }
         else
         {
            if(b_export_c)
               _out.append("      _d[outIdx++] = (char)(out >> ("+FX_SHR+"-7));\n");
            else
               _out.append("      _d[outIdx++] = (out >> ("+FX_SHR+"-7)) * (1.0f / 128.0f);\n");
         }
         _out.append("   } /* end loop frames */\n");

         if(b_mirror)
         {
            _out.append("\n");
            _out.append("   int mirrorSrcIdx = outIdx;\n");
            _out.append("   loop("+((num_frames/2)*oversample_factor)+")\n");
            _out.append("   {\n");
            _out.append("      _d[outIdx++] = -_d[--mirrorSrcIdx];\n");
            _out.append("   }\n");
         }

         _out.append("} /* end calc() */\n");
      }

      if(wt_w > 0)
      {
         boolean bCycleFreq = (wt_freqs.numElements > 0);
         _out.append("\n// ----- wavetable w="+wt_w+" h="+wt_h+" cyclelen="+num_frames+"\n");
         if(b_export_c)
         {
            if(!b_export_c_no_static)
               _out.append("static ");
            _out.append("void calc"+export_c_prefix+"(char *_d) {\n");
         }
         else
            _out.append("function Calc(FloatArray _d) {\n");

         setTmpVarContext("Calc_Cycle");
         _out.append("$(TMPVARDECL)");

         _out.append("   int off = 0;\n");
         _out.append("   var_wt_y"+export_c_prefix+" = 0;\n");
         _out.append(sInitMain);
         if(bCycleFreq)
         {
            int wtFreqIdx = 0;
            local FloatArray wtFreqs;
            loop(wt_w * wt_h)
            {
               wtFreqs.add(wt_freqs.get(wtFreqIdx++ % wt_freqs.numElements));
            }
            _out.append("   int freqIdx = 0;\n");
            if(b_export_c)
            {
               if(!b_export_c_no_static)
                  _out.append("   const "+short_type+" "+export_c_prefix+"_wtFreqs["+wtFreqs.numElements+"] = {\n   ");
               else
                  _out.append("   static const "+short_type+" wtFreqs["+wtFreqs.numElements+"] = {\n   ");
               float wtFreq;
               foreach wtFreq in wtFreqs
               {
                  _out.append(String(int(wtFreq * FX_ONE))+", ");
               }
               _out.append("  };\n");
            }
            else
               _out.append("   FloatArray wtFreqs = "+wtFreqs.string+";\n");
         }
         _out.append("$(GLOBAL_RESET)");
         if(bHaveInit)
         {
            if(b_export_c)
               _out.append("\n   init"+export_c_prefix+"();\n");
            else
               _out.append("\n   Init();\n");
         }
         _out.append("   loop("+wt_h+")\n");
         _out.append("   {\n");
         _out.append("      var_wt_x"+export_c_prefix+" = 0;\n");
         _out.append("      loop("+wt_w+")\n");
         _out.append("      {\n");
         if(b_export_c)
         {
            if(bCycleFreq)
               _out.append("         var_wt_freq"+export_c_prefix+" = wtFreqs[freqIdx++];\n");
            _out.append("         char *d = _d + off;\n");
            _out.append("         calc_cycle"+export_c_prefix+"(d);\n");
         }
         else
         {
            if(bCycleFreq)
               _out.append("         var_wt_freq"+export_c_prefix+" = int(wtFreqs[freqIdx++] * "+FX_ONE+");\n");
            _out.append("         FloatArray d;\n");
            _out.append("         d.visit(_d, off, "+int(num_frames * oversample_factor)+");\n");
            _out.append("         Calc_Cycle(d);\n");
         }
         if(wt_w > 1)
            _out.append("         var_wt_x"+export_c_prefix+" += "+int(FX_ONE / (wt_w-1))+";\n");
         _out.append("         off += "+int(num_frames * oversample_factor)+";\n");
         _out.append("      }\n");
         if(wt_h > 1)
            _out.append("      var_wt_y"+export_c_prefix+" += "+int(FX_ONE / (wt_h-1))+";\n");
         _out.append("   }\n");
         _out.append("}\n");
         _out.replace("$(TMPVARDECL)", s_tmp_var_decl);
      }

      _out.replace("$(VAR_DECLS)", s_var_decl);

      sInitIndent.empty();
      AppendIndentedLines(sInitIndent, s_init, 3);
      _out.replace("$(INIT)", sInitIndent);

      _out.replace("$(CYCLE_RESET)", s_cycle_reset);
      _out.replace("$(GLOBAL_RESET)", s_global_reset);

      if(b_use_float_fallback)
      {
         if(b_export_c)
            sFloatFunctions.append("\nstatic float ffrac_s(float _f) { int i; if(_f >= 0.0f) { i = (int)_f; return _f - (float)i; } else { i = (int)-_f; return 1.0f - (-_f - (float)i); } }\n");
         else
            sFloatFunctions.append("\nfunction ffrac_s(float _f) { return (_f >= 0.0f) ? frac(_f) : (1.0f + frac(_f)); }\n");

         if(b_use_pow)
            b_use_log = true;  // mathLogf() called in mathPowerf()
         addFloatUtilityFunctions(sFloatFunctions);
      }
      ////else
      if(b_use_bts_int)
      {
         addBipolarToScale_int(sFloatFunctions);
      }
      _out.replace("$(FLOAT_FUNCTIONS)", sFloatFunctions);

      _out.replace("$(DITHER_TBL)", sDitherTbl);

      if(b_export_c)
      {
         _exportCStaticInit.append(sStaticInit);
      }

      return true;
   }

   // <method_update.png>
   public method updateArgsFromHashTable(HashTable _argValues) {
      CyArg *arg;
      foreach arg in args
      {
         if(_argValues.exists(arg.id))
            arg.cur_value = _argValues[arg.id];
      }
   }

   // <method.png>
   public method run(String _src, FloatArray _d, boolean _bSetLenToDst, Sample _smp) : boolean {
      local Script sc;

      // trace "xxx load script src="+#(_src);
      // trace "xxx load script src="+_src;
      if(_src.isBlank())
         return true;
      if(sc.load(_src))
      {
         Global.Debug("CyScript::run: script compiled OK");
         Variable *v;

         // Update sine_tbl ref
         v <= sc.findVariable("cycle_sine_tbl_i");
         if(null != v)
         {
            v.pointerAssign(int_sine_tbl);
            v.store();
         }

         // Update xfade_buf ref
         v <= sc.findVariable("cycle_xfade_buf");
         if(null != v)
         {
            v.pointerAssign(b_lofi ? int_xfade_buf : float_xfade_buf);
            v.store();
         }

         // Update curve refs
         String *curveId;
         int curveIdx = 0;
         foreach curveId in curve_aliases
         {
            if(!curveId.isBlank())
            {
               v <= sc.findVariable("curve_"+curveIdx);
               v.pointerAssign(curve_intarrays[curveIdx]);
               v.store();
            }
            curveIdx++;
         }

         // Zone refs
         int zoneIdx = 0;
         String *zoneId;
         FloatArray smpAll <= _smp.waveform.sampleData;
         foreach zoneId in zone_refs
         {
            Sample *zoneSmp;
            FloatArray *zoneSmpAll;
            String zoneSmpId <= zone_smp_refs.get(zoneIdx);
            // // trace "xxx zoneSmpId=\""+zoneSmpId+"\"";
            if(zoneSmpId.isBlank())
            {
               zoneSmp <= _smp;
               zoneSmpAll <= smpAll;
            }
            else
            {
               zoneSmp <= current_project.findSampleByUniqueName(zoneSmpId);
               zoneSmpAll <= (null != zoneSmp) ? (zoneSmp.waveform.sampleData) : null;
            }

            if(null != zoneSmp)
            {
               StSample s <= zoneSmp.findZoneByName(zoneId);
               if(null == s)
                  s <= zoneSmp.getZoneByIdx(int(zoneId));
               if(null != s)
               {
                  int loopStart = s.lastLoopOffset;
                  int loopLen   = s.lastLoopLen;
                  v <= sc.findVariable("zone_smp_"+zoneIdx);
                  v.query();
                  FloatArray zoneSmpDat <= v.value;
                  zoneSmpDat.visit(zoneSmpAll, loopStart, loopLen);
                  zoneSmpDat.useAll();
                  if(b_debug0)
                     trace "[trc] update zone["+zoneIdx+"] ref: id=\""+zoneId+"\" off="+loopStart+" len="+zoneSmpDat.numElements;

                  // Next zone
                  zoneIdx++;
               }
               else
               {
                  trace "[---] CyScript::run: sample \""+zoneSmp.unique_name+"\" has no zone named \""+zoneId+"\"";
                  return false;
               }
            }
            else
            {
               trace "[---] CyScript::run: project has no sample named \""+zoneSmpId+"\"  (failed to resolve zone \""+zoneSmpId+"."+zoneId+"\")";
               return false;
            }
         }

         // StPluginVoice refs + parameter values
         CyModuleVpl *modVpl;
         int vplIdx = 0;
         foreach modVpl in vpl_modules
         {
            modVpl.loadParams();

            v <= sc.findVariable("vpl_voice_"+vplIdx);
            if(null != v)
            {
               v.setObjectValue(modVpl.voice);
               v.store();
               Global.Debug("CyScript::run: update \"vpl_voice_"+vplIdx+"\" to "+#(modVpl.voice));
            }
            else
            {
               trace "[---] CyScript::run: failed to find variable \"vpl_voice_"+vplIdx+"\"";
            }
            vplIdx++;
         }

         // trace "xxx eval script";
         // global initializers
         sc.eval();
         // trace "xxx   DONE eval script";

         if(_bSetLenToDst)
         {
            num_frames = _d.numElements;
         }
         else
         {
            _d.alloc(num_frames);
            _d.useAll();
         }

         local FloatArray renderSmp;
         local FloatArray renderSmpResample;
         int srsDlyFrames = 0;

         if(1.0 != oversample_factor)
         {
            srsDlyFrames = SpeexResampler.GetOutputDelayInFramesByQualityAndFactor(oversample_quality, oversample_factor);
            srsDlyFrames /= oversample_factor;

            renderSmp.allocAndFill((num_frames + srsDlyFrames) * oversample_factor, 0.0);
            renderSmpResample.allocAndFill(num_frames + srsDlyFrames, 0);
         }
         else
         {
            renderSmp <= _d;
         }

         // Calc()
         // trace "xxx find Calc";
         local Function f <= sc.findFunction("Calc");
         // trace "xxx find Calc f="+#(f);
         if(null != f)
         {
            try
            {
               f.eval({renderSmp});

               if(0)
               {
                  WavIO.SaveLocal("debug.wav", renderSmp, sample_rate*oversample_factor, 1/*numCh*/,
                                  Sample.KEY_MIDDLE_C/*C-5*/, 0/*loopStart*/, 0/*loopEnd*/,
                                  null/*bwfHint*/
                                  );
                  trace "[dbg] wrote \"debug.wav\"";
               }

               if(1.0 != oversample_factor)
               {
                  // (note) resampler delay:
                  //   -   4 frames at quality=0
                  //   -   8 frames at quality=1
                  //   -  16 frames at quality=2
                  //   -  24 frames at quality=3
                  //   -  32 frames at quality=4
                  //   -  40 frames at quality=5
                  //   -  48 frames at quality=6
                  //   -  64 frames at quality=7
                  //   -  80 frames at quality=8
                  //   -  96 frames at quality=9
                  //   - 128 frames at quality=10
                  local SpeexResampler srs;
                  srs.init(1/*numCh*/,
                           sample_rate * oversample_factor,
                           sample_rate,
                           oversample_quality
                           );

                  // trace "xxx resample: renderSmp.numElements="+renderSmp.numElements+" num_frames_os="+int(num_frames*oversample_factor);
                  // trace "xxx resample: d.numElements="+_d.numElements+" num_frames="+num_frames;

                  srs.process(0/*chIdx*/,
                              renderSmp, (num_frames + srsDlyFrames) * oversample_factor,
                              renderSmpResample, num_frames + srsDlyFrames
                              );
                  _d.copyFrom(renderSmpResample, srsDlyFrames, num_frames, 0);
                  srs.exit();
                  renderSmp.free();
               }

               // Succeeded
               return true;
            }
            catch(Error e)
            {
               trace "[---] CyScript::run: caught runtime exception e.name=\""+e.name+"\" e.msg=\""+e.message+"\"";
            }
         }

      }
      else
      {
         // Failed to load script
      }

      return false;
   }

   // <method_get.png>
   public method isPlugin() : boolean {
      return !plugin_id.isBlank();
   }

}
