// ----
// ---- file   : modcv_rpnout.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 13Apr2021
// ---- changed: 16Apr2021, 07May2021, 22Dec2021, 21Feb2022, 16Nov2024
// ----
// ----
// ----

module MModularCVMod_RPNOut;

use namespace ui;
namespace modularcv;


class ModCV_RPNOut : ModCV_Output {
   // (note) send RPN 1..16 on selected I/O port

   public virtual init() {
      Module::init();

      initModule("rpnout"/*id*/,
                 "RPNOut"/*header_id*/,
                 "RPN Output (RPN 1..16)"/*tooltip*/
                 );
      setModuleSize(6, 3);

      addInput("o1",  "output value 1 (RPN#100)",  0.0f, IO_ANY);
      addInput("o2",  "output value 2 (RPN#101)",  0.0f, IO_ANY);
      addInput("o3",  "output value 3 (RPN#102)",  0.0f, IO_ANY);
      addInput("o4",  "output value 4 (RPN#103)",  0.0f, IO_ANY);
      addInput("o5",  "output value 5 (RPN#104)",  0.0f, IO_ANY);
      addInput("o6",  "output value 6 (RPN#105)",  0.0f, IO_ANY);
      addInput("o7",  "output value 7 (RPN#106)",  0.0f, IO_ANY);
      addInput("o8",  "output value 8 (RPN#107)",  0.0f, IO_ANY);
      addInput("o9",  "output value 9 (RPN#108)",  0.0f, IO_ANY);
      addInput("o10", "output value 10 (RPN#109)", 0.0f, IO_ANY);
      addInput("o11", "output value 11 (RPN#110)", 0.0f, IO_ANY);
      addInput("o12", "output value 12 (RPN#111)", 0.0f, IO_ANY);
      addInput("o13", "output value 13 (RPN#112)", 0.0f, IO_ANY);
      addInput("o14", "output value 14 (RPN#113)", 0.0f, IO_ANY);
      addInput("o15", "output value 15 (RPN#114)", 0.0f, IO_ANY);
      addInput("o16", "output value 16 (RPN#115)", 0.0f, IO_ANY);
   }

   public virtual copyFrom(ModCV_RPNOut _o) {
      port_index  = _o.port_index;
   }

   public virtual initUI() {

      Module::initUI();

      port_select_widget <= createPortSelectWidget(15, 20, port_index, true/*bOutput*/);

      float cx = 13;
      float cy = 58;
      float stepY = 18;
      float rightOff = 20;
      float bottomOff = 80;

      int pIdx = 0;
      loop(4)
      {
         // left top
         PortWidget pw <= createPortWidget(pIdx, false/*bOutput*/,
                                           cx,
                                           cy,
                                           null/*captionOrNull*/
                                           );

         // left bottom
         pw <= createPortWidget(pIdx + 4, false/*bOutput*/,
                                cx,
                                cy + bottomOff,
                                null/*captionOrNull*/
                                );

         // right top
         pw <= createPortWidget(pIdx + 8, false/*bOutput*/,
                                cx + rightOff,
                                cy,
                                null/*captionOrNull*/
                                );

         // right bottom
         pw <= createPortWidget(pIdx + 12, false/*bOutput*/,
                                cx + rightOff,
                                cy + bottomOff,
                                null/*captionOrNull*/
                                );

         cy += stepY;
         pIdx++;
      }
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      ofs.i8 = port_index;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            port_index = ifs.u8;

            return true;
         }
         else
         {
            trace "[---] ModCV_RPNOut::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   protected virtual handlePortChanged(int _portIndex) {
      port_index = _portIndex;
      Global.Print("RPN Output Port is "+(_portIndex + 1)+" ("+parent_node.getPortIdByIndex(port_index)+")");
   }

   public method tickOutput(MIDIPipeFrame _frOut) {
      int pIdx = 0;
      loop(16)
      {
         if(inputs[pIdx].isConnected())
         {
            float val = inputs[pIdx].getValue();
            // trace "xxx modcv_rpnout: emit pIdx="+pIdx+" val="+val;

            parent_node.emitOutputBipolar(_frOut, port_index, Node.RPN_CTL_BASE/*100*/ + pIdx, val, MIDIMapDefs.TYPE_RPN/*forcedType*/);
         }

         pIdx++;
      }
   }

}
