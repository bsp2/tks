// ----
// ---- file   : modcv_rpnctl.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 31Mar2021
// ---- changed: 03Apr2021, 16Apr2021, 07May2021, 21Feb2022, 16Nov2024, 23Mar2025
// ----
// ----
// ----

module MModularCVMod_RPNCtl;

use namespace ui;
namespace modularcv;


class ModCV_RPNCtl : ModCV_Input {

   public virtual init() {
      Module::init();

      initModule("RPNCtl"/*id*/,
                 "RPNCtl"/*header_id*/,
                 "RPN Ctl Input (Ctl 1..12, RPN 100..111)"/*tooltip*/
                 );
      setModuleSize(6, 3);

      addOutput("i1",  "input value 1 (RPN#100)", IO_ANY);
      addOutput("i2",  "input value 2 (RPN#101)", IO_ANY);
      addOutput("i3",  "input value 3 (RPN#102)", IO_ANY);
      addOutput("i4",  "input value 4 (RPN#103)", IO_ANY);
      addOutput("i5",  "input value 5 (RPN#104)", IO_ANY);
      addOutput("i6",  "input value 6 (RPN#105)", IO_ANY);
      addOutput("i7",  "input value 7 (RPN#106)", IO_ANY);
      addOutput("i8",  "input value 8 (RPN#107)", IO_ANY);
      addOutput("i9",  "input value 9 (RPN#108)", IO_ANY);
      addOutput("i10", "input value 10 (RPN#109)", IO_ANY);
      addOutput("i11", "input value 11 (RPN#110)", IO_ANY);
      addOutput("i12", "input value 12 (RPN#111)", IO_ANY);
   }

   public virtual copyFrom(ModCV_RPNCtl _o) {
      port_index = _o.port_index;
   }

   public virtual initUI() {

      Module::initUI();

      float cx = 15;
      float cy = 20;

      port_select_widget <= createPortSelectWidget(cx, cy, port_index, false/*bOutput*/);

      cx = 13;
      cy = 74;
      float stepY = 20;
      float rightOff = 20;
      float bottomOff = 74;

      int pIdx = 0;
      loop(3)
      {
         // left top
         PortWidget pw <= createPortWidget(pIdx, true/*bOutput*/,
                                           cx,
                                           cy,
                                           null/*captionOrNull*/
                                           );

         // left bottom
         pw <= createPortWidget(pIdx + 3, true/*bOutput*/,
                                cx,
                                cy + bottomOff,
                                null/*captionOrNull*/
                                );

         // right top
         pw <= createPortWidget(pIdx + 6, true/*bOutput*/,
                                cx + rightOff,
                                cy,
                                null/*captionOrNull*/
                                );

         // right bottom
         pw <= createPortWidget(pIdx + 9, true/*bOutput*/,
                                cx + rightOff,
                                cy + bottomOff,
                                null/*captionOrNull*/
                                );

         cy += stepY;
         pIdx++;
      }
   }

   protected virtual handlePortChanged(int _portIndex) {
      port_index = _portIndex;
      Global.Print("RPN Ctl Input Port is "+(_portIndex + 1)+" ("+parent_node.getPortIdByIndex(port_index)+")");
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      ofs.i8 = port_index;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            port_index = ifs.u8;

            return true;
         }
         else
         {
            trace "[---] ModCV_RPNCtl::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   public method tickInput(MIDIPipeFrame _frIn, boolean _bAdvance) {
      CtlIOPort ioPort <= parent_node.getPortByIndex(port_index);
      if(null != ioPort)
      {
         if(ioPort.b_enable)
         {
            int pIdx = 0;
            loop(12)
            {
               float t = _frIn.getFilteredRPN(ioPort.dev_idx, ioPort.dev_ch, Node.RPN_CTL_BASE/*100*/ + pIdx);
               if(t >= 0.0f)
                  out[pIdx] = t / 16383.0;

               pIdx++;
            }
         }
      }
   }

}
