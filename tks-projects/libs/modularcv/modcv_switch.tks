// ----
// ---- file   : modcv_switch.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2024 by Bastian Spiegel. 
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See 
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : 
// ----
// ---- created: 06Apr2021
// ---- changed: 16Apr2021, 07May2021, 28Dec2021, 21Feb2022, 17Nov2024
// ----
// ----
// ----

module MModularCVMod_Switch;

use namespace st2;
namespace modularcv;


class ModCV_Switch : Module {

   define int INTERPOL_NONE        = 0;
   define int INTERPOL_LIN         = 1;
   define int INTERPOL_SIN         = 2;
   define int INTERPOL_COS         = 3;
   define int INTERPOL_SMOOTHSTEP  = 4;

   float select_offset;
   float i1_offset;
   float i2_offset;
   float i3_offset;
   float i4_offset;
   float i5_offset;
   float i6_offset;
   int   interpol_type;

   static StringArray interpol_type_short_names = [
      "-",
      "lin",
      "sin",
      "cos",
      "stp",
                                                   ];

   static StringArray interpol_type_long_names = [
      "-: None",
      "lin: Linear",
      "sin: Sine",
      "cos: Cosine",
      "stp: Smoothstep",
                                                   ];


   public virtual init() {
      Module::init();

      initModule("Switch"/*id*/,
                 "switch"/*header_id*/,
                 "Switch"/*tooltip*/
                 );
      setModuleSize(6, 3);

      select_offset = 0.0;
      i1_offset = 0.0;
      i2_offset = 0.0;
      i3_offset = 0.0;
      i4_offset = 0.0;
      i5_offset = 0.0;
      i6_offset = 0.0;

      addInput("select", "Select (0..1 => Input 1..6)",  0.0, IO_ANY);

      addInput("i1", "Input 1", 0.0, IO_ANY);
      addInput("i2", "Input 2", 0.0, IO_ANY);
      addInput("i3", "Input 3", 0.0, IO_ANY);
      addInput("i4", "Input 4", 0.0, IO_ANY);
      addInput("i5", "Input 5", 0.0, IO_ANY);
      addInput("i6", "Input 6", 0.0, IO_ANY);

      addOutput("out", "Output", IO_ANY);
   }

   public virtual copyFrom(ModCV_Switch _o) {
      select_offset = _o.select_offset;
      i1_offset     = _o.i1_offset;
      i2_offset     = _o.i2_offset;
      i3_offset     = _o.i3_offset;
      i4_offset     = _o.i4_offset;
   }

   public virtual initUI() {

      Module::initUI();

      float cx = 12;
      float cy = 28;
      float stepY = 22;
      float portOffX = 17;
      float ledOffX = 10;
      ui::ComboBox *cm;
      ui::Dial *dl;

      // Select
      dl <= createSmallDial(cx + portOffX + 2, cy,
                            "select_offset",
                            -1.0, 1.0, 0.0, select_offset,
                            "sel"
                            );
      dl.setStep(1.0 / 12);
      createPortWidget(0, false/*bOutput*/,
                       cx,
                       cy,
                       null/*captionOrNull*/
                       );


      // Input 1
      cx = 12;
      cy += 30;
      createSmallDial(cx, cy,
                      "i1_offset",
                      -1.0, 1.0, 0.0, i1_offset,
                      null/*captionOrNull*/
                      );
      createPortWidget(1, false/*bOutput*/,
                       cx + portOffX,
                       cy,
                       null/*captionOrNull*/
                       );
      createLED(cx + portOffX + ledOffX, cy);
                       

      // Input 2
      cy += stepY;
      createSmallDial(cx, cy,
                      "i2_offset",
                      -1.0, 1.0, 0.0, i2_offset,
                      null/*captionOrNull*/
                      );
      createPortWidget(2, false/*bOutput*/,
                       cx + portOffX,
                       cy,
                       null/*captionOrNull*/
                       );
      createLED(cx + portOffX + ledOffX, cy);

      // Input 3
      cy += stepY;
      createSmallDial(cx, cy,
                      "i3_offset",
                      -1.0, 1.0, 0.0, i3_offset,
                      null/*captionOrNull*/
                      );
      createPortWidget(3, false/*bOutput*/,
                       cx + portOffX,
                       cy,
                       null/*captionOrNull*/
                       );
      createLED(cx + portOffX + ledOffX, cy);

      // Input 4
      cy += stepY;
      createSmallDial(cx, cy,
                      "i4_offset",
                      -1.0, 1.0, 0.0, i4_offset,
                      null/*captionOrNull*/
                      );
      createPortWidget(4, false/*bOutput*/,
                       cx + portOffX,
                       cy,
                       null/*captionOrNull*/
                       );
      createLED(cx + portOffX + ledOffX, cy);

      // Input 5
      cy += stepY;
      createSmallDial(cx, cy,
                      "i5_offset",
                      -1.0, 1.0, 0.0, i5_offset,
                      null/*captionOrNull*/
                      );
      createPortWidget(5, false/*bOutput*/,
                       cx + portOffX,
                       cy,
                       null/*captionOrNull*/
                       );
      createLED(cx + portOffX + ledOffX, cy);

      // Input 6
      cy += stepY;
      createSmallDial(cx, cy,
                      "i6_offset",
                      -1.0, 1.0, 0.0, i6_offset,
                      null/*captionOrNull*/
                      );
      createPortWidget(6, false/*bOutput*/,
                       cx + portOffX,
                       cy,
                       null/*captionOrNull*/
                       );
      createLED(cx + portOffX + ledOffX, cy);

      // Output
      cm <= createModeParamWidget(13, RACK_MODULE_HEIGHT - 19,
                                  "interpol_type",
                                  interpol_type_short_names,
                                  interpol_type_long_names,
                                  interpol_type,
                                  null/*captionOrNull*/
                                  );
      cm.setToolTipCaption("Interpolation Type");

      createPortWidget(0, true/*bOutput*/,
                       36,
                       RACK_MODULE_HEIGHT - 20,
                       null/*captionOrNull*/
                       );

   }

   public virtual setParamByName(String _name, float _value) {
      switch(_name)
      {
         case "select_offset":
            select_offset = _value;
            break;

         case "i1_offset":
            i1_offset = _value;
            break;

         case "i2_offset":
            i2_offset = _value;
            break;

         case "i3_offset":
            i3_offset = _value;
            break;

         case "i4_offset":
            i4_offset = _value;
            break;

         case "i5_offset":
            i5_offset = _value;
            break;

         case "i6_offset":
            i6_offset = _value;
            break;

         case "interpol_type":
            interpol_type = _value;
            break;
      }
   }

   public virtual getParamByName(String _name) : float {
      switch(_name)
      {
         case "select_offset":
            return select_offset;

         case "i1_offset":
            return i1_offset;

         case "i2_offset":
            return i2_offset;

         case "i3_offset":
            return i3_offset;

         case "i4_offset":
            return i4_offset;

         case "i5_offset":
            return i5_offset;

         case "i6_offset":
            return i6_offset;

         case "interpol_type":
            return interpol_type;
      }
   }

   public virtual getNormalizedParamNames() : Object {
      return ["select off", "i1 off", "i2 off", "i3 off", "i4 off", "i5 off", "i6 off", "interpol type"
              ];
   }

   public virtual setNormalizedParamByIndexUI(int _paramIdx, float _value) {
      switch(_paramIdx)
      {
         case 0:
            select_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("select_offset", select_offset);
            break;

         case 1:
            i1_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("i1_offset", i1_offset);
            break;

         case 2:
            i2_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("i2_offset", i2_offset);
            break;

         case 3:
            i3_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("i3_offset", i3_offset);
            break;

         case 4:
            i4_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("i4_offset", i4_offset);
            break;

         case 5:
            i5_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("i5_offset", i5_offset);
            break;

         case 6:
            i6_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("i6_offset", i6_offset);
            break;

         case 7:
            interpol_type = FromNormalized(_value, 0, interpol_type_short_names.numElements-1);
            updateParamWidget("interpol_type", interpol_type);
            break;
      }
   }

   public virtual getNormalizedParamByIndex(int _paramIdx) : float {
      switch(_paramIdx)
      {
         case 0:
            return ToNormalized(select_offset, -1, 1);

         case 1:
            return ToNormalized(i1_offset, -1, 1);

         case 2:
            return ToNormalized(i2_offset, -1, 1);

         case 3:
            return ToNormalized(i3_offset, -1, 1);

         case 4:
            return ToNormalized(i4_offset, -1, 1);

         case 5:
            return ToNormalized(i5_offset, -1, 1);

         case 6:
            return ToNormalized(i6_offset, -1, 1);

         case 7:
            return ToNormalized(interpol_type, 0, interpol_type_short_names.numElements-1);
      }
      return 0.0f;
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      // params
      ofs.f32 = select_offset;
      ofs.f32 = i1_offset;
      ofs.f32 = i2_offset;
      ofs.f32 = i3_offset;
      ofs.f32 = i4_offset;
      ofs.f32 = i5_offset;
      ofs.f32 = i6_offset;
      ofs.i8  = interpol_type;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            // params
            select_offset = ifs.f32;
            i1_offset     = ifs.f32;
            i2_offset     = ifs.f32;
            i3_offset     = ifs.f32;
            i4_offset     = ifs.f32;
            i5_offset     = ifs.f32;
            i6_offset     = ifs.f32;
            interpol_type = ifs.u8;

            return true;
         }
         else
         {
            trace "[---] ModCV_Switch::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   // public virtual reset() {
   // }

   public virtual tick() {
      local float fSelect = (inputs[0].getValue() + select_offset)*6;
      local float f1      = inputs[1].getValue() + i1_offset;
      local float f2      = inputs[2].getValue() + i2_offset;
      local float f3      = inputs[3].getValue() + i3_offset;
      local float f4      = inputs[4].getValue() + i4_offset;
      local float f5      = inputs[5].getValue() + i5_offset;
      local float f6      = inputs[6].getValue() + i6_offset;

      int iCur = mathWrapi(mathClampi(fSelect, -6, 5), 0, 6);
      int iNext;
      float r = fSelect - iCur;
      float c;
      float n;

      int outputIdx = 0;
      loop(6)
         setLED(outputIdx++, 0.0f);

      switch(iCur)
      {
         case 0:
            c = f1; n = f2; setLED(0, -1.0f);
            break;

         case 1:
            c = f2; n = f3; setLED(1, -1.0f);
            break;

         case 2:
            c = f3; n = f4; setLED(2, -1.0f);
            break;

         case 3:
            c = f4; n = f5; setLED(3, -1.0f);
            break;

         case 4:
            c = f5; n = f6; setLED(4, -1.0f);
            break;

         case 5:
            c = f6; n = f6; setLED(5, -1.0f);
            break;
      }

      switch(interpol_type)
      {
         case INTERPOL_NONE:
            out[0] = c;
            break;

         case INTERPOL_LIN:
            out[0] = c + (n - c) * r;
            break;

         case INTERPOL_SIN:
            out[0] = c + (n - c) * sin(r * PI * 0.5);
            break;

         case INTERPOL_COS:
            out[0] = c + (n - c) * (1.0f - cos(r * PI * 0.5));
            break;

         case INTERPOL_SMOOTHSTEP:
            out[0] = mathSmoothStepf(c, n, r);
            break;
      }
   }

}
