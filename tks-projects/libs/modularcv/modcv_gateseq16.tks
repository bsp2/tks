// ----
// ---- file   : modcv_gateseq16.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : based on ModCV_CVSeq16
// ----
// ---- created: 02Nov2024
// ---- changed: 03Nov2024
// ----
// ----
// ----

module MModularCVMod_GateSeq16;

use namespace ui;
namespace modularcv;


// <class.png>
class GateSeq16_Pattern {

   // 'clk' phase-input ("LUT") modes
   define int LUT_NONE     = 0;
   define int LUT_WRAP     = 1;
   define int LUT_FOLD     = 2;
   define int LUT_FOLD_NR  = 3;  // don't repeat last step
   define int LUT_CLAMP    = 4;  // scale clk CV 0..1 to 0..numSteps   (e.g. num=4, cv=0.5 => step=2)
   define int LUT_CLAMP_PK = 5;  // scale clk CV 0..1 to 0..numSteps-1 (e.g. num=4, cv=0.5 => step=1.5)

   static StringArray lut_mode_names = [
      "-",
      "Wrap",
      "Fold",
      "Fold (no repeat)",
      "Clamp",
      "Clamp (peak)",
                                                   ];

   int        pat_idx;
   int        num_steps;
   int        step_offset;
   FloatArray steps;
   byte       lut_mode;
   float      time_scl;  // 0=pow(2,0)=>1.0
   float      time_off;

   float cached_min_t;  // 0: recalc. used for normalized gate duration output.
   float cached_max_t;


   public method init(int _patIdx) {
      pat_idx     = _patIdx;

      num_steps     = 16;
      step_offset   = 0;
      time_scl      = 0.0f;
      time_off      = 0.0f;

      steps.allocAndFill(16, 0.0f);
   }

   public method copyFrom(GateSeq16_Pattern _o) {
      num_steps     = _o.num_steps;
      step_offset   = _o.step_offset;
      steps         = _o.steps;
      lut_mode      = _o.lut_mode;
      time_scl      = _o.time_scl;
      time_off      = _o.time_off;
      invalidateMinMaxT();
   }

   public method invalidateMinMaxT() {
      cached_min_t = 0.0f;  // force recalc
   }

   public method lazyRecalcMinMaxT() {
      if(cached_min_t <= 0.0f)
      {
         cached_min_t = 999;
         cached_max_t = 0;
         int stepIdx = 0;
         loop(16)
         {
            float f = steps[stepIdx];
            if(f >= ModCV_GateSeq16.TOGGLE_THRESHOLD)
            {
               cached_min_t = mathMinf(cached_min_t, f);
               cached_max_t = mathMaxf(cached_max_t, f);
            }
            stepIdx++;
         }
         if(cached_min_t >= 999)
         {
            // no active steps
            cached_min_t = ModCV_GateSeq16.TOGGLE_THRESHOLD;
            cached_max_t = cached_min_t;
         }
      }
   }

   public method clear() {
      steps.fill(false);
      invalidateMinMaxT();
   }

   public method clearUnmaskedOnly() {
      int stepIdx = 0;
      loop(16)
      {
         if(steps[stepIdx] >= ModCV_GateSeq16.TOGGLE_THRESHOLD)
            steps[stepIdx] = 0.0f;
         stepIdx++;
      }
      invalidateMinMaxT();
   }

   public method randomize(float _max) {
      int stepIdx = 0;
      loop(16)
         steps[stepIdx++] = rand(_max);
      invalidateMinMaxT();
   }

   public method randomizeUnmaskedOnly(float _max) {
      int stepIdx = 0;
      loop(16)
      {
         if(steps[stepIdx] >= ModCV_GateSeq16.TOGGLE_THRESHOLD)
            steps[stepIdx] = rand(_max - ModCV_GateSeq16.TOGGLE_THRESHOLD) + ModCV_GateSeq16.TOGGLE_THRESHOLD;
         stepIdx++;
      }
      invalidateMinMaxT();
   }

   public =replay= method setLUTMode(int _mode) {
      lut_mode = _mode;
   }

   public method calcLUTOffset(float _fOff, int _numSteps) : float {
      switch(lut_mode)
      {
         default:
         case LUT_WRAP:
            return mathWrapf(_fOff * _numSteps, 0, _numSteps);

         case LUT_FOLD:
            return mathClampf(mathFoldf(_fOff * _numSteps, 0, _numSteps), 0, _numSteps-1);

         case LUT_FOLD_NR:
            return mathClampf(mathFoldf(_fOff * (_numSteps - 1), 0, _numSteps), 0, _numSteps-1);

         case LUT_CLAMP:
            return mathClampf(_fOff * _numSteps, 0, (_numSteps - 1));

         case LUT_CLAMP_PK:
            return mathClampf(_fOff * (_numSteps-1), 0, (_numSteps - 1));
      }
   }

   public method saveState(Stream ofs) {
      // ver
      ofs.i16 = 2;

      // params
      ofs.i8  = num_steps;
      ofs.i8  = step_offset;
      ofs.i8  = lut_mode;

      ofs.f32 = time_scl;  // v2+
      ofs.f32 = time_off;  // v2+

      int stepIdx = 0;
      loop(16)
         ofs.f32 = steps[stepIdx++];
   }

   public method loadState(Stream ifs) : boolean {
      // ver
      short ver = ifs.u16;

      if(ver >= 1)
      {
         // params
         num_steps   = ifs.u8;
         step_offset = ifs.s8;
         lut_mode    = ifs.u8;

         if(ver >= 2)
         {
            time_scl = ifs.f32;  // v2+
            time_off = ifs.f32;  // v2+
         }

         int stepIdx = 0;
         loop(16)
            steps[stepIdx++] = ifs.f32;

         invalidateMinMaxT();

         return true;
      }
      return false;
   }

}


// <class.png>
class ModCV_GateSeq16 : Module {
   // (note) when 'clk' is not connected, play step at 'off' (=> LUT mode)

   define int NUM_PATTERNS = 8;

   define float TOGGLE_THRESHOLD = 1.0 / 256;  // 1/256 note

   int     edit_pat_idx;
   boolean b_force_edit_pat;
   int     step_idx;
   int     step_idx_last_played;
   boolean b_oneshot;
   boolean b_playing;
   boolean b_rec_th;   // 1=record only to steps that already store values >= TOGGLE_THRESHOLD

   GateSeq16_Pattern *[] patterns;

   protected RoundButton *bt_force_edit_pat;
   protected PortWidget *pw_clk;

   protected Dial *[] step_dials;
   protected LED  *[] step_leds;

   protected Button *bt_rec_th;

   protected TrigInput trig_reset;
   protected TrigInput trig_clock;

   protected FloatParam *fp_off;
   protected FloatParam *fp_len;

   static GateSeq16_Pattern *pat_clipboard;

   protected boolean b_ui_queued_step_update;

   protected int gate_ticks_left;


   public virtual init() {
      Module::init();

      initModule("GateSeq16"/*id*/,
                 "gate seq 16"/*header_id*/,
                 "Gate Seq 16\n\n - Off input is relative to default pattern offset\n - Len input overrides the default pattern len when connected\n - Pat input overrides the edit pattern during replay when connected"/*tooltip*/
                 );
      setModuleSize(15, 3);

      int patIdx = 0;
      loop(NUM_PATTERNS)
      {
         GateSeq16_Pattern pat <= new GateSeq16_Pattern;
         pat.init(patIdx++);
         patterns.add(#(deref pat));
      }

      edit_pat_idx = 0;
      step_idx = 0;

      addInput("reset",    "Reset",           0.0, IO_GATE);   // 0
      addInput("clock",    "Clock",           0.0, IO_CLOCK);  // 1
      addInput("len",      "Len\n\n (note) Overrides the default pattern len when connected", 0.0, IO_SCALE);  // 2
      addInput("off",      "Offset",          0.0, IO_OFF);    // 3
      addInput("pat",      "Pattern (offset)\n\n (note) Overrides the current edit pattern nr during replay when connected", 0.0, IO_OFF);  // 4
      addInput("rec_cv",   "Record CV",       0.0, IO_ANY);    // 5
      addInput("rec_gate", "Record Gate",     0.0, IO_GATE);   // 6
      addInput("time_scl", "Time Scale",      0.0, IO_ANY);    // 7
      addInput("time_off", "Time Offset",     0.0, IO_ANY);    // 8

      addOutput("out",    "Output",              IO_GATE); // 0
      addOutput("norm_t", "Normalized duration", IO_ANY);  // 1  (0=min duration .. 1=max duration)

      b_rec_th = false;
   }

   public virtual copyFrom(ModCV_GateSeq16 _o) {

      b_force_edit_pat = _o.b_force_edit_pat;

      GateSeq16_Pattern *pat;
      GateSeq16_Pattern *patO;
      int patIdx = 0;
      loop(NUM_PATTERNS)
      {
         pat <= patterns.get(patIdx);
         patO <= _o.patterns.get(patIdx);
         pat.copyFrom(patO);
         patIdx++;
      }

      b_rec_th = _o.b_rec_th;
   }

   public method getEditPattern() : GateSeq16_Pattern {
      return patterns.get(edit_pat_idx);
   }

   public virtual initUI() {

      Module::initUI();

      float shiftX = 2;
      float cx = 9 + shiftX;
      float cy = 48;
      ComboBox *cm;
      FloatParam *fp;
      RoundButton *bt;
      Dial *dl;

      // b_force_edit_pat
      bt_force_edit_pat <= createCheckButton(cx-4+22-14, cy-28+10-1,
                                             "b_force_edit_pat",
                                             b_force_edit_pat
                                             );
      bt_force_edit_pat.setToolTipCaption("When checked, force edit pattern replay (patnr+offset+len).\n\nWhen unchecked, \"pat\" input controls replay pattern selection, \"len\" overrides default len, and \"off\" is added to default pattern offset");


      // edit_pat_idx
      local StringArray patNrOpt;
      int patNr = 1;
      loop(NUM_PATTERNS)
         patNrOpt.add(String(patNr++));
      cm <= createModeParamWidget(cx-4+22-10+22, cy-28+10,
                                  "edit_pat_idx",
                                  patNrOpt,
                                  null/*patNrOptLong*/,
                                  edit_pat_idx,
                                  null/*captionOrNull*/
                                  );
      cm.setRequiredSize2fScaled(20, 21);
      cm.setToolTipCaption("Current edit pattern index.\n\n (note) also the current play pattern when the \"pat\" input is not connected, or the \"force\" toggle button is engaged");

      // offset
      fp_off <= createIntParamWidget(cx-4+22+22, cy-25,
                                     "step_offset",
                                     -16/*min*/,
                                     16/*max*/,
                                     0/*reset*/,
                                     0/*step_offset*/,
                                     null/*captionOrNull*/
                                     );

      // #steps
      fp_len <= createIntParamWidget(cx-4+22+22+22, cy-25,
                                     "num_steps",
                                     1/*min*/,
                                     16/*max*/,
                                     16/*reset*/,
                                     16/*num_steps*/,
                                     null/*captionOrNull*/
                                     );

      // Clock
      cx = 14+shiftX;
      pw_clk <= createPortWidget(1, false/*bOutput*/,
                                 cx, cy,
                                 "clk"/*captionOrNull*/
                                 );

      // Play Pattern (0..1 => pat#1..8)
      cx += 22;
      createPortWidget(4, false/*bOutput*/,
                       cx, cy,
                       "pat"/*captionOrNull*/
                       );

      // off
      cx += 22;
      createPortWidget(3, false/*bOutput*/,
                       cx, cy,
                       "off"/*captionOrNull*/
                       );


      // len
      cx += 22;
      createPortWidget(2, false/*bOutput*/,
                       cx, cy,
                       "len"/*captionOrNull*/
                       );

      // Reset
      cx += 22;
      createPortWidget(0, false/*bOutput*/,
                       cx, cy,
                       "rst"/*captionOrNull*/
                       );

      // Output
      createPortWidget(0, true/*bOutput*/,
                       cx, cy-19,
                       null/*captionOrNull*/
                       );


      int stepIdx = 0;
      cx = 10+shiftX+5;
      cy = 94-6 - 5;
      float stepXI = 24 + 4;
      float stepYI = 30;

      step_leds.alloc(16);
      step_leds.useAll();
      float ledOffY = 13;

      local FloatArray aPresetValues <= [0.0f, 1.0f/256, 1.0f/128, 1.0f/64, 1.0f/32, 1.0f/16, 1.0/12, 1.0f/8, 1.0f/6, 1.0f/4];
      local StringArray aPresetNames <= ["-",  "1/256",  "1/128",  "1/64",  "1/32",  "1/16",  "1/12", "1/8",  "1/6",  "1/4" ];

      step_dials.alloc(16);
      step_dials.useAll();
      loop(4)
      {
         // 1
         dl <= createSmallDial(cx + (stepIdx * stepXI), cy,
                               "step_"+(stepIdx+1),
                               0.0, 1.0, 0.0,
                               0.0f/*steps[stepIdx]*/,
                               null/*captionOrNull*/
                               );
         dl.setResetValues([0.0f, 1.0/64, 1.0/16]);
         dl.setPresetOptions(Object(aPresetValues), Object(aPresetNames));
         dl.setStep(TOGGLE_THRESHOLD);
         dl.setToggleThreshold(TOGGLE_THRESHOLD);
         dl.setToggleMinValue(0.0f);
         dl.setEnableToggle(true);
         dl.setPowerOfTwoDisplayMax(256);
         step_dials[stepIdx] = dl;
         step_leds[stepIdx] = createLED(cx + (stepIdx * stepXI), cy+ledOffY);

         // 2
         dl <= createSmallDial(cx + (stepIdx * stepXI), cy + stepYI,
                               "step_"+(4+stepIdx+1),
                               0.0, 1.0, 0.0,
                               0.0f/*steps[4 + stepIdx]*/,
                               null/*captionOrNull*/
                               );
         dl.setResetValues([0.0f, 1.0/64, 1.0/16]);
         dl.setPresetOptions(Object(aPresetValues), Object(aPresetNames));
         dl.setStep(TOGGLE_THRESHOLD);
         dl.setToggleThreshold(TOGGLE_THRESHOLD);
         dl.setToggleMinValue(0.0f);
         dl.setEnableToggle(true);
         dl.setPowerOfTwoDisplayMax(256);
         step_dials[4 + stepIdx] = dl;
         step_leds[4 + stepIdx] = createLED(cx + (stepIdx * stepXI), cy+stepYI+ledOffY);

         // 3
         dl <= createSmallDial(cx + (stepIdx * stepXI), cy + (stepYI *2),
                               "step_"+(8+stepIdx+1),
                               0.0, 1.0, 0.0,
                               0.0f/*steps[8 + stepIdx]*/,
                               null/*captionOrNull*/
                               );
         dl.setResetValues([0.0f, 1.0/64, 1.0/16]);
         dl.setPresetOptions(Object(aPresetValues), Object(aPresetNames));
         dl.setStep(TOGGLE_THRESHOLD);
         dl.setToggleThreshold(TOGGLE_THRESHOLD);
         dl.setToggleMinValue(0.0f);
         dl.setEnableToggle(true);
         dl.setPowerOfTwoDisplayMax(256);
         step_dials[8 + stepIdx] = dl;
         step_leds[8 + stepIdx] = createLED(cx + (stepIdx * stepXI), cy+(stepYI*2)+ledOffY);

         // 4
         dl <= createSmallDial(cx + (stepIdx * stepXI), cy + (stepYI * 3),
                               "step_"+(12+stepIdx+1),
                               0.0, 1.0, 0.0,
                               0.0f/*steps[12 + stepIdx]*/,
                               null/*captionOrNull*/
                               );
         dl.setResetValues([0.0f, 1.0/64, 1.0/16]);
         dl.setPresetOptions(Object(aPresetValues), Object(aPresetNames));
         dl.setStep(TOGGLE_THRESHOLD);
         dl.setToggleThreshold(TOGGLE_THRESHOLD);
         dl.setToggleMinValue(0.0f);
         dl.setEnableToggle(true);
         dl.setPowerOfTwoDisplayMax(256);
         step_dials[12 + stepIdx] = dl;
         step_leds[12 + stepIdx] = createLED(cx + (stepIdx * stepXI), cy+(stepYI*3)+ledOffY);

         stepIdx++;
      }

      // Rec CV
      cx = 14+shiftX;
      cy += stepYI * 4 - 3;
      pw_clk <= createPortWidget(5, false/*bOutput*/,
                                 cx, cy,
                                 null/*captionOrNull*/
                                 );

      bt_rec_th <= createTinyCheckButton(cx + 11, cy,
                                         "b_rec_th",
                                         b_rec_th
                                         );
      bt_rec_th.setToolTipCaption("When checked, record only to steps which already contain a value >= 0\n\n (note) a 'math' module set to mode 'sth' can mask / skip the negative output values\n (note) also enables Dial-toggle mode (LMB-click toggles between skip(0) and last edited value)\n (note) 't'");

      // Rec Gate
      cx += 22;
      createPortWidget(6, false/*bOutput*/,
                       cx, cy,
                       null/*captionOrNull*/
                       );


      // Time Scale offset
      cx = 56;
      dl <= createTinyDial(cx, cy+1,
                           "time_scl",
                           -1.0, 1.0, 0.0,
                           0.0f,
                           null/*captionOrNull*/
                           );
      dl.setResetValues([0.0f]);
      dl.setPresetOptions([-1.0f, log(1.0/6)/(3*log(2)), -2.0/3, log(1.0/3)/(3*log(2)), -1.0/3, 0.0,  1.0/3, log(3)/(3*log(2)), 2.0/3, log(6)/(3*log(2)), 1.0],
                          ["/8",  "/6",                  "/4",   "/3",                  "/2",   "-",  "*2",  "*3",              "*4",  "*6",              "*8"]
                          );
      dl.setStep(1.0/32);

      // Time Scale input
      createPortWidget(7, false/*bOutput*/,
                       cx + 12, cy,
                       null/*captionOrNull*/
                       );

      // Time Offset
      cx = 81;
      dl <= createTinyDial(cx, cy+1,
                           "time_off",
                           -0.25, 0.25, 0.0,
                           0.0f,
                           null/*captionOrNull*/
                           );
      dl.setResetValues([0.0f]);
      dl.setPresetOptions([-1.0/4, -1.0/8, -1.0/16, -1.0/32, 0.0, 1.0/32,  1.0/16,  1.0/8,  1.0/4 ],
                          ["-1/4", "-1/8", "-1/16", "-1/32", "-", "+1/32", "+1/16", "+1/8", "+1/4"]
                          );
      dl.setStep(1.0/256);

      // Time Offset input
      createPortWidget(8, false/*bOutput*/,
                       cx + 12, cy,
                       null/*captionOrNull*/
                       );


      // Normalized gate time / duration output
      createPortWidget(1, true/*bOutput*/,
                       108, cy-1,
                       null/*captionOrNull*/
                       );

      updatePatWidgets();
   }

   protected method updateClkPhaseCaption() {
      GateSeq16_Pattern pat <= getEditPattern();
      if(null != pw_clk)
         pw_clk.updateCaption(GateSeq16_Pattern.LUT_NONE != pat.lut_mode ? "pha" : "clk");
   }

   protected method updateStepWidgets(GateSeq16_Pattern _pat) {
      FloatArray faSteps <= _pat.steps;
      Dial *dl;
      int stepIdx = 0;
      loop(16)
      {
         dl <= step_dials[stepIdx];
         float f = faSteps.get(stepIdx);
         dl.setValue(f);
         dl.setToggleState(f >= TOGGLE_THRESHOLD);
         stepIdx++;
      }
   }

   protected method updatePatWidgets() {
      GateSeq16_Pattern pat <= getEditPattern();

      updateStepWidgets(pat);

      fp_off.setValue(pat.step_offset);
      fp_len.setValue(pat.num_steps);

      updateClkPhaseCaption();
   }

   public virtual wantDefaultParamMessage(String _name) : boolean {
      return !(_name <= "step_") && ("b_rec_th" != _name) && ("time_scl" != _name) && ("time_off" != _name);
   }

   public virtual setParamByName(String _name, float _value) {
      GateSeq16_Pattern pat <= getEditPattern();

      switch(_name)
      {
         default:
            if(_name <= "step_")
            {
               int stepIdx = int(_name.replace("step_", "")) - 1;
               FloatArray steps <= pat.steps;
               steps[stepIdx] = _value;
               pat.invalidateMinMaxT();

               if(_value >= TOGGLE_THRESHOLD)
               {
                  int numTicks = round(4 * st2::current_song.ppq * _value);
                  float num16ths = int(100*numTicks/float(st2::current_song.ppq/4.0))/100.0;
                  float num;

                  if(numTicks >= st2::current_song.ppq*3)
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq*4))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" whole"+Utils.GetPluralStringFloat(num));
                  }
                  else if(numTicks >= st2::current_song.ppq*1.5)
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq*2))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" half"+Utils.GetPluralStringFloat(num));
                  }
                  else if(numTicks >= st2::current_song.ppq/1.5)
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" quarter"+Utils.GetPluralStringFloat(num));
                  }
                  else if(numTicks >= st2::current_song.ppq/3)
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq/2.0))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" eight"+Utils.GetPluralStringFloat(num));
                  }
                  else if(numTicks >= st2::current_song.ppq/6)
                  {
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths));
                  }
                  else if(numTicks >= st2::current_song.ppq/12)
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq/8.0))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" 32th"+Utils.GetPluralStringFloat(num));
                  }
                  else if(numTicks >= st2::current_song.ppq/24)
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq/16.0))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" 64th"+Utils.GetPluralStringFloat(num));
                  }
                  else if(numTicks >= st2::current_song.ppq/48)
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq/32.0))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" 128th"+Utils.GetPluralStringFloat(num));
                  }
                  else
                  {
                     num = int(100*numTicks/float(st2::current_song.ppq/64.0))/100.0;
                     Global.Print("Step "+(stepIdx+1)+" is "+numTicks+" tick"+Utils.GetPluralString(numTicks)+" => "+num16ths+" 16th"+Utils.GetPluralStringFloat(num16ths)+" => "+num+" 256th"+Utils.GetPluralStringFloat(num));
                  }
               }
               else
               {
                  Global.Print("Step "+(stepIdx+1)+" is disabled");
               }

               if(!st2::replay.b_playing)
                  setStepIdxLastPlayed(stepIdx);  // for CV recording (e.g. MIDI note input)
            }
            break;

         case "num_steps":
            pat.num_steps = _value;
            break;

         case "step_offset":
            pat.step_offset = _value;
            break;

         case "edit_pat_idx":
            edit_pat_idx = _value;
            updatePatWidgets();
            resetStepLEDs();
            b_force_edit_pat = true;
            bt_force_edit_pat.setSelected(true);
            break;

         case "b_force_edit_pat":
            b_force_edit_pat = _value;
            break;

         case "b_rec_th":
            b_rec_th = _value;
            updatePatWidgets();
            Global.Print("Threshold recording mode is "+Utils.GetEnableString(b_rec_th));
            break;

         case "time_scl":
            pat.time_scl = _value;
            float tScl = mathPowerf(2.0f, 3*_value);
            if(tScl < 1.0f)
            {
               tScl = int(100.0f / tScl)/100.0f;
               Global.Print("Param time_scl is "+_value+" => /"+tScl);
            }
            else
            {
               tScl = int(100 * tScl)/100.0f;
               Global.Print("Param time_scl is "+_value+" => *"+tScl);
            }
            break;

         case "time_off":
            pat.time_off = _value;
            int offTicks = round(_value * 4 * st2::current_song.ppq);
            Global.Print("Param time_off is "+_value+" => "+offTicks+" tick"+Utils.GetPluralString(offTicks));
            break;
      }
   }

   public virtual getParamByName(String _name) : float {
      GateSeq16_Pattern pat <= getEditPattern();

      switch(_name)
      {
         default:
            if(_name <= "step_")
            {
               int stepIdx = _name.replace("step_", "");
               FloatArray steps <= pat.steps;
               return steps[stepIdx - 1];
            }
            break;

         case "num_steps":
            return pat.num_steps;

         case "step_offset":
            return pat.step_offset;

         case "edit_pat_idx":
            return edit_pat_idx;

         case "b_force_edit_pat":
            return b_force_edit_pat;

         case "b_rec_th":
            return b_rec_th;

         case "time_scl":
            return pat.time_scl;

         case "time_off":
            return pat.time_off;
      }
   }

   public virtual getNormalizedParamNames() : Object {
      return ["step 1",  "step 2",  "step 3",  "step 4",
              "step 5",  "step 6",  "step 7",  "step 8",
              "step 9",  "step 10", "step 11", "step 12",
              "step 13", "step 14", "step 15", "step 16",
              ];
   }

   public virtual setNormalizedParamByIndexUI(int _paramIdx, float _value) {
      GateSeq16_Pattern pat <= getEditPattern();
      FloatArray steps <= pat.steps;
      switch(_paramIdx)
      {
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 7:
         case 8:
         case 9:
         case 10:
         case 11:
         case 12:
         case 13:
         case 14:
         case 15:
            steps[_paramIdx] = FromNormalized(_value, 0, 1);
            updateParamWidget("step_"+(_paramIdx+1), steps[_paramIdx]);
            break;
      }
   }

   public virtual getNormalizedParamByIndex(int _paramIdx) : float {
      GateSeq16_Pattern pat <= getEditPattern();
      FloatArray steps <= pat.steps;
      switch(_paramIdx)
      {
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 7:
         case 8:
         case 9:
         case 10:
         case 11:
         case 12:
         case 13:
         case 14:
         case 15:
            return ToNormalized(steps[_paramIdx], 0, 1);
      }
      return 0.0f;
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      // Patterns
      GateSeq16_Pattern *pat;
      foreach pat in patterns
      {
         pat.saveState(ofs);
      }

      // Current edit pattern
      ofs.i8 = edit_pat_idx;

      // Force edit pattern
      ofs.i8 = b_force_edit_pat;

      // Oneshot mode
      ofs.i8 = b_oneshot;

      // Record to steps >= TOGGLE_THRESHOLD only
      ofs.i8 = b_rec_th;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            GateSeq16_Pattern *pat;

            int patNr = 1;
            foreach pat in patterns
            {
               if(!pat.loadState(ifs))
               {
                  trace "[---] ModCV_GateSeq16::loadState: failed to load pattern "+patNr+"/"+NUM_PATTERNS;
                  return false;
               }
               patNr++;
            }

            // Current edit pattern (v3+)
            edit_pat_idx = ifs.u8;

            // Force edit pattern (v4+)
            b_force_edit_pat = ifs.b8;

            // Oneshot Mode (v5+)
            b_oneshot = ifs.b8;

            // Record to steps >= TOGGLE_THRESHOLD only (v6+)
            b_rec_th = ifs.b8;

            return true;
         }
         else
         {
            trace "[---] ModCV_GateSeq16::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   protected method resetStepLEDs() {
      LED *led;
      foreach led in step_leds
      {
         led.setConstValue(0.0f);
      }
   }

   public virtual reset() {
      step_idx = 0;
      b_playing = !b_oneshot;
      step_idx_last_played = 0;

      resetStepLEDs();

      trig_reset.reset();
      trig_clock.reset();

      gate_ticks_left = 0;
   }

   protected =replay= method setStepIdxLastPlayed(int _idx) {
      // when editing dial and replay is not running
      step_idx_last_played = _idx;
   }

   // <method.png>
   protected virtual addExtraContextMenuItems(PopupMenu pm) {
      PopupMenuButton *pmb;
      GateSeq16_Pattern pat <= getEditPattern();

      pm.addSeparator();

      pmb <= pm.addDefaultButton("Copy to Clipboard", "copy");
      pmb.setAccelerators("c", "");

      pmb <= pm.addDefaultButton("Paste from Clipboard", "paste");
      pmb.setAccelerators("v", "");
      pmb.setActive(null != pat_clipboard);

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Clear", "clear");
      pmb.setAccelerators("BACKSPACE", "");

      pmb <= pm.addDefaultButton("Randomize", "rand");
      pmb.setAccelerators("r", "");

      PopupMenu *spm;
      pm.addSeparator();
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Clock-Phase LUT mode", deref spm);
      spm.addRadioButton("-",                (GateSeq16_Pattern.LUT_NONE     == pat.lut_mode), "lut_none");
      spm.addRadioButton("Wrap",             (GateSeq16_Pattern.LUT_WRAP     == pat.lut_mode), "lut_wrap");
      spm.addRadioButton("Fold",             (GateSeq16_Pattern.LUT_FOLD     == pat.lut_mode), "lut_fold");
      spm.addRadioButton("Fold (no repeat)", (GateSeq16_Pattern.LUT_FOLD_NR  == pat.lut_mode), "lut_fold_nr");
      spm.addRadioButton("Clamp",            (GateSeq16_Pattern.LUT_CLAMP    == pat.lut_mode), "lut_clamp");
      spm.addRadioButton("Clamp (peak)",     (GateSeq16_Pattern.LUT_CLAMP_PK == pat.lut_mode), "lut_clamp_pk");

      pm.addSeparator();
      pmb <= pm.addCheckButton("Oneshot Mode", b_oneshot, "oneshot");
      pmb.setToolTipCaption("When enabled, stop replay after last step\n\n (note) use \'rst\' input to start replay\n\n (note) ignored in clock-phase LUT mode");
   }

   // <method.png>
   protected method handlePatCopy() {
      if(null == pat_clipboard)
      {
         pat_clipboard <= new GateSeq16_Pattern;
         pat_clipboard.init(0);
      }
      pat_clipboard.copyFrom(getEditPattern());
      Global.Print("Copy GateSeq16 pattern to clipboard");
   }

   // <method.png>
   protected method handlePatPaste() {
      if(null != pat_clipboard)
      {
         GateSeq16_Pattern pat <= getEditPattern();
         pat.copyFrom(pat_clipboard);
         updatePatWidgets();
         Global.Print("Paste GateSeq16 pattern from clipboard");
         updateParentEditorBidirectionalControls();
      }
   }

   // <method.png>
   protected method handlePatClear() {
      GateSeq16_Pattern pat <= getEditPattern();
      if(b_rec_th)
         pat.clearUnmaskedOnly();
      else
         pat.clear();
      updatePatWidgets();
      Global.Print("Clear GateSeq16 pattern"+(b_rec_th?" (unmasked only)":""));
      updateParentEditorBidirectionalControls();
   }

   // <method.png>
   protected method handlePatRand() {
      GateSeq16_Pattern pat <= getEditPattern();
      if(b_rec_th)
         pat.randomizeUnmaskedOnly(1.0/16/*max*/);
      else
         pat.randomize(1.0/16/*max*/);
      updatePatWidgets();
      Global.Print("Randomize GateSeq16 pattern"+(b_rec_th?" (unmasked only)":""));
      updateParentEditorBidirectionalControls();
   }

   // <method.png>
   protected =replay= method handleToggleOneShot() {
      b_oneshot = !b_oneshot;
      Global.Print("Oneshot Mode is "+Utils.GetEnableString(b_oneshot));
   }

   // <method.png>
   protected =replay= method toggleThresholdMode() {
      b_rec_th = !b_rec_th;
      setParamByName("b_rec_th", b_rec_th);
      bt_rec_th.setToggleState(b_rec_th);
   }

   // <method.png>
   protected virtual handleExtraContextMenuItem(String _id) : boolean {
      GateSeq16_Pattern pat <= getEditPattern();
      switch(_id)
      {
         case "copy":
            handlePatCopy();
            return true;

         case "paste":
            handlePatPaste();
            return true;

         case "clear":
            handlePatClear();
            return true;

         case "rand":
            handlePatRand();
            return true;

         case "oneshot":
            handleToggleOneShot();
            return true;

         case "lut_none":
            pat.setLUTMode(GateSeq16_Pattern.LUT_NONE);
            Global.Print("Clock LUT mode is \""+(GateSeq16_Pattern.lut_mode_names.get(pat.lut_mode))+"\"");
            updateClkPhaseCaption();
            return true;

         case "lut_wrap":
            pat.setLUTMode(GateSeq16_Pattern.LUT_WRAP);
            Global.Print("Clock LUT mode is \""+(GateSeq16_Pattern.lut_mode_names.get(pat.lut_mode))+"\"");
            updateClkPhaseCaption();
            return true;

         case "lut_fold":
            pat.setLUTMode(GateSeq16_Pattern.LUT_FOLD);
            Global.Print("Clock LUT mode is \""+(GateSeq16_Pattern.lut_mode_names.get(pat.lut_mode))+"\"");
            updateClkPhaseCaption();
            return true;

         case "lut_fold_nr":
            pat.setLUTMode(GateSeq16_Pattern.LUT_FOLD_NR);
            Global.Print("Clock LUT mode is \""+(GateSeq16_Pattern.lut_mode_names.get(pat.lut_mode))+"\"");
            updateClkPhaseCaption();
            return true;

         case "lut_clamp":
            pat.setLUTMode(GateSeq16_Pattern.LUT_CLAMP);
            Global.Print("Clock LUT mode is \""+(GateSeq16_Pattern.lut_mode_names.get(pat.lut_mode))+"\"");
            updateClkPhaseCaption();
            return true;

         case "lut_clamp_pk":
            pat.setLUTMode(GateSeq16_Pattern.LUT_CLAMP_PK);
            Global.Print("Clock LUT mode is \""+(GateSeq16_Pattern.lut_mode_names.get(pat.lut_mode))+"\"");
            updateClkPhaseCaption();
            return true;
      }
   }

   public virtual wantKeyboardFocus() : boolean {
      return true;
   }

   public virtual onKey(Key _k) : boolean {

      switch(_k.pressed)
      {
         case VKEY_BACKSPACE:
            if(_k.modNone())
            {
               handlePatClear();
               return true;
            }
            break;

         case 'c':
            if(_k.modNone())
            {
               handlePatCopy();
               return true;
            }
            break;

         case 't':
            if(_k.modNone())
            {
               toggleThresholdMode();
               return true;
            }
            break;

         case 'v':
            if(_k.modNone())
            {
               handlePatPaste();
               return true;
            }
            break;

         case 'r':
            if(_k.modNone())
            {
               handlePatRand();
               return true;
            }
            break;
      }

      return Module::onKey(_k);
   }

   public virtual onDraw() {
      if(b_ui_queued_step_update)
      {
         b_ui_queued_step_update = false;
         updateStepWidgets(getEditPattern());
      }
      Module::onDraw();
   }

   public virtual tick() {
      local GateSeq16_Pattern *pat;

      if(inputs[4/*pat*/].isConnected())
      {
         // Pattern input overrides edit pattern
         local int patIdx = mathClampi(inputs[4/*pat*/].getValue() * NUM_PATTERNS, 0, NUM_PATTERNS-1);
         if(b_force_edit_pat)
            pat <= getEditPattern();
         else
            pat <= patterns.get(patIdx);
      }
      else
      {
         // Play edit pattern
         pat <= getEditPattern();
      }

      local int numSteps;
      if(inputs[2/*len*/].isConnected())
      {
         if(b_force_edit_pat)
            numSteps = pat.num_steps;
         else
            numSteps = mathClampi(inputs[2/*len*/].getValue() * 16, 1, 16);
      }
      else
      {
         numSteps = pat.num_steps;
      }

      if(trig_reset.process(inputs[0/*reset*/].getValue()))
      {
         step_idx = 0;
         b_playing = true;
      }

      local float fClock = inputs[1/*clock*/].getValue();

      local float fOff = inputs[3/*offset*/].getValue();
      if(b_force_edit_pat)
         fOff = 0;
      else
         fOff = fOff * 16;
      fOff += pat.step_offset;

      local float recCV   = inputs[5/*rec_cv*/].getValue();
      recCV = mathClampf(recCV, 0.0f, 1.0f);
      local float recGate = inputs[6/*rec_gate*/].getValue();

      local float timeScl = inputs[7/*time_scl*/].getValue() + pat.time_scl;
      local float timeOff = inputs[8/*time_off*/].getValue() + pat.time_off;

      boolean bRec = (recGate >= TRIG_ON);

      LED *led;
      FloatArray faSteps <= pat.steps;
      float gateT = 0.0f;

      if(GateSeq16_Pattern.LUT_NONE == pat.lut_mode)
      {
         boolean bClock = trig_clock.process(fClock);

         if(bClock || bRec)
         {
            int stepOff = mathClampi(fOff, -32, 32);

            led <= step_leds[step_idx_last_played]; led.setConstValue(0.0);

            if(b_oneshot && (step_idx >= numSteps))
               b_playing = false;

            if(b_playing && st2::replay.b_playing)
            {
               step_idx_last_played = mathWrapi(((step_idx % numSteps) + stepOff) % 16, 0, 16);
               if(bClock)
                  step_idx++;

               led <= step_leds[step_idx_last_played]; led.setConstValue(-1.0);
               if(pat.pat_idx == edit_pat_idx)
               {
                  led <= step_leds[step_idx_last_played];
                  led.setConstValue(-1.0);
               }

               gateT = faSteps[step_idx_last_played];
            }

            if(bRec)
            {
               if(!b_rec_th || (faSteps[step_idx_last_played] >= TOGGLE_THRESHOLD))
               {
                  faSteps[step_idx_last_played] = recCV;
                  gateT = recCV;
               }
               else
                  bRec = false;  // skip redraw
            }

         }
      }
      else
      {
         // Clock LUT mode
         float lutOff = fClock;

         // // trace "xxx lutOff="+lutOff+" numSteps="+numSteps+" => idxF="+pat.calcLUTOffset(lutOff, numSteps);
         float idxF = mathWrapf(pat.calcLUTOffset(lutOff, numSteps) + fOff, 0, 16);
         step_idx = int(idxF);

         if(bRec)
         {
            if(!b_rec_th || (faSteps[step_idx] >= TOGGLE_THRESHOLD))
               faSteps[step_idx] = recCV;
            else
               bRec = false;  // skip redraw
         }

         gateT = faSteps[step_idx];

         led <= step_leds[step_idx_last_played]; led.setConstValue(0.0);
         step_idx_last_played = step_idx;
         led <= step_leds[step_idx]; led.setConstValue(1.0);

         step_idx_last_played = step_idx;

         // trace "xx   step_idx="+step_idx+" stepIdxN="+stepIdxN+" ledC="+(1.0 - fFrac)+" ledN="+fFrac;

      } // else if LUT mode

      if(bRec && parent_node.nodeIsEditorVisible())
      {
         b_ui_queued_step_update = true;
         Events.SendRedrawAll();  // (todo) optimize (only redraw updated step widget(s))
      }

      if(gateT > 0.0f)
      {
         // Calc 'norm_t' output (independent of scale+offset)
         pat.lazyRecalcMinMaxT();
         out[1] = (gateT - pat.cached_min_t) / (pat.cached_max_t - pat.cached_min_t);  // to 0..1 range

         // Scale+offset gate time
         gateT = gateT * mathPowerf(2.0f, 3*timeScl) + timeOff;
         int numTicks = round(gateT * 4 * st2::current_song.ppq);
         if(numTicks < 1)
            numTicks = 1;
         gate_ticks_left = numTicks;

         // trace "xxx gateT="+gateT+" pat.cached_min_t="+pat.cached_min_t+" pat.cached_max_t="+pat.cached_max_t+" out[1]="+out[1];
      }

      if(gate_ticks_left > 0)
      {
         gate_ticks_left--;
         out[0] = 1.0f;
      }
      else
      {
         out[0] = 0.0f;
      }

   }
}
