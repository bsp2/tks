// ----
// ---- file   : modcv_shift.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2022 by Bastian Spiegel. 
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See 
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : 
// ----
// ---- created: 13Apr2021
// ---- changed: 16Apr2021, 01May2021, 07May2021, 28Dec2021, 21Feb2022
// ----
// ----
// ----

module MModularCVMod_Shift;

use namespace st2;
namespace modularcv;


class ModCV_Shift : Module {

   int rec_offset;   // -12..12  (record head offset)
   int len_offset;   // -12..12  (shift register rotate size)

   protected TrigInput trig_sample;
   protected TrigInput trig_up;
   protected TrigInput trig_down;


   public virtual init() {
      Module::init();

      initModule("Shift"/*id*/,
                 "shift"/*header_id*/,
                 "Shift"/*tooltip*/
                 );
      setModuleSize(6, 3);

      rec_offset = 0;
      len_offset = 8;

      addInput("in",        "Input",      0.0, IO_ANY);   // 0
      addInput("sample",    "Sample",     0.0, IO_GATE);  // 1
      addInput("up",        "Shift Up",   0.0, IO_GATE);  // 2
      addInput("down",      "Shift Down", 0.0, IO_GATE);  // 3
      addInput("off",       "off",        0.0, IO_OFF);   // 4
      addInput("len",       "len",        0.0, IO_SCALE); // 5

      addOutput("o1", "Output 1", IO_ANY);
      addOutput("o2", "Output 2", IO_ANY);
      addOutput("o3", "Output 3", IO_ANY);
      addOutput("o4", "Output 4", IO_ANY);
      addOutput("o5", "Output 5", IO_ANY);
      addOutput("o6", "Output 6", IO_ANY);
      addOutput("o7", "Output 7", IO_ANY);
      addOutput("o8", "Output 8", IO_ANY);
      addOutput("o9", "Output 9", IO_ANY);
      addOutput("oa", "Output 10", IO_ANY);
      addOutput("ob", "Output 11", IO_ANY);
      addOutput("oc", "Output 12", IO_ANY);
   }

   public virtual copyFrom(ModCV_Shift _o) {
      rec_offset = _o.rec_offset;
      len_offset = _o.len_offset;

      out = _o.out;
   }

   public virtual initUI() {

      Module::initUI();

      float cx = 6;
      float cy = 26;
      float stepY = 22;
      float portOffX = 20;
      float portOffY = 22;
      float ledOffX = 10;
      float inStepX = 11;

      // In
      createPortWidget(0, false/*bOutput*/,
                       cx,
                       cy,
                       "i"/*captionOrNull*/
                       );

      // Sample Trig
      createPortWidget(1, false/*bOutput*/,
                       cx + inStepX*1,
                       cy,
                       "s"/*captionOrNull*/
                       );

      // Up
      createPortWidget(2, false/*bOutput*/,
                       cx + inStepX*2,
                       cy,
                       "u"/*captionOrNull*/
                       );

      // Down
      createPortWidget(3, false/*bOutput*/,
                       cx + inStepX*3,
                       cy,
                       "d"/*captionOrNull*/
                       );

      // Rec Offset
      cx = 10;
      cy += 31;
      createTinyDial(cx, cy,
                     "rec_offset",
                     -12.0, 12.0, 0.0, rec_offset,
                     "off"/*captionOrNull*/
                     );
      createPortWidget(4, false/*bOutput*/,
                       cx,
                       cy + portOffY,
                       null/*captionOrNull*/
                       );

      // Len
      cx = 12 + 24;
      createTinyDial(cx, cy,
                     "len_offset",
                     -12.0, 12.0, 0.0, len_offset,
                     "len"/*captionOrNull*/
                     );
      createPortWidget(5, false/*bOutput*/,
                       cx,
                       cy + portOffY,
                       null/*captionOrNull*/
                       );


      // Outputs
      cx = 9;
      cy += 39;
      float cyLEd = cy;

      // Outputs: Left
      int outIdx = 0;
      loop(6)
      {
         createPortWidget(outIdx + 0, true/*bOutput*/,
                          cx,
                          cy,
                          null/*captionOrNull*/
                          );
         createLED(cx + ledOffX, cy);

         outIdx++;
         cy += 20;
      }

      // Outputs: Right
      cy = cyLEd;
      cx += 24;
      loop(6)
      {
         createPortWidget(outIdx, true/*bOutput*/,
                          cx,
                          cy,
                          null/*captionOrNull*/
                          );
         createLED(cx + ledOffX, cy);
         outIdx++;
         cy += 20;
      }

      updateLEDs();
   }

   public virtual setParamByName(String _name, float _value) {
      switch(_name)
      {
         case "rec_offset":
            rec_offset = _value;
            break;

         case "len_offset":
            len_offset = _value;
            break;
      }
   }

   public virtual getParamByName(String _name) : float {
      switch(_name)
      {
         case "rec_offset":
            return rec_offset;

         case "len_offset":
            return len_offset;
      }
   }

   public virtual getNormalizedParamNames() : Object {
      return ["rec off", "len off"
              ];
   }

   public virtual setNormalizedParamByIndexUI(int _paramIdx, float _value) {
      switch(_paramIdx)
      {
         case 0:
            rec_offset = FromNormalized(_value, -12, 12);
            updateParamWidget("rec_offset", rec_offset);
            break;

         case 1:
            len_offset = FromNormalized(_value, -12, 12);
            updateParamWidget("len_offset", len_offset);
            break;
      }
   }

   public virtual getNormalizedParamByIndex(int _paramIdx) : float {
      switch(_paramIdx)
      {
         case 0:
            return ToNormalized(rec_offset, -12, 12);

         case 1:
            return ToNormalized(len_offset, -12, 12);
      }
      return 0.0f;
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 2;

      // params
      ofs.i8 = rec_offset;
      ofs.i8 = len_offset;

      // output values (v2+)
      ofs << out;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            // params
            rec_offset = ifs.s8;
            len_offset = ifs.s8;

            if(ver >= 2)
            {
               // output values (v2+)
               out << ifs;
            }

            return true;
         }
         else
         {
            trace "[---] ModCV_Shift::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   protected method rotateUp(int _off, int _len) : boolean {
      if(_len > 1)
      {
         float first = out[_off];
         int idx = _off;
         loop(_len - 1)
         {
            int nIdx = mathWrapi(idx + 1, 0, 12);
            out[idx] = out[nIdx];
            idx = nIdx;
         }
         out[(_off + _len - 1) % 12] = first;
         return true;
      }
      return false;
   }

   protected method rotateDown(int _off, int _len) : boolean {
      if(_len > 1)
      {
         int idx = (_off + _len - 1) % 12;
         float last = out[idx];
         loop(_len - 1)
         {
            int nIdx = mathWrapi(idx - 1, 0, 12);
            out[idx] = out[nIdx];
            idx = nIdx;
         }
         out[0] = last;
         return true;
      }
      return false;
   }

   protected method updateLEDs() {
      int outIdx = 0;
      loop(12)
      {
         setLED(outIdx, out[outIdx]);
         outIdx++;
      }
   }

   public virtual reset() {
      trig_sample.reset();
      trig_up.reset();
      trig_down.reset();
   }

   public virtual tick() {
      local float fIn = inputs[0].getValue();

      local int off = mathClampi(inputs[4].getValue() * 12, -12, 12) + rec_offset;
      off = mathWrapi(rec_offset, 0, 12);
      off = mathWrapi(rec_offset, 0, 12);

      local int len = mathClampi(inputs[5].getValue() * 12, -12, 12) + len_offset;
      len = mathWrapi(len_offset, 0, 12);
      len = mathWrapi(len_offset, 0, 12);
      len = mathMaxi(1, len_offset);

      if(trig_up.process(inputs[2].getValue()))
      {
         if(rotateUp(off, len))
            updateLEDs();
      }

      if(trig_down.process(inputs[3].getValue()))
      {
         if(rotateDown(off, len))
            updateLEDs();
      }

      if(trig_sample.process(inputs[1].getValue()))
      {
         if(!inputs[2].isConnected() && !inputs[3].isConnected())
            if(rotateDown(off, len))
               updateLEDs();

         out[off] = fIn;
         setLED(off, fIn);
      }

   }

}
