// ----
// ---- file   : modcv_input.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 26Mar2021
// ---- changed: 27Mar2021, 30Mar2021, 16Apr2021, 07May2021, 21Feb2022, 08Oct2024, 16Nov2024
// ----          23Mar2025
// ----
// ----
// ----

module MModularCVMod_Input;

use namespace ui;
namespace modularcv;


class ModCV_Input : Module {
   int port_index;
   PortSelectWidget *port_select_widget;
   Label *[] labels;


   public virtual init() {
      Module::init();

      initModule("Input"/*id*/,
                 "cv in"/*header_id*/,
                 "Input"/*tooltip*/
                 );
      setModuleSize(6, 3);

      addOutput("i1", "input value 1", IO_ANY);
      addOutput("i2", "input value 2", IO_ANY);
      addOutput("i3", "input value 3", IO_ANY);
      addOutput("i4", "input value 4", IO_ANY);
   }

   public virtual initUI() {

      Module::initUI();

      float cx = 15;
      float cy = 20;
      float stepY = 40;

      port_select_widget <= createPortSelectWidget(cx, cy, port_index, false/*bOutput*/);

      cx = 24;
      cy = 56;
      int pIdx = 0;
      loop(4)
      {
         String portId <= parent_node.getPortIdByIndex(pIdx + port_index);

         PortWidget pw <= createPortWidget(pIdx, true/*bOutput*/,
                                           cx,
                                           cy,
                                           portId/*captionOrNull*/
                                           );

         labels.add(pw.lb);

         cy += stepY;
         pIdx++;
      }
   }

   protected method handlePortChanged(int _portIndex) {
      port_index = _portIndex;
      int pIdx = 0;
      ui::Label *lb;
      foreach lb in labels
      {
         lb.setCaption(parent_node.getPortIdByIndex(pIdx + port_index));
         float w = lb.getCaptionWidth();
         float h = lb.getCaptionHeight();
         lb.setRequiredSize2f(w, h);
         lb.setPositionX(24*UI.font_scaling - w * 0.5 + 2*UI.font_scaling);
         pIdx++;
      }
      relayout();
      redraw();
      Global.Print("Base Input Port is "+(_portIndex + 1)+" ("+parent_node.getPortIdByIndex(port_index)+")");
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      ofs.i8 = port_index;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            port_index = ifs.u8;

            return true;
         }
         else
         {
            trace "[---] ModCV_Input::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   public method tickInput(MIDIPipeFrame _frIn, boolean _bAdvance) {
      // (note) this is called twice per song tick: 1st for frameRec, then for frameReplay
      //         'bAdvance' will be set to true for the second call
      //         the implementation must not decrement gate / active note countdowns unless bAdvance=true
      int pIdx = 0;
      loop(4)
      {
         float val = parent_node.readInput(_frIn, port_index + pIdx);
         if(val > INVALID_VALUE)
            out[pIdx] = val;
         pIdx++;
      }
   }

   public virtual onPortSelectionChanged() {
      port_select_widget.updatePortOptions(parent_node);
   }

   public virtual consumeAction(ui::Action _ac) : boolean {
      String acName <= _ac.getActionName();
      ui::ActionProvider *ap; ap <= _ac.getActionProvider();

      switch(@(ap))
      {
         case @(port_select_widget):
            handlePortChanged(port_select_widget.getSelectedPortIndex());
            return true;
      }

      return Module::consumeAction(_ac);
   }
}
