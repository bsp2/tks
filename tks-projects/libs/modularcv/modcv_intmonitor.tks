// ----
// ---- file   : modcv_intmonitor.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 08Oct2024
// ---- changed: 10Oct2024
// ----
// ----
// ----

module MModularCVMod_IntMonitor;

use namespace st2;
namespace modularcv;


class ModCV_IntMonitor : ModCV_Output {


   public virtual init() {
      Module::init();

      initModule("IntMonitor"/*id*/,
                 "int"/*header_id*/,
                 "Integer Monitor\n\n (note) the displayed values are scaled by 127"/*tooltip*/
                 );
      setModuleSize(3, 3);

      int dpyIdx = 0;
      loop(6)
      {
         addInput("i"+(dpyIdx+1), "Input "+(dpyIdx+1), 0.0, IO_ANY);
         dpyIdx++;
      }
   }

   public virtual initUI() {

      Module::initUI();

      float cx = 11;
      float cy = 2+10;
      float stepY = 30;
      float portOffY = 17;

      int dpyIdx = 0;
      loop(6)
      {
         cy += stepY;
         createPortWidget(dpyIdx, false/*bOutput*/,
                          cx,
                          cy,
                          null/*captionOrNull*/
                          );
         createValueDisplay(cx, cy - portOffY);
         dpyIdx++;
      }

   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            return true;
         }
         else
         {
            trace "[---] ModCV_IntMonitor::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   public virtual tickOutput(MIDIPipeFrame _frOut) {
      local int dpyIdx = 0;
      loop(6)
      {
         if(inputs[dpyIdx].isConnected())
         {
            local float f = inputs[dpyIdx].getValue();
            // if(0.0f != f)
            //    trace "xxx ["+current_song.song_offset+"] node.tick_nr="+parent_node.tick_nr+" imon["+dpyIdx+"] f="+f;
            f = round(f * 127.0f);
            updateValueDisplay(dpyIdx, mathClampf(int(f), -127.0f, 127.0f));
         }
         dpyIdx++;
      }
   }

}
