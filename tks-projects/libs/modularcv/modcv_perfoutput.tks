// ----
// ---- file   : modcv_perfoutput.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 21Apr2021
// ---- changed: 22Apr2021, 07May2021, 21Feb2022, 16Nov2024
// ----
// ----
// ----

module MModularCVMod_PerfOutput;

namespace modularcv;
use namespace st2;


class ModCV_PerfOutput : ModCV_Output {


   public virtual init() {
      Module::init();

      initModule("perf_output"/*id*/,
                 "p out"/*header_id*/,
                 "PerfCtl Output"/*tooltip*/
                 );
      setModuleSize(4, 3);

      addInput("mw", "Mod Wheel (CC#1)",      0.0f, IO_CV);
      addInput("bc", "Breath Control (CC#2)", 0.0f, IO_CV);
      addInput("fc", "Foot Control (CC#4)",   0.0f, IO_CV);
      addInput("ex", "Expression (CC#11)",    0.0f, IO_CV);
      addInput("at", "Aftertouch",            0.0f, IO_CV);
   }

   public virtual copyFrom(ModCV_PerfOutput _o) {
      port_index = _o.port_index;
   }

   public virtual initUI() {

      Module::initUI();

      float cx = 7;
      float cy = 20;

      port_select_widget <= createPortSelectWidget(cx, cy, port_index, true/*bOutput*/);

      PortWidget *pw;
      cx = 15;
      cy = 53;
      float stepY = 32;

      // Mod Wheel
      pw <= createPortWidget(0, false/*bOutput*/,
                             cx,
                             cy,
                             "mw"/*captionOrNull*/
                             );

      // Breath Control
      cy += stepY;
      pw <= createPortWidget(1, false/*bOutput*/,
                             cx,
                             cy,
                             "bc"/*captionOrNull*/
                             );

      // Foot Control
      cy += stepY;
      pw <= createPortWidget(2, false/*bOutput*/,
                             cx,
                             cy,
                             "fc"/*captionOrNull*/
                             );

      // Expression
      cy += stepY;
      pw <= createPortWidget(3, false/*bOutput*/,
                             cx,
                             cy,
                             "ex"/*captionOrNull*/
                             );

      // Aftertouch
      cy += stepY;
      pw <= createPortWidget(4, false/*bOutput*/,
                             cx,
                             cy,
                             "at"/*captionOrNull*/
                             );

   }

   protected virtual handlePortChanged(int _portIndex) {
      port_index = _portIndex;
      Global.Print("PerfCtl Output Port is "+(_portIndex + 1)+" ("+parent_node.getPortIdByIndex(port_index)+")");
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      ofs.i8  = port_index;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            port_index = ifs.u8;

            return true;
         }
         else
         {
            trace "[---] ModCV_PerfOutput::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   public virtual tickOutput(MIDIPipeFrame _frOut) {
      local CtlIOPort ioPort <= parent_node.getPortByIndex(port_index);
      if(null != ioPort)
      {
         if(ioPort.b_enable)
         {
            int numEv;
            int evIdx;
            MIDIPipeEvent ev;
            float f;

            // Mod Wheel
            if(inputs[0].isConnected())
            {
               f = inputs[0].getValue();
               _frOut.cc(true/*bSet*/, ioPort.dev_idx, ioPort.dev_ch, 1, f * 127.0);
            }

            // Breath Control
            if(inputs[1].isConnected())
            {
               f = inputs[1].getValue();
               _frOut.cc(true/*bSet*/, ioPort.dev_idx, ioPort.dev_ch, 2, f * 127.0);
            }

            // Foot Control
            if(inputs[2].isConnected())
            {
               f = inputs[2].getValue();
               _frOut.cc(true/*bSet*/, ioPort.dev_idx, ioPort.dev_ch, 4, f * 127.0);
            }

            // Expression
            if(inputs[3].isConnected())
            {
               f = inputs[3].getValue();
               _frOut.cc(true/*bSet*/, ioPort.dev_idx, ioPort.dev_ch, 11, f * 127.0);
            }

            // Channel Pressure
            if(inputs[4].isConnected())
            {
               f = inputs[4].getValue();
               _frOut.chPressure(true/*bSet*/, ioPort.dev_idx, ioPort.dev_ch, f * 127.0);
            }

         } // if ioPort.b_enable
      } // if ioPort
   }
}
