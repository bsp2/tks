// ----
// ---- file   : modcv_buttons.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : 10 buttons that emit gate signals and can also be controlled via keyboard ('1'..'0')
// ----
// ---- created: 23Oct2024
// ---- changed:
// ----
// ----
// ----

module MModularCVMod_Buttons;

use namespace ui;
namespace modularcv;


// <class.png>
class ModCV_Buttons : Module {

   RoundButton *[] buttons;

   IntArray button_states;
   IntArray button_modes;   // 0=momentary, 1=toggle

   Button *[] a_bt_mode;
   Button *[] a_bt_state;


   public virtual init() {
      Module::init();

      initModule("buttons"/*id*/,
                 "bt"/*header_id*/,
                 "Buttons\n\n (note) keyboard '1' .. '0'"/*tooltip*/
                 );
      setModuleSize(5, 3);

      addOutput("out_1",  "Output 1",  IO_GATE);
      addOutput("out_2",  "Output 2",  IO_GATE);
      addOutput("out_3",  "Output 3",  IO_GATE);
      addOutput("out_4",  "Output 4",  IO_GATE);
      addOutput("out_5",  "Output 5",  IO_GATE);
      addOutput("out_6",  "Output 6",  IO_GATE);
      addOutput("out_7",  "Output 7",  IO_GATE);
      addOutput("out_8",  "Output 8",  IO_GATE);
      addOutput("out_9",  "Output 9",  IO_GATE);
      addOutput("out_10", "Output 10", IO_GATE);

      button_states.allocAndFill(10, false);
      button_modes .allocAndFill(10, false);
   }

   public virtual copyFrom(ModCV_Buttons _o) {
      button_states = _o.button_states;
      button_modes  = _o.button_modes;
   }

   public virtual initUI() {

      Module::initUI();

      float cx = RACK_UNIT_WIDTH * 3;
      float cy = 30;
      float stepY = 18;
      float offXMode  = -19;
      float offYMode  =   0;
      float offXState =  -7;
      float offYState =   0.5;
      float offXPort  =   6;
      float offYPort  =   0;
      Button *bt;

      int btIdx = 0;
      loop(10)
      {
         // Mode
         bt <= createTinyCheckButton(cx + offXMode, cy + offYMode,
                                     "bt_mode_"+btIdx,
                                     button_modes.get(btIdx)
                                     );
         bt.setToggleState(button_modes.get(btIdx));
         a_bt_mode.add(bt);

         // State
         bt <= createSmallCheckButton(cx + offXState, cy + offYState,
                                      "bt_state_"+btIdx,
                                      button_states.get(btIdx)
                                      );
         a_bt_state.add(bt);
         bt.setEnableToggle(button_modes.get(btIdx));
         bt.setToggleState(button_states.get(btIdx));
         bt.setEnableDelta(0 == button_modes.get(btIdx)); // send press/release actions (momentary)

         // Output
         createPortWidget(btIdx, true/*bOutput*/,
                          cx + offXPort, cy + offYPort,
                          null/*captionOrNull*/
                          );

         // Next button / output
         cy += stepY;
         btIdx++;
      }

   }

   protected method updateButtonWidgets() {
      if(!a_bt_state.isEmpty())
      {
         int btIdx = 0;
         Button *bt;
         loop(10)
         {
            // Mode
            bt <= a_bt_mode[btIdx];
            bt.setToggleState(button_modes[btIdx]);

            // State
            bt <= a_bt_state[btIdx];
            bt.setEnableToggle(button_modes[btIdx]);
            bt.setToggleState(button_states[btIdx]);
            bt.setEnableDelta(0 == button_modes.get(btIdx)); // send press/release actions (momentary)

            // Next button / output
            btIdx++;
         }
      }
   }

   public virtual setParamByName(String _name, float _value) {
      int btIdx;
      // // trace "xxx ModCV_Buttons::setParamByName: name=\""+_name+"\" value="+_value;

      switch(_name)
      {
         default:
            if(_name <= "bt_mode_")
            {
               btIdx = _name.replace("bt_mode_", "");
               button_modes[btIdx] = (_value >= 0.5f);
               if(0 == button_modes[btIdx])
                  button_states[btIdx] = false;
               updateButtonWidgets();
            }
            else if(_name <= "bt_state_")
            {
               btIdx = _name.replace("bt_state_", "");
               button_states[btIdx] = (_value >= 0.5f);
               updateButtonWidgets();
            }
            break;
      }
   }

   public virtual getParamByName(String _name) : float {
      int btIdx;
      switch(_name)
      {
         default:
            if(_name <= "bt_mode_")
            {
               btIdx = _name.replace("bt_mode_", "");
               return button_modes[btIdx];
            }
            else if(_name <= "bt_state_")
            {
               btIdx = _name.replace("bt_state_", "");
               return button_states[btIdx];
            }
            break;
      }
   }

   public virtual getNormalizedParamNames() : Object {
      return ["bt_state_0",
              "bt_state_1",
              "bt_state_2",
              "bt_state_3",
              "bt_state_4",
              "bt_state_5",
              "bt_state_6",
              "bt_state_7",
              "bt_state_8",
              "bt_state_9",
              ];
   }

   public virtual setNormalizedParamByIndexUI(int _paramIdx, float _value) {
      switch(_paramIdx)
      {
         default:
            if(0 <= _paramIdx < 10)
            {
               button_states[_paramIdx] = (_value >= 0.5f);
               updateButtonWidgets();
            }
            break;
      }
   }

   public virtual getNormalizedParamByIndex(int _paramIdx) : float {
      if(0 <= _paramIdx < 10)
         return button_states[_paramIdx];
   }

   public virtual handleRackKey(Key _k) : boolean {
      if(_k.mod)
         return false;

      int btIdx;
      Button *bt;

      switch(_k.pressed)
      {
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            btIdx = _k.pressed - '1';
            bt <= a_bt_state.get(btIdx);
            if(bt.getEnableDelta()) // momentary ?
               bt.handleBeginPress(false/*bRMB*/);
            else
               bt.toggleStateAction();
            return true;
         case '0':
            btIdx = 9;
            bt <= a_bt_state.get(9);
            if(bt.getEnableDelta()) // momentary ?
               bt.handleBeginPress(false/*bRMB*/);
            else
               bt.toggleStateAction();
            return true;
      }

      switch(_k.released)
      {
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            btIdx = _k.released - '1';
            bt <= a_bt_state.get(btIdx);
            if(bt.getEnableDelta()) // momentary ?
               bt.handleEndPress();
            return true;
         case '0':
            btIdx = 9;
            bt <= a_bt_state.get(btIdx);
            if(bt.getEnableDelta()) // momentary ?
               bt.handleEndPress();
            return true;
      }

      return false;
   }

   public method wantRackKeyRepeat(Key _k) : boolean {
      switch(_k.code)
      {
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '0':
            return false;
      }
      return maybe;
   }

   public virtual handleShowModule() {
      updateButtonWidgets();
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      // Toggle modes
      ofs.i16 =
         (button_modes.get(0) << 0) |
         (button_modes.get(1) << 1) |
         (button_modes.get(2) << 2) |
         (button_modes.get(3) << 3) |
         (button_modes.get(4) << 4) |
         (button_modes.get(5) << 5) |
         (button_modes.get(6) << 6) |
         (button_modes.get(7) << 7) |
         (button_modes.get(8) << 8) |
         (button_modes.get(9) << 9) ;

      // States
      ofs.i16 =
         (button_states.get(0) << 0) |
         (button_states.get(1) << 1) |
         (button_states.get(2) << 2) |
         (button_states.get(3) << 3) |
         (button_states.get(4) << 4) |
         (button_states.get(5) << 5) |
         (button_states.get(6) << 6) |
         (button_states.get(7) << 7) |
         (button_states.get(8) << 8) |
         (button_states.get(9) << 9) ;
   }

   protected static BitsToArray(IntArray _d, short _bits) {
      int idx = 0;
      loop(10)
      {
         _d[idx] = (_bits & (1 << idx)) >> idx;
         idx++;
      }
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            short bits;

            // Toggle modes
            bits = ifs.u16;
            BitsToArray(button_modes, bits);

            // States
            bits = ifs.u16;
            BitsToArray(button_states, bits);

            return true;
         }
         else
         {
            trace "[---] ModCV_Buttons::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   // public virtual reset() {
   // }

   public virtual tick() {
      // trace "xxx button_states="+button_states;
      int idx = 0;
      loop(10)
      {
         out[idx] = button_states[idx];
         idx++;
      }
   }

}
