// ----
// ---- file   : modcv_pan.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2023 by Bastian Spiegel. 
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See 
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : 
// ----
// ---- created: 01Apr2021
// ---- changed: 03Apr2021, 16Apr2021, 01May2021, 07May2021, 28Dec2021, 21Feb2022, 11Nov2023
// ----
// ----
// ----

module MModularCVMod_Pan;

namespace modularcv;


class ModCV_Pan : Module {

   float pan_offset;  // -1..1


   public virtual init() {
      Module::init();

      initModule("Pan"/*id*/,
                 "pan"/*header_id*/,
                 "Pan"/*tooltip*/
                 );
      setModuleSize(4, 3);

      pan_offset = 0.0;

      addInput("in",  "In",                 0.0, IO_ANY);
      addInput("pan", "Pan (-1=L .. +1=R)", 0.0, IO_ANY);

      addOutput("out_l", "Output L", IO_ANY);
      addOutput("out_r", "Output R", IO_ANY);
   }

   public virtual copyFrom(ModCV_Pan _o) {
      pan_offset = _o.pan_offset;
   }

   public virtual initUI() {

      Module::initUI();

      float cy = 34;
      float stepYI = 24;
      float stepYO = 38;
      ui::Dial *dl;

      // Input
      createPortWidget(0, false/*bOutput*/,
                       15, 32,
                       null/*captionOrNull*/
                       );

      // L
      cy += stepYO;
      createPortWidget(0, true/*bOutput*/,
                       15, cy,
                       "L"/*captionOrNull*/
                       );

      // Pan
      cy += stepYO+2;
      dl <= createTinyDial(15, cy,
                           "pan_offset",
                           -1.0, 1.0, 0.0, pan_offset,
                           "pan"
                           );
      dl.setResetValues([0.0f, 1.0f, -1.0f]);

      cy += stepYI;
      createPortWidget(1, false/*bOutput*/,
                       15, cy,
                       null/*captionOrNull*/
                       );


      // R
      cy += stepYO-8;
      createPortWidget(1, true/*bOutput*/,
                       15, cy,
                       "R"/*captionOrNull*/
                       );

   }

   public virtual setParamByName(String _name, float _value) {
      switch(_name)
      {
         case "pan_offset":
            pan_offset = _value;
            break;
      }
   }

   public virtual getParamByName(String _name) : float {
      switch(_name)
      {
         case "pan_offset":
            return pan_offset;
      }
   }

   public virtual getNormalizedParamNames() : Object {
      return ["pan off"
              ];
   }

   public virtual setNormalizedParamByIndexUI(int _paramIdx, float _value) {
      switch(_paramIdx)
      {
         case 0:
            pan_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("pan_offset", pan_offset);
            break;
      }
   }

   public virtual getNormalizedParamByIndex(int _paramIdx) : float {
      switch(_paramIdx)
      {
         case 0:
            return ToNormalized(pan_offset, -1, 1);
      }
      return 0.0f;
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 1;

      // params
      ofs.f32 = pan_offset;
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            // params
            pan_offset = ifs.f32;

            return true;
         }
         else
         {
            trace "[---] ModCV_Pan::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   public virtual tick() {
      local float fIn  = inputs[0].getValue();
      local float fPan = mathClampf(inputs[1].getValue() + pan_offset, -1.0f, 1.0f);

      out[0] = fIn * (fPan < 0.0f) ? 1.0f : (1.0f - fPan);
      out[1] = fIn * (fPan > 0.0f) ? 1.0f : (1.0f + fPan);
   }
}
