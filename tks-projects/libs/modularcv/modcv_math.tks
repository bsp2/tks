// ----
// ---- file   : modcv_math.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 02Apr2021
// ---- changed: 03Apr2021, 05Apr2021, 12Apr2021, 14Apr2021, 16Apr2021, 20Apr2021, 07May2021
// ----          09Dec2021, 22Dec2021, 28Dec2021, 21Feb2022, 10Oct2024, 12Oct2024, 23Oct2024
// ----          01Nov2024, 02Nov2024, 03Nov2024
// ----
// ----
// ----

module MModularCVMod_Math;

namespace modularcv;


class ModCV_Math : Module {
   define int OP_ABS            =  0;
   define int OP_AND            =  1;
   define int OP_MIN            =  2;
   define int OP_OR             =  3;
   define int OP_MAX            =  4;
   define int OP_EOR            =  5;
   define int OP_NAND           =  6;
   define int OP_NOR            =  7;
   define int OP_ADD            =  8;
   define int OP_AVG            =  9;
   define int OP_SUB            = 10;
   define int OP_DIFF           = 11;
   define int OP_MUL            = 12;
   define int OP_RM             = 13;
   define int OP_POW            = 14;
   define int OP_LT             = 15;
   define int OP_LE             = 16;
   define int OP_EQ             = 17;
   define int OP_NE             = 18;
   define int OP_GE             = 19;
   define int OP_GT             = 20;
   define int OP_CMP            = 21;
   define int OP_SIGN           = 22;
   define int OP_4AND           = 23;
   define int OP_8AND           = 24;
   define int OP_16AND          = 25;
   define int OP_4OR            = 26;
   define int OP_8OR            = 27;
   define int OP_16OR           = 28;
   define int OP_4EOR           = 29;
   define int OP_8EOR           = 30;
   define int OP_16EOR          = 31;
   define int OP_4S             = 32;
   define int OP_8S             = 33;
   define int OP_16S            = 34;
   define int OP_4G             = 35;
   define int OP_8G             = 36;
   define int OP_16G            = 37;
   define int OP_PROB           = 38;
   define int OP_QUANT          = 39;
   define int OP_CURVE          = 40;
   define int OP_CROSS          = 41;
   define int OP_RISE           = 42;
   define int OP_FALL           = 43;
   define int OP_RAND           = 44;
   define int OP_SH             = 45;
   define int OP_QPOW2          = 46;  // quantize to power of two: 1, 0.5, 0.25, 0.125, 0.0625, ..
   define int OP_TH             = 47;
   define int OP_CLAMP_0B       = 48;  //  0..b (v5+)
   define int OP_CLAMP_B        = 49;  // -b..b
   define int OP_WRAP_0B        = 50;  //  0..b
   define int OP_WRAP_B         = 51;  // -b..b
   define int OP_FOLD_0B        = 52;  //  0..b
   define int OP_FOLD_B         = 53;  // -b..b
   define int OP_POW2_1         = 54;  // a * pow(2,b) (/2..*1..*2)
   define int OP_POW2_1I        = 55;  // e.g. a*pow(2,-0.9)     = pow(2,sign(-0.9)*round(abs(-0.9))) = a*(1/2)  (/2,*1,*2)
   define int OP_POW2_2         = 56;  // a * pow(2,b*2)
   define int OP_POW2_2I        = 57;  // e.g. a*pow(2,-0.8*2)   = pow(2,sign(-1.6)*round(abs(-1.6))) = a*(1/4)  (/4,/2,*1,*2,*4)
   define int OP_POW2_3         = 58;  // a * pow(2,b*3)
   define int OP_POW2_3I        = 59;  // e.g. a*pow(2,-0.9*3)   = pow(2,sign(-2.7)*round(abs(-2.7))) = a*(1/8)  (/8;/4,/2,*1,*2,*4,*8)
   define int OP_POW2_4         = 60;  // a * pow(2,b*4) (/16..*1..*16)
   define int OP_POW2_4I        = 61;  // e.g. a*pow(2,-0.975*4) = pow(2,sign(-3.9)*round(abs(-3.9))) = a*(1/16) (/16,/8;/4,/2,*1,*2,*4,*8,*16)
   define int OP_A_CHANGE       = 62;  // emit 1 if 'a' differs from slewed 'last_a' (b=slew amount)
   define int OP_A_DELTA        = 63;  // emit delta between 'a' and slewed 'last_a' (a - last_a) (b=slew amount)
   define int OP_U2B            = 64;  // scale by 'b' and convert unipolar to bipolar
   define int OP_B2U            = 65;  // scale by 'b' and convert bipolar to unipolar
   define int OP_STH            = 66;  // sample&hold new a when a is >= b
   define int OP_GTS            = 67;  // only pass gate 'a' when value 'b' is not equal to last gate-sampled value
   define int OP_GTL            = 68;  // only pass gate 'a' when value 'b' is not equal to last value
   define int OP_SAT            = 69;  // saturate(a * (1 + b))
   int op;

   static StringArray op_short_names =
      ["abs",    //
       "&&",     //  1
       "min",    //  2
       "||",     //  3
       "mx",     //  4
       "^^",     //  5
       "!&",     //  6
       "!|",     //  7
       "+",      //  8
       "a",      //  9
       "-",      // 10
       "d",      // 11
       "*",      // 12
       "rm",     // 13
       "p",      // 14
       "<",      // 15
       "<=",     // 16
       "==",     // 17
       "!=",     // 18
       ">=",     // 19
       ">",      // 20
       "c",      // 21
       "s",      // 22
       "4&",     // 23
       "8&",     // 24
       "6&",     // 25
       "4|",     // 26
       "8|",     // 27
       "6|",     // 28
       "4^",     // 29
       "8^",     // 30
       "6^",     // 31
       "4g",     // 32
       "8g",     // 33
       "6g",     // 34
       "4s",     // 35
       "8s",     // 36
       "6s",     // 37
       "pro",    // 38
       "q",      // 39
       "v",      // 40
       "x",      // 41
       "ris",    // 42
       "fal",    // 43
       "rnd",    // 44
       "sh",     // 45
       "q2",     // 46
       "th",     // 47
       "cl0",    // 48
       "cls",    // 49
       "wr0",    // 50
       "wrs",    // 51
       "fl0",    // 52
       "fls",    // 53
       "2^",     // 54
       "2^i",    // 55
       "2^2",    // 56
       "2*2i",   // 57
       "2^3",    // 58
       "2^3i",   // 59
       "2^4",    // 60
       "2^4i",   // 61
       "chg",    // 62
       "delt",   // 63
       "u2b",    // 64
       "b2u",    // 65
       "sth",    // 66
       "gts",    // 67
       "gtl",    // 68
       "sat",    // 69
       ];

   static StringArray op_long_names =
      ["abs\tAbs (a=in)",        //  0
       "&&\tLogic And",          //  1
       "min\tMin (analog And) ", //  2
       "||\tLogic Or",           //  3
       "mx\tMax (analog Or)",    //  4
       "^^\tExlusive Or",        //  5
       "!&\tNot-And (NAND)",     //  6
       "!|\tNot-Or (NOR)",       //  7
       "+\tAdd",                 //  8
       "avg\tAvg",               //  9
       "-\tSub",                 // 10
       "d\tDiff",                // 11
       "*\tMul",                 // 12
       "rm\tRing-Mod (4q Mul)",  // 13
       "pow\tPow",               // 14
       "<\tLess",                // 15
       "<=\tLess Equal",         // 16
       "==\tEqual",              // 17
       "!=\tNot Equal",          // 18
       ">=\tGreater Equal",      // 19
       ">\tGreater Than",        // 20
       "cmp\tCompare",           // 21
       "s\tSign (copy from b)",  // 22
       "4&\t4-bit bitwise And",  // 23
       "8&\t8-bit bitwise And",  // 24
       "6&\t16-bit bitwise And", // 25
       "4|\t4-bit bitwise Or",   // 26
       "8|\t8-bit bitwise Or",   // 27
       "16|\t16-bit bitwise Or", // 28
       "4^\t4-bit bitwise Eor",  // 29
       "8^\t8-bit bitwise Eor",  // 30
       "16^\t16-bit bitwise Eor",// 31
       "4s\t4-bit set bit",      // 32
       "8s\t8-bit set bit",      // 33
       "16s\t16-bit set bit",    // 34
       "4g\t4-bit get bit",      // 35
       "8g\t8-bit get bit",      // 36
       "16g\t16-bit get bit",    // 37
       "pro\t Probability (a=chance -1..1, b_off=seed, b=trig)", // 38
       "q\tQuantize (b=step)",                  // 39
       "v\tCurve (b=log..lin..exp)",            // 40
       "x\tB Crossing Detect",                  // 41
       "ris\ta >= b Edge Detect",               // 42
       "fal\ta < b Edge Detect",                // 43
       "rnd\tRandom (a_off=seed b=color)",      // 44
       "sh\tSample and Hold (b=trig)",          // 45
       "q2\tQuantize to Power-of-Two (a=in)",   // 46
       "th\tTrack and Hold (b=trig, b_off=decay(0=none))", // 47
       "cl0\tClamp to 0..b",                    // 48
       "cls\tClamp to -b..b",                   // 49
       "wr0\tWrap into range 0..b",             // 50
       "wrs\tWrap into range -b..b",            // 51
       "fl0\tFold into range 0..b",             // 52
       "fls\tFold into range -b..b",            // 53
       "2^\tMultiply by pow(2,b)",              // 54
       "2^i\tMultiply by pow(2,round(b))",      // 55
       "2^2\tMultiply by pow(2,b*2)",           // 56
       "2^2i\tMultiply by pow(2,round(b*2))",   // 57
       "2^3\tMultiply by pow(2,b*3)",           // 58
       "2^3i\tMultiply by pow(2,round(b*3))",   // 59
       "2^4\tMultiply by pow(2,b*4)",           // 60
       "2^4i\tMultiply by pow(2,round(b*4))" ,  // 61
       "chg\t 1.0 if a differs from slewed last_a (b=slew amt)",  // 62
       "delt\t Diff between a and slewed last_a (b=slew amt)",    // 63
       "u2b\t(abs(a)*2-1) * b",                 // 64
       "b2u\tabs( (a+1)*0.5 * b )",             // 65
       "sth\ tSample&hold new a when a is >= b (-0.8 for CVSeq16)", // 66
       "gts\tPass gate a when b != last gate-sampled b", // 67
       "gtl\tPass gate a when b != last b",              // 68
       "sat\tsaturate(a * (1 + b))",                     // 69
       ];

   float a_offset;
   float b_offset;

   protected float   last_a;
   protected float   last_a_slewed;  // OP_A_CHANGE, OP_A_DELTA
   protected boolean b_allow_trig_b;
   protected int     rand_seed_1;
   protected int     rand_seed_2;
   protected float   last_sampled_b;

   protected Double th_a;
   protected Double d_one = 1;


   public virtual init() {
      Module::init();

      initModule("Math"/*id*/,
                 "math"/*header_id*/,
                 "Math"/*tooltip*/
                 );
      setModuleSize(4, 3);

      a_offset = 0.0f;
      b_offset = 0.0f;

      last_a         = INVALID_VALUE;
      last_a_slewed  = INVALID_VALUE;
      b_allow_trig_b = true;
      last_sampled_b = INVALID_VALUE;

      addInput("a", "a", 0.0, IO_ANY);
      addInput("b", "b", 0.0, IO_ANY);

      addOutput("out", "Output", IO_ANY);
   }

   protected method updateIOClasses() {
      Input inA <= getInputByIndex(0);
      Input inB <= getInputByIndex(1);
      Output out <= getOutputByIndex(0);

      switch(op)
      {
         default:
         case OP_ABS:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_AND:
            inA.io_class = IO_GATE;
            inB.io_class = IO_GATE;
            out.io_class = IO_GATE;
            break;

         case OP_MIN:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_OR:
            inA.io_class = IO_GATE;
            inB.io_class = IO_GATE;
            out.io_class = IO_GATE;
            break;

         case OP_MAX:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_EOR:
            inA.io_class = IO_GATE;
            inB.io_class = IO_GATE;
            out.io_class = IO_GATE;
            break;

         case OP_NAND:
            inA.io_class = IO_GATE;
            inB.io_class = IO_GATE;
            out.io_class = IO_GATE;
            break;

         case OP_NOR:
            inA.io_class = IO_GATE;
            inB.io_class = IO_GATE;
            out.io_class = IO_GATE;
            break;

         case OP_ADD:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_AVG:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_SUB:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_DIFF:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_MUL:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_RM:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_POW:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_LT:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_LE:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_EQ:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_NE:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_GE:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_GT:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_CMP:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_SIGN:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_4AND:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_8AND:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_16AND:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_4OR:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_8OR:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_16OR:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_4EOR:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_8EOR:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_16EOR:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_4G:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_8G:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_16G:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_4S:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_8S:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_16S:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_PROB:
            inA.io_class = IO_ANY;
            inB.io_class = IO_GATE;
            out.io_class = IO_GATE;
            break;

         case OP_QUANT:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_CURVE:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_CROSS:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_RAND:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_SH:
            inA.io_class = IO_ANY;
            inB.io_class = IO_CLOCK;
            out.io_class = IO_ANY;
            break;

         case OP_QPOW2:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_TH:
            inA.io_class = IO_ANY;
            inB.io_class = IO_GATE;
            out.io_class = IO_ANY;
            break;

         case OP_CLAMP_0B:
         case OP_CLAMP_B:
         case OP_WRAP_0B:
         case OP_WRAP_B:
         case OP_FOLD_0B:
         case OP_FOLD_B:
         case OP_POW2_1:
         case OP_POW2_1I:
         case OP_POW2_2:
         case OP_POW2_2I:
         case OP_POW2_3:
         case OP_POW2_3I:
         case OP_POW2_4:
         case OP_POW2_4I:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_A_CHANGE:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_A_DELTA:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;

         case OP_GTS:
         case OP_GTL:
            inA.io_class = IO_GATE;
            inB.io_class = IO_ANY;
            out.io_class = IO_GATE;
            break;

         case OP_SAT:
            inA.io_class = IO_ANY;
            inB.io_class = IO_ANY;
            out.io_class = IO_ANY;
            break;
      }
   }

   public virtual copyFrom(ModCV_Math _o) {
      op       = _o.op;
      a_offset = _o.a_offset;
      b_offset = _o.b_offset;
      updateIOClasses();
   }

   public virtual initUI() {

      Module::initUI();

      float cx = 15;
      float cy = 30;
      float stepY = 48;
      ui::Dial *dl;

      createModeParamWidget(cx, cy,
                            "op",
                            op_short_names,
                            op_long_names,
                            op,
                            "op"/*captionOrNull*/
                            );
      cy += stepY;


      // A
      dl <= createSmallDial(15, cy,
                            "a_offset",
                            -1.0, 1.0, 0.0, a_offset,
                            "a"
                            );
      dl.setPrecision(4);
      dl.setResetValues([0.0f, 1.0f]);
      dl.setPresetOptions([-1,   -0.75,  -0.5,   -0.25,  -0.125, 0.0f, 0.125, 0.25,  0.5,   0.75,  1.0],
                          ["-1", "-3/4", "-1/2", "-1/4", "-1/8", "0",  "1/8", "1/4", "1/2", "3/4", "1"]
                          );
      dl.setResetValues([0.0f, 1.0, -1.0f]);
      dl.setStep(1.0f / 32);


      cy += 28;
      createPortWidget(0, false/*bOutput*/,
                       15, cy,
                       null/*captionOrNull*/
                       );


      // B
      cy += 26;
      dl <= createSmallDial(15, cy,
                            "b_offset",
                            -1.0, 1.0, 0.0, b_offset,
                            "b"
                            );
      dl.setPrecision(4);
      dl.setResetValues([0.0f, 1.0f]);
      dl.setPresetOptions([-1,   -0.75,  -0.5,   -0.25,  -0.125, 0.0f, 0.125, 0.25,  0.5,   0.75,  1.0],
                          ["-1", "-3/4", "-1/2", "-1/4", "-1/8", "0",  "1/8", "1/4", "1/2", "3/4", "1"]
                          );
      dl.setResetValues([0.0f, 1.0, -1.0f]);
      dl.setStep(1.0f / 32);

      cy += 28;
      createPortWidget(1, false/*bOutput*/,
                       15, cy,
                       null/*captionOrNull*/
                       );


      // Output
      createPortWidget(0, true/*bOutput*/,
                       cx, (RACK_MODULE_HEIGHT - 20),
                       null/*captionOrNull*/
                       );
   }

   public virtual setParamByName(String _name, float _value) {
      switch(_name)
      {
         case "op":
            op = _value;
            updateIOClasses();
            break;

         case "a_offset":
            a_offset = _value;
            reset();
            break;

         case "b_offset":
            b_offset = _value;
            break;
      }
   }

   public virtual getParamByName(String _name) : float {
      switch(_name)
      {
         case "op":
            return op;

         case "a_offset":
            return a_offset;

         case "b_offset":
            return b_offset;
      }
   }

   public virtual getNormalizedParamNames() : Object {
      return ["op", "a offset", "b offset"
              ];
   }

   public virtual setNormalizedParamByIndexUI(int _paramIdx, float _value) {
      switch(_paramIdx)
      {
         case 0:
            op = FromNormalized(_value, 0, op_short_names.numElements-1);
            updateParamWidget("op", op);
            updateIOClasses();
            break;

         case 1:
            a_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("a_offset", a_offset);
            reset();  // OP_RAND
            break;

         case 2:
            b_offset = FromNormalized(_value, -1, 1);
            updateParamWidget("b_offset", b_offset);
            break;
      }
   }

   public virtual getNormalizedParamByIndex(int _paramIdx) : float {
      switch(_paramIdx)
      {
         case 0:
            return ToNormalized(op, 0, op_short_names.numElements-1);

         case 1:
            return ToNormalized(a_offset, -1, 1);

         case 2:
            return ToNormalized(b_offset, -1, 1);
      }
      return 0.0f;
   }

   protected method calcRand() : float {
      int fb1 = rand_seed_1 & 1;
      rand_seed_1 >>= 1;
      if(0 != fb1)
         rand_seed_1 ^= 0xB4BCD35C;

      int fb2 = rand_seed_2 & 1;
      rand_seed_2 >>= 1;
      if(0 != fb2)
         rand_seed_2 ^= 0x7A5BC2E3;

      int r16 = (rand_seed_1 ^ rand_seed_2) & 0xFFFF;
      return (r16 - 0x8000) / float(0x8000);  // => -1..1
   }

   public virtual saveState(Stream ofs) {
      Module::saveState(ofs);

      // ver
      ofs.i16 = 5;

      // params
      ofs.i8  = op;
      ofs.f32 = a_offset; // v2+
      ofs.f32 = b_offset; // v2+
   }

   public virtual loadState(Stream ifs) : boolean {
      if(Module::loadState(ifs))
      {
         short ver = ifs.u16;
         if(ver >= 1)
         {
            // params
            op = ifs.u8;

            if(ver < 3)
               if(op >= 41)  // OP_RISE, OP_FALL added in v3
                  op += 2;

            if(ver < 4)
               op++;  // OP_AND added in v4

            if(ver >= 2)
            {
               a_offset = ifs.f32;
               b_offset = ifs.f32;
            }

            updateIOClasses();

            return true;
         }
         else
         {
            trace "[---] ModCV_Math::loadState: invalid ver="+ver;
         }
      }
      return false;
   }

   public virtual reset() {
      last_a         = INVALID_VALUE;
      last_a_slewed  = INVALID_VALUE;
      b_allow_trig_b = true;
      last_sampled_b = INVALID_VALUE;

      float fSeed = (OP_PROB == op) ? b_offset : a_offset;
      rand_seed_1 = int(fSeed * 0x7FFFFFF) ^ 0xAAAAaaaa;// ^ 0xd89dcfbdu;
      rand_seed_2 = int(-fSeed * 0x7FFFFFF) ^ 0x55555555;// ^ 0x3fb8deacu;
      loop(abs(int(fSeed*32))&31)
         calcRand();
   }

   public virtual tick() {
      local float inA = inputs[0].getValue();
      local float a   = inA + a_offset;

      local float inB = inputs[1].getValue();
      local float b   = inB + b_offset;

      switch(op)
      {
         default:
         case OP_ABS:
            out[0] = abs(a);
            break;

         case OP_AND:
            out[0] = ((a >= TRIG_ON) && (b >= TRIG_ON)) ? 1.0f : 0.0f;
            break;

         case OP_MIN:
            out[0] = mathMinf(a, b);
            break;

         case OP_OR:
            out[0] = ((a >= TRIG_ON) || (b >= TRIG_ON)) ? 1.0f : 0.0f;
            break;

         case OP_MAX:
            out[0] = mathMaxf(a, b);
            break;

         case OP_EOR:
            out[0] = ((a >= TRIG_ON) ^ (b >= TRIG_ON)) ? 1.0f : 0.0f;
            break;

         case OP_NAND:
            out[0] = !((a >= TRIG_ON) && (b >= TRIG_ON)) ? 1.0f : 0.0f;
            break;

         case OP_NOR:
            out[0] = !((a >= TRIG_ON) || (b >= TRIG_ON)) ? 1.0f : 0.0f;
            break;

         case OP_ADD:
            out[0] = a + b;
            break;

         case OP_AVG:
            out[0] = (a + b) * 0.5;
            break;

         case OP_SUB:
            out[0] = a - b;
            break;

         case OP_DIFF:
            out[0] = abs(a - b);
            break;

         case OP_MUL:
            out[0] = a * b;
            break;

         case OP_RM:
            a *= 0.5f;
            b *= 0.5f;
            out[0] = (-a * -b) + (a * b);
            break;

         case OP_POW:
            out[0] = mathPowerf(a, b);
            break;

         case OP_LT:
            out[0] = (a < b) ? 1.0f : 0.0f;
            break;

         case OP_LE:
            out[0] = (a <= b) ? 1.0f : 0.0f;
            break;

         case OP_EQ:
            out[0] = (a == b) ? 1.0f : 0.0f;
            break;

         case OP_NE:
            out[0] = (a != b) ? 1.0f : 0.0f;
            break;

         case OP_GE:
            out[0] = (a >= b) ? 1.0f : 0.0f;
            break;

         case OP_GT:
            out[0] = (a > b) ? 1.0f : 0.0f;
            break;

         case OP_CMP:
            out[0] = (a - b);
            if(out[0] < 0.0f)
               out[0] = -1.0f;
            else if(out[0] > 0.0f)
               out[0] = 1.0f;
            break;

         case OP_SIGN:
            out[0] = abs(a);
            if(b < 0.0f)
               out[0] = -out[0];
            break;

         case OP_4AND:
            out[0] = (mathClampi(a*16, 0, 15) & mathClampi(b*16, 0, 15)) / 15.0;
            break;

         case OP_8AND:
            out[0] = (mathClampi(a*256, 0, 255) & mathClampi(b*256, 0, 255)) / 255.0;
            break;

         case OP_16AND:
            out[0] = (mathClampi(a*65536, 0, 65535) & mathClampi(b*65536, 0, 65535)) / 65535.0;
            break;

         case OP_4OR:
            out[0] = (mathClampi(a*16, 0, 15) | mathClampi(b*16, 0, 15)) / 15.0;
            break;

         case OP_8OR:
            out[0] = (mathClampi(a*256, 0, 255) | mathClampi(b*256, 0, 255)) / 255.0;
            break;

         case OP_16OR:
            out[0] = (mathClampi(a*65536, 0, 65535) | mathClampi(b*65536, 0, 65535)) / 65535.0;
            break;

         case OP_4EOR:
            out[0] = (mathClampi(a*16, 0, 15) ^ mathClampi(b*16, 0, 15)) / 15.0;
            break;

         case OP_8EOR:
            out[0] = (mathClampi(a*256, 0, 255) ^ mathClampi(b*256, 0, 255)) / 255.0;
            break;

         case OP_16EOR:
            out[0] = (mathClampi(a*65536, 0, 65535) ^ mathClampi(b*65536, 0, 65535)) / 65535.0;
            break;

         case OP_4G:
            out[0] = (mathClampi(a*16, 0, 15) & mathClampi(b*4, 0, 3)) ? 1.0f : 0.0f;
            break;

         case OP_8G:
            out[0] = (mathClampi(a*256, 0, 255) & mathClampi(b*8, 0, 7)) ? 1.0f : 0.0f;
            break;

         case OP_16G:
            out[0] = (mathClampi(a*65536, 0, 65535) & mathClampi(b*16, 0, 15)) ? 1.0f : 0.0f;
            break;

         case OP_4S:
            out[0] = (mathClampi(a*16, 0, 15) | (1 << mathClampi(b*4, 0, 3))) / 15.0;
            break;

         case OP_8S:
            out[0] = (mathClampi(a*256, 0, 255) | (1 << mathClampi(b*8, 0, 7))) / 255.0;
            break;

         case OP_16S:
            out[0] = (mathClampi(a*65536, 0, 65535) | (1 << mathClampi(b*16, 0, 15))) / 65535.0;
            break;

         case OP_PROB:
            out[0] = 0.0f;
            if(b_allow_trig_b)
            {
               if(inB >= TRIG_ON)
               {
                  // trig
                  b_allow_trig_b = false;
                  float fRand = calcRand();
                  if(a >= fRand)
                     out[0] = 1.0f;
               }
            }
            else if(inB < TRIG_OFF)
            {
               b_allow_trig_b = true;
            }
            break;

         case OP_QUANT:
            float st = b;
            out[0] = round(a / st) * st;
            break;

         case OP_CURVE:
            out[0] = mathLogLinExpf(a, b);
            break;

         case OP_CROSS:
            // trace "xxx cross last_a="+last_a+" a="+a+" b="+b;
            if(last_a > INVALID_VALUE)
            {
               if( ((a <= b) && (last_a > b)) ||
                   ((a >= b) && (last_a < b))
                   )
               {
                  // trace "xxx =====> cross last_a="+last_a+" a="+a+" b="+b;
                  out[0] = 1.0f;
               }
               else
               {
                  out[0] = 0.0f;
               }
            }
            break;

         case OP_RISE:
            if(last_a > INVALID_VALUE)
            {
               if((a > b) && (last_a <= b))
               {
                  out[0] = 1.0f;
               }
               else
               {
                  out[0] = 0.0f;
               }
            }
            break;

         case OP_FALL:
            if(last_a > INVALID_VALUE)
            {
               if((a < b) && (last_a >= b))
               {
                  out[0] = 1.0f;
               }
               else
               {
                  out[0] = 0.0f;
               }
            }
            break;

         case OP_RAND:
            float rndSlew = mathClampf(b, 0.0f, 1.0f);
            // trace "xxx OP_RAND r16="+r16+" => "+rndSlew;
            rndSlew *= rndSlew * rndSlew;
            float rndOut = calcRand();
            out[0] = rndOut + (out[0] - rndOut) * rndSlew;
            break;

         case OP_SH:
            if(b_allow_trig_b)
            {
               if(b >= TRIG_ON)
               {
                  // trig
                  b_allow_trig_b = false;
                  out[0] = a;
               }
            }
            else if(b < TRIG_OFF)
            {
               b_allow_trig_b = true;
            }
            break;

         case OP_QPOW2:
            if(a >= 1.0f)
               out[0] = 1.0f;
            else if(a >= (1.0 / 2))
               out[0] = 1.0 / 2;
            else if(a >= (1.0 / 4))
               out[0] = 1.0 / 4;
            else if(a >= (1.0 / 8))
               out[0] = 1.0 / 8;
            else if(a >= (1.0 / 16))
               out[0] = 1.0 / 16;
            else if(a >= (1.0 / 32))
               out[0] = 1.0 / 32;
            else if(a >= (1.0 / 64))
               out[0] = 1.0 / 64;
            else if(a >= (1.0 / 128))
               out[0] = 1.0 / 128;
            else if(a >= (1.0 / 256))
               out[0] = 1.0 / 256;
            else if(a >= (1.0 / 512))
               out[0] = 1.0 / 512;
            else if(a >= (1.0 / 1024))
               out[0] = 1.0 / 1024;
            else
               out[0] = 0.0;
            break;

         case OP_TH:
            if(inB >= TRIG_ON)
            {
               // trig
               b_allow_trig_b = true;
               th_a = a;
               out[0] = a;
            }
            else
            {
               Double tmp_decay = mathMaxf(0.0f, b_offset*0.75f);
               tmp_decay *= tmp_decay;
               tmp_decay *= tmp_decay;
               tmp_decay *= tmp_decay;
               tmp_decay = d_one - tmp_decay;
               th_a *= tmp_decay;
               out[0] = th_a;
            }
            break;

         case OP_CLAMP_0B:
            out[0] = mathClampf(a, 0.0f, b);
            break;

         case OP_CLAMP_B:
            out[0] = mathClampf(a, -b, b);
            break;

         case OP_WRAP_0B:
            out[0] = mathWrapf(a, 0.0f, b);
            break;

         case OP_WRAP_B:
            out[0] = mathWrapf(a, -b, b);
            break;

         case OP_FOLD_0B:
            out[0] = mathFoldf(a, 0.0f, b);
            break;

         case OP_FOLD_B:
            out[0] = mathFoldf(a, -b, b);
            break;

         case OP_POW2_1:
            out[0] = a * mathPowerf(2.0f, b);
            break;

         case OP_POW2_1I:
            out[0] = a * mathPowerf(2.0f, round(b));
            break;

         case OP_POW2_2:
            out[0] = a * mathPowerf(2.0f, b * 2.0f);
            break;

         case OP_POW2_2I:
            out[0] = a * mathPowerf(2.0f, round(b * 2.0f));
            break;

         case OP_POW2_3:
            out[0] = a * mathPowerf(2.0f, b * 3.0f);
            break;

         case OP_POW2_3I:
            out[0] = a * mathPowerf(2.0f, round(b * 3.0f));
            break;

         case OP_POW2_4:
            out[0] = a * mathPowerf(2.0f, b * 4.0f);
            break;

         case OP_POW2_4I:
            out[0] = a * mathPowerf(2.0f, round(b * 4.0f));
            break;

         case OP_A_CHANGE:
            float changeSlew = mathClampf(b, 0.0f, 1.0f);
            changeSlew *= changeSlew * changeSlew;
            if(INVALID_VALUE != last_a_slewed)
            {
               out[0] = (a != last_a_slewed);
               last_a_slewed = a + (last_a_slewed - a) * changeSlew;
            }
            else
            {
               out[0] = 0;
               last_a_slewed = a;
            }
            break;

         case OP_A_DELTA:
            float deltaSlew = mathClampf(b, 0.0f, 1.0f);
            deltaSlew *= deltaSlew * deltaSlew;
            if(INVALID_VALUE != last_a_slewed)
            {
               out[0] = (a - last_a_slewed);
               last_a_slewed = a + (last_a_slewed - a) * deltaSlew;
            }
            else
            {
               out[0] = 0;
               last_a_slewed = a;
            }
            break;

         case OP_U2B:
            out[0] = (abs(a) * 2.0f - 1.0f) * b;
            break;

         case OP_B2U:
            out[0] = abs( (a + 1.0f) * 0.5f * b );
            break;

         case OP_STH:
            if(a >= b)
               last_a = a;
            a = last_a;
            out[0] = last_a;
            break;

         case OP_GTS:
            if(a >= TRIG_ON && last_a < TRIG_ON)  // gate rising edge ?
            {
               if(b != last_sampled_b)
               {
                  // sample&hold new 'b'
                  last_sampled_b = b;
                  last_a = a;
               }
               else
               {
                  // filter out gate (keep last_a)
                  a = last_a;
               }
            }
            else
            {
               // gate low or falling edge
               last_a = a;
            }
            out[0] = last_a;
            break;

         case OP_GTL:
            if(a >= TRIG_ON && last_a < TRIG_ON)  // gate rising edge ?
            {
               if(b != last_sampled_b)
               {
                  // sample&hold new 'b'
                  last_a = a;
               }
               else
               {
                  // filter out gate (keep last_a)
                  a = last_a;
               }
            }
            else
            {
               // gate low or falling edge
               last_a = a;
            }
            out[0] = last_a;
            last_sampled_b = b;
            break;

         case OP_SAT:
            out[0] = tanh(a * (1.0f + b));
            break;

      }

      last_a = a;
   }
}
