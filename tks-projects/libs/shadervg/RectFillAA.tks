// ----
// ---- file   : ShaderVG_RectFillAA.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : Distributed under terms of the MIT license (https://opensource.org/licenses/MIT)
// ----          Copyright 2025 by bsp
// ----
// ----          Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
// ----          associated documentation files (the "Software"), to deal in the Software without restriction, including
// ----          without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// ----          copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to
// ----          the following conditions:
// ----
// ----          The above copyright notice and this permission notice shall be included in all copies or substantial
// ----          portions of the Software.
// ----
// ----          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// ----          NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// ----          IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// ----          WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// ----          SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----
// ---- info   : ShaderVG render utilities
// ----
// ----
// ----

module MShaderVG_RectFillAA;

namespace shadervg;


class RectFillAA : Shape {

   public method init() {
      Shape::init();
   }

   // ------------ vertex shader --------------
   static String vs_src =
      "uniform mat4 u_transform; \n"
      " \n"
      "ATTRIBUTE vec2 a_vertex; \n"
      " \n"
      "VARYING_OUT vec2 v_p; \n"
      " \n"
      "void main(void) { \n"
      "  v_p = a_vertex; \n"
      "  gl_Position = u_transform * vec4(a_vertex,0,1); \n"
      "} \n"
      ;

   // ------------ fragment shader ------------
   static String fs_src =
      "uniform vec2  u_center; \n"
      "uniform vec2  u_size; \n"
      "uniform float u_aa_range; \n"
      "uniform float u_aa_exp; \n"
      "uniform vec4  u_color_fill; \n"
      "uniform float u_debug; \n"
      " \n"
      "VARYING_IN vec2 v_p; \n"
      " \n"
      "void main(void) { \n"
      "  float aRect = 0.0; \n"
      "  vec4 color = vec4(0,0,0,0); \n
      "  // outer \n"
      "  vec2 vd = abs(v_p - u_center); \n"
      // // if(vd.x < u_size.x && vd.y < u_size.y) \n"
      "  { \n"
      "    aRect  = 1.0 - smoothstep(u_size.x-u_aa_range, u_size.x, vd.x); \n"
      "    aRect *= 1.0 - smoothstep(u_size.y-u_aa_range, u_size.y, vd.y); \n"
      "    color = u_color_fill; \n"
      "  } \n"
      "  \n"
      "  float a = aRect; \n"
      "  \n"
      "  // a = smoothstep(0.0, 1.0, a); \n"
      "#if 0 \n"
      "  a = pow(a, u_aa_exp); \n"
      "#endif \n"
      "  FRAGCOLOR = vec4(color.xyz, color.a*a); \n"
      "  if(u_debug > 0.0) \n"
      "    FRAGCOLOR = vec4(1,0,0,1); \n"
      "} \n"
      ;

   public virtual onOpen() : boolean {
      if(createShapeShader(vs_src, fs_src))
      {
         return true;
      }
      return false;
   }

   public method setupRectFillAAVBO32(Buffer _vb, Buffer _dl,
                                      float _centerX, float _centerY,
                                      float _sizeX, float _sizeY,
                                      float _aaRange
                                      ) {
      //  +0  u16 aaRange * 256
      //  +2  i32 vbOffInner
      //  +6  u16 numVertsInner  (0 or 6. GL_TRIANGLES)
      //  +8  i32 vbOffBorder
      //  +12 u16 numVertsBorder
      //  +14 u16 primTypeBorder

      _dl.i16 = _aaRange * 256;

      boolean bSingle = ((_sizeX*_sizeY) <= RECT_SINGLE_AREA_THRESHOLD);
      int numVerts;

      // Inner
      boolean bInner = !bSingle && b_draw_inner;
      if(bInner)
      {
         // (note) GL_TRIANGLES
         numVerts = 6;

         _dl.i32 = _vb.offset;
         _dl.i16 = numVerts;

         // left/top
         _vb.f32 = _centerX - _sizeX + _aaRange;
         _vb.f32 = _centerY - _sizeY + _aaRange;

         _vb.f32 = _centerX + _sizeX - _aaRange;
         _vb.f32 = _centerY - _sizeY + _aaRange;

         _vb.f32 = _centerX - _sizeX + _aaRange;
         _vb.f32 = _centerY + _sizeY - _aaRange;

         // right/bottom
         _vb.f32 = _centerX - _sizeX + _aaRange;
         _vb.f32 = _centerY + _sizeY - _aaRange;

         _vb.f32 = _centerX + _sizeX - _aaRange;
         _vb.f32 = _centerY - _sizeY + _aaRange;

         _vb.f32 = _centerX + _sizeX - _aaRange;
         _vb.f32 = _centerY + _sizeY - _aaRange;
      }
      else
      {
         _dl.i32 = _vb.offset;
         _dl.i16 = 0/*numVerts*/;
      }

      if(bSingle)
      {
         numVerts = 4;

         _dl.i32 = _vb.offset;
         _dl.i16 = numVerts;
         _dl.i16 = GL_TRIANGLE_FAN;

         EmitQuadVertices(_vb,
                         _centerX - _sizeX,
                         _centerY - _sizeY,
                         _sizeX * 2.0f,
                         _sizeY * 2.0f
                         );
      }
      else if(b_draw_border)
      {
         numVerts = 8*3;

         _dl.i32 = _vb.offset;
         _dl.i16 = numVerts;
         _dl.i16 = GL_TRIANGLES;

         EmitRectBorderVertices(_vb,
                                _centerX, _centerY,
                                _sizeX, _sizeY,
                                0.0f/*_strokeW*/,
                                _aaRange
                                );
      }
      else
      {
         _dl.i32 = _vb.offset;
         _dl.i16 = 0/*numVerts*/;
         _dl.i16 = GL_NONE;
      }

   }

   public method drawRectFillAAVBO32(int      _vboId,
                                     int      _byteOffsetInner,
                                     int      _numVertsInner,
                                     int      _byteOffsetBorder,
                                     int      _numVertsBorder,
                                     int      _glPrimTypeBorder,
                                     Matrix4f _projMatrix,
                                     float    _centerX, float _centerY,
                                     float    _sizeX,   float _sizeY,
                                     float    _fillR,   float _fillG,   float _fillB,   float _fillA,
                                     float    _aaRange,
                                     float    _aaExp
                                     ) {

      ShaderVG.BindVBO(_vboId);

      if(_numVertsInner > 0)
      {
         int aVertexFill = ShaderVG.BindFillShader();

         zglVertexAttribOffset(aVertexFill, 2/*size*/, GL_FLOAT, GL_FALSE/*normalize*/, 0/*stride*/, _byteOffsetInner);
         glDrawArrays(GL_TRIANGLES, 0, _numVertsInner);

         ShaderVG.EndFillShader();
      }

      // Outer border
      if(_numVertsBorder > 0)
      {
         shape_shader.bind();

         glUniformMatrix4fv(shape_u_transform, 1/*count*/, GL_TRUE/*transpose*/, _projMatrix);
         glUniform2f(shape_u_center,   _centerX, _centerY);
         glUniform2f(shape_u_size,     _sizeX, _sizeY);
         glUniform1f(shape_u_aa_range, _aaRange);

         if(-1 != shape_u_aa_exp)
            glUniform1f(shape_u_aa_exp, _aaExp);

         glUniform4f(shape_u_color_fill, _fillR, _fillG, _fillB, _fillA);

         if(-1 != shape_u_debug)
            glUniform1f(shape_u_debug, b_debug ? 1.0f : 0.0f);

         zglVertexAttribOffset(shape_a_vertex, 2/*size*/, GL_FLOAT, GL_FALSE/*normalize*/, 0/*stride*/, _byteOffsetBorder);
         glEnableVertexAttribArray(shape_a_vertex);

         glDrawArrays(_glPrimTypeBorder, 0, _numVertsBorder);

         glDisableVertexAttribArray(shape_a_vertex);
      }
   }

   public method drawRectFillAA(Buffer _scratchBuf,
                                Matrix4f _projMatrix,
                                float _centerX, float _centerY,
                                float _sizeX,   float _sizeY,
                                float _fillR,   float _fillG,   float _fillB,   float _fillA,
                                float _aaRange,
                                float _aaExp
                                ) {

      ShaderVG.BindScratchBuffer();

      boolean bSingle = ((_sizeX*_sizeY) <= RECT_SINGLE_AREA_THRESHOLD);

      // Inner
      boolean bInner = !bSingle && b_draw_inner;
      if(bInner)
      {
         int aVertexFill = ShaderVG.BindFillShader();

         int numTris = 2;
         allocScratchBuffer(aVertexFill, _scratchBuf, (numTris*3*2/*xy*/*4/*float*/));

         // left/top
         _scratchBuf.f32 = _centerX - _sizeX + _aaRange;
         _scratchBuf.f32 = _centerY - _sizeY + _aaRange;

         _scratchBuf.f32 = _centerX + _sizeX - _aaRange;
         _scratchBuf.f32 = _centerY - _sizeY + _aaRange;

         _scratchBuf.f32 = _centerX - _sizeX + _aaRange;
         _scratchBuf.f32 = _centerY + _sizeY - _aaRange;

         // right/bottom
         _scratchBuf.f32 = _centerX - _sizeX + _aaRange;
         _scratchBuf.f32 = _centerY + _sizeY - _aaRange;

         _scratchBuf.f32 = _centerX + _sizeX - _aaRange;
         _scratchBuf.f32 = _centerY - _sizeY + _aaRange;

         _scratchBuf.f32 = _centerX + _sizeX - _aaRange;
         _scratchBuf.f32 = _centerY + _sizeY - _aaRange;

         glDrawArrays(GL_TRIANGLES, 0, numTris*3);

         ShaderVG.EndFillShader();
      }

      // Outer corners
      shape_shader.bind();

      glUniformMatrix4fv(shape_u_transform, 1/*count*/, GL_TRUE/*transpose*/, _projMatrix);
      glUniform2f(shape_u_center,   _centerX, _centerY);
      glUniform2f(shape_u_size,     _sizeX, _sizeY);
      glUniform1f(shape_u_aa_range, _aaRange);

      if(-1 != shape_u_aa_exp)
         glUniform1f(shape_u_aa_exp, _aaExp);

      glUniform4f(shape_u_color_fill, _fillR, _fillG, _fillB, _fillA);

      if(-1 != shape_u_debug)
         glUniform1f(shape_u_debug, b_debug ? 1.0f : 0.0f);

      glEnableVertexAttribArray(shape_a_vertex);

      if(bSingle)
      {
         setQuadVertices(shape_a_vertex, _scratchBuf,
                         _centerX - _sizeX,
                         _centerY - _sizeY,
                         _sizeX * 2.0f,
                         _sizeY * 2.0f
                         );
         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
      }
      else if(b_draw_border)
      {
         allocScratchBuffer(shape_a_vertex, _scratchBuf, (8*3*2/*xy*/*4/*float*/));

         EmitRectBorderVertices(_scratchBuf,
                                _centerX, _centerY,
                                _sizeX, _sizeY,
                                0.0f/*_strokeW*/,
                                _aaRange
                                );

         glDrawArrays(GL_TRIANGLES, 0, 8*3);
      }

      glDisableVertexAttribArray(shape_a_vertex);
   }

}
