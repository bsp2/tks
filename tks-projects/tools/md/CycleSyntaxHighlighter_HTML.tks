// ----
// ---- file   : CycleSyntaxHighlighter_HTML.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : 'Cycle' highlighter, adapted for 'md'
// ----
// ---- created: 14Dec2024
// ---- changed: 15Dec2024, 18Dec2024, 19Dec2024, 22Dec2024, 11Jan2025, 13Jan2025, 15Jan2025
// ----          31Jan2025
// ----
// ----
// ----

module MCycleSyntaxHighlighter_HTML;


// <class.png>
class CycleSyntaxHighlighter_HTML {

   define int C32_OTHER     = #ff747474;   // "'
   define int C32_TEXT      = #ffc2c2c2;
   define int C32_COMMENT   = #ff6d6d59;   // #removed           #777761 #929278 #bbbb99
   define int C32_COMMENT2  = #ffbbbb99;   // # spaced comment   #929278 #a3a386 #bbbb99
   define int C32_KEYWORD_1 = #ffffddbb;   // oversample,wt_w,..
   define int C32_KEYWORD_2 = #ffbbffff;   // arg,def,lut,..
   define int C32_KEYWORD_3 = #ffffffff;   // sin,clp,..
   define int C32_KEYWORD_4 = #fff0ffff;   // +,-,*,..
   define int C32_ASSIGN    = #ffb1dfff;
   define int C32_KEYWORD_5 = C32_ASSIGN;  // <,>,! (after module name / keyword_3)
   define int C32_VAR       = #fff4f4bb;
   define int C32_VAR2      = #fff4f4bb;   // "special" vars (note, spd, vel)
   define int C32_TEMPLATE  = #ffbbffbb;
   define int C32_LANE      = #ffffbe66;   // <lane:
   define int C32_LUT       = #ffffa366;   // <lut_lane:
   define int C32_ID        = #ffffffff;   // plugin name (after 'id')
   define int C32_KEY       = #ffbbddbb;   // key=<value>
   define int C32_INPUT     = #ff94e7e2;   // input:  //66fff5
   define int C32_INC       = #ff90cc8b;   // inc|xinc <name>
   define int C32_FIELD     = #ffc29ca3;   // myarrayparam.myfield   #c2c2a3

   static StringArray a_keywords_1 = [
      "id",
      "name",
      "author",
      "cat",
      "oversample",
      "oversample_factor",
      "oversample_quality",
      "dither",
      "rate",
      "freq",
      "oct",
      "dur",
      "wt_w",
      "wt_h",
      "wt_cyclelen",
      "wt_freqs",
      "skip",
      "xfade",
      "mirror",

      // cycle_ui:
      "options",
      "dir",
      "tooltip",
                                      ];

   static StringArray a_keywords_2 = [
      "arg", "a",
      "arg_values", "av",
      "array", "ap",
      "curve", "c",
      "lcurve", "lc",
      "def",
      "inc", "xinc",
      "param", "p",
      "param_values", "pv",
      "lparam", "lp",
      "lparam_values", "lpv",
      "macro",
      "mod", "m",
      "modparam", "mp",
      "var", "v",
      // // "lut",
      "zone", "z",

      // cycle_ui:
      "in",
      "out",
      "pos",
                                      ];

   static StringArray a_keywords_3 = [
      "abs", "adsr",
      "bit", "boo", "box", "bpf", "bts", "buf",
      // // "bus",
      "clk", "clp", "cmp", "clt", "cne", "ceq", "cge", "cgt", "con",
      "dec", "div", "dly", "drv",
      "env", "eq3",
      "fed", "fix", "fld", "flt", "fam", "fma", "frc", "fsr", "fwr",
      "hbx", "hld", "hpf", "hwr",
      "if", "inc", "inp", "int", "ipl", "itg",
      "kbd",
      "lle", "log", "lop", "lpf", "lut",
      "mac", "map", "mkv", "mul",
      "neg", "nos", "not", "note", "nth",
      // // "out",
      "pal", "par", "pha", "p2s", "pow", "pre", "pul",
      "qua",
      "rbl", "rbr",
      "red", "rcp", "rdl", "rdr", "rep", "rev", "rmp",
      "saw", "set", "sin", "slf", "smp", "spd", "slw", "spr", "ssl", "sta", "sto", "svf", "sat",
      "tanh", "tmp", "~", "trc", "tri", "tsq",
      "vel", "vpl", "vsq", "vst",
      "wbl", "wbr",
      "wrl", "wrp", "wrr",
      "xfd",
      "zlp", "zon", "zsq",
      "init", "prepare", "calc", "global",
                                      ];

   static StringArray a_keywords_4 = [
      "+", "sr", "-", "r-", "*",
      "&", "|", "^",
      "&&", "||", "^^", "!&", "!|", "!^",
      "m", "x", "M", "X",
      ".",
      "am", "qm", "QM", "hm", "HM", "gm", "GM",
                                      ];

   static StringArray a_keywords_5 = [
      "<", ">", "!",
                                      ];

   static StringArray a_keywords_var2 = [
      "note", "spd", "vel",
                                         ];


   // <method.png>
   // static int dbg_count;
   public static ColorizeText(String _text) : String {
      // trace "xxx --------------------------------------------------";
      // trace "xxx ColorizeText";
      // trace "xxx --------------------------------------------------";
      _text.replace("'", "_SQUOT_");  // (todo) proper-fix this (workaround for e.g. "won't trigger" cuts off at "won")
      local String buf;
      local StringArray aLines <= _text.splitChar('\n');
      int numRows = aLines.numElements;
      // trace "xxx ["+(dbg_count++)+"] CycleSyntaxHighlighter::colorizeText: numRows="+numRows;

      local IntArray aRanges;
      local StringArray aTok;

      String *sLine;
      IntArray aColors; aColors.allocAndFill(1024, 0);
      int rowIdx = 0;
      loop(numRows)
      {
         sLine <= aLines.get(rowIdx);
         if(null != sLine)
         {
            // trace "xxx ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
            // trace "xxx sLine=\""+sLine+"\"";
            // trace "xxx ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";

            sLine.tokenizeWithRanges(" \t=~<>()[]{}*+&|^,;:", aRanges) => aTok;
            aColors.fill(C32_OTHER);
            // trace "aTok="+#(aTok);
            // trace "aRanges="+#(aRanges);

            int c32Comment = 0;
            boolean bTemplate = false;
            String sTokP <= "";
            String sTokPP <= "";
            boolean bAllowKW12 = true;  // directive
            boolean bAllowKW3 = true;   // mod
            boolean bAllowKW4 = true;   // op
            boolean bAllowKW5 = false;  // rel

            String *sTok;
            int tokOff = 0;
            foreach sTok in aTok
            {
               int startOff = aRanges.get(tokOff + 0);
               int numChars = aRanges.get(tokOff + 1);
               // trace "token["+(tokOff/2)+"] sTok=\""+sTok+"\"  substr=\""+sLine.substring(startOff, numChars)+"\"";
               int c32 = C32_TEXT;
               if(sTok <= "#")
               {
                  // # spaced comment ?
                  c32Comment = (sTok.numChars > 1) ? C32_COMMENT : C32_COMMENT2;
               }
               if(c32Comment)
                  c32 = c32Comment;
               else if(sTok == "def" || sTok == "~")
               {
                  bTemplate = true;
                  c32 = C32_KEYWORD_2;
                  bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW4 = false;
               }
               else if(bTemplate)
               {
                  bTemplate = false;
                  c32 = C32_TEMPLATE;
               }
               else if(sTok <= "$")
                  c32 = C32_VAR;
               else if(sTok == "=" && tokOff >= 2)
               {
                  int startOffKey = aRanges.get(tokOff - 2);
                  int numCharsKey = aRanges.get(tokOff - 1);
                  aColors.fillRegion(startOffKey, numCharsKey, C32_KEY);
                  c32 = C32_KEYWORD_4;
               }
               else if(bAllowKW12 && a_keywords_1.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_1;
                  bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW4 = false;
               }
               else if(bAllowKW12 && a_keywords_2.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_2;
                  bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW4 = false;
               }
               else if(bAllowKW3 && "=" != sTokP && a_keywords_3.containsObject(sTok))
               {
                  if(0 == startOff && "lut" == sTok)  // (note) both a module name and global directive
                     c32 = C32_KEYWORD_2;
                  else
                     c32 = C32_KEYWORD_3;
                  // // bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW5 = true;
                  bAllowKW4 = false;
               }
               else if(bAllowKW4 && a_keywords_4.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_4;
                  bAllowKW12 = false;
               }
               else if(bAllowKW5 && a_keywords_5.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_5;
               }
               else if("=" == sTok)
                  c32 = C32_ASSIGN;
               else if(":" == sTok && "<" == sTokPP)
               {
                  int startOffLane = aRanges.get(tokOff - 2);
                  int numCharsLane = aRanges.get(tokOff - 1);
                  aColors.fillRegion(startOffLane, numCharsLane,
                                     (sTokP <= "lut_") ? C32_LUT : C32_LANE
                                     );
               }
               else if(":" == sTok)
               {
                  int startOffInput = aRanges.get(tokOff - 2);
                  int numCharsInput = aRanges.get(tokOff - 1);
                  aColors.fillRegion(startOffInput, numCharsInput, C32_INPUT);
               }
               else if("id" == sTokP)
                  c32 = C32_ID;
               else if("inc" == sTokP || "xinc" == sTokP)
                  c32 = C32_INC;
               else if(a_keywords_var2.containsObject(sTok))
                  c32 = C32_VAR2;
               else if(sTok & "." && sTok.checkConversions() >= YAC_TYPE_STRING)
                  c32 = C32_FIELD;

               aColors.fillRegion(startOff, numChars, c32);

               // Next token
               tokOff += 2;
               sTokPP <= sTokP;
               sTokP <= sTok;
            }

            int lastRangeStartOff = 0;
            int rangeOff = 0;
            int c32Cur = -3;
            int tokIdx = 0;
            String *sClass;
            loop(aRanges.numElements / 2)
            {
               sTok <= aTok[tokIdx++];
               int rangeStartOff = aRanges.get(rangeOff + 0);
               int rangeNumChars = aRanges.get(rangeOff + 1);
               int c32Range = aColors[rangeStartOff];
               if(c32Range != c32Cur)
               {
                  if(-3 != c32Cur)
                     buf.append("</span>");

                  c32Cur = c32Range;

                  // map ARGB32 color to CSS class
                  switch(c32Cur)
                  {
                     default:             sClass <= null;   break;
                     case C32_OTHER:      sClass <= "cy_o"; break;
                     case C32_TEXT:       sClass <= "cy_x"; break;
                     case C32_COMMENT:    sClass <= "cy_c"; break;
                     case C32_COMMENT2:   sClass <= "cy_s"; break;
                     case C32_KEYWORD_1:  sClass <= "cy_1"; break;
                     case C32_KEYWORD_2:  sClass <= "cy_2"; break;
                     case C32_KEYWORD_3:  sClass <= "cy_3"; break;
                     case C32_KEYWORD_4:  sClass <= "cy_4"; break;
                     case C32_ASSIGN:     sClass <= "cy_a"; break;
                     case C32_KEYWORD_5:  sClass <= "cy_5"; break;
                     case C32_VAR:        sClass <= "cy_v"; break;
                     case C32_VAR2:       sClass <= "cy_w"; break;
                     case C32_TEMPLATE:   sClass <= "cy_t"; break;
                     case C32_LANE:       sClass <= "cy_l"; break;
                     case C32_LUT:        sClass <= "cy_u"; break;
                     case C32_ID:         sClass <= "cy_d"; break;
                     case C32_KEY:        sClass <= "cy_k"; break;
                     case C32_INPUT:      sClass <= "cy_i"; break;
                     case C32_INC:        sClass <= "cy_n"; break;
                     case C32_FIELD:      sClass <= "cy_f"; break;
                  }
                  if(null != sClass)
                     buf.append("<span class=\""+sClass+"\">");
                  else
                     c32Cur = -3;
               }

               // trace "~~~~~~~~~~~~~~~";
               // trace "xxx rangeStartOff="+rangeStartOff+" lastRangeStartOff="+lastRangeStartOff;

               boolean bQuoted = sTok.wasQuoted();

               if(bQuoted)
               {
                  while(++lastRangeStartOff < rangeStartOff)
                     buf.append("&nbsp;");
               }
               else
               {
                  while(lastRangeStartOff++ < rangeStartOff)
                     buf.append("&nbsp;");
               }

               // String sRangeTok <= sLine.substring(rangeStartOff, rangeNumChars);
               // if(bQuoted)
               //    sRangeTok <= "\""+sRangeTok+"\"";
               // // String sRangeTok <= sTok;
               String sRangeTok = bQuoted ? ("\""+sTok+"\"") : sTok;
               Integer c32CurIO = c32Cur;
               // trace "xxx cycle line sRangeTok=\""+sRangeTok+"\" rangeNumChars="+rangeNumChars+" c32Cur="+c32CurIO.printf("#%06x")+" => sClass=\""+sClass+"\"";
               Utils.ASCIIToHTML(sRangeTok, false/*bEntities*/);
               sRangeTok.replace("_SQUOT_", "'");
               buf.append(sRangeTok);
               // trace "xxx cycle line buf=\""+buf+"\"";
               if(bQuoted)
                  lastRangeStartOff += rangeNumChars+1;
               else
                  lastRangeStartOff += rangeNumChars-1;
               rangeOff += 2;
            } // loop ranges

            if(-3 != c32Cur)
               buf.append("</span>");

            buf.append("\n");

            // trace "xxx line["+rowIdx+"] sLine=\""+sLine+"\"";
            // trace "xxx line["+rowIdx+"] aColors="+aColors;

            // Next visible row
            rowIdx++;
         }
         else
            break;  // beyond end of text
      }
      return deref buf;
   }

}
