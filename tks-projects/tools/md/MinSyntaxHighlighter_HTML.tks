// ----
// ---- file   : MinSyntaxHighlighter_HTML.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : 'minnie' highlighter
// ----
// ---- created: 06Jul2025
// ---- changed: 13Jul2025
// ----
// ----
// ----

module MMinSyntaxHighlighter_HTML;


// <class.png>
class MinSyntaxHighlighter_HTML {

   define int C32_OTHER     = #ff747474;   // "'
   define int C32_TEXT      = #ffc2c2c2;
   define int C32_COMMENT   = #ff6d6d59;   // #removed           #777761 #929278 #bbbb99
   define int C32_COMMENT2  = #ffbbbb99;   // # spaced comment   #929278 #a3a386 #bbbb99
   define int C32_KEYWORD_1 = #ffffddbb;   // oversample,wt_w,..

   static StringArray a_keywords_1 = [
      "geo_scale",
      "gs",
      "geo_div",
      "gd",
      "geo",
      "geo_transform",
      "gxf",
      "gxfs",
      "aa",
      "rev",
      "pal",
      "palette",
      "pal_brightness",
      "pal_contrast",
      "pal_hsv",
      "fb",
      "f32",
      "m_f32",
      "a_f32",
      "arc_f32",
      "c_f32",
      "l_f32",
      "i",
      "color",
      "col",
      "g",
      "logic_op",
      "h",
      "join_cap",
      "line_join_cap",
      "n",
      "transform_2d",
      "transform2d",
      "t2d",
      "q",
      "transform_3d",
      "transform3d",
      "t3d",
      "M",
      "move_abs",
      "m",
      "move_rel",
      "t",
      "target",
      "dest",
      "dst",
      "u",
      "source",
      "src",
      "f",
      "fill",
      "w2",
      "w2p",
      "woff",
      "w2off",
      "w3off",
      "w2fb",
      "w3fb",
      "b",
      "blit",
      "a",
      "mask",
      "k",
      "stroke",
      "p",
      "path",
      "pt",
      "path_tesselate",
      "ph",
      "path_vgtesselate",
      "svg",
      "l",
      "line_rel",
      "L",
      "line_abs",
      "seg_scale",
      "sgs",
      "stroke_scale",
      "sts",
      "path_seg",
      "j",
      "seg",
      "c",
      "cubic",
      "C",
      "cubic_abs",
      "s",
      "cubic_mirror_rel",
      "S",
      "cubic_mirror_abs",
      "arc",
      "arc_rel",
      "ARC",
      "arc_abs",
      "r",
      "rect",
      "rc",
      "rect_ctr",
      "e",
      "ellipse",
      "doff",
      "don",
      "d",
      "draw_path",
      "d2",
      "d2d",
      "draw_path_2d",
      "d3",
      "d3d",
      "draw_path_3d",
      "y",
      "z",
                                      ];

   // static StringArray a_keywords_2 = [
   //                                    ];


   // <method.png>
   static int dbg_count;
   public static ColorizeText(String _text) : String {
      // trace "xxx --------------------------------------------------";
      // trace "xxx ColorizeText<min>";
      // trace "xxx --------------------------------------------------";
      _text.replace("'", "_SQUOT_");  // (todo) proper-fix this (workaround for e.g. "won't trigger" cuts off at "won")
      local String buf;
      local StringArray aLines <= _text.splitChar('\n');
      int numRows = aLines.numElements;
      // trace "xxx ["+(dbg_count++)+"] MinSyntaxHighlighter::colorizeText: numRows="+numRows;

      local IntArray aRanges;
      local StringArray aTok;

      String *sLine;
      IntArray aColors; aColors.allocAndFill(1024, 0);
      int rowIdx = 0;
      loop(numRows)
      {
         sLine <= aLines.get(rowIdx);
         if(null != sLine)
         {
            // trace "xxx ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
            // trace "xxx sLine=\""+sLine+"\"";
            // trace "xxx ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";

            sLine.tokenizeWithRanges(" \t=~<>()[]{}*+&|^,:", aRanges) => aTok;
            aColors.fill(C32_OTHER);
            // trace "aTok="+#(aTok);
            // trace "aRanges="+#(aRanges);

            int c32Comment = 0;
            boolean bTemplate = false;
            String sTokP <= "";
            String sTokPP <= "";
            boolean bAllowKW12 = true;  // directive

            String *sTok;
            int tokOff = 0;
            foreach sTok in aTok
            {
               int startOff = aRanges.get(tokOff + 0);
               int numChars = aRanges.get(tokOff + 1);
               // trace "token["+(tokOff/2)+"] sTok=\""+sTok+"\"  substr=\""+sLine.substring(startOff, numChars)+"\"";
               int c32 = C32_TEXT;
               if(sTok <= ";")
               {
                  // ; spaced comment ?
                  c32Comment = (sTok.numChars > 1) ? C32_COMMENT : C32_COMMENT2;
               }
               if(c32Comment)
                  c32 = c32Comment;
               else if(bAllowKW12 && a_keywords_1.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_1;
                  bAllowKW12 = false;
               }

               aColors.fillRegion(startOff, numChars, c32);

               // Next token
               tokOff += 2;
               sTokPP <= sTokP;
               sTokP <= sTok;
            }

            int lastRangeStartOff = 0;
            int rangeOff = 0;
            int c32Cur = -3;
            int tokIdx = 0;
            String *sClass;
            loop(aRanges.numElements / 2)
            {
               sTok <= aTok[tokIdx++];
               int rangeStartOff = aRanges.get(rangeOff + 0);
               int rangeNumChars = aRanges.get(rangeOff + 1);
               int c32Range = aColors[rangeStartOff];
               if(c32Range != c32Cur)
               {
                  if(-3 != c32Cur)
                     buf.append("</span>");

                  c32Cur = c32Range;

                  // map ARGB32 color to CSS class
                  switch(c32Cur)
                  {
                     default:             sClass <= null;   break;
                     case C32_OTHER:      sClass <= "cy_o"; break;
                     case C32_TEXT:       sClass <= "cy_x"; break;
                     case C32_COMMENT:    sClass <= "cy_c"; break;
                     case C32_COMMENT2:   sClass <= "cy_s"; break;
                     case C32_KEYWORD_1:  sClass <= "cy_1"; break;
                  }
                  if(null != sClass)
                     buf.append("<span class=\""+sClass+"\">");
                  else
                     c32Cur = -3;
               }

               // trace "~~~~~~~~~~~~~~~";
               // trace "xxx rangeStartOff="+rangeStartOff+" lastRangeStartOff="+lastRangeStartOff;

               boolean bQuoted = sTok.wasQuoted();

               if(bQuoted)
               {
                  while(++lastRangeStartOff < rangeStartOff)
                     buf.append("&nbsp;");
               }
               else
               {
                  while(lastRangeStartOff++ < rangeStartOff)
                     buf.append("&nbsp;");
               }

               // String sRangeTok <= sLine.substring(rangeStartOff, rangeNumChars);
               // if(bQuoted)
               //    sRangeTok <= "\""+sRangeTok+"\"";
               // // String sRangeTok <= sTok;
               String sRangeTok = bQuoted ? ("\""+sTok+"\"") : sTok;
               Integer c32CurIO = c32Cur;
               // trace "xxx cycle line sRangeTok=\""+sRangeTok+"\" rangeNumChars="+rangeNumChars+" c32Cur="+c32CurIO.printf("#%06x")+" => sClass=\""+sClass+"\"";
               Utils.ASCIIToHTML(sRangeTok, false/*bEntities*/);
               sRangeTok.replace("_SQUOT_", "'");
               buf.append(sRangeTok);
               // trace "xxx cycle line buf=\""+buf+"\"";
               if(bQuoted)
                  lastRangeStartOff += rangeNumChars+1;
               else
                  lastRangeStartOff += rangeNumChars-1;
               rangeOff += 2;
            } // loop ranges

            if(-3 != c32Cur)
               buf.append("</span>");

            buf.append("\n");

            // trace "xxx line["+rowIdx+"] sLine=\""+sLine+"\"";
            // trace "xxx line["+rowIdx+"] aColors="+aColors;

            // Next visible row
            rowIdx++;
         }
         else
            break;  // beyond end of text
      }
      return deref buf;
   }

}
