// TODO

- kleine hindernisse automatisch überqueren
   - 1/4 std.blockhöhe?

- gravity taxi (passagenweise) ins spiel integrieren ?

- werfen von items überdenken
   ! derzeit nur nach oben
   - sollte auch horizontal möglich sein
      - 

- 3 health points ?

- verschlossene exits und secret exit keys

- world map

- sticky platforms
   - nur kleine sprünge möglich

- steuerung überdenken
   - d-pad + 2 buttons
      - button A: jump
      - button B: 
         - pick up item / rope
         - use item / throw
   - support für wiimote (als nes pad ersatz)

- entity credits wären toll (d.h. in welchem spiel zuerst erfunden)

- auto-scroll levels
   - horizontal oder vertikal

- flood level ?
   - player startet unten und muss unter zeitdruck das ziel oben erreichen

- vernünftiger level-editor
   - extern
   - schreibt ascii files
   - evtl. kommunikation mit game über sockets?
      - mind. aber re-load bzw. filechange detection im game

- neue npcs:
   - draufspringbar/zerstörbar
   - draufspringbar/bounce
   - spiky/unzerstörbar 

- sound!
   - als erstes fx

- auto-swing entity
   - a la SMG flower
   - mittels rope

- rotierbare plattformen (a la supermario world)
   - formation
   - auf plattform stehen führt zu rotation

- per schalter flip-bare plattformen (a la dkc)

- im takt flippende plattformen (a la mario galaxy)

- einfärbbare plattformen (a la mario galaxy)
   - einfärben einer formation löst event aus

- long-jump a la mario galaxy ??
   - rennen, dann kurz ducken, dann springen

- plattformen zum drunterhängen
   - jump gedrückt halten ??

- "lavaball" style bewegungspfade

- wippende plattformen

- rotierende plattformen

- turbo-lift style platforms (a la turrican)

- breaking platforms

- non-wall-jumpable walltype

- horizontal boost (a la warioland)
   - run, dann zweimal in die jeweilige richtung drücken
   - zerstören von bestimmten blöcken und gegnern
   - rampen hochlaufen

- level challenges:
   1) complete level
   2) collect all coins
   3) time attack (race)

- coins

- dkc-like shooting barrels
   - direction
      - fixed or adjustable (dirmask)

- diagonale slides


------------------------------------------------------------------------------------ \/ v0.1 (pre 24Jan2011)

- slomo item
   - motion blur wenn slomo =)
- hiscore.dat
   - "verschlüsseln"
   - replays speichern
- level_timer erst nach erstem tastendruck starten
o gruppierungen und §copy:<id> entity
   ==> wave, wheel
- global: timescale=0.9
- bug: wall fallthrough immer noch möglich durch aufstehen: bei uncrouch checken ob spdy > 0, nur dann position_y anpassen
- 'hide', 'show' actions
- tkscript bug: wenn default data.tkx geladen wurde, funktionieren Arguments nicht mehr (z.B. -editor switch)
+ neues flag für switch: nur von runners zu bedienen
- neues flag für runner: wenn gravity=0 und entweder dirx oder diry !=0 sind, den
  runner auf den durch die begrenzersteine definierten Bereich begrenzen (ansonsten
  kann es passieren, dass der block, wenn unsichtbar, durch wände "geht")
- '.' als unsichtbarer begrenzer für runners
+ runner.semipermeable flag (für plattformen)
+ bug: runner: visible=0 funktioniert nicht
+ bug: runner: active=0 macht objekt unsichtbar
+ bug: switch: visible=0 funktioniert nicht
+ neues flag für switch: nur von runners zu bedienen
- bug: bei invert gravity kann man sich durch wände drücken, sobald die yspeed
       einen bestimmten wert überschreitet ==> begrenzen (max stomp_timeout)
o translate und scale als §entity property, nicht nur durch script setzbar
   --> finetuning von blockposition/grösse relativ zur cell position
   ==> cell=A-12;6
- infoentity, bei berührung message anzeigen
+ lars' map integrieren

+ sequencer entity
   + speed
   + step0_script, .., step7_script ?

§script
id=closealldoors
actions=close A, close B, close C

§script
id=openalldoors
actions=open A, open B, open C

§sequencer
speed=6
step0_script = call closealldoors
step1_script = call openalldoors


+ script entity + call <scriptentity> action ?

- worldcyclelist.txt
   --> je nach worldname in verschiedenen maps_<worldname>/ foldern suchen
- features pro map konfigurierbar machen:
    [x] jumping
      [x] walljumps
      [x] floating/double-jumps
    [f] gravity (-1..1)
+ jump retrigger (press jump n millisec vor der landung)
+ FLYING state (hold jump)
x coins
o gegner bzw. wurfmaterial
+ stomp (down while falling, dir_x==0. long falltime = mega stomp)
- "fx": items an decke zusammendrücken
+ halbdurchlässige plattformen (von unten nach oben erlaubt)
+ breakable/stompable platforms (blue and red)
- map packs / "worlds"
- polygon particle system für break animation
- sinking platforms
- autotoggle platforms
- switch platforms
+ doors
   + müssen mit switch verbunden werden
   + vertikal oder horizontal
+ switches
   x auto-reset (wenn keine kollision)
   + trigger
   + on/off
- laser barriers (speed + on/off pattern)
+ entity names / scriptable levels / level api
- elastic floors
- gravity invert a la vvvvvv ?
- character groups
   - z.B. circle, sinewave, ..
   - automatische platzierung und animation der elemente
x schadensmodell: a la ghost'n'goblins ? ("super mario"..)
x proximity mines (evtl. radius grafisch darstellen)
x defusable mines (a la oddworld, on/off pattern red/green)
o designentscheidung: "gegner" (im fall von knuddel ai)
   + evtl. nicht killbar? bonuspunkte/secrets wenn man den viechern hindernisse aus dem weg räumt (wege zu teleportern freimacht)
- entity grid für collision detection
+ level bounding box, falltodeath wenn py unter bbox.min.y
+ level editor
   x wieder ingame oder als tkui app ??
      --> als externe app und über tcp/ip netzwerk  
   + als ASCII und ingame editor
o ai:
  + runner
     + mit oder ohne gravity
     + mover (schieben den Player)
     + killer blocks (level reset bei Berührung)
     + free run mode (player physics), laufrichtung bei wandkollision umkehren
o ai:
   - designentscheidung: passt ai zum spiel? hat eigentlich mehr was von den bionic commando challenges..
      - pro: abwechslungsreichere/lebendigere levels möglich
      - contra: ohne passende grafik sind die npcs evtl. schwer zu unterscheiden
      - contra: könnte den zeitrahmen sprengen. leveleditor/design steht ja auch noch aus..!
   - designentscheidung: ai auswahl: eher knuddelig (nintendo etc) oder eher tödlich (oddworld etc)
      - pro: zum arcade gameplay passt wohl eher knuddelig
      - contra: knuddelige npcs sind oft langweilig
      --> evtl. beides, d.h. 3 parteien, die knuddelviechers müsste man dann vor den evilviechers retten...(oddworld, lemmings, ..)
   o small walker 
      + kehrt bei hindernissen einfach um
      - stompable/jumpable
         - kann item hinterlassen
   - jumpy walker 
      - springt kleine stufen hoch
      - stompable/jumpable
   - shell walker 
      - a la mario. hinterlässt ein aufsammelbares shell item.
   - spiky walker 
      - liegt nach stomp auf dem rücken
      - dreht sich nach timeout wieder um
   - ghost
      - bewegt sich auf den player zu solange sich dieser von ihm abwendet
      - a lawsuit waiting to happen :P
   - small flyer
      - stompable/jumpable
      - fixed position?
- vulnerable to sticky-wall-climb exploit (hard to reproduce)
o level erstmal als coarse ascii file (1/3 auflösung?) importieren? (spart den lvl editor :P)
   - a..z als entity types, A..Z als variablen (später zuweisung zu entitytype/longname f. scripting)
   + textfile in 2d array laden
   + zusammenhängende # blöcke finden, boxentity erzeugen und aus 2d array löschen
- auto-wall climb bei kleineren stufen
- portals to other map files
   - remember state of previous map
