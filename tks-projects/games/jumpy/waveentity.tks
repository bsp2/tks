
// 22Mar2010

module MWaveEntity;

namespace jumpy;


class WaveEntity extends BoxEntity {

   define int TYPE_SIN        = 0;
   define int TYPE_TRI        = 1;
   define int TYPE_SMOOTHSTEP = 2;

   public float reset_speed;
   public float reset_inner_speed;
   public float reset_angle;
   public StringArray members;

   float speed;
   float inner_speed;
   float angle;
   public boolean b_vertical;

   public int type;

   public method initWaveEntity() {
      initEntity();
   }

   public virtual resetEntity() {
      Entity::resetEntity();

      speed       = reset_speed;
      inner_speed = reset_inner_speed;
      angle       = reset_angle;
      b_visible   = false;
   }

   public virtual calc(float dt) {
      if(b_active)
      {
         // Rotate
         angle = mathWrapf(angle + speed*dt, 0, 2PI);
         ////trace "xxx angle="+angle+" speed="+speed;
      }

      String *id;
      float a = mathWrapf(angle, 0, 2PI);
      float step = b_vertical ? size_y/members.numElements : size_x/members.numElements;
      float w = inner_speed;
      float c = 0;
      foreach id in members 
      {
         Entity e <= g_level.findEntityById(id);
         ////trace "xxx id="+id+" e="+#(e)+" members="+#(members);
         if(null != e)
         {
            float amp;
            switch(type)
            {
               case TYPE_SIN:
                  amp = 0.5 * sin(a) + 0.5;
                  break;

               case TYPE_TRI:
                  if(a < PI)
                  {
                     amp = a/PI;
                  }
                  else
                  {
                     amp = 1-(a-PI)/PI;
                  }
                  break;

               case TYPE_SMOOTHSTEP:
                  if(a < PI)
                  {
                     amp = mathSmoothStepf(0, 1, a/PI);
                  }
                  else
                  {
                     amp = 1-(a-PI)/PI;
                     amp = mathSmoothStepf(0, 1, amp);
                  }
                  break;
            }
            if(b_vertical)
            {
               float nx = position_x + amp * size_x - (e.size_x * 0.5);
               e.delta_x = nx - e.position_x;
               e.delta_y = 0;
               e.position_x = nx;
               e.position_y = position_y + c;
            }
            else
            {
               float ny = position_y + amp * size_y - (e.size_y * 0.5);
               e.delta_x = 0;
               e.delta_y = ny - e.position_y;
               e.position_x = position_x + c;
               e.position_y = ny;
            }
         }
         c += step;
         a = mathWrapf(a + w, 0, 2PI);
      }
   }

   public virtual draw(float dt) {
      return;
   }

   public virtual hitBy(Entity _o) : int {
      return 0;
   }

   public virtual actionSet(String key, value) : boolean {
      StringArray *a;
      switch(key)
      {
         case "angle":
            angle = mathClampf(value, 0, 360) * (2PI/360);
            return true;

         case "speed":
            speed = mathClampf(value, -20, 20) * (2PI/360);
            return true;

         case "innerspeed":
            inner_speed = mathClampf(value, -20, 20) * (2PI/360);
            return true;
      }
      return Entity::actionSet(key, value);
   }

   public virtual markScriptTargets() {
      String *entityId;
      foreach entityId in members {
         Entity e <= g_level.findEntityById(entityId);
         if(null != e)
         {
            e.b_script_target = true;
         }
      }
   }

}
