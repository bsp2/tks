
// 11Oct2009, 19Oct2009, 14Mar2010, 17Mar2010, 18Mar2010

module Entity;

namespace jumpy;


class Entity {
   define int DIR_LEFT  = 1;
   define int DIR_RIGHT = 2;
   define int DIR_UP    = 4;
   define int DIR_DOWN  = 8;

   define int DIR_H = (DIR_LEFT | DIR_RIGHT);
   define int DIR_V = (DIR_UP   | DIR_DOWN);

   public float   reset_x;
   public float   reset_y;
   public float   reset_size_x;
   public float   reset_size_y;
   public int     reset_dir_x;
   public int     reset_dir_y;
   public boolean reset_b_active;
   public boolean reset_b_visible;
   public boolean reset_b_mover;
   public float   reset_speedscale;
   public boolean b_script_target;

   float position_x;
   float position_y;
   float size_x;
   float size_y;
   int   dir_x;
   int   dir_y;
   float speed_x;
   float speed_y;
   float gravity;
   float speed_scale;

   float suggested_speed_x; // if >=0, move entity to this position if there was no wall collision
   float suggested_speed_y;

   float delta_x; // used to move player when standing on a moving platform
   float delta_y;

   boolean b_mover; // 1=move player, 0=cause map reset on collision. default = false

   boolean b_active;

   boolean b_visible;

   boolean b_collectable;

   boolean b_nocollision;

   public method initEntity() {
      reset_b_active   = true;
      reset_b_visible  = true;
      reset_b_mover    = true;
      reset_size_x     = 3;
      reset_size_y     = 6;
      reset_speedscale = 1.0;
      reset_dir_x      = 0;
      reset_dir_y      = 0;
   }

   public method resetEntity() {
      position_x    = reset_x;
      position_y    = reset_y;
      size_x        = reset_size_x;
      size_y        = reset_size_y;
      dir_x         = reset_dir_x;
      dir_y         = reset_dir_y;
      b_active      = reset_b_active;
      b_visible     = reset_b_visible;
      b_mover       = reset_b_mover;
      speed_scale   = reset_speedscale;
      delta_x       = 0;
      delta_y       = 0;
      b_collectable = false;
      b_nocollision = false;
      ////trace "xxx resetEntity this="+#(this)+" b_visible="+b_visible+" "+reset_b_visible;
   }

   public method setEntityPosition(float x, y) {
      reset_x    = x;
      reset_y    = y;
      position_x = x;
      position_y = y;
   }

   public method setEntitySize(float x, y) {
      reset_size_x = x;
      reset_size_y = y;
      size_x = x;
      size_y = y;
   }

   public method rotatecw() {
      float t;

      t = position_x;
      position_x = position_y;
      position_y = (g_level.t_size_x*6 - t - size_x);

      t = size_x;
      size_x = size_y;
      size_y = t;
      
      if(size_y < 0)
      {
         position_y += size_y;
         size_y = - size_y;
      }

      if(size_x < 0)
      {
         position_x += size_x;
         size_x = - size_x;
      }

   }

   public method resizex(float _sx) {
      switch(gravity_dir)
      {
         case DIR_UP:
            size_x = _sx;
            break;

         case DIR_DOWN:
            size_x = _sx;
            break;

         case DIR_RIGHT:
            size_y = _sx;
            break;

         case DIR_LEFT:
            size_y = _sx;
            break;
      }
   }

   public method resizey(float _sy) {
      switch(gravity_dir)
      {
         case DIR_UP:
            size_y = _sy;
            break;

         case DIR_DOWN:
            size_y = _sy;
            break;

         case DIR_RIGHT:
            size_x = _sy;
            break;

         case DIR_LEFT:
            size_x = _sy;
            break;
      }
   }

   public method translatex(float _dx) {
      switch(gravity_dir)
      {
         case DIR_UP:
            position_x += _dx;
            break;

         case DIR_DOWN:
            position_x -= _dx;
            break;

         case DIR_RIGHT:
            position_y += _dx;
            break;

         case DIR_LEFT:
            position_y -= _dx;
            break;
      }
   }

   public method translatey(float _dy) {
      switch(gravity_dir)
      {
         case DIR_UP:
            position_y += _dy;
            break;

         case DIR_DOWN:
            position_y -= _dy;
            break;

         case DIR_LEFT:
            position_x -= _dy;
            break;

         case DIR_RIGHT:
            position_x += _dy;
            break;
      }
   }

   public method setSuggestedSpeedX(float _s) {
      suggested_speed_x = _s;
   }

   public method setSuggestedSpeedY(float _s) {
      suggested_speed_y = _s;
   }

   public method checkCollision(Entity _o) : boolean {
      // Check whether this entity collides with other entity _o

      ////trace "xxx checkcoll this=("+position_x+";"+position_y+";"+size_x+";"+size_y+") o=("+_o.position_x+";"+_o.position_y+";"+_o.size_x+";"+_o.size_y+")";

      boolean r;

      compile 
      {
         r = false;

         // bbox test first
         if( (position_x+size_x) > _o.position_x )
         {
            if( position_x < (_o.position_x + _o.size_x) )
            {
               if( (position_y+size_y) > _o.position_y )
               {
                  if( position_y < (_o.position_y + _o.size_y) )
                  {
                     // Check exact collision (entity dependent)
                     r = true;
                  }
               }
            }
         }

         if(r)
         {
            r = checkExactCollision(_o);
         }
      }

      return r;
   }

   public abstract checkExactCollision(Entity _o) {
   }

   public method handleCollision(Entity _o, int _dir, float _px, _py) {
   }

   public method handleInsideCollision(Entity _o) {
   }

   public abstract hitBy(Entity _o) {
   }

   public method handleCollect(Entity _carryEntity) : boolean {
      return false;
   }

   public method handleDrop() {
   }

   public abstract draw(float dt) {
   }

   public abstract drawOverlays(float dt) {
   }

   public method prepareArray(FloatArray _verts, FloatArray _uvs) {
      // prepare triangle array
   }

   public abstract calc(float dt) {
   }

   public method actionActivate() {
      b_active = true;
   }

   public method actionDeactivate() {
      b_active = false;
   }

   public method actionSet(String key, value) : boolean {
      StringArray *a;
      ////trace "xxx entity::actionSet: key=\""+key+"\" value=\""+value+"\"";
      switch(key)
      {
         case "pos":
            a <= value.splitChar(';');
            position_x = a.get(0);
            position_y = a.get(1);
            return true;

         case "translate":
            a <= value.splitChar(';');
            position_x += float(a.get(0));
            position_y += float(a.get(1));
            return true;
               
         case "cell":
            Float tx, ty;
            g_level.findNamedCell(value, tx, ty);
            position_x = tx;
            position_y = ty;
            return true;

         case "size":
            a <= value.splitChar(';');
            size_x = a.get(0);
            size_y = a.get(1);
            return true;

         case "scale":
            a <= value.splitChar(';');
            size_x += float(a.get(0));
            if(size_x < 0)
            {
               size_x = 0;
            }
            size_y += float(a.get(1));
            if(size_y < 0)
            {
               size_y = 0;
            }
            return true;

         case "visible":
            if(value == "toggle")
            {
               b_visible = !b_visible;
            }
            else
            {
               b_visible = value;
            }
            return true;

         case "active":
            if(value == "toggle")
            {
               b_active = ! b_active;
            }
            else
            {
               b_active = value;
            }
            if(b_active)
            {
               actionActivate();
            }
            else
            {
               actionDeactivate();
            }
            return true;
      }

      return false;
   }

   public method actionToggle() {
      b_active = ! b_active;
   }

   public method actionToggleMover() {
      ////trace "xxx actionToggleMover b_mover="+b_mover;
      if(b_mover)
      {
         b_mover = false;
         //
      }
      else
      {
         b_mover = true;
      }
   }

   public method actionToggleVisibility() {
      if(b_visible)
      {
         b_visible = false;
         //
      }
      else
      {
         b_visible = true;
      }
   }

   public method checkRayCollision(float px, py, qx, qy, Float rx, ry) : boolean {
      // used for hook <-> wall/floor collision detection
      //  note: not really an exact collision but good enough

      float dirx = (qx - px);
      float diry = (qy - py);

      float d, l, t, cx, cy;

      // Potential wall collision
      if(dirx > 0)
      {
         // Left side
         if((px < position_x) && (qx > position_x))
         {
            /*
              position_x = px + dirx*t
              position_x - px = dirx *t
              (position_x-px)/dirx = t
            */
            t = (position_x-px)/dirx;
            cy = py + diry*t;
            if( (cy >= position_y) && (cy < (position_y+size_y)) )
            {
               ////trace "xxx coll left";
               rx = position_x;
               ry = cy;
               return true;
            }
         }
      }
      else
      {
         // Right side
         if(px > (position_x+size_x) && qx < (position_x+size_x))
         {
            /*
              position_x+size_x = px + dirx*t
              position_x+size_x - px = dirx *t
              (position_x+size_x-px)/dirx = t
            */
            t = (position_x+size_x-px)/dirx;
            cy = py + diry*t;
            if( (cy >= position_y) && (cy < (position_y+size_y)) )
            {
               ////trace "xxx coll right";
               rx = position_x+size_x;
               ry = cy;
               return true;
            }
         }
      }

      // Potential ceiling collision
      if(diry > 0)
      {
         /*
           rayy(t) = py + diry*t
         */

         // Bottom side
         if((py < position_y) && (qy > position_y))
         {
            /*
              position_y = py + diry*t
              position_y - py = diry *t
              (position_y-py)/diry = t
            */
            t = (position_y-py)/diry;
            cx = px + dirx*t;
            if( (cx >= position_x) && (cx < (position_x + size_x)) )
            {
               ////trace "xxx coll bottom";
               ////trace "   t="+t+" dirx="+dirx+" diry="+diry;
               rx = cx;
               ry = position_y;
               //g_ingame.b_freeze = true;
               return true;
            }
         }
      }
      else
      {
         // Top side
         // if((py > (position_y+size_y)) && (qy < (position_y+size_y)))
         // {
         //    /*
         //      position_y = py + diry*t
         //      position_y - py = diry *t
         //      (position_y-py)/diry = t
         //    */
         //    t = (position_y-py)/diry;
         //    cx = px + dirx*t;
         //    if( (cx >= position_x) && (cx < (position_x + size_x)) )
         //    {
         //       trace "xxx coll bottom";
         //       trace "   t="+t+" dirx="+dirx+" diry="+diry;
         //       rx = cx;
         //       ry = position_y;
         //       //g_ingame.b_freeze = true;
         //       return true;
         //    }
         // }
      }

      return false;
   }

   public method markScriptTargets() {
   }

}
