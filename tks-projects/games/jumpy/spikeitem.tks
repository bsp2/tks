
// 13Mar2010

module MSpikeItem;

namespace jumpy;

class SpikeItem : Item  {

   boolean b_walkable;

   public static NewSpikeItem(float x, y, boolean _bWalkable) : SpikeItem {
      SpikeItem f <= new SpikeItem;
      f.initSpikeEntity(x,y, _bWalkable);
      return deref f;
   }

   public method initSpikeEntity(float x, y, boolean _bWalkable) {
      initItem();

      setEntityPosition(x, y);
      setEntitySize(3-0.25, 6-0.25);
      color32 = #ffff1037;
      b_collectable = true;
      b_nocollision = true;
      b_walkable    = _bWalkable;
   }

   public virtual handleCollect(Entity _carryEntity) : boolean {
      ////trace "xxx SpikeItem: handleCollect: carry="+#(_carryEntity);
      if(b_visible)
      {
         if(b_walkable && (null != _carryEntity))
         {
            return false;
         }
         else
         {
            ////trace "xxx b_walkable="+b_walkable;
            g_ingame.showMessage("do not touch these blocks!", "you have failed to complete this room. please try again !", 0, Ingame.ACTION_RESETMAP);
         }
      }
      return false;
   }

   public virtual calc(float dt) {
      //BoxEntity::calc(dt);
   }
   
   public virtual draw(float dt) {

      if(!b_script_target)
      {
         // (note) static items drawn via glDrawArrays(). see Level::spike_verts/uvs
         return;
      }

      if(!b_visible)
      {
         return;
      }

      if(null != g_player.carry_entity) && b_walkable
      {
         Render.drawFilledBox(position_x, position_y, size_x, size_y, #ff107f37);
      }
      else
      {
         if(!b_collectable)
         {
            Render.drawFilledBox(position_x, position_y, size_x, size_y, color32);
         }
      }

      if(b_collectable)
      {
         if(true)
         {
            tex_spike.bind();
            tex_spike.enable();
            glBegin(GL_TRIANGLE_FAN);
            glTexCoord2f(0, 1);
            glVertex2f(position_x, position_y);
            
            glTexCoord2f(1, 1);
            glVertex2f(position_x + size_x, position_y);
            
            glTexCoord2f(1, 0);
            glVertex2f(position_x + size_x, position_y + size_y);
            
            glTexCoord2f(0, 0);
            glVertex2f(position_x, position_y + size_y);
            glEnd();
            tex_spike.disable();
         }
         else
         {
            // original render code (slow on PVR):
            glLineWidth(4.0);
            Render.drawRectangle(position_x+2, position_y+2, size_x-4, size_y-4, #ff2f0000);
            glBegin(GL_LINES);
            glVertex2f(position_x, position_y+size_y*0.5);
            glVertex2f(position_x+size_x*0.5, position_y+size_y);
            
            glVertex2f(position_x+size_x*0.5, position_y+size_y);
            glVertex2f(position_x+size_x, position_y+size_y*0.5);
            
            glVertex2f(position_x, position_y+size_y*0.5);
            glVertex2f(position_x+size_x*0.5, position_y);
            
            glVertex2f(position_x+size_x*0.5, position_y);
            glVertex2f(position_x+size_x, position_y+size_y*0.5);
            glEnd();
            glLineWidth(1.0);
         }
      }
   }

   public virtual prepareArray(FloatArray _verts, FloatArray _uvs) {
      if(b_script_target)
      {
         return;
      }

      // speed hack for mobile devices (e.g. SGX533)
      _uvs.add(0);
      _uvs.add(1);
      _verts.add(position_x);
      _verts.add(position_y);

      _uvs.add(1);
      _uvs.add(1);
      _verts.add(position_x + size_x);
      _verts.add(position_y);

      _uvs.add(1);
      _uvs.add(0);
      _verts.add(position_x + size_x);
      _verts.add(position_y + size_y);

      // 2nd triangle:
      _uvs.add(0);
      _uvs.add(1);
      _verts.add(position_x);
      _verts.add(position_y);

      _uvs.add(1);
      _uvs.add(0);
      _verts.add(position_x + size_x);
      _verts.add(position_y + size_y);

      _uvs.add(0);
      _uvs.add(0);
      _verts.add(position_x);
      _verts.add(position_y + size_y);
   }

}
