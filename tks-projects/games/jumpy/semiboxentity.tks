
module SemiBoxEntity;

namespace jumpy;

class SemiBoxEntity extends BoxEntity {

   // player can jump through it (but not fall through)

   public static NewSemiBoxEntity(float x, y, w, h, int c32) : SemiBoxEntity {
      SemiBoxEntity b <= new SemiBoxEntity;
      b.initBoxEntity(x, y, w, h, c32);
      return deref b;
   }

   public virtual draw(float dt) {
      Render.drawFilledBox(position_x, position_y, size_x, size_y, color32);

//       glLineWidth(4.0);
//       Render.drawRectangle(position_x, position_y, size_x, size_y, #ffffffff);
//       glLineWidth(1.0);
   }

   public virtual hitBy(Entity _o) : int {
      // Return 1=horizontal, 2=vertical

      return = 0;

      // Determine which edge was hit

      ////trace "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";

      float ydist=999999, xdist=999999;
      int yedgeNr = 0;
      int xedgeNr = 0;

      // Top edge
      if(1)//_o.isFalling())//if(_o.speed_y < 0)
      {
         if( (_o.position_y < (position_y + size_y)) && ((_o.position_y+_o.size_y) > (position_y+size_y)) )
         {
            ////trace "xxx hit top edge";
            yedgeNr = 1;
            ydist = (position_y+size_y) - _o.position_y;
            //_o.speed_y = 0;
         }
      }

      // Bottom edge
      if(1)//_o.isJumping())//if(_o.speed_y > 0)
      {
         if( (_o.position_y < (position_y)) && ((_o.position_y+_o.size_y) > position_y) )
         {
            ////trace "xxx hit bottom edge";
            yedgeNr = 2;
            ydist = ((_o.position_y+_o.size_y) - position_y);
            //_o.speed_y = 0;
         }
      }

      if(1)//if( (_o.position_y < (position_y + size_y)) )
      {
         // Left edge
         if(1)//if(_o.speed_x > 0)
         {
            if( (_o.position_x < (position_x)) && ((_o.position_x+_o.size_x) > position_x) )
            {
               ////trace "xxx hit left edge";
               xedgeNr = 1;
               xdist = (_o.position_x+_o.size_x) - position_x;
            }
         }
         
         // Right edge
         if(1)//if(_o.speed_x < 0)
         {
            if( (_o.position_x < (position_x+size_x)) && ((_o.position_x+_o.size_x) > (position_x+size_x)) )
            {
               ////trace "xxx hit right edge";
               xedgeNr = 2;
               xdist = (position_x + size_x) - _o.position_x;
            }
         }
      }

      //trace "xxx xedgeNr="+xedgeNr+" yedgeNr="+yedgeNr;

      //if((999998<xdist)&&(999998<ydist))
      //{
      //   trace "xxx no coll";
      //}


      if(ydist < xdist)
      {
         if(yedgeNr == 1)
         {
            // Top edge collision
            boolean bTopColl = true;
            if(_o instanceof Character)
            {
               Character c <= _o;
               ///if((c.state != Character.ST_FALLING))
               if(c.speed_y > 0)
               {
                  ////trace "xxx jump through semiboxentity";
                  bTopColl = false;
                  return 0;
               }
            }
            if(bTopColl)
            {
               _o.handleCollision(this, DIR_UP, _o.position_x, position_y + size_y);
               return = DIR_UP;
            }
         }
         else if(yedgeNr == 2)
         {
            // Bottom edge collision
            ////_o.handleCollision(this, DIR_DOWN, _o.position_x, position_y - _o.size_y - COLL_YCORRECT);
            ////return = DIR_DOWN;
         }
      }
      else if(xdist < ydist)
      {
         ////trace "xxx ydist="+ydist+" xdist="+xdist+" yedge="+yedgeNr+" xedge="+xedgeNr;
         // Note: the +- shiftintowall (0.01) constant will keep the player colliding with the wall. 
         //       this makes walljumping a bit less hectic!
         if(!b_semipermeablex)
         {
            float shiftintowall = (_o instanceof Player) ? 0.01*g_dt : 0; // hack
            if(xedgeNr == 1)
            {
               // Left edge collision
               _o.handleCollision(this, DIR_LEFT, position_x - _o.size_x + shiftintowall, _o.position_y);
//             ////trace "xxx left edge collision _o.speed_x="+_o.speed_x;
               return = DIR_LEFT;
            }
            else if(xedgeNr == 2)
            {
               // Right edge collision
               _o.handleCollision(this, DIR_RIGHT, position_x + size_x - shiftintowall, _o.position_y);
               return = DIR_RIGHT;
            }
         }

//       _o.speed_x = 0;
//       _o.speed_y = 0;
      }

      ////trace "xxx after BoxEntity::hitBy: o.pos=("+_o.position_x+";"+_o.position_y+")";

   }
}
