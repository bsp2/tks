
// 11Oct2010, 19Oct2010, 16Mar2010, 17Mar2010, 22Mar2010, 26Mar2010

module BoxEntity;

namespace jumpy;

class BoxEntity extends Entity {

   int color32;

   define float COLL_YCORRECT = 0.0;

   boolean reset_b_semipermeable;
   boolean b_semipermeable;

   boolean reset_b_semipermeablex;
   boolean b_semipermeablex;


   public static NewBoxEntity(float x, y, w, h, int c32) : BoxEntity {
      BoxEntity b <= new BoxEntity;
      b.initBoxEntity(x, y, w, h, c32);
      return deref b;
   }

   public method initBoxEntity(float x, y, w, h, int c32) {
      initEntity();
      setEntityPosition(x, y);
      setEntitySize(w, h);
      color32 = c32;
      reset_b_visible        = true;
      reset_b_semipermeable  = false;
      reset_b_semipermeablex = false;

      b_semipermeable  = reset_b_semipermeable;
      b_semipermeablex = reset_b_semipermeablex;
      b_visible        = reset_b_visible;
   }

   public virtual checkExactCollision(Entity _o) : boolean {
      // Same as bbox test
      ////trace "xxx BoxEntity::checkExactCollision _o="+#(_o)+" this="+#(this);
      return true;
   }

   public virtual resetEntity() {
      Entity::resetEntity();

      b_semipermeable  = reset_b_semipermeable;
      b_semipermeablex = reset_b_semipermeablex;
   }

   public virtual draw(float dt) {
      if(!b_visible)
      {
         if(b_edit_mode)
         {
            Render.drawFilledBox(position_x, position_y, size_x, size_y, #ff222222); // debug info
            Render.drawRectangle(position_x, position_y, size_x, size_y, #ff555555); // debug info
         }
         return;
      }

      Render.drawFilledBox(position_x, position_y, size_x, size_y, color32);

//       glLineWidth(4.0);
//       Render.drawRectangle(position_x, position_y, size_x, size_y, #ffffffff);
//       glLineWidth(1.0);
   }

   public virtual calc(float dt) {
      //calcGravity(dt);
   }

   public virtual hitBy(Entity _o) : int {
      // Return 1=horizontal, 2=vertical

      ////try { throw Error("test"); } catch(Error e) { trace e.stackTrace; }
      ////trace "xxx BoxEntity::hitBy: o="+#(_o);

      if(!b_visible)
      {
         return 0;
      }

      return = 0;

      if(!b_mover)
      {
         _o.setSuggestedSpeedX(0); // walls have priority over moving blocks
         _o.setSuggestedSpeedY(0); // walls have priority over moving blocks
      }

      // Determine which edge was hit

      ////trace "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";

      if!(this instanceof Item)
      {
         boolean bInsideColl = false;

         // note: +1.0 hack done to not make the player get crushed while jumping up against the bottom of a moving platform
         if( (((_o.position_y + _o.size_y) < ((position_y + size_y))) && ( (_o.position_y+_o.size_y) > (position_y+1.0))) &&
             (((_o.position_x + _o.size_x) < ((position_x + size_x))) && ( (_o.position_x) > (position_x)))
             )
         {
            // Do not let thin platforms crush the player (even not when crouched!)
            //if!( ((_o.position_y + _o.size_y) >= (position_y + size_y)) && (_o.position_y <= position_y) )
            if(Player.NORMAL_SIZE_Y < size_y) //_o.size_y
            {
               // trace "xxx this p=("+position_x+";"+position_y+")";
               // trace "xxx this s=("+size_x+";"+size_y+")";
               // trace "xxx o    p=("+_o.position_x+";"+_o.position_y+")";
               // trace "xxx o    s=("+_o.size_x+";"+_o.size_y+")";
               // trace "xxx inside collision this="+#(this)+" o="+#(_o);
               ////trace "xxx   opx="+_o.position_x+" px="+position_x+" sx="+size_x;
               ////trace "xxx   opy="+_o.position_y+" py="+position_y+" sy="+size_y;
               _o.handleInsideCollision(this);
            }
         }
      }

      float ydist=999999, xdist=999999;
      int yedgeNr = 0;
      int xedgeNr = 0;

      // Top edge
      if( (_o.position_y < (position_y + size_y)) && ((_o.position_y+_o.size_y) > (position_y+size_y)) )
      {
         ////trace "xxx hit top edge";
         yedgeNr = 1;
         ydist = (position_y+size_y) - _o.position_y;
      }

      // Bottom edge
      if( (_o.position_y < (position_y)) && ((_o.position_y+_o.size_y) > position_y) )
      {
         ////trace "xxx hit bottom edge";
         yedgeNr = 2;
         ydist = ((_o.position_y+_o.size_y) - position_y);
      }

      if(!b_semipermeablex)
      {
         // Left edge
         if( (_o.position_x < (position_x)) && ((_o.position_x+_o.size_x) > position_x) )
         {
            ////trace "xxx hit left edge";
            xedgeNr = 1;
            xdist = (_o.position_x+_o.size_x) - position_x;
         }
         
         // Right edge
         if( (_o.position_x < (position_x+size_x)) && ((_o.position_x+_o.size_x) > (position_x+size_x)) )
         {
            ////trace "xxx hit right edge";
            xedgeNr = 2;
            xdist = (position_x + size_x) - _o.position_x;
         }
      }

      ////trace "xxx BoxEntity p=("+position_x+";"+position_y+") s=("+size_x+";"+size_y+") hitBy o="+#(_o);
      ////trace "xxx xedgeNr="+xedgeNr+" yedgeNr="+yedgeNr;

      if(ydist < xdist)
      {
         if(yedgeNr == 1)
         {
            // Top edge collision
            if(b_semipermeable)
            {
               if(_o.speed_y >= 0)
               {
                  ////trace "xxx jump through semiboxentity";
                  return 0;
               }
            }
            _o.handleCollision(this, DIR_UP, _o.position_x, position_y + size_y);
            return = DIR_UP;
         }
         else if(yedgeNr == 2)
         {
            // Bottom edge collision
            ////trace "xxx bottom edge semi="+reset_b_semipermeable;
            if(!b_semipermeable)
            {
               _o.handleCollision(this, DIR_DOWN, _o.position_x, position_y - _o.size_y - COLL_YCORRECT);
               return = DIR_DOWN;
            }
            else
            {
               return 0;
            }
         }
      }
      else if(xdist < ydist)
      {
         ////trace "xxx ydist="+ydist+" xdist="+xdist+" yedge="+yedgeNr+" xedge="+xedgeNr;
         // Note: the +- shiftintowall (0.01) constant will keep the player colliding with the wall. 
         //       this makes walljumping a bit less hectic!
         float shiftintowall = (_o instanceof Player) ? 0.01*g_dt : 0; // hack
         if(xedgeNr == 1)
         {
            // Left edge collision
            _o.handleCollision(this, DIR_LEFT, position_x - _o.size_x + shiftintowall, _o.position_y);
            ////trace "xxx left edge collision _o.speed_x="+_o.speed_x;
            return = DIR_LEFT;
         }
         else if(xedgeNr == 2)
         {
            // Right edge collision
            _o.handleCollision(this, DIR_RIGHT, position_x + size_x - shiftintowall, _o.position_y);
            return = DIR_RIGHT;
         }

      }

      ////trace "xxx after BoxEntity::hitBy: o.pos=("+_o.position_x+";"+_o.position_y+")";

   }

   public virtual actionSet(String key, value) : boolean {
      StringArray *a;
      ////trace "xxx boxentity::actionSet: key=\""+key+"\" value=\""+value+"\"";
      switch(key)
      {
         case "color":
            color32 = value;
            return true;

         case "semipermeable":
            if("toggle" == value)
            {
               b_semipermeable = ! b_semipermeable;
            }
            else
            {
               b_semipermeable = value;
            }
            return true;

         case "semipermeablex":
            if("toggle" == value)
            {
               b_semipermeablex = ! b_semipermeablex;
            }
            else
            {
               b_semipermeablex = value;
            }
            return true;
      }

      return Entity::actionSet(key, value);
   }

}
