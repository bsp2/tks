
// 27Mar2010

module MElasticEntity;

namespace jumpy;

class ElasticEntity extends BoxEntity {

   // platform starts sinking when player jumps on it
   // and springs back to original position once the player
   // jumps off again

   float top_coll_timeout;
   float last_position_y;
   float force_y; // xx should use speed_y ?
   float sink_speed;
   float elasticity;
   float decay;
   float range;
   Character *character;

   define float TOP_COLL_TIMEOUT = 8;

   define float MIN_ELASTICITY = 0.001;
   define float MAX_ELASTICITY = 0.1;

   public static NewElasticEntity(float x, y, w, h, int c32) : ElasticEntity {
      ElasticEntity e <= new ElasticEntity;
      e.initBoxEntity(x, y, w, h, c32);
      e.initElasticEntity();
      return deref e;
   }

   public method initElasticEntity() {
      sink_speed = -0.08;
      elasticity = 0.15;
      decay      = 0.916;
      range      = 24;
   }

   public virtual draw(float dt) {
      Render.drawFilledBox(position_x, position_y, size_x, size_y, color32);

//       glLineWidth(4.0);
//       Render.drawRectangle(position_x, position_y, size_x, size_y, #ffffffff);
//       glLineWidth(1.0);
   }

   public virtual resetEntity() {
      BoxEntity::resetEntity();

      speed_y          = 0;
      top_coll_timeout = 0;
      last_position_y  = reset_y;
      speed_y/*force_y*/          = 0;
      character       <= null;
   }

   public virtual calc(float dt) {

      last_position_y = position_y;

      if(top_coll_timeout > 0)
      {
         //speed_y -= 0.001 * dt;
         speed_y/*force_y*/ += sink_speed * dt;

         top_coll_timeout -= dt;
         if(top_coll_timeout <= 0)
         {
            top_coll_timeout = 0;
            character <= null;
         }
      }
      else
      {
         //speed_y *= mathPowerf(0.97, dt);
         ////position_y += (reset_y - last_position_y) * mathPowerf(0.000016, dt);
         float el = (MIN_ELASTICITY + (MAX_ELASTICITY - MIN_ELASTICITY)*elasticity);
         speed_y/*force_y*/ += (reset_y - last_position_y) * el * dt;
      }

      ////trace "xxx position_y="+position_y+" force_y="+speed_y/*force_y*/;
      position_y += speed_y/*force_y*/ * dt;

      ////trace "xxx decay="+decay+" cdecay="+mathPowerf(decay, dt);
      speed_y/*force_y*/ *= mathPowerf(decay, dt);

      // Limit maximum speed
      if(speed_y/*force_y*/ < -6)
         speed_y/*force_y*/ = -6;
      else if(speed_y/*force_y*/ > 6)
         speed_y/*force_y*/ = 6;

      // if(null != character)
      // {
      //    trace "xxx suggest speedy="+speed_y/*force_y*/;
      //    character.setSuggestedSpeedY(speed_y/*force_y*/);
      // }

      // Limit lowest/highest distance to original position
      float d = abs(reset_y - position_y);
      ////trace "xxx d="+d;
      if(d > range)
      {
         if(position_y < reset_y)
         {
            position_y = reset_y - range;
         }
         else
         {
            position_y = reset_y + range;
         }
      }
   }

   public virtual hitBy(Entity _o) : int {
      // Return 1=horizontal, 2=vertical

      return = 0;

      // Determine which edge was hit

      ////trace "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";

      float ydist=999999, xdist=999999;
      int yedgeNr = 0;
      int xedgeNr = 0;

      // Top edge
      if(1)//_o.isFalling())//if(_o.speed_y < 0)
      {
         if( (_o.position_y < (position_y + size_y)) && ((_o.position_y+_o.size_y) > (position_y+size_y)) )
         {
            ////trace "xxx hit top edge";
            yedgeNr = 1;
            ydist = (position_y+size_y) - _o.position_y;
            //_o.speed_y = 0;
            if(_o instanceof Character)
            {
               Character ch <= _o;
               if(ch.speed_y < 0)
               {
                  if(ch.tryToLandOnEntity(DIR_UP, this))
                  {
                     character <= ch;
                     top_coll_timeout = TOP_COLL_TIMEOUT;
                  }
                  else
                  {
                     character <= null;
                  }
               }
            }
         }
      }

      // Bottom edge
      if(1)//_o.isJumping())//if(_o.speed_y > 0)
      {
         if( (_o.position_y < (position_y)) && ((_o.position_y+_o.size_y) > position_y) )
         {
            ////trace "xxx hit bottom edge";
            yedgeNr = 2;
            ydist = ((_o.position_y+_o.size_y) - position_y);
            //_o.speed_y = 0;
         }
      }

      if(1)//if( (_o.position_y < (position_y + size_y)) )
      {
         // Left edge
         if(1)//if(_o.speed_x > 0)
         {
            if( (_o.position_x < (position_x)) && ((_o.position_x+_o.size_x) > position_x) )
            {
               ////trace "xxx hit left edge";
               xedgeNr = 1;
               xdist = (_o.position_x+_o.size_x) - position_x;
            }
         }
         
         // Right edge
         if(1)//if(_o.speed_x < 0)
         {
            if( (_o.position_x < (position_x+size_x)) && ((_o.position_x+_o.size_x) > (position_x+size_x)) )
            {
               ////trace "xxx hit right edge";
               xedgeNr = 2;
               xdist = (position_x + size_x) - _o.position_x;
            }
         }
      }

      //trace "xxx xedgeNr="+xedgeNr+" yedgeNr="+yedgeNr;

      //if((999998<xdist)&&(999998<ydist))
      //{
      //   trace "xxx no coll";
      //}


      if(ydist < xdist)
      {
         if(yedgeNr == 1)
         {
            // Top edge collision
            boolean bTopColl = true;
            if(_o instanceof Character)
            {
               Character c <= _o;
               ///if((c.state != Character.ST_FALLING))
               if(c.speed_y > 0)
               {
                  ////trace "xxx jump through semiboxentity";
                  bTopColl = false;
                  return 0;
               }
            }
            if(bTopColl)
            {
               _o.handleCollision(this, DIR_UP, _o.position_x, position_y + size_y);
               return = DIR_UP;
            }
         }
         else if(yedgeNr == 2)
         {
            // Bottom edge collision
            ////_o.handleCollision(this, DIR_DOWN, _o.position_x, position_y - _o.size_y - COLL_YCORRECT);
            ////return = DIR_DOWN;
         }
      }
      else if(xdist < ydist)
      {
         ////trace "xxx ydist="+ydist+" xdist="+xdist+" yedge="+yedgeNr+" xedge="+xedgeNr;
         // Note: the +- shiftintowall (0.01) constant will keep the player colliding with the wall. 
         //       this makes walljumping a bit less hectic!
         float shiftintowall = (_o instanceof Player) ? 0.01*g_dt : 0; // hack
         if(xedgeNr == 1)
         {
            // Left edge collision
//              _o.handleCollision(this, DIR_LEFT, position_x - _o.size_x + shiftintowall, _o.position_y);
// //             ////trace "xxx left edge collision _o.speed_x="+_o.speed_x;
//              return = DIR_LEFT;
         }
         else if(xedgeNr == 2)
         {
            // Right edge collision
            // _o.handleCollision(this, DIR_RIGHT, position_x + size_x - shiftintowall, _o.position_y);
            // return = DIR_RIGHT;
         }

//       _o.speed_x = 0;
//       _o.speed_y = 0;
      }

      ////trace "xxx after BoxEntity::hitBy: o.pos=("+_o.position_x+";"+_o.position_y+")";

   }
}
