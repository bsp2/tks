
// 12Mar2010, 06Apr2010

module MFinishItem;

namespace jumpy;

class FinishItem : Item  {

   protected String achievement;
   protected String achievement_message;
   protected String warp;

   public static NewFinishItem(float x, y, String _achievement, String _achievementMessage, String _warp) : FinishItem {
      FinishItem f <= new FinishItem;
      f.initFinishEntity(x,y, _achievement, _achievementMessage, _warp);
      return deref f;
   }

   public method initFinishEntity(float x, y, String _achievement, String _achievementMessage, _warp) {
      initItem();

      setEntityPosition(x, y);
      setEntitySize(6, 6);

      achievement = _achievement;

      warp = _warp;

      if(!warp.isBlank())
      {
         color32 = #ff398fcf;
      }
      else if(!_achievement.isBlank())
      {
         _achievementMessage.replaceChar(';', '\n') => achievement_message;
         color32 = #ffcf8f39;
      }
      else
      {
         color32 = #ff00ff89;
      }

      b_collectable = true;
   }

   public method handleCollect(Entity _carryEntity) : boolean {
      if(b_visible)
      {
         String head;
         String msg;

         if(!warp.isBlank() && !b_edit_mode)
         {
            if!(achievement.isBlank())
            {
               Ingame.HandleAchievement(achievement);
            }

            StringArray a <= warp.splitChar(':');
            String world = a.get(0);
            String room  = a.get(1);
            head = "warp to world \'"+world+"\', room \'"+room+"\'";
            msg="";
            g_ingame.showMessage(head, achievement_message, 0, Ingame.ACTION_SHOWMAPINFO);
            g_ingame.min_message_time = Ingame.MIN_FINISH_MESSAGE_TIME;
            g_level.warpTo(world, room);
            // Note: "this" becomes invalid after last call
            return;
         }

         if(achievement.isBlank() || b_edit_mode)
         { 
            head = "finish !";
            msg = "you have successfully completed this room in "+ g_ingame.getLevelTimeString()
               +" seconds.\n\n\n\n"
               "  >> Press RETURN or SPACE to play this room again <<\n\n";

            // List challenges
            PointerArray ch <= g_level.challenges;
            if(ch.numElements > 0)
            {
               msg.append("\n\n\n\nNow that you completed this room, how about a challenge?\n\n");
               Challenge *c;
               String ci = "1";
               foreach c in ch
               {
                  msg.append("  Challenge ");
                  msg.append(ci);
                  ci[0] = ci[0]+1;
                  msg.append(": ");
                  msg.append(c.message);
               
                  if(c.time > 0)
                  {
                     if(g_ingame.level_timer < c.time)
                     {
                        c.b_complete = 1;
                     }
                  }

                  if(c.b_complete)
                  {
                     msg.append(" **COMPLETE* !");
                  }
                  else
                  {
                     g_level.current_challenge <= c;
                     break;
                  }
                  msg.append("\n\n");
               }
            }

            if(b_edit_mode)
            {
               g_ingame.showMessage(head, msg, 0, Ingame.ACTION_RESETMAP);
            }
            else
            {
               g_level.handleMapFinished();
               g_ingame.showMessage("finish !", msg, 0, Ingame.ACTION_NEXTMAP);
               g_ingame.min_message_time = Ingame.MIN_FINISH_MESSAGE_TIME;
               trace "[dbg] reached finish after "+g_ingame.getLevelTimeString()+" seconds.";
            }

         }
         else
         {
            Ingame.HandleAchievement(achievement);

            head = "you have found a secret !";
            g_ingame.min_message_time = Ingame.MIN_FINISH_MESSAGE_TIME;
            g_ingame.showMessage(head, achievement_message, 0, Ingame.ACTION_RESETMAP);
         }

      }
   }

   public method calc(float dt) {
      //BoxEntity::calc(dt);
   }
   
   public virtual draw(float dt) {
      ////trace "xxx finishitem::draw: visible="+b_visible+" "+reset_b_visible;
      if(!b_visible)
      {
         return;
      }

      if(!b_collectable)
      {
         Render.drawFilledBox(position_x, position_y, size_x, size_y, color32);
      }

      if(b_collectable)
      {
         if(true)
         {
            tex_exit.bind();
            tex_exit.enable();
            glBegin(GL_TRIANGLE_FAN);
            glTexCoord2f(0, 1);
            glVertex2f(position_x, position_y);

            glTexCoord2f(1, 1);
            glVertex2f(position_x + size_x, position_y);

            glTexCoord2f(1, 0);
            glVertex2f(position_x + size_x, position_y + size_y);

            glTexCoord2f(0, 0);
            glVertex2f(position_x, position_y + size_y);
            glEnd();
            tex_exit.disable();
         }
         else
         {
            // original render code (slow on PVR):
            glLineWidth(4.0);
            Render.drawRectangle(position_x, position_y, size_x, size_y, #ffffffff);
            glBegin(GL_LINES);
            glVertex2f(position_x, position_y+size_y*0.5);
            glVertex2f(position_x+size_x*0.5, position_y+size_y);
            
            glVertex2f(position_x+size_x*0.5, position_y+size_y);
            glVertex2f(position_x+size_x, position_y+size_y*0.5);
            
            glVertex2f(position_x, position_y+size_y*0.5);
            glVertex2f(position_x+size_x*0.5, position_y);
            
            glVertex2f(position_x+size_x*0.5, position_y);
            glVertex2f(position_x+size_x, position_y+size_y*0.5);
            glEnd();
            glLineWidth(1.0);
         }
      }
   }

   public virtual actionActivate() {
      b_visible = true;
   }

   public virtual actionDeactivate() {
      b_visible = false;
   }

}
