
module MTrack;

namespace racer;


IntArray seg_tri_colors = [ // 6*3 vertex colors
   #ff103050,   #ff103050,   #ff103050,
   #ff205080,   #ff205080,   #ff205080,
   #ffa0a040,   #ffa0a040,   #ffa0a040,
   #ffd0d070,   #ffd0d070,   #ffd0d070,
   #ffa0a040,   #ffa0a040,   #ffa0a040,
   #ffd0d070,   #ffd0d070,   #ffd0d070
];

IntArray seg_solid_colors = [ // 6*3 vertex colors
   #ff103050,   #ff103050,   #ff103050,
   #ff14385c,   #ff14385c,   #ff14385c,
   #ffa0a040,   #ffa0a040,   #ffa0a040,
   #ffd0d070,   #ffd0d070,   #ffd0d070,
   #ffa0a040,   #ffa0a040,   #ffa0a040,
   #ffd0d070,   #ffd0d070,   #ffd0d070
];




   // "testlevel.svg"
   //String svgPolyline = "M 135.71429,559.50504 C 178.42738,421.50889 48.571428,202.36218 71.428571,102.36218 C 95.497102,-2.9376432 210,98.076468 210,98.076468 C 265.71429,160.93361 134.28572,275.21933 178.57143,328.07647 C 250.81789,414.30611 457.14286,336.64789 460,263.79075 C 464.00136,154.95503 264.63607,137.42354 295.71428,79.505039 C 327.14286,20.933611 671.34052,80.786848 692.85714,116.64789 C 710,145.21932 743.77012,317.88155 640,320.93361 C 591.42858,322.36219 481.42858,199.50504 484.28572,168.07646 C 489.07817,115.35955 594.28571,100.93361 637.14286,125.21933 C 712.7244,168.04887 666.2287,261.40464 617.14286,249.50504 C 570,238.07647 540,189.50504 542.85714,173.79076 C 549.97596,134.63727 592.85714,129.50504 617.14286,148.07646 C 671.34055,189.52176 686.25536,457.57248 660,559.50504 C 635.71429,653.79076 564.66754,730.54171 502.85714,712.36218 C 405.71428,683.79075 290.52493,559.99998 312.85714,459.50504 C 327.14286,395.21933 529.7079,253.55043 517.14286,383.79075 C 500.248,551.89815 768.39814,814.37848 692.85714,945.21933 C 598.30125,1039.7752 598.95173,688.02138 480,783.79075 C 401.42858,850.93361 645.22099,949.04547 481.42857,1010.9336 C 305.71428,1008.0765 413.38716,769.26182 342.85714,695.21933 C 274.28571,628.07647 13.026166,908.8262 87.142857,965.21933 C 152.85714,1015.2193 278.11047,1036.0276 332.85714,969.50504 C 387.73554,902.82242 162.85714,803.79075 100,725.21932 C 61.875737,677.564 117.14286,619.50504 135.71429,559.50504 z";

   // "testlevel2.svg"
   //String svgPolyline = "M 95.714287,392.36218 C 47.677487,268.27806 230.16408,354.51782 222.85714,292.36218 C 215.45036,229.35719 68.571429,268.07647 61.428572,179.50504 C 86.143763,97.121067 142.85714,85.219326 215.71429,89.50504 C 371.19397,98.514505 252.85715,158.07647 297.14286,228.07647 C 335.19383,288.22155 368.57143,143.79075 442.85714,140.93361 C 546.23069,136.692 567.14286,232.36218 567.14286,232.36218 C 578.57143,330.93361 376.2753,247.91059 404.28571,325.21933 C 440,423.79076 663.62482,256.66296 644.28571,429.50504 C 632.85714,540.93361 520,533.79075 520,533.79075 C 340,449.50504 474.92044,411.67129 352.85714,375.21933 C 252.85714,355.21933 281.73706,489.14825 217.14286,495.21932 C 151.42857,485.21932 114.73158,444.32154 95.714287,392.36218 z";

   // "testlevel2b.svg" (trickjump + speed)
String svgPolyline2b ="M 248.81601,98.777511 C 448.38297,17.894168 309.68185,325.16121 409.648,312.85794 C 510.98017,300.38656 448.70719,53.074941 591.15838,41.047947 C 723.65816,82.662867 742.79996,178.15564 735.90717,300.83097 C 721.41705,562.62435 625.62237,363.37132 513.03997,437.93865 C 416.30746,502.00807 648.59838,558.20857 653.19359,683.28927 C 660.01543,857.34746 506.14719,892.55898 506.14719,892.55898 C 347.6128,911.80215 481.14036,571.18018 356.80319,618.3435 C 198.2688,678.47848 467.06376,1055.0133 189.07841,1022.4504 C 9.8656171,1003.2072 21.353628,813.18078 21.353628,813.18078 C 156.91202,510.1006 217.76077,737.27676 276.38719,531.74918 C 308.55359,363.3713 93.153047,411.99871 83.388827,303.23636 C 99.472032,192.58802 165.24874,130.79842 248.81601,98.777511 z";

   // "testlevel3.svg" (marnie :))
   //String svgPolyline = "M 437.14286,150.9336 C 389.15287,139.148 367.39021,135.18904 327.14286,78.076468 C 226.81269,47.996358 207.16843,79.528768 204.28572,82.362183 C 160,120.93361 168.57142,163.79075 168.57142,163.79075 C 171.42857,163.79075 217.14286,209.50504 217.14286,209.50504 C 217.14286,209.50504 229.08942,276.91956 218.57143,293.79075 C 202.29565,319.89761 87.105288,244.69674 47.142858,296.6479 C 32.857144,315.21933 17.142857,340.93362 30,360.93362 C 54.876769,399.63081 215.65109,460.93944 244.28571,420.93361 C 314.1262,323.35849 332.85714,370.93361 361.42857,412.36218 C 385.28218,446.94991 431.42857,416.64789 402.85714,493.79075 C 394.91853,515.22501 460.28877,544.26813 401.42857,596.6479 C 375.47782,619.74151 255.36779,567.78291 230,598.07647 C 199.1181,634.95484 228.57143,660.93361 228.57143,660.93361 C 390,793.79075 462.42335,794.65921 568.57143,688.07647 C 604.28572,630.93361 636.92201,622.85514 580,466.6479 C 554.53255,396.77838 528.18738,425.05543 495.71429,370.93361 C 427.14286,256.6479 513.96379,304.79969 488.57143,239.50504 C 468.57143,188.07647 576.4475,188.26017 437.14286,150.9336 z";

   //String svgPolyline = "M 227.14285,426.6479 C 230,300.93361 99.514139,343.50167 95.714286,248.07647 C 90,120.93361 142.85714,33.790754 214.28571,29.50504 C 339.75989,21.738855 231.42858,149.50504 375.71429,242.36219 C 492.78824,321.80369 438.32955,74.883287 505.71428,75.219325 C 637.14285,76.647897 632.765,215.21069 631.42857,245.21933 C 615.71428,488.07647 591.62434,623.97072 528.57143,692.36218 C 447.14286,780.93361 144.64426,902.80305 131.42857,709.50504 C 122.85714,575.21932 224.31819,526.608 227.14285,426.6479 z";

   // "testlevel5.svg" (marnie, 8)
   //String svgPolyline = "M 41.428572,56.647897 C 118.55328,-25.185333 458.57143,-20.494961 552.85714,103.79075 C 664.7178,251.24344 -91.779206,609.98885 40,939.50504 C 136.44953,1183.1247 786.99425,957.8185 667.14286,728.07648 C 563.51496,530.52104 -128.57143,236.6479 41.428572,56.647897 z";

   // "testlevel6.svg"
   //String svgPolyline ="M 148.57143,880.93361 C 134.28572,798.07647 134.28572,223.79076 138.57143,135.21933 C 141.25704,79.716694 248.57143,29.505039 347.14286,42.362182 C 430.15446,53.189783 560.81744,163.90579 611.42857,510.93361 C 641.42857,736.64789 615.71429,929.50504 407.14286,945.21932 C 407.14286,945.21932 156.94102,929.47721 148.57143,880.93361 z";

   // "testlevel7.svg" (spiral)
   //String svgPolyline = "M 341.30952,521.76691 C 312.88827,509.04275 315.93047,469.91772 332.61911,449.2669 C 362.47115,412.32742 418.95645,418.87653 450.3572,449.86224 C 496.43907,495.33501 486.01335,571.19389 440.47611,612.83842 C 379.78213,668.34404 283.96548,653.87513 232.26184,593.67158 C 167.19809,517.91156 185.78392,401.89271 260.71444,340.21922 C 351.46533,265.52436 487.81206,288.26471 559.40489,377.95757 C 643.77456,483.65749 616.85822,640.40547 512.38078,721.88611 C 391.75745,815.95873 214.56156,784.8531 123.21416,665.57625 C 19.419435,530.04632 54.72314,332.37093 188.80976,231.17153 C 339.23469,117.64111 557.41195,157.14898 668.45257,306.0529 C 791.7287,471.36447 748.01229,710.06004 584.28545,830.93379 L 585.71429,832.36218 C 491.42858,909.50504 300.86521,1015.2524 215.71428,905.21932 C 54.464491,696.74446 598.57143,725.21932 538.57143,539.50504 C 505.84309,455.96672 377.022,528.61178 341.30952,521.76691 z";

   // "testlevel8.svg" (the egg)
   //String svgPolyline = "M 240.00001,170.9336 C 423.64671,31.517078 664.96821,10.182527 714.28572,306.6479 C 763.60323,603.11327 670.57324,786.23119 572.85715,888.07646 C 546.93081,915.09837 357.93627,1039.7561 164.28572,883.79075 C 52.441503,793.71192 -143.23254,461.86696 240.00001,170.9336 z";
   
   // "testlevel9.svg" (unclosed polyline)
String svgPolyline9 = "M 211.42857,895.21932 C 434.28571,286.64789 -11.428567,592.36218 105.71429,218.07647 C 173.3428,8.4172308 500.11234,37.623817 557.14286,232.36218 C 674.28572,632.36218 628.57142,783.79075 468.57142,829.50504";


// "testlevel10.svg" (straight line)
String svgPolyline10 = "M 300,163.79076 C 300,77.886206 308.57143,907.06168 308.57143,818.07647";



// "testenvelope.svg"
String svgEnvelope1 = "M 42.857143,478.07647 C 42.857143,478.07647 81.42857,433.07647 128.57143,435.21933 C 172.09931,437.16677 182.7583,538.90257 220,535.21933 C 285,528.79076 298.57143,460.93361 340,432.36218 C 382.28296,403.08678 413.19028,528.75578 485.71429,520.93361 C 618.57143,508.79075 671.42857,478.07647 671.42857,478.07647";


Texture tex_track_pattern;
Texture tex_border_pattern;




class Track {
   define float SCALE = 8;
   //prev5: define float SIZE = 1000.0f * SCALE; // 1000.0f for level
   define float SIZE = 10.0f * SCALE; // 10.0f for level, v5+
   ////define int GRIDSIZE = 128; // ORIGINAL
   define int GRIDSIZE = 256;
   //define int GRIDSIZE = 32;

   define int FLOOR_GRIDSIZE = 64;

   PointerArray track_entities; // deletable TrackEntity instances
   
   FloatArray           track_vertexarray; // triangulized vertices
   FloatArray           track_colorarray;  // vertex colors
   FloatArray           track_uvcoordarray;
   FloatArray           border_vertexarray_l; 
   FloatArray           border_vertexarray_r; 
   FloatArray           border_colorarray_l; 
   FloatArray           border_colorarray_r; 
   FloatArray           border_uvcoordarray_l;
   FloatArray           border_uvcoordarray_r;

   // FloatArray           border_vertexarray;
   // FloatArray           border_colorarray; 
   // FloatArray           border_uvcoordarray;

   int bo_track  = -1;
   int bo_border_l = -1;
   int bo_border_r = -1;

   PointerArray         track_segments; // deletable TrackSegment instances

   PointerArray         segment_grid; // List, references to TrackSegment

   float coll_vec_sum_x;
   float coll_vec_sum_y;
   float coll_vec_sum_z;

   float coll_pos_sum_x;
   float coll_pos_sum_y;
   float coll_pos_sum_z;

   int total_num_collisions;
   TrackSegment last_coll_seg;

   float border_anim_offset = 0;

   Vector3f player_start_pos;
   Vector3f player_start_dir;

   PointerArray sorted_checkpoints;
   TrackCheckpointEntity next_checkpoint;

   Vector3f track_bb_min;
   Vector3f track_bb_max;

   float fog_r, fog_g, fog_b;

   float hiscore_author;
   float hiscore_gold;
   float hiscore_silver;
   float hiscore_bronze;

   int medal_himode;

   protected method initEntities() {
      TrackPolyLineEntity ple;

      track_entities.free();

      ple <= new TrackPolyLineEntity();

      BezierPolyLine bpl;
      bpl.addSimpleCtlPoint(-Track.SIZE,0);
      bpl.addSimpleCtlPoint(-Track.SIZE*0.75,0);
      bpl.addSimpleCtlPoint(-Track.SIZE*0.5,0);
      bpl.addSimpleCtlPoint(-Track.SIZE*0.25,0);
      bpl.addSimpleCtlPoint( 0,0);
      bpl.addSimpleCtlPoint( Track.SIZE*0.25,0);
      bpl.addSimpleCtlPoint( Track.SIZE*0.5,0);
      bpl.addSimpleCtlPoint( Track.SIZE*0.75,0);
      bpl.addSimpleCtlPoint( Track.SIZE,0);
      ple.initPolyLine(bpl,      // svg polyline path
                       false,             // is closed
                       vector3f(0, 0, 0),          // base position
                       vector3f(0.5,1,0.5),//vector3f(SCALE, 1, SCALE),   // scaling
                       null, null, null, null
                       );
      PathEdit.SetEnvelope(ple.points, bpl);

      track_entities.add(#(deref ple));
   }

   public method init() {

      initEntities();

      fog_r = 0x6d/255.0;
      fog_g = 0x6c/255.0;
      fog_b = 0x7a/255.0;

      //updateTrack(); // keep commented out unless no map is loaded during startup
   }
   
   public method setPlayerStartAndDirection(float _px, _py, _pz,
                                            float _dx, _dy, _dz) {
      
      player_start_pos.init(_px, _py, _pz);
      player_start_dir.init(_dx, _dy, _dz);

      trace "[...] Track::setPlayerStartAndDirection: set to pos="+player_start_pos+" dir="+player_start_dir;
   }

   public method newPolyLineEntityAt3f(float _x, _y, _z) : TrackPolyLineEntity {
      BezierPolyLine bpl <= new BezierPolyLine;
      bpl.addSimpleCtlPoint(-Track.SIZE/(Track.SCALE/2),0);
      bpl.addSimpleCtlPoint( 0,0);
      bpl.addSimpleCtlPoint( Track.SIZE/(Track.SCALE/2),0);

      TrackPolyLineEntity ple <= new TrackPolyLineEntity;
      ple.initPolyLine(deref bpl,      // svg polyline path
                       false,             // is closed
                       vector3f(_x, _y, _z),          // base position
                       vector3f(0.5,1,0.5),//vector3f(SCALE, 1, SCALE),   // scaling
                       null, null, null, null
                       );
      PathEdit.SetEnvelope(ple.points, bpl);

      // Reset rotation
      ple.rotation.initIdentity();

      track_entities.add(#(deref ple));
      return ple;
   }

   public method newCheckpointEntityAt3f(float _x, _y, _z) {
      TrackCheckpointEntity cpe <= new TrackCheckpointEntity;
      cpe.initCheckpoint(_x, _y, _z, false);
      // Reset rotation
      cpe.rotation.initIdentity();
      PathEdit.SetEnvelope(null, null);
      track_entities.add(#(deref cpe));
   }

   public method onOpen() {
      int flags = TEX_REPEAT_S | TEX_REPEAT_T;
      if(RacerConfiguration.b_texture_filter)
      {
         flags |= TEX_MAGFILTERLINEAR;
         flags |= TEX_MINFILTERLINEAR;
      }

      tex_track_pattern.unload();
      tex_track_pattern.loadImage("tex_track_pattern.png", 64, 64, 3);
      tex_track_pattern.flags = flags;
      tex_track_pattern.upload();

      tex_border_pattern.unload();
      tex_border_pattern.loadImage("tex_border_pattern.png", 64, 64, 3);
      tex_border_pattern.flags = flags;
      tex_border_pattern.upload();
   }

   public method updateTrack() {
      createTrackSegments();
      calcTrackBBox();
      if(!RacerConfiguration.b_edit)
      {
         createSegmentGrid();
      }
      createTrackVertexArray();

      sortCheckpoints();
      sortHiscores();
      next_checkpoint <= null;
      last_coll_seg <= null;
   }

   public method resetTrack() {
      if(sorted_checkpoints.numElements)
      {
         next_checkpoint <= sorted_checkpoints[0];
         trace "[dbg] Track::resetTrack: next_checkpoint = "+#(next_checkpoint);
         last_coll_seg <= null;
      }
      else
      {
         next_checkpoint <= null;
      }
   }

   protected method sortHiscores() {
      IntArray ia;
      ia.alloc(4);
      ia.identity(4);
      FloatArray fa;
      fa.empty();
      fa.add(hiscore_author);
      fa.add(hiscore_gold);
      fa.add(hiscore_silver);
      fa.add(hiscore_bronze);
      fa.sortByValue(ia);
      fa.rearrange(ia);
      hiscore_author = fa.get(0);
      hiscore_gold   = fa.get(1);
      hiscore_silver = fa.get(2);
      hiscore_bronze = fa.get(3);
   }

   protected method sortCheckpoints() {
      PointerArray pa; pa.empty();

      TrackCheckpointEntity cpe;
      IntArray ids;
      ids.empty();
      foreach cpe in track_entities {
         if(cpe instanceof TrackCheckpointEntity) {
            ids.add(cpe.checkpoint_id);
            pa.add(cpe);
         }
      }

      IntArray sortedIds;
      ids.sortByValue(sortedIds);
      sorted_checkpoints.empty();
      int idx = 0;
      loop(pa.numElements) {
         sorted_checkpoints.add(pa[sortedIds[idx++]]);
      }

      // debug:
      trace "[dbg] track has "+(sorted_checkpoints.numElements)+" checkpoint(s):";
      idx = 0;
      foreach cpe in sorted_checkpoints {
         trace "[dbg]    checkpoint #"+idx+": id="+cpe.checkpoint_id;
         idx++;
      }
   }

   public method addTrackSegment(TrackSegment _seg) {
      track_segments.add(#(deref _seg));
   }

   protected method calcSegmentNormals() {
      TrackSegment seg;
      foreach seg in track_segments {
         // Calculate surface and edge normals
         seg.calcFaceNormals();
         seg.calcEdgeNormals();
      }
   }

   public method createTrackSegments() {

      trace "[dbg] Track::createTrackSegments: iterating "+track_entities.numElements+" entities.";

      track_segments.free();

      TrackEntity te;

      foreach te in track_entities {
         te.addSegmentsToTrack(this);
      }

      calcSegmentNormals();
   }

   protected method addSegmentToGrid(int gridx, int gridy, TrackSegment seg) {
      if(0 < gridx < GRIDSIZE)
      {
         if(0 < gridy < GRIDSIZE)
         {
            List l <= segment_grid[gridx + gridy*GRIDSIZE];
            if(l == null)
            {
               l <= new List;
               segment_grid[gridx + gridy*GRIDSIZE] = deref l;
            }
            l.addLast(#(seg));
         }
      }
   }

   protected method calcTrackBBox() {
      track_bb_min.init(999999, 999999, 999999);
      track_bb_max.init(-999999, -999999, -999999);
      TrackSegment seg;
      foreach seg in track_segments compile {
         Vector2f minxz, maxxz;
         seg.getXZBoundingBox(minxz, maxxz);

         if(minxz.x < track_bb_min.x)
         {
            track_bb_min.x = minxz.x;
         }
         if(minxz.y < track_bb_min.z)
         {
            track_bb_min.z = minxz.y;
         }
         if(maxxz.x > track_bb_max.x)
         {
            track_bb_max.x = maxxz.x;
         }
         if(maxxz.y > track_bb_max.z)
         {
            track_bb_max.z = maxxz.y;
         }
      }
      track_bb_min.x -= 200 * 0.01;
      track_bb_min.z -= 200 * 0.01;
      track_bb_max.x += 200 * 0.01;
      track_bb_max.z += 200 * 0.01;
      trace "[dbg] track bb_min="+track_bb_min+" bb_max="+track_bb_max;
   }

   protected method createSegmentGrid() {
      trace "[dbg] Track::createSegmentGrid: iterating "+track_segments.numElements+" segments.";

      segment_grid.alloc(GRIDSIZE*GRIDSIZE);
      segment_grid.useAll();

      TrackSegment seg;
      int segid = 0;
      foreach seg in track_segments compile {
         Vector2f minxz, maxxz;
         seg.getXZBoundingBox(minxz, maxxz);
         int mingridx = int( ((minxz.x - track_bb_min.x) / (track_bb_max.x - track_bb_min.x))  * GRIDSIZE) - 0;
         int mingridz = int( ((minxz.y - track_bb_min.z) / (track_bb_max.z - track_bb_min.z))  * GRIDSIZE) - 0;
         int maxgridx = int( ((maxxz.x - track_bb_min.x) / (track_bb_max.x - track_bb_min.x))  * GRIDSIZE) + 1;
         int maxgridz = int( ((maxxz.y - track_bb_min.z) / (track_bb_max.z - track_bb_min.z))  * GRIDSIZE) + 1;
         //trace "#"+(segid++)+" min="+minxz+" max="+maxxz+" mingrid=("+mingridx+";"+mingridz+") maxgrid=("+maxgridx+";"+maxgridz+")";
         int cgridz = mingridz;
         while(cgridz < maxgridz)
         {
            int cgridx = mingridx;
            while(cgridx < maxgridx)
            {
               addSegmentToGrid(cgridx, cgridz, seg);
               cgridx++;
            }
            cgridz++;
         }
      }
   }

   protected method appendTrackColor32(int argb32) {
      track_colorarray.add( ((argb32>>16)&255) / 255.0 );
      track_colorarray.add( ((argb32>> 8)&255) / 255.0 );
      track_colorarray.add( ((argb32    )&255) / 255.0 );
      track_colorarray.add( ((argb32>>24)&255) / 255.0 );
   }

   protected method appendBorderLeftColor32(int argb32) {
      border_colorarray_l.add( ((argb32>>16)&255) / 255.0 );
      border_colorarray_l.add( ((argb32>> 8)&255) / 255.0 );
      border_colorarray_l.add( ((argb32    )&255) / 255.0 );
      border_colorarray_l.add( ((argb32>>24)&255) / 255.0 );
   }

   protected method appendBorderRightColor32(int argb32) {
      border_colorarray_r.add( ((argb32>>16)&255) / 255.0 );
      border_colorarray_r.add( ((argb32>> 8)&255) / 255.0 );
      border_colorarray_r.add( ((argb32    )&255) / 255.0 );
      border_colorarray_r.add( ((argb32>>24)&255) / 255.0 );
   }

   protected method optimizeVA(FloatArray _verts, _cols, _uvs, newVerts, newCols, newUV) {
      // Calculate (temporary) normals array
      stdout "[dbg] Track::optimizeVA: calculating normals..";
      FloatArray norms; 
      norms.alloc(_verts.numElements / 3);
      int vIdx = 0;
      float nx, ny, nz;
      int numFaces = _verts.numElements / (3*3);

      compile loop(numFaces)
      {
         // Calc cross product and store surface normal
         float bax = _verts[vIdx+3*1+0]  - _verts[vIdx+3*2+0];
         float bay = _verts[vIdx+3*1+1]  - _verts[vIdx+3*2+1];
         float baz = _verts[vIdx+3*1+2]  - _verts[vIdx+3*2+2];

         float cax = _verts[vIdx+3*1+0]  - _verts[vIdx+3*0+0];
         float cay = _verts[vIdx+3*1+1]  - _verts[vIdx+3*0+1];
         float caz = _verts[vIdx+3*1+2]  - _verts[vIdx+3*0+2];

         nx = ( bay*caz - baz*cay );
         ny = ( baz*cax - bax*caz );
         nz = ( bax*cay - bay*cax );
         float l = sqrt(nx*nx + ny*ny + nz*nz);
         norms.add(-nx / l);
         norms.add(-ny / l);
         norms.add(-nz / l);
         vIdx += 3*3;
      }
      trace "..done.";

      // Merge quads

      // old: (2008)
      //  x----x----x
      //  |\ 1 |\ 3 |
      //  | \  | \  |
      //  |  \ |  \ | ...
      //  | 0 \| 2 \|
      //  x----x----x
      //
      // new: (2014)
      //  x----x
      //  |\ 1 |
      //  | \  |
      //  |  \ | ...
      //  | 0 \|
      //  x----x
      //

      //float dotThreshold = 0.99995;
      //float dotThreshold = 0.9995;
      float dotThreshold = 0.999515;

      float refnx;
      float refny;
      float refnz;
      int refVtxIdx = -1;

      vIdx = 0;
      int nIdx = 0;
      int colIdx = 0;
      int uvIdx = 0;

      float nx2, ny2, nz2;
      int tvIdx;
      float d;
      boolean bMerged;
      int numMerged = 0;

      float refDot;
      float refNx;
      float refNy;
      float refNz;

      compile loop(numFaces/2)
      {
         bMerged = false;

         nx = norms[nIdx +0];
         ny = norms[nIdx +1];
         nz = norms[nIdx +2];

         nx2 = norms[nIdx +3];
         ny2 = norms[nIdx +4];
         nz2 = norms[nIdx +5];

         d = (nx*nx2 + ny*ny2 + nz*nz2);
         //trace "xxx d="+d;

         if(-1 != refVtxIdx)
         {
            // Not start of new polyline ?
            if(
               (_verts[vIdx + (0*3+0)] == _verts[vIdx - (6*3) + (1*3+0)]) &&
               (_verts[vIdx + (0*3+1)] == _verts[vIdx - (6*3) + (1*3+1)]) &&
               (_verts[vIdx + (0*3+2)] == _verts[vIdx - (6*3) + (1*3+2)])
               )
            {
               if(d > dotThreshold)
               {
                  if( (refNx*nx + refNy*ny + refNz*nz) > dotThreshold )
                  {
                     if(numMerged < 4)
                     {
                        // Merge triangles
                        newVerts[newVerts.numElements - (6*3) + (1*3+0)] = _verts[vIdx + (1*3+0)];
                        newVerts[newVerts.numElements - (6*3) + (1*3+1)] = _verts[vIdx + (1*3+1)];
                        newVerts[newVerts.numElements - (6*3) + (1*3+2)] = _verts[vIdx + (1*3+2)];
                        newCols[newCols.numElements - (6*4) + (1*4+0)] = _cols[colIdx + (1*4+0)];
                        newCols[newCols.numElements - (6*4) + (1*4+1)] = _cols[colIdx + (1*4+1)];
                        newCols[newCols.numElements - (6*4) + (1*4+2)] = _cols[colIdx + (1*4+2)];
                        newCols[newCols.numElements - (6*4) + (1*4+3)] = _cols[colIdx + (1*4+3)];
                        newUV[newUV.numElements - (6*2) + (1*2+0)] = _uvs[uvIdx + (1*2+0)];
                        newUV[newUV.numElements - (6*2) + (1*2+1)] = _uvs[uvIdx + (1*2+1)];

                        newVerts[newVerts.numElements - (6*3) + (2*3+0)] = _verts[vIdx + (2*3+0)];
                        newVerts[newVerts.numElements - (6*3) + (2*3+1)] = _verts[vIdx + (2*3+1)];
                        newVerts[newVerts.numElements - (6*3) + (2*3+2)] = _verts[vIdx + (2*3+2)];
                        newCols[newCols.numElements - (6*4) + (2*4+0)] = _cols[colIdx + (2*4+0)];
                        newCols[newCols.numElements - (6*4) + (2*4+1)] = _cols[colIdx + (2*4+1)];
                        newCols[newCols.numElements - (6*4) + (2*4+2)] = _cols[colIdx + (2*4+2)];
                        newCols[newCols.numElements - (6*4) + (2*4+3)] = _cols[colIdx + (2*4+3)];
                        newUV[newUV.numElements - (6*2) + (2*2+0)] = _uvs[uvIdx + (2*2+0)];
                        newUV[newUV.numElements - (6*2) + (2*2+1)] = _uvs[uvIdx + (2*2+1)];

                        newVerts[newVerts.numElements - (6*3) + (4*3+0)] = _verts[vIdx + (4*3+0)];
                        newVerts[newVerts.numElements - (6*3) + (4*3+1)] = _verts[vIdx + (4*3+1)];
                        newVerts[newVerts.numElements - (6*3) + (4*3+2)] = _verts[vIdx + (4*3+2)];
                        newCols[newCols.numElements - (6*4) + (4*4+0)] = _cols[colIdx + (4*4+0)];
                        newCols[newCols.numElements - (6*4) + (4*4+1)] = _cols[colIdx + (4*4+1)];
                        newCols[newCols.numElements - (6*4) + (4*4+2)] = _cols[colIdx + (4*4+2)];
                        newCols[newCols.numElements - (6*4) + (4*4+3)] = _cols[colIdx + (4*4+3)];
                        newUV[newUV.numElements - (6*2) + (4*2+0)] = _uvs[uvIdx + (4*2+0)];
                        newUV[newUV.numElements - (6*2) + (4*2+1)] = _uvs[uvIdx + (4*2+1)];

                        bMerged = true;
                        numMerged++;
                     }
                  }
               }
            }
            else
            {
               // New polyline start, not a candidate for poly merging
               d = 0;
            }
         }

         if(!bMerged)
         {
            // Add old triangles
            numMerged = 0;

            tvIdx = 0;
            loop(2*3)
            {
               newVerts.add(_verts[vIdx + (3*tvIdx+0)]);
               newVerts.add(_verts[vIdx + (3*tvIdx+1)]);
               newVerts.add(_verts[vIdx + (3*tvIdx+2)]);
               newCols.add(_cols[colIdx + (4*tvIdx+0)]);
               newCols.add(_cols[colIdx + (4*tvIdx+1)]);
               newCols.add(_cols[colIdx + (4*tvIdx+2)]);
               newCols.add(_cols[colIdx + (4*tvIdx+3)]);
               newUV.add(_uvs[uvIdx + (2*tvIdx+0)]);
               newUV.add(_uvs[uvIdx + (2*tvIdx+1)]);
               tvIdx++;
            }

            if(d > dotThreshold)
            {
               // Candidate for merging
               refVtxIdx = vIdx;
               refNx = nx;
               refNy = ny;
               refNz = nz;
               refDot = d;
            }
            else
            {
               refVtxIdx = -1;
            }
         }

         // Next segment
         nIdx   += (2)*3;
         vIdx   += (2*3)*3;
         colIdx += (2*3)*4;
         uvIdx  += (2*3)*2;
      }

      trace "xxx new num tri="+(newVerts.numElements/(3*3));
//       die "xxx";

      norms.free();
   }

   protected method optimizeVertexArrays() {

      // Optimize track
      FloatArray newVerts <= new FloatArray;
      FloatArray newCols  <= new FloatArray;
      FloatArray newUV    <= new FloatArray;

      optimizeVA(track_vertexarray, track_colorarray, track_uvcoordarray,
                 newVerts, newCols, newUV
                 );

      track_vertexarray  <= deref newVerts;
      track_colorarray   <= deref newCols;
      track_uvcoordarray <= deref newUV;


      // Optimize left border
      if(true)
      {
         newVerts <= new FloatArray;
         newCols  <= new FloatArray;
         newUV    <= new FloatArray;

         optimizeVA(border_vertexarray_l, border_colorarray_l, border_uvcoordarray_l,
                    newVerts, newCols, newUV
                    );

         border_vertexarray_l  <= deref newVerts;
         border_colorarray_l   <= deref newCols;
         border_uvcoordarray_l <= deref newUV;


         // Optimize right border
         newVerts <= new FloatArray;
         newCols  <= new FloatArray;
         newUV    <= new FloatArray;

         optimizeVA(border_vertexarray_r, border_colorarray_r, border_uvcoordarray_r,
                    newVerts, newCols, newUV
                    );

         border_vertexarray_r  <= deref newVerts;
         border_colorarray_r   <= deref newCols;
         border_uvcoordarray_r <= deref newUV;
      }
   }

   public method createTrackVertexArray() {
      
      trace "[dbg] Track::createTrackVertexArray: begin pass 1";

      int segIdx = 0;
      track_vertexarray .empty();
      track_colorarray  .empty();
      track_uvcoordarray.empty();

      border_vertexarray_l .empty();
      border_colorarray_l  .empty();
      border_uvcoordarray_l.empty();

      border_vertexarray_r .empty();
      border_colorarray_r  .empty();
      border_uvcoordarray_r.empty();

      IntArray vtxCols <= RacerConfiguration.b_color_tris ? seg_tri_colors : seg_solid_colors;

      compile loop(track_segments.numElements) {
         TrackSegment seg <= track_segments[segIdx++];
         int vtxIdx = 0;
         FloatArray collVerts <= seg.vertices;      // collision mesh
         FloatArray verts <= seg.orig_vertices; // render mesh
         FloatArray uv <= seg.uv_coords;

         int colIdx = 0;
         int uvIdx = 0;

         loop(2*3)
         {
            appendTrackColor32(vtxCols[colIdx++]);
            track_vertexarray.add(verts[vtxIdx++]);
            track_vertexarray.add(verts[vtxIdx++]);
            track_vertexarray.add(verts[vtxIdx++]);
            track_uvcoordarray.add(uv[uvIdx++]);
            track_uvcoordarray.add(uv[uvIdx++]);
         }

         loop(2*3)
         {
            appendBorderRightColor32(vtxCols[colIdx++]);
            border_vertexarray_r.add(verts[vtxIdx++]);
            border_vertexarray_r.add(verts[vtxIdx++]);
            border_vertexarray_r.add(verts[vtxIdx++]);
            border_uvcoordarray_r.add(uv[uvIdx++]);
            border_uvcoordarray_r.add(uv[uvIdx++]);
         }

         loop(2*3)
         {
            appendBorderLeftColor32(vtxCols[colIdx++]);
            border_vertexarray_l.add(verts[vtxIdx++]);
            border_vertexarray_l.add(verts[vtxIdx++]);
            border_vertexarray_l.add(verts[vtxIdx++]);
            border_uvcoordarray_l.add(uv[uvIdx++]);
            border_uvcoordarray_l.add(uv[uvIdx++]);
         }

      }

      int oldNumTriangles = (
         (track_vertexarray.numElements + border_vertexarray_l.numElements + border_vertexarray_r.numElements)
         / 9
                             );
      trace "[dbg] Track::createTrackVertexArray: extruded track has "+
         oldNumTriangles + " triangles and "+
         ((track_vertexarray.numElements + border_vertexarray_l.numElements + border_vertexarray_r.numElements)/3)+" vertices.";

      if(RacerConfiguration.b_tri_optimizer)
      {
         trace "[dbg] Track::createTrackVertexArray: Running optimizer..";
         optimizeVertexArrays();

         int newNumTriangles = ((track_vertexarray.numElements + border_vertexarray_l.numElements + border_vertexarray_r.numElements)/9);
         trace "[dbg] Track::createTrackVertexArray: optimized track has "+
            newNumTriangles + " triangles and "+
            ((track_vertexarray.numElements + border_vertexarray_l.numElements + border_vertexarray_r.numElements)/3)+" vertices. discarded "+(oldNumTriangles-newNumTriangles)+" triangles ("+
            ((1-(float(newNumTriangles)/oldNumTriangles))*100)+"%).";
      }



      if(RacerConfiguration.b_use_vbo)
      {
         zglLoadExtensions();

         // Create "track" buffer object
         zglDeleteBuffer(bo_track);
         bo_track = zglGenBuffer();
         glBindBuffer(GL_ARRAY_BUFFER, bo_track);
         zglBufferData(GL_ARRAY_BUFFER, 
                       track_vertexarray.numElements*4 + track_uvcoordarray.numElements*4 + track_colorarray.numElements*4,
                       null, GL_STATIC_DRAW);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          0, 
                          track_vertexarray.numElements*4, 
                          track_vertexarray);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          track_vertexarray.numElements*4, 
                          track_uvcoordarray.numElements*4, 
                          track_uvcoordarray);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          track_vertexarray.numElements*4 + track_uvcoordarray.numElements*4, 
                          track_colorarray.numElements*4,
                          track_colorarray);
         glBindBuffer(GL_ARRAY_BUFFER, 0);


         // Create "border_l" buffer object
         zglDeleteBuffer(bo_border_l);
         bo_border_l = zglGenBuffer();
         glBindBuffer(GL_ARRAY_BUFFER, bo_border_l);
         zglBufferData(GL_ARRAY_BUFFER, 
                       border_vertexarray_l.numElements*4 + border_uvcoordarray_l.numElements*4 + border_colorarray_l.numElements*4,
                       null, GL_STATIC_DRAW);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          0, 
                          border_vertexarray_l.numElements*4, 
                          border_vertexarray_l);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          border_vertexarray_l.numElements*4, 
                          border_uvcoordarray_l.numElements*4, 
                          border_uvcoordarray_l);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          border_vertexarray_l.numElements*4 + border_uvcoordarray_l.numElements*4, 
                          border_colorarray_l.numElements*4,
                          border_colorarray_l);
         glBindBuffer(GL_ARRAY_BUFFER, 0);


         // Create "border_r" buffer object
         zglDeleteBuffer(bo_border_r);
         bo_border_r = zglGenBuffer();
         glBindBuffer(GL_ARRAY_BUFFER, bo_border_r);
         zglBufferData(GL_ARRAY_BUFFER, 
                       border_vertexarray_r.numElements*4 + border_uvcoordarray_r.numElements*4 + border_colorarray_r.numElements*4,
                       null, GL_STATIC_DRAW);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          0, 
                          border_vertexarray_r.numElements*4, 
                          border_vertexarray_r);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          border_vertexarray_r.numElements*4, 
                          border_uvcoordarray_r.numElements*4, 
                          border_uvcoordarray_r);
         zglBufferSubData(GL_ARRAY_BUFFER, 
                          border_vertexarray_r.numElements*4 + border_uvcoordarray_r.numElements*4, 
                          border_colorarray_r.numElements*4,
                          border_colorarray_r);
         glBindBuffer(GL_ARRAY_BUFFER, 0);
      }
      else
      {
         bo_track    = -1;
         bo_border_l = -1;
         bo_border_r = -1;
      }
   }

   public method drawFloorGrid() {
      float cz = -SIZE * 0.5;
      float az = SIZE / FLOOR_GRIDSIZE;
      zglColorARGB(#ff003300);
      glLineWidth(1.0f);
      glBegin(GL_LINES);
      compile loop(FLOOR_GRIDSIZE)
      {
         glVertex3f(-SIZE*0.5, 0, cz);
         glVertex3f( SIZE*0.5, 0, cz);
         cz += az;
      }
      glEnd();

      zglColorARGB(#ff006600);
      glBegin(GL_LINES);
      float cx = -SIZE * 0.5; 
      float ax = SIZE / FLOOR_GRIDSIZE;
      compile loop(FLOOR_GRIDSIZE)
      {
         glVertex3f(cx, 0, -SIZE*0.5);
         glVertex3f(cx, 0,  SIZE*0.5);
         cx += ax;
      }
      glEnd();
   }

   public method draw(float dt) {

      if(RacerConfiguration.b_fog && !RacerConfiguration.b_edit)
      {
         zglFogMode(GL_LINEAR);
         zglFogDensity(1);
         zglFogStart(7.4);
         zglFogEnd(14.0);
         zglFogColor4f(fog_r,fog_g,fog_b,1);
         //zglFogColor4f(1,0,0,1);
         glEnable(GL_FOG);
      }

      if(RacerConfiguration.i_draw_mode >= RacerConfiguration.DRAWMODE_FLAT)
      {
         if(RacerConfiguration.b_draw_grid)
         {
            drawFloorGrid();
         }
      }
      
      // //drawLines();
      // //drawPointNormals();
      // //drawExtrudedMesh2();
      // //drawTrackSegmentsSingle();
      if(!RacerConfiguration.b_path_edit)
      {
         drawTrackSegmentsAll(dt);
      }

      TrackEntity te;
      foreach te in track_entities {
         if(!RacerConfiguration.b_edit)
         {
            if(te instanceof TrackCheckpointEntity)
            {
               if(@(next_checkpoint) == @(te))
               {
                  te.drawDynamic(dt);
               }
            }
            else
            {
               te.drawDynamic(dt);
            }
         }
         else
         {
            te.drawDynamic(dt);
         }
      }

      if(RacerConfiguration.b_fog)
      {
         glDisable(GL_FOG);
      }
   }

   public method drawTrackSegmentsAll(float _dt)  {//compile
      if(!RacerConfiguration.b_use_vbo)
      {
         if(RacerConfiguration.DRAWMODE_TEX == RacerConfiguration.i_draw_mode)
         {
            // // calcBorderUV(_dt);
         }
      }

      if(RacerConfiguration.i_draw_mode)
      {
         // The regular draw method
         glEnableClientState(GL_VERTEX_ARRAY);
         if(RacerConfiguration.i_draw_mode == RacerConfiguration.DRAWMODE_FLAT)
         {
            glDisableClientState(GL_TEXTURE_COORD_ARRAY);
            glEnableClientState(GL_COLOR_ARRAY);

            if(-1 != bo_track)
            {
               glBindBuffer(GL_ARRAY_BUFFER, bo_track);
               zglVertexOffset(3, GL_FLOAT, 0, 0);
               zglColorOffset(4, GL_FLOAT, 0, track_vertexarray.numElements*4 + track_uvcoordarray.numElements*4);
            }
            else
            {
               zglColorPointer4f(track_colorarray);
               zglVertexPointer(track_vertexarray);
            }
            glDrawArrays((RacerConfiguration.i_draw_mode==1) ? GL_POINTS : GL_TRIANGLES, 0, track_vertexarray.numElements/3);

            if(-1 != bo_border_l)
            {
               glBindBuffer(GL_ARRAY_BUFFER, bo_border_l);
               zglVertexOffset(3, GL_FLOAT, 0, 0);
               zglColorOffset(4, GL_FLOAT, 0, border_vertexarray_l.numElements*4 + border_uvcoordarray_l.numElements*4);
            }
            else
            {
               zglColorPointer4f(border_colorarray_l);
               zglVertexPointer(border_vertexarray_l);
            }
            glDrawArrays((RacerConfiguration.i_draw_mode==1) ? GL_POINTS : GL_TRIANGLES, 0, border_vertexarray_l.numElements/3);


            if(-1 != bo_border_r)
            {
               glBindBuffer(GL_ARRAY_BUFFER, bo_border_r);
               zglVertexOffset(3, GL_FLOAT, 0, 0);
               zglColorOffset(4, GL_FLOAT, 0, border_vertexarray_r.numElements*4 + border_uvcoordarray_r.numElements*4);
            }
            else
            {
               zglColorPointer4f(border_colorarray_r);
               zglVertexPointer(border_vertexarray_r);
            }
            glDrawArrays((RacerConfiguration.i_draw_mode==1) ? GL_POINTS : GL_TRIANGLES, 0, border_vertexarray_r.numElements/3);
         }
         else
         {
            zglColorARGB(#ffffffff); // (note) tkopengl GLES port does not support GL_REPLACE (only GL_MODULATE)
            glDisableClientState(GL_COLOR_ARRAY);
            glEnableClientState(GL_TEXTURE_COORD_ARRAY);
            glEnable(GL_TEXTURE_2D);
            if(RacerConfiguration.b_texture_perspective_correction)
            {
               glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
            }
            else
            {
               glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
            }

            tex_track_pattern.bind();

            if(-1 != bo_track)
            {
               glBindBuffer(GL_ARRAY_BUFFER, bo_track);
               zglVertexOffset(3, GL_FLOAT, 0, 0);
               zglTexCoordOffset(2, GL_FLOAT, 0, track_vertexarray.numElements*4);
            }
            else
            {
               zglVertexPointer(track_vertexarray);
               zglTexCoordPointer2f(track_uvcoordarray);
            }

            glDrawArrays((RacerConfiguration.i_draw_mode==1) ? GL_POINTS : GL_TRIANGLES, 0, track_vertexarray.numElements/3);

            tex_border_pattern.bind();

            if(-1 != bo_border_l)
            {
               glBindBuffer(GL_ARRAY_BUFFER, bo_border_l);
               zglVertexOffset(3, GL_FLOAT, 0, 0);
               zglTexCoordOffset(2, GL_FLOAT, 0, border_vertexarray_l.numElements*4);
            }
            else
            {
               zglVertexPointer(border_vertexarray_l);
               // // zglTexCoordPointer2f(border_temp_uvcoordarray);
               zglTexCoordPointer2f(border_uvcoordarray_l);
            }
            glDrawArrays((RacerConfiguration.i_draw_mode==1) ? GL_POINTS : GL_TRIANGLES, 0, border_vertexarray_l.numElements/3);


            if(-1 != bo_border_r)
            {
               glBindBuffer(GL_ARRAY_BUFFER, bo_border_r);
               zglVertexOffset(3, GL_FLOAT, 0, 0);
               zglTexCoordOffset(2, GL_FLOAT, 0, border_vertexarray_r.numElements*4);
            }
            else
            {
               zglVertexPointer(border_vertexarray_r);
               // // zglTexCoordPointer2f(border_temp_uvcoordarray);
               zglTexCoordPointer2f(border_uvcoordarray_r);
            }
            glDrawArrays((RacerConfiguration.i_draw_mode==1) ? GL_POINTS : GL_TRIANGLES, 0, border_vertexarray_r.numElements/3);
         }

         glDisableClientState(GL_TEXTURE_COORD_ARRAY);
         glDisableClientState(GL_COLOR_ARRAY);
         glDisableClientState(GL_VERTEX_ARRAY);
         glDisable(GL_TEXTURE_2D);
         glBindBuffer(GL_ARRAY_BUFFER, 0);
      }



      // Draw face normals
      if(RacerConfiguration.b_draw_facenormals)
      {
         int idx = 0;
         loop(track_segments.numElements) {
            TrackSegment seg <= track_segments[idx++];
            int faceIdx = 0;
            zglColorARGB(#ffff0f70);
            glLineWidth(1);
            glBegin(GL_LINES);
            loop(6)
            {
               glVertex3f(seg.orig_vertices[faceIdx*3*3+0],
                          seg.orig_vertices[faceIdx*3*3+1],
                          seg.orig_vertices[faceIdx*3*3+2]
                          );
               glVertex3f(seg.orig_vertices[faceIdx*3*3+0] + 3*seg.face_normals[faceIdx*3+0], 
                          seg.orig_vertices[faceIdx*3*3+1] + 3*seg.face_normals[faceIdx*3+1], 
                          seg.orig_vertices[faceIdx*3*3+2] + 3*seg.face_normals[faceIdx*3+2]
                          );
               faceIdx += 1;
            }
            glEnd();
         }
      }
   }


   static int totalNumSegTested;
   public method checkPlayerCollision(float dt, PlayerSphere coll) {

      int gridx = ((coll.x-track_bb_min.x) / (track_bb_max.x - track_bb_min.x)) * GRIDSIZE;
      int gridz = ((coll.z-track_bb_min.z) / (track_bb_max.z - track_bb_min.z)) * GRIDSIZE;

      totalNumSegTested = 0;
      total_num_collisions = 0;

      coll_vec_sum_x = 0;
      coll_vec_sum_y = 0;
      coll_vec_sum_z = 0;

      coll_pos_sum_x = 0;
      coll_pos_sum_y = 0;
      coll_pos_sum_z = 0;

      coll.b_last_tick_collision = false;

      if!(checkPlayerCollisionGrid(dt, gridx, gridz, coll))
      {
      }
      else
      {
         coll.vecx += coll_vec_sum_x * dt;
         coll.vecy += coll_vec_sum_y * dt;
         coll.vecz += coll_vec_sum_z * dt;
      }
      
      if(total_num_collisions)
      {
         //trace "xxx total_num_collisions = "+ total_num_collisions;
         //stdout total_num_collisions+" ";
      }
      else
      {
         //stdout ".";
      }

      ////trace  "totalNumSegTested="+totalNumSegTested;


      checkCheckpointCollision(dt, coll);
   }

   protected method checkCheckpointCollision(float dt, PlayerSphere coll) {
      // Checkpoint collision
      if(next_checkpoint != null)
      {
         Vector4f chkPos = next_checkpoint.center_pos;
         Vector4f shPos; shPos.init(coll.x, coll.y, coll.z, 1);
         chkPos.sub(shPos);
         if(chkPos.abs < (1.23*TrackCheckpointEntity.RADIUS))
         {
            TrackCheckpointEntity cpe <= next_checkpoint;
            if(cpe.b_goal)
            {
               trace "[...] *** GOAL *** ";
               next_checkpoint <= null;
               OSD.ShowScreen(scr_map_finish);
            }
            else
            {
               int idx = sorted_checkpoints.indexOfPointer(next_checkpoint, 0);
               if(idx == (sorted_checkpoints.numElements - 1))
               {
                  String lapTime; 
                  lapTime = "[...] lap time = ";
                  RacerConfiguration.AppendTimeString(lapTime, RacerConfiguration.race_millisec);
                  trace lapTime;

                  // Loop checkpoints
                  if(RacerConfiguration.race_millisec < RacerConfiguration.race_millisec_hiscore)
                  {
                     RacerConfiguration.race_millisec_hiscore = RacerConfiguration.race_millisec;
                     trace "[...]    --->  new LAP record  <--- ";
                     checkMedalScore();
                  }
                  else
                  {
                     trace "[dbg] ### NEXT LAP ###";
                  }
                  RacerConfiguration.race_millisec = 0;
                  next_checkpoint <= sorted_checkpoints[0];
               }
               else
               {
                  trace "[dbg] next checkpoint";
                  next_checkpoint <= sorted_checkpoints[idx + 1];
               }
            }
         }
      }
   }

   public method replayGetCurrentCheckpointId() : int {
      int idx = sorted_checkpoints.indexOfPointer(next_checkpoint, 0);
      return idx;
   }

   public method replaySelectCheckpointById(int _idx) {
      next_checkpoint <= sorted_checkpoints.get(_idx);
      //trace "[dbg] Track::replaySelectCheckpoint: idx="+_idx;
   }

   static method Reflect(Vector3f vNorm, vIn, vReflect) {
      vNorm.unit();
      float l = vIn.abs;
      Vector3f i; vIn.unit() => i;
      float f2 = i.dot(vNorm);
      Vector3f t;
      vNorm.mulf(f2) => t;
      vReflect = t;
      vReflect.add(t);
      vReflect.sub(i);
      vReflect.mulf(-l);
   }

   protected method checkPlayerCollisionGrid(float dt, int gridx, gridy, PlayerSphere coll) : boolean {

      if!(0 < gridx < GRIDSIZE)
         return false;

      if!(0 < gridy < GRIDSIZE)
         return false;

      List segList <= segment_grid[gridx + gridy * GRIDSIZE];
      if(null == segList)
      {
         return false;
      }
      ListNode ln <= segList.head;

      boolean bRet = false;

      TrackSegment lastCollSeg <= last_coll_seg;
      
      ////trace "[dbg] player gridpos=("+gridx+";"+gridy+")";

      int numSeg = segList.size;
//       trace "xxx numSeg="+numSeg;
      if(lastCollSeg != null)
      {
         numSeg++;
      }

      loop(numSeg) {
         TrackSegment seg;
         if(lastCollSeg != null)
         {
            seg <= lastCollSeg;
         }
         else
         {
            seg <= ln.objectValue;
         }
         FloatArray segVerts <= seg.vertices;
         FloatArray segNorms <= seg.face_normals;
         FloatArray segEdgeNorms <= seg.edge_normals;

         FloatArray collVerts <= seg.orig_vertices; // seg.vertices;

         totalNumSegTested++;

         float tx, ty, tz;
         float nx, ny, nz;

         // Loop faces and calc point<->plane distance
         int faceIdx = 0;

         compile loop(6/*numFaces*/)
         {
            nx = segNorms[faceIdx*3+0];
            ny = segNorms[faceIdx*3+1];
            nz = segNorms[faceIdx*3+2];
            tx = coll.x - segVerts[faceIdx*3*3+0];
            ty = coll.y - segVerts[faceIdx*3*3+1];
            tz = coll.z - segVerts[faceIdx*3*3+2];
            float d = ( tx * nx + ty * ny + tz * nz );

            //if(-(Player.RADIUS*1.0) < d < (Player.RADIUS*1.0))  // Note: triple arg expr is not jit accelerated..!
            if(-(Player.RADIUS) < d) && (d < (Player.RADIUS))
            {
               // test point in triangle by comparing sign of distances to edge normals
               float td;
               int vIdx = faceIdx*3*3;
               float dx, dy, dz;


               if(RacerConfiguration.b_draw_colltris)
               {
                  zglColorARGB(#ff0000ff);
                  glBegin(GL_TRIANGLES);
                  glVertex3f(
                     collVerts[vIdx+3*0+0] + segNorms[faceIdx*3+0]*0.5*0.01, 
                     collVerts[vIdx+3*0+1] + segNorms[faceIdx*3+1]*0.5*0.01, 
                     collVerts[vIdx+3*0+2] + segNorms[faceIdx*3+2]*0.5*0.01
                     );
                  glVertex3f(
                     collVerts[vIdx+3*1+0] + segNorms[faceIdx*3+0]*0.5*0.01, 
                     collVerts[vIdx+3*1+1] + segNorms[faceIdx*3+1]*0.5*0.01, 
                     collVerts[vIdx+3*1+2] + segNorms[faceIdx*3+2]*0.5*0.01
                     );
                  glVertex3f(
                     collVerts[vIdx+3*2+0] + segNorms[faceIdx*3+0]*0.5*0.01,
                     collVerts[vIdx+3*2+1] + segNorms[faceIdx*3+1]*0.5*0.01, 
                     collVerts[vIdx+3*2+2] + segNorms[faceIdx*3+2]*0.5*0.01
                     );
                  glEnd();
               }

               if(RacerConfiguration.b_draw_edgenormals)
               {
                  // draw edge normals
                  zglColorARGB(#ffffffff);
                  glBegin(GL_LINES);
                  // edge AB
                  glVertex3f( 
                     (collVerts[vIdx+3*0+0] + collVerts[vIdx+3*1+0]) * 0.5 + segNorms[faceIdx*3+0]*1.3,
                     (collVerts[vIdx+3*0+1] + collVerts[vIdx+3*1+1]) * 0.5 + segNorms[faceIdx*3+1]*1.3,
                     (collVerts[vIdx+3*0+2] + collVerts[vIdx+3*1+2]) * 0.5 + segNorms[faceIdx*3+2]*1.3
                     );
                  glVertex3f( 
                     (collVerts[vIdx+3*0+0] + collVerts[vIdx+3*1+0]) * 0.5 + segNorms[faceIdx*3+0]*1.3 + segEdgeNorms[faceIdx*3*3+3*0+0]*2,
                     (collVerts[vIdx+3*0+1] + collVerts[vIdx+3*1+1]) * 0.5 + segNorms[faceIdx*3+1]*1.3 + segEdgeNorms[faceIdx*3*3+3*0+1]*2,
                     (collVerts[vIdx+3*0+2] + collVerts[vIdx+3*1+2]) * 0.5 + segNorms[faceIdx*3+2]*1.3 + segEdgeNorms[faceIdx*3*3+3*0+2]*2
                     );
                  // edge BC
                  glVertex3f( 
                     (collVerts[vIdx+3*2+0] + collVerts[vIdx+3*1+0]) * 0.5 + segNorms[faceIdx*3+0]*1.3,
                     (collVerts[vIdx+3*2+1] + collVerts[vIdx+3*1+1]) * 0.5 + segNorms[faceIdx*3+1]*1.3,
                     (collVerts[vIdx+3*2+2] + collVerts[vIdx+3*1+2]) * 0.5 + segNorms[faceIdx*3+2]*1.3
                     );
                  glVertex3f( 
                     (collVerts[vIdx+3*2+0] + collVerts[vIdx+3*1+0]) * 0.5 + segNorms[faceIdx*3+0]*1.3 + segEdgeNorms[faceIdx*3*3+3*1+0]*2,
                     (collVerts[vIdx+3*2+1] + collVerts[vIdx+3*1+1]) * 0.5 + segNorms[faceIdx*3+1]*1.3 + segEdgeNorms[faceIdx*3*3+3*1+1]*2,
                     (collVerts[vIdx+3*2+2] + collVerts[vIdx+3*1+2]) * 0.5 + segNorms[faceIdx*3+2]*1.3 + segEdgeNorms[faceIdx*3*3+3*1+2]*2
                     );
                  // edge CA
                  glVertex3f( 
                     (collVerts[vIdx+3*2+0] + collVerts[vIdx+3*0+0]) * 0.5 + segNorms[faceIdx*3+0]*1.3,
                     (collVerts[vIdx+3*2+1] + collVerts[vIdx+3*0+1]) * 0.5 + segNorms[faceIdx*3+1]*1.3,
                     (collVerts[vIdx+3*2+2] + collVerts[vIdx+3*0+2]) * 0.5 + segNorms[faceIdx*3+2]*1.3
                     );
                  glVertex3f( 
                     (collVerts[vIdx+3*2+0] + collVerts[vIdx+3*0+0]) * 0.5 + segNorms[faceIdx*3+0]*1.3 + segEdgeNorms[faceIdx*3*3+3*2+0]*2,
                     (collVerts[vIdx+3*2+1] + collVerts[vIdx+3*0+1]) * 0.5 + segNorms[faceIdx*3+1]*1.3 + segEdgeNorms[faceIdx*3*3+3*2+1]*2,
                     (collVerts[vIdx+3*2+2] + collVerts[vIdx+3*0+2]) * 0.5 + segNorms[faceIdx*3+2]*1.3 + segEdgeNorms[faceIdx*3*3+3*2+2]*2
                     );
                  glEnd();
               }

                  
               // float p0x = segVerts[faceIdx*3*3+3*0+0];
               // float p0y = segVerts[faceIdx*3*3+3*0+1];
               // float p0z = segVerts[faceIdx*3*3+3*0+2];

               dx = (coll.x - segVerts[vIdx+0]);
               dy = (coll.y - segVerts[vIdx+1]);
               dz = (coll.z - segVerts[vIdx+2]);
               nx = segEdgeNorms[faceIdx*3*3+3*0+0];
               ny = segEdgeNorms[faceIdx*3*3+3*0+1];
               nz = segEdgeNorms[faceIdx*3*3+3*0+2];
               td = ( (dx * nx) + (dy * ny) + (dz * nz) );/// / sqrt(nx*nx + ny*ny + nz*nz);

               if(td > 0)
               {
                  dx = (coll.x - segVerts[vIdx+3*1+0]);
                  dy = (coll.y - segVerts[vIdx+3*1+1]);
                  dz = (coll.z - segVerts[vIdx+3*1+2]);
                  nx = segEdgeNorms[faceIdx*3*3+3*1+0];
                  ny = segEdgeNorms[faceIdx*3*3+3*1+1];
                  nz = segEdgeNorms[faceIdx*3*3+3*1+2];
                  td = ( (dx * nx) + (dy * ny) + (dz * nz) );//// / sqrt(nx*nx + ny*ny + nz*nz);

                  if(td > 0)
                  {
                     dx = (coll.x - segVerts[vIdx+3*2+0]);
                     dy = (coll.y - segVerts[vIdx+3*2+1]);
                     dz = (coll.z - segVerts[vIdx+3*2+2]);
                     nx = segEdgeNorms[faceIdx*3*3+3*2+0];
                     ny = segEdgeNorms[faceIdx*3*3+3*2+1];
                     nz = segEdgeNorms[faceIdx*3*3+3*2+2];
                     td = ( (dx * nx) + (dy * ny) + (dz * nz) );//// / sqrt(nx*nx + ny*ny + nz*nz);
                     
                     if(td > 0)
                     {
//                trace "----- d="+d;
//                trace "     |t|="+sqrt(tx*tx +ty*ty +tz*tz);
//                trace "      t =("+tx+";"+ty+";"+tz+")";
//                trace "      n =("+nx+";"+ny+";"+nz+")";

                        //trace "xxx checkPlayerCollision: segIdx="+segIdx+" faceIdx="+faceIdx+" d="+d;
//                         trace "xxx checkPlayerCollision: faceIdx="+faceIdx+" d="+d;
//                         trace "v=("+(segVerts[faceIdx*3*3+0])+";"+(segVerts[faceIdx*3*3+1])+";"+(segVerts[faceIdx*3*3+2])+")";
//                         trace "p=("+coll.x+";"+coll.y+";"+coll.z+")";
//                         trace "t=("+tx+";"+ty+";"+tz+")";
//                         trace "n=("+(segNorms[faceIdx*3+0])+";"+(segNorms[faceIdx*3+1])+";"+(segNorms[faceIdx*3+2])+")";

                        // push player away from surface
                        float pf = 1.0 - (d / (Player.RADIUS));
                        if(pf > 10)
                           trace "xxx pf="+pf;
                        //float pf = (d / (Player.RADIUS));
                        //pf = pf*pf;
                        Vector3f vIn; 
                        vIn.init(coll.vecx, coll.vecy, coll.vecz);
                        Vector3f vNorm;

                        if(RacerConfiguration.b_draw_coll)
                        {
                           zglColorARGB(#ffffff00);
                           glLineWidth(2.0);
                           glBegin(GL_LINES);
                           glVertex3f(coll.x, coll.y, coll.z);
                           glVertex3f(coll.x + vNorm.x*8, coll.y+vNorm.y*8, coll.z+vNorm.z*8);
                           glEnd();

                           zglColorARGB(#ffff00ff);
                           glLineWidth(2.0);
                           glBegin(GL_LINES);
                           glVertex3f(coll.x, coll.y, coll.z);
                           glVertex3f(coll.x + coll.vecx*-8, coll.y+coll.vecy*-8, coll.z+coll.vecz*-8);
                           glEnd();
                        }

                        
                        //float refDt = mathPowerf(0.85, dt);
                        //pf = pf*pf; // xxx re-enabled 07Dec2008
                        //pf = 1;//xxx
                        
                        // bounciness:
                        ////trace "spd="+player.speed+" pf="+pf;
                        float plySpeed = player.speed;
                        if(plySpeed > 1.0) plySpeed = 1.0;
                        //else if(plySpeed < 0.1) plySpeed = 0.1;
                        /////else if(plySpeed > 0.25) plySpeed = 0.25; // xxx
                        //float bounceDt = 0.107*115 * (0.3*pf*pf) * plySpeed * 1.23*2;
                        float bounceDt = (0.107*115*0.3 * (1.23 *0.3 *0.01)) * (pf*pf) * plySpeed;
                        coll.vecx += segNorms[faceIdx*3+0] * bounceDt;
                        coll.vecy += segNorms[faceIdx*3+1] * bounceDt;
                        coll.vecz += segNorms[faceIdx*3+2] * bounceDt;
                        
                        float vdotn = 
                           (coll.vecx) * segNorms[faceIdx*3+0] + 
                           (coll.vecy) * segNorms[faceIdx*3+1] + 
                           (coll.vecz) * segNorms[faceIdx*3+2];
                        vdotn *= pf;
                        float newVecx = coll.vecx - segNorms[faceIdx*3+0] * vdotn;
                        float newVecy = coll.vecy - segNorms[faceIdx*3+1] * vdotn;
                        float newVecz = coll.vecz - segNorms[faceIdx*3+2] * vdotn;
//                            trace "2 coll.vec=("+newVecx+";"+newVecy+";"+newVecz+")";
//                            trace "vdotn="+vdotn;
                        
                        if(RacerConfiguration.b_draw_coll)
                        {
                           zglColorARGB(#ff00ff00);
                           glLineWidth(2.0);
                           glBegin(GL_LINES);
                           glVertex3f(coll.x, coll.y, coll.z);
                           glVertex3f(coll.x + newVecx*(8*0.01), coll.y+newVecy*(8*0.01), coll.z+newVecz*(8*0.01));
                           glEnd();
                        }
                        
                        if(!RacerConfiguration.b_halt_collision)
                        {
                           float newVecDt = mathPowerf(0.79, dt); // ORIGINAL
                           ////float newVecDt = 0.97096457 * dt;
                           // coll.vecx = coll.vecx * (1-newVecDt) + newVecx * (newVecDt);
                           // coll.vecy = coll.vecy * (1-newVecDt) + newVecy * (newVecDt);
                           // coll.vecz = coll.vecz * (1-newVecDt) + newVecz * (newVecDt);
                           coll.vecx = coll.vecx + (newVecx - coll.vecx) * newVecDt;
                           coll.vecy = coll.vecy + (newVecy - coll.vecy) * newVecDt;
                           coll.vecz = coll.vecz + (newVecz - coll.vecz) * newVecDt;
                        }
                        
                        
                        
                        
//                         float pushx = segNorms[faceIdx*3+0] * 0.03 * 315 * pf;
//                         float pushy = segNorms[faceIdx*3+1] * 0.03 * 315 * pf;
//                         float pushz = segNorms[faceIdx*3+2] * 0.03 * 315 * pf;
//                         if(!player.b_collision)
//                         {
//                            // First collision
//                            coll_vec_sum_x = pushx;
//                            coll_vec_sum_y = pushy;
//                            coll_vec_sum_z = pushz;
//                         }
//                         else
//                         {
//                            // Blend vectors
//                            coll_vec_sum_x = (coll_vec_sum_x + pushx) * 0.5;
//                            coll_vec_sum_y = (coll_vec_sum_y + pushy) * 0.5;
//                            coll_vec_sum_z = (coll_vec_sum_z + pushz) * 0.5;
//                         }

                        // kill gravity
                        coll.spring_vecy += coll.vecy * 0.02 * dt * coll.time_since_collision;
                        //trace "time_since_collision="+coll.time_since_collision;
                        //trace "coll.spring_vecy="+coll.spring_vecy;
                        if(coll.spring_vecy < -Player.MAXSPRINGGRAVITY)
                           coll.spring_vecy = -Player.MAXSPRINGGRAVITY;
                        coll.accy = 0;
                        //float accyDt = mathPowerf(0.94998, dt);
                        //coll.accy *= accyDt;
                        
                        if(!RacerConfiguration.b_halt_collision)
                        {
                           float newCDY = segNorms[faceIdx*3+1] * pf * dt;
                           pf *= dt * 0.01;
                           coll.x += segNorms[faceIdx*3+0] * pf;
                           if(newCDY > 0)
                           {
                              coll.y += segNorms[faceIdx*3+1] * pf;
                           }
                           coll.z += segNorms[faceIdx*3+2] * pf;

//                            float posx = segNorms[faceIdx*3+0] * 0.6 * (Player.RADIUS*1.0 - d);
//                            float posy = segNorms[faceIdx*3+1] * 0.6 * (Player.RADIUS*1.0 - d);
//                            float posz = segNorms[faceIdx*3+2] * 0.6 * (Player.RADIUS*1.0 - d);
//                            if(!player.b_collision)
//                            {
//                               coll_pos_sum_x = posx;
//                               coll_pos_sum_y = posy;
//                               coll_pos_sum_z = posz;
//                            }
//                            else
//                            {
//                               coll_pos_sum_x = (coll_pos_sum_x*0.75 + posx*0.25);
//                               coll_pos_sum_y = (coll_pos_sum_y*0.75 + posy*0.25);
//                               coll_pos_sum_z = (coll_pos_sum_z*0.75 + posz*0.25);
//                            }
                        }


                        if(RacerConfiguration.b_draw_coll)
                        {
                           zglColorARGB(#ffaa4444);
                           glBegin(GL_TRIANGLES);
                           glVertex3f(
                              collVerts[vIdx+3*0+0] + segNorms[faceIdx*3+0]*0.01, 
                              collVerts[vIdx+3*0+1] + segNorms[faceIdx*3+1]*0.01, 
                              collVerts[vIdx+3*0+2] + segNorms[faceIdx*3+2]*0.01
                              );
                           glVertex3f(
                              collVerts[vIdx+3*1+0] + segNorms[faceIdx*3+0]*0.01, 
                              collVerts[vIdx+3*1+1] + segNorms[faceIdx*3+1]*0.01, 
                              collVerts[vIdx+3*1+2] + segNorms[faceIdx*3+2]*0.01
                              );
                           glVertex3f(
                              collVerts[vIdx+3*2+0] + segNorms[faceIdx*3+0]*0.01,
                              collVerts[vIdx+3*2+1] + segNorms[faceIdx*3+1]*0.01, 
                              collVerts[vIdx+3*2+2] + segNorms[faceIdx*3+2]*0.01
                              );
                           glEnd();
                        }
                        //return true;
                        player.b_collision = true;
                        bRet = true;
                        total_num_collisions++;
                        coll.time_since_collision = 0;
                        if(RacerConfiguration.b_debug_collision)
                        {
                           RacerConfiguration.b_halt_collision = 1;
                        }

                        last_coll_seg <= seg;
                        //coll.b_last_tick_collision = true;

                        //return true;
                     }
                  }
               }

            } // if d < 0.2

            faceIdx++;

         } // loop 6

         if(lastCollSeg != null)
         {
            lastCollSeg <= null;
         }
         else
         {
            ln <= ln.next;
         }
      } // loop seg

      return bRet;
   }

   public method calcFogColor(Texture tex, float _r, _g, _b) {
      // Used to calculate fog color for a given skybox texture
      int y = 0;
      float r = _r;
      float g = _g;
      float b = _b;
      compile loop(tex.sy)
      {
         int x = 0;
         loop(tex.sx)
         {
            int c32 = tex[x++ + y*tex.sx];
            float cr = ((c32>>16)&255)/255.0;
            float cg = ((c32>> 8)&255)/255.0;
            float cb = ((c32    )&255)/255.0;
            r = r * 0.5 + cr * 0.5;
            g = g * 0.5 + cg * 0.5;
            b = b * 0.5 + cb * 0.5;
         }
         y++;
      }
      trace "[dbg] CalcFogColor: rgb=("+r+";"+g+";"+b+")";
      fog_r = r;
      fog_g = g;
      fog_b = b;
   }

   public method checkMedalScore() {
      medal_himode = RacerConfiguration.HIMODE_NORMAL;

      if(RacerConfiguration.race_millisec < hiscore_author)
      {
         trace "[...]   ** you beat the author's hiscore ! **";
         medal_himode = RacerConfiguration.HIMODE_AUTHOR;
         if(RacerConfiguration.b_record)
         {
            RacerConfiguration.b_replay_fail = false;
         }
      }
      else if(RacerConfiguration.race_millisec < hiscore_gold)
      {
         trace "[...]   ** you won the GOLD medal ! **";
         medal_himode = RacerConfiguration.HIMODE_GOLD;
         if(RacerConfiguration.b_record)
         {
            RacerConfiguration.b_replay_fail = false;
         }
      }
      else if(RacerConfiguration.race_millisec < hiscore_silver)
      {
         trace "[...]   ** you won the SILVER medal ! **";
         medal_himode = RacerConfiguration.HIMODE_SILVER;
         if(RacerConfiguration.b_record)
         {
            RacerConfiguration.b_replay_fail = false;
         }
      }
      else if(RacerConfiguration.race_millisec < hiscore_bronze)
      {
         trace "[...]   ** you won the BRONZE medal ! **";
         medal_himode = RacerConfiguration.HIMODE_BRONZE;
         if(RacerConfiguration.b_record)
         {
            RacerConfiguration.b_replay_fail = false;
         }
      }

      switch(RacerConfiguration.hiscore_mode)
      {
         case RacerConfiguration.HIMODE_NORMAL:
            break;
         case RacerConfiguration.HIMODE_AUTHOR:
            medal_himode = RacerConfiguration.HIMODE_AUTHOR;
            hiscore_author = RacerConfiguration.race_millisec;
            break;
         case RacerConfiguration.HIMODE_GOLD:
            medal_himode = RacerConfiguration.HIMODE_GOLD;
            hiscore_gold = RacerConfiguration.race_millisec;
            break;
         case RacerConfiguration.HIMODE_SILVER:
            medal_himode = RacerConfiguration.HIMODE_SILVER;
            hiscore_silver = RacerConfiguration.race_millisec;
            break;
         case RacerConfiguration.HIMODE_BRONZE:
            medal_himode = RacerConfiguration.HIMODE_BRONZE;
            hiscore_bronze = RacerConfiguration.race_millisec;
            break;
      }

   }


   public method saveLocal(String _fileName) {
      File f;
      if(f.openLocal(_fileName, IOS_OUT))
      {
         // f.i32 = 0x900df06d; // v06   column-major track entity rotation
         f.i32 = 0x900df07d; // v07 row major track entity rotation

         f << player_start_pos;
         f << player_start_dir;

         f.f32 = hiscore_author;
         f.f32 = hiscore_gold;
         f.f32 = hiscore_silver;
         f.f32 = hiscore_bronze;

         f.i32 = track_entities.numElements;
         TrackEntity te;
         foreach te in track_entities {
            te.saveToStream(f);
         }

         f.close();
         trace "[...] track saved to \""+_fileName+"\".";
      }
      else
      {
         trace "[---] failed to save track to \""+_fileName+"\" (file open failed).";
      }
   }

   public method loadLocal(String _fileName) {
      File f;
      if(f.openLocal(_fileName, IOS_IN))
      {
         int ver = f.i32;
         if( (ver & 0xfffff00f) == 0x900df00d)
         {
            medal_himode = RacerConfiguration.HIMODE_NORMAL;

            ver = (ver & 0x00000ff0) >> 4;
            if(ver > 0)
            {
               player_start_pos << f;
               player_start_dir << f;
               trace "[dbg] Track::loadLocal: loaded player start pos="+player_start_pos+" dir="+player_start_dir;
               if(ver < 5)
               {
                  player_start_pos.mulf(1.0 / RacerConfiguration.PREV5_SCALE);
               }
               if(ver >= 6)
               {
                  hiscore_author = f.f32;
                  hiscore_gold   = f.f32;
                  hiscore_silver = f.f32;
                  hiscore_bronze = f.f32;
               }
               else
               {
                  hiscore_author = 0;
                  hiscore_gold   = (9*60+59) *1000;
                  hiscore_silver = (9*60+59) *1000;
                  hiscore_bronze = (9*60+59) *1000;
               }
            }
            int numEntities = f.i32;
            track_entities.free();
            loop(numEntities)
            {
               int entityType = f.i32; // See TrackEntity.TYPE_xxx
               if(TrackEntity.TYPE_POLYLINE == entityType)
               {
                  TrackPolyLineEntity ple <= new TrackPolyLineEntity;
                  ple.loadFromStream(f, ver);
                  track_entities.add(#(deref ple));
               }
               else if(TrackEntity.TYPE_CHECKPOINT == entityType)
               {
                  TrackCheckpointEntity cpe <= new TrackCheckpointEntity;
                  cpe.loadFromStream(f, ver);
                  track_entities.add(#(deref cpe));
               }
            }

            EnvEdit.SetEnvelope(null, null);
            PathEdit.SetEnvelope(null, null);
            updateTrack();

            trace "[...] track loaded from \""+_fileName+"\".";
         }
         else
         {
            trace "[---] failed to load track from \""+_fileName+"\" (wrong header).";
         }

         f.close();
      }
      else
      {
         trace "[---] failed to load track from \""+_fileName+"\" (file open failed).";
      }
   }

}


Track track;
