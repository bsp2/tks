// ----
// ---- file   : gmodsceneselect.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 09Jul2020
// ---- changed: 10Jul2020, 11Jul2020, 14Aug2020
// ----
// ----
// ----
module MGModSceneSelect;

use namespace ui;
use namespace gledit;


// <class.png>
class GModSceneSelect : GMod, GParamProvider {
   // only in "global" namespace
   // // define String SCENE_SELECT_ID = "scene_select";


   // <method_init.png>
   public virtual init() {
      GMod::init();

      addInput(GInput.IN_DEF, TYPE_FUNCTION);
   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "scene_select";
   }

   // // // <method_get.png>
   // // public virtual canRename() : boolean {
   // //    return false;
   // // }

   // // // <method_get.png>
   // // public virtual canDelete() : boolean {
   // //    return false;
   // // }

   // // // <method_get.png>
   // // public virtual canClone() : boolean {
   // //    return false;
   // // }

   // <method_get.png>
   public method isSceneConnected() : boolean {
      return isInputConnected(GInput.IN_DEF);
   }

  // <save.png>
   public virtual saveStateObject(local Stream ofs, local GConnectionWriter connectionWriter) {
      GObject::saveStateObject(ofs, connectionWriter);

      // Version
      ofs.i16 = 1;

      // Params
      GParamProvider::saveStateParamProvider(ofs, connectionWriter);
   }

   // <load.png>
   public method loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject

      // Version
      short ver = ifs.u16;

      if(1 <= ver <= 1)
      {
         if(GParamProvider::loadStateParamProvider(ifs))
         {
            // Succeeded
            return true;
         }
         else
         {
            trace "[---] GSceneSelect::loadStateObject: failed to load params, this="+#(this)+" path="+getObjectPath();
         }
      }
      else
      {
         trace "[---] GSceneSelect::loadStateObject: invalid version "+ver+", this="+#(this)+" path="+getObjectPath();
      }
      return false;
   }

   // // // <method.png>
   // // public virtual emit(local String       _outputId,
   // //                     local GModule      _module,
   // //                     local GProgram     _program,
   // //                     local String       _out,
   // //                     local String       _dstVar,
   // //                     local boolean      _bGLSL,
   // //                     local PointerArray _parents
   // //                     ) {
   // //    _parents.add(this);
   // //    // local GInput input <= getInputById(GInput.IN_DEF);
   // //    // input.emit(_module, _program, _out, _dstVar, _bGLSL, _parents);
   // //    _parents.remove(this);
   // // }

   // <method.png>
   public method emitCallDraw(GModule _module) {
      // Called by Project::updateScript()

      local PointerArray parents;
      parents.add(this);
      local String sDrawPre;

      local GInput input <= getInputById(GInput.IN_DEF);
      local String sVarDraw <= _module.allocTmpVarScript(sDrawPre, TYPE_FUNCTION, id+"_draw");
      input.emit(_module, null/*_program*/, sDrawPre, sVarDraw, false/*bGLSL*/, parents);
      sDrawPre.append("if(null != "+sVarDraw+") "+sVarDraw+".eval({"+current_project.cur_emit_fb_w+", "+current_project.cur_emit_fb_h+"});\n");

      _module.appendDrawPre(sDrawPre);
      parents.remove(this);
   }

}
