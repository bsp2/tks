// ----
// ---- file   : gmodtween.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 10Jul2020
// ---- changed: 08Aug2020, 09Aug2020, 12Aug2020, 13Aug2020, 14Aug2020
// ----
// ----
// ----
module MGModTween;

use namespace ui;
use namespace gledit;


// <class.png>
class GModTween : GMod, GParamProvider, GConnectionContainer {
   // interpolates between 2 out of "n" inputs

   // params:
   //   choice io_type
   //   choice input mode (inputs_01..inputs_16 or connections of input "input_conn")
   //   int    num_inputs
   //   int    initial_src
   //   int    initial_dst
   //   int    forced_src
   //   int    forced_dst
   //   bool   eval_all
   //   choice repeat

   // inputs:
   //   var   in
   //   int   src_idx
   //   int   dst_idx
   //   bool  reset
   //   bool  prev
   //   bool  next
   //   float speed
   //   float time  (0..1)
   //   float time_cont (0..numInput-1) (overrides src_idx/dst_idx/time/speed)
   //   var   input_01, .., input_16

   define int INPUT_MODE_INPUTS      = 0;
   define int INPUT_MODE_CONNECTIONS = 1;

   // (note) EASE* by Andrey Sitnik and Ivan Solovev <https://easings.net>
   define int INTERPOL_LINEAR           =  0;
   define int INTERPOL_SIN              =  1;
   define int INTERPOL_COS              =  2;
   define int INTERPOL_SMOOTHSTEP       =  3;
   define int INTERPOL_EASEINSINE       =  4;  // https://easings.net/#easeInSine
   define int INTERPOL_EASEOUTSINE      =  5;  // https://easings.net/#easeOutSine
   define int INTERPOL_EASEINOUTSINE    =  6;  // https://easings.net/#easeInOutSine
   define int INTERPOL_EASEINQUAD       =  7;  // https://easings.net/#easeInQuad
   define int INTERPOL_EASEOUTQUAD      =  8;  // https://easings.net/#easeOutQuad
   define int INTERPOL_EASEINOUTQUAD    =  9;  // https://easings.net/#easeInOutQuad
   define int INTERPOL_EASEINCUBIC      = 10;  // https://easings.net/#easeInCubic
   define int INTERPOL_EASEOUTCUBIC     = 11;  // https://easings.net/#easeOutCubic
   define int INTERPOL_EASEINOUTCUBIC   = 12;  // https://easings.net/#easeInOutCubic
   define int INTERPOL_EASEINQUART      = 13;  // https://easings.net/#easeInQuart
   define int INTERPOL_EASEOUTQUART     = 14;  // https://easings.net/#easeOutQuart
   define int INTERPOL_EASEINOUTQUART   = 15;  // https://easings.net/#easeInOutQuart
   define int INTERPOL_EASEINQUINT      = 16;  // https://easings.net/#easeInQuint
   define int INTERPOL_EASEOUTQUINT     = 17;  // https://easings.net/#easeOutQuint
   define int INTERPOL_EASEINOUTQUINT   = 18;  // https://easings.net/#easeInOutQuint
   define int INTERPOL_EASEINEXPO       = 19;  // https://easings.net/#easeInExpo
   define int INTERPOL_EASEOUTEXPO      = 20;  // https://easings.net/#easeOutExpo
   define int INTERPOL_EASEINOUTEXPO    = 21;  // https://easings.net/#easeInOutExpo
   define int INTERPOL_EASEINCIRC       = 22;  // https://easings.net/#easeInCirc
   define int INTERPOL_EASEOUTCIRC      = 23;  // https://easings.net/#easeOutCirc
   define int INTERPOL_EASEINOUTCIRC    = 24;  // https://easings.net/#easeInOutCirc
   define int INTERPOL_EASEINBACK       = 25;  // https://easings.net/#easeInBack
   define int INTERPOL_EASEOUTBACK      = 26;  // https://easings.net/#easeOutBack
   define int INTERPOL_EASEINOUTBACK    = 27;  // https://easings.net/#easeInOutBack
   define int INTERPOL_EASEINELASTIC    = 28;  // https://easings.net/#easeInElastic
   define int INTERPOL_EASEOUTELASTIC   = 29;  // https://easings.net/#easeOutElastic
   define int INTERPOL_EASEINOUTELASTIC = 30;  // https://easings.net/#easeInOutElastic
   define int INTERPOL_EASEINBOUNCE     = 31;  // https://easings.net/#easeInBounce
   define int INTERPOL_EASEOUTBOUNCE    = 32;  // https://easings.net/#easeOutBounce
   define int INTERPOL_EASEINOUTBOUNCE  = 33;  // https://easings.net/#easeInOutBounce



   static StringArray interpol_names = [
      /*  0 */ "Linear",
      /*  1 */ "Sin",
      /*  2 */ "Cos",
      /*  3 */ "Smoothstep",
      /*  4 */ "easeInSine",
      /*  5 */ "easeOutSine",
      /*  6 */ "easeInOutSine",
      /*  7 */ "easeInQuad",
      /*  8 */ "easeOutQuad",
      /*  9 */ "easeInOutQuad",
      /* 10 */ "easeInCubic",
      /* 11 */ "easeOutCubic",
      /* 12 */ "easeInOutCubic",
      /* 13 */ "easeInQuart",
      /* 14 */ "easeOutQuart",
      /* 15 */ "easeInOutQuart",
      /* 16 */ "easeInQuint",
      /* 17 */ "easeOutQuint",
      /* 18 */ "easeInOutQuint",
      /* 19 */ "easeInExpo",
      /* 20 */ "easeOutExpo",
      /* 21 */ "easeInOutExpo",
      /* 22 */ "easeInCirc",
      /* 23 */ "easeOutCirc",
      /* 24 */ "easeInOutCirc",
      /* 25 */ "easeInBack",
      /* 26 */ "easeOutBack",
      /* 27 */ "easeInOutBack",
      /* 28 */ "easeInElastic",
      /* 29 */ "easeOutElastic",
      /* 30 */ "easeInOutElastic",
      /* 31 */ "easeInBounce",
      /* 32 */ "easeOutBounce",
      /* 33 */ "easeInOutBounce",
                                        ];

   protected boolean b_init_done;
   protected String *s_var_src_idx;
   protected String *s_var_dst_idx;
   protected String *s_var_t;
   protected String *s_var_adv;


   // <method_init.png>
   public virtual init() {
      GMod::init();

      GParam *p;
      GParamFloat *pf;

      addParamChoiceIOType("io_type", "IO Type", TYPE_FLOAT);

      p <= addParamChoice("input_mode", "Input Mode", 1, ["Inputs", "Connections"]);
      p.setToolTipCaption("Input Mode");

      p <= addParamInt("num_inputs", "Num Inputs", 2, 2, 2,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1
                       );
      p.setToolTipCaption("Number of Inputs (for Input Mode \"Input\")");

      p <= addParamInt("initial_src", "Initial Src", 1, 1, 1,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1
                       );
      p.setToolTipCaption("Initial Source Input Nr\n\n (note) only has an effect when src_idx input is not connected");

      p <= addParamInt("initial_dst", "Initial Dst", 2, 1, 1,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1);
      p.setToolTipCaption("Initial Destination Input Nr\n\n (note) only has an effect when dst_idx input is not connected");

      p <= addParamInt("forced_src",  "Forced Src",  0, 0, 0,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1);
      p.setToolTipCaption("When >0, force source input #n\n\n (note) useful while editing / debugging");

      p <= addParamInt("forced_dst",  "Forced Dst",  0, 0, 0,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1);
      p.setToolTipCaption("When >0, force destination input #n\n\n (note) useful while editing / debugging");

      p <= addParamBool("auto_adv", "Auto Advance", true);
      p.setToolTipCaption("When checked, auto-advance to next src/dst when \'t\'t reaches 1.0");

      p <= addParamBool("eval_all", "Eval All", false);
      p.setToolTipCaption("When checked, always calculate all inputs\n\nWhen unchecked, calculate currently active source / dest only [default]");

      p <= addParamChoice("repeat", "Repeat", 1, ["Clamp", "Wrap"]);
      p.setToolTipCaption("Repeat Mode");

      p <= addParamChoice("interpol", "Interpolation", 0, interpol_names);

      p <= addParamFloat("def_speed", "Def.Speed", (1.0f / 60.0f), 0.0f, 0.0f, 1.0f, 1.0f, -1.0f);

      pf <= addParamFloat("cyclic", "Cyclic Interval", 0.0f, 0.0f, 0.0f, 2PI, FLT_MAX, -1);

      p <= addParamBool("debug_srcdst", "Debug Src/Dst", false);
      p.setToolTipCaption("When checked, debug-print current src/dst indices");

      addInput("src_idx", TYPE_INT);
      addInput("dst_idx", TYPE_INT);
      addInput("reset", TYPE_BOOL);
      addInput("prev", TYPE_BOOL);
      addInput("next", TYPE_BOOL);
      addInput("speed", TYPE_FLOAT);
      addInput("time", TYPE_FLOAT);
      addInput("time_cont", TYPE_FLOAT);

      // // addInput("input_01", TYPE_FLOAT);
      // // addInput("input_02", TYPE_FLOAT);
      lazyAddInputs();

      addOutput(GOutput.OUT_DEF, TYPE_FLOAT);
      addOutput("out_inv", TYPE_FLOAT);  // 1-out (crossfades)
   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "tween";
   }

   // <ui_handle.png>
   public virtual handleParamChanged(String _paramId) {
      if("io_type" == _paramId)
      {
         updateIOType();
      }
      else if(("num_inputs" == _paramId) || ("input_mode" == _paramId))
      {
         lazyAddInputs();
         lazyRemoveUnconnectedInputs();
      }
   }

   // <method.png>
   protected method updateIOType() {
      GOutput output <= getOutputById(GOutput.OUT_DEF);
      int ioType = getChoiceIOTypeParamById("io_type");
      output.type = ioType;

      GInput *input;
      foreach input in inputs
      {
         if(input.id <= "input_")
         {
            input.type = ioType;
         }
      }

      // Update connections
      handleOutputTypeChanged(output);

      type = ioType;
   }

   // <method.png>
   protected method getNumInputPorts() : int {
      int inputMode = getChoiceParamById("input_mode");
      if(INPUT_MODE_INPUTS == inputMode)
         return getIntParamById("num_inputs");
      else
         return 1;
   }

   // <method.png>
   protected method getNumInputs() : int {
      int inputMode = getChoiceParamById("input_mode");
      if(INPUT_MODE_INPUTS == inputMode)
         return getIntParamById("num_inputs");
      else
      {
         GInput input <= getInputById("input_conn");
         if(null != input)
            return input.getNumActiveConnections();
         else
            return 0;
      }
   }

   // <method_remove.png>
   protected method lazyAddInputs() {
      int ioType = getChoiceIOTypeParamById("io_type");
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null == input)
            {
               addInput(inputName, ioType);
            }
            inputNr++;
         }
      }
      else
      {
         if(null == getInputById("input_conn"))
            addInput("input_conn", ioType);
      }
   }

   // <method_remove.png>
   protected method lazyRemoveUnconnectedInputs() {
      GInput *input;
      int inputIdx = 0;
      int inputMode = getChoiceParamById("input_mode");
      int numInputs = getIntParamById("num_inputs");
      while(inputIdx < inputs.numElements)
      {
         boolean bRemoved = false;
         input <= inputs.get(inputIdx);
         if(input.id <= "input_")
         {
            boolean bRemove = false;
            if(INPUT_MODE_INPUTS == inputMode)
            {
               if("input_conn" != input.id)
               {
                  int inputNr = input.id.substring(6,-1);
                  bRemove = (inputNr > numInputs);
               }
            }
            else
            {
               bRemove = ("input_conn" != input.id);
            }
            if(bRemove)
            {
               if(!input.isConnected())
               {
                  inputs.delete(inputIdx);
                  bRemoved = true;
               }
            }
         }
         if(!bRemoved)
            inputIdx++;
      }
   }

   // // // <method_get.png>
   // // public virtual getSupportedAnonInputObjectTypes(String _inputId) : PointerArray {
   // //    if((null == _inputId) || (_inputId <= "input_"))
   // //    {
   // //       return GDefs.GetAnonObjectTypesByIOType(type);
   // //    }
   // //    return null;
   // // }

   // <method_set.png>
   public virtual containerSetForcedConnectionOrProbe(GConnection _conn, boolean _bProbe) : boolean {
      // when 's' is pressed in inputs table
      Global.Debug("GModTween::setForcedConnection: conn="+#(_conn));
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null != input)
            {
               if(-1 != input.findActiveConnectionIndex(_conn))
               {
                  if(!_bProbe)
                  {
                     setIntParamById("forced_src", inputNr);
                     setIntParamById("forced_dst", inputNr);
                     current_project.queueUpdate();
                  }
                  return true;
               }
            }
            inputNr++;
         }
      }
      else
      {
         input <= getInputById("input_conn");
         int activeIdx = input.findActiveConnectionIndex(_conn);
         // trace "xxx activeIdx="+activeIdx;
         if(-1 != activeIdx)
         {
            if(!_bProbe)
            {
               setIntParamById("forced_src", activeIdx+1);
               setIntParamById("forced_dst", activeIdx+1);
               // trace "xxx getIntParamById(forced_src)="+getIntParamById("forced_src");
               current_project.queueUpdate();
            }
            return true;
         }
      }

      if(!_bProbe)
      {
         setIntParamById("forced_src", 0);
         setIntParamById("forced_dst", 0);
         current_project.queueUpdate();
      }
      return false;
   }

   // <method_find.png>
   public virtual containerFindConnectionByObject(GObject _obj) : GConnection {
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      GConnection *conn;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null != input)
            {
               foreach conn in input.connections
               {
                  if(@(conn.object) == @(_obj))
                     return conn;
               }
            }
            inputNr++;
         }
      }
      else
      {
         input <= getInputById("input_conn");
         foreach conn in input.connections
         {
            if(@(conn.object) == @(_obj))
               return conn;
         }
      }
      return null;
   }

   // <method_get.png>
   public method containerGetNumActiveConnections() : int {
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      int r = 0;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null != input)
            {
               r += input.getNumActiveConnections();
            }
            inputNr++;
         }
      }
      else
      {
         input <= getInputById("input_conn");
         r += input.getNumActiveConnections();
      }
      return r;
   }

   // <method_get.png>
   public virtual containerGetActiveConnectionByIndex(int _idx) : GConnection {
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = _idx + 1;
         local String inputName <= "input_"+inputNr.printf("%02d");
         input <= getInputById(inputName);
         if(null != input)
         {
            return input.getActiveConnectionByIndex(0);
         }
      }
      else
      {
         input <= getInputById("input_conn");
         return input.getActiveConnectionByIndex(_idx);
      }
   }

   // <method_get.png>
   public virtual containerIsForcedConnection(GConnection _conn) : boolean {
      // trace "xxx GModTween::containerIsForcedConnection: ENTER _conn="+#(_conn);
      if(null != _conn)
      {
         int forcedSrc = getIntParamById("forced_src");
         if(forcedSrc > 0)
         {
            GConnection conn <= containerGetActiveConnectionByIndex(forcedSrc-1);
            // trace "xxx GModTween::containerIsForcedConnection: conn="+#(conn)+" _conn="+#(_conn);
            if(@(_conn) == @(conn))
               return true;
         }
      }
      return false;
   }

   // <method_get.png>
   public virtual containerIsForcedConnectionObject(GObject _obj) : boolean {
      int idx = getIntParamById("forced_src") - 1;
      if(idx >= 0)
      {
         GConnection conn <= containerGetActiveConnectionByIndex(idx);
         if(null != conn)
         {
            return (@(conn.object) == @(_obj));
         }
      }
      return false;
   }

   // <save.png>
   public virtual saveStateObject(local Stream ofs, local GConnectionWriter connectionWriter) {
      GObject::saveStateObject(ofs, connectionWriter);

      // Version
      ofs.i16 = 1;

      // Params
      GParamProvider::saveStateParamProvider(ofs, connectionWriter);
   }

   // <load.png>
   public method loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject

      // Version
      short ver = ifs.u16;

      if(1 <= ver <= 1)
      {
         if(GParamProvider::loadStateParamProvider(ifs))
         {
            updateIOType();

            lazyAddInputs();
            lazyRemoveUnconnectedInputs();

            // Succeeded
            return true;
         }
         else
         {
            trace "[---] GModTween::loadStateObject: failed to load params, this="+#(this)+" path="+getObjectPath();
         }
      }
      else
      {
         trace "[---] GModTween::loadStateObject: invalid version "+ver+", this="+#(this)+" path="+getObjectPath();
      }
      return false;
   }

   // <method.png>
   public virtual emitBegin() {
      b_init_done = false;
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {
      _parents.add(this);

      local int inputMode     = getChoiceParamById("input_mode");
      local int numInputs     = getNumInputs();
      local int initialSrc    = getIntParamById("initial_src");
      local int initialDst    = getIntParamById("initial_dst");
      local int forcedSrc     = getIntParamById("forced_src");
      local int forcedDst     = getIntParamById("forced_dst");
      local boolean bEvalAll  = getBoolParamById("eval_all");
      local int repeatMode    = getChoiceParamById("repeat");
      local int interpol      = getChoiceParamById("interpol");
      local float defSpeed    = getFloatParamById("def_speed");
      local boolean bAutoAdv  = getBoolParamById("auto_adv");
      local float cyclic      = getFloatParamById("cyclic");  // cyclic interval, 0=not cyclic
      local boolean bDebugSrcDst = getBoolParamById("debug_srcdst");

      if(!b_init_done)
      {
         b_init_done = true;
         s_var_src_idx   <= _module.allocGlobalVarScript(this, TYPE_INT,   "src_idx", String((initialSrc - 1)));
         s_var_dst_idx   <= _module.allocGlobalVarScript(this, TYPE_INT,   "dst_idx", String((initialDst - 1)));
         s_var_t         <= _module.allocGlobalVarScript(this, TYPE_FLOAT, "t",       "0.0f");
         s_var_adv       <= _module.allocGlobalVarScript(this, TYPE_BOOL,  "adv",     "false");
      }
      local String sVarSrcIdx <= s_var_src_idx;
      local String sVarDstIdx <= s_var_dst_idx;
      local String sVarT <= s_var_t;

      _out.append("\n//\n");
      _out.append("// Tween "+getObjectPath());
      if(cyclic != 0.0f)
         _out.append(" cyclic="+cyclic);
      _out.append(":\n");
      _out.append("//\n");

      local String sVarReset <= _module.allocTmpVarScript(_out, TYPE_BOOL, id+"_reset");
      local GInput inReset <= getInputById("reset");
      if(inReset.isConnected())
      {
         inReset.emit(_module, _program, _out, sVarReset, _bGLSL, _parents);
      }

      local GInput inPrev <= getInputById("prev");
      local String sVarPrev <= _module.allocTmpVarScript(_out, TYPE_BOOL, id+"_prev");
      if(inPrev.isConnected())
      {
         inPrev.emit(_module, _program, _out, sVarPrev, _bGLSL, _parents);
      }

      local GInput inNext <= getInputById("next");
      local String sVarNext <= _module.allocTmpVarScript(_out, TYPE_BOOL, id+"_next");
      if(inNext.isConnected())
      {
         inNext.emit(_module, _program, _out, sVarNext, _bGLSL, _parents);
      }

      local GInput inSrcIdx <= getInputById("src_idx");
      if(inSrcIdx.isConnected())
         inSrcIdx.emit(_module, _program, _out, sVarSrcIdx, _bGLSL, _parents);

      local GInput inDstIdx <= getInputById("dst_idx");
      if(inDstIdx.isConnected())
         inDstIdx.emit(_module, _program, _out, sVarDstIdx, _bGLSL, _parents);

      local GInput inSpeed <= getInputById("speed");
      local String sVarSpeed <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_speed");
      if(inSpeed.isConnected())
      {
         inSpeed.emit(_module, _program, _out, sVarSpeed, _bGLSL, _parents);
      }
      else
         _out.append(sVarSpeed+" = "+defSpeed+";\n");

      local GInput inTime <= getInputById("time");
      if(inTime.isConnected())
      {
         // (note) overrides animation speed when connected
         inTime.emit(_module, _program, _out, sVarT, _bGLSL, _parents);
      }

      local GInput inTimeCont <= getInputById("time_cont");
      if(inTimeCont.isConnected())
      {
         // (note) overrides animation speed when connected
         inTimeCont.emit(_module, _program, _out, sVarT, _bGLSL, _parents);
         _out.append(sVarSrcIdx+" = int("+sVarT+");\n");
         _out.append(sVarDstIdx+" = "+sVarSrcIdx+" + 1;\n");
         _out.append(sVarT+" = "+sVarT+" - int("+sVarT+");\n");
      }

      _out.append("if("+sVarReset+") { "+sVarSrcIdx+" = "+(initialSrc - 1)+"; "+sVarDstIdx+" = "+(initialDst - 1)+"; "+sVarT+" = 0.0f; }\n");
      _out.append("if("+sVarPrev+") { "+sVarSrcIdx+"--; "+sVarDstIdx+"--; "+sVarT+" = 0.0f; }\n");
      _out.append("if("+sVarNext+") { "+sVarSrcIdx+"++; "+sVarDstIdx+"++; "+sVarT+" = 0.0f; }\n");
      _out.append("if("+s_var_adv+") { "+s_var_adv+" = false; "+sVarSrcIdx+"++; "+sVarDstIdx+"++; }\n");

      if(0 == repeatMode)
      {
         // Clamp
         _out.append("if("+sVarSrcIdx+" < 0) "+sVarSrcIdx+" = 0; else if("+sVarSrcIdx+" >= "+numInputs+") "+sVarSrcIdx+" = "+(numInputs - 1)+";\n");
         _out.append("if("+sVarDstIdx+" < 0) "+sVarDstIdx+" = 0; else if("+sVarDstIdx+" >= "+numInputs+") "+sVarDstIdx+" = "+(numInputs - 1)+";\n");
      }
      else
      {
         // Wrap
         // _out.append("if("+sVarSrcIdx+" < 0) "+sVarSrcIdx+" += "+numInputs+"; else if("+sVarSrcIdx+" >= "+numInputs+") "+sVarSrcIdx+" -= "+numInputs+";\n");
         // _out.append("if("+sVarDstIdx+" < 0) "+sVarDstIdx+" += "+numInputs+"; else if("+sVarDstIdx+" >= "+numInputs+") "+sVarDstIdx+" -= "+numInputs+";\n");
         _out.append(sVarSrcIdx+" = ("+sVarSrcIdx+" % "+numInputs+");\n");
         _out.append(sVarDstIdx+" = ("+sVarDstIdx+" % "+numInputs+");\n");
      }

      local int inputIdx = 0;
      local Integer inputNr = 1;
      local GInput *input;
      local String sInEmit;

      int ioType = getChoiceIOTypeParamById("io_type");
      local String sVarSrc <= _module.allocTmpVarScript(_out, ioType, id+"_src");
      local String sVarDst <= _module.allocTmpVarScript(_out, ioType, id+"_dst");

      local String *sVarIn;

      if(bDebugSrcDst)
      {
         _out.append("trace \"[dbg] tween src=\"+"+sVarSrcIdx+"+\" dst=\"+"+sVarDstIdx+"+\" t=\"+"+sVarT+";\n");
      }

      if(bEvalAll)
      {
         local String sCalc;

         local String sSwitchSrc;
         sSwitchSrc.append("switch("+sVarSrcIdx+")\n{\n");
         sSwitchSrc.append("   default:\n");

         local String sSwitchDst;
         sSwitchDst.append("switch("+sVarDstIdx+")\n{\n");
         sSwitchDst.append("   default:\n");

         // Calculate all inputs
         loop(numInputs)
         {
            if( ((0 == forcedSrc) || (forcedSrc == inputNr)) || ((0 == forcedDst) || (forcedDst == inputNr)) )
            {
               if(INPUT_MODE_INPUTS == inputMode)
                  input <= getInputById("input_"+inputNr.printf("%02d"));
               else
                  input <= getInputById("input_conn");
               sCalc.append("// input "+inputNr+"/"+numInputs+": "+input.getConnectionInfoString()+"\n");
               sVarIn <= _module.allocTmpVarScript(sCalc, input.type, id+"_case_"+inputIdx);
               sInEmit.empty();
               if(INPUT_MODE_INPUTS == inputMode)
                  input.emit(_module, _program, sInEmit, sVarIn, _bGLSL, _parents);
               else
                  input.emitFltConn(inputIdx/*fltConnIdx*/, _module, _program, sInEmit, sVarIn, _bGLSL, _parents);
               Utils.AppendIndentedLines(sCalc, sInEmit, 0);

               sSwitchSrc.append("   case "+inputIdx+": "+((0 != forcedSrc)?" // forced src":"")+"\n");
               sSwitchSrc.append("      "+sVarSrc+" = "+sVarIn+";\n");
               sSwitchSrc.append("      break;\n");

               sSwitchDst.append("   case "+inputIdx+": "+((0 != forcedDst)?" // forced dst":"")+"\n");
               sSwitchDst.append("      "+sVarDst+" = "+sVarIn+";\n");
               sSwitchDst.append("      break;\n");
            }

            // Next input
            inputIdx++;
            inputNr++;
         }
         sSwitchSrc.append("} // src switch("+sVarSrcIdx+")\n");
         sSwitchDst.append("} // dst switch("+sVarDstIdx+")\n");

         _out.append(sCalc);
         _out.append(sSwitchSrc);
         _out.append(sSwitchDst);
      }
      else
      {
         loop(numInputs)
         {
            if( (forcedSrc == inputNr) || (forcedDst == inputNr) )
               _out.append("if(1) {\n");
            else
               _out.append("if( ("+sVarSrcIdx+" == "+inputIdx+") || ("+sVarDstIdx+" == "+inputIdx+") )\n{\n");

            if(INPUT_MODE_INPUTS == inputMode)
               input <= getInputById("input_"+inputNr.printf("%02d"));
            else
               input <= getInputById("input_conn");
            _out.append("   // input "+inputNr+"/"+numInputs+": "+input.getConnectionInfoString()+"\n");
            sInEmit.empty();
            _out.append("   ");
            sVarIn <= _module.allocTmpVarScript(_out, input.type, id+"_input_"+inputIdx);
            if(INPUT_MODE_INPUTS == inputMode)
               input.emit(_module, _program, sInEmit, sVarIn, _bGLSL, _parents);
            else
               input.emitFltConn(inputIdx/*fltConnIdx*/, _module, _program, sInEmit, sVarIn, _bGLSL, _parents);
            Utils.AppendIndentedLines(_out, sInEmit, 3);

            if(forcedSrc > 0)
               _out.append("   if("+forcedSrc+" == "+inputNr+")\n");
            else
               _out.append("   if("+sVarSrcIdx+" == "+inputIdx+")\n");
            _out.append("      "+sVarSrc+" = "+sVarIn+";\n");

            if(forcedDst > 0)
               _out.append("   if("+forcedDst+" == "+inputNr+")\n");
            else
               _out.append("   if("+sVarDstIdx+" == "+inputIdx+")\n");
            _out.append("      "+sVarDst+" = "+sVarIn+";\n");

            _out.append("} // end tween inputIdx="+inputIdx+"\n");

            // Next input
            inputIdx++;
            inputNr++;
         }
      }

      // Tween
      _out.append("// Tween interpol="+interpol_names.get(interpol)+"\n");
      local String *t;
      local String x <= sVarT;
      switch(interpol)
      {
         default:
         case INTERPOL_LINEAR:
            t <= x;
            break;

         case INTERPOL_SIN:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_tsin");
            _out.append(t+" = sin("+x+" * (PI * 0.5f));\n");
            break;

         case INTERPOL_COS:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_tcos");
            _out.append(t+" = 1.0f - cos("+x+" * (PI * 0.5f));\n");
            break;

         case INTERPOL_SMOOTHSTEP:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_tsmoothstep");
            _out.append(t+" = "+x+"*"+x+" * (3.0f - 2.0f * "+x+");\n");
            break;

         case INTERPOL_EASEINSINE:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinsine");
            _out.append(t+" = 1 - cos(("+x+" * PI) / 2);\n");
            break;

         case INTERPOL_EASEOUTSINE:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutsine");
            _out.append(t+" =  sin(("+x+" * PI) / 2);\n");
            break;

         case INTERPOL_EASEINOUTSINE:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutsine");
            _out.append(t+" =  -(cos(PI * "+x+") - 1) / 2;\n");
            break;

         case INTERPOL_EASEINQUAD:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinquad");
            _out.append(t+" =  "+x+" * "+x+";\n");
            break;

         case INTERPOL_EASEOUTQUAD:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutquad");
            _out.append(t+" =  1 - (1 - "+x+") * (1 - "+x+");\n");
            break;

         case INTERPOL_EASEINOUTQUAD:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutquad");
            _out.append(t+" =  "+x+" < 0.5 ? 2 * "+x+" * "+x+" : 1 - pow(-2 * "+x+" + 2, 2) / 2;\n");
            break;

         case INTERPOL_EASEINCUBIC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseincubic");
            _out.append(t+" =  "+x+" * "+x+" * "+x+";\n");
            break;

         case INTERPOL_EASEOUTCUBIC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutcubic");
            _out.append(t+" =  1 - pow(1 - "+x+", 3);\n");
            break;

         case INTERPOL_EASEINOUTCUBIC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutcubic");
            _out.append(t+" = "+x+" < 0.5 ? 4 * "+x+" * "+x+" * "+x+" : 1 - pow(-2 * "+x+" + 2, 3) / 2;\n");
            break;

         case INTERPOL_EASEINQUART:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinquart");
            _out.append(t+" =  "+x+" * "+x+" * "+x+" * "+x+";\n");
            break;

         case INTERPOL_EASEOUTQUART:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutquart");
            _out.append(t+" =  1 - pow(1 - "+x+", 4);\n");
            break;

         case INTERPOL_EASEINOUTQUART:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutquart");
            _out.append(t+" = "+x+" < 0.5 ? 8 * "+x+" * "+x+" * "+x+" * "+x+" : 1 - pow(-2 * "+x+" + 2, 4) / 2;\n");
            break;

         case INTERPOL_EASEINQUINT:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinquint");
            _out.append(t+" =  "+x+" * "+x+" * "+x+" * "+x+" * "+x+";\n");
            break;

         case INTERPOL_EASEOUTQUINT:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutquint");
            _out.append(t+" =  1 - pow(1 - "+x+", 5);\n");
            break;

         case INTERPOL_EASEINOUTQUINT:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutquint");
            _out.append(t+" = "+x+" < 0.5 ? 16 * "+x+" * "+x+" * "+x+" * "+x+" * "+x+" : 1 - pow(-2 * "+x+" + 2, 5) / 2;\n");
            break;

         case INTERPOL_EASEINEXPO:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinexpo");
            _out.append(t+" = "+x+" == 0 ? 0 : pow(2, 10 * "+x+" - 10);\n");
            break;

         case INTERPOL_EASEOUTEXPO:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutexpo");
            _out.append(t+" = "+x+" == 1 ? 1 : 1 - pow(2, -10 * "+x+");\n");
            break;

         case INTERPOL_EASEINOUTEXPO:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutexpo");
            _out.append(t+" = "+x+" == 0 ? 0 : "+x+" == 1 ? 1 : "+x+" < 0.5 ? pow(2, 20 * "+x+" - 10) / 2 : (2 - pow(2, -20 * "+x+" + 10)) / 2;\n");
            break;

         case INTERPOL_EASEINCIRC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseincirc");
            _out.append(t+" =  1 - sqrt(1 - pow("+x+", 2));\n");
            break;

         case INTERPOL_EASEOUTCIRC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutcirc");
            _out.append(t+" = sqrt(1 - pow("+x+" - 1, 2));\n");
            break;

         case INTERPOL_EASEINOUTCIRC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutcirc");
            _out.append(t+" =  "+x+" < 0.5 ? (1 - sqrt(1 - pow(2 * "+x+", 2))) / 2 : (sqrt(1 - pow(-2 * "+x+" + 2, 2)) + 1) / 2;\n");
            break;

         case INTERPOL_EASEINBACK:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinback");
            _out.append(t+" = 2.70158 * "+x+" * "+x+" * "+x+" - 1.70158 * "+x+" * "+x+";\n");
            break;

         case INTERPOL_EASEOUTBACK:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutback");
            _out.append(t+" = 1 + 2.70158 * pow("+x+" - 1, 3) + 1.70158 * pow("+x+" - 1, 2);\n");
            break;

         case INTERPOL_EASEINOUTBACK:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutback");
            _out.append(t+" = "+x+" < 0.5 ? (pow(2 * "+x+", 2) * (((1.70158*1.525) + 1) * 2 * "+x+" - (1.70158*1.525))) / 2 : (pow(2 * "+x+" - 2, 2) * (((1.70158*1.525) + 1) * ("+x+" * 2 - 2) + (1.70158*1.525)) + 2) / 2;\n");
            break;

         case INTERPOL_EASEINELASTIC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinelastic");
            _out.append(t+" = "+x+" == 0 ? 0 : "+x+" == 1 ? 1 : -pow(2, 10 * "+x+" - 10) * sin(("+x+" * 10 - 10.75) * (2PI / 3)/*c4*/);\n");
            break;

         case INTERPOL_EASEOUTELASTIC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutelastic");
            _out.append(t+" = "+x+" == 0 ? 0 : "+x+" == 1 ? 1 : pow(2, -10 * "+x+") * sin(("+x+" * 10 - 0.75) * (2PI / 3)/*c4*/) + 1;\n");
            break;

         case INTERPOL_EASEINOUTELASTIC:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutelastic");
            _out.append(t+" = "+x+" == 0 ? 0 : "+x+" == 1 ? 1 : "+x+" < 0.5 ? -(pow(2, 20 * "+x+" - 10) * sin((20 * "+x+" - 11.125) * (2PI / 4.5)/*c5*/)) / 2 : (pow(2, -20 * "+x+" + 10) * sin((20 * "+x+" - 11.125) * (2PI / 4.5)/*c5*/)) / 2 + 1;\n");
            break;

         case INTERPOL_EASEINBOUNCE:
            // 1 - easeOutBounce(1 - x)
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinbounce");
            local String xm <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_1mx");
            _out.append(xm+" = 1 - "+x+";\n");
            x <= xm;
            _out.append("if("+x+" < (1 / 2.75/*d1*/)) "+t+" = 7.5625/*n1*/ * "+x+" * "+x+";\n");
            _out.append("else if("+x+" < (2 / 2.75/*d1*/)) { "+t+" = ("+x+" - 1.5 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.75; }\n");
            _out.append("else if("+x+" < (2.5 / 2.75/*d1*/)) { "+t+" = ("+x+" - 2.25 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.9375; }\n");
            _out.append("else { "+t+" = ("+x+" - 2.625 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.984375; }\n");
            _out.append(t+" = 1 - "+t+";\n");
            break;

         case INTERPOL_EASEOUTBOUNCE:
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseoutbounce");
            _out.append("if("+x+" < (1 / 2.75/*d1*/)) "+t+" = 7.5625/*n1*/ * "+x+" * "+x+";\n");
            _out.append("else if("+x+" < (2 / 2.75/*d1*/)) { "+t+" = ("+x+" - 1.5 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.75; }\n");
            _out.append("else if("+x+" < (2.5 / 2.75/*d1*/)) { "+t+" = ("+x+" - 2.25 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.9375; }\n");
            _out.append("else { "+t+" = ("+x+" - 2.625 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.984375; }\n");
            break;

         case INTERPOL_EASEINOUTBOUNCE:
            // x < 0.5 ? (1 - easeOutBounce(1 - 2 * x)) / 2 : (1 + easeOutBounce(2 * x - 1)) / 2
            t <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_teaseinoutbounce");
            local String xp <= _module.allocTmpVarScript(_out, TYPE_FLOAT, id+"_xp");
            _out.append("if("+x+" < 0.5) { ");
            _out.append("   "+xp+" = 1 - 2 * "+x+";");
            _out.append("   if("+xp+" < (1 / 2.75/*d1*/)) "+t+" = 7.5625/*n1*/ * "+xp+" * "+xp+";\n");
            _out.append("   else if("+xp+" < (2 / 2.75/*d1*/)) { "+t+" = ("+xp+" - 1.5 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.75; }\n");
            _out.append("   else if("+xp+" < (2.5 / 2.75/*d1*/)) { "+t+" = ("+xp+" - 2.25 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.9375; }\n");
            _out.append("   else { "+t+" = ("+xp+" - 2.625 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.984375; }\n");
            _out.append("   "+t+" = (1 - "+t+") / 2;\n}\n");

            _out.append("else { ");
            _out.append("   "+xp+" = 2 * "+x+" - 1; ");
            _out.append("   if("+xp+" < (1 / 2.75/*d1*/)) "+t+" = 7.5625/*n1*/ * "+xp+" * "+xp+";\n");
            _out.append("   else if("+xp+" < (2 / 2.75/*d1*/)) { "+t+" = ("+xp+" - 1.5 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.75; }\n");
            _out.append("   else if("+xp+" < (2.5 / 2.75/*d1*/)) { "+t+" = ("+xp+" - 2.25 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.9375; }\n");
            _out.append("   else { "+t+" = ("+xp+" - 2.625 / 2.75/*d1*/); "+t+" = 7.5625/*n1*/ * "+t+" * "+t+" + 0.984375; }\n");
            _out.append("   "+t+" = (1 + "+t+") / 2;\n}\n");
            break;
      }

      if("out_inv" == _outputId)
      {
         _out.append(t+" = 1.0 - "+t+";\n");
      }

      if(0)
         _out.append("trace \"t=\"+"+t+"+\" srcIdx=\"+"+sVarSrcIdx+"+\" dstIdx=\"+"+sVarDstIdx+";\n");

      local int matIdx = 0;

      switch(ioType)
      {
         case TYPE_FLOAT:
            if(cyclic != 0.0f)
            {
               _out.append(_dstVar+" = mathLerpCyclicf("+sVarSrc+", "+sVarDst+", "+cyclic+", "+t+");\n");
            }
            else
            {
               _out.append(_dstVar+" = "+sVarSrc+" + ("+sVarDst+" - "+sVarSrc+") * "+t+";\n");
            }
            break;

         case TYPE_VEC2:
            if(cyclic != 0.0f)
            {
               _out.append(_dstVar+".x = mathLerpCyclicf("+sVarSrc+".x, "+sVarDst+".x, "+cyclic+", "+t+");\n");
               _out.append(_dstVar+".y = mathLerpCyclicf("+sVarSrc+".y, "+sVarDst+".y, "+cyclic+", "+t+");\n");
            }
            else
            {
               _out.append(_dstVar+".x = "+sVarSrc+".x + ("+sVarDst+".x - "+sVarSrc+".x) * "+t+";\n");
               _out.append(_dstVar+".y = "+sVarSrc+".y + ("+sVarDst+".y - "+sVarSrc+".y) * "+t+";\n");
            }
            break;

         case TYPE_VEC3:
            if(cyclic != 0.0f)
            {
               _out.append(_dstVar+".x = mathLerpCyclicf("+sVarSrc+".x, "+sVarDst+".x, "+cyclic+", "+t+");\n");
               _out.append(_dstVar+".y = mathLerpCyclicf("+sVarSrc+".y, "+sVarDst+".y, "+cyclic+", "+t+");\n");
               _out.append(_dstVar+".z = mathLerpCyclicf("+sVarSrc+".z, "+sVarDst+".z, "+cyclic+", "+t+");\n");
            }
            else
            {
               _out.append(_dstVar+".x = "+sVarSrc+".x + ("+sVarDst+".x - "+sVarSrc+".x) * "+t+";\n");
               _out.append(_dstVar+".y = "+sVarSrc+".y + ("+sVarDst+".y - "+sVarSrc+".y) * "+t+";\n");
               _out.append(_dstVar+".z = "+sVarSrc+".z + ("+sVarDst+".z - "+sVarSrc+".z) * "+t+";\n");
            }
            break;

         case TYPE_VEC4:
            if(cyclic != 0.0f)
            {
               _out.append(_dstVar+".x = mathLerpCyclicf("+sVarSrc+".x, "+sVarDst+".x, "+cyclic+", "+t+");\n");
               _out.append(_dstVar+".y = mathLerpCyclicf("+sVarSrc+".y, "+sVarDst+".y, "+cyclic+", "+t+");\n");
               _out.append(_dstVar+".z = mathLerpCyclicf("+sVarSrc+".z, "+sVarDst+".z, "+cyclic+", "+t+");\n");
               _out.append(_dstVar+".w = mathLerpCyclicf("+sVarSrc+".w, "+sVarDst+".w, "+cyclic+", "+t+");\n");
            }
            else
            {
               _out.append(_dstVar+".x = "+sVarSrc+".x + ("+sVarDst+".x - "+sVarSrc+".x) * "+t+";\n");
               _out.append(_dstVar+".y = "+sVarSrc+".y + ("+sVarDst+".y - "+sVarSrc+".y) * "+t+";\n");
               _out.append(_dstVar+".z = "+sVarSrc+".z + ("+sVarDst+".z - "+sVarSrc+".z) * "+t+";\n");
               _out.append(_dstVar+".w = "+sVarSrc+".w + ("+sVarDst+".w - "+sVarSrc+".w) * "+t+";\n");
            }
            break;

         case TYPE_MAT2:
            if(cyclic != 0.0f)
            {
               loop(2*2)
               {
                  _out.append(_dstVar+"["+matIdx+"] = mathLerpCyclicf("+sVarSrc+"["+matIdx+"], "+sVarDst+"["+matIdx+"], "+cyclic+", "+t+");\n");
                  matIdx++;
               }
            }
            else
            {
               loop(2*2)
               {
                  _out.append(_dstVar+"["+matIdx+"] = "+sVarSrc+"["+matIdx+"] + ("+sVarDst+"["+matIdx+"] - "+sVarSrc+"["+matIdx+"]) * "+t+";\n");
                  matIdx++;
               }
            }
            break;

         case TYPE_MAT3:
            if(cyclic != 0.0f)
            {
               loop(3*3)
               {
                  _out.append(_dstVar+"["+matIdx+"] = mathLerpCyclicf("+sVarSrc+"["+matIdx+"], "+sVarDst+"["+matIdx+"], "+cyclic+", "+t+");\n");
                  matIdx++;
               }
            }
            else
            {
               loop(3*3)
               {
                  _out.append(_dstVar+"["+matIdx+"] = "+sVarSrc+"["+matIdx+"] + ("+sVarDst+"["+matIdx+"] - "+sVarSrc+"["+matIdx+"]) * "+t+";\n");
                  matIdx++;
               }
            }
            break;

         case TYPE_MAT4:
            if(cyclic != 0.0f)
            {
               loop(4*4)
               {
                  _out.append(_dstVar+"["+matIdx+"] = mathLerpCyclicf("+sVarSrc+"["+matIdx+"], "+sVarDst+"["+matIdx+"], "+cyclic+", "+t+");\n");
                  matIdx++;
               }
            }
            else
            {
               loop(4*4)
               {
                  _out.append(_dstVar+"["+matIdx+"] = "+sVarSrc+"["+matIdx+"] + ("+sVarDst+"["+matIdx+"] - "+sVarSrc+"["+matIdx+"]) * "+t+";\n");
                  matIdx++;
               }
            }
            break;

         case TYPE_ORBITCAMVIEW:
            _out.append(_dstVar+".rot_x = mathLerpCyclicf("+sVarSrc+".rot_x, "+sVarDst+".rot_x, 360.0, "+t+");\n");
            _out.append(_dstVar+".rot_y = mathLerpCyclicf("+sVarSrc+".rot_y, "+sVarDst+".rot_y, 360.0, "+t+");\n");
            _out.append(_dstVar+".rot_z = mathLerpCyclicf("+sVarSrc+".rot_z, "+sVarDst+".rot_z, 360.0, "+t+");\n");
            _out.append(_dstVar+".ctr_x = "+sVarSrc+".ctr_x + ("+sVarDst+".ctr_x - "+sVarSrc+".ctr_x) * "+t+";\n");
            _out.append(_dstVar+".ctr_y = "+sVarSrc+".ctr_y + ("+sVarDst+".ctr_y - "+sVarSrc+".ctr_y) * "+t+";\n");
            _out.append(_dstVar+".ctr_z = "+sVarSrc+".ctr_z + ("+sVarDst+".ctr_z - "+sVarSrc+".ctr_z) * "+t+";\n");
            _out.append(_dstVar+".eye_dist = "+sVarSrc+".eye_dist + ("+sVarDst+".eye_dist - "+sVarSrc+".eye_dist) * "+t+";\n");
            break;
      }

      if(!inTime.isConnected() && !inTimeCont.isConnected())
      {
         _out.append(sVarT+" += "+sVarSpeed+";\n");
         _out.append("if("+sVarT+" >= 1.0f)\n");
         _out.append("{\n");
         if(bAutoAdv)
         {
            _out.append("   "+s_var_adv+" = true; \n");
            _out.append("   "+sVarT+" -= 1.0f;\n");
         }
         else
         {
            _out.append("   "+sVarT+" = 1.0f;\n");
         }
         _out.append("}\n");
      }

      _out.append("\n");

      _parents.remove(this);
   }

}
