// ----
// ---- file   : gorbitcamview.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 09Aug2020
// ---- changed: 12Aug2020, 13Aug2020, 18Sep2025
// ----
// ----
// ----
module MGOrbitCamView;

use namespace ui;
use namespace gledit;


// <class.png>
class OrbitCamView {
   // simplified type, used in generated script
   float ctr_x;
   float ctr_y;
   float ctr_z;
   float rot_x;
   float rot_y;
   float rot_z;
   float eye_dist;
}


// <class.png>
class GOrbitCamView : GConstant {
   OrbitCamView edit_cam;


   // <method_new.png>
   public static New() : GOrbitCamView {
      local GOrbitCamView r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GObject::init();
      type = TYPE_ORBITCAMVIEW;

      GParamFloat *pf;

      addParamFloat("ctr_x",  "Ctr X",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("ctr_y",  "Ctr Y",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("ctr_z",  "Ctr Z",   0.0, -100, -10000, 100.0, 10000.0, 0.0);

      pf <= addParamFloat("rot_x",  "Rot X",   0.0, -360, -360, 360.0, 360.0, 0.0);
      pf.setEnableCyclic(true);

      pf <= addParamFloat("rot_y",  "Rot Y",   0.0, -360, -360, 360.0, 360.0, 0.0);
      pf.setEnableCyclic(true);

      pf <= addParamFloat("rot_z",  "Rot Z",   0.0, -360, -360, 360.0, 360.0, 0.0);
      pf.setEnableCyclic(true);

      addParamFloat("eye_dist", "Eye Dist",  1.0, 0.0001, 0.0001, 10.0, 10000.0, 0.0);

      addInput("ctr",  TYPE_VEC3);
      addInput("rot",  TYPE_VEC3);
      addInput("dist", TYPE_FLOAT);

      addOutput(GOutput.OUT_DEF, TYPE_ORBITCAMVIEW);
   }

   // <method.png>
   public method strafe(float _spdX, float _spdY, float _spdZ) {
      // Matrix3f mat; mat.initEulerYXZ(getFloatParamById("rot_y") * (2PI/360.0),
      //                                getFloatParamById("rot_x") * (2PI/360.0),
      //                                0
      //                                );
      Matrix3f mat; mat.initEulerXYZ(getFloatParamById("rot_x") * (-2PI/360.0),
                                     getFloatParamById("rot_y") * (-2PI/360.0),
                                     0
                                     );
      Vector3f v;
      Vector3f vRot;

      float ctrX = getFloatParamById("ctr_x");
      float ctrY = getFloatParamById("ctr_y");
      float ctrZ = getFloatParamById("ctr_z");

      v.init(1, 0, 0);
      mat.mulv(v) => vRot;
      vRot.mulf(_spdX);
      ctrX += vRot.x;
      ctrY += vRot.y;
      ctrZ += vRot.z;

      v.init(0, 1, 0);
      mat.mulv(v) => vRot;
      vRot.mulf(_spdY);
      ctrX += vRot.x;
      ctrY += vRot.y;
      ctrZ += vRot.z;

      v.init(0, 0, 1);
      mat.mulv(v) => vRot;
      vRot.mulf(_spdZ);
      ctrX += vRot.x;
      ctrY += vRot.y;
      ctrZ += vRot.z;

      setFloatParamById("ctr_x", ctrX);
      setFloatParamById("ctr_y", ctrY);
      setFloatParamById("ctr_z", ctrZ);
   }

   // <method.png>
   public method rotate(float _rotX, float _rotY, float _rotZ) {
      // // // setFloatParamById("rot_x", (getFloatParamById("rot_x") + _rotX) % 360.0);
      // // // setFloatParamById("rot_y", (getFloatParamById("rot_y") + _rotY) % 360.0);
      setFloatParamById("rot_x", _rotX);
      setFloatParamById("rot_y", _rotY);
      setFloatParamById("rot_z", _rotZ);
   }

   // <method.png>
   public method center(float _ctrX, float _ctrY, float _ctrZ) {
      setFloatParamById("ctr_x", _ctrX);
      setFloatParamById("ctr_y", _ctrY);
      setFloatParamById("ctr_z", _ctrZ);
   }

   // <method_get.png>
   public method getUpdatedEditCamView() : OrbitCamView {
      edit_cam.ctr_x    = getFloatParamById("ctr_x");
      edit_cam.ctr_y    = getFloatParamById("ctr_y");
      edit_cam.ctr_z    = getFloatParamById("ctr_z");
      edit_cam.rot_x    = getFloatParamById("rot_x");
      edit_cam.rot_y    = getFloatParamById("rot_y");
      edit_cam.rot_z    = getFloatParamById("rot_z");
      edit_cam.eye_dist = getFloatParamById("eye_dist");
      return edit_cam;
   }

   // <save.png>
   public virtual saveStateObject(local Stream ofs, local GConnectionWriter connectionWriter) {

      GObject::saveStateObject(ofs, connectionWriter);

      // Version
      ofs.i16 = 1;

      // Params
      GParamProvider::saveStateParamProvider(ofs, connectionWriter);
   }

   // <load.png>
   public method loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject

      // Version
      short ver = ifs.u16;

      if(1 <= ver <= 1)
      {
         if(GParamProvider::loadStateParamProvider(ifs))
         {
            // Succeeded
            return true;
         }
         else
         {
            trace "[---] GOrbitCamView::loadStateObject: failed to load params, this="+#(this)+" path="+getObjectPath();
         }
      }
      else
      {
         trace "[---] GOrbitCamView::loadStateObject: invalid version "+ver+", this="+#(this)+" path="+getObjectPath();
      }
      return false;
   }

   // <method.png>
   public method copyToOrbitCamView(OrbitCamView _cam) {
      // called by GEnvelopeOrbitCam editor (Curve7Dialog)
      _cam.ctr_x    = getFloatParamById("ctr_x");
      _cam.ctr_y    = getFloatParamById("ctr_y");
      _cam.ctr_z    = getFloatParamById("ctr_z");
      _cam.rot_x    = getFloatParamById("rot_x") % 360.0;
      _cam.rot_y    = getFloatParamById("rot_y") % 360.0;
      trace "xxx copy _cam.rot_y="+_cam.rot_y+" mod="+(_cam.rot_y%360.0);
      _cam.rot_z    = getFloatParamById("rot_z") % 360.0;
      _cam.eye_dist = getFloatParamById("eye_dist");
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {

      local String sCtrX;
      local String sCtrY;
      local String sCtrZ;
      local String sRotX;
      local String sRotY;
      local String sRotZ;
      local String sEyeDist;
      local boolean bScalarParam;

      if(!current_project.b_export &&
         (@(this) == @(current_project.edit_cam))
         )
      {
         sCtrX    = "g_edit_cam.ctr_x";
         sCtrY    = "g_edit_cam.ctr_y";
         sCtrZ    = "g_edit_cam.ctr_z";
         sRotX    = "g_edit_cam.rot_x";
         sRotY    = "g_edit_cam.rot_y";
         sRotZ    = "g_edit_cam.rot_z";
         sEyeDist = "g_edit_cam.eye_dist";
         bScalarParam = false;
      }
      else
      {
         sCtrX = getFloatParamById("ctr_x");
         sCtrY = getFloatParamById("ctr_y");
         sCtrZ = getFloatParamById("ctr_z");

         sRotX = getFloatParamById("rot_x");
         sRotY = getFloatParamById("rot_y");
         sRotZ = getFloatParamById("rot_z");

         sEyeDist = getFloatParamById("eye_dist");

         bScalarParam = true;
      }

      _parents.add(this);

      GInput *input;
      local String sCtr   <= _module.allocTmpVarScript(_out, TYPE_VEC3, "in_ctr");
      local String sRot   <= _module.allocTmpVarScript(_out, TYPE_VEC3, "in_rot");
      local String sDist  <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_dist");

      _out.append("// ---- BEGIN GOrbitCamView "+getObjectPath()+"\n");

      // ctr
      input <= getInputById("ctr");
      if(input.isConnected())
      {
         input.emit(_module, _program, _out, sCtr, _bGLSL, _parents);
         if(bScalarParam && (0.0f != float(sCtrX)))
            _out.append(sCtr+".x = "+sCtr+".x + "+sCtrX+";\n");
         if(bScalarParam && (0.0f != float(sCtrY)))
            _out.append(sCtr+".y = "+sCtr+".y + "+sCtrY+";\n");
         if(bScalarParam && (0.0f != float(sCtrZ)))
            _out.append(sCtr+".z = "+sCtr+".z + "+sCtrZ+";\n");
      }
      else
      {
         _out.append(sCtr+".init("+sCtrX+", "+sCtrY+", "+sCtrZ+");\n");
      }

      // rot
      input <= getInputById("rot");
      if(input.isConnected())
      {
         input.emit(_module, _program, _out, sRot, _bGLSL, _parents);
         if(bScalarParam && (0.0f != float(sRotX)))
            _out.append(sRot+".x = "+sRot+".x + "+sRotX+";\n");
         if(bScalarParam && (0.0f != float(sRotY)))
            _out.append(sRot+".y = "+sRot+".y + "+sRotY+";\n");
         if(bScalarParam && (0.0f != float(sRotZ)))
            _out.append(sRot+".z = "+sRot+".z + "+sRotZ+";\n");
      }
      else
      {
         _out.append(sRot+".init("+sRotX+", "+sRotY+", "+sRotZ+");\n");
      }

      // dist
      input <= getInputById("dist");
      if(input.isConnected())
      {
         input.emit(_module, _program, _out, sDist, _bGLSL, _parents);
         if(bScalarParam && (0.0f != float(sEyeDist)))
            _out.append(sDist+" += "+sEyeDist+";\n");
      }
      else
      {
         _out.append(sDist+" = "+sEyeDist+";\n");
      }


      _out.append(_dstVar+".ctr_x = "+sCtr+".x;\n");
      _out.append(_dstVar+".ctr_y = "+sCtr+".y;\n");
      _out.append(_dstVar+".ctr_z = "+sCtr+".z;\n");

      _out.append(_dstVar+".rot_x = "+sRot+".x;\n");
      _out.append(_dstVar+".rot_y = "+sRot+".y;\n");
      _out.append(_dstVar+".rot_z = "+sRot+".z;\n");

      _out.append(_dstVar+".eye_dist = "+sDist+";\n");


      // _out.append(_dstVar+".ctr_x = "+ctrX+";\n");
      // _out.append(_dstVar+".ctr_y = "+ctrY+";\n");
      // _out.append(_dstVar+".ctr_z = "+ctrZ+";\n");

      // _out.append(_dstVar+".rot_x = "+rotX+";\n");
      // _out.append(_dstVar+".rot_y = "+rotY+";\n");
      // _out.append(_dstVar+".rot_z = "+rotZ+";\n");

      // _out.append(_dstVar+".eye_dist = "+eyeDist+";\n");

      _out.append("// ---- END GOrbitCamView "+getObjectPath()+"\n");

      _parents.remove(this);
   }

}
