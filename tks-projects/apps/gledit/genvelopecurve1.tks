// ----
// ---- file   : genvelopecurve1.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 15Aug2020
// ---- changed:
// ----
// ----
// ----
module MGEnvelopeCurve1;

use namespace ui;
use namespace gledit;


// <class.png>
class GEnvelopeCurve1 : GEnvelope, GParamProvider {

   define int NUM_CURVES = 1;

   BezierEditState *[] curve_states;
   Envelope *[]        curve_envs;

   static Curve1Dialog *dlg_curve;

   protected boolean b_init_done;
   protected boolean b_post_done;


   // <method_init.png>
   public virtual init() {
      GObject::init();
      type = TYPE_FLOAT;

      GParamFloat *pf;

      addParamFloat("scl", "Env Scale", 1.0f, -10.0f, FLT_MIN, 10.0f, FLT_MAX, 1.0f);
      addParamFloat("off", "Env Offset", 0.0f, -10, FLT_MIN, 10, FLT_MAX, 0);

      addParamBool("repeat", "Repeat", true);

      addInput("t",    TYPE_FLOAT);

      addOutput(GOutput.OUT_DEF, TYPE_FLOAT);

      loop(NUM_CURVES)
      {
         BezierEditState beState <= new BezierEditState;
         Envelope beEnv <= new Envelope;
         BezierCurveForm.InitLinearEnv(beState, beEnv);
         curve_states.add(#(deref beState));
         curve_envs.add(#(deref beEnv));
         // trace "xxx beEnv="+#(beEnv);
      }

   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "env_curve";
   }

   // <method.png>
   public virtual getVarName() : String {
      return getVarNamePrefix()+"_env1_"+id;
   }

   // <method_get.png>
   public virtual getInputDomain(String _inputId) : int {
      return DOMAIN_SCRIPT;
   }

   // <method_get.png>
   public virtual getOutputDomain(String _outputId) : int {
      return DOMAIN_SCRIPT;
   }

   // <ui_show.png>
   public method showEditor() {
      if(null == dlg_curve)
      {
         dlg_curve <= new Curve1Dialog;
         dlg_curve.initCurve1Dialog();
      }
      dlg_curve.showCurve1Dialog(this);
   }

   // <save.png>
   public virtual saveStateObject(local Stream ofs, local GConnectionWriter connectionWriter) {
      GObject::saveStateObject(ofs, connectionWriter);

      // Version
      ofs.i16 = 1;

      // Params
      GParamProvider::saveStateParamProvider(ofs, connectionWriter);

      // Save curves
      int curveIdx = 0;
      loop(NUM_CURVES)
      {
         BezierEditState beState <= curve_states.get(curveIdx);
         ofs << beState;
         curveIdx++;
      }
   }

   // <load.png>
   public virtual loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject

      // Version
      short ver = ifs.u16;

      if(1 <= ver <= 1)
      {
         if(GParamProvider::loadStateParamProvider(ifs))
         {
            // Read Curves
            int curveIdx = 0;
            local BezierEditState beStateTmp;
            loop(NUM_CURVES)
            {
               BezierEditState beState <= curve_states.get(curveIdx);
               Envelope beEnv <= curve_envs.get(curveIdx);
               beState << ifs;
               BezierCurveForm.CalcEnv(beState, beEnv);
               curveIdx++;
            }

            // Succeeded
            return true;
         }
         else
         {
            trace "[---] GEnvelopeCurve1::loadStateObject: failed to load params, this="+#(this)+" path="+getObjectPath();
         }
      }
      else
      {
         trace "[---] GEnvelopeCurve1::loadStateObject: invalid version "+ver+", this="+#(this)+" path="+getObjectPath();
      }
      return false;
   }

   // <method_get.png>
   public virtual hasDefaultAction() : boolean {
      return true;
   }

   // <method.png>
   public virtual execDefaultAction() {
      // trace "xxx GEnvelopeCurve1::execDefaultAction";
      showEditor();
   }

   // <method.png>
   public virtual emitBegin() {
      // trace "xxx GEnvelopeCurve1::emitBegin";
      b_init_done = false;
      b_post_done = false;
   }

   // <method.png>
   protected method emitEnv(local String       _sEnvVar,
                            local String       _sVarT,
                            local float        _scl,
                            local float        _off,
                            local GModule      _module,
                            local String       _out,
                            local String       _dstVar,
                            local PointerArray _parents
                            ) {

      _out.append(_dstVar+" = "+_sEnvVar+".valueAtTime("+_sVarT+") * "+_scl+" + "+_off+";\n");
      // _out.append("trace \""+_dstVar+"=\"+"+_dstVar+";\n");
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {

      // trace "xxx GEnvelopeCurve1::emit: outputId="+_outputId+" b_init_done="+b_init_done;
      // trace "xxx   parents="+Utils.GetParentsDebugString(_parents);

      local String sEnvVar <= getVarName();

      boolean bRepeat = getBoolParamById("repeat");

      if(!b_init_done)
      {
         b_init_done = true;

         local String sGlobal;

         sGlobal.append("Envelope *"+sEnvVar+"_val;\n");

         _module.appendGlobal(sGlobal);
      }

      _parents.add(this);

      // trace "xxx GEnvelopeCurve1::emit: outputId=\""+_outputId+"\"";

      local GInput *input;

      // Time
      input <= getInputById("t");
      local String *sVarT;
      if(input.isConnected())
      {
         sVarT <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_t");
         input.emit(_module, null/*program*/, _out, sVarT, false/*bGLSL*/, _parents);
         if(bRepeat)
            _out.append(sVarT+" = "+sVarT+" % 1.0f;\n");
         else
            _out.append(sVarT+" = mathClampf("+sVarT+", 0.0f, 1.0f);\n");
      }
      else
         sVarT <= "0/*no in_t input*/";

      // Envelopes
      emitEnv(sEnvVar+"_val",
              sVarT,
              getFloatParamById("scl"), getFloatParamById("off"),
              _module,
              _out,
              _dstVar,
              _parents
              );

      _parents.remove(this);

   }

   // <method.png>
   protected method updateEnvVars() {
      local String sEnvVar <= getVarName();
      local Variable *v;

      v <= current_project.script.findVariable(sEnvVar+"_val");
      v.pointerAssign(curve_envs.get(0));
      v.store();
   }

   // <method.png>
   public virtual emitModulePost(GModule _module) {
      if(b_init_done && !b_post_done)
      {
         b_post_done = true;

         local PointerArray parents;
         parents.add(this);
         emitPost(_module, null/*_program*/, parents);
         parents.remove(this);
      }
   }

   // <method.png>
   public virtual emitPost(local GModule      _module,
                           local GProgram     _program,
                           local PointerArray _parents
                           ) {
      if(b_init_done && !b_post_done)
      {
         b_post_done = true;

         GObject::emitPost(_module, null/*_program*/, _parents);

         if(current_project.b_export)
         {
            local String sEnvVar <= getVarName();

            current_project.exportAddEnvelope(_module,
                                              sEnvVar+"_val",
                                              curve_envs.get(0)
                                              );

         }
         else
         {
            updateEnvVars();
         }
      }
   }

}
