// ----
// ---- file   : gconstantvec4.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel. 
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See 
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 12Jun2020
// ---- changed: 13Jun2020, 14Jun2020, 15Jun2020, 16Jun2020, 18Jun2020, 21Jun2020, 09Jul2020
// ----          20Jul2020, 14Aug2020
// ----
// ----
// ----
module MGConstantVec4;

use namespace ui;
use namespace gledit;


// <class.png>
class GConstantVec4 : GConstant {

   // <method_new.png>
   public static New() : GConstantVec4 {
      local GConstantVec4 r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GConstant::init();
      type = TYPE_VEC4;

      addParamFloat("x", "x", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamFloat("y", "y", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamFloat("z", "z", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamFloat("w", "w", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamBool("normalize", "normalize", false);

      addInput("x", TYPE_FLOAT);
      addInput("y", TYPE_FLOAT);
      addInput("z", TYPE_FLOAT);
      addInput("w", TYPE_FLOAT);

      addInput("xyzw", TYPE_VEC4);
      addInput("transform", TYPE_MAT4);

      addOutput(GOutput.OUT_DEF, type);
   }

   // <method_get.png>
   public virtual getString() : String {
      float x = getFloatParamById("x");
      float y = getFloatParamById("y");
      float z = getFloatParamById("z");
      float w = getFloatParamById("w");
      return "vec4("+x+", "+y+", "+z+", "+w+")";
   }

   // <method.png>
   public virtual emit(local String       _outputId, 
                       local GModule      _module, 
                       local GProgram     _program, 
                       local String       _out, 
                       local String       _dstVar, 
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {
      float x = getFloatParamById("x");
      float y = getFloatParamById("y");
      float z = getFloatParamById("z");
      float w = getFloatParamById("w");
      boolean bNormalize = getBoolParamById("normalize");

      _parents.add(this);
      local GInput *input;

      // x
      local String *sX;
      input <= getInputById("x");
      if(input.isConnected())
      {
         sX <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_x");
         input.emit(_module, _program, _out, sX, _bGLSL, _parents);
         _out.append(sX+" += "+x+";\n");
      }
      else
         sX <= String(x);

      // y
      local String *sY;
      input <= getInputById("y");
      if(input.isConnected())
      {
         sY <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_y");
         input.emit(_module, _program, _out, sY, _bGLSL, _parents);
         _out.append(sY+" += "+y+";\n");
      }
      else
         sY <= String(y);

      // z
      local String *sZ;
      input <= getInputById("z");
      if(input.isConnected())
      {
         sZ <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_z");
         input.emit(_module, _program, _out, sZ, _bGLSL, _parents);
         _out.append(sZ+" += "+z+";\n");
      }
      else
         sZ <= String(z);

      // w
      local String *sW;
      input <= getInputById("w");
      if(input.isConnected())
      {
         sW <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_w");
         input.emit(_module, _program, _out, sW, _bGLSL, _parents);
         _out.append(sW+" += "+w+";\n");
      }
      else
         sW <= String(w);

      // xyzw
      local String *sXYZW;
      input <= getInputById("xyzw");
      if(input.isConnected())
      {
         sXYZW <= _module.allocTmpVarScript(_out, TYPE_VEC4, "in_xyzw");
         input.emit(_module, _program, _out, sXYZW, _bGLSL, _parents);

         if(_bGLSL)
         {
            if(bNormalize)
            {
               _out.append(_dstVar+" = normalize(vec2("+sX+"+"+sXYZW+".x, "+sY+"+"+sXYZW+".y, "+sZ+"+"+sXYZW+".z, "+sW+"+"+sXYZW+".w));\n");
            }
            else
            {
               _out.append(_dstVar+" = vec2("+sX+"+"+sXYZW+".x, "+sY+"+"+sXYZW+".y, "+sZ+"+"+sXYZW+".z, "+sW+"+"+sXYZW+".w);\n");
            }
         }
         else
         {
            _out.append(_dstVar+" = vector2f("+sX+"+"+sXYZW+".x, "+sY+"+"+sXYZW+".y, "+sZ+"+"+sXYZW+".z, "+sW+"+"+sXYZW+".w);\n");
            if(bNormalize)
               _out.append(_dstVar+".unit();\n");
         }
      }
      else
      {
         if(_bGLSL)
         {
            if(bNormalize)
            {
               _out.append(_dstVar+" = normalize(vec3("+sX+", "+sY+", "+sZ+", "+sW+"));\n");
            }
            else
            {
               _out.append(_dstVar+" = vec3("+sX+", "+sY+", "+sZ+", "+sW+");\n");
            }
         }
         else
         {
            _out.append(_dstVar+" = vector3f("+sX+", "+sY+", "+sZ+", "+sW+");\n");
            if(bNormalize)
               _out.append(_dstVar+".unit();\n");
         }
      }

      input <= getInputById("transform");
      if(input.isConnected())
      {
         local String sTransform <= _module.allocTmpVarScript(_out, TYPE_MAT4, "in_transform");
         input.emit(_module, _program, _out, sTransform, _bGLSL, _parents);
         _out.append(_dstVar+" = "+sTransform+" * "+_dstVar+";\n");
      }

      _parents.remove(this);
   }
}
