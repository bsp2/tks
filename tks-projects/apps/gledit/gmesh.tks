// ----
// ---- file   : gmesh.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 12Jun2020
// ---- changed: 13Jun2020, 14Jun2020, 15Jun2020, 16Jun2020, 18Jun2020, 19Jun2020, 20Jun2020
// ----          21Jun2020, 27Jun2020, 09Aug2020, 14Aug2020
// ----
// ----
// ----
module MGMesh;

use namespace ui;
use namespace gledit;


// <class.png>
class GMesh : GObject, GParamProvider {

   protected String *emit_s_init;       // valid during emit
   protected Buffer *emit_data;
   protected int     emit_pitch;


   // <method_init.png>
   public virtual init() {
      GObject::init();

      // // addParamBool("emit_normal", "Normal", true);
      // // addParamBool("emit_color",  "Color",  true);
      // // addParamBool("emit_uv",     "UV",     true);

      addOutput(GOutput.OUT_DEF_OBJ, TYPE_REF);
   }

   // <method_get.png>
   public method getDefaultOutputId() : String {
      return "position";
   }

   // <method_get.png>
   public virtual getObjectPathVirtFolder() : String {
      return "meshes";
   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "mesh";
   }

   // <method_get.png>
   public virtual getIdString() : String {
      return "<"+yacMetaClassName().replace("GMesh_","")+">"+getId();
   }

   // <method_get.png>
   public virtual getString() : String {
      return "<"+yacMetaClassName().replace("GMesh_","")+">"+getId()+" #vert="+getNumVertices()+" #ind="+getNumIndices()+" #tri="+getNumTriangles();
   }

   // <method.png>
   public virtual getVarName() : String {
      return getNamespacePrefix()+"_mesh_"+id;
   }

   // <method_get.png>
   public method getNumVertices() : int {
   }

   // <method_get.png>
   public method getNumIndices() : int {
      return 0;
   }

   // <method_get.png>
   public method getNumTriangles() : int {
      // utility function, calculates #triangles from draw mode and num vertices/num indices
      int count = getNumIndices();
      if(0 == count)
         count = getNumVertices();
      int glMode = getGLMode();
      switch(glMode)
      {
         default:
            trace "[---] GMesh::getNumTriangles: invalid mode "+getGLModeName()+" ("+glMode+") this="+#(this)+" id="+id;
            break;

         case GL_POINTS:
            return count * 2;  // (note) points are not necessarily drawn as triangles.. but anyway

         case GL_TRIANGLES:
            return count / 3;

         case GL_TRIANGLE_STRIP:
            return (count - 2);

         case GL_TRIANGLE_FAN:
            return (count - 2);

         case GL_QUADS:
            return (count / 4);

         case GL_QUAD_STRIP:
            return (count - 2) / 2;

         case GL_POLYGON:
            return (count - 2);

         case GL_LINES:
            return (count / 2) * 2;  // (note) lines are not necessarily drawn as triangles.. but anyway

         case GL_LINE_STRIP:
            return (count - 1);

         case GL_LINE_LOOP:
            return (count / 2) * 2 + 2;  // (note) lines are not necessarily drawn as triangles.. but anyway
      }
   }

   // <method_get.png>
   public method getGLMode() : int {
      // should not be reachable
      return GL_NONE;
   }

   // <method_get.png>
   public method getGLModeName() : String {
      int glMode = getGLMode();
      switch(glMode)
      {
         default:
            return "<ill mode "+glMode+" this="+#(this)+" id="+id+">";
         case GL_POINTS:         return "GL_POINTS";
         case GL_TRIANGLES:      return "GL_TRIANGLES";
         case GL_TRIANGLE_STRIP: return "GL_TRIANGLE_STRIP";
         case GL_TRIANGLE_FAN:   return "GL_TRIANGLE_FAN";
         case GL_QUADS:          return "GL_QUADS";
         case GL_QUAD_STRIP:     return "GL_QUAD_STRIP";
         case GL_POLYGON:        return "GL_POLYGON";
         case GL_LINES:          return "GL_LINES";
         case GL_LINE_STRIP:     return "GL_LINE_STRIP";
         case GL_LINE_LOOP:      return "GL_LINE_LOOP";
      }
   }

   // <method.png>
   protected method emitBeginAttribData(String _sInit, GBuffer _buffer, int _pitch) {
      emit_s_init  <= _sInit;
      emit_data    <= _buffer.data;
      emit_pitch   = _pitch;
   }

   // <method.png>
   protected method emitFloat(Integer  _offset,
                              float    _f
                              ) {
      // emit_s_init.append(emit_aBufVarData+".offset = "+_offset+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_f+";\n");
      emit_data.offset = _offset;
      emit_data.f32    = _f;
      _offset += emit_pitch;
   }

   // <method.png>
   protected method emitVec2(Integer  _offset,
                             float    _x,
                             float    _y
                             ) {
      // emit_s_init.append(emit_aBufVarData+".offset = "+_offset+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_x+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_y+";\n");
      emit_data.offset = _offset;
      emit_data.f32    = _x;
      emit_data.f32    = _y;
      _offset += emit_pitch;
   }

   // <method.png>
   protected method emitVec3(Integer  _offset,
                             float    _x,
                             float    _y,
                             float    _z
                             ) {
      // emit_s_init.append(emit_aBufVarData+".offset = "+_offset+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_x+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_y+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_z+";\n");
      emit_data.offset = _offset;
      emit_data.f32    = _x;
      emit_data.f32    = _y;
      emit_data.f32    = _z;
      _offset += emit_pitch;
   }

   // <method.png>
   protected method emitVec3v(Integer  _offset,
                              Vector3f _v
                              ) {
      emit_data.offset = _offset;
      emit_data.f32    = _v.x;
      emit_data.f32    = _v.y;
      emit_data.f32    = _v.z;
      _offset += emit_pitch;
   }

   // <method.png>
   protected method emitVec4(Integer  _offset,
                             float    _x,
                             float    _y,
                             float    _z,
                             float    _w
                             ) {
      // emit_s_init.append(emit_aBufVarData+".offset = "+_offset+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_x+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_y+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_z+";\n");
      // emit_s_init.append(emit_aBufVarData+".f32 = "+_w+";\n");
      emit_data.offset = _offset;
      emit_data.f32    = _x;
      emit_data.f32    = _y;
      emit_data.f32    = _z;
      emit_data.f32    = _w;
      _offset += emit_pitch;
   }

   // <method.png>
   protected method emitUByteVec4(Integer  _offset,
                                  int      _abgr  // == (x,y,z,w) / (r,g,b,a) order in little endian memory
                                  ) {
      Integer io = _abgr;
      // trace "xxx emitUByteVec4: abgr=#"+io.printf("%08x");
      // emit_s_init.append(emit_aBufVarData+".offset = "+_offset+";\n");
      // emit_s_init.append(emit_aBufVarData+".i32 = "+_abgr+";\n");
      emit_data.offset = _offset;
      emit_data.i32    = _abgr;
      _offset += emit_pitch;
   }

   // <method.png>
   protected method emitEndAttribData() {
   }

   // <method.png>
   public method emitPrepareAttribBuffer(GModule  _module,
                                         GModel   _model,
                                         GProgram _program,
                                         String   _sInit,
                                         GBuffer  _buffer,
                                         int      _pitch
                                         ) {
   }

   // <method.png>
   protected method emitBeginIndexData(String _sInit, GBuffer _buffer) {
      emit_s_init <= _sInit;
      emit_data   <= _buffer.data;
   }

   // <method.png>
   public method emitPrepareIndexBuffer(GModule _module, GModel _model, String _sInit, GBuffer _buffer) {
   }

   // <method.png>
   protected method emitIndex32(int _idx) {
      // emit_s_init.append(emit_aBufVarData+".i32 = "+_idx+";\n");
      // trace "xxx emitIndex32("+_idx+")";
      emit_data.i32 = _idx;
   }

   // <method.png>
   protected method emitEndIndexData() {
   }

   // <save.png>
   public virtual saveStateObject(local Stream ofs, local GConnectionWriter connectionWriter) {
      GObject::saveStateObject(ofs, connectionWriter);

      // Version
      ofs.i16 = 1;

      // Params
      GParamProvider::saveStateParamProvider(ofs, connectionWriter);
   }

   // <load.png>
   public virtual loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject

      // Version
      short ver = ifs.u16;

      if(1 <= ver <= 1)
      {
         // Params
         if(!GParamProvider::loadStateParamProvider(ifs))
         {
            trace "[---] GMesh::loadStateObject: failed to load params, this="+#(this)+" path="+getObjectPath();
            return false;
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] GMesh::loadStateObject: invalid version "+ver+", this="+#(this)+" path="+getObjectPath();
      }
      return false;
   }

}
