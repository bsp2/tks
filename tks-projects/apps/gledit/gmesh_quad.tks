// ----
// ---- file   : gmesh_quad.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----           generates GL_TRIANGLE_FAN with subdiv=0
// ----           and indexed GL_TRIANGLES with subdiv>0
// ----
// ---- created: 12Jun2020
// ---- changed: 13Jun2020, 19Jun2020, 21Jun2020, 27Jun2020, 11Jul2020, 25Jul2020, 09Aug2020
// ----          14Aug2020
// ----
// ----
// ----
module MGMesh_Quad;

use namespace ui;
use namespace gledit;


// <class.png>
class GMesh_Quad : GMesh {

   // <method_new.png>
   static New() : GMesh_Quad {
      local GMesh_Quad r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GMesh::init();

      addParamFloat("width",  "width",  1.0, 0.00001, 0.0001, 10.0, 1000.0, 1.0);
      addParamFloat("height", "height", 1.0, 0.00001, 0.0001, 10.0, 1000.0, 1.0);
      addParamIntSimple("subdiv_x", 0, 0, 99);
      addParamIntSimple("subdiv_y", 0, 0, 99);

      addParamFloat("off_x", "Offset X", 0.0, -10.0, -1000.0, 10.0, 1000.0, 0.0);
      addParamFloat("off_y", "Offset Y", 0.0, -10.0, -1000.0, 10.0, 1000.0, 0.0);

      addOutput("position", TYPE_VEC2);
      addOutput("normal",   TYPE_VEC3);
      addOutput("uv",       TYPE_VEC2);
      addOutput("color",    TYPE_VEC4);
   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "quad";
   }

   // <method_get.png>
   public virtual getNumVertices() : int {
      int subdivX = getIntParamById("subdiv_x");
      int subdivY = getIntParamById("subdiv_y");
      return ((2+subdivX) * (2+subdivY));
   }

   // <method_get.png>
   public method getNumIndices() : int {
      int subdivX = getIntParamById("subdiv_x");
      int subdivY = getIntParamById("subdiv_y");
      return ((subdivX > 0) || (subdivY > 0)) ? ( (3*2*(1+subdivX)) * (1+subdivY) ) : 0;
   }

   // <method_get.png>
   public method getGLMode() : int {
      int subdivX = getIntParamById("subdiv_x");
      int subdivY = getIntParamById("subdiv_y");
      return ((0 == subdivX) && (0 == subdivY)) ? GL_TRIANGLE_FAN : GL_TRIANGLES;
   }

   // <method.png>
   public virtual emitPrepareAttribBuffer(GModule  _module,
                                          GModel   _model,
                                          GProgram _program,
                                          String   _sInit,
                                          GBuffer  _buffer,
                                          int      _pitch
                                          ) {
      Integer offPosition = _model.getAttributeOffsetById("position");

      boolean bNormal = /*getBoolParamById("emit_normal") && */_program.hasAttribute("normal");
      boolean bColor  = /*getBoolParamById("emit_color")  && */_program.hasAttribute("color");
      boolean bUV     = /*getBoolParamById("emit_uv")     && */_program.hasAttribute("uv");

      Integer offNormal = bNormal ? _model.getAttributeOffsetById("normal") : -1;
      Integer offColor  = bColor  ? _model.getAttributeOffsetById("color")  : -1;
      Integer offUV     = bUV     ? _model.getAttributeOffsetById("uv")     : -1;

      // trace "xxx mesh bUV="+bUV+" offUV="+offUV;

      float width   = getFloatParamById("width");
      float height  = getFloatParamById("height");
      int   subdivX = getIntParamById("subdiv_x");
      int   subdivY = getIntParamById("subdiv_y");
      float offX    = getFloatParamById("off_x");
      float offY    = getFloatParamById("off_y");

      float w = (2.0f * width) / (1+subdivX);
      float h = (2.0f * height) / (1+subdivY);

      float cy = -height + offY;
      float cx;
      float cu;
      float cv = 0.0;
      float uStep = 1.0 / (1+subdivX);
      float vStep = 1.0 / (1+subdivY);

      emitBeginAttribData(_sInit, _buffer, _pitch);

      if((0 == subdivX) && (0 == subdivY))
      {
         cu = 0.0;
         cx = -width + offX;

         // trace "xxx 1 cx="+cx+" cy="+cy;

         emitVec2(offPosition, cx, cy);
         if(bNormal)
            emitVec3(offNormal, 0,0,1);
         if(bColor)
            emitVec4(offColor, 1,1,1,1);
         if(bUV)
            emitVec2(offUV, cu, cv);

         // trace "xxx 2 cx="+cx+" cy="+(cy+h);

         emitVec2(offPosition, cx, (cy+h));
         if(bNormal)
            emitVec3(offNormal, 0,0,1);
         if(bColor)
            emitVec4(offColor, 1,1,1,1);
         if(bUV)
            emitVec2(offUV, cu, cv+vStep);

         // trace "xxx 3 cx="+(cx+w)+" cy="+(cy+h);

         emitVec2(offPosition, (cx+w), (cy+h));
         if(bNormal)
            emitVec3(offNormal, 0,0,1);
         if(bColor)
            emitVec4(offColor, 1,1,1,1);
         if(bUV)
            emitVec2(offUV, cu+uStep, cv+vStep);

         // trace "xxx 4 cx="+(cx+w)+" cy="+cy;

         emitVec2(offPosition, (cx+w), cy);
         if(bNormal)
            emitVec3(offNormal, 0,0,1);
         if(bColor)
            emitVec4(offColor, 1,1,1,1);
         if(bUV)
            emitVec2(offUV, cu+uStep, cv);
      }
      else
      {
         // (dont) emit code, that fills the array via nested loops
         //          ==> on second thought: no, don't.
         // _sInit.append("// fill "+_aBufVarData+" mode=GL_TRIANGLES indexType=GL_UNSIGNED_INT w="+width+" h="+height+" subdiv="+subdiv+"\n");
         loop(2+subdivY)
         {
            cx = -width + offX;
            cu = 0;
            loop(2+subdivX)
            {
               emitVec2(offPosition, cx, cy);
               if(bNormal)
                  emitVec3(offNormal, 0,0,1);
               if(bColor)
                  emitVec4(offColor, 1,1,1,1);
               if(bUV)
                  emitVec2(offUV, cu, cv);

               cx += w;
               cu += uStep;
            }
            cy += h;
            cv += vStep;
         }
      }

      emitEndAttribData();
   }

   // <method.png>
   public virtual emitPrepareIndexBuffer(GModule _module, GModel _model, String _sInit, GBuffer _buffer) {

      int subdivX = getIntParamById("subdiv_x");
      int subdivY = getIntParamById("subdiv_y");

      emitBeginIndexData(_sInit, _buffer);

      int cy = 0;
      int w = (2 + subdivX);
      // _sInit.append(_aBufVarData+".offset = 0;\n");
      _buffer.data.setOffset(0);
      loop(1+subdivY)
      {
         int cx = 0;
         loop(1+subdivX)
         {
            // tri 1
            emitIndex32(cy + cx + 0);
            emitIndex32(cy + cx + w + 0);
            emitIndex32(cy + cx + w + 1 + 0);

            // tri 2
            emitIndex32(cy + cx + 0);
            emitIndex32(cy + cx + w + 1);
            emitIndex32(cy + cx + 1);

            cx++;
         }
         cy += w;
      }

      emitEndIndexData();
   }

}
