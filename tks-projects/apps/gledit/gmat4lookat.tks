// ----
// ---- file   : gmat4lookat.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 20Jul2020
// ---- changed: 09Aug2020, 14Aug2020
// ----
// ----
// ----
module MGMat4LookAt;

use namespace ui;
use namespace gledit;


// <class.png>
class GMat4LookAt : GConstant {
   protected boolean b_fxn_done;

   // <method_new.png>
   public static New() : GMat4LookAt {
      local GMat4LookAt r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GObject::init();
      type = TYPE_MAT4;

      addParamFloat("eye_x",  "Eye X",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("eye_y",  "Eye Y",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("eye_z",  "Eye Z",   0.0, -100, -10000, 100.0, 10000.0, 0.0);

      addParamFloat("center_x",  "Center X",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("center_y",  "Center Y",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("center_z",  "Center Z",  -1.0, -100, -10000, 100.0, 10000.0, 0.0);

      addParamFloat("translate_x",  "Translate X",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("translate_y",  "Translate Y",   0.0, -100, -10000, 100.0, 10000.0, 0.0);
      addParamFloat("translate_z",  "Translate Z",   0.0, -100, -10000, 100.0, 10000.0, 0.0);

      addParamFloat("up_x",  "Up X",   0.0, -10, -100, 10.0, 100.0, 0.0);
      addParamFloat("up_y",  "Up Y",   1.0, -10, -100, 10.0, 100.0, 0.0);
      addParamFloat("up_z",  "Up Z",   0.0, -10, -100, 10.0, 100.0, 0.0);

      addInput("eye",       TYPE_VEC3);
      addInput("center",    TYPE_VEC3);
      addInput("translate", TYPE_VEC3);
      addInput("up",        TYPE_VEC3);

      addOutput(GOutput.OUT_DEF, type);
   }

   // <method_get.png>
   public virtual getString() : String {
      return "lookat center=("+getFloatParamById("center_x")+";"+getFloatParamById("center_y")+";"+getFloatParamById("center_z")+")";
   }

   // <method.png>
   public virtual emitBegin() {
      b_fxn_done = false;
   }

   // <method.png>
   public method emit(local String       _outputId,
                      local GModule      _module,
                      local GProgram     _program,
                      local String       _out,
                      local String       _dstVar,
                      local boolean      _bGLSL,
                      local PointerArray _parents
                      ) {
      float eyeX = getFloatParamById("eye_x");
      float eyeY = getFloatParamById("eye_y");
      float eyeZ = getFloatParamById("eye_z");

      float centerX = getFloatParamById("center_x");
      float centerY = getFloatParamById("center_y");
      float centerZ = getFloatParamById("center_z");

      float translateX = getFloatParamById("translate_x");
      float translateY = getFloatParamById("translate_y");
      float translateZ = getFloatParamById("translate_z");

      float upX = getFloatParamById("up_x");
      float upY = getFloatParamById("up_y");
      float upZ = getFloatParamById("up_z");

      _out.append("// GMat4LookAt id="+getObjectPathDir()+"\n");

      if(_bGLSL)
      {
         _out.append("ERROR: GMat4LookAt not supported in GLSL mode");
      }

      GInput *input;

      if(!b_fxn_done)
      {
         b_fxn_done = true;

         // local String sFunction;

         // // sFunction.append("\nfunction CalcMat4Ortho(Matrix4f _d, float w, float h, float d) {\n");
         // // sFunction.append(
         // //    "   float left   = -w;\n"
         // //    "   float right  =  w;\n"
         // //    "   float bottom = -h;\n"
         // //    "   float top    =  h;\n"
         // //    "   float znear  = -d;\n"
         // //    "   float zfar   =  d;\n"
         // //    "\n"
         // //    "   float tx = (right + left) / (right - left);\n"
         // //    "   float ty = (top + bottom) / (top - bottom);\n"
         // //    "   float tz = (zfar + znear) / (zfar - znear);\n"
         // //    "\n"
         // //    "   float sx = 2.0f / (right - left);\n"
         // //    "   float sy = 2.0f / (top - bottom);\n"
         // //    "   float sz = -2.0f / (zfar - znear);\n"
         // //    "\n"
         // //    "    _d = [sx,0,0,0, 0,sy,0,0, 0,0,sz,0, tx, ty, tz, 1];\n"
         // //    "}\n"
         // //                  );
         // // _module.appendGlobalOnce("CalcMat4Ortho", sFunction);
      }

      _parents.add(this);

      local String sEye       <= _module.allocTmpVarScript(_out, TYPE_VEC3, "in_eye");
      local String sCenter    <= _module.allocTmpVarScript(_out, TYPE_VEC3, "in_center");
      local String sTranslate <= _module.allocTmpVarScript(_out, TYPE_VEC3, "in_translate");
      local String sUp        <= _module.allocTmpVarScript(_out, TYPE_VEC3, "in_up");

      // translate
      input <= getInputById("translate");
      if(input.isConnected())
      {
         input.emit(_module, _program, _out, sTranslate, _bGLSL, _parents);
         if(0.0 != translateX)
            _out.append(sTranslate+".x = "+sTranslate+".x + "+translateX+";\n");
         if(0.0 != translateY)
            _out.append(sTranslate+".y = "+sTranslate+".y + "+translateY+";\n");
         if(0.0 != translateX)
            _out.append(sTranslate+".z = "+sTranslate+".z + "+translateZ+";\n");
      }
      else
      {
         _out.append(sTranslate+".init("+translateX+", "+translateY+", "+translateZ+");\n");
      }

      // eye
      input <= getInputById("eye");
      if(input.isConnected())
      {
         input.emit(_module, _program, _out, sEye, _bGLSL, _parents);
         if(0.0f != eyeX)
            _out.append(sEye+".x = "+sEye+".x + "+eyeX+";\n");
         if(0.0f != eyeY)
            _out.append(sEye+".y = "+sEye+".y + "+eyeY+";\n");
         if(0.0f != eyeZ)
            _out.append(sEye+".z = "+sEye+".z + "+eyeZ+";\n");
      }
      else
      {
         _out.append(sEye+".init("+eyeX+", "+eyeY+", "+eyeZ+");\n");
      }
      _out.append(sEye+".add("+sTranslate+");\n");

      // center
      input <= getInputById("center");
      if(input.isConnected())
      {
         input.emit(_module, _program, _out, sCenter, _bGLSL, _parents);
         if(0.0f != centerX)
            _out.append(sCenter+".x = "+sCenter+".x + "+centerX+";\n");
         if(0.0f != centerY)
            _out.append(sCenter+".y = "+sCenter+".y + "+centerY+";\n");
         if(0.0f != centerZ)
            _out.append(sCenter+".z = "+sCenter+".z + "+centerZ+";\n");
      }
      else
      {
         _out.append(sCenter+".init("+centerX+", "+centerY+", "+centerZ+");\n");
      }
      _out.append(sCenter+".add("+sTranslate+");\n");

      // up
      input <= getInputById("up");
      if(input.isConnected())
      {
         input.emit(_module, _program, _out, sUp, _bGLSL, _parents);
         if(0.0f != upX)
            _out.append(sUp+".x = "+sUp+".x + "+upX+";\n");
         if(0.0f != upY)
            _out.append(sUp+".y = "+sUp+".y + "+upY+";\n");
         if(0.0f != upZ)
            _out.append(sUp+".z = "+sUp+".z + "+upZ+";\n");
      }
      else
      {
         _out.append(sUp+".init("+upX+", "+upY+", "+upZ+");\n");
      }

      _out.append("Matrix4f.BuildLookAtMatrix4f("+sEye+", "+sCenter+", "+sUp+") => "+_dstVar+";\n");

      _parents.remove(this);
   }
}
