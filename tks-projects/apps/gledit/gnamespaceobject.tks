// ----
// ---- file   : gnamespaceobject.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 12Jun2020
// ---- changed: 14Jun2020, 15Jun2020, 19Jun2020, 22Jun2020, 28Jun2020, 10Jul2020, 12Jul2020
// ----          13Jul2020, 25Jul2020, 02Aug2020, 03Aug2020, 09Feb2025
// ----
// ----
// ----
module MGNamespaceObject;

use namespace ui;
use namespace gledit;


// <class.png>
class GNamespaceObject : GDefs {
   protected GNamespace *parent_namespace;

   protected boolean   b_ui_folded;
   protected HashTable ui_virt_folder_folded;  // "args", "constants", ..


   // <method_set.png>
   public method setNamespace(GNamespace _nsp) {
      parent_namespace <= _nsp;
   }

   // <method_get.png>
   public method getNamespace() : GNamespace {
      return parent_namespace;
   }

   // <method_get.png>
   public method getRootNamespace() : GNamespace {
      GNamespaceObject r <= this;
      while(null != r.parent_namespace)
         r <= r.parent_namespace;
      return r;
   }

   // <method_get.png>
   public method getParent() : GNamespaceObject {
      // default implementation. a GVertexSource object returns its parent GVertexShader for example.
      // used when moving objects
      return parent_namespace;
   }

   // <method_get.png>
   public method getRootModel() : GModel {
      if(this instanceof GModel)
         return this;
      GNamespaceObject r <= this;
      while(null != r)
      {
         r <= r.parent_namespace;
         if(r instanceof GModel)
            return r;
      }
      return r;
   }

   // <method_get.png>
   public method getRootScene() : GScene {
      if(this instanceof GScene)
         return this;
      GNamespaceObject r <= this;
      while(null != r)
      {
         r <= r.parent_namespace;
         if(r instanceof GScene)
            return r;
      }
      return r;
   }

   // <method_get.png>
   protected method getNamespacePrefixInt(String _sep) : String {
      local String r;
      // // if(this instanceof GObject)
      // // {
      // //    GObject thisObj <= this;
      // //    r.append(this.getObjectPathVirtFolder());
      // //    if(!r.isBlank())
      // //       r.append(_sep);
      // // }
      GNamespace nsp <= getNamespace();
      int i = 0;
      while(null != nsp)
      {
         // trace "xxx pfx: nsp.getNamespaceId()=\""+nsp.getNamespaceId()+"\" nsp="+#(nsp);
         if(0 == i++)
            r = nsp.getNamespaceId();
         else
            r <= nsp.getNamespaceId()+_sep+r;
         nsp <= nsp.getNamespace();
      }
      // trace "xxx r=\""+r+"\"";
      return deref r;
   }

   // <method_get.png>
   public method getNamespacePrefix() : String {
      return getNamespacePrefixInt("_");
   }

   // <method_get.png>
   public method getNamespacePrefixDot() : String {
      return getNamespacePrefixInt(".");
   }

   // <method.png>
   public method handleWatchFileChanged(local String _pathName) {
   }

   // <method.png>
   public method emitBeginRecursive() {
   }

   // <method_find.png>
   public method enumerateObjects(local PointerArray _ret, local int _recurseDepthLeft) {
   }

   // <method_set.png>
   public method setFoldStatus(boolean _bFolded) {
      // trace "xxx setFoldStatus: this="+#(this)+" bFolded="+_bFolded;
      b_ui_folded = _bFolded;
   }

   // <method_get.png>
   public method isFolded() : boolean {
      // trace "xxx getFoldStatus: this="+#(this)+" bFolded="+b_ui_folded;
      return b_ui_folded;
   }

   // <method_set.png>
   public method setVirtFolderFoldStatus(String _name, boolean _bFolded) {
      ui_virt_folder_folded[_name] = _bFolded;
   }

   // <method_set.png>
   public method setAllVirtFolderFoldStatus(boolean _bFolded) {
   }

   // <method_get.png>
   public method isVirtFolderFolded(String _name) : boolean {
      boolean r;
      if(ui_virt_folder_folded.exists(_name))
      {
         r = ui_virt_folder_folded.get(_name);
         // trace "xxx getVirtFoldStatus: this="+#(this)+" name=\""+_name+"\" CACHE bFolded="+r;
      }
      else
      {
         r = true;
         // trace "xxx getVirtFoldStatus: this="+#(this)+" name=\""+_name+"\" FORCE bFolded="+r;
      }
      return r;
   }

   // <method_set.png>
   public method getVirtFolderFoldedHashTable() : HashTable {
      return ui_virt_folder_folded;
   }

   // <method.png>
   public method hasSubObjects() : boolean {
      // derived class should return true to indicate that e.g. a namespace has sub objects
      //  (note) used to determine initial folder status (e.g. unfold renderpass if child folders are hidden and there are no sub objects)
      return false;
   }

}
