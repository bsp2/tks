// ----
// ---- file   : gmesh_tri.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel. 
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See 
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 26Jul2020
// ---- changed: 14Aug2020
// ----
// ----
// ----
module MGMesh_Tri;

use namespace ui;
use namespace gledit;


// <class.png>
class GMesh_Tri : GMesh {

   // <method_new.png>
   static New() : GMesh_Tri {
      local GMesh_Tri r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GMesh::init();

      addParamFloat("width",  "width",  1.0, 0.00001, 0.0001, 10.0, 1000.0, 1.0);
      addParamFloat("height", "height", 1.0, 0.00001, 0.0001, 10.0, 1000.0, 1.0);

      addParamFloat("off_x", "Offset X", 0.0, -10.0, -1000.0, 10.0, 1000.0, 0.0);
      addParamFloat("off_y", "Offset Y", 0.0, -10.0, -1000.0, 10.0, 1000.0, 0.0);

      addOutput("position", TYPE_VEC2);
      addOutput("normal",   TYPE_VEC3);
      addOutput("uv",       TYPE_VEC2);
      addOutput("color",    TYPE_VEC4);
   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "tri";
   }

   // <method_get.png>
   public virtual getNumVertices() : int {
      return 3;
   }

   // <method_get.png>
   public method getNumIndices() : int {
      return 0;
   }

   // <method_get.png>
   public method getGLMode() : int {
      return GL_TRIANGLES;
   }

   // <method.png>
   public virtual emitPrepareAttribBuffer(GModule  _module, 
                                          GModel   _model, 
                                          GProgram _program,
                                          String   _sInit, 
                                          GBuffer  _buffer, 
                                          int      _pitch
                                          ) {
      Integer offPosition = _model.getAttributeOffsetById("position");

      boolean bNormal = /*getBoolParamById("emit_normal") && */_program.hasAttribute("normal");
      boolean bColor  = /*getBoolParamById("emit_color")  && */_program.hasAttribute("color");
      boolean bUV     = /*getBoolParamById("emit_uv")     && */_program.hasAttribute("uv");

      Integer offNormal = bNormal ? _model.getAttributeOffsetById("normal") : -1;
      Integer offColor  = bColor ? _model.getAttributeOffsetById("color") : -1;
      Integer offUV     = bUV ? _model.getAttributeOffsetById("uv") : -1;

      // trace "xxx mesh bUV="+bUV+" offUV="+offUV;

      float width   = getFloatParamById("width");
      float height  = getFloatParamById("height");
      float offX    = getFloatParamById("off_x");
      float offY    = getFloatParamById("off_y");

      emitBeginAttribData(_sInit, _buffer, _pitch);

      float cx;
      float cy;

      cx = -width + offX;
      cy = -height + offY;
      emitVec2(offPosition, cx, cy);
      if(bNormal)
         emitVec3(offNormal, 0,0,1);
      if(bColor)
         emitVec4(offColor, 1,1,1,1);
      if(bUV)
         emitVec2(offUV, 0, 0);

      cx = 0 + offX;
      cy = height + offY;
      emitVec2(offPosition, cx, cy);
      if(bNormal)
         emitVec3(offNormal, 0,0,1);
      if(bColor)
         emitVec4(offColor, 1,1,1,1);
      if(bUV)
         emitVec2(offUV, 0, 1);

      cx = width + offX;
      cy = -height + offY;
      emitVec2(offPosition, cx, cy);
      if(bNormal)
         emitVec3(offNormal, 0,0,1);
      if(bColor)
         emitVec4(offColor, 1,1,1,1);
      if(bUV)
         emitVec2(offUV, 1.0, 0.0);

      emitEndAttribData();
   }


}
