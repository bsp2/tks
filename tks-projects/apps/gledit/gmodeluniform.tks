// ----
// ---- file   : gmodeluniform.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 01Aug2020
// ---- changed: 02Aug2020, 03Aug2020, 14Aug2020, 08Feb2025
// ----
// ----
// ----
module MGModelUniform;

use namespace ui;
use namespace gledit;


// <class.png>
class GModelUniform : GObject {
   // stored in GModel, output overrides GProgram uniform input
   //
   //  (note) for changing programs while keeping uniform connections
   //  (note) id must match program uniform id (e.g. "tex")
   //

   // <method_new.png>
   static New(String _id, int _type) : GModelUniform {
      local GModelUniform r;
      r.initIdType(_id, _type);
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GObject::init();
      type = TYPE_FLOAT;
      initIO();
   }

   // <method.png>
   public method initIO() {
      inputs.free();
      outputs.free();
      addInput(GInput.IN_DEF, type);
   }

   // <method.png>
   public virtual initIdType(String _id, int _type) {
      // trace "xxx GModelUniform::initIdType: id="+_id+" type="+_type;
      GObject::initIdType(_id, _type);  // calls init()
      initIO();
   }

   // <method_get.png>
   public virtual getInputDomain(String _inputId) : int {
      return DOMAIN_SCRIPT;
   }

   // <method_get.png>
   public virtual getObjectPathVirtFolder() : String {
      return "model_uniforms";
   }

   // <method.png>
   public virtual getVarName() : String {
      return getNamespacePrefix()+"_u_"+id;
   }

   // <method_get.png>
   public virtual getParent() : GNamespaceObject {
      return getNamespace();  // returns parent model
   }

   // <method_get.png>
   public virtual getString() : String {
      return "<"+getGLSLTypeName()+">"+getId();
   }

   // <method_find.png>
   public virtual isConnectedToAnyObject() : boolean {
      // auto-connected to model.getFirstConnectedProgram() object
      return true;
   }

   // <load.png>
   public virtual loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject
      if(GObject::loadStateObject(ifs))
      {
         // trace "xxx GModelUniform::loadStateObject: type="+type;

         // Update input port type
         initIO();
         return true;
      }
      return false;
   }

   // <method_get.png>
   public method needDstVar() : boolean {
      return true;
   }

   // <method.png>
   public method emitModelUniform(local GModule      _module,
                                  local GProgram     _program,
                                  local String       _out,
                                  local String       _dstVar,
                                  local PointerArray _parents
                                  ) {

      local String uniVarName <= getVarName();

      local GUniform uni <= _program.getUniformById(id);
      if(null != uni)
      {
         // // local String sInVar <= _module.allocTmpVarScript(_out, type, "mu_init");
         local GInput inVal <= getInputById("in");
         if(inVal.isConnected())
         {
            _parents.add(this);
            inVal.emit(_module, _program, _out, _dstVar, false/*bGLSL*/, _parents);
            _parents.remove(this);

            // // uni.emitSetUniformFromVar(_module, _out/*out*/, uniVarName, _dstVar);
         }
         else
         {
            trace "[~~~] GModelUniform::emit: id="+id+" input is not connected, skipping initialization..";
            trace "[~~~]                      this="+getObjectPath();
         }
      }
      else
      {
         trace "[~~~] GModelUniform::emit: id="+id+" does not map to a program uniform, skipping..";
         trace "[~~~]                      this="+getObjectPath();
      }
   }
}
