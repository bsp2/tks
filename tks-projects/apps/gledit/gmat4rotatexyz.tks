// ----
// ---- file   : gmat4rotatexyz.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 13Jun2020
// ---- changed: 16Jun2020, 18Jun2020, 24Jun2020, 08Aug2020, 14Aug2020, 04Feb2025
// ----
// ----
// ----
module MGMat4RotateXYZ;

use namespace ui;
use namespace gledit;


// <class.png>
class GMat4RotateXYZ : GConstant, GParamProvider {

   // <method_new.png>
   public static New() : GMat4RotateXYZ {
      local GMat4RotateXYZ r;
      r.init();
      return deref r;
   }

   // <method_new.png>
   public static New3(float _x, float _y, float _z) : GMat4RotateXYZ {
      local GMat4RotateXYZ r;
      r.init();
      r.setFloatParamById("x", _x);
      r.setFloatParamById("y", _y);
      r.setFloatParamById("z", _z);
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GObject::init();
      type = TYPE_MAT4;

      GParamFloat *p;
      p <= addParamFloatSimple("x", 0.0, -360.0, 360.0);
      p.setEnableCyclic(true);
      p <= addParamFloatSimple("y", 0.0, -360.0, 360.0);
      p.setEnableCyclic(true);
      p <= addParamFloatSimple("z", 0.0, -360.0, 360.0);
      p.setEnableCyclic(true);

      // addParamChoice("angle_mode", "Input Mode", 0, ["Rad", "Deg"]);
      addParamChoice("angle_mode", "Scale (tbr)", 0, ["-", "*2PI/360 (tbr)"]);

      addInput("x", TYPE_FLOAT);
      addInput("y", TYPE_FLOAT);
      addInput("z", TYPE_FLOAT);

      addOutput(GOutput.OUT_DEF, type);
   }

   // <method_get.png>
   public virtual getString() : String {
      float x = getFloatParamById("x") * (2PI / 360.0);
      float y = getFloatParamById("y") * (2PI / 360.0);
      float z = getFloatParamById("z") * (2PI / 360.0);
      return "rotxyz("+x+", "+y+", "+z+")";
   }

   // <method.png>
   public method emit(local String       _outputId,
                      local GModule      _module,
                      local GProgram     _program,
                      local String       _out,
                      local String       _dstVar,
                      local boolean      _bGLSL,
                      local PointerArray _objDone
                      ) {
      float x = getFloatParamById("x") * (2PI / 360.0);
      float y = getFloatParamById("y") * (2PI / 360.0);
      float z = getFloatParamById("z") * (2PI / 360.0);
      int angleMode = getChoiceParamById("angle_mode");   // (note) should be removed? angles are always in degrees

      _out.append("// GMat4RotateXYZ id="+getObjectPathDir()+"\n");

      if(_bGLSL)
      {
         throw GNotImplemented "GMat4RotateXYZ GLSL";
      }
      else
      {
         local GInput *input;
         local String *sX;
         local String *sY;
         local String *sZ;

         // x
         input <= getInputById("x");
         if(input.isConnected())
         {
            sX <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_x");
            input.emit(_module, _program, _out, sX, false/*bGLSL*/, _objDone);
            if(1 == angleMode)
               _out.append(sX+" = "+sX+"*(2PI/360.0) + "+x+";\n");
            else
               _out.append(sX+" += "+x+";\n");
         }
         else
            sX <= String(x);

         // y
         input <= getInputById("y");
         if(input.isConnected())
         {
            sY <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_y");
            input.emit(_module, _program, _out, sY, false/*bGLSL*/, _objDone);
            if(1 == angleMode)
               _out.append(sY+" = "+sY+"*(2PI/360.0) + "+y+";\n");
            else
               _out.append(sY+" += "+y+";\n");
         }
         else
            sY <= String(y);

         // z
         input <= getInputById("z");
         // trace "xxx gmat4rotatexyz: inputz="+#(input);
         if(input.isConnected())
         {
            sZ <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_z");
            // _out.append("// gmat4rotatexyz: sZ="+sZ+" call input.emit\n");
            // input.b_debug = 1;
            input.emit(_module, _program, _out, sZ, false/*bGLSL*/, _objDone);
            // input.b_debug = 0;
            // _out.append("// gmat4rotatexyz: END input.emit\n");
            if(1 == angleMode)
               _out.append(sZ+" = "+sZ+"*(2PI/360.0) + "+z+";\n");
            else
               _out.append(sZ+" += "+z+";\n");
         }
         else
            sZ <= String(z);

         // (todo) emit CalcMat4EulerXYZ() function (in preparation for standalone "C" code exporter)
         _out.append(_dstVar+".initEulerXYZ("+sX+", "+sY+", "+sZ+");\n");
         // // _out.append("trace \"xxx EulerXYZmat=\"+"+_dstVar+".string;\n");
      }
   }
}
