// ----
// ---- file   : TextureForm.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL Edit" application.
// ----
// ---- created: 18Jun2020
// ---- changed: 19Jun2020, 20Jun2020, 28Jun2020, 07Jul2020
// ----
// ----
// ----

module MTextureForm;

use namespace ui;
use namespace gledit;


// <class.png>
class TextureForm : XMLForm, ActionProvider {

   define String ACTION_TEXTURE_PATH_CHANGED;

   GTexture *texture;

   protected ComboBox *cm_proctype;
   protected Button   *bt_edit;

   protected Label  *lb_pathname;
   protected Button *bt_browse;
   protected Button *bt_clear;

   protected ComboBox   *cm_target;
   protected FloatParam *fp_width;
   protected FloatParam *fp_height;
   protected FloatParam *fp_depth;
   protected ComboBox   *cm_format;

   protected ComboBox   *cm_flt_min;
   protected ComboBox   *cm_flt_mag;

   protected ComboBox   *cm_wrap_s;
   protected ComboBox   *cm_wrap_t;


   // <ui_init.png>
   public method initTextureForm() : boolean {

      if(!initPakFile("TextureForm.xfm"))
         return false;

      autoResolveIds(this);

      recursiveSetEnableCursorKeyTabCycling(false);

      cm_proctype.setOptions(GTexture.proc_names);
      cm_target  .setOptions(GTexture.target_names);
      cm_format  .setOptions(GTexture.fmt_names);
      cm_flt_min .setOptions(GTexture.flt_names);
      cm_flt_mag .setOptions(GTexture.flt_names);
      cm_wrap_s  .setOptions(GTexture.wrap_names);
      cm_wrap_t  .setOptions(GTexture.wrap_names);

      return true;
   }

   // <ui.png>
   public virtual getProvidedActionNames() : StringArray {
      return [ACTION_TEXTURE_PATH_CHANGED];
   }

   // <method.png>
   protected method provideEdited() {
      provideAction(Action.New(getProvidedActionAlias(ACTION_TEXTURE_PATH_CHANGED), this));
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray _retLayers) {
      _retLayers.joinRR(_retLayers,
                        [
                           cm_proctype,
                           bt_edit,

                           bt_browse,
                           bt_clear,

                           cm_target,
                           fp_width,
                           fp_height,
                           fp_depth,
                           cm_format,
                         ]
                        );
   }

   // <ui_show.png>
   public method showTexture(GTexture _tex) {
      // trace "[trc] TextureForm::showTexture("+#(_tex)+")";
      texture <= _tex;

      boolean bEditable = (null != texture);

      cm_proctype.setEditable(bEditable);
      bt_edit    .setEditable(bEditable);
      bt_browse  .setEditable(bEditable);
      bt_clear   .setEditable(bEditable);
      cm_target  .setEditable(bEditable);
      fp_width   .setEditable(bEditable);
      fp_height  .setEditable(bEditable);
      fp_depth   .setEditable(bEditable);
      cm_format  .setEditable(bEditable);
      cm_flt_min .setEditable(bEditable);
      cm_flt_mag .setEditable(bEditable);
      cm_wrap_s  .setEditable(bEditable);
      cm_wrap_t  .setEditable(bEditable);

      if(bEditable)
      {
         lb_pathname.setCaption(texture.path_name);

         cm_proctype.setSelectedOption(texture.proc_type);
         bt_edit    .setEditable(GTexture.PROC_NONE != texture.proc_type);
         cm_target  .setSelectedOption(texture.tex_target);
         fp_width   .setValue(texture.tex_width);
         fp_height  .setValue(texture.tex_height);
         fp_depth   .setValue(texture.tex_depth);
         cm_format  .setSelectedOption(texture.tex_format);
         cm_flt_min .setSelectedOption(texture.tex_flt_min);
         cm_flt_mag .setSelectedOption(texture.tex_flt_mag);
         cm_wrap_s  .setSelectedOption(texture.tex_wrap_s);
         cm_wrap_t  .setSelectedOption(texture.tex_wrap_t);
      }
      else
      {
         lb_pathname.setCaption("-");

         cm_proctype.setSelectedOption(-1);
         cm_target  .setSelectedOption(-1);
         fp_width   .setValue(-1);
         fp_height  .setValue(-1);
         fp_depth   .setValue(-1);
         cm_format  .setSelectedOption(-1);
         cm_flt_min .setSelectedOption(-1);
         cm_flt_mag .setSelectedOption(-1);
         cm_wrap_s  .setSelectedOption(-1);
         cm_wrap_t  .setSelectedOption(-1);
      }
   }

   // <ui_handle.png>
   protected method handleBrowse() {
      local String *suggestedFile;
      if(Utils.CanFileBeRead(Utils.ToNativePathName(texture.path_name)))  // (note) win32 dialog does not open if file does not exist
      {
         suggestedFile <= Utils.ToNativePathName(texture.path_name);
      }
      trace "[dbg] TextureForm::handleBrowse: TKUI_OpenFileDialog suggestedFile=\""+suggestedFile+"\"";
      suggestedFile <= null;

      String file <= TKUI_OpenFileDialog(current_project.getSuggestedTextureDirectory(),
                                         suggestedFile,
                                         "Select texture image",
                                         ["All Images"],
                                         ["*.png"],
                                         false/*bMultipleSelection*/,
                                         false/*bDirectoriesOnly*/
                                         );
      // trace "xxx selected file="+#(file);
      if(null != file)
      {
         texture.setPathName(Utils.ToProjectPathName(file));
         lb_pathname.setCaption(texture.path_name);
         redraw();

         Global.Print("Texture image file is \""+texture.path_name+"\"");
         current_project.addImageFileToWatchList(texture.path_name);
         provideEdited();
      }

   }

   // <ui_handle.png>
   protected method handleClear() {
      current_project.removeImageFileFromWatchList(texture.path_name);

      texture.setPathName("");
      lb_pathname.setCaption("");
      redraw();

      Global.Print("Clear image file");
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleTargetChanged() {
      texture.setTextureTarget(cm_target.getSelectedOption());
      Global.Print("Texture Target is "+cm_target.getSelectedOptionName());
      texture.reloadTexture();
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleWidthChanged() {
      texture.setTextureWidth(fp_width.getFloatValue());
      Global.Print("Texture Width is "+fp_width.getText());
      texture.reloadTexture();
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleHeightChanged() {
      texture.setTextureHeight(fp_height.getFloatValue());
      Global.Print("Texture Height is "+fp_height.getText());
      texture.reloadTexture();
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleDepthChanged() {
      texture.setTextureDepth(fp_depth.getFloatValue());
      Global.Print("Texture (2D_ARRAY / 3D) Depth is "+fp_depth.getText());
      texture.reloadTexture();
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleFormatChanged() {
      texture.setTextureFormat(cm_format.getSelectedOption());
      Global.Print("Texture Format is "+cm_format.getSelectedOptionName());
      texture.reloadTexture();
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleFltMinChanged() {
      texture.setTextureFilterMin(cm_flt_min.getSelectedOption());
      Global.Print("Texture Min Filter is "+cm_flt_min.getSelectedOptionName());
      texture.reloadTexture(); // (todo) update filter only
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleFltMagChanged() {
      texture.setTextureFilterMag(cm_flt_mag.getSelectedOption());
      Global.Print("Texture Mag Filter is "+cm_flt_mag.getSelectedOptionName());
      texture.reloadTexture(); // (todo) update filter only
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleWrapSChanged() {
      texture.setTextureWrapS(cm_wrap_s.getSelectedOption());
      Global.Print("Texture Wrap S mode is "+cm_wrap_s.getSelectedOptionName());
      texture.reloadTexture(); // (todo) update filter only
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleWrapTChanged() {
      texture.setTextureWrapT(cm_wrap_t.getSelectedOption());
      Global.Print("Texture Wrap T mode is "+cm_wrap_t.getSelectedOptionName());
      texture.reloadTexture(); // (todo) update filter only
      provideEdited();
   }

   // <ui_handle.png>
   protected method handleProcTypeChanged() {
      texture.changeProcType(cm_proctype.getSelectedOption());
      bt_edit.setEditable(GTexture.PROC_NONE != texture.proc_type);
      bt_edit.redraw();

      Global.Print("Procedural texture type is "+cm_proctype.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handleEdit() {

      if(null != texture.proc_state)
      {
         texture.proc_state.showEditor(texture);
         Global.Print("Edit procedural texture class="+(texture.proc_state.yacMetaClassName()));
      }

   }

   // <ui_consume.png>
   public virtual consumeAction(Action _ac) : boolean {

      String acName <= _ac.getActionName();
      ActionProvider ap <= _ac.getActionProvider();

      //trace "xxx TextureForm::consumeAction: acName=\""+acName+"\".";

      switch(@(ap))
      {
         case @(cm_proctype):
            handleProcTypeChanged();
            return true;

         case @(bt_edit):
            handleEdit();
            return true;

         case @(bt_browse):
            handleBrowse();
            return true;

         case @(bt_clear):
            handleClear();
            return true;

         case @(cm_target):
            handleTargetChanged();
            return true;

         case @(fp_width):
            handleWidthChanged();
            return true;

         case @(fp_height):
            handleHeightChanged();
            return true;

         case @(fp_depth):
            handleDepthChanged();
            return true;

         case @(cm_format):
            handleFormatChanged();
            return true;

         case @(cm_flt_min):
            handleFltMinChanged();
            return true;

         case @(cm_flt_mag):
            handleFltMagChanged();
            return true;

         case @(cm_wrap_s):
            handleWrapSChanged();
            return true;

         case @(cm_wrap_t):
            handleWrapTChanged();
            return true;
      }

      return XMLForm::consumeAction(_ac);
   }

}
