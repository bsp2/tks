// ----
// ---- file   : utils.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2009-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL Edit" application.
// ----
// ---- changed: 26Dec2009, 02Jan2010, 29Jan2010, 10Oct2010, 19Jan2011, 07Mar2011, 15Jan2012
// ----          13May2012, 01Jun2013, 03Jun2013, 09Aug2014, 29Sep2014, 23Jan2015, 24Jan2015
// ----          02Feb2015, 19Apr2015, 28Feb2016, 28Mar2016, 04Apr2016, 08Mar2017, 11Mar2017
// ----          14Apr2017, 09Jun2017, 04Jan2018, 31May2018, 04Jun2018, 02Jan2019, 05Jan2019
// ----          18Jan2019, 18May2019, 24Jun2019, 06Oct2019, 21Oct2019, 05Nov2019, 06Mar2020
// ----          08Apr2020, 20Apr2020, 25Apr2020, 06May2020, 18May2020, 12Jun2020, 13Jun2020
// ----          15Jun2020, 19Jun2020, 21Jun2020, 26Jun2020, 01Jul2020, 08Jul2020, 09Jul2020
// ----          01Aug2020, 02Aug2020, 04Feb2025, 18Sep2025
// ----
// ----
// ----

module MUtils;

use namespace ui;
use namespace gledit;


// <class.png>
class Utils {

   // <method.png>
   static SplitPathname(String name, path, file) {
      // Split last used file name into directory/file components

      int idx = name.lastIndexOf("/");
      int idxDos = name.lastIndexOf("\\");
      if(idxDos > idx)
      {
         idx = idxDos;
      }

      if(-1 != idx)
      {
         name.substring(0, idx) => path;
         name.substring(idx+1, -1) => file;
      }
      else
      {
         path = null;
         file = name;
      }

      ////trace "xxx SplitPathname: name=\""+name+"\" path=\""+path+"\" file=\""+file+"\".";
   }

   // <method.png>
   static BaseName(String _name, String _retSuffixOrNull) : String {
      int idx = _name.lastIndexOf(".");
      if(-1 != idx)
      {
         if(null != _retSuffixOrNull)
         {
            _name.substring(idx, -1) => _retSuffixOrNull;
         }

         return _name.substring(0, idx);
      }
      return _name;
   }

   // <method.png>
   static ConvertToFileName(String _name) : String {
      String r = _name;
      r.replaceChar(':',  '_');
      r.replaceChar('/',  '_');
      r.replaceChar('\\', '_');
      r.replaceChar('$',  '_');
      r.replaceChar('&',  '_');
      r.replaceChar('ยง',  '_');
      r.replaceChar('%',  '_');
      r.replaceChar('\'', '_');
      r.replaceChar('`',  '_');
      r.replaceChar('<',  '_');
      r.replaceChar('>',  '_');
      r.replaceChar('*',  '_');
      r.replaceChar('|',  '_');
      r.replaceChar('!',  '_');
      r.replaceChar('?',  '_');
      r.replaceChar('^',  '_');
      r.replaceChar('=',  '_');
      r.replaceChar('~',  '_');
      r.replaceChar('#',  '_');
      r.replaceChar(';',  '_');
      return r;
   }

   // <method.png>
   static ConvertToIdentifier(String _s) : String {
      local String r = ConvertToFileName(_s);
      r.replace("+", "_");
      r.replace("-", "_");
      r.replace("[", "_");
      r.replace("]", "_");
      r.replace("(", "_");
      r.replace(")", "_");
      r.replace("{", "_");
      r.replace("}", "_");
      if(0 == r.charsetIndexOf("0123456789", 0))
         r.insert(0, "_");
      return deref r;
   }

   // <method.png>
   static FixFileName(String _name) : String {
      local String r = _name;
      r.replaceChar('\\', '/');
      r.replaceChar('\\', '/');
      r.replace("//", "/");
      r.replace("//", "/");
      r.replace("//", "/");
      return deref r;
   }

   // <method.png>
   static LazyAppendSuffix(String _name, String _suffix) : String {
      local String r = _name;
      // trace "xxx LazyAppendSuffix: r=\""+r+"\" suffix=\""+_suffix+"\"";
      if(!r.endsWith(_suffix))
         r.append(_suffix);
      // trace "xxx 2 LazyAppendSuffix: r=\""+r+"\"";
      return deref r;
   }

   // <method.png>
   static LazyRemoveSuffix(String _name, String _suffix) : String {
      local String r = _name;
      int idx = r.lastIndexOf(_suffix);
      // trace "xxx LazyRemoveSuffix: name=\""+_name+"\" suffix=\""+_suffix+"\" idx="+idx;
      if(-1 != idx)
      {
         r.replaceRegion(idx, r.length, "");
      }
      // trace "xxx LazyRemoveSuffix:   => r=\""+r+"\"";
      return deref r;
   }

   // <method.png>
   static Backtrace() {
      try { throw UncriticalError("debug/backtrace"); } catch(UncriticalError e) { trace e.stackTrace; }
   }

   // <method_get.png>
   static GetCurrentDateString() : String {
      Time t; t.now();
      return
         t.monthday+
         ((["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"])[t.month])+t.year;
   }

   // <method_get.png>
   static GetCurrentTimeString() : String {
      Time t;
      Integer io_h;
      Integer io_m;
      Integer io_s;
      t.now();
      io_h.value=t.hour;
      io_m.value=t.min;
      io_s.value=t.sec;
      return io_h.printf("%02i")+"_"+io_m.printf("%02i")+"_"+io_s.printf("%02i");
   }

   // <method_get.png>
   static GetCurrentDateTimeStringNumeric() : String {
      Time t;
      Integer io_mon;
      Integer io_mday;
      Integer io_h;
      Integer io_m;
      Integer io_s;
      t.now();
      io_mon = t.month + 1;
      io_mday = t.monthday;
      io_h.value=t.hour;
      io_m.value=t.min;
      io_s.value=t.sec;
      return t.year + io_mon.printf("%02d")+io_mday.printf("%02d")+"-"+io_h.printf("%02i")+io_m.printf("%02i")+io_s.printf("%02i");
   }

   // <method.png>
   static BPMPPQToMS(float _bpm, float _ppq) : float {
      return 1000.0f / (_bpm * _ppq / 60.0f);
   }

   // <method.png>
   static UsecQuarterToBPM(float _usec) : float {
      // return 1000.0f / (_bpm * _ppq / 60.0f);
      // millisec = 1000.0f / (_bpm * _ppq / 60.0f)
      // millisec * _bpm * _ppq / 60.0f = 1000.0f
      // _bpm * millisec * _ppq / 60.0f = 1000.0f
      // _bpm  = 1000.0f / (millisec * _ppq / 60.0f)
      // _bpm  = 1000.0f / (usec * 1000 * _ppq / 60.0f)
      // _bpm  = 1.0f / (usec * _ppq / 60.0f)
      // return 1.0f / (_usec / 60.0f);
      return 1000000.0f / (_usec / 60.0f);
   }

   // <method.png>
   static HexDump(Buffer buf, int start, int num) {
      int HEXDUMP_COLS = 16;
      int j, i=start;
      int c;
      int x=0;
      int y=start;
      Integer io;
      io.value=i-start;
      stdout io.printf("%04x: ");
      loop(num)
      {
         io.value=buf[i++];
         stdout io.printf("%02x ");
         if( (++x % HEXDUMP_COLS) == 0)
         {
            j = y;
            loop(HEXDUMP_COLS)
            {
               c = buf[j++];
               if(c<32)
                  c='.';
               else if(c>126)
                  c='.';
               stdout tcchar(c);
            }
            stdout "\n";
            if(i<(start+num))
            {
               io.value = i-start;
               stdout io.printf("%04x: ");
            }
            x = 0;
            y += HEXDUMP_COLS;
         }
      }
      if(x)
      {
         loop(3*(HEXDUMP_COLS-x))
         {
            stdout " ";
         }
         j = y;
         loop(x)
         {
            c = buf[j++];
            if(c<32)
               c='.';
            else if(c>126)
               c='.';
            stdout tcchar(c);
         }
         stdout "\n";
      }
   }

   // <method.png>
   static BufferDiff(Buffer a, Buffer b, boolean _bVerbose) : boolean {
      boolean ret = true;

      if(_bVerbose)
         Global.Debug("Utils::BufferDiff: a.size="+a.size+" b.size="+b.size);

      if(a.size > 0)
      {
         if(a.size == b.size)
         {
            Integer off = 0;

            ret = false;

            loop(a.size)
            {
               UnsignedByte ba = a.peekI8(off);
               UnsignedByte bb = b.peekI8(off);

               if(ba != bb)
               {
                  if(_bVerbose)
                     Global.Debug("Utils::BufferDiff: diff at off="+off+" ("+off.printf("0x%x")+") a="+ba.printf("0x%02x")+" b="+bb.printf("0x%02x"));
                  ret = true;
               }

               off++;
            }
         }
      }

      return ret;
   }

   // <method.png>
   static BufferDiffARKit(Buffer a, Buffer b, boolean _bVerbose) : boolean {
      boolean ret = true;

      // if(_bVerbose)
      //    Global.Debug("Utils::BufferDiff: a.size="+a.size+" b.size="+b.size);

      if(a.size > 0)
      {
         if(a.size == b.size)
         {
            Integer off = 0;

            ret = false;

            loop(a.size)
            {
               UnsignedByte ba = a.peekI8(off);
               UnsignedByte bb = b.peekI8(off);

               if((46+0x1C) <= off < (2062+0x1C))
               {
                  if(ba != bb)
                  {
                     int trackIdx = (off - 46) / 168;
                     Integer soundOff = off - (46 + trackIdx*168);
                     Integer paramIdx = (soundOff - 0x1C)/2;
                     Global.Debug("Utils::BufferDiff<ARKit>: diff at trackNr="+(trackIdx+1)+" soundOff="+soundOff+" ("+soundOff.printf("0x%x")+") paramNr="+(paramIdx+1)+" a="+ba.printf("0x%02x")+" b="+bb.printf("0x%02x")+" kitOff="+off+" (0x"+off.printf("%04x")+")");
                     ret = true;
                  }
               }

               off++;
            }
         }
      }

      return ret;
   }

   // <method.png>
   static SaveBufferToFile(String _filename, Buffer _b, int _offset, int _num) {
      File f;
      if(f.openLocal(_filename, IOS_OUT))
      {
         int off = _offset;
         loop(_num)
         {
            byte c = _b.peekI8(off++);
            f.i8 = c;
         }

         f.close();

         Global.Debug("Utils::SaveBufferToFile: filename=\""+_filename+"\" off="+_offset+" num="+_num);
      }
   }

   // <method.png>
   static UnmapLetterNr(String _name) : int {
      explain "Map name (e.g. z) to number (e.g. 61)";
      int c;
      if(_name.length>0)
      {
         c = _name[0];
      }
      else
      {
         return 0;
      }
      c = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".indexOfChar(c, 0);
      if(c == -1)
      {
         return 0;
      }
      else
      {
         return c;
      }
   }

   // <method.png>
   static ExtractCopyPrefix(String _s, String _prefix) {
      int idx = _s.indexOf("(Copy", 0);
      if(-1 == idx)
      {
         idx = _s.length;
      }
      _s.substring(0, idx) => _prefix;
   }

   // <method.png>
   static DetermineCopyNr(String _s) : int {
      int idx = _s.indexOf("(Copy", 0);
      if(-1 != idx)
      {
         int idxNrStart = idx + 5;
         int idxNrEnd = _s.indexOfChar(')', idxNrStart);
         if(-1 == idxNrEnd)
         {
            idxNrEnd = _s.length;
         }
         return _s.substring(idxNrStart, idxNrEnd-idxNrStart).trim();
      }

      return -1;
   }

   // <method.png>
   static BuildCopiedName(String _orig, int _appendixNr) : String {
      // Adds incremental " (Copy x)" string to end of original name and returns new string

      int idx = _orig.indexOf("(Copy", 0);
      local String r;
      if(-1 != idx)
      {
         int idxNrStart = idx + 5;
         _orig.substring(0, idxNrStart) => r;
         int idxNrEnd = _orig.indexOfChar(')', idxNrStart);
         if(-1 != idxNrEnd)
         {
            r.append(" ");
            r.append(_appendixNr);
            r.append(")");
            r.append(_orig.substring(idxNrEnd+1, _orig.length-(idxNrEnd+1)));
         }
         else
         {
            r.append(" 1)");
         }
      }
      else
      {
         r = _orig;
         r.append(" (Copy ");
         r.append(_appendixNr);
         r.append(")");
      }
      return deref r;
   }

   // <method.png>
   public static KeycodeToMidiNote(int _code):int {
      switch(_code) {
         case 122: return  0; //c-0: 122
         case 115: return  1; //c#0: 115
         case 120: return  2; //d-0: 120
         case 100: return  3; //d#0: 100
         case  99: return  4; //e-0: 99
         case 118: return  5; //f-0: 118
         case 103: return  6; //f#0: 103
         case  98: return  7; //g-0: 98
         case 104: return  8; //g#0: 104
         case 110: return  9; //a-0: 110
         case 106: return 10; //a#0: 106
         case 109: return 11; //b-0: 109
         case  44: return 12; //c-1: 44
         case 108: return 13; //c#1: 108
         case  46: return 14; //d-1: 46
         case  59: return 15; //d#1: 59
         case  47: return 16; //e-1: 47
         case 113: return 12; //c-1: 113
         case  50: return 13; //c#1: 50
         case 119: return 14; //d-1: 119
         case  51: return 15; //d#1: 51
         case 101: return 16; //e-1: 101
         case 114: return 17; //f-1: 114
         case  53: return 18; //f#1: 53
         case 116: return 19; //g-1: 116
         case  54: return 20; //g#1: 54
         case 121: return 21; //a-1: 121
         case  55: return 22; //a#1: 55
         case 117: return 23; //h-1: 117
         case 105: return 24; //c-2: 105
         case  57: return 25; //c#2: 57
         case 111: return 26; //d-2: 111
         case  48: return 27; //d#2: 48
         case 112: return 28; //e-2: 112
         case  91: return 29; //f-2: 91
         case  61: return 30; //f#2: 61
         case  93: return 31; //g-2: 93
      }
      return -1;
   }

   // <method.png>
   static KeycodeToInstrument(int _unicode) {
      switch(_unicode)
      {
         case '0': return 0;
         case '1': return 1;
         case '2': return 2;
         case '3': return 3;
         case '4': return 4;
         case '5': return 5;
         case '6': return 6;
         case '7': return 7;
         case '8': return 8;
         case '9': return 9;
         case 'a': return 10;
         case 'b': return 11;
         case 'c': return 12;
         case 'd': return 13;
         case 'e': return 14;
         case 'f': return 15;
         case 'g': return 16;
         case 'h': return 17;
         case 'i': return 18;
         case 'j': return 19;
         case 'k': return 20;
         case 'l': return 21;
         case 'm': return 22;
         case 'n': return 23;
         case 'o': return 24;
         case 'p': return 25;
         case 'q': return 26;
         case 'r': return 27;
         case 's': return 28;
         case 't': return 29;
         case 'u': return 30;
         case 'v': return 31;
         case 'w': return 32;
         case 'x': return 33;
         case 'y': return 34;
         case 'z': return 35;
         case 'A': return 36;
         case 'B': return 37;
         case 'C': return 38;
         case 'D': return 39;
         case 'E': return 40;
         case 'F': return 41;
         case 'G': return 42;
         case 'H': return 43;
         case 'I': return 44;
         case 'J': return 45;
         case 'K': return 46;
         case 'L': return 47;
         case 'M': return 48;
         case 'N': return 49;
         case 'O': return 50;
         case 'P': return 51;
         case 'Q': return 52;
         case 'R': return 53;
         case 'S': return 54;
         case 'T': return 55;
         case 'U': return 56;
         case 'V': return 57;
         case 'W': return 58;
         case 'X': return 59;
         case 'Y': return 60;
         case 'Z': return 61;
         default: return -1;
      }
   }

   // <method.png>
   static KeycodeToHex(Key _k) : int {
      switch(_k.unicode)
      {
         case '0': return 0;
         case '1': return 1;
         case '2': return 2;
         case '3': return 3;
         case '4': return 4;
         case '5': return 5;
         case '6': return 6;
         case '7': return 7;
         case '8': return 8;
         case '9': return 9;
         case 'a': return 10;
         case 'b': return 11;
         case 'c': return 12;
         case 'd': return 13;
         case 'e': return 14;
         case 'f': return 15;
      }

      if(_k.modShiftOrCaps())
      {
         // German kbd
         if("de" == GConfig.kbd_layout)
         {
            switch(_k.unicode)
            {
               case '=': return 0;
               case '!': return 1;
               case '"': return 2;
               case 'ยง': return 3;
               case '$': return 4;
               case '%': return 5;
               case '&': return 6;
               case '/': return 7;
               case '(': return 8;
               case ')': return 9;
               case 'A': return 10;
               case 'B': return 11;
               case 'C': return 12;
               case 'D': return 13;
               case 'E': return 14;
               case 'F': return 15;
            }
         }
         //else if("us" == GConfig.kbd_layout)
         {
            switch(_k.code)
            {
               case '0': return 0;
               case '1': return 1;
               case '2': return 2;
               case '3': return 3;
               case '4': return 4;
               case '5': return 5;
               case '6': return 6;
               case '7': return 7;
               case '8': return 8;
               case '9': return 9;
               case 'A': return 10;
               case 'B': return 11;
               case 'C': return 12;
               case 'D': return 13;
               case 'E': return 14;
               case 'F': return 15;
            }
         }
      }

      return -1;
   }

   // <method_get.png>
   static GetNumString(int _num, String _s) : String {
      if( (_num > 1) || (0 == _num) )
      {
         return _num+" "+_s + "s";
      }
      else
      {
         return _num+" "+_s;
      }
   }

   // <method_get.png>
   static GetNumString2(int _num, String _s1, String _s2) : String {
      if( (_num > 1) || (0 == _num) )
      {
         return _num+" "+_s2;
      }
      else
      {
         return _num+" "+_s1;
      }
   }

   // <method_get.png>
   static GetNumString3(float _num, String _s1, String _s2) : String {
      // e.g. "0.75 bars", "1.25 bars", "1 bar", "0 bars"
      // (note) truncate float to 2 decimal places
      if( (_num > 1) || (_num < 1) )
      {
         Float num = _num;

         if(0 == _num)
         {
            return "0 "+_s2;
         }
         else if(int(_num) == _num)
         {
            return int(_num)+" "+_s2;
         }
         else
         {
            return num.printf("%3.2f")+" "+_s2;
         }
      }
      else
      {
         return "1 "+_s1;
      }
   }

   // <method_get.png>
   static GetEnableString(boolean _bEnabled) : String {
      return (maybe == _bEnabled) ? "enabled(maybe)" : (false != _bEnabled) ? "enabled" : "disabled";
   }

   // <method_get.png>
   static GetEnableStringMixed(boolean _bEnabled, String _sFalse, String _sTrue, String _sMixed) : String {
      return (maybe == _bEnabled) ? _sMixed : (false != _bEnabled) ? _sTrue : _sFalse;
   }

   // <method.png>
   public static Bipolar8ToOffset(float _t) : float {
      // t (0..255) => -128 .. +127

      if(_t < 0.0f)
         _t = 0.0f;
      else if(_t > 255.0f)
         _t = 255.0f;

      return (_t - 128.0f);
   }

   // <method.png>
   public static Bipolar8ToFloat(float _t) : float {
      // t (0..255) => -1 .. +1
      float r;

      if(_t < 0.0f)
         r = 0.0f;
      else if(_t < 128.0f)
         r = (_t / 128.0) - 1.0f;
      else if(_t > 255.0f)
         r = 1.0f;
      else
         r = (_t - 128.0f) / 127.0f;

      return r;
   }

   // <method.png>
   public static Bipolar8ToScale(float _t, float _div, float _mul) : float {
      // t (0..255) => /_div .. *_mul

      if(_t < 0.0f)
         _t = 0.0f;
      else if(_t > 255.0f)
         _t = 255.0f;

      float s;

      if(_t < 128.0f)
      {
         // // s = 1.0 + ((128.0 - _t) / (128.0 / (_div - 1.0)));
         s = (1.0f / _div);
         s = s + ( (1.0 - s) * (_t / 128.0) );
      }
      else
      {
         s = 1.0 + ((_t - 128.0) / (127.0 / (_mul - 1.0)));
      }

      return s;
   }

   // <method.png>
   public static Bipolar8ToScaleRev(float _val, float _div, float _mul) : float {
      // t (/div .. *mul) =>  (0..255)

      float s = (1.0f / _div);

      _val = mathClampf(_val, s, _mul);

      if(_val < 1.0)
      {
         s = 128 - 128.0*(2.0 - (_val / s));
      }
      else
      {
         s = 128.0 + 127.0*(((_val-1.0) / (_mul-1.0)));
      }

      return s;
   }

   // <method.png>
   public static Bipolar14ToScaleZero(float _t, float _mul) : float {
      // t (0..16383) => 0 .. *_mul, 0x2000=1.0

      if(_t < 0.0f)
         _t = 0.0f;
      else if(_t > 16383.0f)
         _t = 16383.0f;

      float s;

      if(_t < 8192.0f)
      {
         s = (_t / 8192.0);
      }
      else
      {
         s = 1.0 + ((_t - 8192.0) / (8192.0 / (_mul - 1.0)));
      }

      return s;
   }

   // <method.png>
   public static IntToBinary255String(byte _val) : String {
      _val &= 255;

      String r = "0b";
      int bit = 128;
      loop(8)
      {
         if(_val & bit)
            r.append("1");
         else
            r.append("0");
         bit >>= 1;
      }

      return r;
   }

   // <method.png>
   public static SignedInt14ToFloat(short _val) : float {
      _val -= 8192;
      if(_val < 0)
         return _val / 8192.0;
      else
         return _val / 8191.0;
   }

   // <method.png>
   public static GetPluralString(int _num) : String {
      if((0 == _num) || (abs(_num) > 1))
         return "s";
      return "";
   }

   // <method.png>
   public static GetPluralStringFloat(float _num) : String {
      if((0 == _num) || (_num > 1) || (_num < 1.0))
         return "s";
      return "";
   }

   // <method.png>
   public static GetPluralStringEx(int _num, String _single, String _multi) : String {
      if((0 == _num) || (abs(_num) > 1))
         return _multi;
      return _single;
   }

   // <method.png>
   public static IsWindows() {
      // // return (null != getenv("COMSPEC"));
      return (".dll" == TKS.dllSuffix);
   }

   // <method.png>
   public static IsLinux() {
      return (".so" == TKS.dllSuffix);
   }

   // <method.png>
   public static IsMacOS() {
      return (".dylib" == TKS.dllSuffix);
   }

   // <method.png>
   public static SubstitutePathVars(local String _path) : String {
      local String r = _path;
      ////r.replace("$(PROGRAM_DIR)", TKS.getTksExeDir());
      r.replace("~", getenv("HOME"));
      loop(2)
      {
         r.replace("$(PROJECT)", current_project.getProjectPath());
         r.replace("$(PROJECT_DIR)", GConfig.project_rootpath);
         r.replace("$(PROGRAM_DIR)", gledit::program_directory);
         r.replace("$(HOME)", getenv("HOME"));
      }
      return deref r;
   }

   // <method.png>
   public static SubstitutePathVarsNoProject(local String _path) : String {
      // called by Project::getProjectPath()
      local String r = _path;
      ////r.replace("$(PROGRAM_DIR)", TKS.getTksExeDir());
      r.replace("~", getenv("HOME"));
      loop(2)
      {
         r.replace("$(PROJECT_DIR)", GConfig.project_rootpath);
         r.replace("$(PROGRAM_DIR)", gledit::program_directory);
         r.replace("$(HOME)", getenv("HOME"));
      }
      return deref r;
   }

   // <method.png>
   public static CanFileBeRead(String _pathName) : boolean {
      trace "xxx CanFileBeRead(\""+_pathName+"\")";
      if(!_pathName.isBlank())
      {
         local File f;
         if(f.openLocal(_pathName, IOS_IN))
         {
            f.close();
            return true;
         }
      }
      return false;
   }

   // // <method.png>
   // // static public method ToNativePathName(local String _name) : String {
   // //    local String r;
   // //    if(_name <= "~")
   // //       r = getenv("HOME")+"/"+_name.substring(1,9999);
   // //    else
   // //       r = _name;
   // //    return SubstitutePathVars(deref r);
   // // }

   // <method.png>
   public static FixPathname_psystem_exe(String _pathName) : String {
      String r;
      _pathName.replace("//", "/") => r;

      if(IsWindows())
      {
         // Windows
         r.replace("/", "\\");
         r.replace("\\\\", "\\");
         // // // cmdLine.replace(" ", "\\ ");
         // // // cmdLine.replace("(", "\\(");  // does not work (=> "c:\Program" not found)
         // // // cmdLine.replace(")", "\\)");
      }

      return "\""+r+"\"";
   }

   // <method.png>
   public static FixPathname_psystem_arg(String _pathName) : String {
      String r;
      _pathName.replace("//", "/") => r;

      if(IsWindows())
      {
         // Windows
         r.replace("/", "\\");
         r.replace("\\\\", "\\");
         // r.replace(" ", "\\ ");
         // // r.replace(" ", "\" \"");  // wth
      }

      return r;
   }

   // <method.png>
   static public method FixChunkSize(Stream _out, int _chunkStartOff) {
      ////trace "xxx 1 fixchunksize: out.offset="+_out.offset;
      int coff = _out.offset;
      int chunkSize = coff - _chunkStartOff;
      _out.seek(_chunkStartOff, SEEK_SET);
      _out.i32 = chunkSize;
      _out.seek(coff, SEEK_SET);
   }

   // <method_write.png>
   static public method WriteString(Stream _out, String _s) {
      // // int coff = _out.offset;

      if(null != _s)
      {
         // (note) first 32bit int of data is string length
         _out.serialize(_s, false);

         // // FixChunkSize(_out, coff);
      }
      else
      {
         _out.i32 = 0;
      }
   }

   // <method_read.png>
   static public method ReadString(Stream _in, String _s) : int {
      int startOff = _in.offset;
      _in.deserialize(_s, false);
      //trace "xxx read string \""+_s+"\".";
      return _in.offset - startOff;
   }

   // <method_write.png>
   static public method WriteBuffer(Stream _out, Buffer _b) {
      if(null != _b)
      {
         _out.i32 = _b.size;
         _out.writeBuffer(_b, 0, _b.size);
      }
      else
      {
         _out.i32 = 0;  // size = 0
      }
   }

   // <method_read.png>
   static public method ReadBuffer(Stream _in, Buffer _b) : int {
      int startOff = _in.offset;
      int size = _in.i32;
      Global.Debug("Utils::ReadBuffer: buffer size="+_b.size);
      _b.free();
      int numRead = _in.readBuffer(_b, 0, size, true/*bResize*/);
      Global.Debug("Utils::ReadBuffer: read "+numRead+" bytes");
      return _in.offset - startOff;
   }

   // <method_write.png>
   static public method WriteIntArray(Stream _out, IntArray _ia) {
      int i;
      ////trace "xxx WriteIntArray ia="+#(_ia)+" out.offset="+_out.offset;
      _out.i32 = _ia.numElements*4;
      i = 0;
      loop(_ia.numElements)
      {
         _out.i32 = _ia[i];
         i++;
      }
   }

   // <method_read.png>
   static public method ReadIntArray(Stream _in, IntArray _ia) {
      int i;
      ////trace "xxx WriteIntArray ia="+#(_ia)+" out.offset="+_out.offset;
      int numElements = _in.i32 / 4;
      _ia.alloc(numElements);
      i = 0;
      loop(numElements)
      {
         _ia.add(_in.i32);
         i++;
      }
   }

   // <method_write.png>
   static public method WriteEnvelope(Stream _out, Envelope _env) {
      _out.i8 = 0; // Element type (reserved), 0=float
      _out.i8 = _env.interpolation;
      int i = 0;
      loop(_env.numElements)
      {
         _out.f32 = _env[i];
         i++;
      }
   }

   // <method_read.png>
   static public method ReadEnvelope(Stream _in, int _chunkDataSize, Envelope _env) : int {
      int startOff = _in.offset;
      if(_chunkDataSize >= (1+1))
      {
         int envDataType = _in.i8;
         _env.interpolation = _in.i8;
         // todo: check envDataType when calculating numElements
         int numElements = (_chunkDataSize - 1 - 1) / 4;
         if(numElements > 0)
         {
            if(_env.alloc(numElements))
            {
               _env.numElements = numElements;
               int i = 0;
               switch(envDataType)
               {
                  default:
                     trace "[---] Utils::ReadEnvelope: unknown data type <"+envDataType+">.";
                     return 0;

                  case 0: // float 32 bit
                     loop(numElements)
                     {
                        _env[i++] = _in.f32;
                     }
                     ////trace "xxx ReadEnvelope: finished, env="+#(_env);
                     ////trace "xxx ReadEnvelope: numread="+(_in.offset - startOff);
                     return _in.offset - startOff;
               }
            }
            else
            {
               trace "[---] Utils::ReadEnvelope: failed to allocate envelope elements (num="+numElements+").";
            }
         }
         else
         {
            //trace "[~~~] Utils::ReadEnvelope: warning, envelope is empty.";
            return _in.offset - startOff;
         }
      }
      else
      {
         trace "[---] Utils::ReadEnvelope: invalid chunk size ("+_chunkDataSize+").";
      }
      return 0;
   }

   // <method.png>
   static public SortStringArray(StringArray _sa, boolean _bCaseSensitive) {
      IntArray indices;
      indices.identity(_sa.numElements);
      _sa.sortByValue(indices, _bCaseSensitive);
      _sa.rearrange(indices);
      indices.free();
   }

   // <method.png>
   static public KbdFocusNextInMiniCycleList(ui::Layer _kbdFocus,
                                             Object _cycleList
                                             ) {
      int idx;
      if(_cycleList instanceof PointerArray)
      {
         PointerArray pa <= _cycleList;
         idx = pa.indexOfPointer(_kbdFocus, 0);
         if(-1 == idx)
            idx = 0;
         else
            idx = (idx + 1) % pa.numElements;
         ui::UI.SetKeyboardFocus(pa.get(idx));
      }
      else if(_cycleList instanceof ValueArray)
      {
         ValueArray va <= _cycleList;
         idx = va.indexOfPointer(_kbdFocus, 0);
         if(-1 == idx)
            idx = 0;
         else
            idx = (idx + 1) % va.numElements;
         ui::UI.SetKeyboardFocus(va.get(idx));
      }
   }

   // <method.png>
   static MatchFilterString(StringArray _filterWords, String _s) : boolean {
      if(null != _filterWords)
      {
         if(_filterWords.numElements > 0)
         {
            local String slc;
            _s.toLower() => slc;
            String *flt;
            foreach flt in _filterWords
            {
               if!(slc & flt.toLower())
                  return false;
            }
         }
      }
      return true;
   }

   // <method_parse.png>
   public static ParseHexString(Buffer _buf, String _msg) {
      local StringArray words <= _msg.splitSpace(false);
      if(null != words)
      {
         _buf.size = words.numElements;
         _buf.offset = 0;
         local String *s;
         foreach s in words
         {
            _buf.i8 = "0x"+s.trim();
         }
      }
   }

   // <method.png>
   public static IsRelativePath(String _name) {
      return
         !(_name & ":") &&
         !_name.startsWith("/") &&
         !_name.startsWith("~") ;
   }

   // <method.png>
   public static CommonRepeat(local int _a, local int _b) : int {
      return (_a * _b) / mathGCD(_a, _b);
   }

   // <method.png>
   public static AbbrevPathName(local String _name) : String {
      // used in "overwrite" dialogs
      if(_name.length >= 60)
      {
         return _name.substring(0, 20) + "..." + _name.substring(_name.length-40, 9999);
      }
      return deref _name;
   }

   // <method.png>
   public static RollTheDice(int _prob) : boolean {
      return (mathClampi(_prob, 0, 100) >= (100 - rand(99 + 1)));
   }

   // <method.png>
   public static AppendIndentedLines(String _d, String _s, int _indent) {
      local StringArray lines <= _s.splitChar('\n');
      local String *line;
      foreach line in lines
      {
         _d.appendRepeat(" ", _indent);
         _d.append(line);
         _d.append("\n");
      }
   }

   // <method.png>
   public static CreateAutoId(String _prefix, PointerArray _a) : String {
      local String r;
      GObject *obj;
      boolean bFound;
      r <= _prefix;
      int nr = 1;
      do
      {
         bFound = false;
         foreach obj in _a
         {
            if(obj.getId() == r)
            {
               bFound = true;
               nr++;
               r <= _prefix+nr;
               break;
            }
         }
      }
      while(bFound);
      return deref r;
   }

   // <method.png>
   public static CreateAutoIdNamespace(String _prefix, PointerArray _a) : String {
      local String r;
      GNamespace *nsp;
      boolean bFound;
      int nr = _a.numElements;
      do
      {
         bFound = false;
         r <= _prefix+nr;
         foreach nsp in _a
         {
            if(nsp.getNamespaceId() == r)
            {
               bFound = true;
               nr++;
            }
         }
      }
      while(bFound);
      return deref r;
   }

   // // // <method.png>
   // // public static BeginEmitObject(PointerArray _objDone, GObject _obj) {
   // //    if(_objDone.contains(obj))
   // //       throw GInfiniteRecursion "obj="+#(obj)+" id="+obj.id+" this.input.id="+input.id+" port_id="+port_id;
   // //    objDone.add(obj);
   // // }

   // <method.png>
   public static ToNativePathName(String _pathName) : String {
      return FixFileName(SubstitutePathVars(_pathName));
   }

   // <method.png>
   public static ToProjectPathName(String _pathName) : String {
      // trace "xxx ToProjectPathName: _pathName=\""+_pathName+"\"";
      local String pathName <= FixFileName(_pathName);
      // trace "xxx ToProjectPathName: pathName=\""+pathName+"\"";
      local String prjDir <= current_project.getProjectPath();
      // trace "xxx ToProjectPathName: prjDir=\""+prjDir+"\"";
      pathName.replace(prjDir, "$(PROJECT)");
      pathName <= FixFileName(pathName);
      // trace "xxx ToProjectPathName: => pathName=\""+pathName+"\"";
      return deref pathName;
   }

   // <method.png>
   public static ToGLSLFloatString(float _f) : String {
      local String r = _f;
      if!(r & ".")
         r.append(".0");
      return deref r;
   }

   // <method_parse.png>
   public static ParseParamStringArray(String _s) : StringArray {
      return _s.splitChar(';');
   }

   // <method.png>
   public static MoveObjectUp(PointerArray _a, Object _obj) : boolean {
      if(_a.numElements >= 2)
      {
         int idx = _a.indexOfPointer(_obj, 0);
         if(idx > 0)
         {
            _a.swap(idx-1, idx);
            return true;
         }
      }
      return false;
   }

   // <method.png>
   public static MoveObjectDown(PointerArray _a, Object _obj) : boolean {
      if(_a.numElements >= 2)
      {
         int idx = _a.indexOfPointer(_obj, 0);
         if((idx >= 0) && (idx < (_a.numElements -1)))
         {
            _a.swap(idx, idx+1);
            return true;
         }
      }
      return false;
   }

   // <method.png>
   public static GetParentsDebugString(PointerArray _parents) : String {
      local String r = "[";
      GObject *obj;
      foreach obj in _parents
         r.append("<type="+obj.yacMetaClassName()+" id="+obj.id+" addr="+@(obj)+"> ");
      r.append("]\n");
      return deref r;
   }

   // <method.png>
   static SavePosition(Layer _l, Point2f _pos) {
      Point2f posNew;
      posNew.x = _l.getPositionX();
      posNew.y = _l.getPositionY();
      if(posNew.x != _pos.x || posNew.y != _pos.y)
      {
         // PrefsDialog.MarkAsEdited();
         _pos = posNew;
      }
   }

   // <method.png>
   static SaveGeometry(Layer _l, Geometry4f _geo) {
      Geometry4f geoNew = _l.getGeometry4f();
      if(geoNew.differsFrom(_geo))
      {
         // PrefsDialog.MarkAsEdited();
         _geo = geoNew;
      }
   }

}
