// ----
// ---- file   : gconstantvec3.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 12Jun2020
// ---- changed: 13Jun2020, 14Jun2020, 15Jun2020, 16Jun2020, 18Jun2020, 21Jun2020, 14Aug2020
// ----
// ----
// ----
module MGConstantVec3;

use namespace ui;
use namespace gledit;


// <class.png>
class GConstantVec3 : GConstant {

   // <method_new.png>
   public static New() : GConstantVec3 {
      local GConstantVec3 r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GConstant::init();
      type = TYPE_VEC3;

      addParamFloat("x", "x", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamFloat("y", "y", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamFloat("z", "z", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamBool("normalize", "normalize", false);

      addInput("x", TYPE_FLOAT);
      addInput("y", TYPE_FLOAT);
      addInput("z", TYPE_FLOAT);

      addInput("xyz", TYPE_VEC3);
      addInput("transform", TYPE_MAT3);

      addOutput(GOutput.OUT_DEF, type);
   }

   // <method_get.png>
   public virtual getString() : String {
      float x = getFloatParamById("x");
      float y = getFloatParamById("y");
      float z = getFloatParamById("z");
      return "vec3("+x+", "+y+", "+z+")";
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {
      float x = getFloatParamById("x");
      float y = getFloatParamById("y");
      float z = getFloatParamById("z");
      boolean bNormalize = getBoolParamById("normalize");

      _parents.add(this);

      local GInput *input;

      // x
      local String *sX;
      input <= getInputById("x");
      if(input.isConnected())
      {
         sX <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_x");
         input.emit(_module, _program, _out, sX, _bGLSL, _parents);
         _out.append(sX+" += "+x+";\n");
      }
      else
         sX <= String(x);

      // y
      local String *sY;
      input <= getInputById("y");
      if(input.isConnected())
      {
         sY <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_y");
         input.emit(_module, _program, _out, sY, _bGLSL, _parents);
         _out.append(sY+" += "+y+";\n");
      }
      else
         sY <= String(y);

      // z
      local String *sZ;
      input <= getInputById("z");
      if(input.isConnected())
      {
         sZ <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_z");
         input.emit(_module, _program, _out, sZ, _bGLSL, _parents);
         _out.append(sZ+" += "+z+";\n");
      }
      else
         sZ <= String(z);

      // xyz
      local String *sXYZ;
      input <= getInputById("xyz");
      if(input.isConnected())
      {
         sXYZ <= _module.allocTmpVarScript(_out, TYPE_VEC3, "in_xyz");
         input.emit(_module, _program, _out, sXYZ, _bGLSL, _parents);

         if(_bGLSL)
         {
            if(bNormalize)
            {
               _out.append(_dstVar+" = normalize(vec2("+sX+"+"+sXYZ+".x, "+sY+"+"+sXYZ+".y, "+sZ+"+"+sXYZ+".z));\n");
            }
            else
            {
               _out.append(_dstVar+" = vec2("+sX+"+"+sXYZ+".x, "+sY+"+"+sXYZ+".y, "+sZ+"+"+sXYZ+".z);\n");
            }
         }
         else
         {
            _out.append(_dstVar+" = vector2f("+sX+"+"+sXYZ+".x, "+sY+"+"+sXYZ+".y, "+sZ+"+"+sXYZ+".z);\n");
            if(bNormalize)
               _out.append(_dstVar+".unit();\n");
         }
      }
      else
      {
         if(_bGLSL)
         {
            if(bNormalize)
            {
               _out.append(_dstVar+" = normalize(vec3("+sX+", "+sY+", "+sZ+"));\n");
            }
            else
            {
               _out.append(_dstVar+" = vec3("+sX+", "+sY+", "+sZ+");\n");
            }
         }
         else
         {
            _out.append(_dstVar+" = vector3f("+sX+", "+sY+", "+sZ+");\n");
            if(bNormalize)
               _out.append(_dstVar+".unit();\n");
         }
      }

      input <= getInputById("transform");
      if(input.isConnected())
      {
         local String sTransform <= _module.allocTmpVarScript(_out, TYPE_MAT3, "in_transform");
         input.emit(_module, _program, _out, sTransform, _bGLSL, _parents);
         _out.append(_dstVar+" = "+sTransform+" * "+_dstVar+";\n");
      }

      _parents.remove(this);
   }
}
