// ----
// ---- file   : genvelopecurve4.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 25Jul2020
// ---- changed: 07Aug2020, 13Aug2020, 14Aug2020, 15Aug2020
// ----
// ----
// ----
module MGEnvelopeCurve4;

use namespace ui;
use namespace gledit;


// <class.png>
class GEnvelopeCurve4 : GEnvelope, GParamProvider {

   define int NUM_CURVES = 4;

   BezierEditState *[] curve_states;
   Envelope *[]        curve_envs;

   static Curve4Dialog *dlg_curve;

   protected boolean b_init_done;
   protected boolean b_post_done;


   // <method_init.png>
   public virtual init() {
      GObject::init();

      // (todo) interpolation mode params (mode_x, mode_y, mode_z, mode_w)

      addParamBool("repeat_x", "Repeat X", true);
      addParamBool("repeat_y", "Repeat Y", true);
      addParamBool("repeat_z", "Repeat Z", true);
      addParamBool("repeat_w", "Repeat W", true);


      addInput("tx", TYPE_FLOAT);
      addInput("ty", TYPE_FLOAT);
      addInput("tz", TYPE_FLOAT);
      addInput("tw", TYPE_FLOAT);

      addOutput("x", TYPE_FLOAT);
      addOutput("y", TYPE_FLOAT);
      addOutput("z", TYPE_FLOAT);
      addOutput("w", TYPE_FLOAT);

      loop(NUM_CURVES)
      {
         BezierEditState beState <= new BezierEditState;
         Envelope beEnv <= new Envelope;
         BezierCurveForm.InitLinearEnv(beState, beEnv);
         curve_states.add(#(deref beState));
         curve_envs.add(#(deref beEnv));
         // trace "xxx beEnv="+#(beEnv);
      }
   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "env_curves";
   }

   // <method.png>
   public virtual getVarName() : String {
      return getNamespacePrefix()+"_envc4_"+id;
   }

   // <method_get.png>
   public virtual getInputDomain(String _inputId) : int {
      return DOMAIN_SCRIPT;
   }

   // <method_get.png>
   public virtual getOutputDomain(String _outputId) : int {
      return DOMAIN_SCRIPT;
   }

   // <ui_show.png>
   public method showEditor() {
      if(null == dlg_curve)
      {
         dlg_curve <= new Curve4Dialog;
         dlg_curve.initCurve4Dialog(false/*bTex*/);
      }
      dlg_curve.showCurve4DialogEnvelope(this);
   }

   // <save.png>
   public virtual saveStateObject(local Stream ofs, local GConnectionWriter connectionWriter) {
      GObject::saveStateObject(ofs, connectionWriter);

      // Version
      ofs.i16 = 1;

      // Params
      GParamProvider::saveStateParamProvider(ofs, connectionWriter);

      // Save curves
      int curveIdx = 0;
      loop(NUM_CURVES)
      {
         BezierEditState beState <= curve_states.get(curveIdx);
         ofs << beState;
         curveIdx++;
      }
   }

   // <load.png>
   public virtual loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject

      // Version
      short ver = ifs.u16;

      if(1 <= ver <= 1)
      {
         if(GParamProvider::loadStateParamProvider(ifs))
         {
            // Read Curves
            int curveIdx = 0;
            local BezierEditState beStateTmp;
            loop(NUM_CURVES)
            {
               BezierEditState beState <= curve_states.get(curveIdx);
               Envelope beEnv <= curve_envs.get(curveIdx);
               beState << ifs;
               BezierCurveForm.CalcEnv(beState, beEnv);
               curveIdx++;
            }

            // Succeeded
            return true;
         }
         else
         {
            trace "[---] GEnvelopeCurve4::loadStateObject: failed to load params, this="+#(this)+" path="+getObjectPath();
         }
      }
      else
      {
         trace "[---] GEnvelopeCurve4::loadStateObject: invalid version "+ver+", this="+#(this)+" path="+getObjectPath();
      }
      return false;
   }


   // <method_get.png>
   public virtual hasDefaultAction() : boolean {
      return true;
   }

   // <method.png>
   public virtual execDefaultAction() {
      showEditor();
   }

   // <method.png>
   public virtual emitBegin() {
      // trace "xxx GEnvelopeCurve4::emitBegin";
      b_init_done = false;
      b_post_done = false;
   }

   // <method.png>
   protected method emitEnv(local String       _sEnvVar,
                            local String       _outputId,
                            local GModule      _module,
                            local String       _out,
                            local String       _dstVar,
                            local boolean      _bRepeat,
                            local PointerArray _parents
                            ) {

      local GInput input <= getInputById("t"+_outputId);  // tx, ty, tz, tw
      local String *sV;
      if(input.isConnected())
      {
         sV <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_t"+_outputId);
         input.emit(_module, null/*program*/, _out, sV, false/*bGLSL*/, _parents);
         if(_bRepeat)
            _out.append(sV+" = "+sV+" % 1.0f;\n");
         else
            _out.append(sV+" = mathClampf("+sV+", 0.0f, 1.0f);\n");
      }
      else
         sV <= "0/*no in_t"+_outputId+" input*/";
      _out.append(_dstVar+" = "+_sEnvVar+"_"+_outputId+".valueAtTime("+sV+");\n");
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {

      // trace "xxx GEnvelopeCurve4::emit: outputId="+_outputId+" b_init_done="+b_init_done;

      local String sEnvVar <= getVarName();

      if(!b_init_done)
      {
         b_init_done = true;

         local String sGlobal;

         sGlobal.append("Envelope *"+sEnvVar+"_x;\n");
         sGlobal.append("Envelope *"+sEnvVar+"_y;\n");
         sGlobal.append("Envelope *"+sEnvVar+"_z;\n");
         sGlobal.append("Envelope *"+sEnvVar+"_w;\n");

         _module.appendGlobal(sGlobal);
      }

      _parents.add(this);

      // trace "xxx genvelopecurv4::emit: outputId=\""+_outputId+"\"";

      switch(_outputId)
      {
         case "x":
            emitEnv(sEnvVar,
                    "x",
                    _module,
                    _out,
                    _dstVar,
                    getBoolParamById("repeat_x"),
                    _parents
                    );
            break;

         case "y":
            emitEnv(sEnvVar,
                    "y",
                    _module,
                    _out,
                    _dstVar,
                    getBoolParamById("repeat_y"),
                    _parents
                    );
            break;

         case "z":
            emitEnv(sEnvVar,
                    "z",
                    _module,
                    _out,
                    _dstVar,
                    getBoolParamById("repeat_z"),
                    _parents
                    );
            break;

         case "w":
            emitEnv(sEnvVar,
                    "w",
                    _module,
                    _out,
                    _dstVar,
                    getBoolParamById("repeat_w"),
                    _parents
                    );
            break;
      }

      _parents.remove(this);
   }

   // <method.png>
   protected method updateEnvVars() {
      local String sEnvVar <= getVarName();
      local Variable *v;

      // trace "[trc] GEnvelopeCurve4: set var "+sEnvVar+"_x";
      v <= current_project.script.findVariable(sEnvVar+"_x");
      v.pointerAssign(curve_envs.get(0));
      v.store();

      // trace "[trc] GEnvelopeCurve4: set var "+sEnvVar+"_y";
      v <= current_project.script.findVariable(sEnvVar+"_y");
      v.pointerAssign(curve_envs.get(1));
      v.store();

      // trace "[trc] GEnvelopeCurve4: set var "+sEnvVar+"_z";
      v <= current_project.script.findVariable(sEnvVar+"_z");
      v.pointerAssign(curve_envs.get(2));
      v.store();

      // trace "[trc] GEnvelopeCurve4: set var "+sEnvVar+"_w";
      v <= current_project.script.findVariable(sEnvVar+"_w");
      v.pointerAssign(curve_envs.get(3));
      v.store();
   }

   // <method.png>
   public virtual emitModulePost(GModule _module) {
      if(b_init_done && !b_post_done)
      {
         b_post_done = true;

         local PointerArray parents;
         parents.add(this);
         GObject::emitPost(_module, null/*_program*/, parents);
         parents.remove(this);

         if(current_project.b_export)
         {
            local String sEnvVar <= getVarName();

            current_project.exportAddEnvelope(_module,
                                              sEnvVar+"_x",
                                              curve_envs.get(0)
                                              );

            current_project.exportAddEnvelope(_module,
                                              sEnvVar+"_y",
                                              curve_envs.get(1)
                                              );

            current_project.exportAddEnvelope(_module,
                                              sEnvVar+"_z",
                                              curve_envs.get(2)
                                              );

            current_project.exportAddEnvelope(_module,
                                              sEnvVar+"_w",
                                              curve_envs.get(3)
                                              );
         }
         else
         {
            updateEnvVars();
         }
      }
   }

}
