// ----
// ---- file   : gconstantrgba.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 15Jun2020
// ---- changed: 16Jun2020, 18Jun2020, 09Jul2020, 11Jul2020, 01Aug2020, 14Aug2020, 07Feb2025
// ----          14Feb2025
// ----
// ----
// ----
module MGConstantRGBA;

use namespace ui;
use namespace gledit;


// <class.png>
class GConstantRGBA : GConstant, ColorPickerListener {


   // <method_new.png>
   public static New() : GConstantRGBA {
      local GConstantRGBA r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GConstant::init();
      type = TYPE_VEC4;

      GParamFloat *p;

      p <= addParamFloat("r", "r", 1.0f, 0.0f, 0.0f, 1.0f, 1.0, 0.5f);
      p.b_percent = true;

      p <= addParamFloat("g", "g", 1.0f, 0.0f, 0.0f, 1.0f, 1.0, 0.5f);
      p.b_percent = true;

      p <= addParamFloat("b", "b", 1.0f, 0.0f, 0.0f, 1.0f, 1.0, 0.5f);
      p.b_percent = true;

      p <= addParamFloat("a", "a", 1.0f, 0.0f, 0.0f, 1.0f, 1.0, 0.5f);
      p.b_percent = true;

      addInput("r", TYPE_FLOAT);
      addInput("g", TYPE_FLOAT);
      addInput("b", TYPE_FLOAT);
      addInput("a", TYPE_FLOAT);

      addOutput(GOutput.OUT_DEF, type);
   }

   // <method_get.png>
   public virtual getOpAuto() : int {
      return OP_RGBA_SRC_OVER;
   }

   // <method_get.png>
   public method getC32() : int {
      int r = getFloatParamById("r") * 255;
      int g = getFloatParamById("g") * 255;
      int b = getFloatParamById("b") * 255;
      int a = getFloatParamById("a") * 255;
      if(r > 255)
         r = 255;
      if(g > 255)
         g = 255;
      if(b > 255)
         b = 255;
      if(a > 255)
         a = 255;
      trace "xxx gconstantrgba: a="+a;
      return argb(a, r, g, b);
   }

   // <method_get.png>
   public virtual getString() : String {
      local Integer ioR = getFloatParamById("r") * 255;
      local Integer ioG = getFloatParamById("g") * 255;
      local Integer ioB = getFloatParamById("b") * 255;
      local Integer ioA = getFloatParamById("a") * 255;
      if(ioR > 255)
         ioR = 255;
      if(ioG > 255)
         ioG = 255;
      if(ioB > 255)
         ioB = 255;
      if(ioA > 255)
         ioA = 255;
      return "#"+ioA.printf("%02x")+ioR.printf("%02x")+ioG.printf("%02x")+ioB.printf("%02x");
   }

   // <ui.png>
   public virtual hasDefaultAction() : boolean {
      return true;
   }

   // <ui_handle.png>
   public virtual execDefaultAction() {
      ShowColorPickerDialog(getC32(), this/*colorPickerListener*/);
   }

   // <ui_handle.png>
   public method colorPickerHandleColorChanged(int _c32) {
      float a = ((_c32 >> 24)&255) / 255.0;
      float r = ((_c32 >> 16)&255) / 255.0;
      float g = ((_c32 >>  8)&255) / 255.0;
      float b = ((_c32      )&255) / 255.0;
      trace "[trc] GConstantRGBA::colorPickerHandleColorChanged: rgba=("+r+";"+g+";"+b+";"+a+")";
      setFloatParamById("r", r);
      setFloatParamById("g", g);
      setFloatParamById("b", b);
      setFloatParamById("a", a);
      PageStart pgStart <= root_form.pg_start;
      pgStart.handleParamEdited("r", false/*bReshowParams*/);
      pgStart.handleParamEdited("g", false/*bReshowParams*/);
      pgStart.handleParamEdited("b", false/*bReshowParams*/);
      pgStart.handleParamEdited("a", true/*bReshowParams*/);
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {
      float r = getFloatParamById("r");
      float g = getFloatParamById("g");
      float b = getFloatParamById("b");
      float a = getFloatParamById("a");

      _parents.add(this);
      local GInput *input;

      // r
      local String *sR;
      input <= getInputById("r");
      if(input.isConnected())
      {
         sR <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_r");
         input.emit(_module, _program, _out, sR, _bGLSL, _parents);
         _out.append(sR+" += "+r+";\n");
      }
      else
         sR <= String(r);

      // g
      local String *sG;
      input <= getInputById("g");
      if(input.isConnected())
      {
         sG <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_g");
         input.emit(_module, _program, _out, sG, _bGLSL, _parents);
         _out.append(sG+" += "+g+";\n");
      }
      else
         sG <= String(g);

      // b
      local String *sB;
      input <= getInputById("b");
      if(input.isConnected())
      {
         sB <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_b");
         input.emit(_module, _program, _out, sB, _bGLSL, _parents);
         _out.append(sB+" += "+b+";\n");
      }
      else
         sB <= String(b);

      // a
      local String *sA;
      input <= getInputById("a");
      if(input.isConnected())
      {
         sA <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_a");
         input.emit(_module, _program, _out, sA, _bGLSL, _parents);
         _out.append(sA+" += "+a+";\n");
      }
      else
         sA <= String(a);

      if(_bGLSL)
         _out.append(_dstVar+" = vec4("+sR+", "+sG+", "+sB+", "+sA+");\n");
      else
         _out.append(_dstVar+" = vector4f("+sR+", "+sG+", "+sB+", "+sA+");\n");

      _parents.remove(this);
   }
}
