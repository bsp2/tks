// ----
// ---- file   : gmodswitch.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 09Jul2020
// ---- changed: 10Jul2020, 11Jul2020, 09Aug2020, 12Aug2020, 13Aug2020, 14Aug2020
// ----
// ----
// ----
module MGModSwitch;

use namespace ui;
use namespace gledit;


// <class.png>
class GModSwitch : GMod, GParamProvider, GConnectionContainer {
   // switches between "n" inputs

   define int INPUT_MODE_INPUTS      = 0;
   define int INPUT_MODE_CONNECTIONS = 1;

   protected boolean b_init_done;
   protected String *s_var_switch_idx;


   // <method_init.png>
   public virtual init() {
      GMod::init();

      GParam *p;

      addParamChoiceIOType("io_type", "IO Type", TYPE_FLOAT);

      p <= addParamChoice("input_mode", "Input Mode", 1, ["Inputs", "Connections"]);
      p.setToolTipCaption("Input Mode");

      p <= addParamInt("num_inputs", "Num Inputs", 1, 1, 1,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1);
      p.setToolTipCaption("Number of Inputs (for Input Mode \"Input\")");

      p <= addParamInt("initial_input", "Initial Input", 1, 1, 1,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1);
      p.setToolTipCaption("Initial Input Nr\n\n (note) only has an effect when switch_idx input is not connected");

      p <= addParamInt("forced_input",  "Forced Input",  0, 0, 0,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       GConnectionContainer.MAX_CONTAINER_CONNECTIONS,
                       -1);
      p.setToolTipCaption("When >0, skip all other inputs and calculate only the forced input\n\n (note) useful while editing / debugging");

      p <= addParamBool("eval_all", "Eval All", false);
      p.setToolTipCaption("When checked, always calculate all inputs (and set output to selected input result)\n\nWhen unchecked, calculate currently active input only [default]");

      p <= addParamChoice("repeat", "Repeat", 1, ["Clamp", "Wrap"]);
      p.setToolTipCaption("Repeat Mode");

      addInput("switch_idx", TYPE_INT);
      addInput("reset", TYPE_BOOL);
      addInput("prev", TYPE_BOOL);
      addInput("next", TYPE_BOOL);
      // // addInput("input_01", TYPE_FLOAT);
      lazyAddInputs();

      addOutput(GOutput.OUT_DEF, TYPE_FLOAT);
   }

   // <method_get.png>
   public virtual getPreferredIdPrefix() : String {
      return "switch";
   }

   // <ui_handle.png>
   public virtual handleParamChanged(String _paramId) {
      if("io_type" == _paramId)
      {
         updateIOType();
      }
      else if(("num_inputs" == _paramId) || ("input_mode" == _paramId))
      {
         lazyAddInputs();
         lazyRemoveUnconnectedInputs();
      }
   }

   // <method.png>
   protected method updateIOType() {
      GOutput output <= getOutputById(GOutput.OUT_DEF);
      int ioType = getChoiceIOTypeParamById("io_type");
      output.type = ioType;

      GInput *input;
      foreach input in inputs
      {
         if(input.id <= "input_")
         {
            input.type = ioType;
         }
      }

      // Update connections
      handleOutputTypeChanged(output);

      type = ioType;
   }

   // <method.png>
   protected method getNumInputPorts() : int {
      int inputMode = getChoiceParamById("input_mode");
      if(INPUT_MODE_INPUTS == inputMode)
         return getIntParamById("num_inputs");
      else
         return 0;
   }

   // <method.png>
   protected method getNumInputs() : int {
      int inputMode = getChoiceParamById("input_mode");
      if(INPUT_MODE_INPUTS == inputMode)
         return getIntParamById("num_inputs");
      else
      {
         GInput input <= getInputById("input_conn");
         if(null != input)
            return input.getNumActiveConnections();
         else
            return 0;
      }
   }

   // <method_remove.png>
   protected method lazyAddInputs() {
      int ioType = getChoiceIOTypeParamById("io_type");
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null == input)
            {
               addInput(inputName, ioType);
            }
            inputNr++;
         }
      }
      else
      {
         if(null == getInputById("input_conn"))
            addInput("input_conn", ioType);
      }
   }

   // <method_remove.png>
   protected method lazyRemoveUnconnectedInputs() {
      GInput *input;
      int inputIdx = 0;
      int inputMode = getChoiceParamById("input_mode");
      int numInputs = getIntParamById("num_inputs");
      while(inputIdx < inputs.numElements)
      {
         boolean bRemoved = false;
         input <= inputs.get(inputIdx);
         if(input.id <= "input_")
         {
            boolean bRemove = false;
            if(INPUT_MODE_INPUTS == inputMode)
            {
               if("input_conn" != input.id)
               {
                  int inputNr = input.id.substring(6,-1);
                  bRemove = (inputNr > numInputs);
               }
            }
            else
            {
               bRemove = ("input_conn" != input.id);
            }
            if(bRemove)
            {
               if(!input.isConnected())
               {
                  inputs.delete(inputIdx);
                  bRemoved = true;
               }
            }
         }
         if(!bRemoved)
            inputIdx++;
      }
   }

   // // // <method_get.png>
   // // public virtual getSupportedAnonInputObjectTypes(String _inputId) : PointerArray {
   // //    if((null == _inputId) || (_inputId <= "input_"))
   // //    {
   // //       return GDefs.GetAnonObjectTypesByIOType(type);
   // //    }
   // //    return null;
   // // }

   // <method_set.png>
   public virtual containerSetForcedConnectionOrProbe(GConnection _conn, boolean _bProbe) {
      // when 's' is pressed in inputs table
      Global.Debug("GModSwitch::containerSetForcedConnection: conn="+#(_conn));
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null != input)
            {
               if(-1 != input.findActiveConnectionIndex(_conn))
               {
                  if(!_bProbe)
                  {
                     setIntParamById("forced_input", inputNr);
                     current_project.queueUpdate();
                  }
                  return true;
               }
            }
            inputNr++;
         }
      }
      else
      {
         input <= getInputById("input_conn");
         int activeIdx = input.findActiveConnectionIndex(_conn);
         // trace "xxx activeIdx="+activeIdx;
         if(-1 != activeIdx)
         {
            if(!_bProbe)
            {
               setIntParamById("forced_input", activeIdx+1);
               current_project.queueUpdate();
            }
            return true;
         }
      }

      if(!_bProbe)
      {
         setIntParamById("forced_input", 0);
         current_project.queueUpdate();
      }
      return false;
   }

   // <method_find.png>
   public virtual containerFindConnectionByObject(GObject _obj) : GConnection {
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      GConnection *conn;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null != input)
            {
               foreach conn in input.connections
               {
                  if(@(conn.object) == @(_obj))
                     return conn;
               }
            }
            inputNr++;
         }
      }
      else
      {
         input <= getInputById("input_conn");
         foreach conn in input.connections
         {
            if(@(conn.object) == @(_obj))
               return conn;
         }
      }
      return null;
   }

   // <method_get.png>
   public method containerGetNumActiveConnections() : int {
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      int r = 0;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = 1;
         loop(numInputs)
         {
            local String inputName <= "input_"+inputNr.printf("%02d");
            input <= getInputById(inputName);
            if(null != input)
            {
               r += input.getNumActiveConnections();
            }
            inputNr++;
         }
      }
      else
      {
         input <= getInputById("input_conn");
         r += input.getNumActiveConnections();
      }
      return r;
   }

   // <method_get.png>
   public virtual containerGetActiveConnectionByIndex(int _idx) : GConnection {
      int inputMode = getChoiceParamById("input_mode");
      GInput *input;
      if(INPUT_MODE_INPUTS == inputMode)
      {
         int numInputs = getNumInputPorts();
         Integer inputNr = _idx + 1;
         local String inputName <= "input_"+inputNr.printf("%02d");
         input <= getInputById(inputName);
         if(null != input)
         {
            return input.getActiveConnectionByIndex(0);
         }
      }
      else
      {
         input <= getInputById("input_conn");
         return input.getActiveConnectionByIndex(_idx);
      }
   }

   // <method_get.png>
   public virtual containerIsForcedConnection(GConnection _conn) : boolean {
      // trace "xxx GModSwitch::containerIsForcedConnection: ENTER _conn="+#(_conn);
      if(null != _conn)
      {
         int forcedInput = getIntParamById("forced_input");
         if(forcedInput > 0)
         {
            GConnection conn <= containerGetActiveConnectionByIndex(forcedInput-1);
            // trace "xxx GModSwitch::containerIsForcedConnection: conn="+#(conn)+" _conn="+#(_conn);
            if(@(_conn) == @(conn))
               return true;
         }
      }
      return false;
   }

   // <method_get.png>
   public virtual containerIsForcedConnectionObject(GObject _obj) : boolean {
      int idx = getIntParamById("forced_input") - 1;
      if(idx >= 0)
      {
         GConnection conn <= containerGetActiveConnectionByIndex(idx);
         if(null != conn)
         {
            return (@(conn.object) == @(_obj));
         }
      }
      return false;
   }

  // <save.png>
   public virtual saveStateObject(local Stream ofs, local GConnectionWriter connectionWriter) {
      GObject::saveStateObject(ofs, connectionWriter);

      // Version
      ofs.i16 = 1;

      // Params
      GParamProvider::saveStateParamProvider(ofs, connectionWriter);
   }

   // <load.png>
   public method loadStateObject(local Stream ifs) : boolean {
      // (note) base class object info is loaded by LoadStateObject

      // Version
      short ver = ifs.u16;

      if(1 <= ver <= 1)
      {
         if(GParamProvider::loadStateParamProvider(ifs))
         {
            updateIOType();

            lazyAddInputs();
            lazyRemoveUnconnectedInputs();

            // Succeeded
            return true;
         }
         else
         {
            trace "[---] GModSwitch::loadStateObject: failed to load params, this="+#(this)+" path="+getObjectPath();
         }
      }
      else
      {
         trace "[---] GModSwitch::loadStateObject: invalid version "+ver+", this="+#(this)+" path="+getObjectPath();
      }
      return false;
   }

   // <method.png>
   public virtual emitBegin() {
      b_init_done = false;
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {
      _parents.add(this);

      local int initialInput = getIntParamById("initial_input");
      local int inputMode = getChoiceParamById("input_mode");
      local int numInputs = getNumInputs();

      if(!b_init_done)
      {
         b_init_done = true;
         s_var_switch_idx <= _module.allocGlobalVarScript(this, TYPE_INT, "switch_idx", String((initialInput - 1)));
      }
      local String sVarSwitchIdx <= s_var_switch_idx;

      local int forcedInput = getIntParamById("forced_input");
      if(0 == forcedInput)
      {
         local GInput inSwitchIdx <= getInputById("switch_idx");
         if(inSwitchIdx.isConnected())
            inSwitchIdx.emit(_module, _program, _out, sVarSwitchIdx, _bGLSL, _parents);

         local GInput inReset <= getInputById("reset");
         if(inReset.isConnected())
         {
            local String sVarReset <= _module.allocTmpVarScript(_out, TYPE_BOOL, id+"_reset");
            inReset.emit(_module, _program, _out, sVarReset, _bGLSL, _parents);
            _out.append("if("+sVarReset+") "+sVarSwitchIdx+" = "+(initialInput - 1)+";\n");
         }

         local GInput inPrev <= getInputById("prev");
         if(inPrev.isConnected())
         {
            local String sVarPrev <= _module.allocTmpVarScript(_out, TYPE_BOOL, id+"_prev");
            inPrev.emit(_module, _program, _out, sVarPrev, _bGLSL, _parents);
            _out.append("if("+sVarPrev+") "+sVarSwitchIdx+"--;\n");
         }

         local GInput inNext <= getInputById("next");
         if(inNext.isConnected())
         {
            local String sVarNext <= _module.allocTmpVarScript(_out, TYPE_BOOL, id+"_next");
            inNext.emit(_module, _program, _out, sVarNext, _bGLSL, _parents);
            _out.append("if("+sVarNext+") "+sVarSwitchIdx+"++;\n");
         }

         int repeatMode = getChoiceParamById("repeat");
         if(0 == repeatMode)
         {
            // Clamp
            _out.append("if("+sVarSwitchIdx+" < 0) "+sVarSwitchIdx+" = 0; else if("+sVarSwitchIdx+" >= "+numInputs+") "+sVarSwitchIdx+" = "+(numInputs - 1)+";\n");
         }
         else
         {
            // Wrap
            _out.append("if("+sVarSwitchIdx+" < 0) "+sVarSwitchIdx+" += "+numInputs+"; else if("+sVarSwitchIdx+" >= "+numInputs+") "+sVarSwitchIdx+" -= "+numInputs+";\n");
         }
      }

      local int inputIdx = 0;
      local Integer inputNr = 1;
      local GInput *input;
      local String sInEmit;

      if(getBoolParamById("eval_all"))
      {
         local String sCalc;
         local String sSwitch;
         sSwitch.append("switch("+sVarSwitchIdx+")\n{\n");
         sSwitch.append("   default:\n");

         // Calculate all inputs
         loop(numInputs)
         {
            if( (0 == forcedInput) || (forcedInput == inputNr) )
            {
               if(INPUT_MODE_INPUTS == inputMode)
                  input <= getInputById("input_"+inputNr.printf("%02d"));
               else
                  input <= getInputById("input_conn");

               sCalc.append("// input "+inputNr+"/"+numInputs+": "+input.getConnectionInfoString()+"\n");
               local String sVarIn <= _module.allocTmpVarScript(sCalc, input.type, id+"_case_"+inputIdx);
               sInEmit.empty();
               if(INPUT_MODE_INPUTS == inputMode)
                  input.emit(_module, _program, sInEmit, sVarIn, _bGLSL, _parents);
               else
                  input.emitFltConn(inputIdx/*fltConnIdx*/, _module, _program, sInEmit, sVarIn, _bGLSL, _parents);
               Utils.AppendIndentedLines(sCalc, sInEmit, 0);
               sSwitch.append("   case "+inputIdx+": "+((0 != forcedInput)?" // forced":"")+"\n");
               sSwitch.append("      "+_dstVar+" = "+sVarIn+";\n");
               sSwitch.append("      break;\n");
            }

            // Next input
            inputIdx++;
            inputNr++;
         }
         sSwitch.append("} // switch("+sVarSwitchIdx+")\n");

         _out.append(sCalc);
         _out.append(sSwitch);
      }
      else
      {
         // Calculate selected input only
         if(0 == forcedInput)
         {
            _out.append("switch("+sVarSwitchIdx+")\n{\n");
            _out.append("   default:\n");

            loop(numInputs)
            {
               if(inputIdx > 0)
                  _out.append("\n");
               if(INPUT_MODE_INPUTS == inputMode)
                  input <= getInputById("input_"+inputNr.printf("%02d"));
               else
                  input <= getInputById("input_conn");
               _out.append("   case "+inputIdx+":\n");
               _out.append("      // input "+inputNr+"/"+numInputs+": "+input.getConnectionInfoString()+"\n");
               sInEmit.empty();
               if(INPUT_MODE_INPUTS == inputMode)
                  input.emit(_module, _program, sInEmit, _dstVar, _bGLSL, _parents);
               else
                  input.emitFltConn(inputIdx/*fltConnIdx*/, _module, _program, sInEmit, _dstVar, _bGLSL, _parents);
               Utils.AppendIndentedLines(_out, sInEmit, 6);
               _out.append("      break;\n");

               // Next input
               inputIdx++;
               inputNr++;
            }
            _out.append("} // switch("+sVarSwitchIdx+")\n");
         }
         else
         {
            _out.append("// forced input nr="+forcedInput+":\n");
            if(INPUT_MODE_INPUTS == inputMode)
               input <= getInputById("input_"+forcedInput.printf("%02d"));
            else
               input <= getInputById("input_conn");
            if(null != input)
            {
               sInEmit.empty();
               if(INPUT_MODE_INPUTS == inputMode)
                  input.emit(_module, _program, sInEmit, _dstVar, _bGLSL, _parents);
               else
                  input.emitFltConn((forcedInput-1)/*fltConnIdx*/, _module, _program, sInEmit, _dstVar, _bGLSL, _parents);
               Utils.AppendIndentedLines(_out, sInEmit, 6);
            }
            else
            {
               _out.append("//  => err, forcedInput="+forcedInput+" does not exist, skipping\n");
            }
         }
      }

      _parents.remove(this);
   }

}
