// ----
// ---- file   : gconstantvec2.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 12Jun2020
// ---- changed: 13Jun2020, 14Jun2020, 15Jun2020, 16Jun2020, 18Jun2020, 21Jun2020, 09Jul2020
// ----          20Jul2020, 14Aug2020
// ----
// ----
// ----
module MGConstantVec2;

use namespace ui;
use namespace gledit;


// <class.png>
class GConstantVec2 : GConstant {

   // <method_new.png>
   public static New() : GConstantVec2 {
      local GConstantVec2 r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GConstant::init();
      type = TYPE_VEC2;

      addParamFloat("x", "x", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamFloat("y", "y", 0.0f, -100.0f, FLT_MIN, 100.0f, FLT_MAX, 0.0f);
      addParamBool("normalize", "normalize", false);

      addInput("x", TYPE_FLOAT);
      addInput("y", TYPE_FLOAT);

      addInput("xy", TYPE_VEC2);

      addOutput(GOutput.OUT_DEF, type);
   }

   // <method_get.png>
   public virtual getString() : String {
      float x = getFloatParamById("x");
      float y = getFloatParamById("y");
      return "vec2("+x+", "+y+")";
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {
      float x = getFloatParamById("x");
      float y = getFloatParamById("y");
      boolean bNormalize = getBoolParamById("normalize");

      _parents.add(this);

      local GInput *input;

      // x
      local String *sX;
      input <= getInputById("x");
      if(input.isConnected())
      {
         sX <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_x");
         input.emit(_module, _program, _out, sX, _bGLSL, _parents);
         _out.append(sX+" += "+x+";\n");
      }
      else
         sX <= String(x);

      // y
      local String *sY;
      input <= getInputById("y");
      if(input.isConnected())
      {
         sY <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_y");
         input.emit(_module, _program, _out, sY, _bGLSL, _parents);
         _out.append(sY+" += "+y+";\n");
      }
      else
         sY <= String(y);

      // xy
      local String *sXY;
      input <= getInputById("xy");
      if(input.isConnected())
      {
         sXY <= _module.allocTmpVarScript(_out, TYPE_VEC2, "in_xy");
         input.emit(_module, _program, _out, sXY, _bGLSL, _parents);

         if(_bGLSL)
         {
            if(bNormalize)
            {
               _out.append(_dstVar+" = normalize(vec2("+sX+"+"+sXY+".x, "+sY+"+"+sXY+".y));\n");
            }
            else
            {
               _out.append(_dstVar+" = vec2("+sX+"+"+sXY+".x, "+sY+"+"+sXY+".y);\n");
            }
         }
         else
         {
            _out.append(_dstVar+" = vector2f("+sX+"+"+sXY+".x, "+sY+"+"+sXY+".y);\n");
            if(bNormalize)
               _out.append(_dstVar+".unit();\n");
         }
      }
      else
      {
         if(_bGLSL)
         {
            if(bNormalize)
            {
               _out.append(_dstVar+" = normalize(vec2("+sX+", "+sY+"));\n");
            }
            else
            {
               _out.append(_dstVar+" = vec2("+sX+", "+sY+");\n");
            }
         }
         else
         {
            _out.append(_dstVar+" = vector2f("+sX+", "+sY+");\n");
            if(bNormalize)
               _out.append(_dstVar+".unit();\n");
         }
      }

      _parents.remove(this);
   }
}
