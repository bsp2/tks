// ----
// ---- file   : gconstantrgb.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "GL edit" application.
// ----
// ---- created: 15Jun2020
// ---- changed: 16Jun2020, 18Jun2020, 09Jul2020, 11Jul2020, 01Aug2020, 02Aug2020, 14Aug2020
// ----          07Feb2025, 14Feb2025
// ----
// ----
// ----
module MGConstantRGB;

use namespace ui;
use namespace gledit;


// <class.png>
class GConstantRGB : GConstant, ColorPickerListener {

   // <method_new.png>
   public static New() : GConstantRGB {
      local GConstantRGB r;
      r.init();
      return deref r;
   }

   // <method_init.png>
   public virtual init() {
      GConstant::init();
      type = TYPE_VEC3;

      GParamFloat *p;

      p <= addParamFloat("r", "r", 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f);
      p.b_percent = true;

      p <= addParamFloat("g", "g", 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f);
      p.b_percent = true;

      p <= addParamFloat("b", "b", 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f);
      p.b_percent = true;

      addInput("r", TYPE_FLOAT);
      addInput("g", TYPE_FLOAT);
      addInput("b", TYPE_FLOAT);

      addOutput(GOutput.OUT_DEF, type);
   }

   // <method_get.png>
   public virtual getString() : String {
      local Integer ioR = getFloatParamById("r") * 255;
      local Integer ioG = getFloatParamById("g") * 255;
      local Integer ioB = getFloatParamById("b") * 255;
      if(ioR > 255)
         ioR = 255;
      if(ioG > 255)
         ioG = 255;
      if(ioB > 255)
         ioB = 255;
      return "#"+ioR.printf("%02x")+ioG.printf("%02x")+ioB.printf("%02x");
   }

   // <method_get.png>
   public method getC32() : int {
      int r = getFloatParamById("r") * 255;
      int g = getFloatParamById("g") * 255;
      int b = getFloatParamById("b") * 255;
      if(r > 255)
         r = 255;
      if(g > 255)
         g = 255;
      if(b > 255)
         b = 255;
      return argb(255, r, g, b);
   }

   // <method_get.png>
   public virtual getOpAuto() : int {
      return OP_RGB_HARDLIGHT;
   }

   // <ui.png>
   public virtual hasDefaultAction() : boolean {
      return true;
   }

   // <ui_handle.png>
   public virtual execDefaultAction() {
      ShowColorPickerDialog(getC32(), this/*colorPickerListener*/);
   }

   // <ui_handle.png>
   public method colorPickerHandleColorChanged(int _c32) {
      float r = ((_c32 >> 16)&255) / 255.0;
      float g = ((_c32 >>  8)&255) / 255.0;
      float b = ((_c32      )&255) / 255.0;
      trace "[trc] GConstantRGB::colorPickerHandleColorChanged: rgb=("+r+";"+g+";"+b+")";
      setFloatParamById("r", r);
      setFloatParamById("g", g);
      setFloatParamById("b", b);
      PageStart pgStart <= root_form.pg_start;
      pgStart.handleParamEdited("r", false/*bReshowParams*/);
      pgStart.handleParamEdited("g", false/*bReshowParams*/);
      pgStart.handleParamEdited("b", true/*bReshowParams*/);
   }

   // <method.png>
   public virtual emit(local String       _outputId,
                       local GModule      _module,
                       local GProgram     _program,
                       local String       _out,
                       local String       _dstVar,
                       local boolean      _bGLSL,
                       local PointerArray _parents
                       ) {
      float r = getFloatParamById("r");
      float g = getFloatParamById("g");
      float b = getFloatParamById("b");

      _parents.add(this);
      local GInput *input;

      // r
      local String *sR;
      input <= getInputById("r");
      if(input.isConnected())
      {
         sR <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_r");
         input.emit(_module, _program, _out, sR, _bGLSL, _parents);
         _out.append(sR+" += "+r+";\n");
      }
      else
         sR <= String(r);

      // g
      local String *sG;
      input <= getInputById("g");
      if(input.isConnected())
      {
         sG <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_g");
         input.emit(_module, _program, _out, sG, _bGLSL, _parents);
         _out.append(sG+" += "+g+";\n");
      }
      else
         sG <= String(g);

      // b
      local String *sB;
      input <= getInputById("b");
      if(input.isConnected())
      {
         sB <= _module.allocTmpVarScript(_out, TYPE_FLOAT, "in_b");
         input.emit(_module, _program, _out, sB, _bGLSL, _parents);
         _out.append(sB+" += "+b+";\n");
      }
      else
         sB <= String(b);

      if(_bGLSL)
         _out.append(_dstVar+" = vec3("+sR+", "+sG+", "+sB+");\n");
      else
         _out.append(_dstVar+" = vector3f("+sR+", "+sG+", "+sB+");\n");

      _parents.remove(this);
   }
}
