// ----
// ---- file   : PluginListVST2TM.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2018-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- changed: 13Feb2018
// ---- created: 20Jul2019, 29Jul2023, 22Mar2024, 06Jul2024, 03Aug2024
// ----
// ----
// ----

module MPluginListVST2TM;

use namespace ui;
use namespace st2;


// <class.png>
class PluginListVST2TM : TableModel {

   define int COL_NAME = 0;

   protected VSTVendor *[] vendors;  // VSTVendor instances
   int total_num_plugin_rows;


   // <method_set.png>
   public method setVendors(PointerArray _vendors) {
      vendors <= deref _vendors;
      total_num_plugin_rows = 0;
   }

   // <method_get.png>
   protected method getEntryByIdx(int _idx, Boolean _bRetIsHeader) : VSTScanEntry {
      _bRetIsHeader = false;

      if(null != vendors)
      {
         VSTVendor *vendor;
         int idx = 0;

         foreach vendor in vendors
         {
            if(_idx == idx)
            {
               // Vendor header
               _bRetIsHeader = true;
               return vendor.entries.get(0);
            }
            else if(_idx < (idx + 1 + vendor.entries.numElements))
            {
               return vendor.entries.get(_idx - idx - 1);
            }

            // Next vendor
            idx += 1 + (vendor.entries.numElements);
         }
      }
      return null;
   }

   // <method.png>
   public virtual tableModelChanged() {
      total_num_plugin_rows = 0;

      if(null != vendors)
      {
         VSTVendor *vendor;
         foreach vendor in vendors
         {
            total_num_plugin_rows += 1 + (vendor.entries.numElements);
         }
      }

      TableModel::tableModelChanged();
   }

   // <method_get.png>
   public virtual getNumColumns() : int {
      return 1;
   }

   // <method_get.png>
   public virtual getColumnCaption(int _col) : String {
      return ["Name"][_col];
   }

   // <method_get.png>
   public virtual getNumRows() : int {
      return total_num_plugin_rows;
   }

   // <method_get.png>
   public virtual getDragObject(int _row) : Object {
      Boolean bIsHeader;
      VSTScanEntry en <= getEntryByIdx(_row, bIsHeader);
      if(!bIsHeader)
      {
         return en;
      }
      return null;
   }

   // <method_get.png>
   public virtual getCellCaption(int _col, _row) : String {
      Boolean bIsHeader;
      VSTScanEntry en <= getEntryByIdx(_row, bIsHeader);

      if(null != en)
      {
         if(bIsHeader)
         {
            switch(_col)
            {
               case COL_NAME:
                  return en.vendor_string;
            }
         }
         else
         {
            switch(_col)
            {
               case COL_NAME:
                  return en.getEffectName();
            }
         }
      }
   }

   // <method_get.png>
   public virtual getMinimumColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_NAME:
            return 80;
      }
   }

   // <method_get.png>
   public virtual getMaximumColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_NAME:
            return 100;
      }
   }

   // <method_get.png>
   public virtual getPreferredColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_NAME:
            return 170;
      }
   }

   // <method_get.png>
   public virtual getCellRenderer(int _col, int _row, int _visibleRow) : Layer {
      Label lb <= TableModel::getCellRenderer(_col, _row, _visibleRow);

      Boolean bIsHeader;
      VSTScanEntry en <= getEntryByIdx(_row, bIsHeader);

      if(null != en)
      {
         lb.setEnableFillBackground(true);

         if(bIsHeader)
         {
            lb.setFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);
            lb.setInnerPadding4f(4, 1, 1, 1);
            lb.setBackgroundTint(#20000000);
            lb.setToolTipCaption(null);
         }
         else
         {
            lb.setInnerPadding4f(1, 1, 1, 1);
            lb.setBackgroundTint(0);
            lb.setToolTipCaption(en.getUniqueIDString());
         }
      }

      return lb;
   }

   // <method_update.png>
   public virtual updateCellRendererColors(Layer l, int _col, int _row, int _visibleRow) {
      Boolean bIsHeader;
      VSTScanEntry en <= getEntryByIdx(_row, bIsHeader);

      // (note) default fg/bg cell colors are overridden in PluginListVST2.tks:init()
      TableModel::updateCellRendererColors(l, _col, _row, _visibleRow);

      if(null != en)
      {
         if(cursor_index != _row)
         {
            l.setBackgroundColor(0);
            l.setEnableFillBackground(false);
         }

         if(bIsHeader)
         {
            l.setForegroundColor(#ffa8a29e);
            l.setBackgroundColor(#ff29292d);
            l.setEnableFillBackground(true);
         }
      }
   }

}
