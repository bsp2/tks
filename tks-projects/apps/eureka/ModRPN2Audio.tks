// ----
// ---- file   : ModRPN2Audio.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2021-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 13Apr2021
// ---- changed: 09Dec2021, 27Dec2021, 29Jul2023, 03Dec2023, 19Sep2024, 05Jan2025, 07Jan2025
// ----
// ----
// ----

module MModRPN2Audio;

namespace st2;


// <class.png>
class ModRPN2Audio : Mod {

   define int PARAM_NONE         = 0;
   define int PARAM_SLEW_RISE    = 1;  // 0..1
   define int PARAM_SLEW_FALL    = 2;  // 0..1
   define int PARAM_CURVE        = 3;  // 0..1 => -1..1
   define int NUM_PARAMS         = 4;

   int rpn_offset;  // 0..15 => RPN 1..16

   float slew_rise;
   float slew_fall;
   float curve;     // -1..1 => log..lin..exp

   protected float dest_val;
   protected float last_out;


   // <method_init.png>
   public virtual init() {
      Mod::init();
      allocateIOBuffers(DEF_NUM_IO_BUFFERS/*numIn*/, DEF_NUM_IO_BUFFERS/*numOut*/);

      slew_rise = 0.7;
      slew_fall = 0.7;
      curve     = 0.0;

      addInput("In L");
      addInput("In R");

      addOutput("Out L");
      addOutput("Out R");
   }

   // <method_exit.png>
   public virtual exit() {
      Mod::exit();
   }

   // <method_get.png>
   public virtual getName() : String {
      return "RPN2Audio";
   }

   // <method.png>
   public virtual isEffect() : boolean {
      return true;
   }

   // <method.png>
   public virtual modClone(boolean _bFullInit) : Mod {
      ModRPN2Audio cl <= new ModRPN2Audio;
      cl.init();
      cl.modCopyBaseFrom(this);
      return deref cl;
   }

   // <method.png>
   public virtual modIsPatchCompatibleWith(Mod _o) : boolean {
      return (_o instanceof ModRPN2Audio);
   }

   // <method.png>
   public virtual modCopyPatchFrom(Mod _o) : boolean {
      if(_o instanceof ModRPN2Audio)
      {
         ModRPN2Audio o <= _o;
         rpn_offset = o.rpn_offset;
         slew_rise  = o.slew_rise;
         slew_fall  = o.slew_fall;
         curve      = o.curve;
         return true;
      }
      return false;
   }

   // <method_get.png>
   public virtual getNumParameters() : int {
      return NUM_PARAMS;
   }

   // <method_get.png>
   public virtual getParameterNamesArray(StringArray _retParamNames) : boolean {
      _retParamNames.empty();

      _retParamNames = [
         "-",           //  0: PARAM_NONE
         "Slew Rise",   //  1: PARAM_SLEW_RISE
         "Slew Fall",   //  2: PARAM_SLEW_FALL
         "Curve",       //  3: PARAM_CURVE
                        ];

      return true;
   }

   // <method_set.png>
   public virtual setParameterValue(local int _idx, local float _value) {
      // // trace "xxx ModRPN2Audio::setParameterValue: idx="+_idx+" value="+_value;

      switch(_idx)
      {
         case PARAM_SLEW_RISE:
            setSlewRise(_value);
            queueUIUpdate();
            break;

         case PARAM_SLEW_FALL:
            setSlewFall(_value);
            queueUIUpdate();
            break;

         case PARAM_CURVE:
            setCurve(_value * 2.0f - 1.0f);
            queueUIUpdate();
            break;
      }
   }

   // <method.png>
   public method setRPNOffset(local int _off) {
      mtx_param.lock();
      rpn_offset = _off;
      mtx_param.unlock();
   }

   // <method.png>
   public method setSlewRise(local float _f) {
      mtx_param.lock();
      slew_rise = _f;
      mtx_param.unlock();
   }

   // <method.png>
   public method setSlewFall(local float _f) {
      mtx_param.lock();
      slew_fall = _f;
      mtx_param.unlock();
   }

   // <method.png>
   public method setCurve(local float _f) {
      mtx_param.lock();
      curve = _f;
      mtx_param.unlock();
   }

   // <save.png>
   public virtual saveState(Stream _ofs) : boolean {

      Mod::saveState(_ofs);

      // Write version
      _ofs.i16 = 2;

      _ofs.i8  = rpn_offset;
      _ofs.f32 = slew_rise;
      _ofs.f32 = slew_fall;
      _ofs.f32 = curve;  // v2+

      return true;
   }

   // <load.png>
   public virtual loadState(Stream _ifs, boolean _bRestoreInstanceIDs) : boolean {

      boolean r = Mod::loadState(_ifs, _bRestoreInstanceIDs);

      if(r)
      {
         // Read version
         short ver = _ifs.u16;

         if(ver >= 1)
         {
            rpn_offset = _ifs.u8;
            slew_rise  = _ifs.f32;
            slew_fall  = _ifs.f32;

            if(ver >= 2)
               curve = _ifs.f32;  // v2+

            r = true;
         }
         else
         {
            Global.Error("ModRPN2Audio::loadState: invalid ver="+ver);
            r = false;
         }
      }

      return r;
   }

   // <replay.png>
   public virtual process(local int _numFrames,
                          local int _fltDev, local int _fltCh,
                          local int _forceCh, local int _globalCh,
                          local boolean _bPlaying
                          ) {
      local FloatArray inL <= input_bufs.get(0);
      local FloatArray inR <= input_bufs.get(1);
      local FloatArray outL <= output_bufs.get(0);
      local FloatArray outR <= output_bufs.get(1);

      if(replay.b_have_events)
      {
         local MIDIPipeFrame frame <= replay.midi_input_frame;
         local float t = frame.getFilteredRPN(_fltDev, _fltCh, 1 + rpn_offset);
         if(t >= 0.0f)
         {
            dest_val = t - 8192.0f;
            if(dest_val < 0.0f)
               dest_val /= 8192.0f;
            else
               dest_val /= 8191.0f;
         }
      }

      if(_bPlaying)
      {
         mtx_param.lock();

         local float slewRise = 1.0f - slew_rise;
         slewRise *= slewRise * slewRise;

         local float slewFall = 1.0f - slew_fall;
         slewFall *= slewFall * slewFall;

         local float lastOut = last_out;
         local int frameIdx = 0;

         local float fCurve = curve;

         loop(_numFrames)
         {
            if(dest_val >= lastOut)
               lastOut += (dest_val - lastOut) * slewRise;
            else
               lastOut += (dest_val - lastOut) * slewFall;

            outL[frameIdx] = mathLogLinExpf(lastOut, fCurve);
            outR[frameIdx] = inR[frameIdx];
            frameIdx++;
         }

         last_out = lastOut;

         mtx_param.unlock();
      }
   }

}
