// ----
// ---- file   : Sample.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2018-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi/audio sequencer.
// ----
// ---- created: 22Dec2018
// ---- changed: 23Dec2018, 27Dec2018, 28Dec2018, 29Dec2018, 31Dec2018, 02Jan2019, 03Jan2019
// ----          04Jan2019, 05Jan2019, 06Jan2019, 07Jan2019, 08Jan2019, 09Jan2019, 10Jan2019
// ----          23Feb2019, 30Mar2019, 31Mar2019, 23Apr2019, 09May2019, 11May2019, 12May2019
// ----          13May2019, 15May2019, 17May2019, 18Jun2019, 13Jul2019, 21Jul2019, 24Jul2019
// ----          15Feb2020, 16Feb2020, 17Feb2020, 18Feb2020, 19Feb2020, 20Feb2020, 21Feb2020
// ----          22Feb2020, 23Feb2020, 24Feb2020, 25Feb2020, 26Feb2020, 27Feb2020, 28Feb2020
// ----          17May2020, 19May2020, 20May2020, 21May2020, 22May2020, 23May2020, 24May2020
// ----          28May2020, 31May2020, 01Jun2020, 04Jun2020, 05Jun2020, 06Jun2020, 08Jun2020
// ----          10Jun2020, 18Aug2020, 19Aug2020, 21Aug2020, 23Aug2020, 24Aug2020, 28Aug2020
// ----          29Aug2020, 06Sep2020, 12Sep2020, 13Sep2020, 23Sep2020, 06Oct2020, 12Oct2020
// ----          13Oct2020, 29Nov2020, 31Jan2021, 11Apr2021, 15Apr2021, 18Apr2021, 26Apr2021
// ----          30Apr2021, 26Jun2021, 17Jul2021, 21Jul2021, 27Jul2021, 30Jul2021, 31Jul2021
// ----          10Aug2021, 23Aug2021, 30Aug2021, 05Sep2021, 04Oct2021, 05Oct2021, 12Oct2021
// ----          20Oct2021, 28Oct2021, 11Dec2021, 12Dec2021, 18Jan2022, 05Feb2022, 11Feb2022
// ----          13Feb2022, 08Jul2022, 17Jul2022, 10Aug2022, 26Sep2022, 23Nov2022, 24Nov2022
// ----          10Dec2022, 20Dec2022, 21Dec2022, 22Dec2022, 23Dec2022, 27Dec2022, 28Dec2022
// ----          31Dec2022, 06Feb2023, 19Feb2023, 20Feb2023, 09Mar2023, 10Mar2023, 24Mar2023
// ----          10Apr2023, 11Apr2023, 12Apr2023, 13Apr2023, 22Apr2023, 23Apr2023, 04May2023
// ----          09May2023, 17May2023, 08Jul2023, 11Aug2023, 14Aug2023, 16Aug2023, 18Aug2023
// ----          20Aug2023, 03Sep2023, 08Sep2023, 16Sep2023, 19Sep2023, 21Sep2023, 22Sep2023
// ----          17Nov2023, 18Nov2023, 21Dec2023, 23Dec2023, 06Jan2024, 08Jan2024, 10Jan2024
// ----          12Jan2024, 13Jan2024, 16Jan2024, 17Jan2024, 18Jan2024, 19Jan2024, 13Apr2024
// ----          26Apr2024, 02Aug2024, 03Aug2024, 04Aug2024, 05Aug2024, 15Aug2024, 13Sep2024
// ----          14Sep2024, 20Sep2024, 26Sep2024, 28Sep2024, 29Sep2024, 01Oct2024, 02Oct2024
// ----          03Oct2024, 13Oct2024, 12Nov2024, 21Dec2024, 26Dec2024, 29Dec2024, 31Dec2024
// ----          03Jan2025, 04Jan2025, 12Jan2025, 15Jan2025, 03Apr2025, 05Apr2025, 06May2025
// ----          20May2025, 28May2025, 05Jun2025, 12Jun2025, 13Jun2025, 14Jun2025
// ----
// ----
// ----

module MSample;

use namespace ui;
use namespace st2;


// <class.png>
class Sample {

   define int NUM_NAMESPACES = 64;

   define float BASE_FREQ_MIDDLE_C = 261.63/*C-5*/;  // middle-c  (c-4 when starting with oct-1)
   define int KEY_MIDDLE_C = (5 * 12);

   define float MAX_NOTE_FREQ = 4186.0/*G-A*/;

   // must be aligned with tksampler.cpp:TKSAMPLER_MAX_TUNING_TABLES
   define int MAX_TUNING_TABLES = 16;

   define int MAX_UNIQUE_ID = 16383;  // 14 bit

   String      unique_name;         // (unique) name. used as WAV basename when writing to $(PROJECT)/samples/ folder
   String      description;         // arbitrary string (e.g. controller modulation notes)
   StringArray tags;                // arbitrary keyword strings (for filtering / finding patches in the patch browser)
   String      suggested_pathname;  // relative dirname within STConfig.sample_rootpath, e.g. "/bsp/eurorack"
   int         namespace_idx;       // 0..Sample.NUM_NAMESPACES-1
   boolean     b_persistent;        // 1=always treat sample as referenced (=> never auto-remove)

   // true if sample was autoloaded while loading track patch or sample pad kit from file
   //  (and will be auto-unloaded when ModSample instance is deleted)
   //  (note) flag resets to false when sample is edited or saved to project directory
   boolean b_autoload;

   boolean b_preview;  // true=is (temporary) preview sample

   byte prg_id;  // for MIDI program changes, -1=unassigned, 0..127 otherwise
   int  unique_id;  // -1=unassigned, 0..MAX_UNIQUE_ID otherwise (never changes after allocation)

   define int TYPE_SINGLE                 =  0;  // chromatic; play entire sample
   define int TYPE_LAYERED                =  1;  // play all zones simultaneously (unless delayed) (v5+)
   define int TYPE_WAVESEQ                =  2;  // layered + set zone delay to zone idx (v5+)
   define int TYPE_SLICE_MOD_EVEN         =  3;  // chromatic; slice select via modwheel (create mod ranges, 0..127
   define int TYPE_SLICE_MOD_ABS          =  4;  // chromatic; slice select via modwheel (create mod ranges, 0..#slices)
   define int TYPE_SLICE_MOD_XFADE        =  5;  // chromatic; slice select via modwheel (create mod ranges, 0..#slices)
   define int TYPE_SLICE_VEL_EVEN         =  6;  // chromatic; slice select via velocity (create vel ranges)
   define int TYPE_SLICE_VEL_ABS          =  7;  // chromatic; slice select via velocity (create vel ranges)
   define int TYPE_SLICE_ALT              =  8;  // chromatic: random slice selection
   define int TYPE_MULTISAMPLE_C          =  9;  // one sample per octave
   define int TYPE_MULTISAMPLE_C_FS       = 10;  // two samples per octave
   define int TYPE_MULTISAMPLE_C_G        = 11;  // two samples per octave
   define int TYPE_MULTISAMPLE_C_E_GS     = 12;  // three samples per octave
   define int TYPE_MULTISAMPLE_C_DS_FS_A  = 13;  // four samples per octave
   define int TYPE_DRUM_MAP               = 14;  // fixed pitch, one zone per key (c3..)
   define int TYPE_DRUM_MAP_WHITE         = 15;  // fixed pitch, one zone per key (c3..) (white keys only)
   define int TYPE_DRUM_MAP_ALT3          = 16;  // three hits form one alt group (c3..)
   define int TYPE_DRUM_MAP_ALT3_WHITE    = 17;  // three hits form one alt group (c3..) (white keys only)
   define int TYPE_DRUM_MAP_MOD3          = 18;  // three hits per key, selectable by modwheel (v13+)
   define int TYPE_DRUM_MAP_MOD3_WHITE    = 19;  // three hits per key, selectable by modwheel (white keys only) (v13+)
   define int TYPE_DRUM_MAP_MOD4          = 20;  // four hits per key, selectable by modwheel (v13+)
   define int TYPE_DRUM_MAP_MOD4_WHITE    = 21;  // four hits per key, selectable by modwheel (white keys only) (v13+)
   define int TYPE_GRID                   = 22;  // split evenly into 'n' zones (c3..)  [moved from 18 to 22 on 08Jul2023/v13]
   define int TYPE_GRID_WHITE             = 23;  // split evenly into 'n' zones (c3..) (white keys only)
   define int TYPE_TUNED_MULTISAMPLE      = 24;  // generate key ranges from current tuning
   int sample_type;
   int grid_size;  // for TYPE_GRID*

   static StringArray type_names = [
      "Single",
      "Layered",
      "Wave Sequence",
      "Slice (Mod Even)",
      "Slice (Mod Abs)",
      "Slice (Mod XFade)",
      "Slice (Vel Even)",
      "Slice (Vel Abs)",
      "Slice (Alt)",
      "Multisample C",
      "Multisample C F#",
      "Multisample C G",
      "Multisample C E G#",
      "Multisample C D# F# A",
      "Drum Map",
      "Drum Map (white keys)",
      "Drum Map Alt3",
      "Drum Map Alt3 (white keys)",
      "Drum Map Mod3",
      "Drum Map Mod3 (white keys)",
      "Drum Map Mod4",
      "Drum Map Mod4 (white keys)",
      "Grid",
      "Grid (white keys)",
      "Tuned Multisample"
                                    ];

   static IntArray white_key_adv_tbl = [
      2,2,1,2,2,2,1
                                    ];

   byte  transpose_oct;    // -4..4
   byte  transpose_semi;   // -12..12
   float transpose_cents;  // -100..100

   float pitchbend_up;  // pitchbend range
   float pitchbend_down;

   // (note) volume, pan, and randomization settings are stored in sample_bank

   define int MODSRC_CC_NONE          = 0;
   define int MODSRC_CC_MODWHEEL      = 1;
   define int MODSRC_CC_BREATH        = 2;
   define int MODSRC_CC_FOOT          = 3;
   define int MODSRC_CC_EXPR          = 4;
   define int MODSRC_CC_BRIGHTNESS    = 5;
   define int MODSRC_CHPRESSURE       = 6;
   define int MODSRC_POLYPRESSURE     = 7;
   define int MODSRC_POLYPRESSURE_MAX = 8;
   byte mod_src;
   boolean b_mod_src_noteon;  // true=only evaluate mod src during note-on

   boolean b_sustain;  // hint for ModSample: 1=handle/queue sustained notes. 0=leave it to zone mod matrix

   static StringArray modsrc_names = [
      "-",
      "MW",
      "BC",
      "FC",
      "Ex",
      "74",
      "CP",
      "PP",
      "PX"
                                      ];

   static StringArray modsrc_names_long = [
      "-",
      "CC#001: Mod Wheel",
      "CC#002: Breath Control",
      "CC#004: Foot Control",
      "CC#011: Expression",
      "CC#074: Brightness (MPE)",
      "Channel Pressure (aftertouch)",
      "Poly Pressure (aftertouch)",
      "Poly Pressure (clip to max)"
                                      ];

   // see StSample.h / STSAMPLE_FLT_TYPE_xxx
   static StringArray flt_type_names = [
      "-",
      "LP",
      "LP2",
      "HP",
      "HP2",
      "BP",
      "BP2",
      "BR",
      "BR2",
      "PEQ",
      "PEQ2",
      "LSH",
      "LSH2",
      "HSH",
      "HSH2",
      "LP+HP",
      "LP+BP",
      "LP+BR",
      "HP+LP",
      "HP+BP",
      "HP+BR",
      "BP+LP",
      "BP+HP",
      "BP+BR",
      "BR+LP",
      "BR+HP",
      "BR+BP"
                                        ];

   boolean b_project_waveform_modified;  // 1=modified since last project save
   boolean b_user_waveform_modified;     // 1=modified since last user sample save
   Time last_modification_time;

   StWaveform waveform;        // sampleData FloatArray is always valid (but may be empty)
   boolean    b_procedural;    // 1=procedural waveform (Cycle SampleSynth), save waveform size only, recalc waveform on load
   boolean    b_audio_clip;    // 1=timeline clip
   float      audio_clip_bpm;  // bpm when audio clip was created (meta info, e.g. for timestretching)

   int        src_track_idx;   // for procedural samples (capture track output). -1=off
   MIDIPipeFrame *[] proc_seq_frames;

   StSampleBank sample_bank;  // stores StSample instances ("zones")

   int solo_zone_idx;  // -1=no solo

   FloatArray *partial_magnitudes; // 256 floats per wavetable entry, up to 256 waves (=>256*256*4 = 256kbytes)
   FloatArray *partial_speeds;     // ^^ pre-sorted by wave magnitudes (loudest first)
   FloatArray *partial_phases;     // ^^ pre-sorted by wave magnitudes (loudest first)  (normalized angles 0..1)
   int num_partial_waves;  // 1..256  (note) currently locked to 256
   int partial_window_bits;
   boolean b_partial_cos_win;  // 0=tri window, 1=cos window
   boolean b_partial_true_freq;
   float   partial_speed_exp;
   float   partial_bin_exp;
   float   partial_mag_exp;
   float   partial_mag_bin_exp;

   static StringArray mm_env_stageop_names = [
      "*",
      "A",
      "+"
                                              ];

   static StringArray mm_env_stageop_names_long = [
      "*: Multiplicative",
      "A: Absolute",
      "+: Additive"
                                              ];

   static StringArray mm_op_names = [
      "A",  //  0
      "+",  //  1
      "*",  //  2
      "R",  //  3
      "I",  //  4
      "S",  //  5
      "T",  //  6
      "C",  //  7
      "X",  //  8
      "%",  //  9
      "t",  // 10
      "n",  // 11
      "s"   // 12
                                     ];

   static StringArray mm_op_names_long = [
      "A: Auto (destination dependent)",
      "+: Add",
      "*: Multiply",
      "R: Replace",
      "I: Replace once during init",
      "S: Blend destination with source according to amount",
      "T: Blend destination with amount according to source",
      "C: Compare to destination + copy. Store result*amount in CC.",
      "X: Compare and detect zero crossing + copy. Store result*amount in CC.",
      "%: Modulo source*amount by destination",
      "t: Triangle/PingPong modulo source*amount by destination (for dest > 0.0)",
      "n: Triangle/PingPong modulo source*amount by destination with no repeat (for dest >= 2.0)",
      "s: Stepped modulation (destination=num steps)",
                                     ];

   static StringArray mm_src_names = [
      "-",                     //   0
      "Const +1",              //   1
      "Const -1",              //   2
      "Const  0",              //   3
      "Const  4",              //   4
      "Const 16",              //   5
      "Const 100",             //   6
      "Const 127",             //   7
      "Const 255",             //   8
      "Rand 1 (+-)",           //   9
      "Rand 1 (+)",            //  10
      "Rand 2 (+-)",           //  11
      "Rand 2 (+)",            //  12
      "Rand 3 (+-)",           //  13
      "Rand 3 (+)",            //  14
      "Rand 4 (+-)",           //  15
      "Rand 4 (+)",            //  16
      "Keyboard (+-)",         //  17
      "Keyboard (+)",          //  18
      "Keyboard (-)",          //  19
      "Keyboard (abs)",        //  20
      "Voice Nr",              //  21
      "Voice Nr Even",         //  22
      "Voice Nr Odd",          //  23
      "Voice Nr EvenOdd",      //  24
      "Voice Nr OddEven",      //  25
      "Active Notes",          //  26
      "Active Note Even",      //  27
      "Active Note Odd",       //  28
      "Active Note EvOdd",     //  29
      "Active Note OddEv",     //  30
      "Layer Nr",              //  31
      "Layer Nr Even",         //  32
      "Layer Nr Odd",          //  33
      "Layer Nr EvenOdd",      //  34
      "Layer Nr OddEven",      //  35
      "Velocity",              //  36
      "Velocity (>95)",        //  37
      "Velocity Exp 2",        //  38
      "Velocity Exp 3",        //  39
      "Velocity Smoothstep",   //  40
      "Velocity Inv",          //  41  // added in MM state ver 27
      "Velocity Bip",          //  42  // added in MM state ver 27
      "Release Vel",           //  43
      "Release Vel (>95)",     //  44
      "Gate",                  //  45  // added in MM state ver 32
      "Trig Pulse",            //  46  // added in MM state ver 32
      "Release",               //  47
      "Release Pulse",         //  48
      "Sustain Pedal",         //  49  // added in MM state ver 39
      "Soft Pedal",            //  50  // added in MM state ver 39
      "Pitchbend (+-)",        //  51
      "Pitchbend (+-) @On",    //  52
      "Pitchbend (+)",         //  53
      "Pitchbend (+) @On",     //  54
      "Pitchbend (-)",         //  55
      "Pitchbend (-) @On",     //  56
      "Pressure",              //  57
      "Pressure @On",          //  58
      "Pressure (>95)",        //  59
      "Pressure (>95) @On",    //  60
      "Pressure Max",          //  61
      "CC#01 Mod",             //  62
      "CC#01 Mod @On",         //  63
      "CC#01 Mod Inv",         //  64  // added in MM state ver 28
      "CC#01 Mod Inv @On",     //  65  // added in MM state ver 28
      "CC#01 Mod Bip",         //  66  // added in MM state ver 28
      "CC#01 Mod Bip @On",     //  67  // added in MM state ver 28
      "CC#02 Breath",          //  68
      "CC#02 Breath @On",      //  69
      "CC#02 Breath Inv",      //  70  // added in MM state ver 29
      "CC#02 Breath Inv @On",  //  71  // added in MM state ver 29
      "CC#02 Breath Bip",      //  72  // added in MM state ver 29
      "CC#02 Breath Bip @On",  //  73  // added in MM state ver 29
      "CC#04 Foot",            //  74
      "CC#04 Foot @On",        //  75
      "CC#04 Foot Inv",        //  76  // added in MM state ver 30
      "CC#04 Foot Inv @On",    //  77  // added in MM state ver 30
      "CC#04 Foot Bip",        //  78  // added in MM state ver 30
      "CC#04 Foot Bip @On",    //  79  // added in MM state ver 30
      "CC#07 Volume",          //  80
      "CC#07 Volume @On",      //  81
      "CC#08 Balance",         //  82
      "CC#08 Balance @On",     //  83
      "CC#10 Pan",             //  84
      "CC#10 Pan @On",         //  85
      "CC#11 Expr",            //  86
      "CC#11 Expr @On",        //  87
      "CC#11 Expr Inv",        //  88  // added in MM state ver 31
      "CC#11 Expr Inv @On",    //  89  // added in MM state ver 31
      "CC#11 Expr Bip",        //  90  // added in MM state ver 31
      "CC#11 Expr Bip @On",    //  91  // added in MM state ver 31
      "CC#16 Gen. 1",          //  92
      "CC#16 Gen. 1 @On",      //  93
      "CC#17 Gen. 2",          //  94
      "CC#17 Gen. 2 @On",      //  95
      "CC#18 Gen. 3",          //  96
      "CC#18 Gen. 3 @On",      //  97
      "CC#19 Gen. 4",          //  98
      "CC#19 Gen. 4 @On",      //  99
      "CC#74 Bright",          // 100
      "CC#74 Bright @On",      // 101
      "CC#80 Gen. 5",          // 102
      "CC#80 Gen. 5 @On",      // 103
      "CC#81 Gen. 6",          // 104
      "CC#81 Gen. 6 @On",      // 105
      "CC#82 Gen. 7",          // 106
      "CC#82 Gen. 7 @On",      // 107
      "CC#83 Gen. 8",          // 108
      "CC#83 Gen. 8 @On",      // 109
      "LFO Freq",              // 110  // (note) was 90 instead of 88 in v24 (bug)
      "LFO Vol",               // 111
      "LFO Pan",               // 112
      "LFO Aux",               // 113
      "Env Freq",              // 114
      "Env Vol",               // 115
      "Env Pan",               // 116
      "Env Aux",               // 117
      "ModSeq 1",              // 118
      "ModSeq 2",              // 119
      "ModSeq 3",              // 120
      "ModSeq 4",              // 121
      "ModSeq 1 by VoiceKey",  // 122
      "ModSeq 2 by VoiceKey",  // 123
      "ModSeq 3 by VoiceKey",  // 124
      "ModSeq 4 by VoiceKey",  // 125
      "ModSeq 4 Step 1",       // 126  v36+
      "ModSeq 4 Step 2",       // 127  ..
      "ModSeq 4 Step 3",       // 128  ..
      "ModSeq 4 Step 4",       // 129  ..
      "ModSeq 4 Step 5",       // 130  ..
      "ModSeq 4 Step 6",       // 131  ..
      "ModSeq 4 Step 7",       // 132  ..
      "ModSeq 4 Step 8",       // 133  ..
      "ModSeq 4 Step 9",       // 134  ..
      "ModSeq 4 Step 10",      // 135  ..
      "ModSeq 4 Step 11",      // 136  ..
      "ModSeq 4 Step 12",      // 137  ..
      "ModSeq 4 Step 13",      // 138  ..
      "ModSeq 4 Step 14",      // 139  ..
      "ModSeq 4 Step 15",      // 140  ..
      "ModSeq 4 Step 16",      // 141  ..
      "Register 1",            // 142
      "Register 2",            // 143
      "Register 3",            // 144
      "Register 4",            // 145
      "CC",                    // 146
      "Voice Cal 1",           // 147
      "Voice Cal 1 R",         // 148
      "Voice Cal 2",           // 149
      "Voice Cal 2 R",         // 150
      "Voice Cal 3",           // 151
      "Voice Cal 3 R",         // 152
      "Voice Cal 4",           // 153
      "Voice Cal 4 R",         // 154
      "Voice Cal 5",           // 155
      "Voice Cal 5 R",         // 156
      "Voice Cal 6",           // 157
      "Voice Cal 6 R",         // 158
      "Play Pos Zone 1",       // 159
      "Play Pos Zone 2",       // 160
      "Play Pos Zone 3",       // 161
      "Play Pos Zone 4",       // 162
      "Glide Time",            // 163
      "Glide Time Inv",        // 164
      "Glide Time Tri",        // 165
      "Glide Time Tri Inv",    // 166
      "Voice Bus 1",           // 167
      "Voice Bus 1 Abs",       // 168
      "Voice Bus 2",           // 169
      "Voice Bus 2 Abs",       // 170
      "Voice Bus 3",           // 171
      "Voice Bus 3 Abs",       // 172
      "Voice Bus 4",           // 173
      "Voice Bus 4 Abs",       // 174
      "Voice Bus 5",           // 175
      "Voice Bus 5 Abs",       // 176
      "Voice Bus 6",           // 177
      "Voice Bus 6 Abs",       // 178
      "Voice Bus 7",           // 179
      "Voice Bus 7 Abs",       // 180
      "Voice Bus 8",           // 181
      "Voice Bus 8 Abs",       // 182
                                      ];

   static StringArray mm_dst_names = [
      "-",                        //  0
      "Freq",                     //  1 (-1..1 => -48.0..+48.0)
      "Freq (Oct)",               //  2 (-1..1 => -12..12)
      "Freq (Fifth)",             //  3 (-1..1 => -5..5)
      "Freq (Fourth)",            //  4 (-1..1 => -4..4)
      "Freq (Semi)",              //  5 (-1..1 => -12..12)
      "Freq (Fine)",              //  6
      "Freq (Beat)",              //  7
      "Tuning Table Abs",         //  8  v35+  (0..1) => 0=no change, 1/16..16/16 => table 1..16
      "Tuning Table Rel",         //  9  v35+  (0..f => table 1..f+1)
      "Note 2",                   // 10  v37+  (0..1 => 0..127.0)
      "Freq 2",                   // 11  v37+  (-f..f) (_not_ scaled)
      "Volume",                   // 12
      "Pan",                      // 13
      "Filter CutOff",            // 14
      "Filter Pan",               // 15
      "Filter Offset",            // 16
      "Filter Res",               // 17
      "Sample Offset",            // 18
      "Sample Shift",             // 19
      "Sample Shift EOL",         // 20
      "Loop Restart",             // 21  v7+
      "Cycle Len",                // 22
      "Cycle Len EOL",            // 23  v26+
      "Cycle Len Smp Off",        // 24
      "2D Wavetable X Abs",       // 25  v21+
      "2D Wavetable X Rel",       // 26  v21+
      "2D Wavetable Y Abs",       // 27  v21+
      "2D Wavetable Y Rel",       // 28  v21+
      "Loop Repeats Scale",       // 29  v15+
      "Jump To Loop Rel",         // 30
      "Jump To Loop Abs*127",     // 31  v6+
      "Jump To Loop Abs",         // 32  v34+ (re-added unscaled version)
      "Freq LFO Spd /*8",         // 33
      "Freq LFO Spd *",           // 34
      "Freq LFO Lvl",             // 35
      "Freq LFO Freq Amt",        // 36  v4+
      "Vol LFO Spd /*8",          // 37
      "Vol LFO Spd *",            // 38
      "Vol LFO Lvl",              // 39
      "Vol LFO Vol Amt",          // 40  v4+
      "Pan LFO Spd /*8",          // 41
      "Pan LFO Spd *",            // 42
      "Pan LFO Lvl",              // 43
      "Pan LFO Pan Amt",          // 44  v4+
      "Aux LFO Spd /*8",          // 45
      "Aux LFO Spd *",            // 46
      "Aux LFO Lvl",              // 47
      "Aux LFO Flt Amt",          // 48  v4+
      "Freq Env Spd /*8",         // 49
      "Freq Env Spd *",           // 50
      "Freq Env Lvl",             // 51
      "Freq Env Int",             // 52
      "Freq Env Atk Spd /*8",     // 53
      "Freq Env Atk Spd *",       // 54
      "Freq Env Sus Spd /*8",     // 55
      "Freq Env Sus Spd *",       // 56
      "Freq Env Rls Spd /*8",     // 57
      "Freq Env Rls Spd *",       // 58
      "Vol Env Spd /*8",          // 59
      "Vol Env Spd *",            // 60
      "Vol Env Lvl",              // 61
      "Vol Env Int",              // 62
      "Vol Env Atk Spd /*8",      // 63
      "Vol Env Atk Spd *",        // 64
      "Vol Env Sus Spd /*8",      // 65
      "Vol Env Sus Spd *",        // 66
      "Vol Env Rls Spd /*8",      // 67
      "Vol Env Rls Spd *",        // 68
      "Pan Env Spd /*8",          // 69
      "Pan Env Spd *",            // 70
      "Pan Env Lvl",              // 71
      "Pan Env Int",              // 72
      "Pan Env Atk Spd /*8",      // 73
      "Pan Env Atk Spd *",        // 74
      "Pan Env Sus Spd /*8",      // 75
      "Pan Env Sus Spd *",        // 76
      "Pan Env Rls Spd /*8",      // 77
      "Pan Env Rls Spd *",        // 78
      "Aux Env Spd /*8",          // 79
      "Aux Env Spd *",            // 80
      "Aux Env Lvl",              // 81
      "Aux Env Int",              // 82
      "Aux Env Atk Spd /*8",      // 83
      "Aux Env Atk Spd *",        // 84
      "Aux Env Sus Spd /*8",      // 85
      "Aux Env Sus Spd *",        // 86
      "Aux Env Rls Spd /*8",      // 87
      "Aux Env Rls Spd *",        // 88
      "Mod 1 Amount",             // 89
      "Mod 2 Amount",             // 90
      "Mod 3 Amount",             // 91
      "Mod 4 Amount",             // 92
      "Mod 5 Amount",             // 93
      "Mod 6 Amount",             // 94
      "Mod 7 Amount",             // 95
      "Mod 8 Amount",             // 96
      "Mod 9 Amount",             // 97
      "Mod 10 Amount",            // 98
      "Mod 11 Amount",            // 99
      "Mod 12 Amount",            // 100
      "Mod 13 Amount",            // 101
      "Mod 14 Amount",            // 102
      "Mod 15 Amount",            // 103
      "Mod 16 Amount",            // 104
      "Glide Speed",              // 105
      "Timestretch",              // 106
      "Timestretch Bend",         // 107
      "ModSeq 1 Patch",           // 108
      "ModSeq 1 Speed /*8",       // 109
      "ModSeq 1 Speed *",         // 110
      "ModSeq 1 Level",           // 111
      "ModSeq 1 Len",             // 112
      "ModSeq 1 Advance",         // 113
      "ModSeq 1 Step",            // 114
      "ModSeq 2 Patch",           // 115
      "ModSeq 2 Speed /*8",       // 116
      "ModSeq 2 Speed *",         // 117
      "ModSeq 2 Level",           // 118
      "ModSeq 2 Len",             // 119
      "ModSeq 2 Advance",         // 120
      "ModSeq 2 Step",            // 121
      "ModSeq 3 Patch",           // 122
      "ModSeq 3 Speed /*8",       // 123
      "ModSeq 3 Speed *",         // 124
      "ModSeq 3 Level",           // 125
      "ModSeq 3 Len",             // 126
      "ModSeq 3 Advance",         // 127
      "ModSeq 3 Step",            // 128
      "ModSeq 4 Patch",           // 129
      "ModSeq 4 Speed /*8",       // 130
      "ModSeq 4 Speed *",         // 131
      "ModSeq 4 Level",           // 132
      "ModSeq 4 Len",             // 133
      "ModSeq 4 Advance",         // 134
      "ModSeq 4 Step",            // 135
      "Retrig Freq Env",          // 136
      "Retrig Vol Env",           // 137
      "Retrig Pan Env",           // 138
      "Retrig Aux Env",           // 139
      "Retrig Freq LFO",          // 140
      "Retrig Vol LFO",           // 141
      "Retrig Pan LFO",           // 142
      "Retrig Aux LFO",           // 143
      "Retrig ModSeq 1",          // 144
      "Retrig ModSeq 2",          // 145
      "Retrig ModSeq 3",          // 146
      "Retrig ModSeq 4",          // 147
      "Init Register 1",          // 148
      "Init Register 2",          // 149
      "Init Register 3",          // 150
      "Init Register 4",          // 151
      "Register 1",               // 152
      "Register 2",               // 153
      "Register 3",               // 154
      "Register 4",               // 155
      "LiveRec Start",            // 156
      "LiveRec Continue",         // 157
      "LiveRec Stop",             // 158
      "Plugin 1 Mod 1",           // 159 (updated dynamically)
      "Plugin 1 Mod 2",           // 160 (updated dynamically)
      "Plugin 1 Mod 3",           // 161 (updated dynamically)
      "Plugin 1 Mod 4",           // 162 (updated dynamically)
      "Plugin 1 Mod 5",           // 163 (updated dynamically)
      "Plugin 1 Mod 6",           // 164 (updated dynamically)
      "Plugin 1 Mod 7",           // 165 (updated dynamically)
      "Plugin 1 Mod 8",           // 166 (updated dynamically)
      "Plugin 2 Mod 1",           // 167 (updated dynamically)
      "Plugin 2 Mod 2",           // 168 (updated dynamically)
      "Plugin 2 Mod 3",           // 169 (updated dynamically)
      "Plugin 2 Mod 4",           // 170 (updated dynamically)
      "Plugin 2 Mod 5",           // 171 (updated dynamically)
      "Plugin 2 Mod 6",           // 172 (updated dynamically)
      "Plugin 2 Mod 7",           // 173 (updated dynamically)
      "Plugin 2 Mod 8",           // 174 (updated dynamically)
      "Plugin 3 Mod 1",           // 175 (updated dynamically)
      "Plugin 3 Mod 2",           // 176 (updated dynamically)
      "Plugin 3 Mod 3",           // 177 (updated dynamically)
      "Plugin 3 Mod 4",           // 178 (updated dynamically)
      "Plugin 3 Mod 5",           // 179 (updated dynamically)
      "Plugin 3 Mod 6",           // 180 (updated dynamically)
      "Plugin 3 Mod 7",           // 181 (updated dynamically)
      "Plugin 3 Mod 8",           // 182 (updated dynamically)
      "Plugin 4 Mod 1",           // 183 (updated dynamically)
      "Plugin 4 Mod 2",           // 184 (updated dynamically)
      "Plugin 4 Mod 3",           // 185 (updated dynamically)
      "Plugin 4 Mod 4",           // 186 (updated dynamically)
      "Plugin 4 Mod 5",           // 187 (updated dynamically)
      "Plugin 4 Mod 6",           // 188 (updated dynamically)
      "Plugin 4 Mod 7",           // 189 (updated dynamically)
      "Plugin 4 Mod 8",           // 190 (updated dynamically)
      "Plugin 1 Level",           // 191
      "Plugin 2 Level",           // 192
      "Plugin 3 Level",           // 193
      "Plugin 4 Level",           // 194
      "Sync Speed",               // 195
      "Sync Slew",                // 196
      "Sample Rate Reduct.",      // 197
      "Bit Reduction",            // 198
      "Addtve Wt Config",         // 199
      "Addtve Wt St. Spread",     // 200
      "Addtve Wt Partials",       // 201
      "Matrix Variation",         // 202
                                      ];

   static StringArray timestretch_interpol_names_short = [
      "None",       //   0
      "Lin",        //   1
      "Smooths",    //   2
      "Clp25",      //   3
      "Clp50",      //   4
      "Clp75",      //   5
      "ClpMod",     //   6
      "ClpVel",     //   7
      "Off25",      //   8
      "Off50",      //   9
      "Off75",      //  10
      "OffMod",     //  11
      "OffVel",     //  12
      "Ph25W00",    //  13
      "Ph25W25",    //  14
      "Ph25W50",    //  15
      "Ph25W75",    //  16
      "Ph50W00",    //  17
      "Ph50W25",    //  18
      "Ph50W50",    //  19
      "Ph50W75",    //  20
      "Ph75W00",    //  21
      "Ph75W25",    //  22
      "Ph75W50",    //  23
      "Ph75W75",    //  24
      "PMW00",      //  25
      "PMW25",      //  26
      "PMW50",      //  27
      "PMW75",      //  28
      "PMVel",      //  29
      "PVW00",      //  30
      "PVW25",      //  31
      "PVW50",      //  32
      "PVW75",      //  33
      "PVMod",      //  34
      "Order2",     //  35
      "Order3",     //  36
      "Order4",     //  37
      "Order5",     //  38
      "Order6",     //  39
      "Order7"      //  40
                                                   ];

   static StringArray timestretch_interpol_names_long= [
      "None",          //   0
      "Linear",        //   1
      "Smoothstep",    //   2
      "Clip25",        //   3
      "Clip50",        //   4
      "Clip75",        //   5
      "ClipMod",       //   6
      "ClipVel",       //   7
      "Off25",         //   8
      "Off50",         //   9
      "Off75",         //  10
      "OffMod",        //  11
      "OffVel",        //  12
      "Phase25W00",    //  13
      "Phase25W25",    //  14
      "Phase25W50",    //  15
      "Phase25W75",    //  16
      "Phase50W00",    //  17
      "Phase50W25",    //  18
      "Phase50W50",    //  19
      "Phase50W75",    //  20
      "Phase75W00",    //  21
      "Phase75W25",    //  22
      "Phase75W50",    //  23
      "Phase75W75",    //  24
      "PhaseModW00",   //  25
      "PhaseModW25",   //  26
      "PhaseModW50",   //  27
      "PhaseModW75",   //  28
      "PhaseModVel",   //  29
      "PhaseVelW00",   //  30
      "PhaseVelW25",   //  31
      "PhaseVelW50",   //  32
      "PhaseVelW75",   //  33
      "PhaseVelMod",   //  34
      "Order2",        //  35
      "Order3",        //  36
      "Order4",        //  37
      "Order5",        //  38
      "Order6",        //  39
      "Order7"         //  40
                                                   ];

   static StringArray timestretch_grain_window_names = [
      "None",
      "Sine",
      "Triangle"
                                                        ];

   static PointerArray plugin_alg_names = [
      // 0
      ["1*2*3*4",    //  0: def
       "f*1*2*3*4",  //  1: outer 1.1 pre
       "f*1*2*3*4",  //  2: outer 1.2 pre
       "f*1*2*3*4",  //  3: outer 1.3 pre
       "f*1*2*3*4",  //  4: outer 1.4 pre
       "f*1*2*3*4",  //  5: outer 2.1 pre
       "f*1*2*3*4",  //  6: outer 2.2 pre
       "f*1*2*3*4",  //  7: outer 2.3 pre
       "f*1*2*3*4",  //  8: outer 2.4 pre
       "1*2*3*4*f",  //  9: outer 1.1 post
       "1*2*3*4*f",  // 10: outer 1.2 post
       "1*2*3*4*f",  // 11: outer 1.3 post
       "1*2*3*4*f",  // 12: outer 1.4 post
       "1*2*3*4*f",  // 13: outer 2.1 post
       "1*2*3*4*f",  // 14: outer 2.2 post
       "1*2*3*4*f",  // 15: outer 2.3 post
       "1*2*3*4*f",  // 16: outer 2.4 post
       ],

      // 1
      ["1+2+3+4",      //  0: def
       "f*(1+2+3+4)",  //  1: outer 1.1 pre
       "f*(1+2+3+4)",  //  2: outer 1.2 pre
       "f*(1+2+3+4)",  //  3: outer 1.3 pre
       "f*(1+2+3+4)",  //  4: outer 1.4 pre
       "f*(1+2+3+4)",  //  5: outer 2.1 pre
       "f*(1+2+3+4)",  //  6: outer 2.2 pre
       "f*(1+2+3+4)",  //  7: outer 2.3 pre
       "f*(1+2+3+4)",  //  8: outer 2.4 pre
       "(1+2+3+4)*f",  //  9: outer 1.1 post
       "(1+2+3+4)*f",  // 10: outer 1.2 post
       "(1+2+3+4)*f",  // 11: outer 1.3 post
       "(1+2+3+4)*f",  // 12: outer 1.4 post
       "(1+2+3+4)*f",  // 13: outer 2.1 post
       "(1+2+3+4)*f",  // 14: outer 2.2 post
       "(1+2+3+4)*f",  // 15: outer 2.3 post
       "(1+2+3+4)*f",  // 16: outer 2.4 post
       ],

      // 2
      ["1+(2+3+4)",       //  0: def
       "f*(1+(2+3+4))",   //  1: outer 1.1 pre
       "1+f*(2+3+4)",     //  2: outer 1.2 pre
       "1+f*(2+3+4)",     //  3: outer 1.3 pre
       "1+f*(2+3+4)",     //  4: outer 1.4 pre
       "f*(1+(2+3+4))",   //  5: outer 2.1 pre
       "f*(1+(2+3+4))",   //  6: outer 2.2 pre
       "f*(1+(2+3+4))",   //  7: outer 2.3 pre
       "f*(1+(2+3+4))",   //  8: outer 2.4 pre
       "(1+(2+3+4))*f",   //  9: outer 1.1 post
       "1+((2+3+4)*f)",   // 10: outer 1.2 post
       "1+((2+3+4)*f)",   // 11: outer 1.3 post
       "1+((2+3+4)*f)",   // 12: outer 1.4 post
       "(1+((2+3+4))*f",  // 13: outer 2.1 post
       "(1+((2+3+4))*f",  // 14: outer 2.2 post
       "(1+((2+3+4))*f",  // 15: outer 2.3 post
       "(1+((2+3+4))*f",  // 16: outer 2.4 post
       ],

      // 3
      ["(1+2+3)+4",      //  0: def
       "(f*(1+2+3))+4",  //  1: outer 1.1 pre
       "(f*(1+2+3))+4",  //  2: outer 1.2 pre
       "(f*(1+2+3))+4",  //  3: outer 1.3 pre
       "(f*(1+2+3))+4",  //  4: outer 1.4 pre
       "f*((1+2+3)+4)",  //  5: outer 2.1 pre
       "f*((1+2+3)+4)",  //  6: outer 2.2 pre
       "f*((1+2+3)+4)",  //  7: outer 2.3 pre
       "f*((1+2+3)+4)",  //  8: outer 2.4 pre
       "((1+2+3)*f)+4",  //  9: outer 1.1 post
       "((1+2+3)*f)+4",  // 10: outer 1.2 post
       "((1+2+3)*f)+4",  // 11: outer 1.3 post
       "((1+2+3)+4)*f",  // 12: outer 1.4 post
       "((1+2+3)+4)*f",  // 13: outer 2.1 post
       "((1+2+3)+4)*f",  // 14: outer 2.2 post
       "((1+2+3)+4)*f",  // 15: outer 2.3 post
       "((1+2+3)+4)*f",  // 16: outer 2.4 post
       ],

      // 4
      ["1+2+(3+4)",      //  0: def
       "f*(1+2+(3+4))",  //  1: outer 1.1 pre
       "f*(1+2+(3+4))",  //  2: outer 1.2 pre
       "1+2+f*(3+4)",    //  3: outer 1.3 pre
       "1+2+f*(3+4)",    //  4: outer 1.4 pre
       "f*(1+2+(3+4))",  //  5: outer 2.1 pre
       "f*(1+2+(3+4))",  //  6: outer 2.2 pre
       "f*(1+2+(3+4))",  //  7: outer 2.3 pre
       "f*(1+2+(3+4))",  //  8: outer 2.4 pre
       "(1+2+(3+4))*f",  //  9: outer 1.1 post
       "(1+2+(3+4))*f",  // 10: outer 1.2 post
       "1+2+(3+4)*f",    // 11: outer 1.3 post
       "1+2+(3+4)*f",    // 12: outer 1.4 post
       "(1+2+(3+4))*f",  // 13: outer 2.1 post
       "(1+2+(3+4))*f",  // 14: outer 2.2 post
       "(1+2+(3+4))*f",  // 15: outer 2.3 post
       "(1+2+(3+4))*f",  // 16: outer 2.4 post
       ],

      // 5
      ["1+(2+3)+4",      //  0: def
       "f*(1+(2+3)+4)",  //  1: outer 1.1 pre
       "1+f*(2+3)+4",    //  2: outer 1.2 pre
       "1+f*(2+3)+4",    //  3: outer 1.3 pre
       "f*(1+(2+3)+4)",  //  4: outer 1.4 pre
       "f*(1+(2+3)+4)",  //  5: outer 2.1 pre
       "f*(1+(2+3)+4)",  //  6: outer 2.2 pre
       "f*(1+(2+3)+4)",  //  7: outer 2.3 pre
       "f*(1+(2+3)+4)",  //  8: outer 2.4 pre
       "(1+(2+3)+4)*f",  //  9: outer 1.1 post
       "1+(2+3)*f+4",    // 10: outer 1.2 post
       "1+(2+3)*f+4",    // 11: outer 1.3 post
       "(1+(2+3)+4)*f",  // 12: outer 1.4 post
       "(1+(2+3)+4)*f",  // 13: outer 2.1 post
       "(1+(2+3)+4)*f",  // 14: outer 2.2 post
       "(1+(2+3)+4)*f",  // 15: outer 2.3 post
       "(1+(2+3)+4)*f",  // 16: outer 2.4 post
       ],

      // 6
      ["(1+2)+3+4",      //  0: def
       "f*(1+2)+3+4",    //  1: outer 1.1 pre
       "f*(1+2)+3+4",    //  2: outer 1.2 pre
       "f*((1+2)+3+4)",  //  3: outer 1.3 pre
       "f*((1+2)+3+4)",  //  4: outer 1.4 pre
       "f*((1+2)+3+4)",  //  5: outer 2.1 pre
       "f*((1+2)+3+4)",  //  6: outer 2.2 pre
       "f*((1+2)+3+4)",  //  7: outer 2.3 pre
       "f*((1+2)+3+4)",  //  8: outer 2.4 pre
       "(1+2)*f+3+4",    //  9: outer 1.1 post
       "(1+2)*f+3+4",    // 10: outer 1.2 post
       "((1+2)+3+4)*f",  // 11: outer 1.3 post
       "((1+2)+3+4)*f",  // 12: outer 1.4 post
       "((1+2)+3+4)*f",  // 13: outer 2.1 post
       "((1+2)+3+4)*f",  // 14: outer 2.2 post
       "((1+2)+3+4)*f",  // 15: outer 2.3 post
       "((1+2)+3+4)*f",  // 16: outer 2.4 post
       ],


      // 7
      ["(1+2)+(3+4)",      //  0: def
       "f*(1+2)+(3+4)",    //  1: outer 1.1 pre
       "f*(1+2)+(3+4)",    //  2: outer 1.2 pre
       "(1+2)+f*(3+4)",    //  3: outer 1.3 pre
       "(1+2)+f*(3+4)",    //  4: outer 1.4 pre
       "f*((1+2)+(3+4))",  //  5: outer 2.1 pre
       "f*((1+2)+(3+4))",  //  6: outer 2.2 pre
       "f*((1+2)+(3+4))",  //  7: outer 2.3 pre
       "f*(((1+2)+(3+4))", //  8: outer 2.4 pre
       "(1+2)*f+(3+4)",    //  9: outer 1.1 post
       "(1+2)*f+(3+4)",    // 10: outer 1.2 post
       "(1+2)+(3+4)*f",    // 11: outer 1.3 post
       "(1+2)+(3+4)*f",    // 12: outer 1.4 post
       "((1+2)+(3+4))*f",  // 13: outer 2.1 post
       "((1+2)+(3+4))*f",  // 14: outer 2.2 post
       "((1+2)+(3+4))*f",  // 15: outer 2.3 post
       "((1+2)+(3+4))*f",  // 16: outer 2.4 post
       ],


      // 8
      ["1*(2+3+4)",      //  0: def
       "f*(1*(2+3+4))",  //  1: outer 1.1 pre
       "1*f*(2+3+4)",    //  2: outer 1.2 pre
       "1*f*(2+3+4)",    //  3: outer 1.3 pre
       "1*f*(2+3+4)",    //  4: outer 1.4 pre
       "f*(1*(2+3+4))",  //  5: outer 2.1 pre
       "f*(1*(2+3+4))",  //  6: outer 2.2 pre
       "f*(1*(2+3+4))",  //  7: outer 2.3 pre
       "f*(1*(2+3+4))",  //  8: outer 2.4 pre
       "(1*(2+3+4))*f",  //  9: outer 1.1 post
       "1*(2+3+4)*f",    // 10: outer 1.2 post
       "1*(2+3+4)*f",    // 11: outer 1.3 post
       "1*(2+3+4)*f",    // 12: outer 1.4 post
       "(1*(2+3+4))*f",  // 13: outer 2.1 post
       "(1*(2+3+4))*f",  // 14: outer 2.2 post
       "(1*(2+3+4))*f",  // 15: outer 2.3 post
       "(1*(2+3+4))*f",  // 16: outer 2.4 post
       ],


      // 9
      ["1*(2+3)*4",      //  0: def
       "f*(1*(2+3)*4)",  //  1: outer 1.1 pre
       "1*f*(2+3)*4",    //  2: outer 1.2 pre
       "1*f*(2+3)*4",    //  3: outer 1.3 pre
       "f*(1*(2+3)*4)",  //  4: outer 1.4 pre
       "f*(1*(2+3)*4)",  //  5: outer 2.1 pre
       "f*(1*(2+3)*4)",  //  6: outer 2.2 pre
       "f*(1*(2+3)*4)",  //  7: outer 2.3 pre
       "f*(1*(2+3)*4)",  //  8: outer 2.4 pre
       "(1*(2+3)*4)*f",  //  9: outer 1.1 post
       "1*(2+3)*f*4",    // 10: outer 1.2 post
       "1*(2+3)*f*4",    // 11: outer 1.3 post
       "(1*(2+3)*4)*f",  // 12: outer 1.4 post
       "(1*(2+3)*4)*f",  // 13: outer 2.1 post
       "(1*(2+3)*4)*f",  // 14: outer 2.2 post
       "(1*(2+3)*4)*f",  // 15: outer 2.3 post
       "(1*(2+3)*4)*f",  // 16: outer 2.4 post
       ],


      // 10
      ["(1+2+3)*4",      //  0: def
       "f*(1+2+3)*4",    //  1: outer 1.1 pre
       "f*(1+2+3)*4",    //  2: outer 1.2 pre
       "f*(1+2+3)*4",    //  3: outer 1.3 pre
       "f*((1+2+3)*4)",  //  4: outer 1.4 pre
       "f*((1+2+3)*4)",  //  5: outer 2.1 pre
       "f*((1+2+3)*4)",  //  6: outer 2.2 pre
       "f*((1+2+3)*4)",  //  7: outer 2.3 pre
       "f*((1+2+3)*4)",  //  8: outer 2.4 pre
       "(1+2+3)*f*4",    //  9: outer 1.1 post
       "(1+2+3)*f*4",    // 10: outer 1.2 post
       "(1+2+3)*f*4",    // 11: outer 1.3 post
       "((1+2+3)*4)*f",  // 12: outer 1.4 post
       "((1+2+3)*4)*f",  // 13: outer 2.1 post
       "((1+2+3)*4)*f",  // 14: outer 2.2 post
       "((1+2+3)*4)*f",  // 15: outer 2.3 post
       "((1+2+3)*4)*f",  // 16: outer 2.4 post
       ],


      // 11
      ["(1+2)*3*4",      //  0: def
       "f*(1+2)*3*4",    //  1: outer 1.1 pre
       "f*(1+2)*3*4",    //  2: outer 1.2 pre
       "f*((1+2)*3*4)",  //  3: outer 1.3 pre
       "f*((1+2)*3*4)",  //  4: outer 1.4 pre
       "f*((1+2)*3*4)",  //  5: outer 2.1 pre
       "f*((1+2)*3*4)",  //  6: outer 2.2 pre
       "f*((1+2)*3*4)",  //  7: outer 2.3 pre
       "f*((1+2)*3*4)",  //  8: outer 2.4 pre
       "(1+2)*f*3*4",    //  9: outer 1.1 post
       "(1+2)*f*3*4",    // 10: outer 1.2 post
       "((1+2)*3*4)*f",  // 11: outer 1.3 post
       "((1+2)*3*4)*f",  // 12: outer 1.4 post
       "((1+2)*3*4)*f",  // 13: outer 2.1 post
       "((1+2)*3*4)*f",  // 14: outer 2.2 post
       "((1+2)*3*4)*f",  // 15: outer 2.3 post
       "((1+2)*3*4)*f",  // 16: outer 2.4 post
       ],


      // 12
      ["1+(2*3*4)",      //  0: def
       "f*(1+(2*3*4))",  //  1: outer 1.1 pre
       "1+f*(2*3*4)",    //  2: outer 1.2 pre
       "1+f*(2*3*4)",    //  3: outer 1.3 pre
       "1+f*(2*3*4)",    //  4: outer 1.4 pre
       "f*(1+(2*3*4))",  //  5: outer 2.1 pre
       "f*(1+(2*3*4))",  //  6: outer 2.2 pre
       "f*(1+(2*3*4))",  //  7: outer 2.3 pre
       "f*(1+(2*3*4))",  //  8: outer 2.4 pre
       "(1+(2*3*4))*f",  //  9: outer 1.1 post
       "1+(2*3*4)*f",    // 10: outer 1.2 post
       "1+(2*3*4)*f",    // 11: outer 1.3 post
       "1+(2*3*4)*f",    // 12: outer 1.4 post
       "(1+(2*3*4))*f",  // 13: outer 2.1 post
       "(1+(2*3*4))*f",  // 14: outer 2.2 post
       "(1+(2*3*4))*f",  // 15: outer 2.3 post
       "(1+(2*3*4))*f",  // 16: outer 2.4 post
       ],


      // 13
      ["(1+2)*(3+4)",      //  0: def
       "f*(1+2)*(3+4)",    //  1: outer 1.1 pre
       "f*(1+2)*(3+4)",    //  2: outer 1.2 pre
       "(1+2)*f*(3+4)",    //  3: outer 1.3 pre
       "(1+2)*f*(3+4)",    //  4: outer 1.4 pre
       "f*((1+2)*(3+4))",  //  5: outer 2.1 pre
       "f*((1+2)*(3+4))",  //  6: outer 2.2 pre
       "f*((1+2)*(3+4))",  //  7: outer 2.3 pre
       "f*((1+2)*(3+4))",  //  8: outer 2.4 pre
       "(1+2)*f*(3+4)",    //  9: outer 1.1 post
       "(1+2)*f*(3+4)",    // 10: outer 1.2 post
       "(1+2)*(3+4)*f",    // 11: outer 1.3 post
       "(1+2)*(3+4)*f",    // 12: outer 1.4 post
       "((1+2)*(3+4))*f",  // 13: outer 2.1 post
       "((1+2)*(3+4))*f",  // 14: outer 2.2 post
       "((1+2)*(3+4))*f",  // 15: outer 2.3 post
       "((1+2)*(3+4))*f",  // 16: outer 2.4 post
       ],


      // 14
      ["(1*2)+(3*4)",      //  0: def
       "f*(1*2)+(3*4)",    //  1: outer 1.1 pre
       "f*(1*2)+(3*4)",    //  2: outer 1.2 pre
       "(1*2)+f*(3*4)",    //  3: outer 1.3 pre
       "(1*2)+f*(3*4)",    //  4: outer 1.4 pre
       "f*((1*2)+(3*4))",  //  5: outer 2.1 pre
       "f*((1*2)+(3*4))",  //  6: outer 2.2 pre
       "f*((1*2)+(3*4))",  //  7: outer 2.3 pre
       "f*((1*2)+(3*4))",  //  8: outer 2.4 pre
       "(1*2)*f+(3*4)",    //  9: outer 1.1 post
       "(1*2)*f+(3*4)",    // 10: outer 1.2 post
       "(1*2)+(3*4)*f",    // 11: outer 1.3 post
       "(1*2)+(3*4)*f",    // 12: outer 1.4 post
       "((1*2)+(3*4))*f",  // 13: outer 2.1 post
       "((1*2)+(3*4))*f",  // 14: outer 2.2 post
       "((1*2)+(3*4))*f",  // 15: outer 2.3 post
       "((1*2)+(3*4))*f",  // 16: outer 2.4 post
       ],


      // 15
      ["1+2+(3*4)",        //  0: def
       "f*(1+2+(3*4))",    //  1: outer 1.1 pre
       "f*(1+2+(3*4))",    //  2: outer 1.2 pre
       "1+2+f*(3*4)",      //  3: outer 1.3 pre
       "1+2+f*(3*4)",      //  4: outer 1.4 pre
       "f*(1+2+(3*4))",    //  5: outer 2.1 pre
       "f*(1+2+(3*4))",    //  6: outer 2.2 pre
       "f*(1+2+(3*4))",    //  7: outer 2.3 pre
       "f*(1+2+(3*4))",    //  8: outer 2.4 pre
       "(1+2+(3*4))*f",    //  9: outer 1.1 post
       "(1+2+(3*4))*f",    // 10: outer 1.2 post
       "1+2+(3*4)*f",      // 11: outer 1.3 post
       "1+2+(3*4)*f",      // 12: outer 1.4 post
       "(1+2+(3*4))*f",    // 13: outer 2.1 post
       "(1+2+(3*4))*f",    // 14: outer 2.2 post
       "(1+2+(3*4))*f",    // 15: outer 2.3 post
       "(1+2+(3*4))*f",    // 16: outer 2.4 post
       ],


      // 16
      ["1+(2*3)+4",        //  0: def
       "f*(1+(2*3)+4)",    //  1: outer 1.1 pre
       "1+f*(2*3)+4",      //  2: outer 1.2 pre
       "1+f*(2*3)+4",      //  3: outer 1.3 pre
       "f*(1+(2*3)+4)",    //  4: outer 1.4 pre
       "f*(1+(2*3)+4)",    //  5: outer 2.1 pre
       "f*(1+(2*3)+4)",    //  6: outer 2.2 pre
       "f*(1+(2*3)+4)",    //  7: outer 2.3 pre
       "f*(1+(2*3)+4)",    //  8: outer 2.4 pre
       "(1+(2*3)+4)*f",    //  9: outer 1.1 post
       "1+(2*3)*f+4",      // 10: outer 1.2 post
       "1+(2*3)*f+4",      // 11: outer 1.3 post
       "(1+(2*3)+4)*f",    // 12: outer 1.4 post
       "(1+(2*3)+4)*f",    // 13: outer 2.1 post
       "(1+(2*3)+4)*f",    // 14: outer 2.2 post
       "(1+(2*3)+4)*f",    // 15: outer 2.3 post
       "(1+(2*3)+4)*f",    // 16: outer 2.4 post
       ],


      // 17
      ["(1*2)+3+4",        //  0: def
       "f*(1*2)+3+4",      //  1: outer 1.1 pre
       "f*(1*2)+3+4",      //  2: outer 1.2 pre
       "f*((1*2)+3+4)",    //  3: outer 1.3 pre
       "f*((1*2)+3+4)",    //  4: outer 1.4 pre
       "f*((1*2)+3+4)",    //  5: outer 2.1 pre
       "f*((1*2)+3+4)",    //  6: outer 2.2 pre
       "f*((1*2)+3+4)",    //  7: outer 2.3 pre
       "f*((1*2)+3+4)",    //  8: outer 2.4 pre
       "(1*2)*f+3+4",      //  9: outer 1.1 post
       "(1*2)*f+3+4",      // 10: outer 1.2 post
       "((1*2)+3+4)*f",    // 11: outer 1.3 post
       "((1*2)+3+4)*f",    // 12: outer 1.4 post
       "((1*2)+3+4)*f",    // 13: outer 2.1 post
       "((1*2)+3+4)*f",    // 14: outer 2.2 post
       "((1*2)+3+4)*f",    // 15: outer 2.3 post
       "((1*2)+3+4)*f",    // 16: outer 2.4 post
       ],


      // 18
      ["(1*(2+3))+4",      //  0: def
       "f*(1*(2+3))+4",    //  1: outer 1.1 pre
       "(1*f*(2+3))+4",    //  2: outer 1.2 pre
       "(1*f*(2+3))+4",    //  3: outer 1.3 pre
       "f*((1*(2+3))+4)",  //  4: outer 1.4 pre
       "f*((1*(2+3))+4)",  //  5: outer 2.1 pre
       "f*(1*(2+3))+4",    //  6: outer 2.2 pre
       "f*(1*(2+3))+4",    //  7: outer 2.3 pre
       "f*((1*(2+3))+4)",  //  8: outer 2.4 pre
       "(1*(2+3))*f+4",    //  9: outer 1.1 post
       "(1*(2+3)*f)+4",    // 10: outer 1.2 post
       "(1*(2+3)*f)+4",    // 11: outer 1.3 post
       "((1*(2+3))+4)*f",  // 12: outer 1.4 post
       "((1*(2+3))+4)*f",  // 13: outer 2.1 post
       "(1*(2+3))*f+4",    // 14: outer 2.2 post
       "(1*(2+3))*f+4",    // 15: outer 2.3 post
       "((1*(2+3))+4)*f",  // 16: outer 2.4 post
       ],


      // 19
      ["((1*2)+3)*4",      //  0: def
       "(f*(1*2)+3)*4",    //  1: outer 1.1 pre
       "(f*(1*2)+3)*4",    //  2: outer 1.2 pre
       "f*((1*2)+3)*4",    //  3: outer 1.3 pre
       "f*(((1*2)+3)*4)",  //  4: outer 1.4 pre
       "f*((1*2)+3)*4",    //  5: outer 2.1 pre
       "f*((1*2)+3)*4",    //  6: outer 2.2 pre
       "f*(((1*2)+3)*4)"   //  7: outer 2.3 pre
       "f*(((1*2)+3)*4)",  //  8: outer 2.4 pre
       "((1*2)*f+3)*4",    //  9: outer 1.1 post
       "((1*2)*f+3)*4",    // 10: outer 1.2 post
       "((1*2)+3)*f*4",    // 11: outer 1.3 post
       "(((1*2)+3)*4)*f",  // 12: outer 1.4 post
       "((1*2)+3)*f*4",    // 13: outer 2.1 post
       "((1*2)+3)*f*4",    // 14: outer 2.2 post
       "(((1*2)+3)*4)*f",  // 15: outer 2.3 post
       "(((1*2)+3)*4)*f",  // 16: outer 2.4 post
       ],

      // 20
      ["(1+(2*3))*4",      //  0: def
       "f*(1+(2*3))*4",    //  1: outer 1.1 pre
       "(1+f*(2*3))*4",    //  2: outer 1.2 pre
       "(1+f*(2*3))*4",    //  3: outer 1.3 pre
       "(1+(2*3))*4*f",    //  4: outer 1.4 pre
       "f*(1+(2*3))*4",    //  5: outer 2.1 pre
       "f*(1+(2*3))*4",    //  6: outer 2.2 pre
       "f*(1+(2*3))*4"     //  7: outer 2.3 pre
       "f*(1+(2*3))*4",    //  8: outer 2.4 pre
       "(1+(2*3))*f*4",    //  9: outer 1.1 post
       "(1+(2*3)*f)*4",    // 10: outer 1.2 post
       "(1+(2*3)*f)*4",    // 11: outer 1.3 post
       "(1+(2*3))*4*f",    // 12: outer 1.4 post
       "(1+(2*3))*4*f",    // 13: outer 2.1 post
       "(1+(2*3))*4*f",    // 14: outer 2.2 post
       "(1+(2*3))*4*f",    // 15: outer 2.3 post
       "(1+(2*3))*4*f",    // 16: outer 2.4 post
       ],


      // 21
      ["1+((2+3)*4)",      //  0: def
       "f*(1+((2+3)*4))",  //  1: outer 1.1 pre
       "1+(f*(2+3)*4)",    //  2: outer 1.2 pre
       "1+(f*(2+3)*4)",    //  3: outer 1.3 pre
       "1+f*((2+3)*4)",    //  4: outer 1.4 pre
       "f*(1+((2+3)*4))",  //  5: outer 2.1 pre
       "1+f*((2+3)*4)",    //  6: outer 2.2 pre
       "1+f*((2+3)*4)",    //  7: outer 2.3 pre
       "f*(1+((2+3)*4))",  //  8: outer 2.4 pre
       "(1+((2+3)*4))*f",  //  9: outer 1.1 post
       "1+((2+3)*f*4)",    // 10: outer 1.2 post
       "1+((2+3)*f*4)",    // 11: outer 1.3 post
       "1+((2+3)*4)*f",    // 12: outer 1.4 post
       "(1+((2+3)*4))*f",  // 13: outer 2.1 post
       "1+((2+3)*4)*f",    // 14: outer 2.2 post
       "1+((2+3)*4)*f",    // 15: outer 2.3 post
       "(1+((2+3)*4))*f",  // 16: outer 2.4 post
       ],


      // 22
      ["1+(2*(3+4))",      //  0: def
       "f*(1+(2*(3+4)))",  //  1: outer 1.1 pre
       "1+f*(2*(3+4))",    //  2: outer 1.2 pre
       "1+(2*f*(3+4))",    //  3: outer 1.3 pre
       "1+(2*f*(3+4))",    //  4: outer 1.4 pre
       "f*(1+(2*(3+4)))",  //  5: outer 2.1 pre
       "f*(1+(2*(3+4)))",  //  6: outer 2.2 pre
       "1+f*(2*(3+4))",    //  7: outer 2.3 pre
       "1+f*(2*(3+4))",    //  8: outer 2.4 pre
       "(1+(2*(3+4)))*f",  //  9: outer 1.1 post
       "1+(2*(3+4))*f",    // 10: outer 1.2 post
       "1+(2*(3+4)*f)",    // 11: outer 1.3 post
       "1+(2*(3+4)*f)",    // 12: outer 1.4 post
       "(1+(2*(3+4)))*f",  // 13: outer 2.1 post
       "(1+(2*(3+4)))*f",  // 14: outer 2.2 post
       "1+(2*(3+4))*f",    // 15: outer 2.3 post
       "1+(2*(3+4))*f",    // 16: outer 2.4 post
       ],


      // 23
      ["1*(2+(3*4))",      //  0: def
       "f*(1*(2+(3*4)))",  //  1: outer 1.1 pre
       "1*f*(2+(3*4))",    //  2: outer 1.2 pre
       "1*(2+f*(3*4))",    //  3: outer 1.3 pre
       "1*(2+f*(3*4))",    //  4: outer 1.4 pre
       "f*(1*(2+(3*4)))",  //  5: outer 2.1 pre
       "f*(1*(2+(3*4)))",  //  6: outer 2.2 pre
       "1*f*(2+(3*4))",    //  7: outer 2.3 pre
       "1*f*(2+(3*4))",    //  8: outer 2.4 pre
       "(1*(2+(3*4)))*f",  //  9: outer 1.1 post
       "1*(2+(3*4))*f",    // 10: outer 1.2 post
       "1*(2+(3*4)*f)",    // 11: outer 1.3 post
       "1*(2+(3*4)*f)",    // 12: outer 1.4 post
       "(1*(2+(3*4)))*f",  // 13: outer 2.1 post
       "(1*(2+(3*4)))*f",  // 14: outer 2.2 post
       "1*(2+(3*4))*f",    // 15: outer 2.3 post
       "1*(2+(3*4))*f",    // 16: outer 2.4 post
       ],

      // 24
      ["1+(2+(3+4))",      //  0: def
       "f*(1+(2+(3+4)))",  //  1: outer 1.1 pre
       "1+f*(2+(3+4))",    //  2: outer 1.2 pre
       "1+(2+f*(3+4))",    //  3: outer 1.3 pre
       "1+(2+f*(3+4))",    //  4: outer 1.4 pre
       "f*(1+(2+(3+4)))",  //  5: outer 2.1 pre
       "f*(1+(2+(3+4)))",  //  6: outer 2.2 pre
       "1+f*(2+(3+4))",    //  7: outer 2.3 pre
       "1+f*(2+(3+4))",    //  8: outer 2.4 pre
       "(1+(2+(3+4)))*f",  //  9: outer 1.1 post
       "1+(2+(3+4))*f",    // 10: outer 1.2 post
       "1+(2+(3+4)*f)",    // 11: outer 1.3 post
       "1+(2+(3+4)*f)",    // 12: outer 1.4 post
       "(1+(2+(3+4)))*f",  // 13: outer 2.1 post
       "(1+(2+(3+4)))*f",  // 14: outer 2.2 post
       "1+(2+(3+4))*f",    // 15: outer 2.3 post
       "1+(2+(3+4))*f",    // 16: outer 2.4 post
       ],


      // -
      // x 1+((2*3)+4)
      // x 1*((2+3)+4)
      // -
      // -
      // -


                                           ];

   CycleState *cycle_state;  // see CycleSynthDialog and CycleState.tks

   // temporary during Project::exportCycleSampleSource():
   int export_all_c_wf_off;

   FloatArray initial_perf_ctl;   // sz=STSAMPLEPLAYER_NUM_PERFCTL. -1=skip. 0..127 / 0..16383(PB)

   int last_edited_vcal_lane_idx;  // see SampleVCalForm

   // invalidated in markWaveformAsModified(). Used by Timeline. 1ms intervals.
   FloatArray cached_sample_peaks;
   float cached_sample_peaks_denorm_factor;  // multiply by this factor to get back non-normalized peaks


   // <method_init.png>
   public method init() {
      sample_bank.maxVoices = 32;
      sample_bank.enableUniqueNotes = false;
      StSampleMutexGroup *mgrp;

      mgrp <= new StSampleMutexGroup;
      mgrp.name = "A";
      sample_bank.addMutexGroup(#(deref mgrp));

      mgrp <= new StSampleMutexGroup;
      mgrp.name = "B";
      sample_bank.addMutexGroup(#(deref mgrp));

      mgrp <= new StSampleMutexGroup;
      mgrp.name = "C";
      sample_bank.addMutexGroup(#(deref mgrp));

      mgrp <= new StSampleMutexGroup;
      mgrp.name = "D";
      sample_bank.addMutexGroup(#(deref mgrp));

      waveform.alloc(1/*ch*/, 1/*frames*/);  // create sampleData FloatArray
      waveform.sampleRate = STConfig.audio_mixrate;
      waveform.baseFrequency = BASE_FREQ_MIDDLE_C;

      prg_id = -1;
      unique_id = -1;
      b_autoload = false;

      b_procedural = false;
      src_track_idx = -1;

      sample_bank.volume = 1;
      sample_bank.pan = 0;

      sample_type = TYPE_SLICE_MOD_EVEN;
      grid_size = 16;

      pitchbend_up = 12;
      pitchbend_down = 12;

      mod_src = MODSRC_CC_MODWHEEL;
      b_mod_src_noteon = false;

      markWaveformAsModified();

      cycle_state <= new CycleState;
      cycle_state.init();

      initial_perf_ctl.allocAndFill(STSAMPLEPLAYER_NUM_PERFCTL, -1);

      partial_window_bits = 13;  // => 8192 frames (e.g. "wt additive organ 1" sounds bad with just 1024 frames)
      b_partial_true_freq = false;
      b_partial_cos_win   = false;
      partial_speed_exp   = 1.0;
      partial_bin_exp     = 0.0;
      partial_mag_exp     = 1.0;
      partial_mag_bin_exp = 0.0;

      b_sustain = true;
   }

   // <method_exit.png>
   public method exit() {

      cycle_state.exit();  // free Cycle voice plugins

      exitSampleZones();
   }

   // <method_exit.png>
   public method exitSampleZones() {
      StSample s <= sample_bank.firstSample;
      int zoneIdx = 0;
      while(null != s)
      {
         // Global.Debug2("Sample::exitSampleZones: exit sample zone["+zoneIdx+"]="+#(s));
         s.freePlugins();

         s <= s.next;
         zoneIdx++;
      }
   }

   // <method.png>
   public method markWaveformAsModified() {
      b_project_waveform_modified = true;
      b_user_waveform_modified = true;
      last_modification_time.now();
      cached_sample_peaks.empty();
   }

   // <method.png>
   public method markParamsAsModified() {
      current_project.markAsModified();
      b_autoload = false;  // prevent auto-unload
   }

   // <method.png>
   public method invalidateNonPersistentInitialPerfCtl() {
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_PITCHBEND]       = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_PRESSURE]        = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC7_VOLUME]      = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC8_BALANCE]     = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC10_PAN]        = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC74_BRIGHTNESS] = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC80_GENERAL_5]  = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC81_GENERAL_6]  = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC82_GENERAL_7]  = -1;
      initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC83_GENERAL_8]  = -1;
   }

   protected method copySampleBankTuningTablesFrom(StSampleBank s) {
      int tuneTblIdx = 0;
      StSampleBank d <= sample_bank;
      loop(STSAMPLE_MAX_TUNING_TABLES)
      {
         // Copy frequency table
         d.setTuningTable(tuneTblIdx, s.getTuningTable(tuneTblIdx));

         // Copy editor meta data
         SampleTuningTable tuneTblSrc <= s.getTuningTableMetaData(tuneTblIdx);
         if(null != tuneTblSrc)
         {
            SampleTuningTable tuneTblDst <= d.getTuningTableMetaData(tuneTblIdx);
            if(null == tuneTblDst)
            {
               tuneTblDst <= new SampleTuningTable;
               tuneTblDst.init();
               d.setTuningTableMetaData(tuneTblIdx, #(deref tuneTblDst));
            }
            tuneTblDst.copyFrom(tuneTblSrc);
         }
         else
         {
            d.setTuningTableMetaData(tuneTblIdx, null);
         }

         tuneTblIdx++;
      }

      d.defaultTuningTableIdx = s.defaultTuningTableIdx;
   }

   // <method.png>
   public =replay= method copyFrom(Sample _o) {
      prg_id = _o.prg_id;
      b_autoload = false;

      // (note) don't copy unique_name
      b_persistent  = _o.b_persistent;
      description   = _o.description;
      // (note) don't copy suggested_pathname
      namespace_idx = _o.namespace_idx;

      initial_perf_ctl = _o.initial_perf_ctl;

      Samples.CopyWaveform(waveform, _o.waveform);
      b_procedural = _o.b_procedural;
      if(!b_procedural)
         markWaveformAsModified();

      src_track_idx = _o.src_track_idx;
      PointerArray oSeqFrames <= _o.proc_seq_frames;
      proc_seq_frames.alloc(oSeqFrames.numElements);
      MIDIPipeFrame *oFrame;
      foreach oFrame in oSeqFrames
      {
         MIDIPipeFrame fr <= new MIDIPipeFrame;
         fr = oFrame;
         proc_seq_frames.add(#(deref fr));
      }

      b_audio_clip   = _o.b_audio_clip;
      audio_clip_bpm = _o.audio_clip_bpm;

      sample_type = _o.sample_type;
      grid_size = _o.grid_size;

      StSampleBank osb <= _o.sample_bank;

      sample_bank.maxVoices = osb.maxVoices;
      sample_bank.enableRealloc = osb.enableRealloc;
      sample_bank.enableUniqueNotes = osb.enableUniqueNotes;
      sample_bank.enablePerfCtlFreezeNoteOff = osb.enablePerfCtlFreezeNoteOff;

      setTransposeOct  (_o.transpose_oct);
      setTransposeSemi (_o.transpose_semi);
      setTransposeCents(_o.transpose_cents);

      pitchbend_up = _o.pitchbend_up;
      pitchbend_down = _o.pitchbend_down;

      sample_bank.volume = osb.volume;
      sample_bank.pan = osb.pan;

      sample_bank.sampleOffsetRandAmount = osb.sampleOffsetRandAmount;
      sample_bank.freqRandAmount         = osb.freqRandAmount;
      sample_bank.volumeRandAmount       = osb.volumeRandAmount;
      sample_bank.panRandAmount          = osb.panRandAmount;

      partial_window_bits = _o.partial_window_bits;
      b_partial_cos_win   = _o.b_partial_cos_win;
      b_partial_true_freq = _o.b_partial_true_freq;
      partial_speed_exp   = _o.partial_speed_exp;
      partial_bin_exp     = _o.partial_bin_exp;
      partial_mag_exp     = _o.partial_mag_exp;
      partial_mag_bin_exp = _o.partial_mag_bin_exp;

      b_sustain = _o.b_sustain;

      // Copy samples
      sample_bank.freeSamples();
      StSample *os;
      StSample *s;
      os <= _o.getZoneByIdx(0);
      while(null != os)
      {
         s <= new StSample;
         s.waveform = waveform;
         Samples.CopySample(s, os, -1/*appendixNr*/, true/*bCopyName*/, false/*bCopyWaveform*/);

         if(null != os.mutexGroup)
         {
            int mgrpIdx = _o.sample_bank.getMutexGroupIndexByObject(os.mutexGroup);
            StSampleMutexGroup mgrp <= sample_bank.getMutexGroupByIdx(mgrpIdx);
            s.mutexGroup = mgrp;
         }

         sample_bank.addSample(#(deref s));

         os <= os.next;
      }

      solo_zone_idx = _o.solo_zone_idx;

      mod_src          = _o.mod_src;
      b_mod_src_noteon = _o.b_mod_src_noteon;

      cycle_state.copyFrom(_o.cycle_state);

      // Tuning tables
      copySampleBankTuningTablesFrom(osb);

      tags = _o.tags;

      // (todo) move analyzeAndUpdatePartials() call here ?!
   }

   // <method.png>
   public method copyFromForUndo(Sample _o) {
      copyFrom(_o);
      unique_id          = _o.unique_id;
      unique_name        = _o.unique_name;
      suggested_pathname = _o.suggested_pathname;
      b_autoload         = _o.b_autoload;
   }

   // <method.png>
   public method assignDefaultName() {
      assignUniqueName(Utils.GetCurrentDateTimeStringNumeric());
   }

   // <method.png>
   public method assignUniqueName(String _name) {
      String newName = Utils.ConvertToFileName(_name);

      int idxNameNr = 0;
      int idxSpc = newName.lastIndexOf(" ");
      int idxUsc = newName.lastIndexOf("_");
      int idxCom = newName.lastIndexOf(",");
      int idxDsh = newName.lastIndexOf("-");
      idxNameNr = mathMaxi(idxSpc, idxUsc);
      idxNameNr = mathMaxi(idxNameNr, idxCom);
      idxNameNr = mathMaxi(idxNameNr, idxDsh);
      int curNameNr = -1;
      if(-1 != idxNameNr)
      {
         idxNameNr++;
         local String sNameNr <= newName.substring(idxNameNr, 9999);
         if!(sNameNr <= "0")
         {
            if(sNameNr.checkFloatConversion())  // (todo) checkIntConversion()
            {
               curNameNr = sNameNr;

               if(curNameNr > 9)
               {
                  // don't enum "SD 808" to "SD 809" if "SD 807" does not exist :-)
                  String tmpName = newName.substring(0, idxNameNr) + String(curNameNr - 1);
                  if(null == current_project.findSampleByUniqueName(tmpName))
                     curNameNr = -1;
               }
            }
         }
      }

      // trace "xxx assignUniqueName: curNameNr="+curNameNr;

      Sample *otherSmp;
      otherSmp <= current_project.findSampleByUniqueName(newName);
      int lastSeenNameNr = curNameNr;
      if((null != otherSmp) && (@(otherSmp) != @(this)))
      {
         int iter = 2;
         for(;;)
         {
            if(-1 != curNameNr)
            {
               // Enum style, e.g. "my_clip_1"=>"my_clip_2", "808 sd 1"=>"808 sd 2"
               curNameNr++;
               newName = newName.substring(0, idxNameNr) + String(curNameNr);

               otherSmp <= current_project.findSampleByUniqueName(newName);
               // trace "xxx assignUniqueName: 1 newName=\""+newName+"\" => otherSmp="+#(otherSmp);
               if(null != otherSmp)
                  lastSeenNameNr = curNameNr;
               else if(curNameNr > 1000) // find highest namenr so clip_4 is created even though clip_2 may have been renamed (but clip_3 exists)
               {
                  newName = newName.substring(0, idxNameNr) + String(lastSeenNameNr + 1);
                  break;
               }
            }
            else
            {
               // Fallback, e.g. "my_sample"=>"my_sample_2", "sd 808"=>"sd 808_2"
               newName = _name + "_" + iter;

               otherSmp <= current_project.findSampleByUniqueName(newName);
               // trace "xxx assignUniqueName: 2 newName=\""+newName+"\" => otherSmp="+#(otherSmp);
               if((null == otherSmp) || (@(otherSmp) == @(this)))
                  break;
            }

            iter++;
         }
      }

      unique_name = newName;

      Global.Debug("Sample::assignUniqueName: _name=\""+_name+"\" => newName=\""+unique_name+"\"");
   }

   // <method_set.png>
   public method setNamespaceIdx(int _idx) {
      namespace_idx = _idx;
   }

   // <method_get.png>
   public method getNamespaceIdx() : int {
      return namespace_idx;
   }

   // <method_get.png>
   public method getNamespaceName() : String {
      return current_project.getSampleNamespaceNameByIdx(namespace_idx);
   }

   // <method_set.png>
   public =replay= method setSourceTrackIndex(int _trackIdx) {
      // -1=off
      src_track_idx = _trackIdx;
   }

   // <method.png>
   public method handleTrackReorder(IntArray _reorderMap) {
      if(src_track_idx >= 0)
         src_track_idx = _reorderMap.get(src_track_idx);
   }

   // <method_init.png>
   public =replay= static InitLiveRecZone(StSample s, boolean _bStereo) {
      // called after basic zone init is done
      s.maxVoices = 1;
      s.volumeRampStepsMillisecIn = 1;

      if(false)
      {
         s.setMMSrc   (0, STSAMPLE_MM_SRC_CC1_MODWHEEL);
         s.setMMCurve (0, 0.0f);
         s.setMMDst   (0, STSAMPLE_MM_DST_SYNC_SPEED);
         s.setMMAmt   (0, 7.5);
         s.setMMEnable(0, true);

         s.setMMSrc   (1, STSAMPLE_MM_SRC_CC1_MODWHEEL);
         s.setMMCurve (1, 0.0f);
         s.setMMDst   (1, STSAMPLE_MM_DST_VOLUME);
         s.setMMAmt   (1, -1.0);
         s.setMMEnable(1, true);

         s.setMMSrc   (2, STSAMPLE_MM_SRC_CONST_1);
         s.setMMCurve (2, 0.0f);
         s.setMMDst   (2, STSAMPLE_MM_DST_SYNC_SLEW);
         s.setMMAmt   (2, 0.4);
         s.setMMEnable(2, true);
      }

      s.liveRecEnable             = true;
      s.liveRecStereo             = _bStereo;
      s.liveRecMonitor            = maybe;  // add input to output (src track mute state (seq or audio) effectively controls monitoring)
      s.liveRecInputPan           = 0.0f;
      s.enableSumInput            = maybe;
      s.sumInputXFade             = 0.0;  //
      s.liveRecSkipInputNumFrames = STConfig.liverec_zone_initial_latency;
      s.liveRecClear              = maybe; // overdub

      StADSR adsr <= s.getOrCreateVolADSR();
      StEnvelope env <= adsr.getOrCreateEnvRelease();
      env.timescale = 700;
      env.setExponent(8);
      BezierEditState beState <= adsr.getEnvReleaseMetaData();
      beState.out_exponent = 8;

      env <= adsr.getOrCreateEnvAttack();
      // BezierEditState beState <= adsr.getEnvAttackMetaData();
      // Envelope beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initSustainEnv(env.metaData, env.data);
   }

   // <method_init.png>
   public method initLiveRecSample(float _millisec, boolean _bStereo) {
      waveform.numChannels   = _bStereo ? 2 : 1;
      waveform.sampleRate    = Audio.mix_rate;
      waveform.baseFrequency = BASE_FREQ_MIDDLE_C;

      int numFrames = (Audio.mix_rate / 1000.0f) * _millisec;
      waveform.alloc(_bStereo ? 2 : 1, numFrames);

      FloatArray smpDat <= waveform.sampleData;
      if(null != smpDat)
      {
         smpDat.fill(0);
      }

      setMaxVoices(2);

      StSample s <= newZone();

      IntArray loops <= s.getOrCreateSampleLoops();
      loops.free();
      loops.add(0);
      loops.add(numFrames);
      loops.add(1);
      s.verifySampleAreas();

      sample_bank.enablePerfCtlFreezeNoteOff = true;

      InitLiveRecZone(s, _bStereo);
   }

   // <method_set.png>
   public method appendOriginalUniqueNameToDescription(String _origUniqueName) {
      int idxS = description.indexOf("<-", 0);
      if(-1 != idxS)
      {
         int idxE = description.indexOf("->", 0);
         if(-1 != idxE)
         {
            description.replaceRegion(idxS, idxE, "<-"+_origUniqueName);
         }
      }
      else
      {
         description.append(" <-"+_origUniqueName+"->");
         description.trim();
      }
   }

   // <method_set.png>
   public =replay= method setSoloZoneIdx(int _idx) {
      // Global.Debug("setSoloZoneIdx("+_idx+"): old solo_zone_idx="+solo_zone_idx);
      solo_zone_idx = _idx;
      sample_bank.setEnableSkipRange(-1 != _idx);
   }

   // <method_set.png>
   public =replay= method setPrgId(int _id) {
      prg_id = _id;
      b_autoload = false;
   }

   // <method_set.png>
   public method setAutoloadFlag(boolean _bEnable) {
      b_autoload = _bEnable;
   }

   // <method_set.png>
   public =replay= method setMaxVoices(int _num) {
      sample_bank.maxVoices = _num;
   }

   // <method_set.png>
   public =replay= method setEnableRealloc(boolean _bEnable) {
      sample_bank.enableRealloc = _bEnable;
   }

   // <method_set.png>
   public =replay= method setEnableUniqueNotes(boolean _bEnable) {
      sample_bank.enableUniqueNotes = _bEnable;
   }

   // <method_set.png>
   public =replay= method setTransposeOct(int _f) {
      transpose_oct = _f;
      sample_bank.transpose = transpose_oct * 12 + transpose_semi + transpose_cents/100.0f;
   }

   // <method_set.png>
   public =replay= method setTransposeSemi(int _f) {
      transpose_semi = _f;
      sample_bank.transpose = transpose_oct * 12 + transpose_semi + transpose_cents/100.0f;
   }

   // <method_set.png>
   public =replay= method setTransposeCents(float _f) {
      transpose_cents = _f;
      sample_bank.transpose = transpose_oct * 12 + transpose_semi + transpose_cents/100.0f;
   }

   // <method_get.png>
   public method getTranspose() : float {
      return sample_bank.transpose;
   }

   // <method.png>
   public method setTransposeAndUpdateOctSemiCents(float _tr) {
      sample_bank.transpose = _tr;
      transpose_oct  = int(_tr / 12.0f);
      _tr -= transpose_oct * 12;
      transpose_semi = (_tr < 0) ? -(int(-_tr) % 12) : (int(_tr) % 12);
      _tr -= transpose_semi;
      transpose_cents = _tr * 100.0f;
   }

   // <method_set.png>
   public =replay= method setPitchbendUp(float _f) {
      pitchbend_up = _f;
   }

   // <method_set.png>
   public =replay= method setPitchbendDown(float _f) {
      pitchbend_down = _f;
   }

   // <method_set.png>
   public =replay= method setVolume(float _f) {
      sample_bank.volume = _f;
   }

   // <method_get.png>
   public method getVolume() : float {
      return sample_bank.volume;
   }

   // <method_set.png>
   public =replay= method setPan(float _f) {
      sample_bank.pan = _f;
   }

   // <method_get.png>
   public method getPan() : float {
      return sample_bank.pan;
   }

   // <method_set.png>
   public =replay= method setSampleOffRand(float _f) {
      sample_bank.sampleOffsetRandAmount = _f;
   }

   // <method_get.png>
   public method getSampleOffRand() : float {
      return sample_bank.sampleOffsetRandAmount;
   }

   // <method_set.png>
   public =replay= method setFreqRand(float _f) {
      sample_bank.freqRandAmount = _f;
   }

   // <method_get.png>
   public method getFreqRand() : float {
      return sample_bank.freqRandAmount;
   }

   // <method_set.png>
   public =replay= method setVolumeRand(float _f) {
      sample_bank.volumeRandAmount = _f;
   }

   // <method_get.png>
   public method getVolumeRand() : float {
      return sample_bank.volumeRandAmount;
   }

   // <method_set.png>
   public =replay= method setPanRand(float _f) {
      sample_bank.panRandAmount = _f;
   }

   // <method_get.png>
   public method getPanRand() : float {
      return sample_bank.panRandAmount;
   }

   // <method_set.png>
   public =replay= method setModSrc(int _type) {
      mod_src = _type;
   }

   // <method_set.png>
   public =replay= method setEnableModSrcNoteOn(boolean _bEnable) {
      b_mod_src_noteon = _bEnable;
   }

   // <method_get.png>
   public method getNumZones() : int {
      return sample_bank.numSamples;
   }

   // <method.png>
   public method multiplyZoneVolumesBySampleVolumeAndReplaceByOne(float _volumeScl) {
      // when merging first sample (PageTrack::handleMergeSamples2())
      StSample zone <= sample_bank.firstSample;
      float smpVol = sample_bank.volume * _volumeScl;
      while(null != zone)
      {
         zone.volume *= smpVol;
         zone <= zone.next;
      }
      sample_bank.volume = 1.0f;
   }

   // <method.png>
   public method addSamplePanToZonesAndReplaceByZero(float _pan) {
      // when merging first sample (PageTrack::handleMergeSamples2())
      StSample zone <= sample_bank.firstSample;
      float smpPan = sample_bank.pan + _pan;
      while(null != zone)
      {
         zone.pan = mathClampf(zone.pan + smpPan, -1.0f, 1.0f);
         zone <= zone.next;
      }
      sample_bank.pan = 0.0f;
   }

   // <method_get.png>
   public static ZoneHasValidKeyAndVelocityRanges(StSample s) : boolean {
      StRange range <= s.getKeyRange();
      if( (range.lo > 0) || (range.hi > 0) )
      {
         range <= s.getVelRange();
         int vrLo = mathClampi(range.lo * 127, 0, 127);
         int vrHi = mathClampi(range.hi * 127, 0, 127);
         if(vrLo > 0 || vrHi > 0)
            return true;
      }
      return false;
   }

   // <method_get.png>
   public method getNumZonesWithValidKeyAndVelocityRanges() : int {
      int r = 0;
      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         if(ZoneHasValidKeyAndVelocityRanges(s))
            r++;

         // Next zone
         s <= s.next;
      }
      return r;
   }

   // <method_get.png>
   public method getZoneByIdx(local int _idx) : StSample {
      return sample_bank.getSampleByIdx(_idx);
   }

   // <method_get.png>
   public method getZoneIdx(StSample _s) : int {
      return sample_bank.getSampleIdx(_s);
   }

   // <method_get.png>
   public method findZoneByName(String _id) : StSample {
      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         if(_id == s.name)
            return s;
         s <= s.next;
      }
      return null;
   }

   // <method_get.png>
   public method hasNamedZone() : boolean {
      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         String sName <= s.name;
         if(null != sName && !sName.isBlank())
            return true;
         s <= s.next;
      }
      return false;
   }

   // <method.png>
   public =replay= method initZone(StSample s) {

      s.waveform = waveform;
      s.volume = 1.0;

      StADSR *adsr;
      StEnvelope *env;
      BezierEditState *beState;
      Envelope *beData;
      StRange *range;
      StLFO *lfo;

      // Key range
      range <= s.getOrCreateKeyRange();
      range.lo = 0;
      range.hi = 127;

      // Velocity range
      range <= s.getOrCreateVelRange();
      range.lo = 0;
      range.hi = 1.01;

      // Mod range
      range <= s.getOrCreateModRange();
      range.lo = 0;
      range.hi = 1.01;

      // Freq ADSR
      adsr <= s.getOrCreateFreqADSR();
      adsr.intensity            = 1.0;
      adsr.level                = 12.0;
      adsr.timescaleMillisec    = 50000;// max = 100000.0;
      adsr.stageOp              = STADSR_STAGEOP_MUL_INTENSITY; //STADSR_STAGEOP_ADD;  //
      adsr.enableSustainLoop    = true;

      // Freq Attack
      env <= adsr.getOrCreateEnvAttack();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initFreqEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 200.0;

      // Freq Sustain
      env <= adsr.getOrCreateEnvSustain();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initFreqEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 100.0;

      // Freq Release
      env <= adsr.getOrCreateEnvRelease();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initFreqEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 70.0;

      // Volume ADSR
      adsr <= s.getOrCreateVolADSR();
      adsr.intensity            = 1.0;
      adsr.level                = 1.0;
      adsr.timescaleMillisec    = 50000;// max = 100000.0;
      adsr.stageOp              = STADSR_STAGEOP_MUL;
      adsr.enableSustainLoop    = true;

      // Volume Attack
      env <= adsr.getOrCreateEnvAttack();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initAttackEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 200.0;

      // Volume Sustain
      env <= adsr.getOrCreateEnvSustain();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initSustainEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 100.0;

      // Volume Release
      env <= adsr.getOrCreateEnvRelease();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initReleaseEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 70.0;

      // Pan ADSR
      adsr <= s.getOrCreatePanADSR();
      adsr.intensity            = 1.0;
      adsr.level                = 1.0;
      adsr.timescaleMillisec    = 50000;// max = 100000.0;
      adsr.stageOp              = STADSR_STAGEOP_ADD;  // STADSR_STAGEOP_MUL_INTENSITY
      adsr.enableSustainLoop    = true;

      // Pan Attack
      env <= adsr.getOrCreateEnvAttack();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initPanEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 200.0;

      // Pan Sustain
      env <= adsr.getOrCreateEnvSustain();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initPanEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 100.0;

      // Pan Release
      env <= adsr.getOrCreateEnvRelease();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initPanEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 70.0;

      // Aux ADSR
      adsr <= s.getOrCreateAuxADSR();
      adsr.intensity            = 1.0;
      adsr.level                = 1.0;
      adsr.timescaleMillisec    = 50000;// max = 100000.0;
      adsr.stageOp              = STADSR_STAGEOP_MUL;//_INTENSITY; // STADSR_STAGEOP_ADD
      adsr.enableSustainLoop    = true;

      // Aux Attack
      env <= adsr.getOrCreateEnvAttack();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      // // Dialogs.curve_dialog.initAuxEnv(beState, beData);
      Dialogs.curve_dialog.initAttackEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 200.0;

      // Aux Sustain
      env <= adsr.getOrCreateEnvSustain();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      Dialogs.curve_dialog.initAuxEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 100.0;

      // Aux Release
      env <= adsr.getOrCreateEnvRelease();
      beState <= new BezierEditState;
      beData <= env.getOrCreateData();
      // // Dialogs.curve_dialog.initAuxEnv(beState, beData);
      Dialogs.curve_dialog.initReleaseEnv(beState, beData);
      env.setMetaData(#(deref beState));
      env.intensity = 1.0;
      env.timescale = 70.0;

      // Freq LFO
      lfo <= s.getOrCreateFreqLFO();
      lfo.type = STLFO_TYPE_NONE;
      lfo.freq = 5;
      lfo.fadedLevel = 0.5;
      lfo.fadeInTime = 500;
      lfo.noiseMinAmp = -1;
      lfo.noiseMaxAmp = 1;
      lfo.noiseMinSpeed = 90;
      lfo.noiseMaxSpeed = 200;

      // Volume LFO
      lfo <= s.getOrCreateVolLFO();
      lfo.type = STLFO_TYPE_NONE;
      lfo.freq = 3;
      lfo.fadedLevel = 0.5;
      lfo.fadeInTime = 500;
      lfo.noiseMinAmp = 0;
      lfo.noiseMaxAmp = 1;
      lfo.noiseMinSpeed = 90;
      lfo.noiseMaxSpeed = 200;

      // Pan LFO
      lfo <= s.getOrCreatePanLFO();
      lfo.type = STLFO_TYPE_NONE;
      lfo.freq = 2;
      lfo.fadedLevel = 0.5;
      lfo.fadeInTime = 500;
      lfo.noiseMinAmp = -1;
      lfo.noiseMaxAmp = 1;
      lfo.noiseMinSpeed = 90;
      lfo.noiseMaxSpeed = 200;

      // Aux LFO
      lfo <= s.getOrCreateAuxLFO();
      lfo.type = STLFO_TYPE_NONE;
      lfo.freq = 5;
      lfo.fadedLevel = 0.5;
      lfo.fadeInTime = 500;
      lfo.noiseMinAmp = -1;
      lfo.noiseMaxAmp = 1;
      lfo.noiseMinSpeed = 90;
      lfo.noiseMaxSpeed = 200;

      // ModSeq 1
      int mseqIdx = 0;
      StModSeq *mseq;
      loop(4)
      {
         mseq <= s.getOrCreateModSeqByIndexAndPatch(mseqIdx++, 0/*patchIdx*/);
      }
   }

   // <method.png>
   public =replay= method newZone() : StSample {
      local StSample s;
      initZone(s);
      sample_bank.addSample(#(deref s));
      return s;
   }

   // <method.png>
   public =replay= method newZoneAfter(StSample _prevZone) : StSample {
      local StSample s;
      initZone(s);
      sample_bank.addSampleAfter(#(deref s), _prevZone);

      // Shift synthpatch target zones
      int smpIdx = sample_bank.getSampleIdx(s);
      cycle_state.shiftTargetZones(smpIdx, 1);

      return s;
   }

   // <method.png>
   public =replay= method removeZone(StSample _s) {

      int smpIdx = sample_bank.getSampleIdx(_s);

      Audio.ResetAllSampleVoices(this);
      sample_bank.removeSample(_s);

      // Shift synthpatch target zones
      cycle_state.shiftTargetZones(smpIdx, -1);
   }

   // <method.png>
   public =replay= method removeAllZones() {
      Audio.ResetAllSampleVoices(this);
      sample_bank.freeSamples();
   }

   // <method.png>
   public =replay= method swapZones(int _idxLeft) {
      sample_bank.swapSamples(_idxLeft);

      // Swap synthpatch target zones
      cycle_state.swapTargetZones(_idxLeft);
   }

   // <method.png>
   public =replay= method reorderOrRemoveOrCloneZones(IntArray _indices) {
      // (note) first zone has index 0
      int numSamples = sample_bank.numSamples;

      local StSample *d;
      local StSample *s;

      // Move deletable sample bank zones to array
      local StSample *[] allZones;
      allZones.alloc(numSamples);
      loop(numSamples)
      {
         allZones.add(#(sample_bank.unlinkFirstSample()));
      }

      // trace "xxx reorderOrRemoveOrCloneZones: numSamples="+numSamples+" newSbNumSamples="+sample_bank.numSamples+" allZones="+#(allZones);

      // Reorder or clone. delete unreferenced zones
      int idx;
      local IntArray indicesDone;
      local PointerArray newZones;
      foreach idx in _indices
      {
         if(0 <= idx < numSamples)
         {
            if(indicesDone.contains(idx))
            {
               // Referenced again, clone to new zone
               s <= allZones.get(idx);
               d <= new StSample;
               initZone(d);
               Samples.CopySample(d, s, -1/*appendixNr*/, true/*bCopyName*/, false/*bCopyWaveform*/);
               newZones.add(#(deref d));
               Global.Debug("reorderOrRemoveOrCloneZones: clone zone "+(idx+1)+"/"+numSamples);
            }
            else
            {
               // First zone ref, move existing zone
               s <= allZones.getDeref(idx);
               indicesDone.add(idx);
               newZones.add(#(deref s));
               Global.Debug("reorderOrRemoveOrCloneZones: ref zone "+(idx+1)+"/"+numSamples);
            }
         }
         // else: delete sample
      }

      // Samplebank is now empty, (re-)add zones
      idx = 0;
      loop(newZones.numElements)
      {
         s <= newZones.getDeref(idx++);
         sample_bank.addSample(#(deref s));
      }

      markParamsAsModified();
   }

   // <method.png>
   public =replay= method reorderZonesByTranspose() {
      local IntArray indices;
      local FloatArray transpose;

      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         transpose.add(-s.transpose);

         s <= s.next;
      }

      if(transpose.numElements > 1)
      {
         transpose.sortByValue(indices);
         reorderOrRemoveOrCloneZones(indices);
      }
   }

   // <method.png>
   public =replay= method reorderWaveformByZones() {
      local FloatArray smpDatNew;
      StSample *s;
      int numCh = waveform.numChannels;
      FloatArray smpDat <= waveform.sampleData;

      // Calc new sample size
      int newNumFrames = 0;
      s <= sample_bank.firstSample;
      while(null != s)
      {
         newNumFrames += (s.maxOffset - s.minOffset);
         s <= s.next;
      }
      Global.Debug("Sample::reorderWaveformByZones: newNumFrames="+newNumFrames);

      // Copy zone regions to new waveform
      if(smpDatNew.alloc(newNumFrames))
      {
         smpDatNew.useAll();

         s <= sample_bank.firstSample;
         int dstSampleOff = 0;
         int zoneIdx = 0;
         while(null != s)
         {
            IntArray loops <= s.getOrCreateSampleLoops();
            int srcOffStart = s.minOffset;
            int srcOffEnd   = s.maxOffset;
            int numSamples = (srcOffEnd - srcOffStart) * numCh;
            Global.Debug("Sample::reorderWaveformByZones: zone["+zoneIdx+"] start="+srcOffStart+" end="+srcOffEnd+" ("+numSamples+" samples)");

            // Append to new waveform
            smpDatNew.copyFrom(smpDat, srcOffStart * numCh, numSamples, dstSampleOff);

            // Relocate loops
            int loopIdx = 0;
            loop(loops.numElements / 3)
            {
               loops[loopIdx + 0] = (loops[loopIdx + 0] - srcOffStart) + dstSampleOff;
               loopIdx += 3;
            }

            // Next zone
            dstSampleOff += numSamples;
            s <= s.next;
            zoneIdx++;
         }

         // Assign new waveform
         smpDat.unlinkFrom(smpDatNew);

         // Verify loop areas (live rec)
         s <= sample_bank.firstSample;
         while(null != s)
         {
            s.verifySampleAreas();
            s <= s.next;
         }

         markWaveformAsModified();
         markParamsAsModified();
      }
      else
      {
         trace "[---] Sample::reorderWaveformByZones: failed to alloc "+newNumFrames+" frames";
      }
   }

   // <method.png>
   public static =replay= SetZoneFirstLoop(StSample s, int _off, int _len, int _rep) {
      s.firstLoopOffset = _off;
      s.firstLoopLen    = _len;
      s.firstLoopRep    = 0;
      s.verifySampleAreas();
   }

   // <method_init.png>
   public =replay= method reinitZones(FloatArray _smp, int _numCh, float _rate,
                                      IntArray _startOffsets,
                                      IntArray _endOffsets,
                                      boolean _bLoop
                                      ) {
      FloatArray smpD <= waveform.sampleData;
      if(null != _smp)
      {
         smpD = _smp;
         waveform.numChannels   = _numCh;
         waveform.sampleRate    = _rate;
         waveform.baseFrequency = BASE_FREQ_MIDDLE_C;
      }

      StSample *s;
      int regionIdx;
      StRange *range;
      float cmod;
      float smod;
      float cvel;
      float svel;
      int ckey;
      int keyAdvIdx;
      float coff;
      float soff;

      sample_bank.freeSamples();

      boolean bInitSingle = true;

      int truncateEndNumFrames = 256;

      if(null != _startOffsets)
      {
         if(_startOffsets.numElements > 0)
         {
            bInitSingle = false;
         }
      }

      if(!bInitSingle)
      {
         // Create zones
         // (note) All zones reference the same waveform. offset+len are used  to configure the slice regions.
         int regionNumFrames;

         switch(sample_type)
         {
            case TYPE_SINGLE:
               bInitSingle = true;
               break;

            case TYPE_LAYERED:
               regionIdx = 0;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  s.enableAlt = false;

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_WAVESEQ:
               regionIdx = 0;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  s.enableAlt = false;
                  s.delay = regionIdx;

                  // Next zone
                  regionIdx++;
               }
               break;

            default:
            case TYPE_SLICE_MOD_EVEN:
               regionIdx = 0;
               cmod = 0;
               smod = 1.0 / _startOffsets.numElements;
               local StSample*[] selectedZones;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  // trace "xxx add sample, #samples="+sample_bank.numSamples;
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;

                  range <= s.getOrCreateModRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cmod;
                  if(regionIdx == (_startOffsets.numElements-1))
                     range.hi = 1.01;
                  else
                     range.hi = cmod + smod;

                  selectedZones.add(s);

                  // Next zone
                  regionIdx++;
                  cmod += smod;
               }

               switch(sample_type)
               {
                  case TYPE_MULTISAMPLE_C:
                  case TYPE_MULTISAMPLE_C_FS:
                  case TYPE_MULTISAMPLE_C_G:
                  case TYPE_MULTISAMPLE_C_E_GS:
                  case TYPE_MULTISAMPLE_C_DS_FS_A:
                     reInitZoneRanges(sample_type, selectedZones);  // update transpose + ranges + altenable
                     break;
               }
               break;

            case TYPE_SLICE_MOD_ABS:
               regionIdx = 0;
               cmod = 0;
               smod = 1.0 / 128;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;

                  range <= s.getOrCreateModRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cmod;
                  if(regionIdx == (_startOffsets.numElements-1))
                     range.hi = 1.0 + smod;
                  else
                     range.hi = cmod + smod;

                  // Next zone
                  regionIdx++;
                  cmod += smod;
               }
               break;

            case TYPE_SLICE_MOD_XFADE:
               regionIdx = 0;
               cmod = 0;
               smod = 1.0 / _startOffsets.numElements;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  // trace "xxx add sample, #samples="+sample_bank.numSamples;
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;

                  range <= s.getOrCreateModRange();
                  range.enableNoteOnFilter = false;
                  range.lo = cmod;
                  if(regionIdx == (_startOffsets.numElements-1))
                     range.hi = 1.01;
                  else
                     range.hi = cmod + smod;
                  range.fadeIn = smod / 2;
                  range.fadeOut = smod / 2;

                  // Next zone
                  regionIdx++;
                  cmod += smod;
               }
               break;

            case TYPE_SLICE_VEL_EVEN:
               regionIdx = 0;
               cvel = 0;
               svel = 1.0 / _startOffsets.numElements;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;

                  range <= s.getOrCreateVelRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cvel;
                  if(regionIdx == (_startOffsets.numElements-1))
                     range.hi = 1.0 + svel;
                  else
                     range.hi = cvel + svel;

                  // Next zone
                  regionIdx++;
                  cvel += svel;
               }
               break;

            case TYPE_SLICE_VEL_ABS:
               regionIdx = 0;
               smod = 1.0 / 128;
               cmod = smod;  // (note) velocity 0 = note off, skip
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;

                  range <= s.getOrCreateVelRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cvel;
                  if(regionIdx == (_startOffsets.numElements-1))
                     range.hi = 1.0 + svel;
                  else
                     range.hi = cvel + svel;

                  // Next zone
                  regionIdx++;
                  cvel += svel;
               }
               break;

            case TYPE_SLICE_ALT:
               regionIdx = 0;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  s.enableAlt = true;

                  // Next zone
                  regionIdx++;
               }
               break;

            // case TYPE_MULTISAMPLE_C:
            //    // handled in default case
            //    break;

            // case TYPE_MULTISAMPLE_C_FS:
            //    // handled in default case
            //    break;

            // case TYPE_MULTISAMPLE_C_G:
            //    // handled in default case
            //    break;

            // case TYPE_MULTISAMPLE_C_E_GS:
            //    // handled in default case
            //    break;

            // case TYPE_MULTISAMPLE_C_DS_FS_A:
            //    // handled in default case
            //    break;

            case TYPE_DRUM_MAP:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
                  ckey++;

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_DRUM_MAP_WHITE:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               keyAdvIdx = 0;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

                  ckey += white_key_adv_tbl.get(keyAdvIdx);
                  keyAdvIdx = (keyAdvIdx + 1) % white_key_adv_tbl.numElements;

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_DRUM_MAP_ALT3:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               keyAdvIdx = 0;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
                  s.enableAlt = true;

                  if(2 == (regionIdx % 3))
                  {
                     ckey++;
                  }

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_DRUM_MAP_ALT3_WHITE:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               keyAdvIdx = 0;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
                  s.enableAlt = true;

                  if(2 == (regionIdx % 3))
                  {
                     ckey += white_key_adv_tbl.get(keyAdvIdx);
                     keyAdvIdx = (keyAdvIdx + 1) % white_key_adv_tbl.numElements;
                  }

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_DRUM_MAP_MOD3:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               keyAdvIdx = 0;
               cmod = 0;
               smod = 1.0 / 3;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

                  range <= s.getOrCreateModRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cmod;
                  if(2 == (regionIdx % 3))
                  {
                     range.hi = 1.01;
                     ckey++;
                  }
                  else
                  {
                     range.hi = cmod + smod;
                  }

                  // Next zone
                  cmod += smod;
                  regionIdx++;
               }
               break;

            case TYPE_DRUM_MAP_MOD3_WHITE:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               keyAdvIdx = 0;
               cmod = 0;
               smod = 1.0 / 3;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

                  range <= s.getOrCreateModRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cmod;
                  if(2 == (regionIdx % 3))
                  {
                     ckey += white_key_adv_tbl.get(keyAdvIdx);
                     keyAdvIdx = (keyAdvIdx + 1) % white_key_adv_tbl.numElements;
                     range.hi = 1.01;
                  }
                  else
                  {
                     range.hi = cmod + smod;
                  }

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_DRUM_MAP_MOD4:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               keyAdvIdx = 0;
               cmod = 0;
               smod = 1.0 / 4;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

                  range <= s.getOrCreateModRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cmod;
                  if(3 == (regionIdx % 4))
                  {
                     range.hi = 1.01;
                     ckey++;
                  }
                  else
                  {
                     range.hi = cmod + smod;
                  }

                  // Next zone
                  cmod += smod;
                  regionIdx++;
               }
               break;

            case TYPE_DRUM_MAP_MOD4_WHITE:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_drummap_base_note;
               keyAdvIdx = 0;
               cmod = 0;
               smod = 1.0 / 4;
               loop(_startOffsets.numElements)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = _startOffsets.get(regionIdx);
                  regionNumFrames = (_endOffsets.get(regionIdx) - _startOffsets.get(regionIdx));
                  if(regionNumFrames > truncateEndNumFrames)
                     regionNumFrames -= truncateEndNumFrames;  // avoid click at end of zone
                  s.firstLen = regionNumFrames;
                  s.volume = 1.0;
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

                  range <= s.getOrCreateModRange();
                  range.enableNoteOnFilter = true;
                  range.lo = cmod;
                  if(3 == (regionIdx % 4))
                  {
                     ckey += white_key_adv_tbl.get(keyAdvIdx);
                     keyAdvIdx = (keyAdvIdx + 1) % white_key_adv_tbl.numElements;
                     range.hi = 1.01;
                  }
                  else
                  {
                     range.hi = cmod + smod;
                  }

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_GRID:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_grid_base_note;
               coff = 0;
               soff = float(waveform.numFrames) / grid_size;
               loop(grid_size)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = coff;
                  s.firstLen = soff;
                  s.volume = 1.0;
                  s.maxVoices = 1;
                  s.mutexGroup = sample_bank.getMutexGroupByIdx(0);
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

                  ckey++;
                  coff += soff;

                  // Next zone
                  regionIdx++;
               }
               break;

            case TYPE_GRID_WHITE:
               regionIdx = 0;
               ckey = STConfig.pgsample_reinit_grid_base_note;
               coff = 0;
               soff = float(waveform.numFrames) / grid_size;
               keyAdvIdx = 0;
               loop(grid_size)
               {
                  s <= newZone();
                  s.waveform = waveform;
                  s.firstOffset = coff;
                  s.firstLen = soff;
                  s.volume = 1.0;
                  s.maxVoices = 1;
                  s.mutexGroup = sample_bank.getMutexGroupByIdx(0);
                  range <= s.getOrCreateKeyRange();
                  range.lo = ckey;
                  range.hi = ckey;
                  range.enableNoteOnFilter = true;
                  range.enableHighInclusive = true;
                  s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

                  ckey += white_key_adv_tbl.get(keyAdvIdx);
                  keyAdvIdx = (keyAdvIdx + 1) % white_key_adv_tbl.numElements;
                  coff += soff;

                  // Next zone
                  regionIdx++;
               }
               break;
         }
      }

      if(bInitSingle)
      {
         s <= newZone();
         s.waveform = waveform;
         s.firstOffset = 0;
         s.firstLen = smpD.numElements / _numCh;
         s.volume = 1.0;
      }

      // Enable / disable loops
      s <= sample_bank.firstSample;
      while(null != s)
      {
         if(_bLoop)
         {
            IntArray loops <= s.getOrCreateSampleLoops();

            if(loops.numElements >= 3)
            {
               loops[2] = 0;
            }
         }

         s <= s.next;
      }

      sample_bank.updateAltGroups();
   }

   // <method_init.png>
   public =replay= method reInitZoneRanges(int _type, PointerArray _selectedZones) {

      // (note) keep envs, lfos, just update ranges
      FloatArray smpD <= waveform.sampleData;
      int numFrames = waveform.numFrames;
      StSample *s;
      int zoneIdx;
      StRange *range;
      float cmod;
      float smod;
      float cvel;
      float svel;
      int ckey;
      int keyAdvIdx;

      int numZones = _selectedZones.numElements; // sample_bank.numSamples

      if(0 == numZones)
         return;

      // Create zones
      // (note) All zones reference the same waveform. offset+len are used  to configure the slice regions.
      switch(_type)
      {
         default:
         case TYPE_SINGLE:
            zoneIdx = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;
               // // s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_LAYERED:
            zoneIdx = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;
               // // s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_WAVESEQ:
            zoneIdx = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;
               // // s.setTransposeAndUpdateOctSemi(0);
               s.delay = zoneIdx;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_SLICE_MOD_EVEN:
            zoneIdx = 0;
            cmod = 0;
            smod = 1.0 / numZones;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.enableNoteOnFilter = true;
               range.lo = cmod;
               if(zoneIdx == (numZones - 1))
                  range.hi = 1.01;
               else
                  range.hi = cmod + smod;

               s.enableAlt = false;
               // // s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
               cmod += smod;
            }
            break;

         case TYPE_SLICE_MOD_ABS:
            zoneIdx = 0;
            cmod = 0;
            smod = 1.0 / 128;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.enableNoteOnFilter = true;
               range.lo = cmod;
               if(zoneIdx == (numZones - 1))
                  range.hi = 1.0 + smod;
               else
                  range.hi = cmod + smod;

               s.enableAlt = false;
               // // s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
               cmod += smod;
            }
            break;

         case TYPE_SLICE_MOD_XFADE:
            zoneIdx = 0;
            cmod = 0;
            smod = 1.0 / numZones;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.enableNoteOnFilter = false;
               range.lo = cmod;
               if(zoneIdx == (numZones - 1))
                  range.hi = 1.01;
               else
                  range.hi = cmod + smod;
               range.fadeIn = smod / 2;
               range.fadeOut = smod / 2;

               s.enableAlt = false;
               // // s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
               cmod += smod;
            }
            break;

         case TYPE_SLICE_VEL_EVEN:
            zoneIdx = 0;
            cvel = 0;
            svel = 1.0 / numZones;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.enableNoteOnFilter = true;
               range.lo = cvel;
               if(zoneIdx == (numZones - 1))
                  range.hi = 1.0 + svel;
               else
                  range.hi = cvel + svel;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;
               s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
               cvel += svel;
            }
            break;

         case TYPE_SLICE_VEL_ABS:
            zoneIdx = 0;
            smod = 1.0 / 128;
            cmod = smod;  // (note) velocity 0 = note off, skip
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.enableNoteOnFilter = true;
               range.lo = cvel;
               if(zoneIdx == (numZones - 1))
                  range.hi = 1.0 + svel;
               else
                  range.hi = cvel + svel;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;
               // // s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
               cvel += svel;
            }
            break;

         case TYPE_SLICE_ALT:
            zoneIdx = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = 0;
               range.hi = 127;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = true;
               // // s.setTransposeAndUpdateOctSemi(0);

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_MULTISAMPLE_C:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_multi_base_note;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();

               if(0 == zoneIdx)
                  range.lo = 0;
               else
                  range.lo = ckey - 12;

               if(zoneIdx == (numZones - 1))
                  range.hi = 127;
               else
                  range.hi = ckey + 11;

               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
               ckey += 12;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_MULTISAMPLE_C_FS:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_multi_base_note;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();

               if(0 == zoneIdx)
                  range.lo = 0;
               else if(zoneIdx & 1)
                  range.lo = ckey - 2;  // e..f#
               else
                  range.lo = ckey - 2;  // a#..c

               if(zoneIdx == (numZones - 1))
                  range.hi = 127;
               else if(zoneIdx & 1)
                  range.hi = ckey + 3;  // f#..a
               else
                  range.hi = ckey + 3;  // c..d#

               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
               ckey += 6;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_MULTISAMPLE_C_G:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_multi_base_note;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();

               if(0 == zoneIdx)
                  range.lo = 0;
               else if(zoneIdx & 1)
                  range.lo = ckey - 3;  // e..g
               else
                  range.lo = ckey - 2;  // a#..c

               if(zoneIdx == (numZones - 1))
                  range.hi = 127;
               else if(zoneIdx & 1)
                  range.hi = ckey + 2;  // g..a
               else
                  range.hi = ckey + 3;  // c..d#

               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

               if(zoneIdx & 1)
                  ckey += 5;
               else
                  ckey += 7;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_MULTISAMPLE_C_E_GS:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_multi_base_note;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();

               if(0 == zoneIdx)
                  range.lo = 0;
               else
                  range.lo = ckey - 1;

               if(zoneIdx == (numZones - 1))
                  range.hi = 127;
               else
                  range.hi = ckey + 2;

               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

               ckey += 4;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_MULTISAMPLE_C_DS_FS_A:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_multi_base_note;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();

               if(0 == zoneIdx)
                  range.lo = 0;
               else
                  range.lo = ckey - 1;

               if(zoneIdx == (numZones - 1))
                  range.hi = 127;
               else
                  range.hi = ckey + 1;

               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

               ckey += 3;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_DRUM_MAP:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_drummap_base_note;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = ckey;
               range.hi = ckey;
               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
               ckey++;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_DRUM_MAP_WHITE:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_drummap_base_note;
            keyAdvIdx = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = ckey;
               range.hi = ckey;
               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);

               ckey += white_key_adv_tbl.get(keyAdvIdx);
               keyAdvIdx = (keyAdvIdx + 1) % white_key_adv_tbl.numElements;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_DRUM_MAP_ALT3:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_drummap_base_note;
            keyAdvIdx = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = ckey;
               range.hi = ckey;
               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
               s.enableAlt = true;

               if(2 == (zoneIdx % 3))
                  ckey++;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_DRUM_MAP_ALT3_WHITE:
            zoneIdx = 0;
            ckey = STConfig.pgsample_reinit_drummap_base_note;
            keyAdvIdx = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               range <= s.getOrCreateKeyRange();
               range.lo = ckey;
               range.hi = ckey;
               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;
               s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - ckey);
               s.enableAlt = true;

               if(2 == (zoneIdx % 3))
               {
                  ckey += white_key_adv_tbl.get(keyAdvIdx);
                  keyAdvIdx = (keyAdvIdx + 1) % white_key_adv_tbl.numElements;
               }

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               // Next zone
               zoneIdx++;
            }
            break;

         case TYPE_TUNED_MULTISAMPLE:
            // (note) zones must be ordered by transpose (lowest note first)
            zoneIdx = 0;
            int lastKey = 0;
            loop(numZones)
            {
               s <= _selectedZones.get(zoneIdx);

               int key = KEY_MIDDLE_C - s.transpose;

               range <= s.getOrCreateKeyRange();
               if(lastKey > key)
                  range.lo = key;
               else
                  range.lo = lastKey;

               if( (zoneIdx+1) < numZones )
               {
                  StSample sNext <= s.next;
                  int nextKey = KEY_MIDDLE_C - sNext.transpose;

                  if(nextKey >= key)
                  {
                     int middleKey = (nextKey + key) / 2;
                     range.hi = middleKey;
                     lastKey = middleKey + 1;  // next lo key
                  }
                  else
                  {
                     trace "[~~~] Sample::reInitZoneRanges: invalid zone order (key="+key+" < nextKey="+nextKey;
                     range.hi = key;
                  }
               }
               else
               {
                  // Last zone
                  range.hi = 127;
               }

               range.enableNoteOnFilter = true;
               range.enableHighInclusive = true;

               range <= s.getOrCreateVelRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               range <= s.getOrCreateModRange();
               range.lo = 0;
               range.hi = 1.01;
               range.enableNoteOnFilter = true;
               range.fadeIn = 0;
               range.fadeOut = 0;

               s.enableAlt = false;

               // Next zone
               zoneIdx++;
            }
            break;
      }

      sample_bank.updateAltGroups();
   }

   // <method_init.png>
   public =replay= method initFromWaveform(FloatArray _smp, int _numCh, float _rate,
                                           IntArray _startOffsets,
                                           IntArray _endOffsets,
                                           boolean _bLoop
                                           ) {

      reinitZones(_smp, _numCh, _rate,
                  _startOffsets,
                  _endOffsets,
                  _bLoop
                  );
   }

   // <method_init.png>
   public =replay= method initSingleFromWaveform(FloatArray _smp, int _numCh, int _chOff, int _dstNumCh, float _rate,
                                                 boolean _bLoop
                                                 ) {
      FloatArray smpD <= waveform.sampleData;
      if(null != _smp)
      {
         int numFrames = (_smp.numElements / _numCh);
         smpD.alloc(numFrames * _dstNumCh);
         smpD.useAll();

         tksampleedit_ringbuf_copy_samples(smpD, _dstNumCh/*dstNumCh*/, 0/*dstChOff*/, 0/*frameStartOff*/,
                                           numFrames, _dstNumCh/*numCh*/,
                                           _smp, _numCh/*srcNumCh*/, _chOff/*srcChOff*/, 0/*srcFrameOff*/
                                           );

         waveform.numChannels   = _dstNumCh;
         waveform.sampleRate    = _rate;
         waveform.baseFrequency = BASE_FREQ_MIDDLE_C;

         StSample *s;
         sample_bank.freeSamples();

         s <= newZone();
         s.waveform = waveform;
         s.firstOffset = 0;
         s.firstLen = smpD.numElements / _dstNumCh;
         s.volume = 1.0;

         if(_bLoop)
         {
            IntArray loops <= s.getOrCreateSampleLoops();
            loops[2] = 0; // inf
         }

         sample_bank.updateAltGroups();
      }
   }

   // <method_init.png>
   public =replay= method initGranularFromWaveform(FloatArray _smp, int _numCh, int _chOff, int _dstNumCh, float _rate,
                                                   boolean _bLoop
                                                   ) {
      FloatArray smpD <= waveform.sampleData;
      if(null != _smp)
      {
         initSingleFromWaveform(_smp, _numCh, _chOff, _dstNumCh, _rate, _bLoop);

         description = "MW=loop start, BC=loop len";

         StSample s1 <= getZoneByIdx(0);

         // (note) caller checks if sample is long enough (>= 16384 frames)
         s1.startEndFadeNumFrames = 2048;
         s1.volumeRampStepsMillisecIn = 8.0;
         IntArray loops <= s1.getOrCreateSampleLoops();
         loops[0] = 0;
         loops[1] = 0;
         loops[2] = 1;

         loops[3] = 0;
         loops[4] = 4096;
         loops[5] = 0;

         s1.setMMSrc   (0, STSAMPLE_MM_SRC_CC1_MODWHEEL);
         s1.setMMCurve (0, 0.0f);
         s1.setMMDst   (0, STSAMPLE_MM_DST_SAMPLE_SHIFT_EOL);
         s1.setMMAmt   (0, 1.0);
         s1.setMMEnable(0, true);

         s1.setMMSrc   (1, STSAMPLE_MM_SRC_CC2_BREATHCTL);
         s1.setMMOp    (1, STSAMPLE_MM_OP_REPLACE);
         s1.setMMCurve (1, 0.0f);
         s1.setMMDst   (1, STSAMPLE_MM_DST_CYCLE_LEN_EOL);
         s1.setMMAmt   (1, 10.0);
         s1.setMMEnable(1, true);

         s1.setMMSrc   (2, STSAMPLE_MM_SRC_CONST_1);
         s1.setMMOp    (2, STSAMPLE_MM_OP_ADD);
         s1.setMMCurve (2, 0.0f);
         s1.setMMDst   (2, STSAMPLE_MM_DST_CYCLE_LEN_EOL);
         s1.setMMAmt   (2, 0.1);
         s1.setMMEnable(2, true);

         s1.setMMSrc   (3, STSAMPLE_MM_SRC_CONST_1);
         s1.setMMOp    (3, STSAMPLE_MM_OP_REPLACE);
         s1.setMMCurve (3, 0.0f);
         s1.setMMDst   (3, STSAMPLE_MM_DST_CYCLE_LEN_SAMPLE_OFFSET);
         s1.setMMAmt   (3, 0.0);
         s1.setMMEnable(3, true);

         StSample s2 <= newZone();
         s2.waveform = s1.waveform;
         Samples.CopySample(s2, s1, -1/*appendixNr*/, true/*bCopyName*/, false/*bCopyWaveform*/);
         s2.setMMAmt   (3, 0.5);

         sample_bank.volume = 0.5;
         initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC1_MODWHEEL]  = 0x00;
         // initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC2_BREATHCTL] = 0x25;
         initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC2_BREATHCTL] = 37.779;
         // initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC2_BREATHCTL] = 0x36;
         solo_zone_idx = -1;
      }
   }

   // <method.png>
   public =replay= method initFromWavFile(String _pathName, boolean _bForceLoop) : boolean {
      boolean ret = false;
      local Integer retSampleRate;
      local Integer retNumCh;
      FloatArray smp <= waveform.sampleData;

      StSample *s;
      sample_bank.freeSamples();

      s <= newZone();
      s.waveform = waveform;
      s.volume = 1.0;
      s.enableFromStart = true;

      try
      {
         if(WavIO.LoadLocal(_pathName,
                            smp,
                            retSampleRate,
                            retNumCh,
                            null/*retFileInfoStr*/,
                            s/*sampleHint*/,
                            waveform/*bwfHint*/
                            ))
         {
            waveform.sampleRate = retSampleRate;
            waveform.numChannels = retNumCh;
            waveform.baseFrequency = BASE_FREQ_MIDDLE_C;

            IntArray loops <= s.getOrCreateSampleLoops();

            if(0 == loops.numElements)
            {
               loops.add(0);
               loops.add(smp.numElements / retNumCh);
               loops.add(_bForceLoop ? 0 : 1);
            }
            else if(_bForceLoop)
            {
               loops[2] = 0;
            }

            local String baseName <= Utils.BaseName(_pathName);
            assignUniqueName(baseName);

            String *sbwf;
            sbwf <= waveform.bwfDescription;
            if(null != sbwf)
            {
               description.append(sbwf);
            }

            sbwf <= waveform.bwfOriginator;
            if(null != sbwf)
            {
               description.append(" {");
               description.append(sbwf);
               description.append("}");
            }

            sbwf <= waveform.bwfDate;
            if(null != sbwf)
            {
               description.append(" ");
               description.append(sbwf);
            }

            sbwf <= waveform.bwfTime;
            if(null != sbwf)
            {
               description.append(" ");
               description.append(sbwf);
            }

            description.trim();

            ret = true;
         }
      }
      catch(Error e)
      {
         trace "[---] Sample::initFromWavFile: caught error e.message="+e.message;
      }

      return ret;
   }

   // <method.png>
   public =replay= method appendZoneFromWavFile(String _pathName, boolean _bLoop) : boolean {
      StSample *s;
      s <= newZone();  // create LFOs, ENVs, ..
      if(initZoneFromWavFile2(s, _pathName, _bLoop))
      {
         return true;
      }
      else
      {
         removeZone(s);
         return false;
      }
   }

   // <method.png>
   public =replay= method initZoneFromWavFile(StSample s, String _pathName, boolean _bLoop) : boolean {
      s.reinit();
      initZone(s);  // create LFOs, ENVs, ..
      return initZoneFromWavFile2(s, _pathName, _bLoop);
   }

   // <method.png>
   protected =replay= method initZoneFromWavFile2(StSample s, String _pathName, boolean _bLoop) : boolean {
      boolean ret = false;
      local Integer retSampleRate;
      local Integer retNumCh;
      local FloatArray faLoad;

      float wfSampleRateOrig = waveform.sampleRate;

      s.waveform = waveform;
      s.volume = 1.0;
      s.enableFromStart = false;

      local WavIO_BWF bwf;

      try
      {
         // (note) may update waveform.sampleRate when 'smpl' chunk is present
         if(WavIO.LoadLocal(_pathName,
                            faLoad,
                            retSampleRate,
                            retNumCh,
                            null/*retFileInfoStr*/,
                            s/*sampleHint*/,
                            bwf/*bwfHint*/
                            ))
         {
            // (note) retSampleRate may differ from (new) waveform.sampleRate
            //         (e.g. Wav FMT says 44100 but smpl chunk says 22675)
            // // waveform.sampleRate = retSampleRate;
            // // waveform.numChannels = retNumCh;
            // trace "xxx appendZone: retSampleRate="+retSampleRate+" wfSampleRate="+waveform.sampleRate;
            if(1 == getNumZones())
            {
               // Keep waveform.sampleRate set by WavIO.LoadLocal()
               waveform.sampleRate = retSampleRate;
            }
            else
            {
               s.setSampleRateRatio(retSampleRate / wfSampleRateOrig);
               waveform.sampleRate = wfSampleRateOrig;
            }

            // Append to current sample (keep current #ch)
            FloatArray smp <= waveform.sampleData;

            int loadNumFrames = faLoad.numElements / retNumCh;
            int newLen = smp.numElements + loadNumFrames * waveform.numChannels;
            int appendFrameOff = waveform.getNumFrames();
            boolean bAllocOk = false;

            if(appendFrameOff < 4)
            {
               newLen -= appendFrameOff * waveform.numChannels;
               appendFrameOff = 0;
            }

            // trace "xxx smp.numElements="+smp.numElements;

            if(appendFrameOff > 0)
            {
               // Add silence before appended waveform
               newLen += SampleView.NUM_BORDER_SILENCE_FRAMES*waveform.numChannels;

               // Resize sample array
               bAllocOk = smp.realloc(newLen);

               if(bAllocOk)
               {
                  smp.numElements = newLen;

                  // Clear silence area before new sample
                  smp.fillRegion(appendFrameOff*waveform.numChannels,
                                 SampleView.NUM_BORDER_SILENCE_FRAMES*waveform.numChannels,
                                 0.0f
                                 );
                  appendFrameOff += SampleView.NUM_BORDER_SILENCE_FRAMES;
               }
            }
            else
            {
               // Resize sample array
               bAllocOk = smp.realloc(newLen);
               if(bAllocOk)
               {
                  smp.numElements = newLen;
               }
            }

            if(bAllocOk)
            {
               // Append new samples (left channel)
               tksampleedit_copy_mono_adv_to_mono_adv(smp,
                                                      appendFrameOff*waveform.numChannels,
                                                      waveform.numChannels/*outAdv*/,
                                                      faLoad, 0, retNumCh,
                                                      loadNumFrames
                                                      );
               if(waveform.numChannels >= 2)
               {
                  if(retNumCh >= 2)
                  {
                     // Append new samples (right channel from loaded sample)
                     tksampleedit_copy_mono_adv_to_mono_adv(smp,
                                                            appendFrameOff*waveform.numChannels + 1,
                                                            waveform.numChannels/*outAdv*/,
                                                            faLoad, 1, retNumCh,
                                                            loadNumFrames
                                                            );
                  }
                  else
                  {
                     // Append new samples (duplicate right channel)
                     tksampleedit_copy_mono_adv_to_mono_adv(smp,
                                                            appendFrameOff*waveform.numChannels + 1,
                                                            waveform.numChannels/*outAdv*/,
                                                            faLoad, 0, retNumCh,
                                                            loadNumFrames
                                                            );
                  }
               }

               IntArray loops <= s.getOrCreateSampleLoops();
               if(0 == loops.numElements)
               {
                  loops.add(appendFrameOff);
                  loops.add(loadNumFrames);
                  loops.add(1);
               }
               else
               {
                  s.firstOffset  = appendFrameOff;
                  s.firstLoopLen = loadNumFrames;
                  s.firstLoopRep = _bLoop ? 0 : 1;
               }

               Global.Debug("Sample::appendZoneFromWavFile: append zone from wav file \""+_pathName+"\", appendOff="+appendFrameOff+" len="+loadNumFrames+" loop="+_bLoop);

               ret = true;
            }
            else
            {
               Global.Error("failed to allocate new waveform (newLen="+newLen+")");
            }
         }
      }
      catch(Error e)
      {
         trace "[---] Sample::initFromWavFile: caught error e.message="+e.message;
         removeZone(s);
      }

      return ret;
   }

   // <method_get.png>
   public method getWavPathname() : String {
      local String r <= Global.GetProjectSamplesWavRootPath() + "/" + unique_name + ".wav";
      r.replace("//", "/");
      r.replace("//", "/");
      return deref r;
   }

   // <save.png>
   protected method saveWav(local String rootPath) {
      local String pathName <= Utils.ToNativePathName(rootPath) + "/" + unique_name + ".wav";

      if(waveform.numFrames > 0)
      {
         FloatArray smp <= waveform.sampleData;

         int loopStart = 0;
         int loopEnd   = 0;
         StSample s <= sample_bank.firstSample;
         if(null != s)
         {
            loopStart = s.firstLoopOffset;
            loopEnd   = loopStart + s.firstLoopLen;
         }

         float midiNote = Audio.FreqToFracNote(waveform.baseFrequency);

         WavIO.SaveLocal(pathName, smp,
                         waveform.sampleRate, waveform.numChannels,
                         midiNote, loopStart, loopEnd,
                         waveform/*bwfHint*/
                         );

         Global.Debug("Sample::saveWav: wrote \""+pathName+"\" (rate="+waveform.sampleRate+" numCh="+waveform.numChannels+" numFrames="+waveform.getNumFrames()+" midiNote="+midiNote+" loopStart="+loopStart+" loopEnd="+loopEnd);
      }
   }

   // <load.png>
   public method loadWav(local String rootPath) : boolean {
      local String pathName <= Utils.ToNativePathName(rootPath) + "/" + unique_name + ".wav";

      Global.Debug("Sample::loadWav: pathName=\""+pathName+"\"");

      local Integer retSampleRate;
      local Integer retNumCh;
      FloatArray smp <= waveform.sampleData;

      return = false;

      try
      {
         if(WavIO.LoadLocal(pathName,
                            smp,
                            retSampleRate,
                            retNumCh,
                            null/*retFileInfoStr*/,
                            null/*sampleHint*/,
                            waveform/*bwfHint*/
                            ))
         {
            waveform.sampleRate = retSampleRate;
            waveform.numChannels = retNumCh;
            return = true;
         }
      }
      catch(Error e)
      {
         trace "[---] Sample::loadWav: caught error e.message="+e.message;
      }

      return;
   }

   // <save.png>
   protected method saveStateSampleRange(Stream ofs, StRange range) {

      ofs.i16 = 1; // Ver

      // Lo
      ofs.f32 = range.lo;

      // Hi
      ofs.f32 = range.hi;

      // Fade-In
      ofs.f32 = range.fadeIn;

      // Fade-Out
      ofs.f32 = range.fadeOut;

      // Note-On Filter
      ofs.i8 = range.enableNoteOnFilter;

      // High Inclusive
      ofs.i8 = range.enableHighInclusive;
   }

   // <save.png>
   protected method exportSampleRangeSYNKey(Stream ofs, StRange range) {

      if(range.lo != 0.0 ||
         range.hi != 127.0 ||
         range.fadeIn > 0.0 ||
         range.fadeOut > 0.0
         )
      {
         ofs.i8 = 1; // Ver

         // Lo
         ofs.i8 = range.lo;

         // Hi
         ofs.i8 = range.hi;

         // Fade-In
         ofs.i8 = range.fadeIn;

         // Fade-Out
         ofs.i8 = range.fadeOut;
      }
      else
      {
         // Default settings
         ofs.i8 = 0;
      }
   }

   // <save.png>
   protected method exportSampleRangeSYNVelMod(Stream ofs, StRange range) {

      if(range.lo != 0.0 ||
         range.hi != 1.01 ||
         range.fadeIn != 0.0 ||
         range.fadeOut != 0.0 ||
         range.enableNoteOnFilter != true
         )
      {
         ofs.i8 = 1; // Ver

         // Lo
         ofs.i8 = range.lo * 127;

         // Hi
         ofs.i8 = range.hi * 127;

         // Fade-In
         ofs.i8 = range.fadeIn * 127;

         // Fade-Out
         ofs.i8 = range.fadeOut * 127;

         // Note-On Filter
         ofs.i8 = range.enableNoteOnFilter;
      }
      else
      {
         // Default settings
         ofs.i8 = 0;
      }

   }

   // <save.png>
   int bezier_int_debug = 0;
   protected method saveStateSampleEnv(Stream ofs, StEnvelope env, boolean _bEditor) {
      BezierEditState *beState;
      Envelope *beData;

      if(_bEditor)
         ofs.i16 = 3; // ver
      else
         ofs.i8 = 3;

      // Envelope data
      //  (note) very large arrays (~170k for 9* A/S/R) => only save Bezier control points?
      //  (note) => save anyway, compresses down to ~6k
      if(true)
      {
         beData <= env.data;
         // trace "xxx saveStateSampleEnv: ofs.offset="+ofs.offset+" beData="+#(beData);
         if(null != beData)
         {
            // trace "xxx saveStateSampleEnv: beData.numElements="+beData.numElements;
            if(_bEditor)
               ofs.i32 = beData.numElements;
            int idx = 0;
            if(_bEditor)
            {
               loop(beData.numElements)
               {
                  ofs.f32 = beData[idx++];
               }
            }
            else if(0) // superceded by cubic spline data (calc'd in standalone loader)
            {
               // Standalone Synergy replay
               //  - map 0..1 delta times => 0..32768
               //  - map -1..1 values => -8192..+8192 (max=-2..+2)
               //  - save deltas
               //  (todo) save bezier ctl points instead.
               //          the precalced arrays are _huge_ (up to ~30k per sample)
               //          (but compress well)
               // trace "xxx saveEnv numElements="+beData.numElements;
               int lt16 = 0;
               int lv16 = 0;
               loop(beData.numElements / 2)
               {
                  // delta time (small values)
                  int ct16 = beData[idx++] * 32768;
                  ofs.i16 = (ct16 - lt16);
                  lt16 = ct16;

                  // value
                  int cv16 = beData[idx++] * 8192;
                  ofs.i16 = (cv16 - lv16);
                  lv16 = cv16;

                  // trace "xxx ct16="+ct16+" cv16="+cv16;
               }
            }
         }
         else
         {
            if(_bEditor)
               ofs.i32 = 0;  // 0 elements
         }
      }

      // BezierEdit state
      beState <= env.metaData;
      if(null != beState)
      {
         if(_bEditor)
         {
            ofs.i16 = 1;
            ofs << beState;
         }
         else
         {
            // Standalone Bezier Control Points (p,c1,c2 x/y pairs)
            FloatArray faSeg <= beState.segments;
            int numSeg = faSeg.numElements / 6;
            if(numSeg > 256)
            {
               trace "[~~~] exportSYN: num bezier control points > 256 !!!";
               numSeg = 256;
            }
            ofs.i8 = numSeg - 1;
            int j = 0;
            loop(numSeg)
            {
               ofs.i16 = (faSeg[j++] * 65535);  // p.x (0..1)
               ofs.i16 = (faSeg[j++] * 16383);  // p.y (-2..+2)
               ofs.i16 = (faSeg[j++] * 16383);  // c1.x (-2..+2)
               ofs.i16 = (faSeg[j++] * 16383);  // c1.y (-2..+2)
               ofs.i16 = (faSeg[j++] * 16383);  // c2.x (-2..+2)
               ofs.i16 = (faSeg[j++] * 16383);  // c2.y (-2..+2)
            }

            // save first curve for debugging
            if(0 && (0 == bezier_int_debug++) && (unique_name == "cycle_tri_zon_andf_2"))
            {
               File f;
               if(f.openLocal("bezier_int_debug.dat", IOS_OUT))
               {
                  f.i8 = numSeg;
                  j = 0;
                  loop(numSeg)
                  {
                     f.i16 = (faSeg[j++] * 65535);  // p.x (0..1)
                     f.i16 = (faSeg[j++] * 16383);  // p.y (-2..+2)
                     f.i16 = (faSeg[j++] * 16383);  // c1.x (-2..+2)
                     f.i16 = (faSeg[j++] * 16383);  // c1.y (-2..+2)
                     f.i16 = (faSeg[j++] * 16383);  // c2.x (-2..+2)
                     f.i16 = (faSeg[j++] * 16383);  // c2.y (-2..+2)
                  }
                  f.close();
               }
            }
         }
      }
      else
      {
         if(_bEditor)
         {
            ofs.i16 = 0;
         }
         else
         {
            // Standalone Replay num control points
            ofs.i8 = 0;
         }
      }

      // Intensity
      if(_bEditor)
         ofs.f32 = env.intensity;
      else
         ofs.i8 = env.intensity * 255;

      // Timescale (ms)
      ofs.f32 = env.timescaleMillisec;

      if(_bEditor)
      {
         // Exponent (v2+)
         ofs.f32 = env.exponent;
      }

      if(_bEditor)
      {
         // Last loaded preset name (v3+)
         Utils.WriteString(ofs, env.uiPresetName);
      }

      // trace "xxx write env intensity="+env.intensity+" timescaleMillisec="+env.timescaleMillisec+" exponent="+env.exponent;
   }

   // <save.png>
   protected method saveStateSampleADSR(Stream ofs, StADSR adsr, boolean _bEditor) {
      StEnvelope *env;

      // trace "xxx saveStateSampleADSR: ofs.offset="+ofs.offset;

      if(_bEditor)
         ofs.i16 = 1; // Ver
      else
         ofs.i8 = 1; // Ver

      // Attack envelope
      env <= adsr.envAttack;
      if(null != env)
      {
         saveStateSampleEnv(ofs, env, _bEditor);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused
         else
            ofs.i8 = 0;
      }

      // Sustain envelope
      env <= adsr.envSustain;
      if(null != env)
      {
         saveStateSampleEnv(ofs, env, _bEditor);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused
         else
            ofs.i8 = 0;
      }

      // Release envelope
      env <= adsr.envRelease;
      if(null != env)
      {
         saveStateSampleEnv(ofs, env, _bEditor);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused
         else
            ofs.i8 = 0;
      }

      // Intensity
      if(_bEditor)
         ofs.f32 = adsr.intensity;
      else
         ofs.i8 = adsr.intensity * 255;

      // Timescale (ms)
      ofs.f32 = adsr.timescaleMillisec;

      // Level
      //  (note) fixed to 1.0
      ofs.f32 = adsr.level;

      // Stage-Op
      ofs.i8 = adsr.stageOp;

      // Sustain loop enable
      ofs.i8 = adsr.enableSustainLoop;
   }

   // <save.png>
   protected method saveStateSampleLFO(Stream ofs, StLFO lfo) {

      ofs.i16 = 3; // Ver

      // Timebase
      ofs.f32 = lfo.timebase;

      // Type
      ofs.i8 = lfo.type;

      // Phase
      ofs.f32 = lfo.phase;

      // Freq
      ofs.f32 = lfo.freq;

      // Pulsewidth
      ofs.f32 = lfo.pulseWidth;

      // Delay
      ofs.f32 = lfo.delay;

      // Fade-In Time (ms)
      ofs.f32 = lfo.fadeInTime;

      // Start level
      ofs.f32 = lfo.startLevel;

      // Faded level
      ofs.f32 = lfo.fadedLevel;

      // Faded speed factor (v2+)
      ofs.f32 = lfo.fadedSpeedFactor;

      // DC Offset
      ofs.f32 = lfo.dcOffset;

      // Noise Min Amp
      ofs.f32 = lfo.noiseMinAmp;

      // Noise Max Amp
      ofs.f32 = lfo.noiseMaxAmp;

      // Noise Min Speed
      ofs.f32 = lfo.noiseMinSpeed;

      // Noise Max Speed
      ofs.f32 = lfo.noiseMaxSpeed;

      // Noise Interpol
      ofs.i8 = lfo.enableNoiseInterpol;

      // Mod Delay
      ofs.i8 = lfo.enableModDelay;

      // One-Shot
      ofs.i8 = lfo.enableOneShot;

      // Global (v3+)
      ofs.i8 = lfo.enableGlobal;

      // Reset (v3+)
      ofs.i8 = lfo.enableReset;
   }

   // <save.png>
   protected method exportSampleLFOSYN(Stream ofs, StLFO lfo) {

      if(STLFO_TYPE_NONE != lfo.type)
      {
         ofs.i8 = 3; // Ver

         // Timebase
         ofs.f32 = lfo.timebase;

         // Type
         ofs.i8 = lfo.type;

         // Phase
         ofs.i8 = lfo.phase * 255;

         // Freq
         ofs.f32 = lfo.freq;

         // Pulsewidth
         if(STLFO_TYPE_PULSE == lfo.type)
         {
            ofs.i8 = lfo.pulseWidth * 255;
         }

         // Delay
         ofs.f32 = lfo.delay;

         // Fade-In Time (ms)
         ofs.f32 = lfo.fadeInTime;

         // Start level
         ofs.f32 = lfo.startLevel;

         // Faded level
         ofs.f32 = lfo.fadedLevel;

         // Faded speed factor (v2+)
         ofs.f32 = lfo.fadedSpeedFactor;

         // DC Offset
         ofs.f32 = lfo.dcOffset;

         if(STLFO_TYPE_NOISE == lfo.type)
         {
            // Noise Min Amp
            ofs.f32 = lfo.noiseMinAmp;

            // Noise Max Amp
            ofs.f32 = lfo.noiseMaxAmp;

            // Noise Min Speed
            ofs.f32 = lfo.noiseMinSpeed;

            // Noise Max Speed
            ofs.f32 = lfo.noiseMaxSpeed;
         }

         int flags = 0;

         // Noise Interpol
         if(lfo.enableNoiseInterpol)
            flags |= (1 << 0);

         // Mod Delay
         if(lfo.enableModDelay)
            flags |= (1 << 1);

         // One-Shot
         if(lfo.enableOneShot)
            flags |= (1 << 2);

         // Global (v3+)
         if(lfo.enableGlobal)
            flags |= (1 << 3);

         // Reset (v3+)
         if(lfo.enableReset)
            flags |= (1 << 4);

         // Flags
         ofs.i8 = flags;
      }
      else
      {
         ofs.i8 = 0;  // ver=0 : no LFO
      }
   }

   // <save.png>
   protected method saveStateSampleModSeq(Stream ofs, StModSeq mseq) {

      ofs.i16 = 4; // Ver

      // Play mode
      ofs.i8 = mseq.playMode;

      // Step mode
      ofs.i8 = mseq.stepMode;

      // Num Steps
      ofs.i8 = mseq.numSteps;

      // Repeat Offset (v4+)
      ofs.i8 = mseq.repeatOffset;

      // Step values+durations
      ofs.i8 = STMODSEQ_MAX_STEPS;
      int stepIdx = 0;
      loop(STMODSEQ_MAX_STEPS)
      {
         ofs.f32 = mseq.getStepValue(stepIdx++);
      }
      stepIdx = 0;
      loop(STMODSEQ_MAX_STEPS)
      {
         ofs.i8 = mseq.getStepDuration(stepIdx++);
      }

      // Speed
      ofs.f32 = mseq.speed;

      // Tempo Sync
      ofs.i8 = mseq.enableTempoSync;

      // Value scale
      ofs.f32 = mseq.valueScl;

      // Value offset
      ofs.f32 = mseq.valueOff;

      // Slew amount (v2+)
      ofs.f32 = mseq.slewAmt;

      // One-Shot
      ofs.i8 = mseq.enableOneShot;

      // Global
      ofs.i8 = mseq.enableGlobal;

      // Reset
      ofs.i8 = mseq.enableReset;

      // Pulse
      ofs.i8 = mseq.enablePulse;
   }

   // <save.png>
   protected method exportSampleModSeqSYN(Stream ofs, StModSeq mseq) {

      if(mseq.numSteps > 0)
      {
         ofs.i8 = 4; // Ver

         // Play mode
         ofs.i8 = mseq.playMode;

         // Step mode
         ofs.i8 = mseq.stepMode;

         // Num Steps (play len)
         ofs.i8 = mseq.numSteps;

         // Repeat Offset (v4+)
         ofs.i8 = mseq.repeatOffset;

         // Step values+durations
         ofs.i8 = STMODSEQ_MAX_STEPS;
         int stepIdx = 0;
         loop(STMODSEQ_MAX_STEPS)
         {
            ofs.f32 = mseq.getStepValue(stepIdx++);
         }
         stepIdx = 0;
         loop(STMODSEQ_MAX_STEPS)
         {
            ofs.i8 = mseq.getStepDuration(stepIdx++);
         }

         // Speed
         ofs.f32 = mseq.speed;

         // Value scale
         ofs.f32 = mseq.valueScl;

         // Value offset
         ofs.f32 = mseq.valueOff;

         // Slew amount (v2+)
         ofs.i8 = mseq.slewAmt * 255;

         int flags = 0;
         // Tempo Sync
         if(mseq.enableTempoSync)
            flags |= (1 << 0);

         // One-Shot
         if(mseq.enableOneShot)
            flags |= (1 << 1);

         // Global
         if(mseq.enableGlobal)
            flags |= (1 << 2);

         // Reset (tristate)
         if(true == mseq.enableReset)
            flags |= (1 << 3);
         else if(maybe == mseq.enableReset)
            flags |= (2 << 3);

         // Pulse (tristate)
         if(true == mseq.enablePulse)
            flags |= (1 << 5);
         else if(maybe == mseq.enablePulse)
            flags |= (2 << 5);

         ofs.i8 = flags;
      }
      else
      {
         // ver=0: play len=0 => no-op modseq patch
         ofs.i8 = 0;
      }
   }

   // <save.png>
   protected method saveStateSampleMM(Stream ofs, StSample s, int mmIdx, boolean _bEditor) {

      if(_bEditor)
      {
         // Ver
         ofs.i16 = 39;

         // Enable
         ofs.i8 = s.getMMEnable(mmIdx);
      }

      // Op
      ofs.i8 = s.getMMOp(mmIdx);

      if(_bEditor)
      {
         // Slew Up (v33+)
         ofs.f32 = s.getMMSlewUp(mmIdx);

         // Slew Down (v33+)
         ofs.f32 = s.getMMSlewDown(mmIdx);
      }
      else
      {
         // Slew Up (v33+)
         ofs.i8 = mathClampi(s.getMMSlewUp(mmIdx) * 255, 0, 255);

         // Slew Down (v33+)
         ofs.i8 = mathClampi(s.getMMSlewDown(mmIdx) * 255, 0, 255);
      }

      // Slew Reset Mode (v38+)
      ofs.i8 = s.getMMSlewReset(mmIdx);

      // Source
      ofs.i8 = s.getMMSrc(mmIdx);

      // Curve (v25+)
      ofs.f32 = s.getMMCurve(mmIdx);

      // Amt
      float amt = s.getMMAmt(mmIdx);
      if(!_bEditor && s.mmVarGetEnable() && s.mmVarGetEnableForceEditIdx())
      {
         // Merge forced variation with base mod matrix
         local FloatArray mmVarData <= s.mmVarGetData();
         amt += mmVarData.get(mmIdx + s.mmVarGetEditIdx()*STSAMPLE_NUM_MODMATRIX_ENTRIES);
      }
      ofs.f32 = amt;

      // Destination
      ofs.i8 = s.getMMDst(mmIdx);
   }

   // <save.png>
   protected method saveStateSamplePlugins(Stream ofs, StSample s) {

      // Ver
      ofs.i16 = 8;

      int pluginIdx = 0;
      loop(STSAMPLE_NUM_PLUGINS)
      {
         StPluginShared pluginShared <= s.getVoicePluginShared(pluginIdx);
         int paramIdx = 0;
         if(null != pluginShared)
         {
            StPluginInfo pluginInfo <= pluginShared.info;

            Global.Debug("Sample::saveStateSamplePlugins: pluginIdx="+pluginIdx+" pluginId=\""+pluginInfo.id+"\" #params="+pluginInfo.numParams);

            // Plugin id
            Utils.WriteString(ofs, pluginInfo.id);

            // Num params
            ofs.i16 = pluginInfo.numParams;

            int numArrayParams = 0;
            int arraySz;
            int numVar;
            int varIdx;
            int arrayIdx;
            float f;
            FloatArray *faData;

            // Param values
            loop(pluginInfo.numParams)
            {
               ofs.f32 = pluginShared.getParamValue(paramIdx);
               arraySz = pluginInfo.getArrayParamSize(paramIdx);
               numVar  = pluginInfo.getArrayParamNumVariations(paramIdx);
               if(arraySz > 0 && numVar > 0)
                  numArrayParams++;
               // Next parameter
               paramIdx++;
            }

            // Array Param Data (v6+)
            //  (note) stored as signed 16bit integers
            ofs.i8 = numArrayParams;
            if(numArrayParams > 0)
            {
               paramIdx = 0;
               loop(pluginInfo.numParams)
               {
                  arraySz = pluginInfo.getArrayParamSize(paramIdx);
                  numVar  = pluginInfo.getArrayParamNumVariations(paramIdx);
                  if(arraySz > 0 && numVar > 0)
                  {
                     ofs.i8 = paramIdx;
                     ofs.i8 = arraySz - 1;
                     ofs.i8 = numVar - 1;
                     varIdx = 0;
                     loop(numVar)
                     {
                        faData <= pluginShared.getArrayParamVariationPtr(paramIdx, varIdx);
                        arrayIdx = 0;
                        if(null != faData)
                        {
                           loop(arraySz)
                           {
                              f = mathClampf(faData.get(arrayIdx++), -1.0f, 1.0f);
                              ofs.i16 = (f < 0.0f) ? (f * 32768.0f) : (f * 32767.0f);
                           }
                        }
                        else
                        {
                           // Bad plugin: arraySz+numVar > 0 but data ptr is null (=> save zeroes)
                           trace "[~~~] bad plugin: array data ptr is null (id=\""+pluginInfo.id+"\" paramIdx="+paramIdx+" varIdx="+varIdx+" arraySz="+arraySz+" numVar="+numVar+")";
                           loop(arraySz)
                              ofs.i16 = 0;
                        }
                        // Next array variation
                        varIdx++;
                     }
                  }
                  // Next parameter
                  paramIdx++;
               } // loop numParams
            } // if numArrayParams > 0
         }
         else
         {
            StPluginSharedMissing pluginSharedMissing <= s.getVoicePluginSharedMissing(pluginIdx);
            if(null != pluginSharedMissing)
            {
               Global.Debug("Sample::saveStateSamplePlugins: pluginIdx="+pluginIdx+" MISSING pluginId=\""+pluginSharedMissing.pluginId+"\" #params="+pluginSharedMissing.numParams);
               // Plugin id
               Utils.WriteString(ofs, pluginSharedMissing.pluginId);

               // Num params
               ofs.i16 = pluginSharedMissing.numParams;

               // Param values
               paramIdx = 0;
               loop(pluginSharedMissing.numParams)
                  ofs.f32 = pluginSharedMissing.getParamValue(paramIdx++);

               // Array Param Data (v6+)
               numArrayParams = pluginSharedMissing.numArrayParams;
               ofs.i8 = numArrayParams;
               if(numArrayParams > 0)
               {
                  paramIdx = 0;
                  loop(pluginSharedMissing.numParams)
                  {
                     arraySz = pluginSharedMissing.getArrayParamSize(paramIdx);
                     numVar  = pluginSharedMissing.getArrayParamNumVariations(paramIdx);
                     if(arraySz > 0 && numVar > 0)
                     {
                        ofs.i8 = paramIdx;
                        ofs.i8 = arraySz - 1;
                        ofs.i8 = numVar - 1;

                        varIdx = 0;
                        loop(numVar)
                        {
                           faData <= pluginSharedMissing.getArrayParamVariationPtr(paramIdx, varIdx);
                           arrayIdx = 0;
                           loop(arraySz)
                           {
                              f = mathClampf(faData.get(arrayIdx++), -1.0f, 1.0f);
                              ofs.i16 = (f < 0.0f) ? (f * 32768.0f) : (f * 32767.0f);
                           }
                           // Next variation
                           varIdx++;
                        }
                     }
                     // else: not an array param

                     // Next param
                     paramIdx++;
                  }
               }
            }
            else
            {
               // Plugin id (no plugin)
               Utils.WriteString(ofs, null);
            }
         }

         // Pre-Filter
         ofs.i8 = s.getEnableVoicePluginPreFilter(pluginIdx);

         // Enable (v2+)
         ofs.i8 = s.getEnableVoicePlugin(pluginIdx);

         // Level (v4+)
         ofs.f32 = s.getVoicePluginLevel(pluginIdx);

         // Destination (v7+)
         //  (todo) standalone player
         ofs.i8 = s.getVoicePluginDst(pluginIdx);

         // Pan (v4+)
         ofs.f32 = s.getVoicePluginPan(pluginIdx);

         // Invert Phase (v5+)
         ofs.i8 = s.getEnableVoicePluginInvertPhase(pluginIdx);

         // Next plugin slot
         pluginIdx++;
      }

      // Alg (v3+)
      ofs.i8 = s.voicePluginAlg;

      // Alg Filter Pos (v3+)
      ofs.i8 = s.voicePluginAlgFilterPos;

      // Alg Outer (v3+)
      ofs.i8 = s.voicePluginAlgOuter;
   }

   // <save.png>
   protected method exportSamplePluginsSYN(Stream ofs, StSample s) {

      int pluginIdx = 0;
      loop(STSAMPLE_NUM_PLUGINS/*4*/)
      {
         // Enable
         boolean bEnable = s.getEnableVoicePlugin(pluginIdx);

         StPluginShared pluginShared <= s.getVoicePluginShared(pluginIdx);
         if( (null != pluginShared) && bEnable )
         {
            // Ver / enable flag
            ofs.i8 = 1;

            StPluginInfo pluginInfo <= pluginShared.info;

            Global.Debug("Sample::exportSamplePlugins: pluginIdx="+pluginIdx+" pluginId=\""+pluginInfo.id+"\" #params="+pluginInfo.numParams+" preFilter="+s.getEnableVoicePluginPreFilter(pluginIdx)+" invPhase="+s.getEnableVoicePluginInvertPhase(pluginIdx)+" level="+s.getVoicePluginLevel(pluginIdx)+" pan="+s.getVoicePluginPan(pluginIdx));

            // Plugin id
            Utils.WriteString(ofs, pluginInfo.id);

            // Num params
            ofs.i16 = pluginInfo.numParams;

            // Param values
            int paramIdx = 0;
            loop(pluginInfo.numParams)
            {
               ofs.f32 = pluginShared.getParamValue(paramIdx++);
            }

            // Pre-Filter flag
            ofs.i8 = s.getEnableVoicePluginPreFilter(pluginIdx);

            // Level (-f..+f) + invert phase
            ofs.f32 =
               s.getEnableVoicePluginInvertPhase(pluginIdx)
               ? -s.getVoicePluginLevel(pluginIdx)
               :  s.getVoicePluginLevel(pluginIdx)
               ;

            // Pan (-1..1)
            ofs.i8 = int(s.getVoicePluginPan(pluginIdx) * 127.0);
         }
         else
         {
            // Ver / enable flag
            ofs.i8 = 0;
         }

         // Next plugin slot
         pluginIdx++;
      }
   }

   // <save.png>
   protected method saveStateSampleTuning(Stream ofs, StSample s, boolean _bEditor) {
      // (todo) export frequency arrays to standalone Synergy Replay
      if(_bEditor)
      {
         // Ver
         if(_bEditor)
            ofs.i16 = 1;

         // Num tables
         int numTables = 0;
         int tblIdx = 0;
         loop(STSAMPLE_MAX_TUNING_TABLES)
         {
            if(null != s.getTuningTable(tblIdx++))
               numTables = tblIdx;
         }
         ofs.i8 = numTables;

         // Default table
         ofs.i8 = s.defaultTuningTableIdx;

         tblIdx = 0;
         loop(numTables)
         {
            FloatArray faFreq <= s.getTuningTable(tblIdx);
            if(null != faFreq)
            {
               // Default flag (0=use custom freq table)
               ofs.i8 = 0;

               // Frequency table (128 MIDI notes)
               Utils.WriteFloatArray(ofs, faFreq);
            }
            else
            {
               // Default flag (1=use parent freq table)
               ofs.i8 = 1;
            }

            if(_bEditor)
            {
               SampleTuningTable meta <= s.getTuningTableMetaData(tblIdx);
               if(null != meta)
               {
                  // Default flag (1=use custom table)
                  //  (note) _should_ always be the same as the frequency table default flag
                  ofs.i8 = 0;

                  meta.saveState(ofs);
               }
               else
               {
                  // Default flag (1=use parent freq table)
                  //  (note) _should_ always be the same as the frequency table default flag
                  ofs.i8 = 1;
               }
            }

            // Next tuning table
            tblIdx++;
         }
      }
   }

   // <save.png>
   protected method saveStateSample(Stream ofs, StSample s, boolean _bEditor) {
      StRange *range;
      StADSR *adsr;
      StLFO *lfo;

      ofs.i16 = 82; // Ver

      // Play Mode (v28+)
      ofs.i8 = s.playMode;

      // Sample Rate Ratio (v21+)
      ofs.f32 = s.sampleRateRatio;

      // Name (v39+)
      Utils.WriteString(ofs, s.name);

      // Mutex Group
      StSampleMutexGroup mgrp <= s.mutexGroup;
      if(null != mgrp)
      {
         ofs.i8 = sample_bank.getMutexGroupIndexByObject(mgrp);
      }
      else
      {
         ofs.i8 = -1;
      }

      // Auto-select (v75+)
      if(_bEditor)
      {
         ofs.i8 = s.uiGetEnableAutoSelect();
      }

      // Key Range
      range <= s.keyRange;
      if(null != range)
      {
         if(_bEditor)
            saveStateSampleRange(ofs, range);
         else
            exportSampleRangeSYNKey(ofs, range);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused/default
         else
            ofs.i8 = 0;
      }

      // Velocity Range
      range <= s.velRange;
      if(null != range)
      {
         if(_bEditor)
            saveStateSampleRange(ofs, range);
         else
            exportSampleRangeSYNVelMod(ofs, range);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused/default
         else
            ofs.i8 = 0;
      }

      // Mod Range
      range <= s.modRange;
      if(null != range)
      {
         if(_bEditor)
            saveStateSampleRange(ofs, range);
         else
            exportSampleRangeSYNVelMod(ofs, range);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused/default
         else
            ofs.i8 = 0;
      }

      // Freq ADSR
      adsr <= s.freqADSR;
      if(null != adsr)
      {
         saveStateSampleADSR(ofs, adsr, _bEditor);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused/default
         else
            ofs.i8 = 0;
      }

      // Volume ADSR
      adsr <= s.volADSR;
      if(null != adsr)
      {
         saveStateSampleADSR(ofs, adsr, _bEditor);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused/default
         else
            ofs.i8 = 0;
      }

      // Pan ADSR
      adsr <= s.panADSR;
      if(null != adsr)
      {
         saveStateSampleADSR(ofs, adsr, _bEditor);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused/default
         else
            ofs.i8 = 0;
      }

      // Aux ADSR (v4+)
      adsr <= s.auxADSR;
      if(null != adsr)
      {
         saveStateSampleADSR(ofs, adsr, _bEditor);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused/default
         else
            ofs.i8 = 0;
      }

      // Freq LFO
      lfo <= s.freqLFO;
      if(null != lfo)
      {
         if(_bEditor)
            saveStateSampleLFO(ofs, lfo);
         else
            exportSampleLFOSYN(ofs, lfo);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused
         else
            ofs.i8 = 0;
      }

      // Volume LFO
      lfo <= s.volLFO;
      if(null != lfo)
      {
         if(_bEditor)
            saveStateSampleLFO(ofs, lfo);
         else
            exportSampleLFOSYN(ofs, lfo);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused
         else
            ofs.i8 = 0;
      }

      // Pan LFO
      lfo <= s.panLFO;
      if(null != lfo)
      {
         if(_bEditor)
            saveStateSampleLFO(ofs, lfo);
         else
            exportSampleLFOSYN(ofs, lfo);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused
         else
            ofs.i8 = 0;
      }

      // Aux LFO (v4+)
      lfo <= s.auxLFO;
      if(null != lfo)
      {
         if(_bEditor)
            saveStateSampleLFO(ofs, lfo);
         else
            exportSampleLFOSYN(ofs, lfo);
      }
      else
      {
         if(_bEditor)
            ofs.i16 = 0;  // ver = 0 => unused
         else
            ofs.i8 = 0;
      }

      // ModSeq (v22+)
      int mseqIdx = 0;
      loop(STSAMPLE_NUM_MODSEQ)
      {
         int numModSeqPatches = s.findLastUsedModSeqPatch(mseqIdx) + 1;
         ofs.i8 = numModSeqPatches;   // v48+

         int modSeqPatchIdx = 0;
         loop(numModSeqPatches)
         {
            StModSeq mseq <= s.getModSeqByIndexAndPatch(mseqIdx, modSeqPatchIdx);
            if(null != mseq)
            {
               if(_bEditor)
                  saveStateSampleModSeq(ofs, mseq);
               else
                  exportSampleModSeqSYN(ofs, mseq);
            }
            else
            {
               if(_bEditor)
                  ofs.i16 = 0;  // ver = 0 => unused
               else
                  ofs.i8 = 0;
            }
            modSeqPatchIdx++;
         }

         // Default modseq patch (v48+)
         ofs.i8 = s.getDefaultModSeqPatch(mseqIdx);

         // Glide modseq retrig (v41+)
         ofs.i8 = s.getEnableGlideRetrigModSeq(mseqIdx);

         mseqIdx++;
      }

      // Sample Loops
      IntArray loops <= s.sampleLoops;
      if(null != loops)
      {
         ofs.i32 = loops.numElements;
         int idx = 0;
         loop(loops.numElements)
         {
            ofs.i32 = loops.get(idx++);
         }
      }
      else
      {
         ofs.i32 = 0;  // No Loops
      }

      // Loop Fade #frames (v74+)
      ofs.i16 = s.startEndFadeNumFrames;

      // Mod matrix (v15+)
      int mmIdx = 0;
      if(_bEditor)
      {
         // Keyboard Center (v76+)
         ofs.f32 = s.getMMKeyboardCenter();

         // Keyboard Min (v77+)
         ofs.f32 = s.getMMKeyboardMin();

         // Keyboard Max (v77+)
         ofs.f32 = s.getMMKeyboardMax();

         // ModMatrix variations (v81+)
         ofs.i8  = s.mmVarGetEnable();                  // v81+
         ofs.i8  = s.mmVarGetNum();                     // v81+
         ofs.i8  = s.mmVarGetEnableSmooth();            // v81+
         ofs.i8  = s.mmVarGetEditIdx();                 // v81+
         ofs.i8  = s.mmVarGetEnableForceEditIdx();      // v81+
         Utils.WriteFloatArray(ofs, s.mmVarGetData());  // v81+   (16 variations*16 mm entries in v81)

         // Save editor state (all entries)
         loop(STSAMPLE_NUM_MODMATRIX_ENTRIES/*16*/)
         {
            saveStateSampleMM(ofs, s, mmIdx++, true/*bEditor*/);
         }
      }
      else
      {
         // Standalone replay

         // Keyboard Center (v76+)
         ofs.i8 = mathClampi(s.getMMKeyboardCenter()*2 + 0.5, 0, 255);

         // Keyboard Min (v77+)
         ofs.i8 = mathClampi(s.getMMKeyboardMin()*2 + 0.5, 0, 255);

         // Keyboard Max (v77+)
         ofs.i8 = mathClampi(s.getMMKeyboardMax()*2 + 0.5, 0, 255);

         //  - save 16bit modmatrix mask (one bit per entry. set=enable, cleared=disabled)
         short mmMask = 0;
         byte mmNumUsed = 0;
         loop(STSAMPLE_NUM_MODMATRIX_ENTRIES/*16*/)
         {
            if(s.getMMEnable(mmIdx))
            {
               mmMask |= 1 << mmIdx;
               mmNumUsed = mmIdx + 1;
            }
            mmIdx++;
         }
         ofs.i16 = mmMask;
         if(0 != mmMask)
         {
            mmIdx = 0;
            loop(STSAMPLE_NUM_MODMATRIX_ENTRIES/*16*/)
            {
               if(mmMask & (1 << mmIdx))
               {
                  saveStateSampleMM(ofs, s, mmIdx, false/*bEditor*/);
               }
               mmIdx++;
            }

            // ModMatrix variations (v81+)
            if(s.mmVarGetEnable())
            {
               // (note) a forced variation is merged with the base mod matrix in saveStateSampleMM()
               if(!s.mmVarGetEnableForceEditIdx())
               {
                  //  76543210
                  //  Sxxnnnnn
                  int mmVarNumAndFlags = s.mmVarGetNum();  // 5 bit (1..16)
                  mmVarNumAndFlags |=  (s.mmVarGetEnableSmooth() << 7);
                  ofs.i8 = mmVarNumAndFlags;
                  mmVarNumAndFlags &= 31;
                  FloatArray mmVarData <= s.mmVarGetData();
                  for(int mmVarIdx = 0; mmVarIdx < mmVarNumAndFlags; mmVarIdx++)
                  {
                     for(mmIdx = 0; mmIdx < mmNumUsed; mmIdx++)
                     {
                        ofs.f32 = mmVarData.get(mmVarIdx * STSAMPLE_NUM_MODMATRIX_ENTRIES + mmIdx);
                     }
                  }
               }
               else
               {
                  ofs.i8 = 0;  // numVar=0
               }
            }
            else
            {
               ofs.i8 = 0;  // numVar=0
            }
         }
      } // if _bEditor

      if(_bEditor)
      {
         // Sync first loop index
         ofs.i8 = s.uiGetEnableSyncFirstLoopIndex();
      }

      // First Loop Index
      ofs.i8 = s.firstLoopIndex;

      // Note-Off loop Index
      ofs.i8 = s.noteOffLoopIndex;

      // EnableNoteOffLoopImmediately
      ofs.i8 = s.enableNoteOffLoopImmediately;

      // EnableJumpToLoopImmediately (v25+)
      ofs.i8 = s.enableJumpToLoopImmediately;

      if(_bEditor)
      {
         // Offset (usually 0)
         ofs.i32 = s.offset;

         // Len (usually 0)
         ofs.i32 = s.len;
      }

      // Max Voices
      if(_bEditor)
      {
         ofs.i16 = s.maxVoices;
      }
      else
      {
         ofs.i8 = s.maxVoices - 1;
      }

      // Volume
      ofs.f32 = s.volume;

      // Volume LFO Amt (v19+)
      ofs.f32 = s.volLFOAmt;

      // Volume Velocity Amount
      ofs.f32 = s.volumeVelocityAmount;

      // Sample Offset Velocity Amount
      ofs.f32 = s.sampleOffsetVelocityAmount;

      // Invert Sample Offset Velocity Amount (v3+)
      ofs.i8 = s.enableInvertSampleOffsetVelocityAmount;

      // Sample Offset Randomization Amount (v2+)
      ofs.f32 = s.sampleOffsetRandAmount;

      // Relative Sample Offset (v14+)
      ofs.f32 = s.sampleOffsetRel;

      // Pan
      ofs.f32 = s.pan;

      // Pan Env Amt (v16+)
      ofs.f32 = s.panEnvAmt;

      // Pan LFO Amt (v16+)
      ofs.f32 = s.panLFOAmt;

      // Transpose Oct
      ofs.i8 = s.uiTransposeOct;

      // Transpose Semi
      ofs.i8 = s.uiTransposeSemi;

      // Transpose Cents
      ofs.f32 = s.uiTransposeCents;

      // Beat Frequency (v8+)
      ofs.f32 = s.beatFrequency;

      // Freq Env Amt (v16+)
      ofs.f32 = s.freqEnvAmt;

      // Freq LFO Amt (v16+)
      ofs.f32 = s.freqLFOAmt;

      // Delay (ms)
      ofs.f32 = s.delay;

      // Delay (ms) (v24+)
      ofs.f32 = s.delayMultiplier;

      // Enable Timestretch
      ofs.i8 = s.enableTimestretch;

      if(_bEditor || s.enableTimestretch)
      {
         if(_bEditor)/// || s.enableTimestretchAdditive)
         {
            // Enable Timestretch Additive (v49+)
            ofs.i8 = s.enableTimestretchAdditive;

            // Timestretch Additive Cycle X-Fade (v80+)
            ofs.f32 = s.timestretchAdditiveXFade;

            // Additive Partial CycleLen Reset (v68+)
            ofs.f32 = s.partialCycleLenReset;

            // Additive Partial Phase 0 (v69+)
            ofs.i8 = s.enablePartialPhase0;

            // Timestretch Additive Num Partials (v60+)
            // // ofs.i8 = s.numPartials - 1;  // pre v67
            ofs.f32 = s.numPartials;  // v67+

            // Additive stereo spread (v66+)
            ofs.f32 = s.additiveStereoSpread;

            // Additive oscillator settings (v62+)
            //  (note) multiple configs added in v64
            ofs.f32 = s.additiveEditCfg;             // v64+
            ofs.i8  = s.enableForceAdditiveEditCfg;  // v64+
            for(int cfgIdx = 0; cfgIdx < STSAMPLE_ADDITIVE_CFG_NUM/*8*/; cfgIdx++)
            {
               ofs.i8 = s.getAdditiveCfgValid(cfgIdx);  // v64+

               ofs.i8 = s.getAdditiveNormalize(cfgIdx);  // v65+

               ofs.i8 = s.getAdditiveRateReduction    (cfgIdx);  // v64+
               ofs.i8 = s.getAdditiveRateReductionMask(cfgIdx);  // v64+

               ofs.f32 = s.getAdditiveBitReductionPreAmp(cfgIdx);  // v64+
               ofs.i8  = s.getAdditiveBitReduction      (cfgIdx);  // v64+
               ofs.i16 = s.getAdditiveBitReductionMask  (cfgIdx);  // v64+

               int oscIdx = 0;
               loop(STSAMPLE_ADDITIVE_OSC_NUM)
               {
                  ofs.f32 = s.getAdditiveLevel (cfgIdx, oscIdx);
                  ofs.f32 = s.getAdditivePhase (cfgIdx, oscIdx);
                  ofs.f32 = s.getAdditiveExpA  (cfgIdx, oscIdx);
                  ofs.f32 = s.getAdditiveFilter(cfgIdx, oscIdx);  // v63+
                  ofs.f32 = s.getAdditiveExpL  (cfgIdx, oscIdx);
                  oscIdx++;
               }
            }
         } // bEditor || s.enableTimestretchAdditive

         // Enable Timestretch XFade
         ofs.i8 = s.enableTimestretchXFade;

         // Timestretch
         ofs.f32 = s.timestretch;

         // Timestretch Granularity (was i16 before v17)
         ofs.f32 = s.timestretchGranularity;

         // Timestretch Granularity Amount
         ofs.f32 = s.timestretchGranularityAmount;

         // Enable Static CycleLen
         ofs.i8 = s.enableStaticCyclelen;

         // Enable Absolute Timestretch
         ofs.i8 = s.enableAbsoluteTimestretch;

         // Timestretch Interpolation Type
         ofs.i8 = s.timestretchInterpolType;

         // Timestretch Grain Window Type
         ofs.i8 = s.timestretchGrainWindowType;

         // Timestretch Phase Bend (v18+)
         ofs.f32 = s.timestretchBend;

         // Timestretch Start Phase Randomization Amount
         ofs.f32 = s.timestretchStartPhaseRandAmount;

         // Timestretch 2D Width (v40+)
         ofs.i8 = s.timestretch2DWidth;

         // Timestretch 2D Height (v40+)
         ofs.i8 = s.timestretch2DHeight;

      } //_bEditor || s.enableTimestretch

      // TimedLoop Enable
      ofs.i8 = s.enableTimedLoop;

      // TimedLoop Fade Enable
      ofs.i8 = s.enableTimedLoopFade;

      // TimedLoop Base
      ofs.f32 = s.timedLoopBase;

      // TimedLoop EnableOneShotLoopStep
      ofs.i8 = s.enableOneShotLoopStep;

      // Volume Ramp Up
      ofs.f32 = s.volumeRampStepsMillisecIn;

      // Volume Ramp Down
      ofs.f32 = s.volumeRampStepsMillisecOut;

      // EnableFreezeSampleOffWhenQuiet
      ofs.i8 = s.enableFreezeSampleOffWhenQuiet;

      // EnableModShiftOrig
      ofs.i8 = s.enableModShiftOrig;

      // EnableSampleOffNoteOn
      ofs.i8 = s.enableSampleOffNoteOn;

      // Enable
      ofs.i8 = s.enabled;

      // Interpolation Type
      ofs.i8 = s.interpolType;

      // Interpolation Order (v71+)
      ofs.i8 = s.interpolOrder;

      // AI Num Poles (v71+)
      ofs.i8 = s.aiNumPoles;

      // AI Exp Up (v71+)
      ofs.f32 = s.aiExpUp;

      // AI Exp Down (v71+)
      ofs.f32 = s.aiExpDown;

      // AI Q (v72+)
      ofs.f32 = s.aiQ;

      // AI Linear Num Octaves (v73+)
      ofs.f32 = s.aiLinOct;

      // AI Linear Max Cutoff (v73+)
      ofs.f32 = s.aiLinMax;

      // // 8bit mode (< v55+)
      // // ofs.i8 = s.enable8bit;

      // Bit reduction pre amp (v56+)
      ofs.f32  = s.bitReductionPreAmp;

      // Bit reduction (v55+)
      ofs.i8  = s.bitReduction;

      // Bit reduction mask (v55+)
      ofs.i16 = s.bitReductionMask;

      // Rate reduction (v54+)
      ofs.i8 = s.rateReduction;

      // Rate reduction mask (v54+)
      ofs.i8 = s.rateReductionMask;

      // Lerp Freq (v42+)
      ofs.i8 = s.enableLerpFreq;

      // Lerp Vol (v42+)
      ofs.i8 = s.enableLerpVol;

      // Play first iteration from sample start to loop end (v20+)
      ofs.i8 = s.enableFromStart;

      // Alt Enable
      ofs.i8 = s.enableAlt;

      boolean bSaveFltSYN;
      if(_bEditor)
      {
         // Filter Enable (v36+)
         ofs.i8 = s.enableFilter;

         // Filter Type (v5+)
         ofs.i8 = s.filterType;

         // Filter CutOff (v5+)
         ofs.f32 = s.filterCutOff;

         // Filter Stereo Panning (v5+)
         ofs.f32 = s.filterPan;

         // Dual Filter Offset (v5+)
         ofs.f32 = s.filterOffset;

         // Filter Bandwidth (v7+)
         ofs.f32 = s.filterEQGain;

         // Filter Resonance (v5+)
         ofs.f32 = s.filterResonance;

         // Filter Aux Env Amount (v5+)
         ofs.f32 = s.filterAuxEnvAmount;

         // Filter Aux Env Velocity Amount (v5+)
         ofs.f32 = s.filterAuxEnvVelocityAmount;

         // Filter Aux LFO Amount (v6+)
         ofs.f32 = s.filterAuxLFOAmount;

         // Filter Keyboard Amount (v6+)
         ofs.f32 = s.filterKeyboardAmount;
      }
      else
      {
         // Filter Type/Enable (v5+)
         ofs.i8 = s.enableFilter ? s.filterType : 0;

         if(s.enableFilter && (STSAMPLE_FLT_TYPE_NONE != s.filterType))
         {
            // Filter CutOff (v5+)
            ofs.i8 = s.filterCutOff * 127;

            // Filter Stereo Panning (v5+)
            ofs.i8 = s.filterPan * 127;

            // Dual Filter Offset (v5+)
            ofs.i8 = s.filterOffset * 127;

            // Filter Bandwidth (v7+)
            ofs.f32 = s.filterEQGain;

            // Filter Resonance (v5+)
            ofs.i8 = s.filterResonance * 255;

            // Filter Aux Env Amount (v5+)
            ofs.i8 = s.filterAuxEnvAmount * 127;

            // Filter Aux Env Velocity Amount (v5+)
            ofs.i8 = s.filterAuxEnvVelocityAmount * 63;

            // Filter Aux LFO Amount (v6+)
            ofs.i8 = s.filterAuxLFOAmount * 127;

            // Filter Keyboard Amount (v6+)
            ofs.i8 = s.filterKeyboardAmount * 127;
         }
      }

      // Glide type (v9+)
      ofs.i8 = s.glideType;

      // Glide speed time up (v9+)
      ofs.f32 = s.glideSpeedTimeUp;

      // Glide speed time down (v9+)
      ofs.f32 = s.glideSpeedTimeDown;

      // Glide speed freq up (v9+)
      ofs.f32 = s.glideSpeedFreqUp;

      // Glide speed freq down (v9+)
      ofs.f32 = s.glideSpeedFreqDown;

      // Glide release enable (v10+)
      ofs.i8 = s.enableGlideRelease;

      // Glide max note distance (v10+)
      ofs.i8 = s.glideMaxNoteDist;

      // Glide glissando enable (v11+)
      ofs.i8 = s.enableGlideGlissando;

      // Glide min time threshold (v12+)
      ofs.i16 = s.glideMinTime;

      // Glide max time threshold (v57+)
      ofs.i16 = s.glideMaxTime;

      if(_bEditor)
      {
         // Glide retrig sample (v13+)
         ofs.i8 = s.enableGlideRetrigSample;

         // Glide retrig freq env (v13+)
         ofs.i8 = s.enableGlideRetrigEnvFreq;

         // Glide retrig vol env (v13+)
         ofs.i8 = s.enableGlideRetrigEnvVol;

         // Glide retrig pan env (v13+)
         ofs.i8 = s.enableGlideRetrigEnvPan;

         // Glide retrig aux env (v13+)
         ofs.i8 = s.enableGlideRetrigEnvAux;

         // Glide retrig freq LFO (v13+)
         ofs.i8 = s.enableGlideRetrigLFOFreq;

         // Glide retrig vol LFO (v13+)
         ofs.i8 = s.enableGlideRetrigLFOVol;

         // Glide retrig pan LFO (v13+)
         ofs.i8 = s.enableGlideRetrigLFOPan;

         // Glide retrig aux LFO (v13+)
         ofs.i8 = s.enableGlideRetrigLFOAux;
      }
      else
      {
         int glideFXFlags = 0;
         // Glide retrig sample (v13+)
         if(s.enableGlideRetrigSample)
            glideFXFlags |= (1 << 0);

         // Glide retrig freq env (v13+)
         if(s.enableGlideRetrigEnvFreq)
            glideFXFlags |= (1 << 1);

         // Glide retrig vol env (v13+)
         if(s.enableGlideRetrigEnvVol)
            glideFXFlags |= (1 << 2);

         // Glide retrig pan env (v13+)
         if(s.enableGlideRetrigEnvPan)
            glideFXFlags |= (1 << 3);

         // Glide retrig aux env (v13+)
         if(s.enableGlideRetrigEnvAux)
            glideFXFlags |= (1 << 4);

         // Glide retrig freq LFO (v13+)
         if(s.enableGlideRetrigLFOFreq)
            glideFXFlags |= (1 << 5);

         // Glide retrig vol LFO (v13+)
         if(s.enableGlideRetrigLFOVol)
            glideFXFlags |= (1 << 6);

         // Glide retrig pan LFO (v13+)
         if(s.enableGlideRetrigLFOPan)
            glideFXFlags |= (1 << 7);

         // Glide retrig aux LFO (v13+)
         if(s.enableGlideRetrigLFOAux)
            glideFXFlags |= (1 << 8);

         // Enable FX
         if(s.enableFX)
            glideFXFlags |= (1 << 9);

         ofs.i16 = glideFXFlags;
      }

      if(_bEditor)
      {
         // LiveRec Enable (v26+)
         ofs.i8 = s.liveRecEnable;

         // LiveRec Input (v26+)
         ofs.i8 = s.liveRecInput;

         // LiveRec Stereo (v26+)
         ofs.i8 = s.liveRecStereo;

         // LiveRec Monitor (v53+)
         ofs.i8 = s.liveRecMonitor;

         // LiveRec Input Pan (v78+)
         ofs.f32 = s.liveRecInputPan;

         // LiveRec LoopIdx (v26+)
         ofs.i16 = s.liveRecLoopIdx;

         // LiveRec Copy (v31+)
         ofs.i8 = s.liveRecCopy;

         // LiveRec Copy (v44+)
         ofs.i8 = s.liveRecClear;

         // LiveRec DblBuf Mode (v26+)
         ofs.i8 = s.liveRecDoubleBufferMode;

         // LiveRec DblBuf XFade (v27+)
         ofs.i8 = s.liveRecDoubleBufferXFade;

         // LiveRec Osc Mode (v29+)
         ofs.i8 = s.liveRecOscMode;

         // LiveRec Osc SingleCycle (v43+)
         ofs.i8 = s.liveRecOscSingleCycle;

         // LiveRec Osc Mode (v30+)
         ofs.f32 = s.liveRecOscTune;

         // LiveRec Osc Mode (v50+)
         ofs.f32 = s.liveRecOscFadeAmt;

         // LiveRec Skip Input Num Frames (v70+)
         ofs.i16 = s.liveRecSkipInputNumFrames;

         // LiveRec Osc Pre Filter (v52+)
         ofs.f32 = s.liveRecOscPreFilter;

         // LiveRec Osc Resampling (v51+)
         ofs.i8 = s.liveRecOscResample;

         // LiveRec Osc Sustain Mode (v32+)
         ofs.i8 = s.liveRecOscSustain;

         // LiveRec Mode (v26+)
         ofs.i8 = s.liveRecMode;

         // LiveRec Threshold (v26+)
         ofs.f32 = s.liveRecThresholdOn;

         // Sum Input (v46+)
         ofs.i8  = s.enableSumInput;
         ofs.f32 = s.sumInputXFade;
      }

      if(_bEditor)
      {
         // Enable FX (v34+)
         ofs.i8 = s.enableFX;
      }
      // else: saved in glideFXFlags (bit 9)

      // Voice Bus (v37+)
      ofs.i8 = s.voiceBus;

      if(_bEditor)
      {
         // SampleView (v38+)
         local Double svZoom <= s.uiSVZoom;
         ofs.serialize(svZoom, false/*bTypeInfo*/);
         ofs.f32 = s.uiSVOffset;
         ofs.i8  = s.uiSVZoomYIdx;

         // AuxToWav (V47+)
         ofs.i8 = s.uiEnableAuxToWav;
      }

      // Voice Calibration tables (v58+)
      int vcalLaneIdx = 0;
      loop(6)
      {
         ofs.i8  = s.getVoiceCalibrationModulo(vcalLaneIdx);
         ofs.f32 = s.getVoiceCalibrationAmount(vcalLaneIdx);  // v59+
         ofs.i8  = s.getVoiceCalibrationEnable(vcalLaneIdx);  // v59+
         int vcalVoiceIdx = 0;
         loop(8)
            ofs.f32 = s.getVoiceCalibrationValue(vcalLaneIdx, vcalVoiceIdx++);
         vcalLaneIdx++;
      }

      if(_bEditor)
      {
         // Voice plugins (v33+)
         saveStateSamplePlugins(ofs, s);
      }
      else
      {
         // Voice plugins
         exportSamplePluginsSYN(ofs, s);
      }

      // Tuning tables (v79+)
      saveStateSampleTuning(ofs, s, _bEditor);
   }

   // <save.png>
   protected method saveStateSampleBankTuning(Stream ofs, boolean _bEditor) {
      // (todo) export frequency arrays to standalone Synergy Replay
      if(_bEditor)
      {
         // Ver
         if(_bEditor)
            ofs.i16 = 1;

         // Num tables
         int numTables = 0;
         int tblIdx = 0;
         loop(STSAMPLE_MAX_TUNING_TABLES)
         {
            if(null != sample_bank.getTuningTable(tblIdx++))
               numTables = tblIdx;
         }
         ofs.i8 = numTables;

         // Default table
         ofs.i8 = sample_bank.defaultTuningTableIdx;

         tblIdx = 0;
         loop(numTables)
         {
            FloatArray faFreq <= sample_bank.getTuningTable(tblIdx);
            if(null != faFreq)
            {
               // Default flag (0=use custom freq table)
               ofs.i8 = 0;

               // Frequency table (128 MIDI notes)
               Utils.WriteFloatArray(ofs, faFreq);
            }
            else
            {
               // Default flag (1=use parent freq table)
               ofs.i8 = 1;
            }

            if(_bEditor)
            {
               SampleTuningTable meta <= sample_bank.getTuningTableMetaData(tblIdx);
               if(null != meta)
               {
                  // Default flag (1=use custom table)
                  //  (note) _should_ always be the same as the frequency table default flag
                  ofs.i8 = 0;

                  meta.saveState(ofs);
               }
               else
               {
                  // Default flag (1=use parent freq table)
                  //  (note) _should_ always be the same as the frequency table default flag
                  ofs.i8 = 1;
               }
            }

            // Next tuning table
            tblIdx++;
         }
      }
   }

   // <save.png>
   protected method saveStateInt(Stream ofs, boolean _bEditor) {

      if(_bEditor)
         ofs.i16 = 18; // ver

      // Program id
      ofs.i8 = prg_id;

      if(_bEditor)
      {
         // Unique ID (v7+)
         ofs.i16 = unique_id;

         // Sample Type
         ofs.i8 = sample_type;

         // Grid Size
         ofs.i8 = grid_size;

         // Sustain hint (v17+)
         ofs.i8 = b_sustain;
      }

      // Max voices
      if(_bEditor)
         ofs.i16 = sample_bank.maxVoices;
      else
         ofs.i8 = sample_bank.maxVoices - 1;

      // Enable Realloc mono-mode (v16+)
      ofs.i8 = sample_bank.enableRealloc;

      // Enable Unique Notes (v2+)
      ofs.i8 = sample_bank.enableUniqueNotes;

      // Freeze PerfCtl at note-off (v14+)
      ofs.i8 = sample_bank.enablePerfCtlFreezeNoteOff;

      if(_bEditor)
      {
         // Solo zone idx
         ofs.i16 = solo_zone_idx;
      }

      // Transpose
      ofs.i8 = transpose_oct;
      ofs.i8 = transpose_semi;
      if(_bEditor)
         ofs.f32 = transpose_cents;
      else
         ofs.i8 = transpose_cents;

      // Pitchbend range
      if(_bEditor)
      {
         ofs.f32 = pitchbend_up;
         ofs.f32 = pitchbend_down;
      }
      else
      {
         ofs.i8 = pitchbend_up;
         ofs.i8 = pitchbend_down;
      }

      // Volume
      ofs.f32 = sample_bank.volume;

      // Pan
      ofs.f32 = sample_bank.pan;

      // Sampleoff rand
      ofs.f32 = sample_bank.sampleOffsetRandAmount;

      // Volume rand
      ofs.f32 = sample_bank.volumeRandAmount;

      // Pan rand
      ofs.f32 = sample_bank.panRandAmount;

      // Freq rand
      ofs.f32 = sample_bank.freqRandAmount;

      // Mod src (v3+)
      ofs.i8 = mod_src;

      // Mod src Note On (v4+)
      ofs.i8 = b_mod_src_noteon;

      if(_bEditor)
      {
         // Partial window bits (v8+)
         ofs.i8 = partial_window_bits;

         // Partial cosine window (v10+)
         ofs.i8 = b_partial_cos_win;

         // Partial true bin frequency (v9+)
         ofs.i8 = b_partial_true_freq;

         // Partial speed exponent (v11+)
         ofs.f32 = partial_speed_exp;

         // Partial bin exponent (v11+)
         ofs.f32 = partial_bin_exp;

         // Partial magnitude exponent (v12+)
         ofs.f32 = partial_mag_exp;

         // Partial magnitude bin exponent (v12+)
         ofs.f32 = partial_mag_bin_exp;
      }

      // Tuning tables (v15+)
      saveStateSampleBankTuning(ofs, _bEditor);

      // Zones
      if(_bEditor)
         ofs.i16 = sample_bank.numSamples;
      else
         ofs.i8 = getNumZonesWithValidKeyAndVelocityRanges();
      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         if(_bEditor || ZoneHasValidKeyAndVelocityRanges(s))
         {
            saveStateSample(ofs, s, _bEditor);
         }

         // Next zone
         s <= s.next;
      }

      if(_bEditor)
      {
         // Synth patch ("cycle") (v6+)
         cycle_state.saveState(ofs);
      }

      if(_bEditor)
      {
         // Procedural track sequence events (v18+)
         ofs.i16 = proc_seq_frames.numElements;
         MIDIPipeFrame *fr;
         foreach fr in proc_seq_frames
            fr.saveState(ofs);
      }
   }

   // <save.png>
   public method saveState(Stream ofs, String _dirName, boolean _bProject) {
      // (note) also update Samples.LoadSampleTagsFromESAHeader() when header format changes

      Global.Debug("Sample::saveState: save sample \""+unique_name+"\" dirName=\""+_dirName+"\" bProject="+_bProject);

      ofs.i8 = 'E';
      ofs.i8 = 'S';
      ofs.i8 = 'A';
      ofs.i8 = '.';

      ofs.i16 = 13; // ver

      // Tags (v9+)
      //  (note) written first so sample cache scan only needs to load the sample header
      SampleCacheEntry.WriteSampleTags(ofs, tags);

      // Procedural waveform flag (v3+)
      ofs.i8 = b_procedural;
      if(b_procedural)
      {
         // Procedural sample, save size only
         ofs.i32 = waveform.numFrames;
         ofs.f32 = waveform.sampleRate;  // v4+

         b_project_waveform_modified = false;
         b_user_waveform_modified = false;
      }
      else
      {
         // Regular sample, save waveform if modified
         if(_bProject && b_project_waveform_modified)
         {
            saveWav(_dirName);
            b_project_waveform_modified = false;
         }
         else if(!_bProject && b_user_waveform_modified)
         {
            saveWav(_dirName);
            b_user_waveform_modified = false;
         }
      }

      // Procedural Source Track Index (v13+)
      ofs.i8 = src_track_idx;

      // Audio-clip flag (v11+)
      ofs.i8 = b_audio_clip;

      // Audio-clip bpm (v12+)
      ofs.f32 = audio_clip_bpm;

      // AuxToWav flag (v5+)
      //  (note) removed in v6 (moved to sample zone)

      if(_bProject)
         b_autoload = false;

      // Sample name
      Utils.WriteString(ofs, unique_name);

      // Description
      Utils.WriteString(ofs, description);

      // Suggested path name
      Utils.WriteString(ofs, suggested_pathname);
      Global.Debug2("Sample::saveState: save sample suggested_pathname=\""+suggested_pathname+"\"");

      // Namespace index (v8+)
      ofs.i8 = namespace_idx;

      // Persistence flag (v10+)
      ofs.i8 = _bProject ? b_persistent : false;

      // Initial performance controller (v7+)
      ofs.i8 = initial_perf_ctl.numElements;
      float perfCtl;
      foreach perfCtl in initial_perf_ctl
         ofs.f32 = perfCtl;

      local Buffer bRaw;
      bRaw.size = 1024*1024*4;
      bRaw.offset = 0;
      saveStateInt(bRaw, true/*bEditor*/);

      // Uncompressed size
      ofs.i32 = bRaw.offset;

      local Buffer bZip;
      bZip.gzip(bRaw, 0/*off*/, bRaw.offset, 9/*level*/);

      // Compressed size
      ofs.i32 = bZip.size;

      // Compressed data
      ofs.writeBuffer(bZip, 0, bZip.size);

      Global.Debug("Sample::saveState: sizeRaw="+bRaw.offset+" sizeZip="+bZip.size+" (ratio="+((float(bZip.size)/bRaw.offset)*100)+"%)");
   }

   // save.png>
   public method saveFile(String _pathName, String _rootPath, boolean _bProject, int _sampleIdx) : boolean {
      // (note) 'sampleIdx' is ignored when bProject=false or Assimil8or YAML export is disabled
      local String dirName;
      local String fileName;
      // // // Utils.SplitPathname(Utils.SubstitutePathVars(_pathName), dirName, fileName);
      // // Utils.SplitPathname(Utils.ToNativePathName(_pathName), dirName, fileName);
      Utils.SplitPathname(_pathName, dirName, fileName);
      Global.Info("Sample::saveFile: dirName=\""+dirName+"\" fileName=\""+fileName+"\"");

      local File f;
      // // local String localPathName <= Utils.SubstitutePathVars(_pathName);
      local String localPathName <= Utils.ToNativePathName(_pathName);
      if(f.openLocal(localPathName, IOS_OUT))
      {
         if(!_bProject)
         {
            local String oldSuggestedPathname = suggested_pathname;
            suggested_pathname = Utils.RemoveDirPrefix(dirName, _rootPath);
            current_project.markAsModified();
            // trace "xxx Sample::saveFile: oldSuggestedPathname=\""+oldSuggestedPathname+"\"";
            // trace "xxx Sample::saveFile: suggested_pathname=\""+suggested_pathname+"\"";
            if(suggested_pathname != oldSuggestedPathname)
               markWaveformAsModified();
         }

         saveState(f, dirName, _bProject);
         f.close();

         // // if( (!_bProject && STConfig.b_write_yml_single) || (_bProject && STConfig.b_write_yml_project) )
         if(_bProject && STConfig.b_write_yml_project)
         {
            // // saveYMLPresetFile(Utils.SubstitutePathVars(dirName), _sampleIdx);
            saveYMLPresetFile(dirName, _sampleIdx);
         }

         return = true;
      }
      else
      {
         return = false;
      }
      return;
   }

   // <save.png>
   protected method saveYMLPresetFile(String _dirName, int _sampleIdx) {

      local Integer ioSampleNr = _sampleIdx + 1;
      local String pathName <= _dirName+"/prst"+ioSampleNr.printf("%03d")+Global.ASSIMIL8OR_FILE_SUFFIX/*.yml*/;

      local String buf;

      buf.append("Preset "+(_sampleIdx+1)+" :\n");
      buf.append("  Name : "+unique_name+"\n");
      int numA8Channels = mathMini(sample_bank.numSamples, 8);
      int a8ChannelIdx = 0;
      StSample s <= sample_bank.firstSample;
      local String wavName <= unique_name+".wav";

      loop(numA8Channels)
      {
         buf.append("  Channel "+(a8ChannelIdx+1)+" :\n");

         float trp = sample_bank.transpose + s.transpose - 24.0;
         buf.append("    Pitch: "+((trp > 0.0)?"+":"")+trp+"\n");
         // LinFM : 4B 1.00
         // ExpFM : 4B 1.00
         buf.append("    PitchCV : 0A 0.50\n");
         // PhaseCV :
         // PMIndexMod : 0C 1.00
         // SampleStartMod : 8A 1.00
         // Attack :
         // AttackFromCurrent : 1
         // Release :
         buf.append("    LoopMode : 1\n");
         buf.append("    LoopLengthIsEnd : 1\n");

         IntArray loops <= s.getSampleLoops();
         if(null != loops)
         {
            int numLoops = loops.numElements / 3;
            if(numLoops > 0)
            {
               int loopIdx = 0;
               float curCV = -5.0;
               float cvStep = 10.0 / numLoops;
               loop(numLoops)
               {
                  int off = loops[loopIdx*3 + 0];
                  int len = loops[loopIdx*3 + 1];

                  buf.append("    Zone "+(loopIdx+1)+" :\n");
                  buf.append("      Sample : "+wavName+"\n");
                  if(s.enableFromStart)
                  {
                     buf.append("      SampleStart : 0\n");
                     buf.append("      SampleEnd : "+(off+len)+"\n");
                  }
                  else
                  {
                     buf.append("      SampleStart : "+off+"\n");
                     buf.append("      SampleEnd : "+(off + len)+"\n");
                  }
                  buf.append("      LoopStart : "+off+"\n");
                  buf.append("      LoopLength : "+len+".0000\n");

                  if(numLoops > 1)
                  {
                     // if(-5.0 != curCV)
                     buf.append("      MinVoltage : "+((curCV >= 0.0) ? "+":"")+curCV+"\n");
                  }

                  // Next loop / a8 zone
                  curCV += cvStep;
                  loopIdx++;
               }
            }
            else
            {
               buf.append("    Zone 1 :\n");
               buf.append("      Sample : "+wavName+"\n");
            }
         }

         // Next zone / a8 channel
         a8ChannelIdx++;
         s <= s.next;
      }

      buf.saveLocal(Utils.ToNativePathName(pathName));
      Global.Debug("wrote Assimil8or preset file \""+pathName+"\"");
   }

   // <save.png>
   public method exportSYNSmpInfo(Stream ofs) {

      int ofsSz = ofs.offset;

      ofs.i16 = 8; // ver

      // .b procedural flag
      ofs.i8 = b_procedural;

      // .l waveform num frames
      ofs.i32 = waveform.numFrames;

      // .b num channels (1=mono, 2=stereo)
      ofs.i8 = waveform.numChannels;

      // .f sample rate
      ofs.f32 = waveform.sampleRate;

      // Sample name (debug helper)
      //  (todo) remove
      Utils.WriteString(ofs, unique_name);

      // Initial performance controller
      //  - ctlMask (set=ctl byte follows, cleared=-1(unused))
      byte perfMask = 0;
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC1_MODWHEEL] >= 0.0f)
         perfMask |= (1 << 0);
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC2_BREATHCTL] >= 0.0f)
         perfMask |= (1 << 1);
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC4_FOOTCTL] >= 0.0f)
         perfMask |= (1 << 2);
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC11_EXPRESSION] >= 0.0f)
         perfMask |= (1 << 3);
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC16_GENERAL_1] >= 0.0f)
         perfMask |= (1 << 4);
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC17_GENERAL_2] >= 0.0f)
         perfMask |= (1 << 5);
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC18_GENERAL_3] >= 0.0f)
         perfMask |= (1 << 6);
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC19_GENERAL_4] >= 0.0f)
         perfMask |= (1 << 7);
      ofs.i8 = perfMask;
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC1_MODWHEEL] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC1_MODWHEEL];
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC2_BREATHCTL] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC2_BREATHCTL];
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC4_FOOTCTL] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC4_FOOTCTL];
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC11_EXPRESSION] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC11_EXPRESSION];
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC16_GENERAL_1] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC16_GENERAL_1];
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC17_GENERAL_2] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC17_GENERAL_2];
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC18_GENERAL_3] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC18_GENERAL_3];
      if(initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC19_GENERAL_4] >= 0.0f)
         ofs.i8 = initial_perf_ctl[STSAMPLEPLAYER_PERFCTL_CC19_GENERAL_4];

      saveStateInt(ofs, false/*bEditor*/);

      ofsSz = ofs.offset - ofsSz;

      trace "[...] exportSynSmpInfo: prg="+prg_id+" name=\""+unique_name+"\" sz="+(int((100*ofsSz)/1024)/100.0)+"k";
   }

   // <save.png>
   public method exportSYNWaveform(Stream ofs) {
      // (note) waveform size is stored in sample header
      FloatArray smpDat <= waveform.sampleData;
      int ioOff = ofs.offset;
      int sz = ioOff;
      smpDat.saveToStreamSigned12FrameEnc(ofs, 0/*num=all*/);
      sz = ofs.offset - sz;
      int srcSz  = (smpDat.numElements*3)/2; // uncompressed data would be stored as signed 12bit integers
      trace "[...] exportSynWaveform: prg="+prg_id+" name=\""+unique_name+"\" ioOff="+ioOff+" srcSz="+(int((100*srcSz)/1024)/100.0)+"k encSz="+(int((100*sz)/1024)/100.0)+"k ("+(int(10000.0*sz/srcSz)/100.0)+"%)";
   }

   // <load.png>
   protected method loadStateSampleRange(Stream ifs, StRange range, short ver) : boolean {

      if(ver >= 1)
      {
         // Lo
         range.lo = ifs.f32;

         // Hi
         range.hi = ifs.f32;

         // Fade-In
         range.fadeIn = ifs.f32;

         // Fade-Out
         range.fadeOut = ifs.f32;

         // Note-On Filter
         range.enableNoteOnFilter = ifs.b8;

         // High Inclusive
         range.enableHighInclusive = ifs.b8;

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleRange: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSampleEnv(Stream ifs, StEnvelope env, short ver) : boolean {

      if(ver >= 1)
      {
         BezierEditState *beState;
         Envelope *beData;

         // Envelope data
         int numDataElements = ifs.i32;
         if(numDataElements > 0)
         {
            beData <= env.data;
            beData.alloc(numDataElements);
            beData.useAll();
            int idx = 0;
            loop(numDataElements)
            {
               beData[idx++] = ifs.f32;
            }
         }

         // BezierEdit state
         short verBezier = ifs.u16;
         if(verBezier > 0)
         {
            beState <= env.metaData;
            beState << ifs;
         }

         // Intensity
         env.intensity = ifs.f32;

         // Timescale (ms)
         env.timescaleMillisec = ifs.f32;

         if(ver >= 2)
         {
            // Exponent (v2+)
            env.exponent = ifs.f32;
         }

         if(ver >= 3)
         {
            // Last loaded preset name (v3+)
            String sPresetName; sPresetName.empty();
            Utils.ReadString(ifs, sPresetName);
            if(!sPresetName.isBlank())
               env.uiPresetName = sPresetName;
            else
               env.uiPresetName = null;
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleEnv: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSampleADSR(Stream ifs, StADSR adsr, short ver) : boolean {

      if(ver >= 1)
      {
         StEnvelope *env;
         short verEnv;

         // Attack envelope
         verEnv = ifs.u16;
         if(verEnv > 0)
         {
            env <= adsr.getOrCreateEnvAttack();
            if(!loadStateSampleEnv(ifs, env, verEnv))
            {
               trace "[---] Sample::loadStateSampleADSR: failed to load attack envelope\n";
               return false;
            }
         }

         // Sustain envelope
         verEnv = ifs.u16;
         if(verEnv > 0)
         {
            env <= adsr.getOrCreateEnvSustain();
            if(!loadStateSampleEnv(ifs, env, verEnv))
            {
               trace "[---] Sample::loadStateSampleADSR: failed to load sustain envelope\n";
               return false;
            }
         }

         // Release envelope
         verEnv = ifs.u16;
         if(verEnv > 0)
         {
            env <= adsr.getOrCreateEnvRelease();
            if(!loadStateSampleEnv(ifs, env, verEnv))
            {
               trace "[---] Sample::loadStateSampleADSR: failed to load release envelope\n";
               return false;
            }
         }

         // Intensity
         adsr.intensity = ifs.f32;

         // Timescale (ms)
         adsr.timescaleMillisec = ifs.f32;

         // Level
         adsr.level = ifs.f32;

         // Stage-Op
         adsr.stageOp = ifs.u8;

         // Sustain loop enable
         adsr.enableSustainLoop = ifs.s8;

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleADSR: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSampleLFO(Stream ifs, StLFO lfo, short ver) : boolean {

      if(ver >= 1)
      {
         // Timebase
         lfo.timebase = ifs.f32;

         // Type
         lfo.type = ifs.u8;

         // Phase
         lfo.phase = ifs.f32;

         // Freq
         lfo.freq = ifs.f32;

         // Pulsewidth
         lfo.pulseWidth = ifs.f32;

         // Delay
         lfo.delay = ifs.f32;

         // Fade-In Time (ms)
         lfo.fadeInTime = ifs.f32;

         // Start level
         lfo.startLevel = ifs.f32;

         // Faded level
         lfo.fadedLevel = ifs.f32;

         if(ver >= 2)
         {
            // Faded speed factor (v2+)
            lfo.fadedSpeedFactor = ifs.f32;
         }

         // DC Offset
         lfo.dcOffset = ifs.f32;

         // Noise Min Amp
         lfo.noiseMinAmp = ifs.f32;

         // Noise Max Amp
         lfo.noiseMaxAmp = ifs.f32;

         // Noise Min Speed
         lfo.noiseMinSpeed = ifs.f32;

         // Noise Max Speed
         lfo.noiseMaxSpeed = ifs.f32;

         // Noise Interpol
         lfo.enableNoiseInterpol = ifs.b8;

         // Mod Delay
         lfo.enableModDelay = ifs.b8;

         // One-Shot
         lfo.enableOneShot = ifs.b8;

         if(ver >= 3)
         {
            // Global (v3+)
            lfo.enableGlobal = ifs.b8;

            // Reset (v3+)
            lfo.enableReset = ifs.b8;
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleLFO: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSampleModSeq(Stream ifs, StModSeq mseq, short ver) : boolean {

      if(ver >= 1)
      {
         // Play mode
         mseq.playMode = ifs.u8;
         if(ver < 3)
         {
            if(mseq.playMode >= STMODSEQ_PLAYMODE_RANDOM_ND)  // RANDOM_ND added in v3
               mseq.playMode = mseq.playMode + 1;
         }

         // Step mode
         mseq.stepMode = ifs.u8;

         // Num Steps
         mseq.numSteps = ifs.u8;

         if(ver >= 4)
         {
            // Repeat Offset (v4+)
            mseq.repeatOffset = ifs.u8;
         }

         // Step values+durations
         int numSteps = ifs.u8;
         if(numSteps > STMODSEQ_MAX_STEPS)
         {
            trace "[---] Sample::loadStateSampleModSeq: invalid numSteps="+numSteps;
            return false;
         }
         int stepIdx = 0;
         loop(STMODSEQ_MAX_STEPS)
         {
            mseq.setStepValue(stepIdx++, ifs.f32);
         }
         stepIdx = 0;
         loop(STMODSEQ_MAX_STEPS)
         {
            mseq.setStepDuration(stepIdx++, ifs.u8);
         }

         // Speed
         mseq.speed = ifs.f32;

         // Tempo Sync
         mseq.enableTempoSync = ifs.b8;

         // Value scale
         mseq.valueScl = ifs.f32;

         // Value offset
         mseq.valueOff = ifs.f32;

         if(ver >= 2)
         {
            // Slew amount (v2+)
            mseq.slewAmt = ifs.f32;
         }

         // One-Shot
         mseq.enableOneShot = ifs.b8;

         // Global
         mseq.enableGlobal = ifs.b8;

         // Reset
         //  (note) -1=delay start until retrig
         mseq.enableReset = ifs.s8;

         // Pulse
         mseq.enablePulse = ifs.s8;  // tristate

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleModSeq: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSampleMM(Stream ifs, StSample s, int mmIdx) : boolean {

      // ver
      short ver = ifs.u16;

      // trace "xxx loadStateSampleMM: ver="+ver;

      if(ver >= 1)
      {
         // Enable
         s.setMMEnable(mmIdx, ifs.b8);

         // Op
         int mmOp = ifs.u8;
         if(ver < 10)
         {
            if(mmOp >= 3)  // OP_REPLACE added in v10
               mmOp++;
         }
         if(ver < 14)
         {
            if(mmOp >= 4)  // OP_REPLACE_INIT added in v14
               mmOp++;
         }
         s.setMMOp(mmIdx, mmOp);

         if(ver >= 33)
         {
            // Slew Up (v33+)
            s.setMMSlewUp(mmIdx, ifs.f32);

            // Slew Down (v33+)
            s.setMMSlewDown(mmIdx, ifs.f32);
         }

         if(ver >= 38)
         {
            // Slew Reset Mode (v38+)
            s.setMMSlewReset(mmIdx, ifs.u8);
         }

         // Source
         int mmSrc = ifs.u8;
         // trace "xxx mmIdx="+mmIdx+" ver="+ver+" mmSrc="+mmSrc;
         if(ver < 2)
         {
            // added PRESSURE_MAX in v2
            if(mmSrc >= 40)
               mmSrc++;
         }
         if(ver < 3)
         {
            // added CONST_255 in v3
            if(mmSrc >= 4)
               mmSrc++;
         }
         if(ver < 8)
         {
            if(mmSrc >= 4)
               mmSrc += 2;  // added CONST_4, CONST_16 in v8
         }
         if(ver < 11)
         {
            if(mmSrc >= 6)  // added CONST_100 in v11
               mmSrc++;
         }
         if(ver < 13)
         {
            if(mmSrc >= 7)  // added CONST_127 in v13
               mmSrc++;
         }
         if(ver < 14)
         {
            if(mmSrc >= 35)  // added RELEASE / RELEASE_PULSE in v14
               mmSrc += 2;
         }
         if(ver < 16)
         {
            if(mmSrc >= 31)  // added LAYER_NR_xxx in v16
               mmSrc += 5;
         }
         if(ver < 18)
         {
            if(mmSrc >= 38)  // added VELOCITY_EXP2/EXP3/SMOOTHSTEP in v18
               mmSrc += 3;
         }
         if(ver < 22)
         {
            // MODSEQn_BY_VOICEKEY added in v22
            if(mmSrc >= 92)
               mmSrc += 4;
         }
         if(ver < 24)
         {
            // CC#80..83 GENERAL_5..8 added in v24
            if(mmSrc >= 80)
               mmSrc += 8;
         }
         if(ver < 27)
         {
            // VELOCITY_INV/BIP added in v27
            if(mmSrc >= 41)
               mmSrc += 2;
         }
         if(ver < 28)
         {
            // MODWHEEL_INV/BIP* added in v28
            if(mmSrc >= 60)
               mmSrc += 4;
         }
         if(ver < 29)
         {
            // BREATH_INV/BIP* added in v29
            if(mmSrc >= 66)
               mmSrc += 4;
         }
         if(ver < 30)
         {
            // FOOTCTL_INV/BIP* added in v30
            if(mmSrc >= 72)
               mmSrc += 4;
         }
         if(ver < 31)
         {
            // EXPR_INV/BIP* added in v31
            if(mmSrc >= 84)
               mmSrc += 4;
         }
         if(ver < 32)
         {
            // MM_SRC_GATE / MM_SRC_TRIG_PULSE added in v32
            if(mmSrc >= 45)
               mmSrc += 2;
         }
         if(ver < 36)
         {
            if(mmSrc >= 124)   // MM_SRC_MODSEQ4_STEP_1..16 added in v36
               mmSrc += 16;
         }
         if(ver < 39)
         {
            if(mmSrc >= 49)    // MM_SRC_SUSTAIN_PEDAL + MM_SRC_SOFT_PEDAL added in v39
               mmSrc += 2;
         }

         // trace "xxx   ==> new mmSrc="+mmSrc;
         s.setMMSrc(mmIdx, mmSrc);  // ----------------------------- setMMSrc --------------------------------

         if(ver >= 25)
         {
            // Curve (v25+)
            s.setMMCurve(mmIdx, ifs.f32);
         }

         // Amt
         s.setMMAmt(mmIdx, ifs.f32);

         // Destination
         int mmDst = ifs.u8;
         if(ver < 4)
         {
            if(mmDst >= 31)  // added AUX_LFO_FLT_AMT in v4
               mmDst++;
            if(mmDst >= 28)  // added PAN_LFO_PAN_AMT in v4
               mmDst++;
            if(mmDst >= 25)  // added VOL_LFO_VOL_AMT in v4
               mmDst++;
            if(mmDst >= 22)  // added FREQ_LFO_FREQ_AMT in v4
               mmDst++;
         }
         if(ver < 5)
         {
            // modmatrix amount 13..16 added in v5
            if(mmDst >= 87)
               mmDst+=4;
         }
         if(ver < 6)
         {
            // JUMPTOLOOP_ABS added in v6
            if(mmDst >= 19)
               mmDst++;
         }
         if(ver < 7)
         {
            // LOOP_RESTART added in v7
            if(mmDst >= 17)
               mmDst++;
         }
         if(ver < 9)
         {
            // REG_n_ON added in v9
            if(mmDst >= 128)
               mmDst += 4;
         }
         if(ver < 15)
         {
            // LOOP_REPEATS_SCALE added in v15
            if(mmDst >= 19)
               mmDst++;
         }
         if(ver < 17)
         {
            // CYCLE_LEN_SAMPLE_OFFSET added in v17
            if(mmDst >= 19)
               mmDst++;
         }
         if(ver < 19)
         {
            // MODSEQ1..4_STEP added in v19
            if(mmDst >= 118)
               mmDst++;
            if(mmDst >= 113)
               mmDst++;
            if(mmDst >= 108)
               mmDst++;
            if(mmDst >= 103)
               mmDst++;
         }
         if(ver < 20)
         {
            // num mods per voice plugin inc'd from 4 to 8 in v20
            if(mmDst >= 161)
               mmDst += 4;
            if(mmDst >= 157)
               mmDst += 4;
            if(mmDst >= 153)
               mmDst += 4;
            if(mmDst >= 149)
               mmDst += 4;
         }
         if(ver < 21)
         {
            // WT_2D_* added in v21
            if(mmDst >= 20)
               mmDst += 4;
         }
         if(ver < 23)
         {
            // DST_MODSEQn_PATCH added in v23 (inserted before MODSEQn_SPEED)
            if(mmDst >= 120)
               mmDst++;
            if(mmDst >= 114)
               mmDst++;
            if(mmDst >= 108)
               mmDst++;
            if(mmDst >= 102)
               mmDst++;
         }
         if(ver < 26)
         {
            if(mmDst >= 19)  // DST_CYCLE_LEN_EOL added in v26
               mmDst++;
         }
         if(ver < 34)
         {
            if(mmDst >= 28)  // DST_JUMPTOLOOP_ABS (re-)added in v34
               mmDst++;
         }
         if(ver < 35)
         {
            if(mmDst >= 8)   // DST_TUNINGTABLE_REL/ABS added in v35
               mmDst += 2;
         }
         if(ver < 37)
         {
            if(mmDst >= 10)  // DST_NOTE_2/FREQ_2 added in v37
               mmDst += 2;
         }

         s.setMMDst(mmIdx, mmDst);

         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleMM: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSamplePlugins(Stream ifs, StSample s) {

      // Ver
      short ver = ifs.u16;

      if(ver >= 1)
      {
         int pluginIdx = 0;
         loop(STSAMPLE_NUM_PLUGINS)
         {
            String pluginId;
            Utils.ReadString(ifs, pluginId);

            StPluginShared        pluginShared        <= null;
            StPluginSharedMissing pluginSharedMissing <= null;

            if(!pluginId.isBlank())
            {
               StPluginInfo pluginInfo <= VoicePlugins.FindVoicePluginInfoById(pluginId);
               int numParams;
               int paramIdx;
               byte numArrayParams;
               int arraySz;
               int numVar;
               int paramArraySz;
               int paramNumVar;
               int varIdx;
               int arrayIdx;
               short s16;
               FloatArray *faData;

               if(null != pluginInfo)
               {
                  pluginShared <= pluginInfo.createSharedInstance();

                  // Num params
                  numParams = ifs.u16;

                  Global.Debug("Sample::loadStateSamplePlugins: pluginIdx="+pluginIdx+" pluginId=\""+pluginInfo.id+"\" #params="+numParams+"/"+pluginInfo.numParams);

                  // Param values
                  paramIdx = 0;
                  loop(numParams)
                     pluginShared.setParamValue(paramIdx++, ifs.f32);

                  // Array Param Data (v6+)
                  if(ver >= 6)
                  {
                     numArrayParams = ifs.u8;
                     if(numArrayParams > 0)
                     {
                        loop(numArrayParams)
                        {
                           paramIdx = ifs.u8;
                           arraySz  = ifs.u8 + 1;
                           numVar   = ifs.u8 + 1;

                           paramArraySz = pluginInfo.getArrayParamSize(paramIdx);
                           paramNumVar  = pluginInfo.getArrayParamNumVariations(paramIdx);

                           varIdx = 0;
                           loop(numVar)
                           {
                              boolean bRead = false;

                              if(varIdx < paramNumVar)
                              {
                                 faData <= pluginShared.getArrayParamVariationPtr(paramIdx, varIdx);
                                 if(null != faData)
                                 {
                                    arrayIdx = 0;
                                    if(arraySz <= paramArraySz)
                                    {
                                       // Restore same or less number of (signed 16bit) elements
                                       loop(arraySz)
                                       {
                                          s16 = ifs.s16;
                                          faData[arrayIdx++] = (s16 < 0) ? (s16 * (1.0f / 32768.0f)) : (s16 * (1.0f / 32767.0f));
                                       }

                                       // Clear remaining elements
                                       loop(paramArraySz - arraySz)
                                          faData[arrayIdx++] = 0.0f;
                                    }
                                    else
                                    {
                                       // Plugin changed: More elements available than needed
                                       loop(paramArraySz)
                                       {
                                          s16 = ifs.s16;
                                          faData[arrayIdx++] = (s16 < 0) ? (s16 * (1.0f / 32768.0f)) : (s16 * (1.0f / 32767.0f));
                                       }

                                       // Skip extra (16bit) elements
                                       ifs.seek((arraySz - paramArraySz) * 2, SEEK_CUR);
                                    }
                                    bRead = true;
                                 }
                                 // else: Plugin changed: not an array parameter anymore
                              }

                              if(!bRead)
                              {
                                 // Plugin changed: More variations available than needed => skip 16bit array data
                                 ifs.seek(arraySz*2, SEEK_CUR);
                              }

                              // Next variation
                              varIdx++;
                           }
                        } // loop numArrayParams
                     } // if numArrayParams > 0
                  }
               }
               else
               {
                  trace "[~~~] Sample::loadStateSamplePlugins: pluginIdx="+pluginIdx+" MISSING pluginId=\""+pluginId+"\" (skipping..)";

                  // Num params
                  numParams = ifs.u16;

                  pluginSharedMissing <= new StPluginSharedMissing;
                  pluginSharedMissing.pluginId  = pluginId;
                  pluginSharedMissing.numParams = numParams;

                  // Param values
                  paramIdx = 0;
                  loop(numParams)
                     pluginSharedMissing.setParamValue(paramIdx++, ifs.f32);

                  // Array Param Data (v6+)
                  if(ver >= 6)
                  {
                     numArrayParams = ifs.u8;
                     if(numArrayParams > 0)
                     {
                        loop(numArrayParams)
                        {
                           paramIdx = ifs.u8;
                           arraySz  = ifs.u8 + 1;
                           numVar   = ifs.u8 + 1;

                           if(pluginSharedMissing.allocArrayParam(paramIdx, arraySz, numVar))
                           {
                              varIdx = 0;
                              loop(numVar)
                              {
                                 faData <= pluginSharedMissing.getArrayParamVariationPtr(paramIdx, varIdx);
                                 arrayIdx = 0;
                                 loop(arraySz)
                                 {
                                    s16 = ifs.s16;
                                    faData[arrayIdx++] = (s16 < 0) ? (s16 * (1.0f / 32768.0f)) : (s16 * (1.0f / 32767.0f));
                                 }

                                 // Next variation
                                 varIdx++;
                              }
                           }
                           else
                           {
                              // Should not be reachable (OOM)
                              ifs.seek(arraySz *2/*signed 16bit*/ * numVar, SEEK_CUR);
                           }
                        } // loop numArrayParams
                     } // if numArrayParams > 0
                  }
               }
            } // if !pluginId.isBlank

            // Install plugin
            s.setVoicePluginShared       (pluginIdx, #(deref pluginShared));
            s.setVoicePluginSharedMissing(pluginIdx, #(deref pluginSharedMissing));

            // Pre-Filter
            s.setEnableVoicePluginPreFilter(pluginIdx, ifs.b8);

            if(ver >= 2)
            {
               // Enable (v2+)
               s.setEnableVoicePlugin(pluginIdx, ifs.b8);
            }

            if(ver >= 4)
            {
               // Level (v4+)
               s.setVoicePluginLevel(pluginIdx, ifs.f32);

               if(ver >= 7)
               {
                  // Destination (v7+)
                  int vpDst = ifs.u8;
                  if(ver < 8)  // DST_SR added in v8
                  {
                     if(vpDst > 0)
                        vpDst++;
                  }
                  s.setVoicePluginDst(pluginIdx, vpDst);
               }

               // Pan (v4+)
               s.setVoicePluginPan(pluginIdx, ifs.f32);
               s.setVoicePluginPan(pluginIdx, 0.0f); /// xxx remove this when pan becomes editable in UI
            }

            if(ver >= 5)
            {
               // Invert Phase (v5+)
               s.setEnableVoicePluginInvertPhase(pluginIdx, ifs.b8);
            }

            // Next plugin slot
            pluginIdx++;
         }

         if(ver >= 3)
         {
            // Alg (v3+)
            s.voicePluginAlg = ifs.u8;

            // Alg Filter Pos (v3+)
            s.voicePluginAlgFilterPos = ifs.u8;

            // Alg Outer (v3+)
            s.voicePluginAlgOuter = ifs.u8;
         }

         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSamplePlugins: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSampleTuning(Stream ifs, StSample s) : boolean {
      short ver = ifs.u16;
      if(ver >= 1)
      {
         // Num tables
         int numTables = ifs.u8;

         // Default table (-1=use parent's default)
         s.defaultTuningTableIdx = ifs.s8;

         int tblIdx = 0;
         loop(numTables)
         {
            // Freq table default flag
            boolean bDefault = ifs.b8;

            local FloatArray faFreq <= null;
            if(!bDefault)
            {
               faFreq <= new FloatArray;
               Utils.ReadFloatArray(ifs, faFreq);
               if(128 != faFreq.numElements)
               {
                  trace "[~~~] loadStateSampleTuning: invalid freq_table #elements="+faFreq.numElements+" (tblIdx="+tblIdx+"), using default_freq_table..";
                  faFreq <= null;
               }
            }

            if(tblIdx < STSAMPLE_MAX_TUNING_TABLES)
            {
               s.setTuningTable(tblIdx, faFreq);
            }
            else
            {
               trace "[~~~] loadStateSampleTuning: tblIdx="+tblIdx+" >= max="+STSAMPLE_MAX_TUNING_TABLES+", skipping..";
            }

            // Editor meta data default flag
            bDefault = ifs.b8;

            local SampleTuningTable meta <= null;
            if(!bDefault)
            {
               meta <= new SampleTuningTable;
               meta.init();
               if(!meta.loadState(ifs))
               {
                  trace "[---] loadStateSampleTuning: failed to load editor meta data (tblIdx="+tblIdx+")";
                  return false;
               }
            }

            if(tblIdx < STSAMPLE_MAX_TUNING_TABLES)
            {
               s.setTuningTableMetaData(tblIdx, null != meta ? #(deref meta) : null);
            }

            // Next tuning table
            tblIdx++;
         }
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleTuning: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSample(Stream ifs, StSample s) : boolean {
      StRange *range;
      StADSR *adsr;
      StLFO *lfo;
      short verRange;
      short verADSR;
      short verLFO;

      // Version
      short ver = ifs.u16;

      if(ver >= 1)
      {
         if(ver >= 28)
         {
            // Play Mode (v28+)
            if(ver < 45)
               s.playMode = ifs.u8 + 1;  // STSAMPLE_PLAY_MODE_FWDNOLOOP added in v45
            else
               s.playMode = ifs.u8;
         }

         if(ver >= 21)
         {
            // Sample Rate Ratio (v21+)
            s.sampleRateRatio = ifs.f32;
         }
         else
         {
            s.sampleRateRatio = 1.0f;
         }

         if(ver >= 39)
         {
            // Name (v39+)
            String name;
            name.empty();
            Utils.ReadString(ifs, name);
            s.name = name;
         }

         // Mutex Group
         int mgrpIdx = ifs.s8;
         if(-1 != mgrpIdx)
         {
            StSampleMutexGroup mgrp <= sample_bank.getMutexGroupByIdx(mgrpIdx);
            s.mutexGroup = mgrp;
         }

         // Auto-select (v75+)
         if(ver >= 75)
         {
            s.uiSetEnableAutoSelect(ifs.b8);
         }

         // Key Range
         verRange = ifs.u16;
         if(verRange > 0)
         {
            range <= s.getOrCreateKeyRange();
            if(!loadStateSampleRange(ifs, range, verRange))
            {
               trace "[---] Sample::loadStateSample: failed to load key range\n";
               return false;
            }
         }

         // Velocity Range
         verRange = ifs.u16;
         if(verRange > 0)
         {
            range <= s.getOrCreateVelRange();
            if(!loadStateSampleRange(ifs, range, verRange))
            {
               trace "[---] Sample::loadStateSample: failed to load velocity range\n";
               return false;
            }
         }

         // Mod Range
         verRange = ifs.u16;
         if(verRange > 0)
         {
            range <= s.getOrCreateModRange();
            if(!loadStateSampleRange(ifs, range, verRange))
            {
               trace "[---] Sample::loadStateSample: failed to load mod range\n";
               return false;
            }
         }

         // Freq ADSR
         verADSR = ifs.u16;
         if(verADSR > 0)
         {
            adsr <= s.getOrCreateFreqADSR();
            if(!loadStateSampleADSR(ifs, adsr, verADSR))
            {
               trace "[---] Sample::loadStateSample: failed to load freq ADSR\n";
               return false;
            }
         }

         // Volume ADSR
         verADSR = ifs.u16;
         if(verADSR > 0)
         {
            adsr <= s.getOrCreateVolADSR();
            if(!loadStateSampleADSR(ifs, adsr, verADSR))
            {
               trace "[---] Sample::loadStateSample: failed to load volume ADSR\n";
               return false;
            }
         }

         // Pan ADSR
         verADSR = ifs.u16;
         if(verADSR > 0)
         {
            adsr <= s.getOrCreatePanADSR();
            if(!loadStateSampleADSR(ifs, adsr, verADSR))
            {
               trace "[---] Sample::loadStateSample: failed to load pan ADSR\n";
               return false;
            }
         }

         if(ver >= 4)
         {
            // Aux ADSR (v4+)
            verADSR = ifs.u16;
            if(verADSR > 0)
            {
               adsr <= s.getOrCreateAuxADSR();
               if(!loadStateSampleADSR(ifs, adsr, verADSR))
               {
                  trace "[---] Sample::loadStateSample: failed to load aux ADSR\n";
                  return false;
               }
            }
         }

         // Freq LFO
         verLFO = ifs.u16;
         if(verLFO > 0)
         {
            lfo <= s.getOrCreateFreqLFO();
            if(!loadStateSampleLFO(ifs, lfo, verLFO))
            {
               trace "[---] Sample::loadStateSample: failed to load freq LFO\n";
               return false;
            }
         }

         // Volume LFO
         verLFO = ifs.u16;
         if(verLFO > 0)
         {
            lfo <= s.getOrCreateVolLFO();
            if(!loadStateSampleLFO(ifs, lfo, verLFO))
            {
               trace "[---] Sample::loadStateSample: failed to load volume LFO\n";
               return false;
            }
         }

         // Pan LFO
         verLFO = ifs.u16;
         if(verLFO > 0)
         {
            lfo <= s.getOrCreatePanLFO();
            if(!loadStateSampleLFO(ifs, lfo, verLFO))
            {
               trace "[---] Sample::loadStateSample: failed to load pan LFO\n";
               return false;
            }
         }

         if(ver >= 4)
         {
            // Aux LFO (v4+)
            verLFO = ifs.u16;
            if(verLFO > 0)
            {
               lfo <= s.getOrCreateAuxLFO();
               if(!loadStateSampleLFO(ifs, lfo, verLFO))
               {
                  trace "[---] Sample::loadStateSample: failed to load aux LFO\n";
                  return false;
               }
            }
         }

         // ModSeq (v22+)
         if(ver >= 22)
         {
            int mseqIdx = 0;
            loop(STSAMPLE_NUM_MODSEQ)
            {
               int numModSeqPatches;
               if(ver >= 48)
                  numModSeqPatches = ifs.u8;
               else
                  numModSeqPatches = 1;

               int modSeqPatchIdx = 0;
               loop(numModSeqPatches)
               {
                  short verModSeq = ifs.u16;
                  if(verModSeq > 0)
                  {
                     StModSeq mseq <= s.getOrCreateModSeqByIndexAndPatch(mseqIdx, modSeqPatchIdx);
                     if(!loadStateSampleModSeq(ifs, mseq, verModSeq))
                     {
                        trace "[---] Sample::loadStateSample: failed to load modseq["+mseqIdx+"]["+modSeqPatchIdx+"]";
                        return false;
                     }
                  }
                  modSeqPatchIdx++;
               }

               if(ver >= 48)
               {
                  // Default modseq patch (v48+)
                  s.setDefaultModSeqPatch(mseqIdx, ifs.u8);
               }

               if(ver >= 41)
               {
                  // Glide modseq retrig (v41+)
                  s.setEnableGlideRetrigModSeq(mseqIdx, ifs.b8);
               }

               mseqIdx++;
            }
         }

         // Sample Loops
         int numLoopElements = ifs.i32;
         if(numLoopElements > 0)
         {
            IntArray loops <= s.getOrCreateSampleLoops();
            loops.alloc(numLoopElements);
            loops.useAll();
            int idx = 0;
            loop(loops.numElements)
            {
               loops[idx++] = ifs.i32;
            }
         }

         if(ver >= 74)
         {
            // Loop Fade #frames (v74+)
            s.startEndFadeNumFrames = ifs.u16;
         }

         if(ver >= 15)
         {
            if(ver >= 76)
            {
               // Keyboard Center (v76+)
               s.setMMKeyboardCenter(ifs.f32);
            }

            if(ver >= 77)
            {
               // Keyboard Min (v77+)
               s.setMMKeyboardMin(ifs.f32);

               // Keyboard Max (v77+)
               s.setMMKeyboardMax(ifs.f32);
            }

            if(ver >= 81)
            {
               // ModMatrix variation (v81+)
               s.mmVarSetEnable(ifs.b8);        // v81+
               s.mmVarSetNum(ifs.u8);           // v81+
               s.mmVarSetEnableSmooth(ifs.s8);  // v81+
               s.mmVarSetEditIdx(ifs.u8);       // v81+
               s.mmVarSetEnableForceEditIdx(ifs.b8);  // v81+
               FloatArray mmVarData <= s.mmVarGetData();
               Utils.ReadFloatArrayNoAlloc(ifs, mmVarData);  // v81+   (16 variations*16 mm entries in v81)
               // if(s.mmVarGetEnable())
               //    trace "xxx loadState: mmVarData="+#(mmVarData);
            }

            // Mod matrix
            int numMM = (ver < 23) ? 12 : STSAMPLE_NUM_MODMATRIX_ENTRIES/*16*/;
            int mmIdx = 0;
            loop(numMM)
            {
               if(!loadStateSampleMM(ifs, s, mmIdx))
               {
                  trace "[---] Sample::loadStateSample: failed to load modmatrix entry["+mmIdx+"]";
                  return false;
               }
               mmIdx++;
            }
         }

         // Sync first loop index
         s.uiSetEnableSyncFirstLoopIndex(ifs.b8);

         // First Loop Index
         s.firstLoopIndex = ifs.s8;

         // Note-Off loop Index
         s.noteOffLoopIndex = ifs.s8;

         // EnableNoteOffLoopImmediately
         s.enableNoteOffLoopImmediately = ifs.b8;

         if(ver >= 25)
         {
            // EnableJumpToLoopImmediately (v25+)
            s.enableJumpToLoopImmediately = ifs.b8;
         }

         // Offset (usually 0)
         s.offset = ifs.i32;

         // Len (usually 0)
         s.len = ifs.i32;

         if(s.offset > 0 || s.len > 0)
         {
            trace "[~~~] Sample::loadStateSample: s.offset="+s.offset+" s.len="+s.len+" (fixing..)";
            s.offset = 0;  // [31Dec2022] _must_ be (0;0) (== use sample_loops)
            s.len    = 0;
         }

         // Max Voices
         s.maxVoices = ifs.u16;

         // Volume
         s.volume = ifs.f32;

         if(ver >= 19)
         {
            // Volume LFO Amt (v19+)
            s.volLFOAmt = ifs.f32;
         }
         else
         {
            s.volLFOAmt = 1.0;
         }

         // Volume Velocity Amount
         s.volumeVelocityAmount = ifs.f32;

         // Sample Offset Velocity Amount
         s.sampleOffsetVelocityAmount = ifs.f32;

         if(ver >= 3)
         {
            // Invert Sample Offset Velocity Amount (v3+)
            s.enableInvertSampleOffsetVelocityAmount = ifs.b8;
         }

         if(ver >= 2)
         {
            // Sample Offset Randomization Amount (v2+)
            s.sampleOffsetRandAmount = ifs.f32;
         }

         if(ver >= 14)
         {
            // Relative Sample Offset (v14+)
            s.sampleOffsetRel = ifs.f32;
         }

         // Pan
         s.pan = ifs.f32;

         if(ver >= 16)
         {
            // Pan Env Amt (v16+)
            s.panEnvAmt = ifs.f32;

            // Pan LFO Amt (v16+)
            s.panLFOAmt = ifs.f32;
         }

         // Transpose Oct
         s.uiTransposeOct = ifs.s8;

         // Transpose Semi
         s.uiTransposeSemi = ifs.s8;

         // Transpose Cents
         s.uiTransposeCents = ifs.f32;

         if(ver >= 8)
         {
            // Beat Frequency (v8+)
            s.beatFrequency = ifs.f32;
         }

         if(ver >= 16)
         {
            // Freq Env Amt (v16+)
            s.freqEnvAmt = ifs.f32;

            // Freq LFO Amt (v16+)
            s.freqLFOAmt = ifs.f32;
         }

         // Delay (ms)
         s.delay = ifs.f32;

         if(ver >= 24)
         {
            // Delay (ms) (v24+)
            s.delayMultiplier = ifs.f32;
         }

         // Enable Timestretch
         s.enableTimestretch = ifs.b8;

         if(ver >= 49)
         {
            // Enable Timestretch Additive (v49+)
            s.enableTimestretchAdditive = ifs.b8;
         }

         if(ver >= 80)
         {
            // Timestretch Additive Cycle X-Fade (v80+)
            s.timestretchAdditiveXFade = ifs.f32;
         }

         if(ver >= 68)
         {
            // Additive Partial CycleLen Reset (v68+)
            s.partialCycleLenReset = ifs.f32;
         }

         if(ver >= 69)
         {
            // Additive Partial Phase 0 (v69+)
            s.enablePartialPhase0 = ifs.b8;
         }

         if(ver >= 60)
         {
            // Timestretch Additive Num Partials (v60+)
            if(ver < 67)
               s.numPartials = ifs.u8 + 1;
            else
               s.numPartials = ifs.f32;  // v67+
         }

         if(ver >= 66)
         {
            // Additive stereo spread (v66+)
            s.additiveStereoSpread = ifs.f32;
         }

         if(ver >= 62)
         {
            // Additive oscillator settings (v62+)
            //  (note) multiple configs added in v64
            if(ver >= 64)
            {
               s.additiveEditCfg            = ifs.f32;  // v64+
               s.enableForceAdditiveEditCfg = ifs.i8;   // v64+
            }
            int cfgIdx = 0;
            loop((ver >= 64) ? STSAMPLE_ADDITIVE_CFG_NUM/*8*/ : 1)
            {
               if(ver >= 64)
               {
                  s.setAdditiveCfgValid(cfgIdx, ifs.b8);  // v64+

                  if(ver >= 65)
                     s.setAdditiveNormalize(cfgIdx, ifs.b8);  // v65+

                  s.setAdditiveRateReduction    (cfgIdx, ifs.u8);  // v64+
                  s.setAdditiveRateReductionMask(cfgIdx, ifs.u8);  // v64+

                  s.setAdditiveBitReductionPreAmp(cfgIdx, ifs.f32);  // v64+
                  s.setAdditiveBitReduction      (cfgIdx, ifs.u8);  // v64+
                  s.setAdditiveBitReductionMask  (cfgIdx, ifs.u16);  // v64+
               }

               int oscIdx = 0;
               loop(STSAMPLE_ADDITIVE_OSC_NUM)
               {
                  s.setAdditiveLevel (cfgIdx, oscIdx, ifs.f32);
                  s.setAdditivePhase (cfgIdx, oscIdx, ifs.f32);
                  s.setAdditiveExpA  (cfgIdx, oscIdx, ifs.f32);
                  if(ver >= 63)
                     s.setAdditiveFilter(cfgIdx, oscIdx, ifs.f32); // v63+
                  s.setAdditiveExpL  (cfgIdx, oscIdx, ifs.f32);
                  oscIdx++;
               }

               cfgIdx++;
            }
         }

         // Enable Timestretch XFade
         s.enableTimestretchXFade = ifs.b8;

         // Timestretch
         s.timestretch = ifs.f32;

         // Timestretch Granularity
         if(ver >= 17)
         {
            s.timestretchGranularity = ifs.f32;
         }
         else
         {
            s.timestretchGranularity = ifs.u16;
         }

         // Timestretch Granularity Amount
         s.timestretchGranularityAmount = ifs.f32;

         // Enable Static CycleLen
         s.enableStaticCyclelen = ifs.b8;

         // Enable Absolute Timestretch
         s.enableAbsoluteTimestretch = ifs.b8;

         // Timestretch Interpolation Type
         s.timestretchInterpolType = ifs.u8;

         if(ver >= 35)
         {
            // Timestretch Grain Window Type (v35+)
            s.timestretchGrainWindowType = ifs.u8;
         }

         if(ver >= 18)
         {
            // Timestretch Phase Bend (v18+)
            s.timestretchBend = ifs.f32;
         }

         // Timestretch Start Phase Randomization Amount
         s.timestretchStartPhaseRandAmount = ifs.f32;

         if(ver >= 40)
         {
            // Timestretch 2D Width (v40+)
            s.timestretch2DWidth = ifs.u8;

            // Timestretch 2D Height (v40+)
            s.timestretch2DHeight = ifs.u8;
         }

         // TimedLoop Enable
         s.enableTimedLoop = ifs.b8;

         // TimedLoop Fade Enable
         s.enableTimedLoopFade = ifs.b8;

         // TimedLoop Base
         s.timedLoopBase = ifs.f32;

         // TimedLoop EnableOneShotLoopStep
         s.enableOneShotLoopStep = ifs.b8;

         // Volume Ramp Up
         s.volumeRampStepsMillisecIn = ifs.f32;

         // Volume Ramp Down
         s.volumeRampStepsMillisecOut = ifs.f32;

         // EnableFreezeSampleOffWhenQuiet
         s.enableFreezeSampleOffWhenQuiet = ifs.b8;

         // EnableModShiftOrig
         s.enableModShiftOrig = ifs.b8;

         // EnableSampleOffNoteOn
         s.enableSampleOffNoteOn = ifs.b8;

         // Enable
         s.enabled = ifs.b8;

         // Interpolation Type
         s.interpolType = ifs.u8;
         if(ver < 82 && s.interpolType >= 2)  // added VSR interpolation types in v82
            s.interpolType += 6;

         if(ver >= 71)
         {
            // Interpolation Order (v71+)
            s.interpolOrder = ifs.i8;

            // AI Num Poles (v71+)
            s.aiNumPoles = ifs.u8;

            // AI Exp Up (v71+)
            s.aiExpUp = ifs.f32;

            // AI Exp Down (v71+)
            s.aiExpDown = ifs.f32;
         }

         if(ver >= 72)
         {
            // AI Q (v72+)
            s.aiQ = ifs.f32;
         }

         if(ver >= 73)
         {
            // AI Linear Num Octaves (v73+)
            s.aiLinOct = ifs.f32;

            // AI Linear Max Cutoff (v73+)
            s.aiLinMax = ifs.f32;
         }

         if(ver >= 20)
         {
            // 8bit mode (< v55+)
            if(ver < 55)
            {
               boolean b8bit = ifs.b8;
               if(b8bit)
                  s.bitReduction = 8;
               else
                  s.bitReduction = 0;
            }
            else
            {
               if(ver >= 56)
               {
                  // Bit reduction pre amp (v56+)
                  s.bitReductionPreAmp = ifs.f32;
               }

               s.bitReduction     = ifs.u8;
               s.bitReductionMask = ifs.u16;
            }

            if(ver >= 54)
            {
               // Rate reduction (v54+)
               s.rateReduction = ifs.u8;

               // Rate reduction mask (v54+)
               s.rateReductionMask = ifs.u8;
            }

            if(ver >= 42)
            {
               // Lerp Freq (v42+)
               s.enableLerpFreq = ifs.b8;

               // Lerp Vol (v42+)
               s.enableLerpVol = ifs.b8;
            }

            // Play first iteration from sample start to loop end (v20+)
            s.enableFromStart = ifs.s8;
         }

         // (todo) "waveguide" table (+rename this feature)

         // Alt Enable
         s.enableAlt = ifs.b8;

         if(ver >= 5)
         {
            if(ver >= 36)
            {
               // Filter Enable (v36+)
               s.enableFilter = ifs.b8;
            }

            // Filter Type (v5+)
            s.filterType = ifs.u8;

            // Filter CutOff (v5+)
            s.filterCutOff = ifs.f32;

            // Filter Stereo Panning (v5+)
            s.filterPan = ifs.f32;

            // Dual Filter Offset (v5+)
            s.filterOffset = ifs.f32;

            if(ver >= 7)
            {
               // Filter EQ Gain (v7+)
               s.filterEQGain = ifs.f32;
            }

            // Filter Resonance (v5+)
            s.filterResonance = ifs.f32;

            // Filter Aux Env Amount (v5+)
            s.filterAuxEnvAmount = ifs.f32;

            // Filter Aux Env Velocity Amount (v5+)
            s.filterAuxEnvVelocityAmount = ifs.f32;
         }

         if(ver >= 6)
         {
            // Filter Aux LFO Amount (v6+)
            s.filterAuxLFOAmount = ifs.f32;

            // Filter Keyboard Amount (v6+)
            s.filterKeyboardAmount = ifs.f32;
         }

         if(ver >= 9)
         {
            // Glide type (v9+)
            s.glideType = ifs.u8;

            // Glide speed time up (v9+)
            s.glideSpeedTimeUp = ifs.f32;

            // Glide speed time down (v9+)
            s.glideSpeedTimeDown = ifs.f32;

            // Glide speed freq up (v9+)
            s.glideSpeedFreqUp = ifs.f32;

            // Glide speed freq down (v9+)
            s.glideSpeedFreqDown = ifs.f32;
         }

         if(ver >= 10)
         {
            // Glide release enable (v10+)
            s.enableGlideRelease = ifs.b8;

            // Glide max note distance (v10+)
            s.glideMaxNoteDist = ifs.u8;
         }

         if(ver >= 11)
         {
            // Glide glissando enable (v10+)
            s.enableGlideGlissando = ifs.b8;
         }

         if(ver >= 12)
         {
            // Glide min time threshold (v12+)
            s.glideMinTime = ifs.u16;
         }

         if(ver >= 57)
         {
            // Glide max time threshold (v57+)
            s.glideMaxTime = ifs.u16;
         }

         if(ver >= 13)
         {
            // Glide retrig sample (v13+)
            s.enableGlideRetrigSample = ifs.b8;

            // Glide retrig freq env (v13+)
            s.enableGlideRetrigEnvFreq = ifs.b8;

            // Glide retrig vol env (v13+)
            s.enableGlideRetrigEnvVol = ifs.b8;

            // Glide retrig pan env (v13+)
            s.enableGlideRetrigEnvPan = ifs.b8;

            // Glide retrig aux env (v13+)
            s.enableGlideRetrigEnvAux = ifs.b8;

            // Glide retrig freq LFO (v13+)
            s.enableGlideRetrigLFOFreq = ifs.b8;

            // Glide retrig vol LFO (v13+)
            s.enableGlideRetrigLFOVol = ifs.b8;

            // Glide retrig pan LFO (v13+)
            s.enableGlideRetrigLFOPan = ifs.b8;

            // Glide retrig aux LFO (v13+)
            s.enableGlideRetrigLFOAux = ifs.b8;
         }

         if(ver >= 26)
         {
            // LiveRec Enable (v26+)
            s.liveRecEnable = ifs.b8;

            // LiveRec Input (v26+)
            s.liveRecInput = ifs.u8;

            // LiveRec Stereo (v26+)
            s.liveRecStereo = ifs.b8;

            if(ver >= 53)
            {
               // LiveRec Monitor (v53+)
               s.liveRecMonitor = ifs.s8;
            }

            if(ver >= 78)
            {
               // LiveRec Input Pan (v78+)
               s.liveRecInputPan = ifs.f32;
            }

            // LiveRec LoopIdx (v26+)
            s.liveRecLoopIdx = ifs.u16;

            if(ver >= 31)
            {
               // LiveRec Copy (v31+)
               s.liveRecCopy = ifs.s8;
            }

            if(ver >= 44)
            {
               // LiveRec Clear (v44+)
               s.liveRecClear = ifs.s8;
            }

            // LiveRec DblBuf Mode (v26+)
            s.liveRecDoubleBufferMode = ifs.u8;
            if(ver < 31)
            {
               if(4 == s.liveRecDoubleBufferMode)  // DBLBUF_MODE_COPY removed in v31
               {
                  s.liveRecCopy = true;
                  s.liveRecDoubleBufferMode = STSAMPLE_LIVEREC_DBLBUF_MODE_END;
               }
            }

            if(ver >= 27)
            {
               // LiveRec DblBuf XFade (v27+)
               s.liveRecDoubleBufferXFade = ifs.b8;
            }

            if(ver >= 29)
            {
               // LiveRec Osc Mode (v29+)
               s.liveRecOscMode = ifs.u8;
            }

            if(ver >= 43)
            {
               // LiveRec Osc SingleCycle (v43+)
               s.liveRecOscSingleCycle = ifs.b8;
            }

            if(ver >= 30)
            {
               // LiveRec Osc Tune (v30+)
               s.liveRecOscTune = ifs.f32;
            }

            if(ver >= 50)
            {
               // LiveRec Osc Fade Amount (v50+)
               s.liveRecOscFadeAmt = ifs.f32;
            }

            if(ver >= 70)
            {
               // LiveRec Skip Input Num Frames (v70+)
               s.liveRecSkipInputNumFrames = ifs.u16;
            }

            if(ver >= 52)
            {
               // LiveRec Osc Pre Filter (v52+)
               s.liveRecOscPreFilter = ifs.f32;
            }

            if(ver >= 51)
            {
               // LiveRec Osc Resampling (v51+)
               s.liveRecOscResample = ifs.b8;
            }

            if(ver >= 32)
            {
               // LiveRec Osc Sustain Mode (v32+)
               s.liveRecOscSustain = ifs.b8;
            }

            // LiveRec Mode (v26+)
            s.liveRecMode = ifs.u8;

            // LiveRec Threshold (v26+)
            s.liveRecThresholdOn = ifs.f32;
         }

         if(ver >= 46)
         {
            // Sum Input Level (v46+)
            s.enableSumInput = ifs.s8;
            s.sumInputXFade  = ifs.f32;
         }

         if(ver >= 34)
         {
            // Enable FX (v34+)
            s.enableFX = ifs.b8;
         }

         if(ver >= 37)
         {
            // Voice Bus (v37+)
            s.voiceBus = ifs.s8;
         }

         if(ver >= 38)
         {
            // SampleView (v38+)
            local Double svZoom;
            ifs.deserialize(svZoom, false/*bTypeInfo*/);
            s.uiSVZoom     = svZoom;
            s.uiSVOffset   = ifs.f32;
            s.uiSVZoomYIdx = ifs.u8;
         }

         if(ver >= 47)
         {
            // AuxToWav (V47+)
            s.uiEnableAuxToWav = ifs.b8;
         }

         if(ver >= 58)
         {
            // Voice Calibration tables (v58+)
            int vcalLaneIdx = 0;
            loop(6)
            {
               s.setVoiceCalibrationModulo(vcalLaneIdx, ifs.u8);
               if(ver >= 59)
               {
                  s.setVoiceCalibrationAmount(vcalLaneIdx, ifs.f32);  // v59+
                  s.setVoiceCalibrationEnable(vcalLaneIdx, ifs.b8);   // v59+
               }
               int vcalVoiceIdx = 0;
               loop(8)
                  s.setVoiceCalibrationValue(vcalLaneIdx, vcalVoiceIdx++, ifs.f32);
               vcalLaneIdx++;
            }
         }

         if(ver >= 33)
         {
            // Voice plugins (v33+)
            if(!loadStateSamplePlugins(ifs, s))
            {
               trace "[---] Sample::loadStateSample: loadStateSamplePlugins() failed\n";
               return false;
            }
         }

         if(ver >= 79)
         {
            // Tuning tables (v79+)
            if(!loadStateSampleTuning(ifs, s))
            {
               trace "[---] Sample::loadStateSample: loadStateSampleTuning() failed\n";
               return false;
            }
         }

         if(s.enableTimestretchAdditive)
            s.recalcAdditiveTbl(-1/*all cfgs*/);

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSample: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateSampleBankTuning(Stream ifs) : boolean {
      short ver = ifs.u16;
      if(ver >= 1)
      {
         // Num tables
         int numTables = ifs.u8;

         // Default table (-1=use parent's default)
         sample_bank.defaultTuningTableIdx = ifs.s8;

         int tblIdx = 0;
         loop(numTables)
         {
            // Freq table default flag
            boolean bDefault = ifs.b8;

            local FloatArray faFreq <= null;
            if(!bDefault)
            {
               faFreq <= new FloatArray;
               Utils.ReadFloatArray(ifs, faFreq);
               if(128 != faFreq.numElements)
               {
                  trace "[~~~] loadStateSampleBankTuning: invalid freq_table #elements="+faFreq.numElements+" (tblIdx="+tblIdx+"), using default_freq_table..";
                  faFreq <= null;
               }
            }

            if(tblIdx < STSAMPLE_MAX_TUNING_TABLES)
            {
               // trace "xxx sample_bank.setTuningTable(tblIdx="+tblIdx+", faFreq="+faFreq+")";
               sample_bank.setTuningTable(tblIdx, faFreq);
            }
            else
            {
               trace "[~~~] loadStateSampleBankTuning: tblIdx="+tblIdx+" >= max="+STSAMPLE_MAX_TUNING_TABLES+", skipping..";
            }

            // Editor meta data default flag
            bDefault = ifs.b8;

            local SampleTuningTable meta <= null;
            if(!bDefault)
            {
               meta <= new SampleTuningTable;
               meta.init();
               if(!meta.loadState(ifs))
               {
                  trace "[---] loadStateSampleBankTuning: failed to load editor meta data (tblIdx="+tblIdx+")";
                  return false;
               }
            }

            if(tblIdx < STSAMPLE_MAX_TUNING_TABLES)
            {
               sample_bank.setTuningTableMetaData(tblIdx, null != meta ? #(deref meta) : null);
            }

            // Next tuning table
            tblIdx++;
         }
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateSampleBankTuning: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   protected method loadStateInt(Stream ifs) : boolean {

      // Version
      short ver = ifs.u16;
      // trace "xxx Sample::loadStateInt: ver="+ver;

      if(ver >= 1)
      {
         // Program id
         prg_id = ifs.s8;
         // prg_id = -1;  // never load program ids

         if(ver >= 7)
         {
            // Unique ID (v7+)
            if(-1 == unique_id)
            {
               // Loading sample from project file
               unique_id = ifs.s16;
            }
            else
            {
               // Loading sample via browser or reload (keep current UID)
               short dummyUID = ifs.s16;
            }
         }

         // Sample type
         sample_type = ifs.u8;

         if(ver < 5)
         {
            if(sample_type >= 1)  // TYPE_LAYERED+TYPE_WAVESEQ added in v5
               sample_type += 2;
         }

         if(ver < 13)
         {
            if(sample_type >= 18)  // TYPE_DRUM_MAP_MOD* added in v13
               sample_type += 4;
         }

         // Grid size
         grid_size = ifs.u8;

         if(ver >= 17)
         {
            // Sustain hint (v17+)
            b_sustain = ifs.b8;
         }

         // Max voices
         sample_bank.maxVoices = ifs.u16;

         if(ver >= 16)
         {
            // Enable Realloc mono-mode (v16+)
            sample_bank.enableRealloc = ifs.b8;
         }

         if(ver >= 2)
         {
            // Enable Unique Notes (v2+)
            sample_bank.enableUniqueNotes = ifs.b8;
         }

         if(ver >= 14)
         {
            // Freeze PerfCtl at note-off (v14+)
            sample_bank.enablePerfCtlFreezeNoteOff = ifs.b8;
         }

         // Solo zone idx
         solo_zone_idx = ifs.s16;

         // trace "xxx load solo_zone_idx="+solo_zone_idx;

         // Transpose
         transpose_oct = ifs.s8;
         transpose_semi = ifs.s8;
         transpose_cents = ifs.f32;
         sample_bank.transpose = transpose_oct * 12 + transpose_semi + transpose_cents/100.0f;

         // Pitchbend range
         pitchbend_up = ifs.f32;
         pitchbend_down = ifs.f32;

         // Volume
         sample_bank.volume = ifs.f32;

         // Pan
         sample_bank.pan = ifs.f32;

         // Sampleoff rand
         sample_bank.sampleOffsetRandAmount = ifs.f32;

         // Volume rand
         sample_bank.volumeRandAmount = ifs.f32;

         // Pan rand
         sample_bank.panRandAmount = ifs.f32;

         // Freq rand
         sample_bank.freqRandAmount = ifs.f32;

         if(ver >= 3)
         {
            // Mod src (v3+)
            mod_src = ifs.u8;
         }

         if(ver >= 4)
         {
            // Mod src Note On (v4+)
            b_mod_src_noteon = ifs.b8;
         }

         if(ver >= 8)
         {
            // Partial window bits (v8+)
            partial_window_bits = ifs.u8;
         }

         if(ver >= 10)
         {
            // Partial cosine window (v10+)
            b_partial_cos_win = ifs.b8;
         }

         if(ver >= 9)
         {
            // Partial true bin frequency (v9+)
            b_partial_true_freq = ifs.b8;
         }

         if(ver >= 11)
         {
            // Partial speed exponent (v11+)
            partial_speed_exp = ifs.f32;

            // Partial bin exponent (v11+)
            partial_bin_exp = ifs.f32;
         }

         if(ver >= 12)
         {
            // Partial magnitude exponent (v12+)
            partial_mag_exp = ifs.f32;

            // Partial magnitude bin exponent (v12+)
            partial_mag_bin_exp = ifs.f32;
         }

         if(ver >= 15)
         {
            // Tuning tables (v15+)
            if(!loadStateSampleBankTuning(ifs))
            {
               trace "[---] Sample::loadStateInt: loadStateSampleBankTuning() failed";
               return false;
            }
         }

         // Zones
         int numZones = ifs.u16;
         int zoneIdx = 0;
         trace "[...] Sample::loadStateInt: loading "+numZones+" zone(s)";
         StSample *s;
         loop(numZones)
         {
            s <= newZone();

            if(Configuration.debugLevel >= 2)
               Global.Debug("Sample::loadStateInt: load zone "+(zoneIdx+1)+"/"+numZones);

            if(!loadStateSample(ifs, s))
            {
               trace "[---] Sample::loadStateInt: failed to load zone "+(zoneIdx+1)+"/"+numZones;
               s.verifySampleAreas();
               return false;
            }

            s.verifySampleAreas();

            zoneIdx++;
         }

         sample_bank.updateAltGroups();

         if(ver >= 6)
         {
            // int t = milliSeconds();

            // Sample Synth state ("cycle") (v6+)
            if(!cycle_state.loadState(ifs))
            {
               trace "[---] Sample::loadStateInt: failed to load cycle_state";
               return false;
            }

            // t = milliSeconds() - t;
            // Global.Profile("Sample::loadStateInt: cycle_state.loadState() took "+t+" milliseconds");
         }

         if(ver >= 18)
         {
            // Procedural track sequence events (v18+)
            int numSeqFrames = ifs.u16;
            proc_seq_frames.free();
            int frIdx = 0;
            loop(numSeqFrames)
            {
               MIDIPipeFrame fr <= new MIDIPipeFrame;
               if(!fr.loadState(ifs))
               {
                  trace "[---] Sample::loadStateInt: failed to load proc_seq_frame "+(frIdx+1)+"/"+numSeqFrames;
                  return false;
               }
               proc_seq_frames.add(#(deref fr));
               frIdx++;
            }
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] Sample::loadStateInt: invalid version (ver="+ver+")";
      }
      return false;
   }

   // <load.png>
   public =replay= method loadState(Stream ifs, String _dirName, boolean _bProject) : boolean {

      boolean bOldStyleAuxToWav = maybe;

      b_procedural = false;

      char hdr1 = ifs.u8;
      char hdr2 = ifs.u8;
      char hdr3 = ifs.u8;
      char hdr4 = ifs.u8;

      if(('E' == hdr1) &&
         ('S' == hdr2) &&
         ('A' == hdr3) &&
         ('.' == hdr4)
         )
      {
         short ver = ifs.u16;

         if(ver >= 1)
         {
            // Tags (v9+)
            if(ver >= 9)
            {
               byte numTags = ifs.u8;
               SampleCacheEntry.ReadSampleTags(ifs, numTags, tags);
            }

            // Procedural waveform flag (v3+)
            if(ver >= 3)
            {
               b_procedural = ifs.b8;
               if(b_procedural)
               {
                  int numFrames = ifs.i32;
                  Global.Debug("Sample::loadState: procedural waveform #frames="+numFrames);
                  waveform.baseFrequency = BASE_FREQ_MIDDLE_C;
                  waveform.alloc(1/*numCh*/, numFrames);
                  FloatArray smpDat <= waveform.sampleData;
                  smpDat.fill(0);

                  if(ver >= 4)
                     waveform.sampleRate = ifs.f32;
               }
            }

            if(ver >= 13)
            {
               // Procedural Source Track Index (v13+)
               src_track_idx = ifs.s8;
            }

            if(ver >= 11)
            {
               // Audio-clip flag (v11+)
               b_audio_clip = ifs.b8;

               if(ver >= 12)
               {
                  // Audio-clip bpm (v12+)
                  audio_clip_bpm = ifs.f32;
               }
            }

            // AuxToWav flag (v5+)
            //  (note) moved to sample zone in v6
            if(5 == ver)
            {
               bOldStyleAuxToWav = ifs.b8;
            }

            // Sample name
            Utils.ReadString(ifs, unique_name);

            Global.Debug("Sample::loadState: load sample \""+unique_name+"\"");

            // Description
            Utils.ReadString(ifs, description);

            // Suggested path name
            Utils.ReadString(ifs, suggested_pathname);
            Global.Debug("Sample::loadState: suggested_pathname=\""+suggested_pathname+"\"");

            if(ver >= 8)
            {
               // Namespace index (v8+)
               namespace_idx = ifs.i8;
               // trace "xxx Sample::loadState: read namespace_idx="+namespace_idx;
               if(!_bProject)
                  namespace_idx = 0; // [04Oct2024] revert to global namespace when loading sample from repo
            }
            // trace "xxx Sample::loadState: using namespace_idx="+namespace_idx;

            if(ver >= 10)
            {
               // Persistence flag (v10+)
               b_persistent = ifs.b8;
               if(!_bProject)
                  b_persistent = false;
            }

            if(!b_procedural)
            {
               if(_bProject)
               {
                  local String rootPath <= Global.GetProjectSamplesWavRootPath();
                  loadWav(deref rootPath);
                  b_project_waveform_modified = false;
                  b_user_waveform_modified = true;
               }
               else
               {
                  loadWav(_dirName);
                  b_project_waveform_modified = true;
                  b_user_waveform_modified = false;
               }
            }
            else
            {
               b_project_waveform_modified = false;
               b_user_waveform_modified = false;
            }

            // Initial performance controller (v7+)
            if(ver >= 7)
            {
               int numPerfCtl = ifs.u8;  // should be STSAMPLEPLAYER_NUM_PERFCTL
               int perfCtlIdx = 0;
               loop(numPerfCtl)
                  initial_perf_ctl[perfCtlIdx++] = ifs.f32;
               loop(STSAMPLEPLAYER_NUM_PERFCTL - numPerfCtl)
                  initial_perf_ctl[perfCtlIdx++] = -1;
               invalidateNonPersistentInitialPerfCtl();
            }

            sample_bank.freeSamples();

            // Uncompressed size
            int sizeRaw = ifs.i32;

            // Compressed size
            int sizeZip = ifs.i32;

            Global.Debug("Sample::loadState: sizeRaw="+sizeRaw+" sizeZip="+sizeZip+" (ratio="+((float(sizeZip)/sizeRaw)*100)+"%)");

            local Buffer bZip;
            bZip.size = sizeZip;
            bZip.offset = 0;
            ifs.readBuffer(bZip, 0, sizeZip, false/*bResize*/);
            local Buffer bRaw;
            bRaw.gunzip(bZip, 0, sizeZip, sizeRaw);

            if(0)
            {
               local File f;
               if(f.openLocal("debug.dat", IOS_OUT))
               {
                  f.writeBuffer(bRaw, 0, bRaw.size);
                  f.close();
               }
            }

            // int t = milliSeconds();
            boolean ret = loadStateInt(bRaw);
            // t = milliSeconds() - t;
            // Global.Profile("Sample::loadState: loadStateInt() took "+t+" milliseconds");

            if(true == bOldStyleAuxToWav)
            {
               StSample s <= sample_bank.firstSample;
               while(null != s)
               {
                  s.uiEnableAuxToWav = bOldStyleAuxToWav;
                  s <= s.next;
               }
            }

            return ret;
         }
         else
         {
            trace "[---] Sample::loadState: invalid version (ver="+ver+")";
         }
      }
      else
      {
         trace "[---] Sample::loadState: bad header (have='"+tcchar(hdr1)+tcchar(hdr2)+tcchar(hdr3)+tcchar(hdr4)+"')";
      }

      return false;
   }

   // <load.png>
   public method loadFile(String _pathName, String _rootPath, boolean _bProject, boolean _bRecalcPatches) : boolean {

      boolean bOldSuppressUnderrunError = Audio.PushSuppressUnderrunError();

      return = false;

      local String dirName;
      local String fileName;
      // // // // Utils.SplitPathname(Utils.SubstitutePathVars(_pathName), dirName, fileName);
      // // Utils.SplitPathname(Utils.ToNativePathName(_pathName), dirName, fileName);
      Utils.SplitPathname(_pathName, dirName, fileName);

      if(!_bProject)
      {
         suggested_pathname = Utils.RemoveDirPrefix(dirName, _rootPath);
         current_project.markAsModified();
      }

      Global.Debug("Sample::loadFile: pathName=\""+_pathName+"\"");

      local File f;
      if(f.openLocal(Utils.ToNativePathName(_pathName), IOS_IN))
      {
         if(loadState(f, dirName, _bProject))
         {
            assignUniqueName(unique_name);

            if(_bRecalcPatches && b_procedural && STConfig.b_cycle_recalc_on_load)
               recalcCyclePatches();

            if(_bRecalcPatches && STConfig.b_patch_plugin_compile_on_load)
            {
               if(usesPatchPlugins())
               {
                  local String sMsgAll;
                  local Integer numFailed = 0;
                  local HashTable idMap; idMap.alloc(3000);  // for sample specific patch plugins
                  int numExported = compileAllPatchPlugins(sMsgAll, numFailed, idMap, false/*bForce*/);

                  local StringArray patchPluginIds;
                  current_project.findPatchPluginIds(patchPluginIds);  // find all referenced patch plugins (last_compiled_plugin_id)
                  // (note) must rescan patch-plugins:
                  //         the plugin may already be compiled/cached (numExported=0) but it may not have been loaded, yet
                  current_project.reloadAllVoicePluginsRemap(idMap,
                                                             patchPluginIds,
                                                             false/*bRescanGlobal*/,
                                                             true/*bRescanPatch*/
                                                             );
                  trace "[...] Sample::loadFile: rebuilt "+numExported+" Cycle STFX plugin"+Utils.GetPluralString(numExported)+" ("+numFailed+" failed to compile):\n"+sMsgAll;

                  if(!_bProject && numExported > 0 && STConfig.b_patch_plugin_resave_patch_on_recompile)
                  {
                     // helper for updating patches after code-generator update (and .c file checksums have changed)
                     trace "[dbg] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
                     trace "[dbg] Sample::loadFile: re-save patch to \""+_pathName+"\" after codegen/checksum update";
                     trace "[dbg] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
                     saveFile(_pathName, _rootPath, false/*bProject*/, 0/*sampleIdx(ignored)*/);
                  }

               }
            }

            if(requiresResynthesis())
               analyzeAndUpdatePartials();

            return = true;
         }
         else
         {
            trace "[---] Sample::loadFile: loadState() failed.";
         }
         f.close();
      }
      else
      {
         trace "[---] Sample::loadFile: failed to open \""+_pathName+"\" for reading";
      }

      Audio.PopSuppressUnderrunError(bOldSuppressUnderrunError);

      return;
   }

   // <method_get.png>
   public method findFirstLiveRecZoneIdx() : int {
      StSample s <= sample_bank.firstSample;
      int zoneIdx = 0;
      while(null != s)
      {
         if(s.liveRecEnable)
            return zoneIdx;
         s <= s.next;
         zoneIdx++;
      }
      return -1;
   }

   // <method.png>
   public =replay= method assignPadZones(PointerArray _zones, int _padNote) {
      if(_zones.numElements > 0)
      {
         StSample *s;
         foreach s in _zones
         {
            StRange range <= s.getOrCreateKeyRange();
            range.lo = _padNote;
            range.hi = _padNote;
            s.setTransposeAndUpdateOctSemi(KEY_MIDDLE_C - _padNote);
         }
         markParamsAsModified();
      }
   }

   // <method_set.png>
   public =replay= method setLiveRecSampleBank(StSamplePlayer _sp) {
      _sp.setLiveRecSampleBank(sample_bank);
   }

   // <method.png>
   public method verifyAllSampleAreas() {
      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         s.verifySampleAreas();
         s <= s.next;
      }
   }

   // <method_get.png>
   public method isMono() : boolean {
      return (1 == waveform.numChannels);
   }

   // <method_update.png>
   public method recalcCyclePatches() : int {
      int numPatches = 0;
      CyclePatch *sp;
      foreach sp in cycle_state.patches
      {
         if(sp.isUsed())
         {
            if(sp.target_zone_idx >= 0)  // targets sample zone ?
            {
               try
               {
                  sp.recalc(this, false/*bMessage*/);

                  if(requiresResynthesis())
                  {
                     analyzeAndUpdatePartials();
                  }
               }
               catch(Error e)
               {
                  // Should not be reachable
                  trace "[---] Sample:.recalcCyclePatches: this="+unique_name+": caught exception e.name=\""+e.name+"\" e.msg=\""+e.message+"\"";
                  trace e.stackTrace;
                  return -1;
               }
            }
            else if(CyclePatch.TARGET_ZONE_PATCH_PLUGIN == sp.target_zone_idx)
            {
            }
            numPatches++;
         }
      }
      return numPatches;
   }

   // <method_get.png>
   public method calcDurationInMillisecondsAtFreq(float _freq) : float {
      StSample s <= sample_bank.firstSample;
      if(null != s)
      {
         // see StSampleVoice::freqToSampleRate()
         float rate = (_freq / waveform.baseFrequency) * (waveform.sampleRate * s.sampleRateRatio);
         float ms = 1000.0f * (s.firstLen / rate);
         return ms;
      }
      return 0.0f;
   }

   // <method.png>
   public method findSamplePeaks(FloatArray _peaks, float _peaksIntervalMs) : float {
      // returns inverse normalization factor (absMax)
      _peaks.empty();
      float intervalSamples = ( (waveform.numChannels * waveform.sampleRate) / 1000.0) * _peaksIntervalMs;
      FloatArray fa <= waveform.sampleData;
      int numPeaks = fa.numElements / intervalSamples;
      if(null != fa)
      {
         FloatArray faTmp;
         float smpOff = 0;
         loop(numPeaks)
         {
            smpOff &= ~1;
            faTmp.visit(fa, smpOff, intervalSamples);
            // trace "xxx faTmp="+#(faTmp);
            _peaks.add(mathMinf(1.0, faTmp.absMean));
            smpOff += intervalSamples;
         }
      }
      float m = _peaks.absMax;
      if(m > 0.01)  // don't boost background noise
         _peaks.scale(_peaks, 1.0/m);
      return m;
   }

   // <method_get.png>
   public method getOrCreateCachedSamplePeaks() : FloatArray {
      if(cached_sample_peaks.isEmpty())
      {
         cached_sample_peaks_denorm_factor = findSamplePeaks(cached_sample_peaks, 1.0f/*peaksIntervalMs*/);
      }
      return cached_sample_peaks;
   }

   // <method_get.png>
   public method requiresResynthesis() : boolean {
      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         if(s.enableTimestretchAdditive)
            return true;
         s <= s.next;
      }
      return false;
   }

   // <method.png>
   public method analyzePartials() : boolean {

      // Find cycle length and crossfade amount (first additive wavetable zone)
      float cycleLenF = 0;
      float cycleXFadeAmt = 0;
      StSample s <= sample_bank.firstSample;
      while(null != s)
      {
         if(s.enableTimestretchAdditive)
         {
            cycleLenF     = s.timestretchGranularity;
            cycleXFadeAmt = s.timestretchAdditiveXFade;
            break;
         }
         s <= s.next;
      }

      if(cycleLenF >= 8)
      {
         int t = milliSeconds();

         int numFrames = waveform.getNumFrames();
         int numWaves = numFrames / cycleLenF;
         if(numWaves > 256)
         {
            Global.Debug("Sample::analyzePartials: clipping numWaves="+numWaves+" to 256");
            numWaves = 256;
         }

         if(numWaves > 0)
         {
            if(null == partial_magnitudes)
            {
               partial_magnitudes <= new FloatArray;
               partial_magnitudes.allocAndFill(256 * 256, 0);
            }

            if(null == partial_speeds)
            {
               partial_speeds <= new FloatArray;
               partial_speeds.allocAndFill(256 * 256, 0);
            }

            if(null == partial_phases)
            {
               partial_phases <= new FloatArray;
               partial_phases.allocAndFill(256 * 256, 0);
            }

            local StFFT fft;
            int fftBits = partial_window_bits;
            int fftWinSize = (1 << fftBits);
            fft.setWindowSize(fftBits);
            if(b_partial_cos_win)
               fft.setEnableWindow(1/*cos*/);
            else
               fft.setEnableWindow(2/*tri*/);

            int phaseShiftNumFrames = b_partial_true_freq ? 16 : 0;
            local FloatArray inputBuf;
            inputBuf.allocAndFill(fftWinSize + phaseShiftNumFrames, 0); // 2048
            // // inputBuf.useAll();

            // fft.setEnableMagnitudeScaling(false);
            fft.setEnableMagnitudeScaling(true);
            fft.setInputSamples(inputBuf, 1/*numCh*/, null/*img*/, 0/*imgSkip*/);
            int fftOffset = fftWinSize/2;
            int numBins = fftWinSize/2 +1;
            local FloatArray magnitudes; magnitudes.alloc(numBins);
            local IntArray magnitudesSortIndices; magnitudesSortIndices.allocAndFill(numBins, 0);
            local FloatArray phases; phases.alloc(numBins);
            local FloatArray phases2;
            if(b_partial_true_freq)
               phases2.alloc(numBins);

            int partialDstOff = 0;
            FloatArray smpDat <= waveform.sampleData;
            local FloatArray  smpDatLoopRef;
            local FloatArray *smpDatLoopCur;

            int   cycleXFadeNum = cycleLenF * cycleXFadeAmt;
            local FloatArray smpDatLoopX; smpDatLoopX.allocAndFill(cycleXFadeNum, 0);

            int   waveIdx = 0;
            float srcOff = 0.0f;
            int   dstOff = 0;
            int   cycleLenI = round(cycleLenF);

            loop(numWaves)
            {
               // Repeat input cycle to fill FFT input buffer

               // // copy_looped_samples writes 0 after loop end
               // // // tksampleedit_copy_looped_samples_mono(inputBuf, dstOff,
               // // //                                       smpDat, srcOff,
               // // //                                       srcOff/*loopStart*/,
               // // //                                       (srcOff+_cycleLen)/*loopEnd*/,
               // // //                                       fftWinSize/*numFrames*/
               // // //                                       );

               // clip last cycle
               int srcOffI = round(srcOff);
               if(srcOffI + cycleLenI > smpDat.numElements)
                  srcOffI = smpDat.numElements - cycleLenI;

               if(cycleXFadeNum > 0 && srcOffI >= cycleXFadeNum && cycleLenI >= cycleXFadeNum)
               {
                  int i = 0;
                  int j = srcOffI;
                  loop(cycleLenI - cycleXFadeNum)
                     smpDatLoopX[i++] = smpDat[j++];
                  float fXFade = 0;
                  float fXFadeStep = (1.0f / cycleXFadeNum);
                  int k = srcOffI - cycleXFadeNum;
                  loop(cycleXFadeNum)
                  {
                     smpDatLoopX[i++] = mathLerpf(smpDat[j++], smpDat[k++], fXFade);
                     fXFade += fXFadeStep;
                  }

                  smpDatLoopCur <= smpDatLoopX;
               }
               else
               {
                  smpDatLoopRef.visit(smpDat, srcOffI, cycleLenI);
                  smpDatLoopCur <= smpDatLoopRef;
               }

               tksampleedit_ringbuf_copy_samples(inputBuf, 1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                                 inputBuf.numElements/*numFrames*/, 1/*numCh*/,
                                                 smpDatLoopCur, 1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                                 );

               // trace "xxx inputBuf="+inputBuf.string;

               fft.fft(fftOffset, 0/*inChOffset*/);
               // trace "xxx fft returned";
               int magNumBins = fft.calcMagnitudes(magnitudes);
               // trace "xxx calcMagnitudes returned magNumBins="+magNumBins;
               // trace "xxx magnitudes="+magnitudes.string;
               magnitudes.fixNaNToZero();
               // trace "xxx fixNaN magnitudes="+#(magnitudes);
               // trace "xxx call sortByValue";

               // if(1)
               //    magnitudesSortIndices.identity(numBins);
               // else
                  magnitudes.sortByValue(magnitudesSortIndices);

               // trace "xxx sortByValue returned";
               // trace "xxx magnitudesSortIndices="+#(magnitudesSortIndices);
               // trace "xxx magnitudesSortIndices.numElements="+magnitudesSortIndices.numElements;

               fft.calcPhases(phases);

               // Repeat FFT to find true frequency
               if(b_partial_true_freq)
               {
                  local FloatArray inputBuf2;
                  inputBuf2.visit(inputBuf, phaseShiftNumFrames, inputBuf.numElements-phaseShiftNumFrames);
                  fft.setInputSamples(inputBuf2, 1/*numCh*/, null/*img*/, 0/*imgSkip*/);
                  fft.fft(fftOffset, 0/*inChOffset*/);
                  fft.calcPhases(phases2);
               }

               // Pick the 256 loudest partials
               int sortIdx = magnitudesSortIndices.numElements;
               // trace "xxx numBins="+numBins;
               loop(mathMini(numBins,256))
               {
                  int sortedIdx = magnitudesSortIndices[--sortIdx];
                  // partial_magnitudes[partialDstOff]   = magnitudes[sortedIdx];
                  float partialMag = mathPowerf(magnitudes[sortedIdx], partial_mag_exp) * mathPowerf(sortedIdx, partial_mag_bin_exp);
                  partial_magnitudes[partialDstOff] = mathClampf(partialMag, -1, 1);
                  float w;

                  if(b_partial_true_freq)
                  {
                     float phase1 = phases[sortedIdx];  // -PI..PI
                     // trace "xxx phases["+sortedIdx+"] = "+phase1;
                     float phase2 = phases2[sortedIdx];
                     if(phase2 < phase1)
                        phase2 += 2PI;
                     float phaseDelta = phase2 - phase1;

                     float binFreq = (sortedIdx * waveform.sampleRate/* * 0.5*/) / numBins;
                     float binPeriodSz = (waveform.sampleRate / binFreq);
                     float expectedPhaseDelta = (2PI * phaseShiftNumFrames) / binPeriodSz;
                     // trace "xxx phaseDelta="+phaseDelta+" expectedPhaseDelta="+expectedPhaseDelta;
                     float actualBinFreq = (binFreq * phaseDelta) / expectedPhaseDelta;
                     // partial_speeds[partialDstOff] = binFreq / waveform.sampleRate;
                     partial_speeds[partialDstOff] = mathPowerf(binFreq / waveform.sampleRate, partial_speed_exp) * mathPowerf(sortedIdx, partial_bin_exp);
                  }
                  else
                  {
                     // partial_speeds[partialDstOff] = float(sortedIdx) / numBins;
                     partial_speeds[partialDstOff] = mathPowerf(float(sortedIdx) / numBins, partial_speed_exp) * mathPowerf(sortedIdx, partial_bin_exp);
                  }
                  partial_phases[partialDstOff++] = (phases[sortedIdx] + PI) / 2PI;
               }

               if(numBins < 256)
                  partialDstOff += 256 - numBins;

               // if(0 == waveIdx)
               // {
               //    int partialIdx = 0;
               //    loop(256)
               //    {
               //       trace "xxx partials["+partialIdx+"] mag="+partial_magnitudes[partialIdx]+" speed="+partial_speeds[partialIdx];
               //       partialIdx++;
               //    }
               // }

               // Next wave
               waveIdx++;
               srcOff += cycleLenF;
            }

            t = milliSeconds() - t;
            Global.Debug("Sample::analyzePartials: numWaves="+numWaves+" bCosWin="+b_partial_cos_win+" bTrueFreq="+b_partial_true_freq+" t="+t+"ms");

            num_partial_waves = numWaves;

            Audio.ResetUnderrunProtection();

            return true;
         }
         else
         {
            Global.Error("Sample::analyzePartials: numWaves=0 => sample is too short");
         }
      }
      else
      {
         Global.Error("Sample::analyzePartials: invalid cycleLen="+cycleLenF+" (must be >= 8, should be 1024 or 2048)");
      }
      return false;
   }

   // <method_update.png>
   public =replay= method updateZonePartials(StSample _zone, FloatArray _magnitudes, FloatArray _speeds, FloatArray _phases) {
      _zone.partialMagnitudes = _magnitudes;
      _zone.partialSpeeds     = _speeds;
      _zone.partialPhases     = _phases;
   }

   // <method_set.png>
   public =replay= method setPartialWindowBits(int _num) {
      partial_window_bits = mathClampi(_num, 5/*9*/, 13);
   }

   // <method_get.png>
   public method getPartialWindowBits() : int {
      return partial_window_bits;
   }

   // <method_set.png>
   public method setEnablePartialCosWin(boolean _bEnable) {
      b_partial_cos_win = _bEnable;
   }

   // <method_set.png>
   public method setEnablePartialTrueFreq(boolean _bEnable) {
      b_partial_true_freq = _bEnable;
   }

   // <method_update.png>
   public method analyzeAndUpdatePartials() : boolean {
      StSample s <= sample_bank.firstSample;
      boolean bAnalyzeOk = false;
      while(null != s)
      {
         if(s.enableTimestretchAdditive)
         {
            if(!bAnalyzeOk)
               bAnalyzeOk = analyzePartials();

            if(bAnalyzeOk)
            {
               updateZonePartials(s, partial_magnitudes, partial_speeds, partial_phases);
            }
            else
            {
               updateZonePartials(s, null, null, null);
            }
         }
         s <= s.next;
      }
      return bAnalyzeOk;
   }

   // <method.png>
   public method findRootKeyForArea(int        _off,
                                    int        _numFrames,
                                    float      _prefilterCutOff,
                                    float      _sampleRate,
                                    boolean    _bQuiet,
                                    FloatArray _retMagnitudesOrNull,
                                    IntArray   _retMagnitudesSortIndicesOrNull,
                                    Float      _retFreqHzOrNull
                                    ) {
      // (note) caller must validate area + make sure that numFrames is >= 512

      int phaseShiftNumFrames = 16;

      if( (_numFrames + _off) > waveform.numFrames )
         _numFrames = waveform.numFrames - _off;

      int fftBits;
      if(_numFrames >= (8192+phaseShiftNumFrames))
         fftBits = 13;
      else if(_numFrames >= (4096+phaseShiftNumFrames))
         fftBits = 12;
      else if(_numFrames >= (2048+phaseShiftNumFrames))
         fftBits = 11;
      else if(_numFrames >= (1024+phaseShiftNumFrames))
         fftBits = 10;
      else if(_numFrames >= (512+phaseShiftNumFrames))
         fftBits = 9;

      int fftWinSize = (1 << fftBits);

      if(!_bQuiet)
         Global.Debug("Sample::findRootKeyForArea: off="+_off+" numFrames="+_numFrames+" fftWinSize="+fftWinSize);

      local FloatArray smpDat;
      smpDat.visit(waveform.sampleData, _off, _numFrames * waveform.numChannels);
      local FloatArray inputBuf;

      if(2 == waveform.numChannels)
      {
         // Copy left channel to mono buffer
         inputBuf.alloc(fftWinSize+phaseShiftNumFrames);
         inputBuf.useAll();

         // // local FloatArray smpDatLoop;
         // // smpDatLoop.visit(smpDat, _off, _numFrames);
         tksampleedit_ringbuf_copy_samples(inputBuf, 1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                           inputBuf.numElements/*numFrames*/, 1/*numCh*/,
                                           smpDat, waveform.numChannels/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                           );
      }
      else if(_prefilterCutOff > 0.99)
      {
         // Mono input (zero-copy)
         inputBuf <= smpDat;
      }
      else
      {
         // Mono input (pre-filter)
         inputBuf.alloc(fftWinSize+phaseShiftNumFrames);
         inputBuf.useAll();

         // // local FloatArray smpDatLoop;
         // // smpDatLoop.visit(smpDat, _off, _numFrames);
         tksampleedit_ringbuf_copy_samples(inputBuf, 1/*dstNumCh*/, 0/*dstChOff*/, 0/*dstFrameOff*/,
                                           inputBuf.numElements/*numFrames*/, 1/*numCh*/,
                                           smpDat, 1/*srcNumCh*/, 0/*srcChOff*/, 0/*srcFrameOff*/
                                           );
      }

      if(_prefilterCutOff < 1.0)
      {
         Global.Debug("Sample::findRootKeyForArea: pre-filter cutoff="+_prefilterCutOff);
         loop(4)
            inputBuf.biquad(inputBuf, 1/*LPF*/, 0.0/*dbGain*/, _prefilterCutOff/*freq*/, 0.0/*res*/);

         // // WavIO.SaveLocal("debuglpf.wav", inputBuf, 44100, 1);
         // // loop(1)
         // //    smpDat.biquad(smpDat, 1/*LPF*/, 0.0/*dbGain*/, _prefilterCutOff/*freq*/, 0.0/*res*/);
      }

      local StFFT fft;
      fft.setWindowSize(fftBits);
      fft.setEnableWindow(2/*tri*/);
      fft.setEnableMagnitudeScaling(true);
      fft.setInputSamples(inputBuf, 1/*numCh*/, null/*img*/, 0/*imgSkip*/);
      int fftOffset = fftWinSize/2;
      int numBins = fftWinSize/2 +1;
      local FloatArray magnitudes; magnitudes.alloc(numBins);
      local IntArray magnitudesSortIndices; magnitudesSortIndices.allocAndFill(numBins, 0);
      local FloatArray phases; phases.alloc(numBins);

      fft.fft(fftOffset, 0/*inChOffset*/);
      int magNumBins = fft.calcMagnitudes(magnitudes);
      magnitudes.fixNaNToZero();
      magnitudes[0] = 0.0f;  // [24Feb2024] hi-cut ("root key too low")
      magnitudes[1] = 0.0f;  // [24Feb2024] hi-cut ("root key too low")
      if(null != _retMagnitudesOrNull)
         _retMagnitudesOrNull = magnitudes;
      magnitudes.sortByValue(magnitudesSortIndices);
      if(null != _retMagnitudesSortIndicesOrNull)
         _retMagnitudesSortIndicesOrNull = magnitudesSortIndices;
      fft.calcPhases(phases);

      int sortedIdx = magnitudesSortIndices.last;

      // Repeat FFT to find true frequency
      local FloatArray inputBuf2;
      inputBuf2.visit(inputBuf, phaseShiftNumFrames, inputBuf.numElements-phaseShiftNumFrames);
      local FloatArray phases2; phases2.alloc(numBins);
      fft.setInputSamples(inputBuf2, 1/*numCh*/, null/*img*/, 0/*imgSkip*/);
      fft.fft(fftOffset, 0/*inChOffset*/);
      fft.calcPhases(phases2);

      float phase1 = phases[sortedIdx];
      float phase2 = phases2[sortedIdx];
      if(phase2 < phase1)
         phase2 += 2PI;
      float phaseDelta = phase2 - phase1;

      float binFreq = (sortedIdx * _sampleRate * 0.5) / numBins;
      float binPeriodSz = (_sampleRate / binFreq);
      float expectedPhaseDelta = (2PI * phaseShiftNumFrames) / binPeriodSz;
      // trace "xxx phaseDelta="+phaseDelta+" expectedPhaseDelta="+expectedPhaseDelta;
      float actualBinFreq = (binFreq * phaseDelta) / expectedPhaseDelta;

      if(null != _retFreqHzOrNull)
         _retFreqHzOrNull = actualBinFreq;

      float note = Audio.FreqToFracNote(actualBinFreq);

      if(!_bQuiet)
         Global.Debug2("Sample::findRootKeyForArea: binRes="+(_sampleRate*0.5/numBins)+"Hz, sortedIdx="+sortedIdx+", binFreq="+binFreq+" => actualFreq="+actualBinFreq+" MIDI-note="+note);

      return note;
   }

   // <method_get.png>
   public method getWaveformNumSamples() : int {
      FloatArray smpDat <= waveform.sampleData;
      return smpDat.numElements;
   }

   // <method_get.png>
   public method getWaveformNumFrames() : int {
      return waveform.numFrames;
   }

   // <method_get.png>
   public method getWaveformSampleRate() : float {
      return waveform.sampleRate;
   }

   // <method_get.png>
   public method unlinkWaveformAndLoadInit() : StWaveform {
      StWaveform r <= deref waveform;

      waveform <= new StWaveform;
      waveform.alloc(1/*ch*/, 1/*frames*/);  // create sampleData FloatArray
      waveform.sampleRate = STConfig.audio_mixrate;
      waveform.baseFrequency = BASE_FREQ_MIDDLE_C;

      return deref r;
   }

   // <method_get.png>
   public method setWaveform(StWaveform _wf) {
      // override waveform, e.g. when loading audio clip preset sample
      waveform <= deref _wf;
   }

   // <method_get.png>
   public method isStereo() : boolean {
      return (2 == waveform.numChannels);
   }

   // <method.png>
   public method compileAllPatchPlugins(local String _sMsgAll, Integer numFailed, HashTable _idMap, boolean _bForce) : int {
      CyclePatch *patch;
      int numExported = 0;
      foreach patch in cycle_state.patches
      {
         if(patch.targetsPatchPlugin())
         {
            boolean bCompile = _bForce || !patch.targetVoicePluginExists();
            Global.Debug("Sample::compileAllPatchPlugins: sample.unique_name=\""+unique_name+"\" bCompile="+bCompile);
            if(bCompile)
            {
               if(patch.recalcExportPlugin(this, false/*bMessage*/, false/*bReload*/, _idMap))
               {
                  local String sMsg <= "Export STFX patch plugin \""+(patch.cycle.plugin_id)+"\"";
                  Global.PrintFast(sMsg);
                  _sMsgAll +="        + \""+(patch.cycle.plugin_id)+"\"\n";
                  trace "[...] "+sMsg;
                  numExported++;
                  trace "[+++] Sample::compileAllPatchPlugins: sample.unique_name=\""+unique_name+"\" built pluginId=\""+patch.last_compiled_plugin_id+"\"";
               }
               else if(null != patch.cycle)
               {
                  if(!((patch.cycle.plugin_id).isBlank()))
                  {
                     numFailed++;
                     trace "[~~~] Sample::compileAllPatchPlugins: sample.unique_name=\""+unique_name+"\" patch plugin compilation FAILED";
                  }
               }
            }
            else
            {
               trace "[...] Sample::compileAllPatchPlugins: sample.unique_name=\""+unique_name+"\" re-use cached pluginId=\""+patch.last_compiled_plugin_id+"\"";
            }
         }
      }
      return numExported;
   }

   // <method.png>
   protected static BuildMergedZoneNr(Sample _o, StSample _zoneO, int _zoneONr) : String {
      local String r = _o.unique_name;
      String sName <= _zoneO.name;
      if(null != sName && !sName.isBlank())
      {
         r.append(".");
         r.append(_zoneO.name);
      }
      else if(_o.getNumZones() >= 2)
      {
         r.append(".z");
         r.append(String(_zoneONr));
      }
      return deref r;
   }

   // <method.png>
   public method mergeSample(Sample _o, float _volumeScl, float _pan) {
      // called by PageSample.handleMergeNextSample() and PageTrack.handleMergeSamples2()
      //  (note) 'this' sample volume should be 1.0 (see multiplyZoneVolumesBySampleVolumeAndReplaceByOne())
      //  (note) 'this' sample pan should be 0.0 (see addSamplePanToZonesAndReplaceByZero())
      FloatArray smpDat <= waveform.sampleData;
      StWaveform wfNext <= _o.waveform;
      FloatArray smpDatNext <= wfNext.sampleData;
      int numFramesPrev = waveform.getNumFrames();
      int numFramesNext = wfNext.getNumFrames();

      smpDat.realloc(numFramesPrev*waveform.numChannels + numFramesNext*waveform.numChannels);
      smpDat.useAll();

      // Copy samples to new region
      if(isMono())
      {
         if(_o.isMono())
         {
            // Mono=>Mono
            smpDat.copyFrom(smpDatNext, 0/*off*/, numFramesNext/*len*/, numFramesPrev/*doff*/);
         }
         else
         {
            // Stereo=>Mono (Skip right channel)
            tksampleedit_copy_mono_adv_to_mono(smpDat, numFramesPrev/*outOff*/,
                                               smpDatNext/*faIn*/, 0/*inOff*/, 2/*inAdv*/,
                                               numFramesNext
                                               );
         }
      }
      else
      {
         if(_o.isMono())
         {
            // Mono=>Stereo
            tksampleedit_copy_mono_to_stereo(smpDat, numFramesPrev*2/*outOff*/,
                                             smpDatNext/*faIn*/, 0/*inOff*/,
                                             numFramesNext
                                             );
         }
         else
         {
            // Stereo=>Stereo
            smpDat.copyFrom(smpDatNext, 0, numFramesNext*2, numFramesPrev*2);
         }
      }

      StSample zoneO <= _o.getZoneByIdx(0);
      float tr = _o.getTranspose() - getTranspose();
      // // float thisVol = getVolume();
      float oVol = _o.getVolume();
      float oPan = _o.getPan();
      int zoneShift = getNumZones();
      local String zoneName;
      int zoneONr = 1;
      while(null != zoneO)
      {
         StSample zone <= newZone();
         Samples.CopySample(zone, zoneO, -1/*appendixNr*/, true/*bCopyName*/, false/*bCopyWaveform*/);
         Samples.ShiftSampleStartOffsets(zone, numFramesPrev);
         Samples.TryConvertFromStartFlagToSampleLoop(zone, numFramesPrev/*off*/, numFramesNext/*num*/);
         zone.setSampleRateRatio( (wfNext.sampleRate * zoneO.sampleRateRatio) / waveform.sampleRate );
         zone.volume = (zone.volume * oVol * _volumeScl);
         zone.pan    = mathClampf(zone.pan + oPan + _pan, -1.0f, 1.0f);
         zone.name   = BuildMergedZoneNr(_o, zoneO, zoneONr);

         // Align transpose
         if(0.0f != tr)
         {
            Global.Debug2("Sample::mergeSample: zone.name=\""+zone.name+"\" zone.transpose="+zone.transpose+" tr="+tr+"   update to (zone.transpose + tr)="+(zone.transpose + tr));
            zone.setTransposeAndUpdateOctSemiCents(zone.transpose + tr);
            Global.Debug2("Sample::mergeSample:    => zone.transpose="+zone.transpose);
         }

         // Merge Cycle patches
         cycle_state.mergePatchesFrom(_o.cycle_state, zoneShift);

         // Next zone
         zoneO <= zoneO.next;
         zoneShift++;
         zoneONr++;
      }

   }

   // <method_get.png>
   public method usesPatchPlugins() : boolean {
      CyclePatch *sp;
      foreach sp in cycle_state.patches
      {
         if(CyclePatch.TARGET_ZONE_PATCH_PLUGIN == sp.target_zone_idx)
            return true;
      }
      return false;
   }

   // <method_find.png>
   public method findAutoAddTags() : StringArray {
      local StringArray aRet;
      StSample *zone;
      local String sUniqueNameLC <= unique_name.toLower();

      boolean bTest = (sUniqueNameLC & "test") || (sUniqueNameLC & "debug");
      if(bTest)
         Utils.AddUniqueStringToArray(aRet, "test");

      boolean bHard = (sUniqueNameLC & "hard");
      if(bHard)
         Utils.AddUniqueStringToArray(aRet, "hard");

      boolean bSoft = (sUniqueNameLC & "soft");
      if(bSoft)
         Utils.AddUniqueStringToArray(aRet, "soft");

      boolean bNoise = (sUniqueNameLC & "noise");
      if(bNoise)
         Utils.AddUniqueStringToArray(aRet, "noise");

      boolean bShort = (sUniqueNameLC & "short") || (sUniqueNameLC & "shrt");
      if(bShort)
         Utils.AddUniqueStringToArray(aRet, "short");

      boolean bLong = (sUniqueNameLC & "long");
      // (note) "long" tag added below

      boolean bLoFi = (waveform.getSampleRate() < 30000);
      bLoFi |= (sUniqueNameLC & "lofi");
      // (note) "lofi" tag added below

      boolean bSeq = (sUniqueNameLC & "seq");
      if(bSeq)
         Utils.AddUniqueStringToArray(aRet, "seq");

      boolean bChip = (sUniqueNameLC & "chip");
      if(bChip)
         Utils.AddUniqueStringToArray(aRet, "chip");

      // Add tags from sample filter categories
      //  - id or long name match, e.g. "ky" or "keys"
      local String relPath = suggested_pathname;
      if(relPath <= "/")
         relPath.substring(1, 999);
      if(relPath >= "/")
         relPath.substring(0, relPath.numChars);
      relPath.replace("//", "/");
      local SampleFilterCategory *[] aCat;
      Samples.FindSampleFilterCategoriesByUniqueNameAndRelPath(sUniqueNameLC, relPath, aCat);
      trace "[trc] Sample::findAutoAddTags: relPath=\""+relPath+"\" #cat="+aCat.numElements;
      SampleFilterCategory *cat;
      StringArray aTagsAll <= Samples.all_tags;
      trace "[trc] Sample::findAutoAddTags: aTagsAll="+aTagsAll;
      String *sTag;
      local String sCatNameLC;
      local String sCatLongNameLC;
      foreach cat in aCat
      {
         sCatNameLC <= cat.name.toLower();
         sCatLongNameLC <= cat.long_name.toLower();
         trace "[trc]     catNameLC=\""+sCatNameLC+"\" catLongNameLC=\""+sCatLongNameLC+"\" bCatNameLC="+aTagsAll.containsObject(sCatNameLC)+" bCatLongNameLC="+aTagsAll.containsObject(sCatLongNameLC);
         if(aTagsAll.containsObject(sCatNameLC))
            Utils.AddUniqueStringToArray(aRet, sCatNameLC);
         else if(aTagsAll.containsObject(sCatLongNameLC))
            Utils.AddUniqueStringToArray(aRet, sCatLongNameLC);

         // hardcoded: map "tm" to "tom"
         if(sCatNameLC == "tm")
         {
            Utils.AddUniqueStringToArray(aRet, "tom");
            Utils.AddUniqueStringToArray(aRet, "perc");
         }

         // hardcoded: map "zp" to "zap"
         if(sCatNameLC == "zp")
         {
            Utils.AddUniqueStringToArray(aRet, "zap");
            Utils.AddUniqueStringToArray(aRet, "perc");
         }

         // hardcoded: map "st" to "stab"
         if(sCatNameLC == "st")
         {
            Utils.AddUniqueStringToArray(aRet, "stab");
         }

         // hardcoded: map other perc categories to "perc"
         if(["cr78", "cr8000", "606", "707", "727", "808", "909"].containsObject(sCatNameLC))
         {
            Utils.AddUniqueStringToArray(aRet, "perc");
         }
      }
      // trace "[trc] Sample::findAutoAddTags: tags added from cats: "+aRet;  // meow

      // Add tags from zone properties
      boolean bWT = false;
      boolean bWTAdditive = false;
      boolean bSTFX = false;
      boolean bFMStack = false;
      boolean bMulti = (getNumZones() > 2);
      boolean bStereo = (waveform.numChannels > 1);
      boolean bMono = false;
      boolean bPoly = false;
      boolean bGlide = false;
      boolean bLiveRec = false;
      int numPanNotCenter = 0;
      zone <= getZoneByIdx(0);
      while(null != zone)
      {
         if(zone.enableTimestretch)
         {
            bWT = true;
            if(zone.enableTimestretchAdditive)
               bWTAdditive = true;
         }
         if(zone.hasPluginsEnabled())
         {
            bSTFX = true;
            int pluginIdx = 0;
            loop(STSAMPLE_NUM_PLUGINS)
            {
               StPluginShared shared <= zone.getVoicePluginShared(pluginIdx);
               if(null != shared)
               {
                  StPluginInfo info <= shared.info;
                  if(info.id & "fm_stack")
                  {
                     bFMStack = true;
                     break;
                  }
               }
               pluginIdx++;
            }
         }
         if(0 != zone.bitReduction || 0 != zone.rateReduction)
            bLoFi = true;
         if(zone.numSampleLoops > 3)
            bMulti = true;
         if(zone.pan != 0.0f)
            numPanNotCenter++;
         // // if(zone.maxVoices > 1)
         // //    bPoly = true;
         if(1 == zone.maxVoices)
            bMono = true;
         // trace "xxx zone.glideType="+zone.glideType;
         if(STSAMPLE_GLIDE_NONE != zone.glideType)  // (mono or poly) glide ?
            bGlide = true;
         if(zone.liveRecEnable)
            bLiveRec = true;

         if(0)
         {
            // check volume release time
            StADSR adsrVol <= zone.getVolADSR();
            if(null != adsrVol)
            {
               StEnvelope envVolR <= adsrVol.getEnvRelease();
               if(null != envVolR)
               {
                  // trace "xxx envVolR.timescale="+envVolR.timescale;
                  if(envVolR.timescale < 25)
                     bLong = true;
               }
            }
         }

         zone <= zone.next;
      }
      if(1 == sample_bank.maxVoices )
      {
         bPoly = false;
         bMono = true;
      }
      if(numPanNotCenter >= 2)
         bStereo = true;
      if(bWT)
         Utils.AddUniqueStringToArray(aRet, "wt");
      if(bWTAdditive)
         Utils.AddUniqueStringToArray(aRet, "additive");
      if(bSTFX)
         Utils.AddUniqueStringToArray(aRet, "stfx");
      if(bFMStack)
         Utils.AddUniqueStringToArray(aRet, "fmstack");
      if(bMulti)
         Utils.AddUniqueStringToArray(aRet, "multi");
      if(bStereo)
         Utils.AddUniqueStringToArray(aRet, "stereo");
      if(bPoly)
         Utils.AddUniqueStringToArray(aRet, "poly");
      if(bMono)
         Utils.AddUniqueStringToArray(aRet, "mono");
      if(bGlide)
         Utils.AddUniqueStringToArray(aRet, "glide");
      if(bLiveRec)
         Utils.AddUniqueStringToArray(aRet, "liverec");
      if(bLong)
         Utils.AddUniqueStringToArray(aRet, "long");
      // trace "[trc] Sample::findAutoAddTags: tags after zone props: "+aRet;

      // Add tags from Cycle Patch properties
      boolean bCycle = false;
      boolean bCyclePrecalc = false;
      if(null != cycle_state)
      {
         CyclePatch *cyPatch;
         foreach cyPatch in cycle_state.patches
         {
            if(CyclePatch.TARGET_ZONE_NONE != cyPatch.target_zone_idx)
            {
               bCycle = true;
               if(cyPatch.target_zone_idx >= 0)  // <0: global or patch plugin (STFX), >=0: precalc target zone
                  bCyclePrecalc = !cyPatch.isPlugin();
               if(cyPatch.b_lofi)
                  bLoFi = true;
            }
         }
      }
      if(bCycle)
         Utils.AddUniqueStringToArray(aRet, "cycle");
      if(bCyclePrecalc)
         Utils.AddUniqueStringToArray(aRet, "precalc");
      if(bLoFi)
         Utils.AddUniqueStringToArray(aRet, "lofi");
      // trace "[trc] Sample::findAutoAddTags: tags after cycle props: "+aRet;

      // (note) hardcoded "Perc" category name
      StringArray *aTagsCat;
      int catIdx = 0;
      StringArray aCatNames <= STConfig.sample_tags_cat_names;
      foreach aTagsCat in STConfig.sample_tags
      {
         if("Perc" == aCatNames.get(catIdx))
         {
            trace "[trc] check cat Perc  aRet="+aRet+"  aTagsCat="+aTagsCat;
            if(Utils.StringArrayContainsAny(aRet, aTagsCat))  // when bd,sd,cp,hh,.. then also add 'perc' tag
            {
               Utils.AddUniqueStringToArray(aRet, "perc");
               break;
            }
         }
         catIdx++;
      }
      // trace "[trc] Sample::findAutoAddTags: tags after Perc: "+aRet;

      // Add 'amiga' tag when sample rate is 16574Hz (usually set by amiga_init page cmd)
      if(16574 == waveform.getSampleRate())
         Utils.AddUniqueStringToArray(aRet, "amiga");

      // Sanitize
      if(aRet.containsObject("perc"))
      {
         aRet.remove("mono");
         aRet.remove("poly");
      }

      trace "[trc] Sample::findAutoAddTags: return tags: "+aRet;

      return deref aRet;
   }

   // <method_get.png>
   public method getZoneSamplePluginIndexByPluginShared(StSample _zone, StPluginShared _pluginShared) : int {
      int pluginIdx = 0;
      loop(STSAMPLE_NUM_PLUGINS)
      {
         if(@(_pluginShared) == @(_zone.getVoicePluginShared(pluginIdx)))
            return pluginIdx;
         pluginIdx++;
      }
      return -1;
   }

   // <method_get.png>
   public method getZoneSamplePluginById(StSample _zone, String _pluginId) : StPluginShared {
      // (note) prefer last plugin slot
      int pluginIdx = STSAMPLE_NUM_PLUGINS - 1;
      loop(STSAMPLE_NUM_PLUGINS)
      {
         StPluginShared pluginShared <= _zone.getVoicePluginShared(pluginIdx);
         if(null != pluginShared)
         {
            StPluginInfo pluginInfo <= pluginShared.info;
            if(pluginInfo.id == _pluginId)
               return pluginShared;
         }
         // Previous plugin slot
         pluginIdx--;
      }
      return null;
   }

   // <method.png>
   public method getOrCreateZoneSamplePluginById(StSample _zone, String _pluginId) : StPluginShared {
      // (note) prefer last plugin slot
      StPluginInfo pluginInfoRef <= VoicePlugins.FindVoicePluginInfoById(_pluginId);
      if(null != pluginInfoRef)
      {
         int pluginIdx = STSAMPLE_NUM_PLUGINS - 1;
         loop(STSAMPLE_NUM_PLUGINS)
         {
            StPluginShared pluginShared <= _zone.getVoicePluginShared(pluginIdx);
            if(null == pluginShared)
            {
               // Found empty plugin slot
               pluginShared <= pluginInfoRef.createSharedInstance();
               _zone.setVoicePluginShared(pluginIdx, #(deref pluginShared));
               return pluginShared;
            }
            else
            {
               // Plugin slot in use, check if it matches 'pluginId'
               StPluginInfo pluginInfo <= pluginShared.info;
               if(pluginInfo.id == _pluginId)
                  return pluginShared;
            }
            // Previous plugin slot
            pluginIdx--;
         }
      }
      return null;
   }

   // <method.png>
   public method loadAudioClipPreset() : boolean {
      StWaveform wfNew <= unlinkWaveformAndLoadInit();
      // trace "xxx loadAudioClipPreset: wfNew.numFrames="+wfNew.numFrames;
      StSample s <= sample_bank.firstSample;
      local IntArray aLoopsNew = s.getOrCreateSampleLoops();
      String sUniqueNameNew = unique_name;
      String sPathname = suggested_pathname;
      int sNSPIdx = namespace_idx;
      boolean bPresetLoaded =
         loadFile(STConfig.sample_rootpath
                  +"/"
                  +STConfig.pgsample_preset_relpath
                  +"/"
                  +STConfig.audio_clip_preset_sample,
                  STConfig.sample_rootpath,
                  false/*bProject*/,
                  false/*bRecalcPatches*/
                  );
      setWaveform(deref wfNew);
      unique_name = sUniqueNameNew;
      suggested_pathname = sPathname;
      namespace_idx = sNSPIdx;
      s <= sample_bank.firstSample;
      s.waveform = wfNew;
      IntArray aLoops <= s.getOrCreateSampleLoops();
      aLoops = aLoopsNew;
      // trace "xxx loadAudioClipPreset: restore aLoops="+#(aLoops);
      // trace "xxx loadAudioClipPreset: restore wfNew="+#(wfNew)+" wfNew.numFrames="+wfNew.numFrames;
      s.verifySampleAreas();
      Global.Debug("Sample::loadAudioClipPreset: restore CLIP aLoops="+#(aLoops));
      Global.Debug("Sample::loadAudioClipPreset: bPresetLoaded="+bPresetLoaded);
      return bPresetLoaded;
   }

   // <method_get.png>
   public method getTotalNumProcSeqEvents() : int {
      int r = 0;
      MIDIPipeFrame *fr;
      foreach fr in proc_seq_frames
         r += fr.numEvents;
      return r;
   }

   // <method.png>
   public =replay= method renderSourceTrack() {
      Track track <= current_project.getTrackByIdx(src_track_idx);
      if(null != track)
      {
         int wfNumFrames = waveform.numFrames;
         if(wfNumFrames > 0)
         {
            if(proc_seq_frames.numElements > 0)
            {
               boolean bOldSuppressUnderrunError = Audio.PushSuppressUnderrunError();

               FloatArray faSmp <= waveform.sampleData;
               boolean bStereo = (2 == waveform.numChannels);
               FloatArray mixBuf <= track.mix_buffer;

               MIDIPipeFrame frInput <= replay.midi_input_frame;
               frInput.empty();
               replay.b_have_events = false;
               replay.b_reset_all_controllers = true;

               // debug:
               // frInput.empty();
               // frInput.noteOn(true/*bSet*/, track.dev_idx, track.midi_ch, 60, 127, 0);
               // replay.b_have_events = true;

               // (note) assumes that (waveform.sampleRate == Audio.mix_rate)
               float framesPerTick = (Audio.mix_rate * 60.0f * 1.0f/*ticks*/) / (current_project.ppq * current_project.bpm);
               Global.Debug2("Sample::renderSourceTrack: uid="+unique_id+" wfNumFrames="+wfNumFrames+" framesPerTick="+framesPerTick);

               int dstFrameOff = 0;
               int framesLeft = wfNumFrames;
               int frIdx = 0;
               MIDIPipeFrame frSeq <= proc_seq_frames.first;
               int framesUntilNextEvent = frSeq.timeStamp * framesPerTick;
               int ticksLast = 0;
               local IntArray aPendingNoteOffs;  // absFrameOff,devIdx,midiCh,note
               int i;

               while(framesLeft > 0)
               {
                  int numFrames = mathMini(framesLeft, STConfig.audio_chunk_size/*64*/);

                  if(framesUntilNextEvent <= 0)
                  {
                     frInput = frSeq;
                     frInput.replaceDevIdxAndMidiCh(-1/*fltDev*/, -1/*fltCh*/,
                                                    track.dev_idx, mathMaxi(0, track.midi_ch)
                                                    );
                     replay.b_have_events = true;

                     if(frInput.numEventsNoteOn > 0)
                     {
                        int evIdx = 0;
                        local MIDIPipeEvent pev;
                        loop(frInput.numEventsNoteOn)
                        {
                           i = 0;
                           loop(aPendingNoteOffs.numElements / 4)
                           {
                              if(aPendingNoteOffs[i+1] == pev.devIdx &&
                                 aPendingNoteOffs[i+2] == pev.midiCh &&
                                 aPendingNoteOffs[i+3] == pev.note
                                 )
                              {
                                 // Force note-off before note-on
                                 frInput.noteOffPre(true/*bSet*/,
                                                    pev.devIdx,
                                                    pev.midiCh,
                                                    pev.note,
                                                    0/*vel*/
                                                    );
                                 aPendingNoteOffs.delete4(i);
                              }
                              else
                              {
                                 i += 4;
                              }
                           }

                           frInput.getEventByIdxAndFlt(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_ON, -1/*fltDev*/, -1/*fltCh*/);

                           // trace "xxx queue pending note-off at frameOff="+int(dstFrameOff + pev.duration * framesPerTick)+" note="+pev.note;
                           aPendingNoteOffs.add(dstFrameOff + pev.duration * framesPerTick);  // absFrameOff
                           aPendingNoteOffs.add(pev.devIdx);
                           aPendingNoteOffs.add(pev.midiCh);
                           aPendingNoteOffs.add(pev.note);

                           evIdx++;
                        }
                     }

                     frSeq <= proc_seq_frames.get(++frIdx);
                     if(null != frSeq)
                     {
                        framesUntilNextEvent = (frSeq.timeStamp - ticksLast) * framesPerTick;
                        ticksLast = frSeq.timeStamp;
                     }
                     else
                     {
                        framesUntilNextEvent = 999999999;
                     }
                  }

                  numFrames = mathMini(numFrames, framesUntilNextEvent);

                  // Find nearest note off event
                  i = 0;
                  int minNumFramesNoteOff = 999999999;
                  // trace "xxx aPendingNoteOffs.num="+(aPendingNoteOffs.numElements/4);
                  loop(aPendingNoteOffs.numElements / 4)
                  {
                     int noteOffFrameOff = aPendingNoteOffs[i+0]/*absFrameOff*/ - dstFrameOff;
                     // trace "xxx dstFrameOff="+dstFrameOff+" noteOffFrameOff="+noteOffFrameOff+" (note="+aPendingNoteOffs[i+3]+") minNumFramesNoteOff="+minNumFramesNoteOff;
                     if(noteOffFrameOff < minNumFramesNoteOff)
                     {
                        if(noteOffFrameOff <= 0)
                        {
                           // trace "xxx noteOff at dstFrameOff="+dstFrameOff+" (ticks="+int(dstFrameOff/framesPerTick)+")";
                           frInput.noteOff(true/*bSet*/,
                                           aPendingNoteOffs[i+1]/*devIdx*/,
                                           aPendingNoteOffs[i+2]/*midiCh*/,
                                           aPendingNoteOffs[i+3]/*note*/,
                                           0/*vel*/
                                           );
                           replay.b_have_events = true;
                           aPendingNoteOffs.delete4(i);
                        }
                        else
                        {
                           minNumFramesNoteOff = noteOffFrameOff;
                           i += 4;
                        }
                     }
                     else
                     {
                        i += 4;
                     }
                  }

                  numFrames = mathMini(numFrames, minNumFramesNoteOff);

                  framesUntilNextEvent -= numFrames;
                  // trace "xxx Sample::renderSourceTrack: process framesLeft="+framesLeft+" numFrames="+numFrames+" framesUntilNextEvent="+framesUntilNextEvent+" frIdx="+frIdx;

                  track.prepareProcess(src_track_idx, numFrames);  // prepare/clear mixBuf
                  track.process(src_track_idx, numFrames);         // render to mixBuf

                  if(bStereo)
                  {
                     tksampleedit_copy_stereo_to_stereo(faSmp, dstFrameOff*2, mixBuf, 0, numFrames);
                  }
                  else
                  {
                     tksampleedit_copy_mono_adv_to_mono(faSmp, dstFrameOff, mixBuf, 0, 2/*inAdv*/, numFrames);
                  }

                  frInput.empty();
                  replay.b_have_events = false;
                  framesLeft -= numFrames;
                  dstFrameOff += numFrames;
                  replay.b_reset_all_controllers = false;
               }

               frInput.empty();
               replay.b_have_events = false;
               replay.b_reset_all_controllers = true;

               Audio.PopSuppressUnderrunError(bOldSuppressUnderrunError);
            }
            else
            {
               // no seq frames
            }
         }
         // else no wav frames
      }
      // else invalid track
   }

}
