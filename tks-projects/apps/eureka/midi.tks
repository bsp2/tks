// ----
// ---- file   : midi.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 14Sep2006, 17Sep2006, 20Sep2006, 15Oct2007, 20Oct2007, 21Oct2007, 22Oct2007,
// ----          30Oct2007, 31Oct2007, 04Nov2007, 05Nov2007, 10Nov2007, 21Dec2007, 04Jan2008
// ----          07Jan2008, 10Jan2008, 12Jan2008, 13Jan2008, 15Jan2008, 16Jan2008, 03Aug2008
// ----          09Aug2008, 24Aug2008, 31Aug2008, 17Sep2009, 18Sep2009, 20Sep2009, 21Sep2009
// ----          22Sep2009, 23Sep2009, 26Dec2009, 02Jan2010, 03Jan2010, 09Jan2010, 10Jan2010
// ----          11Jan2010, 16Jan2010, 25Jan2010, 27Jan2010, 29Jan2010, 06Feb2010, 25Feb2010
// ----          01Mar2010, 24Apr2010, 29Apr2010, 30Apr2010, 01May2010, 02May2010, 03May2010
// ----          04May2010, 11May2010, 14May2010, 15May2010, 16May2010, 06Jun2010, 10Jun2010
// ----          13Jun2010, 15Jun2010, 24Jun2010, 26Jun2010, 28Jun2010, 30Jun2010, 01Jul2010
// ----          02Jul2010, 04Jul2010, 06Jul2010, 10Jul2010, 12Jul2010, 16Jul2010, 17Jul2010
// ----          18Jul2010, 21Jul2010, 08Sep2010, 24Sep2010, 26Sep2010, 27Sep2010, 28Sep2010
// ----          04Oct2010, 08Oct2010, 09Oct2010, 10Oct2010, 12Oct2010, 13Oct2010, 14Oct2010
// ----          15Oct2010, 16Oct2010, 17Oct2010, 19Oct2010, 20Oct2010, 25Oct2010, 26Oct2010
// ----          02Nov2010, 09Nov2010, 16Nov2010, 21Nov2010, 19Jan2011, 23Jan2011, 03Feb2011
// ----          18Feb2011, 20Feb2011, 25Feb2011, 28Feb2011, 12Mar2011, 13Mar2011, 19Mar2011
// ----          30Mar2011, 02Apr2011, 06Apr2011, 20Apr2011, 11Jun2011, 08Jan2012, 09Jan2012
// ----          16Jan2012, 17Jan2012, 19Jan2012, 20Jan2012, 24Jan2012, 06Feb2012, 08Feb2012
// ----          13Feb2012, 14Feb2012, 19Feb2012, 20Feb2012, 24Feb2012, 25Feb2012, 13May2012
// ----          26Jun2012, 28Jun2012, 09Nov2012, 13Nov2012, 21Nov2012, 21Dec2012, 03Jan2013
// ----          04Jan2013, 05Jan2013, 06Jan2013, 09Jan2013, 28Feb2013, 23Mar2013, 01Apr2013
// ----          07Apr2013, 13Apr2013, 14Apr2013, 15Apr2013, 19Apr2013, 04May2013, 08May2013
// ----          09May2013, 10May2013, 13May2013, 14May2013, 15May2013, 24May2013, 26May2013
// ----          27May2013, 29May2013, 31May2013, 01Jun2013, 04Jun2013, 05Jun2013, 02Feb2014
// ----          04Feb2014, 10Feb2014, 11Feb2014, 15Jun2014, 09Aug2014, 11Aug2014, 13Aug2014
// ----          15Aug2014, 19Aug2014, 25Aug2014, 31Aug2014, 04Sep2014, 09Sep2014, 15Sep2014
// ----          27Sep2014, 29Sep2014, 17Oct2014, 11Jan2015, 04Feb2015, 14Feb2015, 17Feb2015
// ----          19Feb2015, 21Feb2015, 23Feb2015, 02Mar2015, 14Apr2015, 18Apr2015, 20Apr2015
// ----          17May2015, 26Jul2015, 14Sep2015, 08Nov2015, 09Jan2016, 11Jan2016, 19Jan2016
// ----          25Jan2016, 26Jan2016, 05Feb2016, 07Feb2016, 22Jul2016, 18Aug2016, 13Jan2017
// ----          18Feb2017, 23Feb2017, 03Mar2017, 10Mar2017, 11Mar2017, 12Mar2017, 27May2017
// ----          14Oct2017, 04Jan2018, 29Jan2018, 01Feb2018, 02Jun2018, 30Jul2019, 05Aug2019
// ----          26Aug2019, 22Jul2023, 29Jul2023, 06Aug2023, 01Jul2024, 07Jul2024, 09Aug2024
// ----          15Jan2025
// ----
// ----
// ----
module MMIDI;

use namespace ui;
use namespace st2;


// <class.png>
class MIDIErrorNotification {
   String device_name;
   String device_alias;
}


// <class.png>
class MIDI : MIDIMapDefs {

   define int MAX_MIDI_INPUTS = 26;  // "a", "b", "c", "d", .., "z". see STConfig.midi_in_devicenames

   // "A","B","C",..,"Z"
   //  (note) actual number depends on STConfig.midi_in_devicenames array size
   //  (note) used as device options array in TrackForm / PageTrack
   static StringArray midi_input_device_short_names;
   static StringArray midi_input_device_long_names;

   static StringArray base_note_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

   // (@* Notes)
   public static StringArray midi_notes = [
      // (note) actually, MIDI note #0 == C-2 (am.) resp. C-3 (ger.). STÂ² starts with C-0
      "C-0", "C#0", "D-0", "D#0", "E-0", "F-0", "F#0", "G-0", "G#0", "A-0", "A#0", "B-0", //   0.. 11
      "C-1", "C#1", "D-1", "D#1", "E-1", "F-1", "F#1", "G-1", "G#1", "A-1", "A#1", "B-1", //  12.. 23
      "C-2", "C#2", "D-2", "D#2", "E-2", "F-2", "F#2", "G-2", "G#2", "A-2", "A#2", "B-2", //  24.. 35
      "C-3", "C#3", "D-3", "D#3", "E-3", "F-3", "F#3", "G-3", "G#3", "A-3", "A#3", "B-3", //  36.. 47
      "C-4", "C#4", "D-4", "D#4", "E-4", "F-4", "F#4", "G-4", "G#4", "A-4", "A#4", "B-4", //  48.. 59
      "C-5", "C#5", "D-5", "D#5", "E-5", "F-5", "F#5", "G-5", "G#5", "A-5", "A#5", "B-5", //  60.. 71
      "C-6", "C#6", "D-6", "D#6", "E-6", "F-6", "F#6", "G-6", "G#6", "A-6", "A#6", "B-6", //  72.. 83
      "C-7", "C#7", "D-7", "D#7", "E-7", "F-7", "F#7", "G-7", "G#7", "A-7", "A#7", "B-7", //  84.. 95
      "C-8", "C#8", "D-8", "D#8", "E-8", "F-8", "F#8", "G-8", "G#8", "A-8", "A#8", "B-8", //  96..107
      "C-9", "C#9", "D-9", "D#9", "E-9", "F-9", "F#9", "G-9", "G#9", "A-9", "A#9", "B-9", // 108..119
      "C-A", "C#A", "D-A", "D#A", "E-A", "F-A", "F#A", "G-A"
                                           ];

   public static StringArray midi_ch_names = [
      "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"
                                              ];

   // (@* "CC Names")
 public static StringArray cc_names = [
      "CC#000 (Bank Select MSB)",
      "CC#001 (Modulation MSB)",
      "CC#002 (Breath Control MSB)",
      "CC#003 (-undefined-)",
      "CC#004 (Foot Control MSB)",
      "CC#005 (Portamento Time MSB)",
      "CC#006 (Data Entry MSB)",
      "CC#007 (Main Volume MSB)",
      "CC#008 (Balance MSB)",
      "CC#009 (-undefined-)",
      "CC#010 (Panorama MSB)",
      "CC#011 (Expression MSB)",
      "CC#012 (Effect Control 1 MSB)",
      "CC#013 (Effect Control 2 MSB)",
      "CC#014 (-undefined- MSB)",
      "CC#015 (-undefined-)",
      "CC#016 (General Purpose #1 MSB)",
      "CC#017 (General Purpose #2 MSB)",
      "CC#018 (General Purpose #3 MSB)",
      "CC#019 (General Purpose #4 MSB)",
      "CC#020 (-undefined- #020 MSB)",
      "CC#021 (-undefined- #021 MSB)",
      "CC#022 (-undefined- #022 MSB)",
      "CC#023 (-undefined- #023 MSB)",
      "CC#024 (-undefined- #024 MSB)",
      "CC#025 (-undefined- #025 MSB)",
      "CC#026 (-undefined- #026 MSB)",
      "CC#027 (-undefined- #027 MSB)",
      "CC#028 (-undefined- #028 MSB)",
      "CC#029 (-undefined- #029 MSB)",
      "CC#030 (-undefined- #030 MSB)",
      "CC#031 (-undefined- #031 MSB)",
      "CC#032 (Bank Select LSB)",
      "CC#033 (Modulation LSB)",
      "CC#034 (Breath Control LSB)",
      "CC#035 (-undefined-)",
      "CC#036 (Foot Control LSB)",
      "CC#037 (Portamento Time LSB)",
      "CC#038 (Data Entry LSB)",
      "CC#039 (Main Volume LSB)",
      "CC#040 (Balance LSB)",
      "CC#041 (-undefined-)",
      "CC#042 (Panorama LSB)",
      "CC#043 (Expression LSB)",
      "CC#044 (Effect Ctl 1 LSB)",
      "CC#045 (Effect Ctl 2 LSB)",
      "CC#046 (-undefined- #014 LSB)",
      "CC#047 (-undefined- #015 LSB)",
      "CC#048 (General Purpose #1 LSB)",
      "CC#049 (General Purpose #2 LSB)",
      "CC#050 (General Purpose #3 LSB)",
      "CC#051 (General Purpose #4 LSB)",
      "CC#052 (-undefined- #020 LSB)",
      "CC#053 (-undefined- #021 LSB)",
      "CC#054 (-undefined- #022 LSB)",
      "CC#055 (-undefined- #023 LSB)",
      "CC#056 (-undefined- #024 LSB)",
      "CC#057 (-undefined- #025 LSB)",
      "CC#058 (-undefined- #026 LSB)",
      "CC#059 (-undefined- #027 LSB)",
      "CC#060 (-undefined- #028 LSB)",
      "CC#061 (-undefined- #029 LSB)",
      "CC#062 (-undefined- #030 LSB)",
      "CC#063 (-undefined- #031 LSB)",
      "CC#064 (Hold 1 SW)",
      "CC#065 (Portamento SW)",
      "CC#066 (Sostenuto SW)",
      "CC#067 (Soft Pedal SW)",
      "CC#068 (Legato SW)",
      "CC#069 (Hold 2 SW)",
      "CC#070 (Sound Ctl 1: Variation)",
      "CC#071 (Sound Ctl 2: Harmonic Content)",
      "CC#072 (Sound Ctl 3: Release Time)",
      "CC#073 (Sound Ctl 4: Attack time)",
      "CC#074 (Sound Ctl 5: Brightness)",
      "CC#075 (Sound Ctl 6: Decay Time)",
      "CC#076 (Sound Ctl 7: Vibrato Rate)",
      "CC#077 (Sound Ctl 8: Vibrato Depth)",
      "CC#078 (Sound Ctl 9: Vibrato Delay)",
      "CC#079 (Sound Ctl10: generic)",
      "CC#080 (General Purpose #5)",
      "CC#081 (General Purpose #6)",
      "CC#082 (General Purpose #7)",
      "CC#083 (General Purpose #8)",
      "CC#084 (Portamento Control)",
      "CC#085 (-undefined- on/off)",
      "CC#086 (-undefined- on/off)",
      "CC#087 (-undefined- on/off)",
      "CC#088 (HiRes Velocity Prefix LSB)",
      "CC#089 (-undefined- on/off)",
      "CC#090 (-undefined- on/off)",
      "CC#091 (Effect 1 Depth: Reverb Send)",
      "CC#092 (Effect 2 Depth: Tremolo)",
      "CC#093 (Effect 3 Depth: Chorus Send)",
      "CC#094 (Effect 4 Depth: Celeste)",
      "CC#095 (Effect 5 Depth: Phaser)",
      "CC#096 (Data Inc. RPN/NRPN)",
      "CC#097 (Data Dec. RPN/NRPN)",
      "CC#098 (NRPN LSB)",
      "CC#099 (NRPN MSB)",
      "CC#100 (RPN LSB)",
      "CC#101 (RPN MSB)",
      "CC#102 (-undefined-)",
      "CC#103 (-undefined-)",
      "CC#104 (-undefined-)",
      "CC#105 (-undefined-)",
      "CC#106 (-undefined-)",
      "CC#107 (-undefined-)",
      "CC#108 (-undefined-)",
      "CC#109 (-undefined-)",
      "CC#110 (-undefined-)",
      "CC#111 (-undefined-)",
      "CC#112 (-undefined-)",
      "CC#113 (-undefined-)",
      "CC#114 (-undefined-)",
      "CC#115 (-undefined-)",
      "CC#116 (-undefined-)",
      "CC#117 (-undefined-)",
      "CC#118 (-undefined-)",
      "CC#119 (-undefined-)",
      "CC#120 (All Sounds Off)",
      "CC#121 (Controller Reset)",
      "CC#122 (Local Ctl On/Off)",
      "CC#123 (All Notes Off)",
      "CC#124 (Omni Off)",
      "CC#125 (Omni On)",
      "CC#126 (Mono On / Poly Off)",
      "CC#127 (Poly On / Mono Off)"
   ];

 public static StringArray cc_names_short = [
      "CC#000 BankSelect MSB",
      "CC#001 Modulation MSB",
      "CC#002 BreathCtl MSB",
      "CC#003 -undefined-",
      "CC#004 FootCtl MSB",
      "CC#005 PortaTime MSB",
      "CC#006 DataEntry MSB",
      "CC#007 MainVol MSB",
      "CC#008 Balance MSB",
      "CC#009 -undefined-",
      "CC#010 Panorama MSB",
      "CC#011 Expression MSB",
      "CC#012 EffectCtl 1 MSB",
      "CC#013 EffectCtl 2 MSB",
      "CC#014 -undefined-",
      "CC#015 -undefined-",
      "CC#016 General #1 MSB",
      "CC#017 General #2 MSB",
      "CC#018 General #3 MSB",
      "CC#019 General #4 MSB",
      "CC#020 -undefined-",
      "CC#021 -undefined-",
      "CC#022 -undefined-",
      "CC#023 -undefined-",
      "CC#024 -undefined-",
      "CC#025 -undefined-",
      "CC#026 -undefined-",
      "CC#027 -undefined-",
      "CC#028 -undefined-",
      "CC#029 -undefined-",
      "CC#030 -undefined-",
      "CC#031 -undefined-",
      "CC#032 BankSelect LSB",
      "CC#033 Modulation LSB",
      "CC#034 BreathCtl LSB",
      "CC#035 -undefined-",
      "CC#036 FootCtl LSB",
      "CC#037 PortaTime LSB",
      "CC#038 DataEntry LSB",
      "CC#039 MainVol LSB",
      "CC#040 Balance LSB",
      "CC#041 -undefined-",
      "CC#042 Panorama LSB",
      "CC#043 Expression LSB",
      "CC#044 EffectCtl 1 LSB",
      "CC#045 EffectCtl 2 LSB",
      "CC#046 -undefined-",
      "CC#047 -undefined-",
      "CC#048 General #1 LSB",
      "CC#049 General #2 LSB",
      "CC#050 General #3 LSB",
      "CC#051 General #4 LSB",
      "CC#052 -undefined-",
      "CC#053 -undefined-",
      "CC#054 -undefined-",
      "CC#055 -undefined-",
      "CC#056 -undefined-",
      "CC#057 -undefined-",
      "CC#058 -undefined-",
      "CC#059 -undefined-",
      "CC#060 -undefined-",
      "CC#061 -undefined-",
      "CC#062 -undefined-",
      "CC#063 -undefined-",
      "CC#064 Hold 1 SW",
      "CC#065 Porta SW",
      "CC#066 Sostenuto SW",
      "CC#067 SoftPedal SW",
      "CC#068 Legato SW",
      "CC#069 Hold 2 SW",
      "CC#070 SndCtl 1:Var)",
      "CC#071 SndCtl 2:Harm",
      "CC#072 SndCtl 3:RlsTm",
      "CC#073 SndCtl 4:AtkTm",
      "CC#074 SndCtl 5:Bright",
      "CC#075 SndCtl 6:DcyTm",
      "CC#076 SndCtl 7:VibRt",
      "CC#077 SndCtl 8:VibDph",
      "CC#078 SndCtl 9:VibDly",
      "CC#079 SndCtl10:gen",
      "CC#080 General #5",
      "CC#081 General #6",
      "CC#082 General #7",
      "CC#083 General #8",
      "CC#084 PortaCtl",
      "CC#085 -undef SW-",
      "CC#086 -undef SW-",
      "CC#087 -undef SW-",
      "CC#088 HiVelocity LSB)",
      "CC#089 -undef SW-",
      "CC#090 -undef SW-",
      "CC#091 FX1Amt:Reverb",
      "CC#092 FX2Amt:Tremolo",
      "CC#093 FX3Amt:Chorus",
      "CC#094 FX4Amt:Celeste",
      "CC#095 FX5Amt:Phaser",
      "CC#096 Data Inc.",
      "CC#097 Data Dec.",
      "CC#098 NRPN LSB",
      "CC#099 NRPN MSB",
      "CC#100 RPN LSB",
      "CC#101 RPN MSB",
      "CC#102 -undefined-",
      "CC#103 -undefined-",
      "CC#104 -undefined-",
      "CC#105 -undefined-",
      "CC#106 -undefined-",
      "CC#107 -undefined-",
      "CC#108 -undefined-",
      "CC#109 -undefined-",
      "CC#110 -undefined-",
      "CC#111 -undefined-",
      "CC#112 -undefined-",
      "CC#113 -undefined-",
      "CC#114 -undefined-",
      "CC#115 -undefined-",
      "CC#116 -undefined-",
      "CC#117 -undefined-",
      "CC#118 -undefined-",
      "CC#119 -undefined-",
      "CC#120 AllSndOff",
      "CC#121 Ctl Reset",
      "CC#122 Local Ctl SW",
      "CC#123 AllNotesOff",
      "CC#124 Omni Off",
      "CC#125 Omni On",
      "CC#126 MonoOnPolyOff",
      "CC#127 PolyOnMonoOff"
   ];

 public static StringArray cc_names_very_short = [
      "CC#000 Bank MSB",
      "CC#001 ModWhl MSB",
      "CC#002 Breath MSB",
      "CC#003 -undef-",
      "CC#004 Foot MSB",
      "CC#005 PortaTm MSB",
      "CC#006 Data MSB",
      "CC#007 MainVol MSB",
      "CC#008 Balance MSB",
      "CC#009 -undef-",
      "CC#010 Pan MSB",
      "CC#011 Expr MSB",
      "CC#012 FX 1 MSB",
      "CC#013 FX 2 MSB",
      "CC#014 -undef-",
      "CC#015 -undef-",
      "CC#016 Gen #1 MSB",
      "CC#017 Gen #2 MSB",
      "CC#018 Gen #3 MSB",
      "CC#019 Gen #4 MSB",
      "CC#020 -undef-",
      "CC#021 -undef-",
      "CC#022 -undef-",
      "CC#023 -undef-",
      "CC#024 -undef-",
      "CC#025 -undef-",
      "CC#026 -undef-",
      "CC#027 -undef-",
      "CC#028 -undef-",
      "CC#029 -undef-",
      "CC#030 -undef-",
      "CC#031 -undef-",
      "CC#032 Bank LSB",
      "CC#033 ModWhl LSB",
      "CC#034 Breath LSB",
      "CC#035 -undefined-",
      "CC#036 Foot LSB",
      "CC#037 PortaTm LSB",
      "CC#038 Data LSB",
      "CC#039 MainVol LSB",
      "CC#040 Balance LSB",
      "CC#041 -undef-",
      "CC#042 Pan LSB",
      "CC#043 Expr LSB",
      "CC#044 FX 1 LSB",
      "CC#045 FX 2 LSB",
      "CC#046 -undef-",
      "CC#047 -undef-",
      "CC#048 Gen #1 LSB",
      "CC#049 Gen #2 LSB",
      "CC#050 Gen #3 LSB",
      "CC#051 Gen #4 LSB",
      "CC#052 -undef-",
      "CC#053 -undef-",
      "CC#054 -undef-",
      "CC#055 -undef-",
      "CC#056 -undef-",
      "CC#057 -undef-",
      "CC#058 -undef-",
      "CC#059 -undef-",
      "CC#060 -undef-",
      "CC#061 -undef-",
      "CC#062 -undef-",
      "CC#063 -undef-",
      "CC#064 Hold 1 SW",
      "CC#065 Porta SW",
      "CC#066 Sost SW",
      "CC#067 Soft SW",
      "CC#068 Legato SW",
      "CC#069 Hold 2 SW",
      "CC#070 Snd 1:Var)",
      "CC#071 Snd 2:Harm",
      "CC#072 Snd 3:RlsTm",
      "CC#073 Snd 4:AtkTm",
      "CC#074 Snd 5:Bright",
      "CC#075 Snd 6:DcyTm",
      "CC#076 Snd 7:VibRt",
      "CC#077 Snd 8:VibDph",
      "CC#078 Snd 9:VibDly",
      "CC#079 Snd10:gen",
      "CC#080 Gen #5",
      "CC#081 Gen #6",
      "CC#082 Gen #7",
      "CC#083 Gen #8",
      "CC#084 PortaCtl",
      "CC#085 -undef SW-",
      "CC#086 -undef SW-",
      "CC#087 -undef SW-",
      "CC#088 HiVel LSB)",
      "CC#089 -undef SW-",
      "CC#090 -undef SW-",
      "CC#091 FX1:Rev",
      "CC#092 FX2:Trem",
      "CC#093 FX3:Cho",
      "CC#094 FX4:Cel",
      "CC#095 FX5:Pha",
      "CC#096 Data+",
      "CC#097 Data-",
      "CC#098 NRPN LSB",
      "CC#099 NRPN MSB",
      "CC#100 RPN LSB",
      "CC#101 RPN MSB",
      "CC#102 -undef-",
      "CC#103 -undef-",
      "CC#104 -undef-",
      "CC#105 -undef-",
      "CC#106 -undef-",
      "CC#107 -undef-",
      "CC#108 -undef-",
      "CC#109 -undef-",
      "CC#110 -undef-",
      "CC#111 -undef-",
      "CC#112 -undef-",
      "CC#113 -undef-",
      "CC#114 -undef-",
      "CC#115 -undef-",
      "CC#116 -undef-",
      "CC#117 -undef-",
      "CC#118 -undef-",
      "CC#119 -undef-",
      "CC#120 AllSndOff",
      "CC#121 Ctl Reset",
      "CC#122 Local SW",
      "CC#123 AllNOff",
      "CC#124 Omni Off",
      "CC#125 Omni On",
      "CC#126 MonoOn",
      "CC#127 PolyOn"
   ];

   static StringArray nrpn_names;

   static MIDIOutDevice *[] out_devices; // MIDIOutDevice instances
   static MIDIInDevice  *[] in_devices;  // MIDIInDevice instances

   static StringArray out_device_names;
   static StringArray in_device_names;

   static StringArray enum_out_device_names;
   static StringArray enum_in_device_names;

   static IntArray in_device_bgcolors;  // bg tint, e.g. for ComboBoxes
   static IntArray out_device_bgcolors; // bg tint, e.g. for ComboBoxes

   static MIDIErrorNotification *[] midi_errors; // MIDIErrorNotification instances
   static InfoDialog *dlg_error;


   // <method_init.png>
   static Init() {

      int nrpnIdx = 0;
      nrpn_names.alloc(ModMatrixEntry.MAX_NRPN);
      loop(ModMatrixEntry.MAX_NRPN)
         nrpn_names.add(String(nrpnIdx++));

      int vstDevIdx = 0;
      String *sDevName;
      foreach sDevName in STConfig.midi_in_devicenames
      {
         midi_input_device_short_names.add(tcchar('A'+vstDevIdx));
         midi_input_device_long_names.add(tcchar('A'+vstDevIdx)+":"+sDevName);
         vstDevIdx++;
      }
   }

   // <method_enum.png>
   static EnumerateMIDIDevices() {

      if(STConfig.b_enable_midi)
      {
         if(STConfig.b_debug_lofreq)
         {
            // In
            trace "[...] EnumerateMIDIInDevices: found "+MIDIIn.GetNumDevices()+" MIDI devices.";

            Integer io;
            int i = 0;

            enum_in_device_names.free();

            loop(MIDIIn.GetNumDevices())
            {
               io.value = i;
               print "\tMIDI["+io.printf("%2i")+"]: \""+MIDIIn.GetDeviceNameByIdx(i)+"\" ";
               enum_in_device_names.add(MIDIIn.GetDeviceNameByIdx(i));
               i++;
            }


            // Out
            trace "[...] EnumerateMIDIInDevices: found "+MIDIOut.GetNumDevices()+" MIDI devices.";

            enum_out_device_names.free();

            i = 0;
            loop(MIDIOut.GetNumDevices())
            {
               io.value = i;
               print "\tMIDI["+io.printf("%2i")+"]: \""+MIDIOut.GetDeviceNameByIdx(i)+"\" ("+TKS.constantToString(MIDIOut.GetDeviceTypeByIdx(i), "MOD_")+")";
               enum_out_device_names.add(MIDIOut.GetDeviceNameByIdx(i));
               i++;
            }
         }
      }
   }

   // <method.png>
   protected static RestoreMIDIInFilter(MIDIIn midiin, HashTable cfg, String key) {
      if(cfg.exists(key))
      {
         TKS.evalMethodByName( midiin, key.replace("flt", "setFlt"), { int(cfg.get(key)) }, null );
      }
      else
      {
         trace "[~~~] RestoreMIDIInFilter: dev=\""+midiin.deviceName+"\" cfg is missing key \""+key+"\".";
      }
   }

   // <method.png>
   static RestoreFilterSettings(MIDIIn midiin, String deviceName) {
      // Restore filter settings from config file
      if(STConfig.midi_in_filter.exists(deviceName))
      {
         HashTable cfg <= STConfig.midi_in_filter.get(deviceName);
         RestoreMIDIInFilter(midiin, cfg, "fltNoteOff");
         RestoreMIDIInFilter(midiin, cfg, "fltNoteOn");
         RestoreMIDIInFilter(midiin, cfg, "fltPolyPressure");
         RestoreMIDIInFilter(midiin, cfg, "fltCC");
         RestoreMIDIInFilter(midiin, cfg, "fltProgramChange");
         RestoreMIDIInFilter(midiin, cfg, "fltChannelPressure");
         RestoreMIDIInFilter(midiin, cfg, "fltPitchbend");
         RestoreMIDIInFilter(midiin, cfg, "fltSysEx");
         RestoreMIDIInFilter(midiin, cfg, "fltSysComTimeCode");
         RestoreMIDIInFilter(midiin, cfg, "fltSysComSongPosition");
         RestoreMIDIInFilter(midiin, cfg, "fltSysComSongSelect");
         RestoreMIDIInFilter(midiin, cfg, "fltSysComTuneRequest");
         RestoreMIDIInFilter(midiin, cfg, "fltSysRTTimingClock");
         RestoreMIDIInFilter(midiin, cfg, "fltSysRTStart");
         RestoreMIDIInFilter(midiin, cfg, "fltSysRTContinue");
         RestoreMIDIInFilter(midiin, cfg, "fltSysRTStop");
         RestoreMIDIInFilter(midiin, cfg, "fltSysRTActiveSensing");
         RestoreMIDIInFilter(midiin, cfg, "fltSysRTSystemReset");
         RestoreMIDIInFilter(midiin, cfg, "fltRpnSelect");
         RestoreMIDIInFilter(midiin, cfg, "fltNrpnSelect");
         RestoreMIDIInFilter(midiin, cfg, "fltRpn");
         RestoreMIDIInFilter(midiin, cfg, "fltNrpn");
      }
   }

   // <method_init.png>
   static InitMIDIInDevice(MIDIInDevice inDev, String deviceName, int deviceIdx/*0..7*/) : boolean {
      // Return true if device was openend or false if it is unavailable
      String origDeviceName = deviceName;
      MIDIIn midiin <= new MIDIIn;
      boolean bOpen = midiin.openByName(deviceName);

      if(!bOpen)
      {
         trace "[~~~] failed to open MIDI input device #"+deviceIdx+" \""+origDeviceName+"\".";
         inDev <= null;
      }
      else
      {
         inDev.init(deref midiin);
         inDev.dev_idx = deviceIdx;
         inDev.cached_out_dev <= out_devices.get(deviceIdx);
         RestoreFilterSettings(midiin, deviceName);
      }

      return bOpen;
   }

   // <method_init.png>
   static InitLocalMIDIInDevice(LocalMIDIInDevice inDev, String deviceName, int deviceIdx/*0..7*/) : boolean {
      // Return true if device was openend or false if it is unavailable
      String origDeviceName = deviceName;
      LocalMIDI localmidi <= inDev.localmidi;
      MIDIIn midiin <= new MIDIIn;
      boolean bOpen = inDev.openLocalMIDI(deviceName);

      if(!bOpen)
      {
         trace "[~~~] failed to open local MIDI input device #"+deviceIdx+" \""+origDeviceName+"\".";
         inDev <= null;
      }
      else
      {
         inDev.init(deref midiin);
         inDev.dev_idx = deviceIdx;
         // inDev.cached_out_dev <= out_devices.get(deviceIdx);
         RestoreFilterSettings(midiin, deviceName);
      }

      return bOpen;
   }

   // <method_init.png>
   static InitMIDIInDevices() : boolean {
      int numInit = 0;
      StringArray deviceNames <= STConfig.midi_in_devicenames;

      // Initialize devices array
      in_devices.alloc(deviceNames.numElements);
      int deviceIdx = 0;
      String *deviceName;
      foreach deviceName in deviceNames
      {
         if(!deviceName.isBlank())
         {
            if(STConfig.b_enable_localmidi)
            {
               LocalMIDIInDevice inDevLocal <= new LocalMIDIInDevice;
               if(InitLocalMIDIInDevice(inDevLocal, deviceName, deviceIdx))
                  numInit++;
               Global.Debug("InitLocalMIDIInDevice: deviceName=\""+deviceName+"\" deviceIdx="+deviceIdx);
               in_devices[deviceIdx++] = deref inDevLocal;
            }
            else
            {
               MIDIInDevice inDev <= new MIDIInDevice;
               if(InitMIDIInDevice(inDev, deviceName, deviceIdx))
                  numInit++;
               Global.Debug("InitMIDIInDevice: deviceName=\""+deviceName+"\" deviceIdx="+deviceIdx);
               in_devices[deviceIdx++] = deref inDev;
            }

         } // !blank
      } // foreach
      in_devices.numElements = deviceIdx;

      Global.Info("opened "+numInit+"/"+deviceIdx+" "+(STConfig.b_enable_localmidi?"Local":"")+"MIDI input devices.");
      return true;
   }

   // <method_get.png>
   static GetMIDIInDeviceByIndex(int _idx) : MIDIInDevice {
      return in_devices.get(_idx);
   }

   // <method_get.png>
   static GetMIDIInDeviceByDeviceName(String _name, boolean _bQuiet) : MIDIInDevice {
      if(in_devices.numElements > 0)
      {
         MIDIInDevice *ret;
         foreach ret in in_devices
         {
            if(ret.getDeviceName() == _name)
               return ret;
         }
      }

      if(!_bQuiet)
      {
         // SongFile.TraceOnce("[~~~] MIDI::GetMIDIInDeviceByDeviceName: device \""+_name+"\" not found.");
      }
      return null;
   }

   // <method_start.png>
   static StartMIDIInDevices() {
      int deviceIdx = 0;
      MIDIInDevice *inDev;
      foreach inDev in in_devices
      {
         if(null != inDev.midiin)
         {
            Global.Debug("Starting MIDI in device #"+deviceIdx+" \""+inDev.getDeviceName()+"\".");
            inDev.start();
         }
         deviceIdx++;
      }
   }

   // <method_exit.png>
   static ExitMIDIInDevices() {
      if(STConfig.b_enable_midi)
      {
         Global.Debug2("MIDI::ExitMIDIInDevices: exit MIDI input devices.");
         int deviceIdx = 0;
         MIDIInDevice *inDev;
         foreach inDev in in_devices
         {
            if(null != inDev)
            {
               // trace "[...] Closing MIDIIn device #"+deviceIdx;
               if(null != inDev.midiin)
               {
                  Global.Debug("closing MIDI in device #"+deviceIdx+" \""+inDev.getDeviceName()+"\".");
                  inDev.close();
               }
            }

            deviceIdx++;
         }
         Global.Debug2("MIDI::ExitMIDIInDevices: LEAVE.");
      }
   }

   // <method_init.png>
   static InitMIDIOutDevice(String deviceName, int deviceIdx, Boolean bInitOK) : MIDIOutDevice {
      // Return true if device was openend or false if it is unavailable
      //  (note) unused
      String origDeviceName = deviceName;

      MIDIOutDevice *outDev;

      MIDIOut midiout <= new MIDIOut;
      boolean bOpen = midiout.openByName(deviceName);

      if(!bOpen)
      {
         trace "[---] failed to open MIDI output device #"+deviceIdx+" \""+origDeviceName+"\".";
         outDev <= null;
      }
      else
      {
         Global.Debug("OK, opened MIDI out device #"+deviceIdx+" \""+deviceName+"\".");
         outDev <= new MIDIOutDevice;
         outDev.init(deref midiout);
         outDev.dev_idx = deviceIdx;
      }

      bInitOK = bOpen;

      return deref outDev;
   }

   // <method_get.png>
   static GetMIDIOutDeviceByDeviceName(String _name) : MIDIOutDevice {
      if(out_devices.numElements > 0)
      {
         MIDIOutDevice *ret;
         foreach ret in out_devices
         {
            if(ret.getDeviceName() == _name)
               return ret;
         }
      }
      // SongFile.TraceOnce("[~~~] MIDI::GetMIDIOutDeviceByDeviceName: device \""+_name+"\" not found.");
      return null;
   }

   // <method_get.png>
   static GetMIDIOutDeviceByIndex(int _idx) {
      return out_devices.get(_idx);
   }

   // <method_exit.png>
   static ExitMIDIOutDevices() {
      if(STConfig.b_enable_midi)
      {
         MIDIOutDevice *outDev;
         int deviceIdx = 0;
         foreach outDev in out_devices
         {
            if(null != outDev)
            {
               if(null != outDev.midiout)
               {
                  Global.Debug("closing MIDI out device #"+deviceIdx+" \""+outDev.getDeviceName()+"\".");
                  outDev.exit();
                  outDev.midiout.close();
               }
            }

            deviceIdx++;
         }
         out_devices.free();
         Global.Debug2("MIDI::ExitMIDIOutDevices: LEAVE.");
      }
   }

   // <method_update.png>
   public static UpdateInDeviceNames() {

      in_device_names.empty();
      in_device_bgcolors.empty();

      MIDIDevice *dev;

      foreach dev in in_devices
      {
         if(null != dev)
         {
            in_device_names.add(dev.getDeviceName());

            int bg32 = 0;

            if(dev.isOpen())
            {
               // // if(dev.isInternal())
               // // {
               // //    bg32 = #14ffff00;
               // // }
            }
            else
            {
               bg32 = #38ff0000;
            }
            in_device_bgcolors.add(bg32);
         }
         else
         {
            in_device_names.add("n/a");
            in_device_bgcolors.add(0);
         }
      }
   }

   // <method_update.png>
   public static UpdateOutDeviceNames() {
      Global.Debug2("UpdateOutDeviceNames");

      out_device_names.empty();
      out_device_bgcolors.empty();

      MIDIDevice *dev;
      foreach dev in out_devices
      {
         if(null != dev)
         {
            String devName <= dev.getDeviceName();

            // trace "xxx dev="+#(dev)+" dev.getAliasOrDeviceName()=\""+aliasOrDevName+"\" isOpen="+dev.isOpen();
            out_device_names.add(devName);
            // trace "[trc] MIDI::UpdateOutDeviceNames: out_device_names="+#(out_device_names);
            int bg32 = 0;

            if(dev.isOpen())
            {
               // if(dev.isInternal())
               // {
               //    bg32 = #10ffff00;
               // }
            }
            else
            {
               bg32 = #38ff0000;
            }

            // trace "xxx out name="+aliasOrDevName+" bg32="+bg32;

            out_device_bgcolors.add(bg32);
         }
         else
         {
            out_device_names.add("<n/a>");
            out_device_bgcolors.add(0);
         }
      }

      // trace "[trc] MIDI::UpdateOutDeviceNames: out_device_names="+#(out_device_names);
   }

   // <error_handling.png>
   static AddDeviceError(String _devName, String _devAlias) {
      MIDIErrorNotification err <= new MIDIErrorNotification;
      err.device_name = _devName;
      err.device_alias = _devAlias;
      midi_errors.add(#(deref err));
   }

   // <error_handling.png>
   static ClearErrorList() {
      midi_errors.free();
   }

   // <error_handling.png>
   static ShowErrorDialog() : boolean {

      if(midi_errors.numElements > 0)
      {
         MIDIErrorNotification *error;

         String errMsg = "The following MIDI output devices could not be opened:\n\n";

         foreach error in midi_errors
         {
            errMsg.append("Device: \"");
            errMsg.append(error.device_name);
            errMsg.append("\"\n");

            errMsg.append("Alias: \"");
            errMsg.append(error.device_alias);
            errMsg.append("\"\n");

            errMsg.append("\n\n");
         }

         errMsg.append("Please open the \"Manage generators\" dialog and select a valid output device for all generators whose device is marked as \"n/a\"\nOR go to the \"Manage instruments\" dialog and select a valid generator for all instruments whose generator is marked as \"<n/a>\".\n\nIn case the MIDI device simply is not connected, reconnect it, restart the program, then reload the song.");

         dlg_error <= InfoDialog.NewError("MIDI device errors",
                                          errMsg,
                                          null
                                          );
         dlg_error.showCentered();
      }
   }

   // <method_get.png>
   static MIDIPipeEvent_GetArg1String(MIDIPipeEvent ev, MIDIDevice dev) : String {
      Integer io;

      switch(ev.type)
      {
         case MIDIPIPE_EVENT_TYPE_NONE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PRGCHG:
            return dev.getPrgShortNameByNr(ev.midiCh, ev.prgChg);

         case MIDIPIPE_EVENT_TYPE_CHPRESSURE:
            return ev.chPressure;

         case MIDIPIPE_EVENT_TYPE_PITCHBEND:
            io = ev.pitchbend;
            return io.printf("$%04x");

         case MIDIPIPE_EVENT_TYPE_CC:
            return dev.getCCShortNameByCtl(ev.midiCh, ev.ccId);

         case MIDIPIPE_EVENT_TYPE_RPN:
            return dev.getRPNShortNameByNr(ev.midiCh, ev.rpn);

         case MIDIPIPE_EVENT_TYPE_NRPN:
            return dev.getNRPNShortNameByNr(ev.midiCh, ev.nrpn);

         case MIDIPIPE_EVENT_TYPE_NOTE_OFF:
            return midi_notes.get(ev.note);

         case MIDIPIPE_EVENT_TYPE_NOTE_ON:
            return midi_notes.get(ev.note);
      }
   }

   // <method_get.png>
   static MIDIPipeEvent_GetArg2String(MIDIPipeEvent ev, MIDIDevice dev) : String {
      switch(ev.type)
      {
         case MIDIPIPE_EVENT_TYPE_NONE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PRGCHG:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CHPRESSURE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PITCHBEND:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CC:
            return ev.ccValue;

         case MIDIPIPE_EVENT_TYPE_RPN:
            return ev.rpnValue;

         case MIDIPIPE_EVENT_TYPE_NRPN:
            return ev.nrpnValue;

         case MIDIPIPE_EVENT_TYPE_NOTE_OFF:
            return ev.velocity;

         case MIDIPIPE_EVENT_TYPE_NOTE_ON:
            return ev.velocity;
      }
   }

   // <method_get.png>
   static MIDIPipeEvent_GetArg3String(MIDIPipeEvent ev, MIDIDevice dev) : String {
      switch(ev.type)
      {
         case MIDIPIPE_EVENT_TYPE_NONE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PRGCHG:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CHPRESSURE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PITCHBEND:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CC:
            return "-";

         case MIDIPIPE_EVENT_TYPE_RPN:
            return "-";

         case MIDIPIPE_EVENT_TYPE_NRPN:
            return "-";

         case MIDIPIPE_EVENT_TYPE_NOTE_OFF:
            return ev.duration;

         case MIDIPIPE_EVENT_TYPE_NOTE_ON:
            return ev.duration;
      }
   }

   // <method_get.png>
   public static RebuildAllCtlNames() {
      MIDIDevice *dev;

      Global.Debug2("MIDI.RebuildAllCtlNames");

      foreach dev in in_devices
      {
         if(null != dev)
            dev.buildCtlNames();
      }

      foreach dev in out_devices
      {
         if(null != dev)
            dev.buildCtlNames();
      }
   }

   // <method_find.png>
   static FindNoteIdxByString(String _s) : int {
      String *noteName;
      int noteIdx = 0;
      foreach noteName in midi_notes
      {
         if(noteName.toLower() == _s)
            return noteIdx;
         noteIdx++;
      }
      return -1;
   }

   // <method_add.png>
   static AddRecordedMIDIEventToFrame(MIDIPipeFrame     _fr,
                                      short             _devIdx,
                                      byte              _midiCh,
                                      RecordedMIDIEvent _recEv,
                                      IntArray          _lastChEvTypes,
                                      IntArray          _noteOffPreFlags
                                      ) {

      // (note) events are added at the beginning of a process() call (audioOut numFrames blocksize)

      int shortMsg = _recEv.shortMessage;
      byte note;
      byte vel;

      switch(_recEv.midiMapEventType)
      {
         case TYPE_NOTE_OFF:
            note = (shortMsg >> 8)&127;
            vel  = (shortMsg >> 16)&127;
            // trace "xxx AddRecordedMIDIEventToFrame: NOTE_OFF note="+note+" vel="+vel+" noteOffPreFlags["+_midiCh+"]="+_noteOffPreFlags[_midiCh];
            if(_noteOffPreFlags[_midiCh])
               _fr.noteOffPre(true/*bSet*/, _devIdx, _midiCh, note, vel);
            else
               _fr.noteOff(true/*bSet*/, _devIdx, _midiCh, note, vel);
            break;

         case TYPE_NOTE_ON:
            note = (shortMsg >> 8)&127;
            vel = (shortMsg >> 16)&127;
            // trace "xxx AddRecordedMIDIEventToFrame: NOTE_ON note="+note+" vel="+vel+" noteOffPreFlags["+_midiCh+"]="+_noteOffPreFlags[_midiCh];
            if(0 != vel)
               _noteOffPreFlags[_midiCh] = false;
            _fr.noteOn(true/*bSet*/, _devIdx, _midiCh, note, vel, 0/*dur*/);
            break;

         case TYPE_POLY_PRESSURE:
            _fr.polyPressure(true/*bSet*/, _devIdx, _midiCh, (shortMsg >> 8)&127/*note*/, (shortMsg >> 16)&127/*pressure*/);
            break;

         case TYPE_CC:
            _fr.cc(true/*bSet*/, _devIdx, _midiCh, (shortMsg >> 8)&127/*cc*/, (shortMsg >> 16)&127/*val*/);
            if(null != _lastChEvTypes)
            {
               _lastChEvTypes[_midiCh + 17] = (shortMsg >> 8)&127;
               _lastChEvTypes[16 + 17] = (shortMsg >> 8)&127;  // any
               // // trace "xxx set last extType="+_lastChEvTypes[_midiCh + 17];
            }
            break;

         case TYPE_PROGRAM_CHANGE:
            _fr.prgChg(true/*bSet*/, _devIdx, _midiCh, (shortMsg >> 8)&127/*prgNr*/);
            break;

         case TYPE_CHANNEL_PRESSURE:
            _fr.chPressure(true/*bSet*/, _devIdx, _midiCh, (shortMsg >> 8)&127/*pressure*/);
            break;

         case TYPE_PITCHBEND:
            _fr.pitchbend(true/*bSet*/, _devIdx, _midiCh, ((shortMsg>> 8) & 127) | ( ( (shortMsg>>16) & 127) << 7));
            break;

         case TYPE_SYSEX:
            break;

         case TYPE_SYSCOM_TIMECODE:
         case TYPE_SYSCOM_SONG_POSITION:
         case TYPE_SYSCOM_SONG_SELECT:
         case TYPE_SYSCOM_F4:
         case TYPE_SYSCOM_F5:
         case TYPE_SYSCOM_TUNE_REQUEST:
         case TYPE_SYSRT_TIMING_CLOCK:
         case TYPE_SYSRT_F9:
         case TYPE_SYSRT_START:
         case TYPE_SYSRT_CONTINUE:
         case TYPE_SYSRT_STOP:
         case TYPE_SYSRT_FD:
         case TYPE_SYSRT_ACTIVE_SENSING:
         case TYPE_SYSRT_SYSTEM_RESET:
            break;

         case TYPE_RPN:
            _fr.rpn(true/*bSet*/, _devIdx, _midiCh, _recEv.nrpnId, _recEv.dataEntry);
            if(null != _lastChEvTypes)
            {
               _lastChEvTypes[_midiCh + 17] = _recEv.nrpnId;
               _lastChEvTypes[16 + 17] = _recEv.nrpnId;  // any
            }
            break;

         case TYPE_NRPN:
            _fr.nrpn(true/*bSet*/, _devIdx, _midiCh, _recEv.nrpnId, _recEv.dataEntry);
            if(null != _lastChEvTypes)
            {
               _lastChEvTypes[_midiCh + 17] = _recEv.nrpnId;
               _lastChEvTypes[16 + 17] = _recEv.nrpnId;  // any
            }
            break;
      }
   }

   // <method.png>
   static AddMIDIPipeFrameToHostMIDIEvents(local MIDIPipeFrame  _frame,
                                           local HostMIDIEvents _events,
                                           local Integer devIdx,
                                           local ModInputFilter inputFilterVRR
                                           ) {

      // (note) 'devIdx' is not an argument. It's passed like an argument to avoid frequent object allocation
      //         (and usually references ModVST2.tmp_io)

      // if(_frame.numEvents > 0)
      //    trace "xxx AddMIDIPipeFrameToHostMIDIEvents: numEvents="+_frame.numEvents;

      local int numEv;
      local int evIdx;
      local int shortMsg;
      local int ms = _frame.timeStamp;
      local MIDIPipeEvent *pev;

      // Program changes
      numEv = _frame.numEventsPrgChg;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getPrgChgShortMsgByIdx(evIdx++, devIdx);
            _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
         }
      }

      // Channel pressure
      numEv = _frame.numEventsChPressure;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getChPressureShortMsgByIdx(evIdx++, devIdx);
            _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
         }
      }

      // Pitchbend
      numEv = _frame.numEventsPitchbend;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getPitchbendShortMsgByIdx(evIdx++, devIdx);
            _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
         }
      }

      // CC
      numEv = _frame.numEventsCC;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getCCShortMsgByIdx(evIdx++, devIdx);
            _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
         }
      }

      // RPN
      numEv = _frame.numEventsRPN;
      if(numEv > 0)
      {
         if(null == pev)
            pev <= new MIDIPipeEvent;
         evIdx = 0;
         loop(numEv)
         {
            if(_frame.getEventByIdx(evIdx, pev, MIDIPIPE_EVENT_TYPE_RPN))
            {
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         101,  // RPN select MSB
                                         pev.rpn >> 7,
                                         0
                                         );
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         100,  // RPN select LSB
                                         pev.rpn & 127,
                                         0
                                         );
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         6,   // RPN value MSB
                                         pev.rpnValue >> 7,
                                         0
                                         );
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         38,   // RPN value LSB
                                         pev.rpnValue & 127,
                                         0
                                         );
            }
            evIdx++;
         }
      }

      // NRPN
      numEv = _frame.numEventsNRPN;
      if(numEv > 0)
      {
         if(null == pev)
            pev <= new MIDIPipeEvent;
         evIdx = 0;
         loop(numEv)
         {
            if(_frame.getEventByIdx(evIdx, pev, MIDIPIPE_EVENT_TYPE_NRPN))
            {
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         99,  // NRPN select MSB
                                         pev.nrpn >> 7,
                                         0
                                         );
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         98,   // NRPN select LSB
                                         pev.nrpn & 127,
                                         0
                                         );
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         6,   // NRPN value MSB
                                         pev.nrpnValue >> 7,
                                         0
                                         );
               _events.addMIDIShortEvent(ms, devIdx,
                                         0xB0|pev.midiCh,
                                         38,   // NRPN value LSB
                                         pev.nrpnValue & 127,
                                         0
                                         );
            }
            evIdx++;
         }
      }

      // Note Off (Pre)
      numEv = _frame.numEventsNoteOffPre;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getNoteOffPreShortMsgByIdx(evIdx++, devIdx);

            if(inputFilterVRR.enableVRR)
            {
               if(inputFilterVRR.vrrNote == ((shortMsg >> 8) & 127))
               {
                  _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
                  // trace "xxx vrr noteoff: note="+inputFilterVRR.vrrNote;
                  inputFilterVRR.vrrNote = -1;
               }
            }
            else
            {
               _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
            }
         }
      }

      // Note On
      numEv = _frame.numEventsNoteOn;
      if(numEv > 0)
      {
         // trace "xxx numEventsNoteOn="+numEv;
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getNoteOnShortMsgByIdx(evIdx, devIdx);

            if(inputFilterVRR.enableVRR)
            {
               if(evIdx == inputFilterVRR.vrrNoteOnIdx)
               {
                  if(-1 != inputFilterVRR.vrrNote)
                  {
                     // Force note-off
                     _events.addMIDIShortEvent32(ms, devIdx,
                                                 (0x80 | (shortMsg&15)) |
                                                 (inputFilterVRR.vrrNote<<8)
                                                 );
                  }

                  _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
                  inputFilterVRR.vrrNote = ((shortMsg >> 8) & 127);
                  // trace "xxx vrr noteon: note="+inputFilterVRR.vrrNote;
               }
            }
            else
            {
               _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
            }

            evIdx++;
         }
      }

      // All Notes Off
      numEv = _frame.numEventsAllNotesOff;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getAllNotesOffShortMsgByIdx(evIdx++, devIdx);
            _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
         }

         inputFilterVRR.vrrNote = -1;
      }

      // Note Off (Post)
      numEv = _frame.numEventsNoteOffPost;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getNoteOffPostShortMsgByIdx(evIdx++, devIdx);

            if(inputFilterVRR.enableVRR)
            {
               if(inputFilterVRR.vrrNote == ((shortMsg >> 8) & 127))
               {
                  _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
                  // trace "xxx vrr noteoff: note="+inputFilterVRR.vrrNote;
                  inputFilterVRR.vrrNote = -1;
               }
            }
            else
            {
               _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
            }
         }
      }

      // Poly Pressure
      numEv = _frame.numEventsPolyPressure;
      if(numEv > 0)
      {
         evIdx = 0;
         loop(numEv)
         {
            shortMsg = _frame.getPolyPressureShortMsgByIdx(evIdx++, devIdx);
            _events.addMIDIShortEvent32(ms, devIdx, shortMsg);
         }
      }

   }

}
