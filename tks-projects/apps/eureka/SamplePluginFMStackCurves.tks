// ----
// ---- file   : SamplePluginFMStackCurves.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2023-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer. see "fm_stack_v2/curves.cpp"
// ----
// ---- created: 21Aug2023
// ---- changed: 22Aug2023, 23Aug2023, 24Aug2023, 25Aug2023, 26Aug2023, 01Sep2023, 03Sep2023
// ----          06Sep2023, 07Sep2023, 08Sep2023, 09Sep2023, 10Sep2023, 11Sep2023, 12Sep2023
// ----          13Sep2023, 16Sep2023, 19Sep2023, 20Sep2023, 21Sep2023, 11Nov2023, 30Nov2023
// ----          15Dec2023, 11Jan2024, 21Jan2024, 07Feb2024, 27Apr2024, 28Apr2024
// ----
// ----
// ----

module MSamplePluginFMStackCurves;

use namespace ui;
use namespace st2;

// PointerArray shapes = [
//    // neg
//    /* 0 */ curve_dcy_shape_4,
//    /* 1 */ curve_dcy_shape_3,
//    /* 2 */ curve_dcy_shape_2_5,
//    /* 3 */ curve_dcy_shape_2,
//    /* 4 */ curve_dcy_shape_1,
//    /* 5 */ curve_dcy_shape_0,
//    /* 6 */ curve_dcy_shape_0_lin,

//    // pos
//    /* 7 */ curve_dcy_shape_m1,
//    /* 8 */ curve_dcy_shape_m2,
//    /* 9  */ curve_dcy_shape_m3,
//    /* 10 */ curve_dcy_shape_m4,
//    /* 11 */ curve_dcy_shape_m5,
//                        ];
IntArray fmstack_env_dat;

function CalcInterpolatedCurve(float _envIdxF/*-1..1*/, FloatArray ret) {
   // (note) 'ret' must be allocated by caller

   if(fmstack_env_dat.isEmpty())
   {
      local PakFile fh;
      if(fh.open("fmstack_env.dat"))
      {
         fmstack_env_dat.alloc(12 * 2048 * 2);
         loop(fmstack_env_dat.maxElements)
            fmstack_env_dat.add(fh.s16);
         fh.close();
      }
   }

   float envIdxF = (_envIdxF < 0.0f) ? (6.0f + 6.0f*_envIdxF) : (6.0f + 5.0f * _envIdxF);
   float amtB = envIdxF - int(envIdxF);
   int envIdxA = mathClampi(int(envIdxF), 0, 11);
   int envIdxB = mathClampi(int(envIdxF) + 1, 0, 11);
   trace "xxx CalcInterpolatedCurve: envIdxF="+envIdxF+" envIdxA="+envIdxA+" envIdxB="+envIdxB+" amtB="+amtB;

   int shapeOffA = envIdxA * 2048;
   int shapeOffB = envIdxB * 2048;

   float a = 0.0f;
   float w = (2048.0f / ret.numElements);

   int i = 0;
   loop(ret.numElements)
   {
      ret[i++] = mathLerpf(fmstack_env_dat.get(shapeOffA + a), fmstack_env_dat.get(shapeOffB + a), amtB) / 32767.0f;
      a += w;
   }

}
