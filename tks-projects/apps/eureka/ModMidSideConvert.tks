// ----
// ---- file   : ModMidSideConvert.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2018-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 21Jul2018
// ---- changed: 08Mar2023, 03Dec2023, 19Sep2024, 20Sep2024, 07Jan2025
// ----
// ----
// ----

module MModMidSideConvert;

use tksdl;

namespace st2;


// <class.png>
abstract class ModMidSideConvert : Mod {
   float amp;

   // // <method_init.png>
   // public virtual init() {
   //    Mod::init();
   //    allocateIOBuffers(DEF_NUM_IO_BUFFERS/*numIn*/, DEF_NUM_IO_BUFFERS/*numOut*/);

   //    addInput("In L");
   //    addInput("In R");

   //    addOutput("Out M");
   //    addOutput("Out S");
   // }

   // // <method_exit.png>
   // public virtual exit() {
   //    Mod::exit();
   // }

   // <method.png>
   public virtual isEffect() : boolean {
      return true;
   }

   // <method.png>
   public virtual modClone(boolean _bFullInit) : Mod {
      ModMidSideConvert *cl;
      if(this instanceof ModMidSideSplit)
         cl <= new ModMidSideSplit;
      else
         cl <= new ModMidSideMerge;
      cl.init();
      cl.modCopyBaseFrom(this);
      return deref cl;
   }

   // <method.png>
   public virtual modIsPatchCompatibleWith(Mod _o) : boolean {
      return (_o instanceof ModMidSideSplit);
   }

   // <method.png>
   public virtual modCopyPatchFrom(Mod _o) : boolean {
      if(_o instanceof ModMidSideSplit)
      {
         ModMidSideSplit o <= _o;
         return true;
      }
      return false;
   }

   // <save.png>
   public virtual saveState(Stream _ofs) : boolean {

      Mod::saveState(_ofs);

      // Write version
      _ofs.i16 = 1;

      return true;
   }

   // <load.png>
   public virtual loadState(Stream _ifs, boolean _bRestoreInstanceIDs) : boolean {

      boolean r = Mod::loadState(_ifs, _bRestoreInstanceIDs);

      if(r)
      {
         // Read version
         short ver = _ifs.u16;

         if(ver >= 1)
         {
            r = true;
         }
         else
         {
            Global.Error("ModMidSideSplit::loadState: invalid ver="+ver);
            r = false;
         }
      }

      return r;
   }

   // <replay.png>
   public virtual process(local int _numFrames,
                          local int _fltDev, local int _fltCh,
                          local int _forceCh, local int _globalCh,
                          local boolean _bPlaying
                          ) {

      local FloatArray inL <= input_bufs.get(0);
      local FloatArray inR <= input_bufs.get(1);

      local FloatArray outM <= output_bufs.get(0);
      local FloatArray outS <= output_bufs.get(1);

      if(_bPlaying)
      {
         tksampleedit_ms_convert_dualmono(outM, outS, 0,
                                          inL, inR, 0,
                                          amp,
                                          _numFrames
                                          );
      }
   }

}


// <class.png>
class ModMidSideSplit : ModMidSideConvert {

   // <method_init.png>
   public virtual init() {
      Mod::init();
      allocateIOBuffers(DEF_NUM_IO_BUFFERS/*numIn*/, DEF_NUM_IO_BUFFERS/*numOut*/);

      amp = 0.5;

      addInput("In L");
      addInput("In R");

      addOutput("Out M");
      addOutput("Out S");
   }

   // <method_get.png>
   public virtual getName() : String {
      return "M / S Split";
   }
}


// <class.png>
class ModMidSideMerge : ModMidSideConvert {

   // <method_init.png>
   public virtual init() {
      Mod::init();
      allocateIOBuffers(DEF_NUM_IO_BUFFERS/*numIn*/, DEF_NUM_IO_BUFFERS/*numOut*/);

      amp = 1.0;

      addInput("In M");
      addInput("In S");

      addOutput("Out L");
      addOutput("Out R");
   }

   // <method_get.png>
   public virtual getName() : String {
      return "M / S Merge";
   }
}
