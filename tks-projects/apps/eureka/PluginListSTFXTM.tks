// ----
// ---- file   : PluginListSTFXTM.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2023-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 21Apr2023
// ---- changed: 22Mar2024, 03Aug2024
// ----
// ----
// ----

module MPluginListSTFXTM;

use namespace ui;
use namespace st2;


// <class.png>
class PluginListSTFXTM : TableModel {

   define int COL_NAME = 0;

   protected STFXAuthor*[] authors;  // STFXAuthor instances
   int total_num_plugin_rows;


   // <method_set.png>
   public method setAuthors(PointerArray _authors) {
      authors <= deref _authors;
      total_num_plugin_rows = 0;
   }

   // <method_get.png>
   protected method getEntryByIdx(int _idx, Boolean _bRetIsHeader) : StPluginInfo {
      _bRetIsHeader = false;

      if(null != authors)
      {
         STFXAuthor *author;
         int idx = 0;

         foreach author in authors
         {
            if(_idx == idx)
            {
               // Author header
               _bRetIsHeader = true;
               return author.entries.get(0);
            }
            else if(_idx < (idx + 1 + author.entries.numElements))
            {
               return author.entries.get(_idx - idx - 1);
            }

            // Next author
            idx += 1 + (author.entries.numElements);
         }
      }
      return null;
   }

   // <method.png>
   public virtual tableModelChanged() {
      total_num_plugin_rows = 0;

      if(null != authors)
      {
         STFXAuthor *author;
         foreach author in authors
         {
            total_num_plugin_rows += 1 + (author.entries.numElements);
         }
      }

      TableModel::tableModelChanged();
   }

   // <method_get.png>
   public virtual getNumColumns() : int {
      return 1;
   }

   // <method_get.png>
   public virtual getColumnCaption(int _col) : String {
      return ["Name"][_col];
   }

   // <method_get.png>
   public virtual getNumRows() : int {
      return total_num_plugin_rows;
   }

   // <method_get.png>
   public virtual getDragObject(int _row) : Object {
      Boolean bIsHeader;
      StPluginInfo en <= getEntryByIdx(_row, bIsHeader);
      if(!bIsHeader)
      {
         return en;
      }
      return null;
   }

   // <method_get.png>
   public virtual getCellCaption(int _col, _row) : String {
      Boolean bIsHeader;
      StPluginInfo en <= getEntryByIdx(_row, bIsHeader);

      if(null != en)
      {
         if(bIsHeader)
         {
            switch(_col)
            {
               case COL_NAME:
                  return en.author.isBlank() ? "<other>" : en.author;
            }
         }
         else
         {
            switch(_col)
            {
               case COL_NAME:
                  return en.getName();
            }
         }
      }
   }

   // <method_get.png>
   public virtual getMinimumColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_NAME:
            return 120;
      }
   }

   // <method_get.png>
   public virtual getPreferredColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_NAME:
            return 170;
      }
   }

   // <method_get.png>
   public virtual getCellRenderer(int _col, int _row, int _visibleRow) : Layer {
      Label lb <= TableModel::getCellRenderer(_col, _row, _visibleRow);

      Boolean bIsHeader;
      StPluginInfo en <= getEntryByIdx(_row, bIsHeader);

      if(null != en)
      {
         lb.setEnableFillBackground(true);

         if(bIsHeader)
         {
            lb.setFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);
            lb.setInnerPadding4f(4, 1, 1, 1);
            lb.setBackgroundTint(#20000000);
            lb.setToolTipCaption(null);
         }
         else
         {
            lb.setInnerPadding4f(1, 1, 1, 1);
            lb.setBackgroundTint(0);
            lb.setToolTipCaption(en.getId());
         }
      }

      return lb;
   }

   // <method_update.png>
   public virtual updateCellRendererColors(Layer l, int _col, int _row, int _visibleRow) {
      Boolean bIsHeader;
      StPluginInfo en <= getEntryByIdx(_row, bIsHeader);

      // (note) default fg/bg cell colors are overridden in PluginList.tks:init()
      TableModel::updateCellRendererColors(l, _col, _row, _visibleRow);

      if(null != en)
      {
         if(cursor_index != _row)
         {
            l.setBackgroundColor(0);
            l.setEnableFillBackground(false);
         }

         if(bIsHeader)
         {
            l.setForegroundColor(#ffa8a29e);
            l.setBackgroundColor(#ff29292d);
            l.setEnableFillBackground(true);
         }
      }
   }

}
