// ----
// ---- file   : ModGridEmptyButton.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2018-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi/audio sequencer.
// ----
// ---- created: 12Feb2018
// ---- changed: 13Feb2018, 15Feb2018, 17Feb2018, 21Feb2018, 22Feb2018, 23Feb2018, 24Feb2018
// ----          28Feb2018, 01Mar2018, 21May2018, 21Jul2018, 05Jan2019, 31Jul2019, 17Nov2019
// ----          03Feb2021, 16Feb2021, 13Apr2021, 07Dec2021, 18Dec2022, 08Jul2023, 21Sep2023
// ----          01Nov2023, 22Mar2024, 05Jan2025
// ----
// ----
// ----

module MModGridEmptyButton;

use namespace ui;
use namespace st2;


// <class.png>
class ModGridEmptyButton : ModGridButtonBase {

   // <ui_init.png>
   public method initEmptyButton() {
      initButton();
   }

   // <ui_show.png>
   protected method showContextMenu() {

      pm_context <= PopupMenu.New(this);
      PopupMenu pm <= pm_context;
      PopupMenuButton *pmb;

      Lane lane <= parent_modgrid.getLaneByIdx(grid_x);
      pmb <= pm.addCheckButton("Lane Input from Track", lane.b_track_input, "lane_track_input");
      pmb.setToolTipCaption("When checked, default lane input is copied from track input\n\n When unchecked, lane input is zero, unless the output of a previous lane is routed to this lane");

      pm.addSeparator();
      if(ModGrid.HaveModClipboard())
      {
         pmb <= pm.addDefaultButton("Paste "+(ModGrid.mod_clipboard.getName()), "paste_mod_clipboard_as_new");
         pmb.setActive(true);
      }
      else
      {
         pmb <= pm.addDefaultButton("Paste", "paste_mod_clipboard_as_new");
         pmb.setActive(false);
      }

      pm.addSeparator();
      PopupMenu spm <= PopupMenu.New(pm);
      pmb <= pm.addIconMenu("Builtin..", "add", deref spm);
      pmb.setIconScale(0.5);

      pmb <= spm.addDefaultButton("Sampler",             "new_builtin_sample");
      pmb <= spm.addDefaultButton("Gain",                "new_builtin_gain");
      pmb <= spm.addDefaultButton("EQ3",                 "new_builtin_eq3");
      pmb <= spm.addDefaultButton("Mid / Side Splitter", "new_builtin_ms_split");
      pmb <= spm.addDefaultButton("Mid / Side Merger",   "new_builtin_ms_merge");
      pmb <= spm.addDefaultButton("Idle Detect",         "new_builtin_idledetect");
      pmb.setToolTipCaption("Insert after instrument and before effects\n\n (note) when level is lower than idle threshold, all following FX will be bypassed");
      pmb <= spm.addDefaultButton("Delay",               "new_builtin_delay");
      pmb <= spm.addDefaultButton("Sync",                "new_builtin_sync");
      pmb.setToolTipCaption(" (note) Sync instances are automatically aligned across all lanes / tracks\n (note) this is primarly meant for temporal alignment of external hardware instrument audio sources");
      pmb <= spm.addDefaultButton("Gate to Audio",        "new_builtin_gate2audio");
      pmb.setToolTipCaption(" (note) converts note on / off to gate signal (e.g. for DC coupled modular audio interface)");
      pmb <= spm.addDefaultButton("RPN to Audio",        "new_builtin_rpn2audio");
      pmb.setToolTipCaption(" (note) converts RPN 1..16 to left/mono channel audio output (e.g. for ES-3 DC coupled modular audio interface)");
      pmb <= spm.addDefaultButton("Audio to RPN",        "new_builtin_audio2rpn");
      pmb.setToolTipCaption(" (note) converts left/mono channel audio to RPN 100..115 (e.g. for ES-6 DC coupled modular audio interface)");

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Insert lane right", "insert_lane_right");
      pmb.setActive(Track.MAX_LANES != num_lanes);

      pmb <= pm.addDefaultButton("Duplicate lane", "duplicate_lane");
      pmb.setActive(Track.MAX_LANES != num_lanes);

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Copy lane to clipboard", "copy_lane_to_clipboard");

      pmb <= pm.addDefaultButton("Paste new lane from clipboard", "paste_new_lane_from_clipboard");
      pmb.setActive(Track.MAX_LANES != num_lanes);

      pm.addSeparator();
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Sync", deref spm);

      pmb <= spm.addDefaultButton("Sync lane mods from clipboard", "sync_lane_mods_from_clipboard");
      pmb.setToolTipCaption("Sync lane mods from clipboard\n\n (note) clipboard lane must have exact same setup");

      pmb <= spm.addDefaultButton("Sync lane mods + mod matrices from clipboard", "sync_lane_mods_and_mod_matrices_from_clipboard");
      pmb.setToolTipCaption("Sync lane mods and mod matrices from clipboard\n\n (note) clipboard lane must have exact same setup");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Sync other MPE/LPC/VRR lanes from this", "sync_other_lanes_from_this");
      pmb.setToolTipCaption("Sync other MPE/LPC/VRR lanes from this lane\n\n (note) other lanes must have exact same setup");
      pmb.setAccelerators("lctrl-j", "");

      pmb <= spm.addDefaultButton("Sync other MPE/LPC/VRR lanes and mod matrices from this", "sync_other_lanes_and_mod_matrices_from_this");
      pmb.setToolTipCaption("Sync other MPE/LPC/VRR lanes and mod matrices from this lane\n\n (note) other lanes must have exact same setup");
      pmb.setAccelerators("lctrl-lshift-j", "");

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Move lane left", "move_lane_left");
      pmb.setActive(grid_x > 0);

      pmb <= pm.addDefaultButton("Move lane right", "move_lane_right");
      pmb.setActive(grid_x != (num_lanes-1));

      pm.addSeparator();
      pmb <= pm.addIconButton("Delete lane", "trashcan_sm", "delete_lane");

      pmb.setActive(num_lanes > 1);
      pmb.setBackgroundTint(pmb.isActive() ? DELETE_TINT32_ACTIVE : DELETE_TINT32_INACTIVE);

      pm.addSeparator();
      pmb <= pm.addIconButton("Delete unused lanes", "trashcan_sm", "delete_unused_lanes");
      pmb.setActive(num_lanes > 1);
      pmb.setBackgroundTint(pmb.isActive() ? DELETE_TINT32_ACTIVE : DELETE_TINT32_INACTIVE);

      pm.resizeToMinimum();

      pm.showNearMouse(-30 * UI.font_scaling, -50 * UI.font_scaling);

      Global.Print("Show lane context menu.");
   }

   // <ui_handle.png>
   protected virtual onMouseClick(MouseEvent _ev/*or null*/) : boolean {
      if(_ev.isRightButton())
      {
         showContextMenu();
         return true;
      }
      return Button::onMouseClick(_ev);
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _ac) : boolean {
      String acName <= _ac.getActionName();
      ActionProvider ap <= _ac.getActionProvider();

      Mod mod <= getUserData();

      switch(@(ap))
      {
         case @(pm_context):
            Global.Debug2("ModGridEmptyButton: pm_context acName="+acName);
            switch(acName)
            {
               case PopupMenu.ACTION_CANCEL:
               case "":
                  Global.Print("Close context menu.");
                  return true;

               default:
                  Global.Print("Select: "+acName);
                  return true;

               case "paste_mod_clipboard_as_new":
                  parent_modgrid.handlePasteModClipboardAsNew(grid_x, grid_y);
                  return true;

               case "new_builtin_gain":
                  parent_modgrid.handleCreateNewGainAt(grid_x, grid_y);
                  return true;

               case "new_builtin_eq3":
                  parent_modgrid.handleCreateNewEQ3At(grid_x, grid_y);
                  return true;

               case "new_builtin_ms_split":
                  parent_modgrid.handleCreateNewMidSideSplitAt(grid_x, grid_y);
                  return true;

               case "new_builtin_ms_merge":
                  parent_modgrid.handleCreateNewMidSideMergeAt(grid_x, grid_y);
                  return true;

               case "new_builtin_idledetect":
                  parent_modgrid.handleCreateNewIdleDetectAt(grid_x, grid_y);
                  return true;

               case "new_builtin_delay":
                  parent_modgrid.handleCreateNewDelayAt(grid_x, grid_y);
                  return true;

               case "new_builtin_sync":
                  parent_modgrid.handleCreateNewSyncAt(grid_x, grid_y);
                  return true;

               case "new_builtin_gate2audio":
                  parent_modgrid.handleCreateNewGate2AudioAt(grid_x, grid_y);
                  return true;

               case "new_builtin_rpn2audio":
                  parent_modgrid.handleCreateNewRPN2AudioAt(grid_x, grid_y);
                  return true;

               case "new_builtin_audio2rpn":
                  parent_modgrid.handleCreateNewAudio2RPNAt(grid_x, grid_y);
                  return true;

               case "new_builtin_sample":
                  parent_modgrid.handleCreateNewSampleAt(grid_x, grid_y);
                  return true;

               case "lane_track_input":
                  parent_modgrid.toggleLaneTrackInput(grid_x);
                  return true;

               case "insert_lane_right":
                  parent_modgrid.handleInsertLaneRight(grid_x, false/*bQuiet*/);
                  return true;

               case "duplicate_lane":
                  parent_modgrid.handleDuplicateLane(grid_x);
                  return true;

               case "copy_lane_to_clipboard":
                  parent_modgrid.handleCopyLaneToClipboard(grid_x);
                  return true;

               case "paste_new_lane_from_clipboard":
                  parent_modgrid.handlePasteNewLaneFromClipboard(grid_x);
                  return true;

               case "sync_lane_mods_from_clipboard":
                  parent_modgrid.handleSyncLaneModsFromClipboard(grid_x, true/*bSyncModMatrix*/);
                  return true;

               case "sync_lane_mods_and_mod_matrices_from_clipboard":
                  parent_modgrid.handleSyncLaneModsFromClipboard(grid_x, false/*bSyncModMatrix*/);
                  return true;

               case "sync_other_lanes_from_this":
                  parent_modgrid.handleSyncOtherLanesFromThis(grid_x, false/*bSyncModMatrix*/);
                  return true;

               case "sync_other_lanes_and_mod_matrices_from_this":
                  parent_modgrid.handleSyncOtherLanesFromThis(grid_x, true/*bSyncModMatrix*/);
                  return true;

               case "move_lane_left":
                  parent_modgrid.handleMoveLaneLeft(grid_x);
                  return true;

               case "move_lane_right":
                  parent_modgrid.handleMoveLaneRight(grid_x);
                  return true;

               case "delete_lane":
                  parent_modgrid.handleDeleteLane(grid_x);
                  return true;

               case "delete_unused_lanes":
                  parent_modgrid.handleDeleteUnusedLanes();
                  return true;
            }
            return true;
      }
      return Button::consumeAction(_ac);
   }
}
