// ----
// ---- file   : utils.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2009-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 26Dec2009, 02Jan2010, 29Jan2010, 10Oct2010, 19Jan2011, 07Mar2011, 15Jan2012
// ----          13May2012, 01Jun2013, 03Jun2013, 09Aug2014, 29Sep2014, 23Jan2015, 24Jan2015
// ----          02Feb2015, 19Apr2015, 28Feb2016, 28Mar2016, 04Apr2016, 08Mar2017, 11Mar2017
// ----          14Apr2017, 09Jun2017, 04Jan2018, 22Jan2018, 24Jan2018, 15Feb2018, 24Feb2018
// ----          26Feb2018, 28Feb2018, 04Mar2018, 06Jul2018, 16Dec2018, 02Jan2019, 05Jan2019
// ----          18May2019, 06Jul2019, 15Oct2019, 21Jun2020, 28Aug2020, 02Jul2022, 10Aug2022
// ----          06Feb2023, 09Feb2023, 19Feb2023, 11Mar2023, 25Mar2023, 01Apr2023, 04May2023
// ----          26May2023, 11Aug2023, 13Aug2023, 18Aug2023, 10Sep2023, 22Sep2023, 11Nov2023
// ----          13Jan2024, 17Jan2024, 04Feb2024, 23Feb2024, 19Apr2024, 03Jul2024, 05Jul2024
// ----          02Aug2024, 03Aug2024, 06Aug2024, 07Aug2024, 14Sep2024, 15Sep2024, 10Oct2024
// ----          17Dec2024, 29Dec2024, 03Jan2025, 14Jan2025
// ----
// ----
// ----

module MUtils;

use namespace ui;
use namespace st2;


// <class.png>
class Utils {

   // <method.png>
   static SplitPathname(String name, path, file) {
      // Split last used file name into directory/file components

      int idx = name.lastIndexOf("/");
      int idxDos = name.lastIndexOf("\\");
      if(idxDos > idx)
      {
         idx = idxDos;
      }

      if(-1 != idx)
      {
         name.substring(0, idx) => path;
         name.substring(idx+1, -1) => file;
      }
      else
      {
         path = null;
         file = name;
      }

      // // trace "xxx SplitPathname: name=\""+name+"\" path=\""+path+"\" file=\""+file+"\".";
   }

   // <method.png>
   static BaseName(String _pathName) : String {
      // "some/path/myfile.ext" => "myfile"
      local String path;
      local String file;
      SplitPathname(_pathName, path, file);
      int idx = file.lastIndexOf(".");  // (todo) lastIndexOfChar()
      if(-1 != idx)
      {
         return file.substring(0, idx);
      }
      // no suffix ??
      return deref file;
   }

   // <method.png>
   static ExtractFileNameFromPathName(String _pathname) : String {
      String dir;
      local String file;
      SplitPathname(_pathname, dir, file);
      return deref file;
   }

   // <method.png>
   static ConvertToFileName(String _name) : String {
      local String r = _name;
      r.replaceChar(':',  '_');
      r.replaceChar('/',  '_');
      r.replaceChar('\\', '_');
      r.replaceChar('$',  '_');
      r.replaceChar('&',  '_');
      r.replaceChar('Â§',  '_');
      r.replaceChar('%',  '_');
      r.replaceChar('\'', '_');
      r.replaceChar('`',  '_');
      r.replaceChar('<',  '_');
      r.replaceChar('>',  '_');
      r.replaceChar('*',  '_');
      r.replaceChar('|',  '_');
      r.replaceChar('!',  '_');
      r.replaceChar('?',  '_');
      r.replaceChar('^',  '_');
      r.replaceChar('=',  '_');
      r.replaceChar('~',  '_');
      r.replaceChar('#',  '_');
      r.replaceChar(';',  '_');
      return deref r;
   }

   // <method.png>
   static ConvertToVarName(String _name) : String {
      local String r = _name;
      r.replaceChar(' ',  '_');
      r.replaceChar('-',  '_');
      r.replaceChar('+',  '_');
      r.replaceChar(':',  '_');
      r.replaceChar('/',  '_');
      r.replaceChar('\\', '_');
      r.replaceChar('$',  '_');
      r.replaceChar('&',  '_');
      r.replaceChar('Â§',  '_');
      r.replaceChar('%',  '_');
      r.replaceChar('\'', '_');
      r.replaceChar('`',  '_');
      r.replaceChar('<',  '_');
      r.replaceChar('>',  '_');
      r.replaceChar('*',  '_');
      r.replaceChar('|',  '_');
      r.replaceChar('!',  '_');
      r.replaceChar('?',  '_');
      r.replaceChar('^',  '_');
      r.replaceChar('=',  '_');
      r.replaceChar('~',  '_');
      r.replaceChar('#',  '_');
      r.replaceChar(';',  '_');
      if(0 == r.charsetIndexOf("0123456789", 0))
         r.insert(0, "x");
      return deref r;
   }

   // <method.png>
   static BuildPathnameFromSuggestedNameAndEditorName(String _suggestedPathname, String _editorName) : String {
      String suggestedDir;
      String suggestedFile;
      SplitPathname(_suggestedPathname, suggestedDir, suggestedFile);
      return suggestedDir+"/"+ConvertToFileName(_editorName);
   }

   // <method.png>
   static FixFileName(local String _name) : String {
      local String r = _name;
      r.replaceChar('\\', '/');
      r.replace("//", "/");
      r.replace("//", "/");
      // // trace "xxx FixFileName: r=\""+r+"\"";
      return deref r;
   }

   // <method.png>
   static LazyAppendSuffix(String _name, String _suffix) : String {
      local String r = _name;
      if(!r.endsWith(_suffix))
         r.append(_suffix);
      return deref r;
   }

   // <method.png>
   static LazyRemoveSuffix(String _name, String _suffix) : String {
      String r = _name;
      int idx = r.lastIndexOf(_suffix);
      // // trace "xxx LazyRemoveSuffix: name=\""+_name+"\" suffix=\""+_suffix+"\" idx="+idx;
      if(-1 != idx)
      {
         r.replaceRegion(idx, r.length, "");
      }
      // // trace "xxx LazyRemoveSuffix:   => r=\""+r+"\"";
      return r;
   }

   // <method.png>
   static RemoveDirPrefix(String _pathName, String _dirPrefix) : String {
      String dirPrefix = FixFileName(_dirPrefix);
      String pathName = FixFileName(_pathName);
      pathName.replace(dirPrefix, "");
      return pathName;
   }

   // <method.png>
   static PrependDirPrefix(String _pathName, String _dirPrefix) : String {
      String dirPrefix = FixFileName(_dirPrefix);
      String pathName = FixFileName(_pathName);
      pathName.replace(dirPrefix, "");
      return FixFileName(dirPrefix+"/"+pathName);
   }

   // <method.png>
   static Backtrace() {
      try { throw UncriticalError("debug/backtrace"); } catch(UncriticalError e) { trace e.stackTrace; }
   }

   // <method_get.png>
   static GetCurrentDateString() : String {
      Time t; t.now();
      Integer io = t.monthday;
      return
         io.printf("%02d")+
         ((["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"])[t.month])+t.year;
   }

   // <method_get.png>
   static GetCurrentTimeString() : String {
      Time t;
      Integer io_h;
      Integer io_m;
      Integer io_s;
      t.now();
      io_h.value=t.hour;
      io_m.value=t.min;
      io_s.value=t.sec;
      return io_h.printf("%02i")+"_"+io_m.printf("%02i")+"_"+io_s.printf("%02i");
   }

   // <method_get.png>
   static GetCurrentDateTimeStringNumeric() : String {
      Time t;
      Integer io_mon;
      Integer io_mday;
      Integer io_h;
      Integer io_m;
      Integer io_s;
      t.now();
      io_mon = t.month + 1;
      io_mday = t.monthday;
      io_h.value=t.hour;
      io_m.value=t.min;
      io_s.value=t.sec;
      return t.year + io_mon.printf("%02d")+io_mday.printf("%02d")+"-"+io_h.printf("%02i")+io_m.printf("%02i")+io_s.printf("%02i");
   }

   // <method.png>
   static HexDump(Buffer buf, int start, int num) {
      int HEXDUMP_COLS = 16;
      int j, i=start;
      int c;
      int x=0;
      int y=start;
      Integer io;
      io.value=i-start;
      stdout io.printf("%04x: ");
      loop(num)
      {
         io.value=buf[i++];
         stdout io.printf("%02x ");
         if( (++x % HEXDUMP_COLS) == 0)
         {
            j = y;
            loop(HEXDUMP_COLS)
            {
               c = buf[j++];
               if(c<32)
                  c='.';
               else if(c>126)
                  c='.';
               stdout tcchar(c);
            }
            stdout "\n";
            if(i<(start+num))
            {
               io.value = i-start;
               stdout io.printf("%04x: ");
            }
            x = 0;
            y += HEXDUMP_COLS;
         }
      }
      if(x)
      {
         loop(3*(HEXDUMP_COLS-x))
         {
            stdout " ";
         }
         j = y;
         loop(x)
         {
            c = buf[j++];
            if(c<32)
               c='.';
            else if(c>126)
               c='.';
            stdout tcchar(c);
         }
         stdout "\n";
      }
   }

   // <method.png>
   static BufferDiff(Buffer a, Buffer b, boolean _bVerbose) : boolean {
      boolean ret = true;

      if(_bVerbose)
         Global.Debug("Utils::BufferDiff: a.size="+a.size+" b.size="+b.size);

      if(a.size > 0)
      {
         if(a.size == b.size)
         {
            Integer off = 0;

            ret = false;

            loop(a.size)
            {
               UnsignedByte ba = a.peekI8(off);
               UnsignedByte bb = b.peekI8(off);

               if(ba != bb)
               {
                  if(_bVerbose)
                     Global.Debug("Utils::BufferDiff: diff at off="+off+" ("+off.printf("0x%x")+") a="+ba.printf("0x%02x")+" b="+bb.printf("0x%02x"));
                  ret = true;
               }

               off++;
            }
         }
      }

      return ret;
   }

   // <method.png>
   static SaveBufferToFile(String _filename, Buffer _b, int _offset, int _num) {
      File f;
      if(f.openLocal(_filename, IOS_OUT))
      {
         int off = _offset;
         loop(_num)
         {
            byte c = _b.peekI8(off++);
            f.i8 = c;
         }

         f.close();

         Global.Debug("Utils::SaveBufferToFile: filename=\""+_filename+"\" off="+_offset+" num="+_num);
      }
   }

   // <method.png>
   static ExtractCopyPrefix(String _s, String _prefix) {
      int idx = _s.indexOf("(Copy", 0);
      if(-1 == idx)
      {
         idx = _s.length;
      }
      _s.substring(0, idx) => _prefix;
   }

   // <method.png>
   static DetermineCopyNr(String _s) : int {
      int idx = _s.indexOf("(Copy", 0);
      if(-1 != idx)
      {
         int idxNrStart = idx + 5;
         int idxNrEnd = _s.indexOfChar(')', idxNrStart);
         if(-1 == idxNrEnd)
         {
            idxNrEnd = _s.length;
         }
         return _s.substring(idxNrStart, idxNrEnd-idxNrStart).trim();
      }

      return -1;
   }

   // <method.png>
   static BuildCopiedName(String _orig, int _appendixNr) : String {
      // Adds incremental " (Copy x)" string to end of original name and returns new string

      int idx = _orig.indexOf("(Copy", 0);
      local String r;
      if(-1 != idx)
      {
         int idxNrStart = idx + 5;
         _orig.substring(0, idxNrStart) => r;
         int idxNrEnd = _orig.indexOfChar(')', idxNrStart);
         if(-1 != idxNrEnd)
         {
            r.append(" ");
            r.append(_appendixNr);
            r.append(")");
            r.append(_orig.substring(idxNrEnd+1, _orig.length-(idxNrEnd+1)));
         }
         else
         {
            r.append(" 1)");
         }
      }
      else
      {
         r = _orig;
         r.append(" (Copy ");
         r.append(_appendixNr);
         r.append(")");
      }
      return deref r;
   }

   // <method.png>
   public static KeycodeToMidiNote(int _code):int {
      switch(_code) {
         case 122: return  0; //c-0: 122
         case 115: return  1; //c#0: 115
         case 120: return  2; //d-0: 120
         case 100: return  3; //d#0: 100
         case  99: return  4; //e-0: 99
         case 118: return  5; //f-0: 118
         case 103: return  6; //f#0: 103
         case  98: return  7; //g-0: 98
         case 104: return  8; //g#0: 104
         case 110: return  9; //a-0: 110
         case 106: return 10; //a#0: 106
         case 109: return 11; //b-0: 109
         case  44: return 12; //c-1: 44
         case 108: return 13; //c#1: 108
         case  46: return 14; //d-1: 46
         case  59: return 15; //d#1: 59
         case  47: return 16; //e-1: 47
         case 113: return 12; //c-1: 113
         case  50: return 13; //c#1: 50
         case 119: return 14; //d-1: 119
         case  51: return 15; //d#1: 51
         case 101: return 16; //e-1: 101
         case 114: return 17; //f-1: 114
         case  53: return 18; //f#1: 53
         case 116: return 19; //g-1: 116
         case  54: return 20; //g#1: 54
         case 121: return 21; //a-1: 121
         case  55: return 22; //a#1: 55
         case 117: return 23; //h-1: 117
         case 105: return 24; //c-2: 105
         case  57: return 25; //c#2: 57
         case 111: return 26; //d-2: 111
         case  48: return 27; //d#2: 48
         case 112: return 28; //e-2: 112
         case  91: return 29; //f-2: 91
         case  61: return 30; //f#2: 61
         case  93: return 31; //g-2: 93
      }
      return -1;
   }

   // <method.png>
   static KeycodeToHex(Key _k) : int {
      switch(_k.unicode)
      {
         case '0': return 0;
         case '1': return 1;
         case '2': return 2;
         case '3': return 3;
         case '4': return 4;
         case '5': return 5;
         case '6': return 6;
         case '7': return 7;
         case '8': return 8;
         case '9': return 9;
         case 'a': return 10;
         case 'b': return 11;
         case 'c': return 12;
         case 'd': return 13;
         case 'e': return 14;
         case 'f': return 15;
      }

      if(_k.modShiftOrCaps())
      {
         // German kbd
         if("de" == STConfig.kbd_layout)
         {
            switch(_k.unicode)
            {
               case '=': return 0;
               case '!': return 1;
               case '"': return 2;
               case 'Â§': return 3;
               case '$': return 4;
               case '%': return 5;
               case '&': return 6;
               case '/': return 7;
               case '(': return 8;
               case ')': return 9;
               case 'A': return 10;
               case 'B': return 11;
               case 'C': return 12;
               case 'D': return 13;
               case 'E': return 14;
               case 'F': return 15;
            }
         }
         //else if("us" == STConfig.kbd_layout)
         {
            switch(_k.code)
            {
               case '0': return 0;
               case '1': return 1;
               case '2': return 2;
               case '3': return 3;
               case '4': return 4;
               case '5': return 5;
               case '6': return 6;
               case '7': return 7;
               case '8': return 8;
               case '9': return 9;
               case 'A': return 10;
               case 'B': return 11;
               case 'C': return 12;
               case 'D': return 13;
               case 'E': return 14;
               case 'F': return 15;
            }
         }
      }

      return -1;
   }

   // <method_get.png>
   static GetNumString(int _num, String _s) : String {
      if( (_num > 1) || (0 == _num) )
      {
         return _num+" "+_s + "s";
      }
      else
      {
         return _num+" "+_s;
      }
   }

   // <method_get.png>
   static GetNumString2(int _num, String _s1, String _s2) : String {
      if( (_num > 1) || (0 == _num) )
      {
         return _num+" "+_s2;
      }
      else
      {
         return _num+" "+_s1;
      }
   }

   // <method_get.png>
   static GetNumString3(float _num, String _s1, String _s2) : String {
      // e.g. "0.75 bars", "1.25 bars", "1 bar", "0 bars"
      // (note) truncate float to 2 decimal places
      if( (_num > 1) || (_num < 1) )
      {
         Float num = _num;

         if(0 == _num)
         {
            return "0 "+_s2;
         }
         else if(int(_num) == _num)
         {
            return int(_num)+" "+_s2;
         }
         else
         {
            return num.printf("%3.2f")+" "+_s2;
         }
      }
      else
      {
         return "1 "+_s1;
      }
   }

   // <method_get.png>
   static GetEnableString(boolean _bEnabled) : String {
      return (maybe == _bEnabled) ? "enabled(maybe)" : (false != _bEnabled) ? "enabled" : "disabled";
   }

   // <method_get.png>
   static GetEnableStringMixed(boolean _bEnabled, String _sFalse, String _sTrue, String _sMixed) : String {
      return (maybe == _bEnabled) ? _sMixed : (false != _bEnabled) ? _sTrue : _sFalse;
   }

   // <method.png>
   public static IntToBinary255String(byte _val) : String {
      _val &= 255;

      String r = "0b";
      int bit = 128;
      loop(8)
      {
         if(_val & bit)
            r.append("1");
         else
            r.append("0");
         bit >>= 1;
      }

      return r;
   }

   // <method.png>
   public static GetPluralString(int _num) : String {
      if((0 == _num) || (abs(_num) > 1))
         return "s";
      return "";
   }

   // <method.png>
   public static GetPluralStringEx(int _num, String _single, String _multi) : String {
      if((0 == _num) || (abs(_num) > 1))
         return _multi;
      return _single;
   }

   // <method.png>
   public static GetPluralStringFloat(float _f) : String {
      if((0.0f == _f) || (_f > 1.0f) || ((_f < 1.0f) && (_f != -1.0f)))
      // return ( (_f < 0.0001) || (_f > 1.0) || (frac(_f)>0.001) ) ? "s" : "";
         return "s";
      return "";
   }

   // <method.png>
   public static IsWindows() {
      // // return (null != getenv("COMSPEC"));
      return (".dll" == TKS.dllSuffix);
   }

   // <method.png>
   public static IsLinux() {
      return (".so" == TKS.dllSuffix);
   }

   // <method.png>
   public static IsMacOS() {
      return (".dylib" == TKS.dllSuffix);
   }

   // <method.png>
   public static SubstitutePathVars(local String _path) : String {
      local String r = _path;
      loop(2)
      {
         r.replace("$(TMP)",             STConfig.temp);
         r.replace("$(PROGRAM_DIR)",     st2::program_directory);
         r.replace("$(ROOT)",            STConfig.rootpath);
         r.replace("$(CACHE_DIR)",       STConfig.cache_rootpath);
         r.replace("$(PROJECT_DIR)",     STConfig.project_rootpath);
         r.replace("$(PROJECT_NAME)",    Utils.ConvertToFileName(current_project.project_name));
         r.replace("$(PROJECT_SAMPLES)", STConfig.project_samples_wav_rootpath);
         r.replace("$(PROJECT_EXPORT)" , STConfig.exported_samples_wav_rootpath);
         r.replace("$(TKS_DIR)",         TKS.tksExeDir);
         r.replace("$(HOME)",            getenv("HOME"));
      }

      r.replace("//", "/");

      return deref r;
   }

   // <method.png>
   public static ReadDirectory(String _pathName) : StringArray {
      local String nativePathName <= ToNativePathName(_pathName);
      local StringArray a <= tkfileutils_read_directory(nativePathName);
      if(null != a)
      {
         local IntArray iaSort;
         a.sortByValue(iaSort, false/*bCS*/);
         a.rearrange(iaSort);
      }
      return deref a;
   }

   // <method.png>
   public static CanFileBeRead(String _pathName) : boolean {
      File f;
      if(f.openLocal(_pathName, IOS_IN))
      {
         f.close();
         return true;
      }
      return false;
   }

   // <method.png>
   static public method FixPathname(String _name) : String {
      if(_name <= "~")
         return getenv("HOME")+"/"+_name.substring(1,9999);
      return _name;
   }

   // <method.png>
   public static FixPathname_psystem_exe(local String _pathName) : String {
      local String r;
      _pathName.replace("//", "/") => r;

      if(IsWindows())
      {
         // Windows
         r.replace("/", "\\");
         r.replace("\\\\", "\\");
         // // // cmdLine.replace(" ", "\\ ");
         // // // cmdLine.replace("(", "\\(");  // does not work (=> "c:\Program" not found)
         // // // cmdLine.replace(")", "\\)");
      }

      return "\""+r+"\"";
   }

   // <method.png>
   public static FixPathname_psystem_arg(String _pathName) : String {
      String r;
      _pathName.replace("//", "/") => r;

      if(IsWindows())
      {
         // Windows
         r.replace("/", "\\");
         r.replace("\\\\", "\\");
         // r.replace(" ", "\\ ");
         // // r.replace(" ", "\" \"");  // wth
      }

      return r;
   }

   // <method.png>
   public static RunPSystemR(local String _jobName, local String _cmd, local StringArray _args, local String _sRet) {
      local String *cmdLine;
      local String *arg;
      local String sArgs;
      foreach arg in _args
      {
         if(Utils.IsWindows())
            sArgs.append(" \""+arg+"\"");
         else
         {
            sArgs.append(" ");
            sArgs.append(arg
                         .replace(" ", "\\ ")
                         .replace("(", "\\(")
                         .replace(")", "\\)")
                         .replace("[", "\\[")
                         .replace("]", "\\]")
                         .replace("{", "\\{")
                         .replace("}", "\\}")
                         .replace("<", "\\<")
                         .replace(">", "\\>")
                         .replace("|", "\\|")
                         .replace("^", "\\^")
                         .replace("=", "\\=")
                         .replace("~", "\\~")
                         .replace("+", "\\+")
                         .replace(":", "\\:")
                         .replace(";", "\\;")
                         .replace("*", "\\*")
                         .replace("?", "\\?")
                         .replace("!", "\\!")
                         .replace("#", "\\#")
                         .replace("%", "\\%")
                         .replace("&", "\\&")
                         .replace("$", "\\$")
                         )
               ;
         }
      }

      if(Utils.IsWindows())
      {
         // (note) popen() cannot handle arguments with spaces
         // (note) the workaround is to write the cmdline to a .bat file, then exec that
         // // trace "xxx STConfig.temp="+STConfig.temp+" native=\""+ToNativePathName(STConfig.temp)+"\"";
         local String tmpBat <= ToNativePathName(STConfig.temp)+"/"+_jobName+".bat";
         tmpBat <= FixPathname_psystem_arg(tmpBat);
         cmdLine <= "@echo off\n"+Utils.FixPathname_psystem_exe(_cmd)+sArgs;
         cmdLine.saveLocal(tmpBat);
         tmpBat = Utils.FixPathname_psystem_exe(tmpBat);
         trace "[trc] Utils::RunPSystemR: jobName=\""+_jobName+"\" tmpBat=<<"+tmpBat+">>";
         psystem(tmpBat, 'r', _sRet);
      }
      else // if(Utils.IsMacOS() || Utils.IsLinux())
      {
         cmdLine <= "sh -c "+Utils.FixPathname_psystem_exe(_cmd+sArgs);
         trace "[trc] Utils::RunPSystemR: jobName=\""+_jobName+"\" cmdLine=<<"+cmdLine+">>";
         psystem(cmdLine, 'r', _sRet);
      }
   }


   // <method_write.png>
   static public method WriteString(local Stream _out, local String _s) {
      // (note) first 32bit int of data is string length
      if(null != _s)
         _out.serialize(_s, false);
      else
         _out.i32 = 0;
   }

   // <method_read.png>
   static public method ReadString(local Stream _in, local String _s) : int {
      local int startOff = _in.offset;
      _in.deserialize(_s, false);
      return _in.offset - startOff;
   }

   // <method_write.png>
   static public method WriteIntArray(local Stream _out, local IntArray _ia) {
      _out.i32 = _ia.numElements*4;
      local int i = 0;
      loop(_ia.numElements)
         _out.i32 = _ia[i++];
   }

   // <method_read.png>
   static public method ReadIntArray(local Stream _in, local IntArray _ia) {
      local int numElements = _in.i32 / 4;
      _ia.alloc(numElements);
      loop(numElements)
         _ia.add(_in.i32);
   }

   // <method_write.png>
   static public method WriteShortArray(local Stream _out, local IntArray _ia) {
      _out.i32 = _ia.numElements;
      local int i = 0;
      loop(_ia.numElements)
         _out.i16 = _ia[i++];
   }

   // <method_read.png>
   static public method ReadShortArray(local Stream _in, local IntArray _ia) {
      local int numElements = _in.i32;
      _ia.alloc(numElements);
      loop(numElements)
         _ia.add(_in.s16);
   }

   // <method_write.png>
   static public method WriteByteArray(local Stream _out, local IntArray _ia) {
      _out.i32 = _ia.numElements;
      local int i = 0;
      loop(_ia.numElements)
         _out.i8 = _ia[i++];
   }

   // <method_read.png>
   static public method ReadByteArray(local Stream _in, local IntArray _ia) {
      local int numElements = _in.i32;
      _ia.alloc(numElements);
      loop(numElements)
         _ia.add(_in.s8);
   }

   // <method_write.png>
   static public method WriteFloatArray(local Stream _out, local FloatArray _fa) {
      _out.i32 = _fa.numElements*4;
      local int i = 0;
      loop(_fa.numElements)
         _out.f32 = _fa[i++];
   }

   // <method_read.png>
   static public method ReadFloatArray(local Stream _in, local FloatArray _fa) {
      local int numElements = _in.i32 / 4;
      _fa.alloc(numElements);
      loop(numElements)
         _fa.add(_in.f32);
   }

   // <method_read.png>
   static public method ReadFloatArrayNoAlloc(local Stream _in, local FloatArray _fa) {
      local int numElements = _in.i32 / 4;
      int num = mathMini(_fa.numElements, numElements);
      int idx = 0;
      loop(num)
         _fa[idx++] = _in.f32;

      if(num < numElements)
      {
         trace "[~~~] ReadFloatArrayNoAlloc: dest array is too short (have="+_fa.numElements+" need="+numElements+")";
         loop(numElements - num)
            _in.getF32();  // dummy read (discard)
      }
   }

   // <method_write.png>
   static public WriteEnvelope(local Stream _out, local Envelope _env) {
      _out.i32 = _env.interpolation;
      _out.i32 = _env.numElements;
      local int i = 0;
      loop(_env.numElements)
         _out.f32 = _env[i++];
   }

   // <method_read.png>
   static public ReadEnvelope(local Stream _in, local Envelope _env) : boolean {
      _env.free();
      _env.interpolation = _in.i32;
      local int numElements = _in.i32;
      if(0 <= numElements < 100000)
      {
         _env.alloc(numElements);
         _env.useAll();
         local int i = 0;
         loop(numElements)
            _env[i++] = _in.f32;
         return true;
      }
      else
      {
         trace "[---] Utils::ReadEnvelope: invalid numElements="+numElements;
         return false;
      }
   }

   // // <method.png>
   // static method LevelToDB(float _v) : float {
   //    /*
   //      ld(x) = ln(x) / ln(2)
   //      db = (ln(v) / ln(2)) * 6
   //    */
   //    return 6.0f * log(_v) / log(2.0f);
   // }

   // <method.png>
   static method DBToLevel(local float _db) : float {
      return mathPowerf(2.0f, _db * (1.0f / 6));
   }

   // <method.png>
   static public method LevelToDB(float _level) : float {
      // y = pow(10, (db/20))
      // x = (db/20)
      // y = pow(10, x)
      // log(y) = log(pow(10,x))
      // log(y) = x * log(10)
      // log(y) / log(10) = x
      // log(y) / log(10) = db / 20
      // 20 * log(y) / log(10) = db
      float r = 20.0f * log(_level) / log(10.0f);
      return r;
   }

   // <method.png>
   static public method DBToRel(float _db) : float {
      // return value in 0..1 range (0=<-90dB, 1=0db)
      float r;
      if(_db < -90.0)
         r = 0.0f;
      else
         r = 1.0 - (-_db / 90.0f);
      return r;
   }

   // <method.png>
   static public method LevelToDBRel(float _level) : float {
      // return value in 0..1 range (0=<-90dB, 1=0db)
      float db = LevelToDB(_level);
      return DBToRel(db);
   }

   // <method.png>
   static public method GetSnapToZeroFloatString(float _f) : String {
      if(abs(_f) < 0.0001)
         return "0";
      else
         return _f;
   }

   // <method.png>
   static BPMPPQToMS(float _bpm, float _ppq) : float {
      return 1000.0f / (_bpm * _ppq / 60.0f);
   }

   // <method.png>
   static MkDirHierarchy(String _pathName) {
      local StringArray subpaths <= _pathName.splitChar('/');
      if(null != subpaths)
      {
         local String dirname = "";
         String *subdir;
         foreach subdir in subpaths
         {
            dirname.append(subdir);
            if!(dirname >= ":")  // skip drives (e.g. "f:")
            {
               // trace "[dbg] Utils::MkDirHierarchy: mkdir dirname=\""+dirname+"\"";
               tkfileutils_mkdir(dirname);
            }
            dirname.append("/");
         }
      }
   }

   // <method.png>
   static public method ToNativePathName(local String _name) : String {
      local String r <= SubstitutePathVars(deref _name);
      r <= SubstitutePathVars(deref r);
      r.replace("//", "/");
      if(r <= "~")
         r <= getenv("HOME")+"/"+r.substring(1,9999);
      r.replace("//", "/");
      return deref r;
   }

   // <method.png>
   public static IsRelativePathname(String _name) {
      return
         !(_name & ":") &&
         !_name.startsWith("/") &&
         !_name.startsWith("~") ;
   }

   // <method.png>
   public static AlignString(String _s, int _numCols) : String {
      local String r = _s;
      int num = _s.numChars;
      if(num < _numCols)
      {
         r.appendRepeat(" ", (_numCols - num));
      }
      return deref r;
   }

   // <method.png>
   public static AlignStringRight(String _s, int _numCols) : String {
      local String r;
      int num = _s.numChars;
      if(num < _numCols)
      {
         r.appendRepeat(" ", (_numCols - num));
      }
      r.append(_s);
      return deref r;
   }

   // <method.png>
   public static AlignStringC(String _s, char _c, int _numCols) : String {
      local String r = _s;
      int num = _s.numChars;
      local String sc <= tcchar(_c);
      if(num < _numCols)
      {
         r.appendRepeat(sc, (_numCols - num));
      }
      return deref r;
   }

   // <method.png>
   public static FramesAndRateToDurationString(String _s, int _sampleRate, int _numFrames) {
      float sec = _numFrames / float(_sampleRate);
      local Integer h = int(sec / (60*60)) % 99;
      local Integer m = int(sec / 60) % 60;
      local Integer s = int(sec) % 60;
      local Integer ms = int(sec*1000) % 1000;
      _s = h.printf("%02d")+":"+m.printf("%02d")+":"+s.printf("%02d")+"."+ms.printf("%03d");
   }

   // <method.png>
   public static LaunchSystemTextEditor(String _pathName) {
      Process proc;
      String cmd;
      local String s = STConfig.textedit_cmd;
      s.replace("$(FILE)", "\""+ToNativePathName(_pathName)+"\"");
      StringArray args <= s.splitSpace(true);
      cmd = args.get(0);
      cmd.trim();
      if(Utils.IsWindows())
         cmd.append("&"); // run in background
      args.delete(0);
      if(!cmd.isBlank())
      {
         Global.Debug("proc.exec(\""+cmd+"\", \""+args+"\")");
         if(!proc.exec(cmd, args))
            Global.Error("proc.exec() failed");
      }
      else
      {
         Global.Warning("unknown STConfig.textedit_cmd");
      }
   }

   // <method.png>
   public static SetFloatParamSampleRatePresetOptions(FloatParam _fp) {
      _fp.setPresetOptions([6000.0,
                            8000.0,
                            8195.0,
                            8287.0,
                            9834.0,
                            11025.0,
                            11084.0,
                            12292.0,
                            16000.0,
                            16390.0,
                            16574.0,
                            19668.0,
                            22050.0,
                            23489.0,
                            24000.0,
                            24585.0,
                            26040.0,
                            27928.0,
                            28836.0,
                            32000.0,
                            32780.0,
                            40000.0,
                            44100.0,
                            48000.0,
                            49170.0,
                            88200.0,
                            96000.0,
                            176400.0,
                            192000.0,
                            352800.0,
                            384000.0
                            ],
                           ["6000\tLoFi-6",
                            "8000\tSpeech",
                            "8195\tAtari Falcon",
                            "8287\tAmiga (C-2)",
                            "9834\tAtari Falcon",
                            "11025\tLo-Fi",
                            "11084\tAmiga (F-2)",
                            "12292\tAtari Falcon",
                            "16000\tVoIP",
                            "16390\tAtari Falcon",
                            "16574\tAmiga (C-3)",
                            "19668\tAtari Falcon",
                            "22050\tSoundblaster (~F-3)",
                            "23489\tAmiga (F#3)",
                            "24000\tAmiga (~F#3)",
                            "24585\tAtari Falcon",
                            "26040\tSP-1200",
                            "27928\tAmiga (A-3)",
                            "28836\tAmiga (max)",
                            "32000\tS900",
                            "32780\tAtari Falcon",
                            "40000\tMPC 60",
                            "44100\tCD",
                            "48000\tStandard",
                            "49170\tAtari Falcon",
                            "88200\tCD x2",
                            "96000\tDVD / BluRay",
                            "176400\tHDCD / CD x4",
                            "192000\tDVD x2",
                            "352800\tDXD / CD x8",
                            "384000\tultrasonic"
                            ]);
   }

   // <method.png>
   public static DecodeMP3(String _pathName) : String {

      boolean bOldSuppressUnderrunError = Audio.PushSuppressUnderrunError();

      local String pathNameBat <= Utils.ToNativePathName(STConfig.temp+"/eureka_mpg123.bat");
      local String pathNameWav <= Utils.ToNativePathName(STConfig.temp+"/eureka_mpg123.wav");
      local String mpg123Path <= Utils.ToNativePathName(STConfig.audiotool_mpg123_pathname);
      local String cmdLine = "\""+mpg123Path+"\" -q -w \""+pathNameWav+"\" \""+_pathName+"\"";
      if(Utils.IsWindows())
      {
         cmdLine.saveLocal(pathNameBat);
         cmdLine <= Utils.FixPathname_psystem_exe(pathNameBat);
      }
      Global.Debug("DecodeMP3: exec >>"+cmdLine+"<<");
      system(cmdLine);

      Audio.PopSuppressUnderrunError(bOldSuppressUnderrunError);

      return deref pathNameWav;
   }

   // <method.png>
   public static ConvertWithSoX(String _pathName) : String {

      boolean bOldSuppressUnderrunError = Audio.PushSuppressUnderrunError();

      local String pathNameBat <= Utils.ToNativePathName(STConfig.temp+"/eureka_soxconvert.bat");
      local String pathNameWav <= Utils.ToNativePathName(STConfig.temp+"/eureka_soxconvert.wav");
      local String soxPath <= Utils.ToNativePathName(STConfig.audiotool_sox_pathname);
      local String cmdLine = "\""+soxPath+"\" \""+_pathName+"\" \""+pathNameWav+"\"";
      if(Utils.IsWindows())
      {
         cmdLine.saveLocal(pathNameBat);
         cmdLine <= Utils.FixPathname_psystem_exe(pathNameBat);
      }
      Global.Debug("ConvertWithSoX: exec >>"+cmdLine+"<<");
      system(cmdLine);

      Audio.PopSuppressUnderrunError(bOldSuppressUnderrunError);

      return deref pathNameWav;
   }

   // <method.png>
   public static IsSoXSupportedFileFormat(String _pathName) : boolean {
      int idx = _pathName.lastIndexOf(".");
      // // trace "xxx IsSoXSupportedFileFormat: idx="+idx;
      if(idx >= 0)
      {
         // (note) .wav files are handled by built-in loader
         int fmtIdx = ["8svx", "aiff", "aif", "aiffc", "aifc", "au", "snd", "caf", "cdda", "cdr", "flac"/*, "mp2"*/, "ogg", "opus", "sds", "txw", "voc"/*, "wv"*/, "w64"].indexOfObject(_pathName.substring(idx+1, 99).toLower(), 0);
         Global.Debug("IsSoXSupportedFileFormat: fmtIdx="+fmtIdx);
         return (fmtIdx >= 0);
      }
      return false;
   }

   // <method.png>
   static MatchFilterStringAny(StringArray _filterWords, String _s) : boolean {
      // match *any* filter word
      if(null != _filterWords)
      {
         if(_filterWords.numElements > 0)
         {
            local String slc;
            _s.toLower() => slc;
            String *flt;
            foreach flt in _filterWords
            {
               if(slc & flt.toLower())
                  return true;
            }
            return false;
         }
      }
      return true;
   }

   // <method.png>
   static AddUniqueStringToArray(StringArray _a, String _s) {
      if(!_a.containsObject(_s))
         _a.add(_s);
   }

   // <method.png>
   static MergeStringArrays(StringArray _dst, StringArray _o) : int {
      int numAdded = 0;
      String *s;
      foreach s in _o
      {
         if(!_dst.containsObject(s))
         {
            _dst.add(s);
            numAdded++;
         }
      }
      return numAdded;
   }

   // <method.png>
   static FindNumAddableStrings(StringArray _dst, StringArray _o) : int {
      int num = 0;
      String *s;
      foreach s in _o
      {
         if(!_dst.containsObject(s))
            num++;
      }
      return num;
   }

   // <method.png>
   static CompareStringArrayUnordered(StringArray _a, StringArray _b) : boolean {
      if(_a.numElements == _b.numElements)
      {
         int idx = 0;
         loop(_a.numElements)
         {
            String s <= _a.get(idx++);
            if(!_b.containsObject(s))
               return false;
         }
         return true;
      }
      return false;
   }

   // <method.png>
   static StringArrayContainsAll(StringArray _a, StringArray _b) : boolean {
      if(_b.numElements <= _a.numElements)
      {
         int idx = 0;
         loop(_b.numElements)
         {
            String s <= _b.get(idx++);
            if(!_a.containsObject(s))
               return false;
         }
         return true;
      }
      return false;
   }

   // <method.png>
   static StringArrayContainsAllSubStrings(StringArray _a, StringArray _b) : boolean {
      if(_b.numElements <= _a.numElements)
      {
         int idx = 0;
         loop(_b.numElements)
         {
            String s <= _b.get(idx++);
            String *sTag;
            boolean bFound = false;
            foreach sTag in _a
            {
               if(sTag & s)
               {
                  bFound = true;
                  break;
               }
            }
            if(!bFound)
               return false;
         }
         return true;
      }
      return false;
   }

   // <method.png>
   static StringArrayContainsAllSubStringsWithExclusions(StringArray _a, StringArray _b) : boolean {
      if(_b.numElements <= _a.numElements)
      {
         int idx = 0;
         loop(_b.numElements)
         {
            String *sTag;
            String s <= _b.get(idx++);
            if(s <= "!")
            {
               s <= s.substring(1,-1);
               foreach sTag in _a
               {
                  if(sTag & s)
                     return false;
               }
            }
            else
            {
               boolean bFound = false;
               foreach sTag in _a
               {
                  if(sTag & s)
                  {
                     bFound = true;
                     break;
                  }
               }
               if(!bFound)
                  return false;
            }
         }
         return true;
      }
      return false;
   }

   // <method.png>
   static StringArrayContainsAny(StringArray _a, StringArray _b) : boolean {
      String *s;
      foreach s in _b
      {
         if(_a.containsObject(s))
            return true;
      }
      return false;
   }

   // <method.png>
   static RemoveFromStringArray(StringArray _a, StringArray _b) {
      String *s;
      foreach s in _b
      {
         for(;;)
         {
            int idx = _a.indexOfObject(s, 0);
            if(-1 != idx)
               _a.delete(idx);
            else
               break;
         }
      }
   }

   // <method.png>
   static StringArrayKeepIfExistsInOther(StringArray _a, StringArray _o) {
      String *s;
      for(;;)
      {
         boolean bRemoved = false;
         foreach s in _a
         {
            if(!_o.containsObject(s))
            {
               _a.remove(s);
               bRemoved = true;
               break;
            }
         }
         if(!bRemoved)
            break;
      }
   }

   // <method.png>
   static AddToStringArrayIndexed(StringArray _a, StringArray _b, IntArray _bIndices) {
      int idx;
      foreach idx in _bIndices
      {
         String sTag <= _b.get(idx);
         if(!_a.containsObject(sTag))
            _a.add(sTag);
      }
   }

   // <method.png>
   static StringArrayRegion(StringArray _a, int _off, int _num) : StringArray {
      local StringArray ret;
      int idx = 0;
      int offLast = _off + _num;
      String *s;
      foreach s in _a
      {
         if(_off <= idx++ < offLast)
            ret.add(s);
      }
      return deref ret;
   }

   // <method.png>
   static SortStringArray(StringArray _a, boolean _bCS) {
      local IntArray ia;
      _a.sortByValue(ia, _bCS);
      _a.rearrange(ia);
   }

   // <method.png>
   static SortStringArrayAndMergeToString(StringArray _a, String _sSeparator) {
      local IntArray ia;
      local StringArray a = _a;
      a.sortByValue(ia, false/*bCS*/);
      a.rearrange(ia);
      return a.mergeToString(_sSeparator);
   }

   // <method.png>
   static GetNumLines(local String _s) : int {
      local int num = 1 + _s.numIndicesOf("\n");
      return num;
   }

   // <method.png>
   static GetTKSPathName() : String {
      local String r <= Utils.ToNativePathName(TKS.tksExePath);
      r.replace(".bin", "");  // exec the wrapper script, not the executable (plugin/library paths)
      return deref r;
   }

   // <method.png>
   static SavePosition(Layer _l, Point2f _pos) {
      Point2f posNew;
      posNew.x = _l.getPositionX();
      posNew.y = _l.getPositionY();
      if(posNew.x != _pos.x || posNew.y != _pos.y)
      {
         PrefsDialog.MarkAsEdited();
         _pos = posNew;
      }
   }

   // <method.png>
   static SaveGeometry(Layer _l, Geometry4f _geo) {
      Geometry4f geoNew = _l.getGeometry4f();
      if(geoNew.differsFrom(_geo))
      {
         PrefsDialog.MarkAsEdited();
         _geo = geoNew;
      }
   }

   // <method.png>
   static MillisecondsToCompactHMSString(int _ms) : String {
      Integer tHour = _ms / (1000*60*60);
      Integer tMin  = (_ms / (1000*60)) % 60;
      Integer tSec  = (_ms / 1000) % 60;
      if(tHour > 0)
         return tHour.printf("%02d")+"h:"+tMin.printf("%02d")+"m:"+tSec.printf("%02d")+"s";
      else if(tMin > 0)
         return tMin.printf("%02d")+"m:"+tSec.printf("%02d")+"s";
      return tSec.printf("%02d")+"s";
   }

}
