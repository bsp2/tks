// ----
// ---- file   : CycleSyntaxHighlighter.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2024-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi/audio sequencer.
// ----
// ---- created: 14Dec2024
// ---- changed: 15Dec2024, 18Dec2024, 22Dec2024, 11Jan2025, 13Jan2025, 15Jan2025, 31Jan2025
// ----          12Jun2025
// ----
// ----
// ----

module MCycleSyntaxHighlighter;

use namespace ui;
use namespace st2;


// <class.png>
class CycleSyntaxHighlighter : TextViewSyntaxHighlighter {

   define int C32_OTHER     = #ff747474;   // "'
   define int C32_TEXT      = #ffc2c2c2;
   define int C32_COMMENT   = #ff6d6d59;   // #removed           #777761 #929278 #bbbb99
   define int C32_COMMENT2  = #ffbbbb99;   // # spaced comment   #929278 #a3a386 #bbbb99
   define int C32_KEYWORD_1 = #ffffddbb;   // oversample,wt_w,..
   define int C32_KEYWORD_2 = #ffbbffff;   // arg,def,lut,..
   define int C32_KEYWORD_3 = #ffffffff;   // sin,clp,..
   define int C32_KEYWORD_4 = #fff0ffff;   // +,-,*,..
   define int C32_ASSIGN    = #ffb1dfff;
   define int C32_KEYWORD_5 = C32_ASSIGN;  // <,>,! (after module name / keyword_3)
   define int C32_VAR       = #fff4f4bb;
   define int C32_VAR2      = #fff4f4bb;   // "special" vars (note, spd, vel)
   define int C32_TEMPLATE  = #ffbbffbb;
   define int C32_LANE      = #ffffbe66;   // <lane:
   define int C32_LUT       = #ffffa366;   // <lut_lane:
   define int C32_ID        = #ffffffff;   // plugin name (after 'id')
   define int C32_KEY       = #ffbbddbb;   // key=<value>
   define int C32_INPUT     = #ff94e7e2;   // input:  //66fff5
   define int C32_INC       = #ff90cc8b;   // inc|xinc <name>
   define int C32_FIELD     = #ffc29ca3;   // myarrayparam.myfield   #c2c2a3
   define int C32_TEMPLVAR  = #ffd2bc63;   // %var%  #ffcf734a #ffdcc413

   static StringArray a_keywords_1 = [
      "id",
      "name",
      "author",
      "cat",
      "oversample",
      "oversample_factor",
      "oversample_quality",
      "dither",
      "rate",
      "freq",
      "oct",
      "dur",
      "wt_w",
      "wt_h",
      "wt_cyclelen",
      "wt_freqs",
      "skip",
      "xfade",
      "mirror",

      // cycle_ui:
      "options",
      "dir",
      "tooltip",
                                      ];

   static StringArray a_keywords_2 = [
      "arg", "a",
      "arg_values", "av",
      "array", "ap",
      "curve", "c",
      "lcurve", "lc",
      "def",
      "inc", "xinc",
      "param", "p",
      "param_values", "pv",
      "lparam", "lp",
      "lparam_values", "lpv",
      "macro",
      "mod", "m",
      "modparam", "mp",
      "var", "v",
      // // "lut",
      "zone", "z",

      // cycle_ui:
      "in",
      "out",
      "pos",
                                      ];

   static StringArray a_keywords_3 = [
      "abs", "adsr",
      "bit", "boo", "box", "bpf", "bts", "buf",
      // // "bus",
      "clk", "clp", "cmp", "clt", "cne", "ceq", "cge", "cgt", "con",
      "dec", "div", "dly", "drv",
      "env", "eq3",
      "fed", "fix", "fld", "flt", "fam", "fma", "frc", "fsr", "fwr",
      "hbx", "hld", "hpf", "hwr",
      "if", "inc", "inp", "int", "ipl", "itg",
      "kbd",
      "lle", "log", "lop", "lpf", "lut",
      "mac", "map", "mkv", "mul",
      "neg", "nos", "not", "note", "nth",
      // // "out",
      "pal", "par", "pha", "p2s", "pow", "pre", "pul",
      "qua",
      "rbl", "rbr",
      "red", "rcp", "rdl", "rdr", "rep", "rev", "rmp",
      "saw", "set", "sin", "slf", "smp", "spd", "slw", "spr", "ssl", "sta", "sto", "svf", "sat",
      "tanh", "tmp", "~", "trc", "tri", "tsq",
      "vel", "vpl", "vsq", "vst",
      "wbl", "wbr",
      "wrl", "wrp", "wrr",
      "xfd",
      "zlp", "zon", "zsq",
      "init", "prepare", "calc", "global",
                                      ];

   static StringArray a_keywords_4 = [
      "+", "sr", "-", "r-", "*",
      "&", "|", "^",
      "&&", "||", "^^", "!&", "!|", "!^",
      "m", "x", "M", "X",
      ".",
      "am", "qm", "QM", "hm", "HM", "gm", "GM",
                                      ];

   static StringArray a_keywords_5 = [
      "<", ">", "!",
                                      ];

   static StringArray a_keywords_var2 = [
      "note", "spd", "vel",
                                         ];


   // <method.png>
   // static int dbg_count;
   public virtual colorizeText(TextView _text) {
      int numRows = _text.getNumRows();
      // trace "xxx ["+(dbg_count++)+"] CycleSyntaxHighlighter::colorizeText: numRows="+numRows;

      local IntArray aRanges;
      local StringArray aTok;

      String *sLine;
      IntArray *aColors;
      int rowIdx = 0;
      loop(numRows)
      {
         sLine <= _text.getVisibleRowStringByIndex(rowIdx);
         if(null != sLine)
         {
            sLine.tokenizeWithRanges(" \t=~<>()[]{}*+&|^,;:", aRanges) => aTok;
            aColors <= _text.getVisibleRowColorsByIndex(rowIdx);
            aColors.fill(C32_OTHER);
            // trace "aTok="+#(aTok);
            // trace "aRanges="+#(aRanges);

            int c32Comment = 0;
            boolean bTemplate = false;
            String sTokP <= "";
            String sTokPP <= "";
            boolean bAllowKW12 = true;  // directive
            boolean bAllowKW3 = true;   // mod
            boolean bAllowKW4 = true;   // op
            boolean bAllowKW5 = false;  // rel

            String *sTok;
            int tokOff = 0;
            foreach sTok in aTok
            {
               int startOff = aRanges.get(tokOff + 0);
               int numChars = aRanges.get(tokOff + 1);
               // trace "token["+(tokOff/2)+"] sTok=\""+sTok+"\"  substr=\""+sLine.substring(startOff, numChars)+"\"";
               int c32 = C32_TEXT;
               if(sTok <= "#")
               {
                  // # spaced comment ?
                  c32Comment = (sTok.numChars > 1) ? C32_COMMENT : C32_COMMENT2;
               }
               if(c32Comment)
                  c32 = c32Comment;
               else if(sTok == "def" || sTok == "~")
               {
                  bTemplate = true;
                  c32 = C32_KEYWORD_2;
                  bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW4 = false;
               }
               else if(bTemplate)
               {
                  bTemplate = false;
                  c32 = C32_TEMPLATE;
               }
               else if(sTok <= "$")
                  c32 = C32_VAR;
               else if(sTok <= "%" && sTok >= "%")
                  c32 = C32_TEMPLVAR;
               else if(sTok == "=" && tokOff >= 2)
               {
                  int startOffKey = aRanges.get(tokOff - 2);
                  int numCharsKey = aRanges.get(tokOff - 1);
                  aColors.fillRegion(startOffKey, numCharsKey, C32_KEY);
                  c32 = C32_KEYWORD_4;
               }
               else if(bAllowKW12 && a_keywords_1.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_1;
                  bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW4 = false;
               }
               else if(bAllowKW12 && a_keywords_2.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_2;
                  bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW4 = false;
               }
               else if(bAllowKW3 && "=" != sTokP && a_keywords_3.containsObject(sTok))
               {
                  if(0 == startOff && "lut" == sTok)  // (note) both a module name and global directive
                     c32 = C32_KEYWORD_2;
                  else
                     c32 = C32_KEYWORD_3;
                  // // bAllowKW12 = false;
                  bAllowKW3 = false;
                  bAllowKW5 = true;
                  bAllowKW4 = false;
               }
               else if(bAllowKW4 && a_keywords_4.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_4;
                  bAllowKW12 = false;
               }
               else if(bAllowKW5 && a_keywords_5.containsObject(sTok))
               {
                  c32 = C32_KEYWORD_5;
               }
               else if("=" == sTok)
                  c32 = C32_ASSIGN;
               else if(":" == sTok && "<" == sTokPP)
               {
                  int startOffLane = aRanges.get(tokOff - 2);
                  int numCharsLane = aRanges.get(tokOff - 1);
                  aColors.fillRegion(startOffLane, numCharsLane,
                                     (sTokP <= "lut_") ? C32_LUT : C32_LANE
                                     );
               }
               else if(":" == sTok)
               {
                  int startOffInput = aRanges.get(tokOff - 2);
                  int numCharsInput = aRanges.get(tokOff - 1);
                  aColors.fillRegion(startOffInput, numCharsInput, C32_INPUT);
               }
               else if("id" == sTokP)
                  c32 = C32_ID;
               else if("inc" == sTokP || "xinc" == sTokP)
                  c32 = C32_INC;
               else if(a_keywords_var2.containsObject(sTok))
                  c32 = C32_VAR2;
               else if(sTok & "." && sTok.checkConversions() >= YAC_TYPE_STRING)
                  c32 = C32_FIELD;

               aColors.fillRegion(startOff, numChars, c32);

               // Next token
               tokOff += 2;
               sTokPP <= sTokP;
               sTokP <= sTok;
            }

            // trace "xxx line["+rowIdx+"] sLine=\""+sLine+"\"";
            // trace "xxx line["+rowIdx+"] aColors="+aColors;

            // Next visible row
            rowIdx++;
         }
         else
            break;  // beyond end of text
      }
   }

}
