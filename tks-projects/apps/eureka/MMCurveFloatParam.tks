// ----
// ---- file   : MMCurveFloatParam.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2022-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 30Dec2022
// ---- changed: 08Sep2023, 18Sep2023, 28Oct2023, 13Sep2025
// ----
// ----
// ----

module MMMCurveFloatParam;

use namespace ui;


// <class.png>
class MMCurveFloatParam extends FloatParam {
   static Texture tex;

   protected virtual calcSizeX() : float {
      return 16.0f;
   }

   protected virtual calcSizeY() : float {
      return 16.0f;
   }

   // <method_init.png>
   public method initMMCurveFloatParam() {
      initFloatParam();

      b_flip_mouse_x = true;
   }

   // <method.png>
   protected virtual layoutContent() {
      // overwrites FloatParam/TextField layoutContent() => no text, no baseline
      cached_baseline_y = 0;
   }

   // <ui_render.png>
   public virtual onDraw() {

      lazyInitFont();

      if(0 == tex.sx)
      {
         tex.flags = TEX_MODULATE | TEX_MINFILTERLINEAR | TEX_ALPHA;
         tex.loadImage("mm_curves.png", 0,0,0);
         tex.upload();
         // tex.saveImage("debugx.png");
      }

      UIRenderer.DrawDefaultBackground(0, 0, 16, 16);
      // trace "xxx MMCurveFloatParam: tex.sz=("+tex.sx+";"+tex.sy+") tex.z="+tex.z+" tex.id="+tex.id;
      tex.bind();
      tex.enable();
      UIRenderer.SetColorARGB(#ffffffff);
      // // glEnable(GL_BLEND);
      // // glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA,  // pre ShaderVG / GLcore (alpha in GL_RED channel instead of GL_INTENSITY)
      // //                     GL_ONE, GL_ONE_MINUS_SRC_ALPHA
      // //                     );
      UIRenderer.EnableBlendingKeepAlpha();

      float f = getValue();
      f += 1.0f;
      f *= 512.0f;
      int i = mathClampf(f, 0, 1023);
      int x = (i & 31) * 32;
      int y = (i / 32) * 32;
      float u = (x + 1) / 1024.0f;
      float v = (y + 1) / 1024.0f;
      float uw = (32-2) / 1024.0f;
      float vw = (32-2) / 1024.0f;
      // trace "xxx cur_value="+cur_value+" i="+i+" => x="+x+" y="+y+" u="+u+" v="+v+" uw="+uw+" vw="+vw;

      float ul = b_flip_x ? (u+uw) : u;
      float ur = b_flip_x ? (u   ) : (u+uw);

      if(UIRenderer.BeginTexturedTriangleFanAlpha(4))
      {
         UIRenderer.TexCoord2f(ul, v);
         UIRenderer.Vertex2f(1, 1);

         UIRenderer.TexCoord2f(ur, v);
         UIRenderer.Vertex2f(15, 1);

         UIRenderer.TexCoord2f(ur, v+vw);
         UIRenderer.Vertex2f(15, 15);

         UIRenderer.TexCoord2f(ul, v+vw);
         UIRenderer.Vertex2f(1, 15);

         UIRenderer.End();
      }

      UIRenderer.DisableBlending();
      tex.disable();

      if(b_outline)
      {
         UIRenderer.DrawDefaultFlatBorderTint(0, 0, getSizeX(), getSizeY(), #60000000);
      }
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {

      initMMCurveFloatParam();

      if(FloatParam::beginXFMTag(_form, _attributes))
      {
      }
   }

}
