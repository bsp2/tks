// ----
// ---- file   : utils.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2009-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 26Dec2009, 02Jan2010, 29Jan2010, 10Oct2010, 19Jan2011, 07Mar2011, 15Jan2012
// ----          13May2012, 01Jun2013, 03Jun2013, 09Aug2014, 29Sep2014, 23Jan2015, 24Jan2015
// ----          02Feb2015, 19Apr2015, 28Feb2016, 28Mar2016, 04Apr2016, 08Mar2017, 11Mar2017
// ----          14Apr2017, 09Jun2017, 04Jan2018, 31May2018, 04Jun2018, 02Jan2019, 05Jan2019
// ----          18Jan2019, 18May2019, 24Jun2019, 06Oct2019, 21Oct2019, 05Nov2019, 06Mar2020
// ----          08Apr2020, 20Apr2020, 25Apr2020, 06May2020, 18May2020, 21Jun2020, 16Apr2022
// ----          10Aug2022, 23Oct2022, 27Oct2022, 27Jan2023, 09Feb2023, 19Feb2023, 04Mar2023
// ----          18Mar2023, 01Apr2023, 10Sep2023, 22Sep2023, 30Oct2023, 11Nov2023, 25Nov2023
// ----          19Apr2024, 20Apr2024, 06Jul2024, 10Oct2024, 28Feb2025
// ----
// ----
// ----

module MUtils;

use namespace st2;


// <class.png>
class Utils {

   // <method.png>
   static SplitPathname(String name, path, file) {
      // Split last used file name into directory/file components

      int idx = name.lastIndexOf("/");
      int idxDos = name.lastIndexOf("\\");
      if(idxDos > idx)
      {
         idx = idxDos;
      }

      if(-1 != idx)
      {
         name.substring(0, idx) => path;
         name.substring(idx+1, -1) => file;
      }
      else
      {
         path = null;
         file = name;
      }

      // // trace "xxx SplitPathname: name=\""+name+"\" path=\""+path+"\" file=\""+file+"\".";
   }

   // <method.png>
   static ConvertToFileName(String _name) : String {
      local String r = _name;
      r.replaceChar(':',  '_');
      r.replaceChar('/',  '_');
      r.replaceChar('\\', '_');
      r.replaceChar('$',  '_');
      r.replaceChar('&',  '_');
      r.replaceChar('ยง',  '_');
      r.replaceChar('%',  '_');
      r.replaceChar('\'', '_');
      r.replaceChar('`',  '_');
      r.replaceChar('<',  '_');
      r.replaceChar('>',  '_');
      r.replaceChar('*',  '_');
      r.replaceChar('|',  '_');
      r.replaceChar('!',  '_');
      r.replaceChar('?',  '_');
      r.replaceChar('^',  '_');
      r.replaceChar('=',  '_');
      r.replaceChar('~',  '_');
      r.replaceChar('#',  '_');
      r.replaceChar(';',  '_');
      return deref r;
   }

   // <method.png>
   static FixFileName(String _name) : String {
      local String r = _name;
      r.replaceChar('\\', '/');
      r.replace("//", "/");
      return deref r;
   }

   // <method.png>
   static LazyAppendSuffix(String _name, String _suffix) : String {
      local String r = _name;
      // // trace "xxx LazyAppendSuffix: r=\""+r+"\" suffix=\""+_suffix+"\"";
      if(!r.endsWith(_suffix))
         r.append(_suffix);
      // // trace "xxx 2 LazyAppendSuffix: r=\""+r+"\"";
      return deref r;
   }

   // <method.png>
   static LazyRemoveSuffix(String _name, String _suffix) : String {
      local String r = _name;
      int idx = r.lastIndexOf(_suffix);
      // // trace "xxx LazyRemoveSuffix: name=\""+_name+"\" suffix=\""+_suffix+"\" idx="+idx;
      if(-1 != idx)
      {
         r.replaceRegion(idx, r.length, "");
      }
      // // trace "xxx LazyRemoveSuffix:   => r=\""+r+"\"";
      return deref r;
   }

   // <method.png>
   static Backtrace() {
      try { throw UncriticalError("debug/backtrace"); } catch(UncriticalError e) { trace e.stackTrace; }
   }

   // <method_get.png>
   static GetCurrentDateString() : String {
      Time t; t.now();
      return
         t.monthday+
         ((["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"])[t.month])+t.year;
   }

   // <method_get.png>
   static GetCurrentTimeString() : String {
      Time t;
      Integer io_h;
      Integer io_m;
      Integer io_s;
      t.now();
      io_h.value=t.hour;
      io_m.value=t.min;
      io_s.value=t.sec;
      return io_h.printf("%02i")+"_"+io_m.printf("%02i")+"_"+io_s.printf("%02i");
   }

   // <method_get.png>
   static GetCurrentDateTimeStringNumeric() : String {
      Time t;
      Integer io_mon;
      Integer io_mday;
      Integer io_h;
      Integer io_m;
      Integer io_s;
      t.now();
      io_mon = t.month + 1;
      io_mday = t.monthday;
      io_h.value=t.hour;
      io_m.value=t.min;
      io_s.value=t.sec;
      return t.year + io_mon.printf("%02d")+io_mday.printf("%02d")+"-"+io_h.printf("%02i")+io_m.printf("%02i")+io_s.printf("%02i");
   }

   // <method.png>
   static BPMPPQToMS(float _bpm, float _ppq) : float {
      return 1000.0f / (_bpm * _ppq / 60.0f);
   }

   // <method.png>
   static UsecQuarterToBPM(float _usec) : float {
      // return 1000.0f / (_bpm * _ppq / 60.0f);
      // millisec = 1000.0f / (_bpm * _ppq / 60.0f)
      // millisec * _bpm * _ppq / 60.0f = 1000.0f
      // _bpm * millisec * _ppq / 60.0f = 1000.0f
      // _bpm  = 1000.0f / (millisec * _ppq / 60.0f)
      // _bpm  = 1000.0f / (usec * 1000 * _ppq / 60.0f)
      // _bpm  = 1.0f / (usec * _ppq / 60.0f)
      // return 1.0f / (_usec / 60.0f);
      return 1000000.0f / (_usec / 60.0f);
   }

   // <method.png>
   static HexDump(Buffer buf, int start, int num) {
      int HEXDUMP_COLS = 16;
      int j, i=start;
      int c;
      int x=0;
      int y=start;
      Integer io;
      io.value=i-start;
      stdout io.printf("%04x: ");
      loop(num)
      {
         io.value=buf[i++];
         stdout io.printf("%02x ");
         if( (++x % HEXDUMP_COLS) == 0)
         {
            j = y;
            loop(HEXDUMP_COLS)
            {
               c = buf[j++];
               if(c<32)
                  c='.';
               else if(c>126)
                  c='.';
               stdout tcchar(c);
            }
            stdout "\n";
            if(i<(start+num))
            {
               io.value = i-start;
               stdout io.printf("%04x: ");
            }
            x = 0;
            y += HEXDUMP_COLS;
         }
      }
      if(x)
      {
         loop(3*(HEXDUMP_COLS-x))
         {
            stdout " ";
         }
         j = y;
         loop(x)
         {
            c = buf[j++];
            if(c<32)
               c='.';
            else if(c>126)
               c='.';
            stdout tcchar(c);
         }
         stdout "\n";
      }
   }

   // <method.png>
   static BufferDiff(Buffer a, Buffer b, boolean _bVerbose) : boolean {
      boolean ret = true;

      if(_bVerbose)
         Global.Debug("Utils::BufferDiff: a.size="+a.size+" b.size="+b.size);

      if(a.size > 0)
      {
         if(a.size == b.size)
         {
            Integer off = 0;

            ret = false;

            loop(a.size)
            {
               UnsignedByte ba = a.peekI8(off);
               UnsignedByte bb = b.peekI8(off);

               if(ba != bb)
               {
                  if(_bVerbose)
                     Global.Debug("Utils::BufferDiff: diff at off="+off+" ("+off.printf("0x%x")+") a="+ba.printf("0x%02x")+" b="+bb.printf("0x%02x"));
                  ret = true;
               }

               off++;
            }
         }
      }

      return ret;
   }

   // <method.png>
   static BufferDiffARKit(Buffer a, Buffer b, boolean _bVerbose) : boolean {
      boolean ret = true;

      // if(_bVerbose)
      //    Global.Debug("Utils::BufferDiff: a.size="+a.size+" b.size="+b.size);

      if(a.size > 0)
      {
         if(a.size == b.size)
         {
            Integer off = 0;

            ret = false;

            loop(a.size)
            {
               UnsignedByte ba = a.peekI8(off);
               UnsignedByte bb = b.peekI8(off);

               // // if((46+0x1C) <= off < (2062+0x1C))
               {
                  if(ba != bb)
                  {
                     // v4/FW1.50+1.61b:
                     // int trackIdx = (off - 46) / 168;
                     // Integer soundOff = off - (46 + trackIdx*168);

                     // v5/FW1.70:
                     int trackIdx = (off - 46) / 162/*AR_SOUND_SZ*/;
                     Integer soundOff = off - (46 + trackIdx*162/*AR_SOUND_SZ*/);

                     Integer paramIdx = (soundOff - 0x1C)/2;
                     Global.Debug("Utils::BufferDiff<ARKit>: diff at trackNr="+(trackIdx+1)+" soundOff="+soundOff+" ("+soundOff.printf("0x%x")+") paramNr="+(paramIdx+1)+" a="+ba.printf("0x%02x")+" b="+bb.printf("0x%02x")+" kitOff="+off+" (0x"+off.printf("%04x")+")");
                     ret = true;
                  }
               }

               off++;
            }
         }
      }

      return ret;
   }

   // <method.png>
   static BufferDiffARPattern(Buffer a, Buffer b, boolean _bVerbose) : boolean {
      boolean ret = true;

      if(_bVerbose)
         Global.Debug("Utils::BufferDiff: a.size="+a.size+"(off="+a.offset+") b.size="+b.size+"(off="+b.offset+") a.checksum="+a.checksum+" b.checksum="+b.checksum);

      if(a.size > 0)
      {
         if(a.size == b.size)
         {
            Integer off = 0;

            ret = false;

            loop(a.size)
            {
               UnsignedByte ba = a.peekI8(off);
               UnsignedByte bb = b.peekI8(off);

               // // if((46+0x1C) <= off < (2062+0x1C))
               {
                  if(ba != bb)
                  {
                     // v5/FW1.70:
                     int trackIdx = (off - 4) / 641;
                     Integer trackOff = off - (4 + trackIdx*641);

                     Global.Debug("Utils::BufferDiff<ARPattern>: diff at trackNr="+(trackIdx+1)+" trackOff="+trackOff+" ("+trackOff.printf("0x%x")+") a="+ba.printf("0x%02x")+" b="+bb.printf("0x%02x")+" patOff="+off+" (0x"+off.printf("%04x")+")");
                     ret = true;
                  }
               }

               off++;
            }
         }
      }

      return ret;
   }

   // <method.png>
   static SaveBufferToFile(String _filename, Buffer _b, int _offset, int _num) {
      File f;
      if(f.openLocal(_filename, IOS_OUT))
      {
         int off = _offset;
         loop(_num)
         {
            byte c = _b.peekI8(off++);
            f.i8 = c;
         }

         f.close();

         Global.Debug("Utils::SaveBufferToFile: filename=\""+_filename+"\" off="+_offset+" num="+_num);
      }
   }

   // <method.png>
   static MapLetterNr(int _nr) : String {
      explain "Map number (e.g. 61) to name (e.g. z)";
      return MNT_PatternView.instr_letters.get(_nr);
   }

   // <method.png>
   static UnmapLetterNr(String _name) : int {
      explain "Map name (e.g. z) to number (e.g. 61)";
      int c;
      if(_name.length>0)
      {
         c = _name[0];
      }
      else
      {
         return 0;
      }
      c = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".indexOfChar(c, 0);
      if(c == -1)
      {
         return 0;
      }
      else
      {
         return c;
      }
   }

   // <method.png>
   static ExtractCopyPrefix(String _s, String _prefix) {
      int idx = _s.indexOf("(Copy", 0);
      if(-1 == idx)
      {
         idx = _s.length;
      }
      _s.substring(0, idx) => _prefix;
   }

   // <method.png>
   static DetermineCopyNr(String _s) : int {
      int idx = _s.indexOf("(Copy", 0);
      if(-1 != idx)
      {
         int idxNrStart = idx + 5;
         int idxNrEnd = _s.indexOfChar(')', idxNrStart);
         if(-1 == idxNrEnd)
         {
            idxNrEnd = _s.length;
         }
         return _s.substring(idxNrStart, idxNrEnd-idxNrStart).trim();
      }

      return -1;
   }

   // <method.png>
   static BuildCopiedName(String _orig, int _appendixNr) : String {
      // Adds incremental " (Copy x)" string to end of original name and returns new string

      int idx = _orig.indexOf("(Copy", 0);
      local String r;
      if(-1 != idx)
      {
         int idxNrStart = idx + 5;
         _orig.substring(0, idxNrStart) => r;
         int idxNrEnd = _orig.indexOfChar(')', idxNrStart);
         if(-1 != idxNrEnd)
         {
            r.append(" ");
            r.append(_appendixNr);
            r.append(")");
            r.append(_orig.substring(idxNrEnd+1, _orig.length-(idxNrEnd+1)));
         }
         else
         {
            r.append(" 1)");
         }
      }
      else
      {
         r = _orig;
         r.append(" (Copy ");
         r.append(_appendixNr);
         r.append(")");
      }
      return deref r;
   }

   // <method.png>
   public static KeycodeToMidiNote(int _code):int {
      switch(_code) {
         case 122: return  0; //c-0: 122
         case 115: return  1; //c#0: 115
         case 120: return  2; //d-0: 120
         case 100: return  3; //d#0: 100
         case  99: return  4; //e-0: 99
         case 118: return  5; //f-0: 118
         case 103: return  6; //f#0: 103
         case  98: return  7; //g-0: 98
         case 104: return  8; //g#0: 104
         case 110: return  9; //a-0: 110
         case 106: return 10; //a#0: 106
         case 109: return 11; //b-0: 109
         case  44: return 12; //c-1: 44
         case 108: return 13; //c#1: 108
         case  46: return 14; //d-1: 46
         case  59: return 15; //d#1: 59
         case  47: return 16; //e-1: 47
         case 113: return 12; //c-1: 113
         case  50: return 13; //c#1: 50
         case 119: return 14; //d-1: 119
         case  51: return 15; //d#1: 51
         case 101: return 16; //e-1: 101
         case 114: return 17; //f-1: 114
         case  53: return 18; //f#1: 53
         case 116: return 19; //g-1: 116
         case  54: return 20; //g#1: 54
         case 121: return 21; //a-1: 121
         case  55: return 22; //a#1: 55
         case 117: return 23; //h-1: 117
         case 105: return 24; //c-2: 105
         case  57: return 25; //c#2: 57
         case 111: return 26; //d-2: 111
         case  48: return 27; //d#2: 48
         case 112: return 28; //e-2: 112
         case  91: return 29; //f-2: 91
         case  61: return 30; //f#2: 61
         case  93: return 31; //g-2: 93
      }
      return -1;
   }

   // <method.png>
   static KeycodeToInstrument(int _unicode) {
      switch(_unicode)
      {
         case '0': return 0;
         case '1': return 1;
         case '2': return 2;
         case '3': return 3;
         case '4': return 4;
         case '5': return 5;
         case '6': return 6;
         case '7': return 7;
         case '8': return 8;
         case '9': return 9;
         case 'a': return 10;
         case 'b': return 11;
         case 'c': return 12;
         case 'd': return 13;
         case 'e': return 14;
         case 'f': return 15;
         case 'g': return 16;
         case 'h': return 17;
         case 'i': return 18;
         case 'j': return 19;
         case 'k': return 20;
         case 'l': return 21;
         case 'm': return 22;
         case 'n': return 23;
         case 'o': return 24;
         case 'p': return 25;
         case 'q': return 26;
         case 'r': return 27;
         case 's': return 28;
         case 't': return 29;
         case 'u': return 30;
         case 'v': return 31;
         case 'w': return 32;
         case 'x': return 33;
         case 'y': return 34;
         case 'z': return 35;
         case 'A': return 36;
         case 'B': return 37;
         case 'C': return 38;
         case 'D': return 39;
         case 'E': return 40;
         case 'F': return 41;
         case 'G': return 42;
         case 'H': return 43;
         case 'I': return 44;
         case 'J': return 45;
         case 'K': return 46;
         case 'L': return 47;
         case 'M': return 48;
         case 'N': return 49;
         case 'O': return 50;
         case 'P': return 51;
         case 'Q': return 52;
         case 'R': return 53;
         case 'S': return 54;
         case 'T': return 55;
         case 'U': return 56;
         case 'V': return 57;
         case 'W': return 58;
         case 'X': return 59;
         case 'Y': return 60;
         case 'Z': return 61;
         default: return -1;
      }
   }

   // <method.png>
   static KeycodeToHex(Key _k) : int {
      switch(_k.unicode)
      {
         case '0': return 0;
         case '1': return 1;
         case '2': return 2;
         case '3': return 3;
         case '4': return 4;
         case '5': return 5;
         case '6': return 6;
         case '7': return 7;
         case '8': return 8;
         case '9': return 9;
         case 'a': return 10;
         case 'b': return 11;
         case 'c': return 12;
         case 'd': return 13;
         case 'e': return 14;
         case 'f': return 15;
      }

      if(_k.modShiftOrCaps())
      {
         // German kbd
         if("de" == STConfig.kbd_layout)
         {
            switch(_k.unicode)
            {
               case '=': return 0;
               case '!': return 1;
               case '"': return 2;
               case 'ยง': return 3;
               case '$': return 4;
               case '%': return 5;
               case '&': return 6;
               case '/': return 7;
               case '(': return 8;
               case ')': return 9;
               case 'A': return 10;
               case 'B': return 11;
               case 'C': return 12;
               case 'D': return 13;
               case 'E': return 14;
               case 'F': return 15;
            }
         }
         //else if("us" == STConfig.kbd_layout)
         {
            switch(_k.code)
            {
               case '0': return 0;
               case '1': return 1;
               case '2': return 2;
               case '3': return 3;
               case '4': return 4;
               case '5': return 5;
               case '6': return 6;
               case '7': return 7;
               case '8': return 8;
               case '9': return 9;
               case 'A': return 10;
               case 'B': return 11;
               case 'C': return 12;
               case 'D': return 13;
               case 'E': return 14;
               case 'F': return 15;
            }
         }
      }

      return -1;
   }

   // <method_get.png>
   static GetNumString(int _num, String _s) : String {
      if( (_num > 1) || (0 == _num) )
      {
         return _num+" "+_s + "s";
      }
      else
      {
         return _num+" "+_s;
      }
   }

   // <method_get.png>
   static GetNumString2(int _num, String _s1, String _s2) : String {
      if( (_num > 1) || (0 == _num) )
      {
         return _num+" "+_s2;
      }
      else
      {
         return _num+" "+_s1;
      }
   }

   // <method_get.png>
   static GetNumString3(float _num, String _s1, String _s2) : String {
      // e.g. "0.75 bars", "1.25 bars", "1 bar", "0 bars"
      // (note) truncate float to 2 decimal places
      if( (_num > 1) || (_num < 1) )
      {
         Float num = _num;

         if(0 == _num)
         {
            return "0 "+_s2;
         }
         else if(int(_num) == _num)
         {
            return int(_num)+" "+_s2;
         }
         else
         {
            return num.printf("%3.2f")+" "+_s2;
         }
      }
      else
      {
         return "1 "+_s1;
      }
   }

   // <method_get.png>
   static GetEnableString(local boolean _bEnabled) : String {
      return (maybe == _bEnabled) ? "enabled(maybe)" : (false != _bEnabled) ? "enabled" : "disabled";
   }

   // <method_get.png>
   static GetEnableStringMixed(boolean _bEnabled, String _sFalse, String _sTrue, String _sMixed) : String {
      return (maybe == _bEnabled) ? _sMixed : (false != _bEnabled) ? _sTrue : _sFalse;
   }

   // <method.png>
   public static Bipolar8ToOffset(float _t) : float {
      // t (0..255) => -128 .. +127

      if(_t < 0.0f)
         _t = 0.0f;
      else if(_t > 255.0f)
         _t = 255.0f;

      return (_t - 128.0f);
   }

   // <method.png>
   public static Bipolar8ToFloat(float _t) : float {
      // t (0..255) => -1 .. +1
      float r;

      if(_t < 0.0f)
         r = 0.0f;
      else if(_t < 128.0f)
         r = (_t / 128.0) - 1.0f;
      else if(_t > 255.0f)
         r = 1.0f;
      else
         r = (_t - 128.0f) / 127.0f;

      return r;
   }

   // <method.png>
   public static Bipolar8ToScale(float _t, float _div, float _mul) : float {
      // t (0..255) => /_div .. *_mul

      if(_t < 0.0f)
         _t = 0.0f;
      else if(_t > 255.0f)
         _t = 255.0f;

      float s;

      if(_t < 128.0f)
      {
         // // s = 1.0 + ((128.0 - _t) / (128.0 / (_div - 1.0)));
         s = (1.0f / _div);
         s = s + ( (1.0 - s) * (_t / 128.0) );
      }
      else
      {
         s = 1.0 + ((_t - 128.0) / (127.0 / (_mul - 1.0)));
      }

      return s;
   }

   // <method.png>
   public static Bipolar8ToScaleRev(float _val, float _div, float _mul) : float {
      // t (/div .. *mul) =>  (0..255)

      float s = (1.0f / _div);

      _val = mathClampf(_val, s, _mul);

      if(_val < 1.0)
      {
         s = 128 - 128.0*(2.0 - (_val / s));
      }
      else
      {
         s = 128.0 + 127.0*(((_val-1.0) / (_mul-1.0)));
      }

      return s;
   }

   // <method.png>
   public static Bipolar14ToScaleZero(float _t, float _mul) : float {
      // t (0..16383) => 0 .. *_mul, 0x2000=1.0

      if(_t < 0.0f)
         _t = 0.0f;
      else if(_t > 16383.0f)
         _t = 16383.0f;

      float s;

      if(_t < 8192.0f)
      {
         s = (_t / 8192.0);
      }
      else
      {
         s = 1.0 + ((_t - 8192.0) / (8192.0 / (_mul - 1.0)));
      }

      return s;
   }

   // <method.png>
   public static IntToBinary255String(byte _val) : String {
      _val &= 255;

      String r = "0b";
      int bit = 128;
      loop(8)
      {
         if(_val & bit)
            r.append("1");
         else
            r.append("0");
         bit >>= 1;
      }

      return r;
   }

   // <method.png>
   public static SignedInt14ToFloat(short _val) : float {
      _val -= 8192;
      if(_val < 0)
         return _val / 8192.0;
      else
         return _val / 8191.0;
   }

   // <method.png>
   public static GetPluralString(int _num) : String {
      if((0 == _num) || (abs(_num) > 1))
         return "s";
      return "";
   }

   // <method.png>
   public static GetPluralStringFloat(float _f) : String {
      if((0.0f == _f) || (_f > 1.0f) || ((_f < 1.0f) && (_f != -1.0f)))
         return "s";
      return "";
   }

   // <method.png>
   public static GetPluralStringEx(int _num, String _single, String _multi) : String {
      if((0 == _num) || (abs(_num) > 1))
         return _multi;
      return _single;
   }

   // <method.png>
   public static IsWindows() {
      // // return (null != getenv("COMSPEC"));
      return (".dll" == TKS.dllSuffix);
   }

   // <method.png>
   public static IsLinux() {
      return (".so" == TKS.dllSuffix);
   }

   // <method.png>
   public static IsMacOS() {
      return (".dylib" == TKS.dllSuffix);
   }

   // <method.png>
   public static SubstitutePathVars(local String _path) : String {
      local String r = _path;
      // // r.replace("~", getenv("HOME"));  // done in ToNativePathName()
      loop(2)
      {
         r.replace("$(TMP)",                STConfig.temp);
         r.replace("$(PROGRAM_DIR)",        st2::program_directory);
         r.replace("$(ROOT)",               STConfig.rootpath);
         r.replace("$(PROJECT_DIR)",        STConfig.project_rootpath);
         r.replace("$(EUREKA_ROOT)",        STConfig.eureka_rootpath);
         r.replace("$(EUREKA_PROJECT_DIR)", STConfig.eureka_project_rootpath);
         r.replace("$(PROJECT_NAME)",       Utils.ConvertToFileName(current_song.song_name));
         r.replace("$(HOME)",               getenv("HOME"));
      }
      return deref r;
   }

   // <method.png>
   public static ReadDirectory(String _pathName) : StringArray {
      local String nativePathName <= ToNativePathName(_pathName);
      local StringArray a <= tkfileutils_read_directory(nativePathName);
      // // trace "xxx ReadDirectory: pathName=\""+_pathName+"\" => nativePathName=\""+nativePathName+"\" => a="+#(a);
      if(null != a)
      {
         local IntArray iaSort;
         a.sortByValue(iaSort, false/*bCS*/);
         a.rearrange(iaSort);
      }
      return deref a;
   }

   // <method.png>
   public static CanFileBeRead(String _pathName) : boolean {
      File f;
      if(f.openLocal(_pathName, IOS_IN))
      {
         f.close();
         return true;
      }
      return false;
   }

   // <method.png>
   static MkDirHierarchy(String _pathName) {
      local StringArray subpaths <= _pathName.splitChar('/');
      if(null != subpaths)
      {
         local String dirname = "";
         String *subdir;
         foreach subdir in subpaths
         {
            dirname.append(subdir);
            if!(dirname >= ":")  // skip drives (e.g. "f:")
            {
               // trace "[dbg] Utils::MkDirHierarchy: mkdir dirname=\""+dirname+"\"";
               tkfileutils_mkdir(dirname);
            }
            dirname.append("/");
         }
      }
   }

   // <method.png>
   static public method ToNativePathName(local String _name) : String {
      local String r <= SubstitutePathVars(deref _name);
      r.replace("//", "/");
      if(r <= "~")
         return getenv("HOME")+"/"+r.substring(1,9999);
      else
         return deref r;
   }

   // <method.png>
   public static FixPathname_psystem_exe(String _pathName) : String {
      String r;
      _pathName.replace("//", "/") => r;

      if(IsWindows())
      {
         // Windows
         r.replace("/", "\\");
         r.replace("\\\\", "\\");
         // // // cmdLine.replace(" ", "\\ ");
         // // // cmdLine.replace("(", "\\(");  // does not work (=> "c:\Program" not found)
         // // // cmdLine.replace(")", "\\)");
      }

      return "\""+r+"\"";
   }

   // <method.png>
   public static FixPathname_psystem_arg(String _pathName) : String {
      String r;
      _pathName.replace("//", "/") => r;

      if(IsWindows())
      {
         // Windows
         r.replace("/", "\\");
         r.replace("\\\\", "\\");
         // r.replace(" ", "\\ ");
         // // r.replace(" ", "\" \"");  // wth
      }

      return r;
   }

   // <method.png>
   static public method FixChunkSize(local Stream _out, local int _chunkStartOff) {
      // // trace "xxx 1 fixchunksize: out.offset="+_out.offset;
      local int coff = _out.offset;
      local int chunkSize = coff - _chunkStartOff;
      _out.seek(_chunkStartOff, SEEK_SET);
      _out.i32 = chunkSize;
      _out.seek(coff, SEEK_SET);
   }

   // <method_write.png>
   static public method WriteString(local Stream _out, local String _s) {
      if(null != _s)
      {
         // (note) first 32bit int of data is string length
         _out.serialize(_s, false);
      }
      else
      {
         _out.i32 = 0;
      }
   }

   // <method_read.png>
   static public method ReadString(local Stream _in, local String _s) : int {
      local int startOff = _in.offset;
      _in.deserialize(_s, false);
      return _in.offset - startOff;
   }

   // <method_write.png>
   static public method WriteBuffer(local Stream _out, local Buffer _b) {
      if(null != _b)
      {
         _out.i32 = _b.size;
         _out.writeBuffer(_b, 0, _b.size);
      }
      else
      {
         _out.i32 = 0;  // size = 0
      }
   }

   // <method_read.png>
   static public method ReadBuffer(local Stream _in, local Buffer _b) : int {
      local int startOff = _in.offset;
      local int size = _in.i32;
      _b.free();
      local int numRead = _in.readBuffer(_b, 0, size, true/*bResize*/);
      return _in.offset - startOff;
   }

   // <method_write.png>
   static public method WriteIntArray(local Stream _out, local IntArray _ia) {
      _out.i32 = _ia.numElements * 4;
      local int i = 0;
      loop(_ia.numElements)
         _out.i32 = _ia[i++];
   }

   // <method_read.png>
   static public method ReadIntArray(local Stream _in, local IntArray _ia) {
      local int numElements = _in.i32 / 4;
      _ia.alloc(numElements);
      loop(numElements)
         _ia.add(_in.i32);
   }

   // <method_write.png>
   static public method WriteByteArray(local Stream _out, local IntArray _ia) {
      _out.i32 = _ia.numElements;
      local int i = 0;
      loop(_ia.numElements)
         _out.i8 = _ia[i++];
   }

   // <method_read.png>
   static public method ReadByteArray(local Stream _in, local IntArray _ia) {
      local int numElements = _in.i32;
      _ia.alloc(numElements);
      loop(numElements)
         _ia.add(_in.s8);
   }

   // <method_write.png>
   static public method WriteShortArray(local Stream _out, local IntArray _ia) {
      _out.i32 = _ia.numElements;
      local int i = 0;
      loop(_ia.numElements)
         _out.i16 = _ia[i++];
   }

   // <method_read.png>
   static public method ReadShortArray(local Stream _in, local IntArray _ia) {
      local int numElements = _in.i32;
      _ia.alloc(numElements);
      loop(numElements)
         _ia.add(_in.s16);
   }

   // <method_write.png>
   static public method WriteEnvelope(local Stream _out, local Envelope _env) {
      _out.i8 = 0; // Element type (reserved), 0=float
      _out.i8 = _env.interpolation;
      local int i = 0;
      loop(_env.numElements)
         _out.f32 = _env[i++];
   }

   // <method_read.png>
   static public method ReadEnvelope(local Stream _in, local int _chunkDataSize, local Envelope _env) : int {
      local int startOff = _in.offset;
      if(_chunkDataSize >= (1+1))
      {
         local int envDataType = _in.i8;
         _env.interpolation = _in.i8;
         // todo: check envDataType when calculating numElements
         local int numElements = (_chunkDataSize - 1 - 1) / 4;
         if(numElements > 0)
         {
            if(_env.alloc(numElements))
            {
               _env.numElements = numElements;
               local int i = 0;
               switch(envDataType)
               {
                  default:
                     trace "[---] Utils::ReadEnvelope: unknown data type <"+envDataType+">.";
                     return 0;

                  case 0: // float 32 bit
                     loop(numElements)
                        _env[i++] = _in.f32;
                     // // trace "xxx ReadEnvelope: finished, env="+#(_env);
                     // // trace "xxx ReadEnvelope: numread="+(_in.offset - startOff);
                     return _in.offset - startOff;
               }
            }
            else
            {
               trace "[---] Utils::ReadEnvelope: failed to allocate envelope elements (num="+numElements+").";
            }
         }
         else
         {
            //trace "[~~~] Utils::ReadEnvelope: warning, envelope is empty.";
            return _in.offset - startOff;
         }
      }
      else
      {
         trace "[---] Utils::ReadEnvelope: invalid chunk size ("+_chunkDataSize+").";
      }
      return 0;
   }

   // <method.png>
   static public SortStringArray(StringArray _sa, boolean _bCaseSensitive) {
      IntArray indices;
      indices.identity(_sa.numElements);
      _sa.sortByValue(indices, _bCaseSensitive);
      _sa.rearrange(indices);
      indices.free();
   }

   // <method.png>
   static public KbdFocusNextInMiniCycleList(ui::Layer _kbdFocus,
                                             Object _cycleList
                                             ) {
      int idx;
      ui::Layer *l;
      if(_cycleList instanceof PointerArray)
      {
         PointerArray pa <= _cycleList;
         idx = pa.indexOfPointer(_kbdFocus, 0);
         if(-1 == idx)
            idx = 0;
         else
            idx = (idx + 1) % pa.numElements;
         l <= pa.get(idx);
         ui::UI.SetKeyboardFocus(l);
         if(l instanceof ui::TextField)
            l.onTabFocus();
      }
      else if(_cycleList instanceof ValueArray)
      {
         ValueArray va <= _cycleList;
         idx = va.indexOfPointer(_kbdFocus, 0);
         if(-1 == idx)
            idx = 0;
         else
            idx = (idx + 1) % va.numElements;
         l <= va.get(idx);
         ui::UI.SetKeyboardFocus(l);
         if(l instanceof ui::TextField)
            l.onTabFocus();
      }
   }

   // <method.png>
   static MatchFilterString(StringArray _filterWords, String _s) : boolean {
      // match *all* filter words
      if(null != _filterWords)
      {
         if(_filterWords.numElements > 0)
         {
            local String slc;
            _s.toLower() => slc;
            String *flt;
            foreach flt in _filterWords
            {
               if!(slc & flt.toLower())
                  return false;
            }
         }
      }
      return true;
   }

   // <method.png>
   static FindOptionIdxByFilterWords(StringArray _opt, StringArray _filterWords) : int {
      // (note) case insensitive
      int opt = -1;
      if(null != _opt)
      {
         if(_filterWords.numElements > 0)
         {
            local StringArray aWordsLC;
            String *sWord;
            foreach sWord in _filterWords
            {
               aWordsLC.add(sWord.toLower().trim());
            }

            opt = 0;
            String *sOpt;
            local String sOptLC;
            foreach sOpt in _opt
            {
               sOpt.toLower() => sOptLC;
               boolean bMatchAll = true;
               foreach sWord in aWordsLC
               {
                  bMatchAll = sOptLC & sWord;
                  if(!bMatchAll)
                     break;
               }
               if(bMatchAll)
                  return opt;
               opt++;
            }
            // no match found
            opt = -1;
         }
         else
         {
            // Empty filter
            opt = -1;  ////////_opt.numElements - 1;
         }
      }
      return opt;
   }

   // <method_parse.png>
   public static ParseHexString(Buffer _buf, String _msg) {
      local StringArray words <= _msg.splitSpace(false);
      if(null != words)
      {
         _buf.size = words.numElements;
         _buf.offset = 0;
         local String *s;
         foreach s in words
         {
            _buf.i8 = "0x"+s.trim();
         }
      }
   }

   // <method.png>
   public static IsRelativePath(String _name) {
      return
         !(_name & ":") &&
         !_name.startsWith("/") &&
         !_name.startsWith("~") &&
         !_name.startsWith("$") ;
   }

   // <method.png>
   public static CommonRepeat(local int _a, local int _b) : int {
      return (_a * _b) / mathGCD(_a, _b);
   }

   // <method.png>
   public static AbbrevPathName(local String _name) : String {
      // used in "overwrite" dialogs
      if(_name.length >= 60)
      {
         return _name.substring(0, 20) + "..." + _name.substring(_name.length-40, 9999);
      }
      return deref _name;
   }

   // <method.png>
   public static RollTheDice(int _prob) : boolean {
      return (mathClampi(_prob, 0, 100) >= (100 - rand(99 + 1)));
   }

   // <method.png>
   public static AlignStringC(String _s, char _c, int _numCols) : String {
      local String r = _s;
      int num = _s.numChars;
      local String sc <= tcchar(_c);
      if(num < _numCols)
      {
         r.appendRepeat(sc, (_numCols - num));
      }
      return deref r;
   }

   // <method.png>
   public static LaunchSystemTextEditor(String _pathName) {
      Process proc;
      String cmd;
      local String s = STConfig.textedit_cmd;
      s.replace("$(FILE)", "\""+ToNativePathName(_pathName)+"\"");
      StringArray args <= s.splitSpace(true);
      cmd = args.get(0);
      cmd.trim();
      if(Utils.IsWindows())
         cmd.append("&"); // run in background
      args.delete(0);
      if(!cmd.isBlank())
      {
         Global.Debug("proc.exec(\""+cmd+"\", \""+args+"\")");
         if(!proc.exec(cmd, args))
            Global.Error("proc.exec() failed");
      }
      else
      {
         Global.Warning("unknown STConfig.textedit_cmd");
      }
   }

}
