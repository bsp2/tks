// ----
// ---- file   : P12_RandOscDialog.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- license: (c) 2017-2023 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 07Sep2017
// ---- changed: 20Feb2023, 08Oct2023, 30Oct2023
// ----
// ----
// ----

module MP12_RandOscDialog;

use namespace ui;


class P12_RandOscDialog extends Dialog, ActionProvider {

   define String ACTION_RANDOSC_CHANGED;

   protected XMLForm *xfm;

   protected LayerSwitch *ls_shapes;
   protected Button      *bt_shapes;

   protected Button   *bt_shape_allnone;
   protected CheckBox *cb_shape_1;
   protected CheckBox *cb_shape_2;
   protected CheckBox *cb_shape_3;
   protected CheckBox *cb_shape_4;
   protected CheckBox *cb_shape_5;
   protected CheckBox *cb_shape_6;
   protected CheckBox *cb_shape_7;
   protected CheckBox *cb_shape_8;
   protected CheckBox *cb_shape_9;
   protected CheckBox *cb_shape_10;
   protected CheckBox *cb_shape_11;
   protected CheckBox *cb_shape_12;
   protected CheckBox *cb_shape_13;
   protected CheckBox *cb_shape_14;
   protected CheckBox *cb_shape_15;
   protected CheckBox *cb_shape_16;

   protected ComboBox   *cm_layer;
   protected ComboBox   *cm_mode;
   protected CheckBox *cb_noise;
   protected CheckBox *cb_sync;
   protected CheckBox *cb_sync_pitch;
   protected CheckBox *cb_fm;
   protected CheckBox *cb_am;
   protected CheckBox *cb_pitch;
   protected CheckBox *cb_lowoct;
   protected CheckBox *cb_detune;
   protected CheckBox *cb_slop;
   protected CheckBox *cb_keyfollow;
   protected CheckBox *cb_normalize;

   protected Button *bt_rand;

   protected EditMIDISynthFormProphet12 *parent_editor;
   protected Prophet12_Patch *patch;


   // <ui_init.png>
   public method init() : boolean {

      initDialog();

      xfm <= XMLForm.New_PakFile("P12_RandOscDialog.xfm");
      if(null == xfm)
         return false;

      xfm.autoResolveIds(this);

      initWindow(xfm,
                 "Oscillator Randomizer",
                 100, 100,
                 640, 100
                 );

      return true;
   }

   public method showRandOsc(EditMIDISynthFormProphet12 _editor) {
      parent_editor <= _editor;
      patch <= parent_editor.patch;

      StringArray midiNotes <= MIDI.midi_notes;
      cb_pitch.setToolTipCaption("When checked, allow different pitches\n\nWhen unchecked, force pitch to "+midiNotes.get(4*12/*C-4*/)+"\n\nIn mixed state, don't allow octaves lower than "+midiNotes.get(4*12/*C-4*/)+" (fold back to higher octaves)");

      showNearMouse(-40, -120);
   }

   public virtual getProvidedActionNames() : StringArray {
      return [ACTION_RANDOSC_CHANGED];
   }

   public virtual isPopup() : boolean {
      return true;
   }

   public virtual isModal():boolean {
      return true;
   }

   public virtual isResizable() : boolean {
      return false;
   }

   // <ui_show.png>
   protected virtual preShow() {

      if(!b_layer_postinit_done)
      {
         resizeToMinimum();
      }

      Dialog::preShow();
   }

   // <ui_show.png>
   protected virtual postShow() {
      Dialog::postShow();
      UI.SetKeyboardFocus(bt_rand);
   }

   // <ui_handle.png>
   protected method handleToggleShapes() {
      Global.Print((bt_shapes.getToggleState() ? "Show" : "Hide")+" shape filter");

      if(bt_shapes.getToggleState())
      {
         ls_shapes.switchToLayerNr(1);
      }
      else
      {
         ls_shapes.switchToLayerNr(0);
      }

      resizeToMinimum();
   }

   // <ui_handle.png>
   protected method handleToggleShapeAllNone() {

      boolean bAll =
         cb_shape_1.isSelected() &&
         cb_shape_2.isSelected() &&
         cb_shape_3.isSelected() &&
         cb_shape_4.isSelected() &&
         cb_shape_5.isSelected() &&
         cb_shape_6.isSelected() &&
         cb_shape_7.isSelected() &&
         cb_shape_8.isSelected() &&
         cb_shape_9.isSelected() &&
         cb_shape_10.isSelected() &&
         cb_shape_11.isSelected() &&
         cb_shape_12.isSelected() &&
         cb_shape_13.isSelected() &&
         cb_shape_14.isSelected() &&
         cb_shape_15.isSelected() &&
         cb_shape_16.isSelected() ;

      cb_shape_1.setSelected(!bAll);
      cb_shape_2.setSelected(!bAll);
      cb_shape_3.setSelected(!bAll);
      cb_shape_4.setSelected(!bAll);
      cb_shape_5.setSelected(!bAll);
      cb_shape_6.setSelected(!bAll);
      cb_shape_7.setSelected(!bAll);
      cb_shape_8.setSelected(!bAll);
      cb_shape_9.setSelected(!bAll);
      cb_shape_10.setSelected(!bAll);
      cb_shape_11.setSelected(!bAll);
      cb_shape_12.setSelected(!bAll);
      cb_shape_13.setSelected(!bAll);
      cb_shape_14.setSelected(!bAll);
      cb_shape_15.setSelected(!bAll);
      cb_shape_16.setSelected(!bAll);

      Global.Print((bAll ? "Deselect" : "Select") + " all shapes");
   }

   // <ui_handle.png>
   protected method handleClose() {
      hide();
   }

   // <ui_handle.png>
   protected method randomizeLayer(Prophet12_Program _layer) {

      int mode = cm_mode.getSelectedOption();

      boolean bNoise     = cb_noise.isSelected();
      boolean bSync      = cb_sync.isSelected();
      boolean bSyncPitch = cb_sync_pitch.isSelected();
      boolean bFM        = cb_fm.isSelected();
      boolean bAM        = cb_am.isSelected();
      boolean bPitch     = cb_pitch.isSelected();
      boolean bLowOct    = cb_lowoct.isSelected();
      boolean bDetune    = cb_detune.isSelected();
      boolean bSlop      = cb_slop.isSelected();
      boolean bKeyFollow = cb_keyfollow.isSelected();
      boolean bNormalize = cb_normalize.isSelected();

      Prophet12_Osc *osc;

      boolean bAnyEnabled = false;
      boolean bForceRecalc = false;
      int recalcCount = 0;

      while( (!bAnyEnabled || bForceRecalc) && (recalcCount++ < 100) )
      {
         bForceRecalc = false;

         switch(mode)
         {
            case 0:  // RAND_ALL
            case 1:  // RAND_ALL_ENABLE
            case 2:  // RAND_MUSICAL
            case 3:  // RAND_MUSICAL_ENABLE
               foreach osc in _layer.oscs
               {
                  osc.loadRandom(mode);
               }

               break;

            case 4:  // chroma
               break;

            case 5:  // chromaoct
               break;
         }

         int lvlSum = 0;
         int numEnabled = 0;
         int oscIdx = 0;

         foreach osc in _layer.oscs
         {
            if(true != bNoise)
            {
               if(osc.shape >= 17/*Red Noise*/)
               {
                  osc.level = 0;
                  if(false == bNoise)
                     bForceRecalc = true;
               }
            }

            lvlSum += osc.b_enable ? osc.level : 0;
            numEnabled += osc.b_enable;

            if(osc.shape >= 17/*Red Noise*/)
            {
               osc.b_sync = false;
            }

            if(!bSync)
            {
               osc.b_sync = false;
            }

            if(!bFM)
            {
               osc.fm = 0;
            }
            else if(maybe == bFM)
            {
               osc.fm = (osc.fm & 255) / 4;
            }

            if(!bAM)
            {
               osc.am = 0;
            }
            else if(maybe == bAM)
            {
               osc.am = (osc.am & 255) / 4;
            }

            if(maybe == bPitch)
            {
               if(osc.pitch < 4*12)
               {
                  osc.pitch = (osc.pitch%12) + ((4 - (osc.pitch/12)) + 4)*12;
               }
            }
            else if(!bPitch)
            {
               osc.pitch = 4*12;
            }

            if(false == bDetune)
            {
               osc.fine = 50;
            }
            else if(maybe == bDetune)
            {
               osc.fine = (osc.fine - 50)/2 + 50;
            }

            if(!bSlop)
            {
               osc.slop = 0;
            }

            if(true == bKeyFollow)
            {
               osc.b_keyfollow = true;
            }
            if(false == bKeyFollow)
            {
               osc.b_keyfollow = false;
            }

            oscIdx++;
         }

         if(bt_shapes.getToggleState())
         {
            foreach osc in _layer.oscs
            {
               if(osc.b_enable)
               {
                  boolean bFiltered = false;

                  IntArray availShapes; availShapes.empty();
                  IntArray availModShapes; availModShapes.empty();

                  if(cb_shape_1.isSelected()) availShapes.add(1);
                  if(cb_shape_2.isSelected()) availShapes.add(2);
                  if(cb_shape_3.isSelected()) availShapes.add(3);
                  if(cb_shape_4.isSelected()) availShapes.add(4);
                  if(cb_shape_5.isSelected()) availShapes.add(5);
                  if(cb_shape_6.isSelected()) availShapes.add(6);
                  if(cb_shape_7.isSelected()) availShapes.add(7);
                  if(cb_shape_8.isSelected()) availShapes.add(8);
                  if(cb_shape_9.isSelected()) availShapes.add(9);
                  if(cb_shape_10.isSelected()) availShapes.add(10);
                  if(cb_shape_11.isSelected()) availShapes.add(11);
                  if(cb_shape_12.isSelected()) availShapes.add(12);
                  if(cb_shape_13.isSelected()) availShapes.add(13);
                  if(cb_shape_14.isSelected()) availShapes.add(14);
                  if(cb_shape_15.isSelected()) availShapes.add(15);
                  if(cb_shape_16.isSelected()) availShapes.add(16);

                  if(availShapes.numElements > 0)
                  {
                     if(cb_shape_5.isSelected()) availModShapes.add(0);
                     if(cb_shape_6.isSelected()) availModShapes.add(1);
                     if(cb_shape_7.isSelected()) availModShapes.add(2);
                     if(cb_shape_8.isSelected()) availModShapes.add(3);
                     if(cb_shape_9.isSelected()) availModShapes.add(4);
                     if(cb_shape_10.isSelected()) availModShapes.add(5);
                     if(cb_shape_11.isSelected()) availModShapes.add(6);
                     if(cb_shape_12.isSelected()) availModShapes.add(7);
                     if(cb_shape_13.isSelected()) availModShapes.add(8);
                     if(cb_shape_14.isSelected()) availModShapes.add(9);
                     if(cb_shape_15.isSelected()) availModShapes.add(10);
                     if(cb_shape_16.isSelected()) availModShapes.add(11);

                     if(1 <= osc.shape <= 16)
                     {
                        if(!availShapes.contains(osc.shape))
                        {
                           osc.shape = availShapes[rand(availShapes.numElements)];
                        }

                        if(5 <= osc.shape <= 16)
                        {
                           if(!availModShapes.contains(osc.shape_left))
                           {
                              osc.shape_left = availModShapes[rand(availModShapes.numElements)];
                           }

                           if(!availModShapes.contains(osc.shape_right))
                           {
                              osc.shape_right = availModShapes[rand(availModShapes.numElements)];
                           }
                        }
                     }
                  }
                  else
                  {
                     bFiltered = true;
                  }

                  if(bFiltered)
                  {
                     osc.b_enable = false;
                     osc.shape = 0;
                     osc.level = 0;

                     if(mode&1) // enableall?
                     {
                        // retry
                        bForceRecalc = true;
                     }
                  }
               } // if osc.b_enable
            } // foreach osc
         } // if bt_shapes

         foreach osc in _layer.oscs
         {
            osc.b_enable = osc.b_enable && (osc.shape > 0);
            bAnyEnabled |= (osc.b_enable && (osc.level > 0));
         }

         if(bSyncPitch)
         {
            oscIdx = 0;
            foreach osc in _layer.oscs
            {
               if(osc.b_sync)
               {
                  Prophet12_Osc oscPrev <= _layer.oscs.get((oscIdx+3) % 4);
                  Prophet12_Osc oscNext <= _layer.oscs.get((oscIdx+1) % 4);
                  if(oscNext.b_enable && (oscNext.shape < 17/*Red Noise*/) && !oscNext.b_sync && !(oscPrev.b_enable && oscPrev.b_sync))
                  {
                     osc.pitch = rnd(127);
                  }
               }

               oscIdx++;
            }
         }

         if(bNormalize)
         {
            foreach osc in _layer.oscs
            {
               if(osc.b_enable)
               {
                  osc.level = 100 * ((float(osc.level) / lvlSum));
               }
            }
         }

         foreach osc in _layer.oscs
         {
            bAnyEnabled |= osc.b_enable;

            if(osc.b_enable)
            {
               int origPitch = osc.pitch;
               if(true == bLowOct)
                  osc.pitch -= 12;
               else if(maybe == bLowOct)
                  osc.pitch -= 24;
               if(osc.pitch < 0)
                  osc.pitch = origPitch;
            }
         }

      }

      _layer.oscs.get(0).send(parent_editor, _layer, false/*bProxy*/);
      _layer.oscs.get(1).send(parent_editor, _layer, false/*bProxy*/);
      _layer.oscs.get(2).send(parent_editor, _layer, false/*bProxy*/);
      _layer.oscs.get(3).send(parent_editor, _layer, false/*bProxy*/);
   }

   // <ui_handle.png>
   protected method handleUpdate() {

      Global.Print("Randomize Osc");

      switch(cm_layer.getSelectedOption())
      {
         case 0:  // A
            randomizeLayer(patch.layer_a);
            break;

         case 1:  // B
            randomizeLayer(patch.layer_b);
            break;

         case 2:  // A+B
            randomizeLayer(patch.layer_b);
            randomizeLayer(patch.layer_a);
            break;
      }

      StringAction ac <= Action.New(getProvidedActionAlias(ACTION_RANDOSC_CHANGED), this);
      parent_editor.consumeAction(ac);
   }

   // <ui_kbd.png>
   public virtual onKey(Key _key) returns boolean {
      switch(_key.pressed)
      {
         case VKEY_ESCAPE:
         case 'r':
            handleClose();
            return true;

         default:
            break;
      }
      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _ac) returns boolean {
      String name=_ac.getActionName();

      switch(@(_ac.getActionProvider()))
      {
         case @(bt_rand):
            handleUpdate();
            return true;

         case @(bt_shapes):
            handleToggleShapes();
            return true;

         case @(bt_shape_allnone):
            handleToggleShapeAllNone();
            return true;
      }

      return true;
   }

}
