// ----
// ---- file   : NodeTrigSeqEditor.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2016-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- changed: 09Jul2016, 10Jul2016, 11Jul2016, 12Jul2016, 13Jul2016, 17Jul2016, 08Oct2016
// ----          09Oct2016, 11Oct2016, 15Oct2016, 16Oct2016, 11Dec2016, 12Dec2016, 19Dec2016
// ----          19Jan2017, 23Jan2017, 31Jan2017, 03Feb2017, 09Feb2017, 26Feb2017, 05Mar2017
// ----          10Mar2017, 18Mar2017, 24Mar2017, 01Jun2017, 16Jun2017, 14Jul2017, 01Sep2017
// ----          12Oct2017, 13Oct2017, 14Oct2017, 10Nov2017, 11Nov2017, 25Nov2017, 29Nov2017
// ----          30Nov2017, 02Dec2017, 04Jan2018, 12May2018, 28May2018, 10Jun2018, 17Jun2018
// ----          26Nov2018, 27Nov2018, 01Dec2018, 01Mar2019, 25Jun2019, 20Jul2019, 29Aug2019
// ----          08Sep2019, 10Sep2019, 20Sep2019, 22Sep2019, 02Oct2019, 03Oct2019, 04Oct2019
// ----          05Oct2019, 06Oct2019, 07Oct2019, 08Oct2019, 09Oct2019, 14Oct2019, 19Oct2019
// ----          24Oct2019, 25Oct2019, 30Oct2019, 01Nov2019, 02Nov2019, 08Nov2019, 28Feb2020
// ----          25Apr2020, 26Apr2020, 09May2020, 26Oct2020, 27Oct2020, 30Oct2020, 02Nov2020
// ----          06Nov2020, 13Nov2020, 26Jan2021, 13May2021, 18Jun2021, 25Jun2021, 08Apr2022
// ----          07May2022, 22Oct2022, 25Nov2022, 11Feb2023, 21Jun2023, 23Jun2023, 01Sep2023
// ----          05Sep2023, 21Sep2023, 03Oct2023, 06Oct2023, 08Oct2023, 14Oct2023, 01Nov2023
// ----          10Nov2023, 27Nov2023, 28Nov2023, 01Dec2023, 02Dec2023, 07Dec2023, 03Feb2024
// ----          22Mar2024, 24Mar2024, 05Oct2024, 06Oct2024, 23Jan2025, 28Feb2025
// ----
// ----
// ----

module MNodeTrigSeqEditor;

use namespace ui;
use namespace st2;


// <class.png>
class NTS_TrackPanel : Panel {
   NodeTrigSeqEditor *editor;

   // <ui_mouse.png>
   public virtual onMouseClick(MouseEvent _ev) : boolean {
      if(NodeTrigSeqEditor.TAB_GRID == (editor.ts_groups.getActiveTabIndex()))
      {
         // trace "xxx NTS_TrackPanel::onMouseClick: _ev.current_state="+_ev.current_state;

         if(_ev.rightButtonUp())
         {
            editor.showContextMenu(false/*bFocusFirst*/);
            return true;
         }
      }

      return false;
   }
}


// <class.png>
class NTS_TrackForm {
   NTS_TrackPanel *pn_track;

   Label       *lb_tracknr;
   Button      *bt_mute;
   Button      *bt_solo;
   LayerSwitch *ls_arg3;
   FloatParam  *fp_arg3;
   ComboBox    *cm_arg3;
   TextField   *tf_name;

   LayerSwitch *ls_hide;
   FloatParam  *fp_quant;
   FloatParam  *fp_swing;
   ComboBox    *cm_notelen;
   FloatParam  *fp_numsteps;

   boolean b_folded;


   // <ui_kbd.png>
   public method addTabCycleOverrides(PointerArray layers) {

      layers.joinRR(layers,
                    [
                       bt_mute,
                       bt_solo,
                       (0 == ls_arg3.getCurrentChildNr()) ? fp_arg3 : cm_arg3,
                       tf_name
                       ]
                    );

      if(!b_folded)
      {
         layers.joinRR(layers,
                       [
                          fp_quant,
                          fp_swing,
                          cm_notelen,
                          fp_numsteps
                        ]
                       );
      }

   }

   // <ui_update.png>
   public method updateTrack(NodeTrigSeq _seq, NTS_Track _track, NTS_Pattern _pat, boolean _bFolded) {

      b_folded = _bFolded;

      lb_tracknr.setCaption(String(_track.track_nr + 1));

      // (note) fp_arg3 is updated in updateArg3NoteNames()
      // // fp_arg3    .setValue         (_track.arg3);

      if( (null == _track.getCurrentNoteNameProfileId(_pat)) || !_track.isNoteOutputMode(_seq) )
      {
         ls_arg3.switchToLayerNr(0);  // Numbers (FloatParam)
      }
      else
      {
         ls_arg3.switchToLayerNr(1);  // Note Name Preset (ComboBox)
         StringArray noteNames <= MIDI.note_name_profiles.get(_track.getCurrentNoteNameProfileId(_pat));
         cm_arg3.setOptions( (null != noteNames) ? noteNames : MIDI.note_name_profiles["default"] );
         cm_arg3.setSelectedOption(_track.arg3 + _pat.arg3_offset);
      }

      tf_name .setText (_track.name);
      fp_quant.setValue(_track.quantization_amount);
      fp_swing.setValue(_track.swing_amount);

      local StringArray options;
      options.join(NTS_Track.notelen_names, NTS_Track.notelen_names_fit);
      cm_notelen .setOptions       (options);
      cm_notelen .setSelectedOption(_track.step_note_length);
      fp_numsteps.setValue         (_track.play_length);

      if(NTS_Track.STATE_MUTE == _track.play_state)
      {
         bt_mute.setBackgroundTint(#60ff0000);
         bt_mute.setEditable(true);
         bt_solo.setBackgroundTint(0);
      }
      else if(NTS_Track.STATE_SOLO == _track.play_state)
      {
         bt_mute.setBackgroundTint(#4000ff00);
         bt_solo.setBackgroundTint(#a0ffff00);
         bt_mute.setEditable(false);
      }
      else
      {
         bt_mute.setBackgroundTint(#4000a000);
         bt_mute.setEditable(true);
         bt_solo.setBackgroundTint(0);
      }

      tf_name.setBackgroundTint(_track.bg_tint);

      ls_hide.switchToLayerNr(_bFolded ? 0 : 1);

      ls_arg3.recursiveOnResize();
   }

   // <method_set.png>
   public method setEditable(boolean _bEditable) {
      lb_tracknr .setEditable(_bEditable);
      fp_arg3    .setEditable(_bEditable);
      cm_arg3    .setEditable(_bEditable);
      tf_name    .setEditable(_bEditable);
      fp_quant   .setEditable(_bEditable);
      fp_swing   .setEditable(_bEditable);
      cm_notelen .setEditable(_bEditable);
      cm_notelen .setEditable(_bEditable);
      fp_numsteps.setEditable(_bEditable);

      if(!_bEditable)
      {
         lb_tracknr .setCaption("-");
         fp_arg3    .setNonEditableText("-");
         tf_name    .setText("-");
         fp_quant   .setNonEditableText("-");
         fp_swing   .setNonEditableText("-");
         cm_notelen .setSelectedOption(-1);
         fp_numsteps.setNonEditableText("-");
      }
   }

   // <ui.png>
   public method handleTrigRepeatMuteUpdate(NTS_TrackState _trackState, Layer _lnfLayer) {
      if(_trackState.uiTickCountdown(_lnfLayer))
      {
         lb_tracknr.setBackgroundTint(_trackState.ui_c32);
         lb_tracknr.redraw();
      }
   }

}


// <class.png>
class NTS_Grid extends Control {

   define String TA_REDRAW;
   module TimerAction *ta_redraw;

   define String TA_CHECKREDRAW;
   module TimerAction *ta_checkredraw;

   NodeTrigSeqEditor *editor;

   module int cursor_x;
   module int cursor_y;

   define int DRAG_NONE      = 0;
   define int DRAG_MICROTIME = 1;  // upper
   define int DRAG_STEP      = 2;  // center
   define int DRAG_ARG2      = 3;  // lower
   define int DRAG_MOD1      = 4;  // left
   define int DRAG_MOD2      = 5;  // right
   protected int drag_mode;
   protected int drag_start_x;
   protected int drag_start_y;
   protected int drag_start_cursor_x;
   protected int drag_start_cursor_y;
   protected float drag_start_microtime;
   protected float drag_start_arg2;
   protected float drag_start_mod1;
   protected float drag_start_mod2;
   protected NTS_Step *drag_step;

   protected boolean b_skip_mb_up; // true=skip first button up event after kbd focus was gained or trigger was set with LMB

   protected NTS_Step clipboard_step;

   protected Font *font;
   protected Font *font_stepnr;

   float cell_sx; // only used when hscroll is active (when not fitting all cells into avail width)

   protected static NTS_Track *track_clipboard;

   module boolean b_make_cursor_visible_pending;

   protected boolean lock_mouse_track_idx;  // -1=not locked, 0..15: locked track idx  (LCTRL modifier)
   protected int lock_mouse_last_grid_x;

   NTS_PasteAllDialog *dlg_track_pasteall;


   // <ui_init.png>
   public method init(NodeTrigSeqEditor _editor) {
      editor <= _editor;

      track_clipboard <= new NTS_Track;
      track_clipboard.init(null/*node*/, 0/*trackNr*/);

      // onLookAndFeelChanged();
      initTimers();
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_redraw       <= TimerAction.New(TA_REDRAW,      this, 1000.0/20);
      ta_checkredraw  <= TimerAction.New(TA_CHECKREDRAW, this, 1000.0/20);
   }

   // <method_get.png>
   public virtual isEditable() : boolean {
      // So that UI does not skip tab focus
      return true;
   }

   // <method_get.png>
   public virtual isTabCycleMember() : boolean {
      return true;
   }

   // <ui_show.png>
   public method handleViewEnter() {
      lock_mouse_track_idx = -1;

      ta_checkredraw.reschedule();
      editor.queueUpdateStepDetails();
   }

   // <ui_handle.png>
   public method handleLeaveNode() {
      ta_redraw.cancel();
      ta_checkredraw.cancel();
   }

   // <method_get.png>
   module method getCellSx() : float {
      NTS_Pattern pat <= editor.getEditPattern();
      if(null != pat)
      {
         float sx = getSizeX();
         // // float sy = getSizeY();
         // // float cellSy = getCellSy();

         int maxSteps = pat.getMaxSteps();
         float cellSx = (STConfig.node_trig_seq_grid_steps_x>0)?cell_sx : sx / maxSteps;

         return cellSx;
      }

      return 1.0f;
   }

   // <method_get.png>
   public method getTrackFormSx() : float {
      NTS_TrackForm form0 <= editor.track_forms.get(0);
      float sx = form0.pn_track.getSizePadX();
      return sx;
   }

   // <method_get.png>
   protected method getCellSy() : float {
      NTS_TrackForm form0 <= editor.track_forms.get(0);
      float cellSy = form0.pn_track.getSizePadY();
      return cellSy;
   }

   // <method_get.png>
   public method getClippedCursorX() : int {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         int r = cursor_x;

         if(r >= track.play_length)
         {
            r = track.play_length - 1;
         }

         return r;
      }

      return -1;
   }

   // <method.png>
   public method makeCursorVisible() {
      Point2f p;
      float cellSx = getCellSx();
      float cellSy = getCellSy();
      p.init(cursor_x * cellSx + (editor.track_forms.get(0).pn_track.getSizePadX()),
             cursor_y * cellSy
             );
      Size2f s;
      s.init(cellSx, cellSy);
      editor.sp_tracks.makeRectVisible(p, s);
   }

   // <method_set.png>
   public method setCursorX(int _newCursorX) {
      cursor_x = _newCursorX;
      editor.seq.uiSetCursorX(_newCursorX);  // for mod recording
   }

   // <method_set.png>
   public method setCursorXYAndMakeVisible(int _newCursorX, int _newCursorY) {
      cursor_x = _newCursorX;
      editor.seq.uiSetCursorX(_newCursorX);  // for mod recording
      setCursorYAndMakeVisible(_newCursorY);
      // // cursor_y = _newCursorY;
      // // makeCursorVisible();
   }

   // <method_set.png>
   public method setCursorYAndMakeVisible(int _newCursorY) {
      // selectTrack
      _newCursorY = mathClampi(_newCursorY, 0, NTS_Pattern.NUM_TRACKS);
      cursor_y = _newCursorY;
      editor.seq.uiSetCursorY(_newCursorY);
      makeCursorVisible();
      editor.queueUpdateStepDetails();
   }

   // <method_get.png>
   public method getCursorX() : int {
      return cursor_x;
   }

   // <method_get.png>
   public method getCursorY() : int {
      return cursor_y;
   }

   // <ui_handle.png>
   public method cursorToFirstTrack() {
      if(cursor_y > 0)
      {
         setCursorXYAndMakeVisible(cursor_x, 0);
         editor.pluginHandleCursorPosChanged();
         redraw();
      }
   }

   // <ui_handle.png>
   public method cursorToLastTrack() {
      if(cursor_y < (NTS_Pattern.NUM_TRACKS-1))
      {
         setCursorXYAndMakeVisible(cursor_x, (NTS_Pattern.NUM_TRACKS-1));
         editor.pluginHandleCursorPosChanged();
         redraw();
      }
   }

   // <ui_handle.png>
   public method cursorUp() {
      NTS_Pattern pat <= editor.seq.nodeGetCurrentEditPattern();

      if(null != pat)
      {
         // Find previous, non-empty track
         int nextCursorY = cursor_y - 1;
         while(nextCursorY >= 0)
         {
            NTS_Track track <= pat.getTrackByIndex(nextCursorY);

            if(track.play_length > 0)
               break;

            nextCursorY--;
         }

         if(nextCursorY >= 0)
         {
            setCursorXYAndMakeVisible(cursor_x, nextCursorY);
            editor.pluginHandleCursorPosChanged();
            redraw();
         }
      }
   }

   // <ui_handle.png>
   public method cursorDown() {
      NTS_Pattern pat <= editor.seq.nodeGetCurrentEditPattern();

      if(null != pat)
      {
         // Find next non-empty track
         int nextCursorY = cursor_y + 1;
         while(nextCursorY < NTS_Pattern.NUM_TRACKS)
         {
            NTS_Track track <= pat.getTrackByIndex(nextCursorY);

            if(track.play_length > 0)
               break;

            nextCursorY++;
         }

         if(nextCursorY < NTS_Pattern.NUM_TRACKS)
         {
            setCursorXYAndMakeVisible(cursor_x, nextCursorY);
            editor.pluginHandleCursorPosChanged();
            redraw();
         }
      }
   }

   // <ui_handle.png>
   public method cursorPageUp() {
      if(cursor_y > 0)
      {
         int newY;

         if(0 == (cursor_y & 3))
         {
            newY = cursor_y - 4;
         }
         else
         {
            newY = cursor_y & ~3;
         }

         if(newY < 0)
            newY = 0;

         setCursorXYAndMakeVisible(cursor_x, newY);
         editor.pluginHandleCursorPosChanged();
         redraw();
      }
   }

   // <ui_handle.png>
   public method cursorPageDown() {
      if(cursor_y < (NTS_Pattern.NUM_TRACKS-1))
      {
         int newY;
         newY = (cursor_y & ~3) + 4;

         if(newY >= NTS_Pattern.NUM_TRACKS)
         {
            newY = NTS_Pattern.NUM_TRACKS - 1;
         }

         setCursorXYAndMakeVisible(cursor_x, newY);
         editor.pluginHandleCursorPosChanged();
         redraw();
      }
   }

   // <ui_handle.png>
   public method cursorLeft() {
      if(cursor_x > 0)
      {
         setCursorXYAndMakeVisible(getClippedCursorX() - 1, cursor_y);
         editor.pluginHandleCursorPosChanged();
         redraw();
      }
   }

   // <ui_handle.png>
   public method cursorRight() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         if(cursor_x < (track.play_length-1))
         {
            setCursorXYAndMakeVisible(cursor_x + 1, cursor_y);
            editor.pluginHandleCursorPosChanged();
            redraw();
         }
      }
   }

   // <method_get.png>
   protected method getStepAtXY(float _x, float _y, Integer _retArea, Integer _retModArea, Float _retNormY) : NTS_Step {
      NTS_Pattern pat <= editor.getEditPattern();

      _retModArea = -1;

      if(null != pat)
      {
         float sx = getSizeX();
         float sy = getSizeY();
         float cellSy = getCellSy();

         int maxSteps = pat.getMaxSteps();
         float cellSx = (STConfig.node_trig_seq_grid_steps_x>0)?cell_sx : sx / maxSteps;

         int xIdx = _x / cellSx;
         int yIdx = _y / cellSy;

         // trace "xxx mouse cell=("+xIdx+";"+yIdx+")";

         NTS_Track track <= pat.getTrackByIndex(yIdx);

         if(null != track)
         {
            NTS_Step st <= track.getStepByIndex(xIdx);

            if(null != st)
            {
               _retArea = 3 * (_y - (yIdx * cellSy)) / cellSy;

               if(null != _retNormY)
               {
                  _retNormY = ((cellSy-1) - ((_y - yIdx*cellSy))) / (cellSy-1);
                  // trace "xxx _retNormY="+_retNormY;
               }

               if( (_x - (xIdx * cellSx)) < (cellSx*0.33) )
                  _retModArea = 1;
               else if( (_x - (xIdx * cellSx)) > (cellSx*0.66) )
                  _retModArea = 2;

               return st;
            }
         }
      }

      return null;
   }

   // <method_get.png>
   module method getStepByIdx(int _x, int _y) : NTS_Step {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         NTS_Track track <= pat.getTrackByIndex(_y);

         if(null != track)
         {
            NTS_Step st <= track.getStepByIndex(_x);

            return st;
         }
      }

      return null;
   }

   // <method_get.png>
   module method getCurrentTrackStepByIdx(int _x) : NTS_Step {
      return getStepByIdx(_x, cursor_y);
   }

   // <method_get.png>
   public method getCursorStep() : NTS_Step {
      return getStepByIdx(getClippedCursorX(), cursor_y);
   }

   // <method_get.png>
   public method getCursorTrack() : NTS_Track {
      local NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         return pat.getTrackByIndex(cursor_y);
      }

      return null;
   }

   // <method_get.png>
   public method getLockedMouseTrack() : NTS_Track {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         NTS_Track track <= pat.getTrackByIndex(lock_mouse_track_idx);

         return track;
      }

      return null;
   }

   // <method.png>
   module method showCursorStepInfo() {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         Global.Print("Track "+(st.grid_y+1)+", Step "+(st.grid_x+1)+": trig="+st.b_trig+" repeat="+st.b_repeat+" mod="+st.b_mod+" arg1="+st.arg1+" arg2="+st.getArg2String(false/*bShort*/));
      }
   }

   // <method.png>
   public method toggleCursorStepTrig() : boolean {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         st.setEnableTrig(!st.b_trig);
         editor.queueUpdateStepDetails();

         redraw();
         return st.b_trig;
      }
      return false;
   }

   // <method.png>
   public method cycleCursorStepArg1AndEnableTrig() : boolean {
      NTS_Step st <= getCursorStep();
      boolean r = false;
      if(null != st)
      {
         editor.undoBeginTimer();
         if(!st.b_trig)
         {
            st.setEnableTrig(true);
            st.setArg1(0);
            r = true;
         }
         else
         {
            st.setArg1(mathWrapi(int(st.arg1) + 1, 0, 4));
         }
         Global.Print("Cycle Step Arg1 ("+st.getArg1Label()+") is "+st.arg1+" ("+(st.getArg1String().substring(3, 99))+")");
         editor.queueUpdateStepDetails();
         redraw();
      }
      return r;
   }

   // <method.png>
   public method cycleCursorStepArg1AndEnableOrDisableTrig() : boolean {
      NTS_Step st <= getCursorStep();
      boolean r = false;
      if(null != st)
      {
         editor.undoBeginTimer();
         if(!st.b_trig)
         {
            st.setEnableTrig(true);
            st.setArg1(0);
            r = true;
         }
         else
         {
            st.setArg1(mathWrapi(int(st.arg1) + 1, 0, 4));
            if(0 == int(st.arg1))
               st.setEnableTrig(false);
         }
         Global.Print("Cycle Step Arg1 ("+st.getArg1Label()+") is "+st.arg1+" ("+(st.getArg1String().substring(3, 99))+")");
         editor.queueUpdateStepDetails();
         redraw();
      }
      return r;
   }

   // <method.png>
   module method playCursorStep() {
      // All tracks
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.seq.queueStepReplay(st.grid_x);
      }
   }

   // <method.png>
   public method queueTrackStep() {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         NTS_Track track <= getCursorTrack();
         track.queueStepReplay(st.grid_x);
      }
   }

   // <method.png>
   public method queueTrackTrigger(boolean _bOn) {
      NTS_Track track <= getCursorTrack();

      if(null != track)
      {
         if(!replay.b_playing)
         {
            NodeTrigSeq seq <= editor.seq;
            seq.tick_nr = cursor_x * track.current_step_num_ticks;
         }

         if(maybe == _bOn)
         {
            track.queueTrackTrigger(true);
            track.queueTrackTrigger(false);
         }
         else
         {
            track.queueTrackTrigger(_bOn);
         }
      }
   }

   // <method.png>
   protected =replay= method clearCursorStep() {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         st.clearStep();
         editor.queueUpdateStepDetails();
         Global.Print("Clear step");
         redraw();
      }
   }

   // <method.png>
   public =replay= method clearCursorTrackStepByIndex(int _idx) {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         NTS_Step st <= track.getStepByIndex(_idx);
         if(null != st)
         {
            editor.undoBeginTimer();
            st.clearStep();
            editor.queueUpdateStepDetails();
            Global.Print("Clear step "+(_idx+1));
            redraw();
         }
      }
   }

   // <method.png>
   protected =replay= method clearCursorStepMod(boolean _bMod2) {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         if(_bMod2)
            st.setMod2(-1);
         else
            st.setMod1(-1);
         editor.queueUpdateStepDetails();
         Global.Print("Clear step mod "+(1+_bMod2));
         redraw();
      }
   }

   // <method.png>
   module =replay= method cutCursorStep() {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         clipboard_step.copyFrom(st);

         editor.undoBeginTimer();
         st.clearStep();

         Global.Print("Cut step to clipboard");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   public method copyCursorStep() {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         clipboard_step.copyFrom(st);

         Global.Print("Copy step to clipboard");
      }
   }

   // <method.png>
   public method copyCursorTrackStepToClipboardByIndex(int _idx) {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         NTS_Step st <= track.getStepByIndex(_idx);
         if(null != st)
         {
            clipboard_step.copyFrom(st);

            Global.Print("Copy step "+(_idx+1)+" to clipboard");
         }
      }
   }

   // <method.png>
   public =replay= method pasteCursorStep() {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         st.copyFrom(clipboard_step);

         Global.Print("Paste clipboard step");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method setCursorStepArg1(float _arg1) {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         if(!st.b_trig)
            st.setEnableTrig(true);
         st.setArg1(_arg1);
         editor.queueUpdateStepDetails();
         Global.Print("Step Arg1 ("+st.getArg1Label()+") is "+_arg1+" ("+(st.getArg1String().substring(3, 99))+")");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method rotateTrackStepsLeft() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.rotateStepsLeft();
         editor.queueUpdateStepDetails();

         Global.Print("Rotate track steps left");
         redraw();
      }
   }

   // <method.png>
   module method rotateTrackStepsRight() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.rotateStepsRight();
         editor.queueUpdateStepDetails();

         Global.Print("Rotate track steps right");
         redraw();
      }
   }

   // <method.png>
   module method rotatePatternStepsLeft() {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         editor.undoBeginTimer();
         pat.rotatePatternStepsLeft();
         editor.queueUpdateStepDetails();

         Global.Print("Rotate pattern steps left");
         redraw();
      }
   }

   // <method.png>
   module method rotatePatternStepsRight() {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         editor.undoBeginTimer();
         pat.rotatePatternStepsRight();
         editor.queueUpdateStepDetails();

         Global.Print("Rotate pattern steps right");
         redraw();
      }
   }

   // <method.png>
   module method cursorStepMicroTimeTickIncDec(int _dir) {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         st.microTimeTickIncDec(_dir);
         editor.queueUpdateStepDetails();

         Global.Print("Step microtime is "+st.getMicroTimeString());
         redraw();
      }
   }

   // <method.png>
   module method moveCursorStepLeft() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         int newX = track.moveStepLeft(getClippedCursorX());
         if(-1 != newX)
         {
            Global.Print("Move step left");
            cursor_x = newX;
            editor.seq.uiSetCursorX(newX);
            editor.queueUpdateStepDetails();
            redraw();
         }
      }
   }

   // <method.png>
   module method moveCursorStepRight() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         int newX = track.moveStepRight(getClippedCursorX());
         if(-1 != newX)
         {
            Global.Print("Move step right");
            cursor_x = newX;
            editor.seq.uiSetCursorX(newX);
            editor.queueUpdateStepDetails();
            redraw();
         }
      }
   }

   // <method.png>
   module method moveCursorStepUp() {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         editor.undoBeginTimer();
         int newY = pat.moveStepUp(cursor_y, getClippedCursorX());
         if(-1 != newY)
         {
            Global.Print("Move step up");
            setCursorXYAndMakeVisible(getClippedCursorX(), newY);
            editor.pluginHandleCursorPosChanged();
            redraw();
         }
      }
   }

   // <method.png>
   module method moveCursorStepDown() {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         editor.undoBeginTimer();
         int newY = pat.moveStepDown(cursor_y, getClippedCursorX());
         if(-1 != newY)
         {
            Global.Print("Move step down");
            setCursorXYAndMakeVisible(getClippedCursorX(), newY);
            editor.pluginHandleCursorPosChanged();
            redraw();
         }
      }
   }

   // <method.png>
   module method insertCursorStep() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.insertStep(getClippedCursorX());
         editor.queueUpdateStepDetails();

         Global.Print("Insert step");
         redraw();
      }
   }

   // <method.png>
   module method deleteCursorStep() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.deleteStep(getClippedCursorX());
         editor.queueUpdateStepDetails();

         Global.Print("Delete step");
         redraw();
      }
   }

   // <method.png>
   module method incTrackLen() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();

         int pl = track.play_length;

         if(pl < 64)
         {
            pl++;
            NTS_Pattern pat <= editor.getEditPattern();
            track.setPlayLength(pl, pat);

            float patTicks = (editor.seq.nodeGetPatternNumTicks(pat.pat_nr));
            float num16th = (patTicks / current_song.getNumTicksPer16th());
            float numBeats = (patTicks / current_song.getNumTicksPerBeat());
            float numBars = (patTicks / current_song.getNumTicksPerBar());
            Global.Print("Inc track len ("+track.play_length+") (patlen="+num16th+" 16th, "+numBeats+" beat"+Utils.GetPluralString(numBeats)+", "+numBars+" bar"+Utils.GetPluralString(numBars)+")");
            editor.queueUpdateStepDetails();
            redraw();
         }
      }
   }

   // <method.png>
   module method decTrackLen() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();

         int pl = track.play_length;

         if(pl > 1)
         {
            pl--;
            NTS_Pattern pat <= editor.getEditPattern();
            track.setPlayLength(pl, pat);

            float patTicks = (editor.seq.nodeGetPatternNumTicks(pat.pat_nr));
            float num16th = (patTicks / current_song.getNumTicksPer16th());
            float numBeats = (patTicks / current_song.getNumTicksPerBeat());
            float numBars = (patTicks / current_song.getNumTicksPerBar());
            Global.Print("Dec track len ("+track.play_length+") (patlen="+num16th+" 16th, "+numBeats+" beat"+Utils.GetPluralString(numBeats)+", "+numBars+" bar"+Utils.GetPluralString(numBars)+")");
            editor.queueUpdateStepDetails();
            redraw();
         }
      }
   }

   // <method.png>
   module method incTrackDefaultNoteDurationTicks(int _delta) {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();

         int dur = track.default_note_duration_ticks + _delta;
         if(dur < 1)
            dur = 1;

         track.setDefaultNoteDurationTicks(dur);

         Global.Print("Track default note duration is "+dur+" tick"+Utils.GetPluralString(dur));
         redraw();
      }
   }

   // <method.png>
   module method toggleTrackSolo() {
      editor.toggleSoloState(cursor_y);
   }

   // <method.png>
   module method toggleTrackMute() {
      editor.toggleMuteState(cursor_y);
   }

   // <method.png>
   module method insertPatternStep() {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         editor.undoBeginTimer();
         pat.insertPatternStep(getClippedCursorX());

         Global.Print("Insert step (all tracks)");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method deletePatternStep() {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         editor.undoBeginTimer();
         pat.deletePatternStep(getClippedCursorX());

         Global.Print("Delete step (all tracks)");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method incDecCursorStepArg2(int _dir) {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         st.incDecArg2(_dir);

         Global.Print("Arg 2 ("+st.getArg2Label()+") is "+st.arg2+" ("+st.getArg2String(false/*bShort*/)+")");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method reverseTrackSteps() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.reverseSteps();

         Global.Print("Reverse steps");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method reversePatternSteps() {
      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         editor.undoBeginTimer();
         pat.reversePatternSteps();

         Global.Print("Reverse pattern steps");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method randomizeTrackArg1() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.randomizeArg1();

         Global.Print("Randomize arg1");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method randomizeTrackMod1() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.randomizeMod1();

         Global.Print("Randomize mod1");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method randomizeTrackMod2() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.randomizeMod2();

         Global.Print("Randomize mod2");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method initTrackArg2(float _val) {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.initArg2(_val);

         Global.Print("Init arg2 val="+_val);
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method loadTrackArg2Identity() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.loadArg2Identity();

         Global.Print("Load arg2 identity");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method initTrackMod1(float _val) {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.initMod1(_val);

         Global.Print("Init mod1 val="+_val);
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method initTrackMod2(float _val) {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.initMod2(_val);

         Global.Print("Init mod2 val="+_val);
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method randomizeTrackTrigs() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.randomizeTrigs();

         Global.Print("Randomize trigs");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   module method randomizeTrackRepeats() {
      NTS_Track track <= getCursorTrack();
      if(null != track)
      {
         editor.undoBeginTimer();
         track.randomizeRepeats();

         Global.Print("Randomize repeats");
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <method.png>
   public method toggleCursorStepRepeat() {
      NTS_Step st <= getCursorStep();
      if(null != st)
      {
         editor.undoBeginTimer();
         if(!st.b_repeat)
         {
            if(!st.b_mod)
            {
               st.setEnableRepeat(true);
               st.setEnableMod(false);
            }
            else
            {
               st.setEnableRepeat(false);
               st.setEnableMod(false);
            }
         }
         else
         {
            if(!st.b_mod)
            {
               st.setEnableRepeat(false);
               st.setEnableMod(true);
            }
            else
            {
               st.setEnableRepeat(false);
               st.setEnableMod(false);
            }
         }
         editor.queueUpdateStepDetails();
         redraw();
      }
   }

   // <ui_handle.png>
   module =replay= method handleTrackCut() {

      NTS_Track track <= getCursorTrack();

      if(null != track)
      {
         editor.undoBeginTimer();

         track_clipboard.copyFrom(track);
         track.clearAll(false/*bMod*/);

         editor.handlePatternChanged(false/*bFromUI*/);

         Global.Print("Track cut to clipboard.");
         editor.queueUpdateStepDetails();
      }
   }

   // <ui_handle.png>
   module method handleTrackCopy() {

      NTS_Track track <= getCursorTrack();

      if(null != track)
      {
         track_clipboard.copyFrom(track);

         editor.handlePatternChanged(false/*bFromUI*/);

         Global.Print("Track copied to clipboard.");
      }
   }

   // <ui_handle.png>
   module method handleTrackPaste() {

      NTS_Track track <= getCursorTrack();

      if(null != track)
      {
         editor.undoBeginTimer();

         int origTrackNr = track.track_nr;
         NodeTrigSeq origParentNode <= track.parent_node;
         track.copyFrom(track_clipboard);
         track.track_nr = origTrackNr;
         track.parent_node <= origParentNode;

         editor.handlePatternChanged(false/*bFromUI*/);

         editor.replayAlignNewPattern(editor.getEditPattern());

         Global.Print("Clipboard pasted to Track.");
         editor.queueUpdateStepDetails();
      }
   }

   // <ui_handle.png>
   module method handleTrackPasteAll1() {

      dlg_track_pasteall <= new NTS_PasteAllDialog();
      dlg_track_pasteall.run(this);
   }

   // <ui_handle.png>
   public =replay= method handleTrackPasteAll2() {

      // (note) undoBeginBuffer() is called by NTS_PasteAllDialog() (while replay mutex is not locked, yet)

      editor.undoBeginBuffer();
      handleTrackPasteAll3();

      editor.handlePatternChanged(false/*bFromUI*/);

      Global.Print("Paste clipboard to all patterns");
      editor.queueUpdateStepDetails();
   }

   // <ui_handle.png>
   protected =replay= method handleTrackPasteAll3() {

      NTS_Pattern *pat;

      foreach pat in (editor.seq.patterns)
      {
         if(null != pat)
         {
            NTS_Track track <= pat.getTrackByIndex(cursor_y);

            if(null != track)
            {
               int origTrackNr = track.track_nr;
               NodeTrigSeq origParentNode <= track.parent_node;
               track.copyFrom(track_clipboard);
               track.track_nr = origTrackNr;
               track.parent_node <= origParentNode;

               pat.patReset(true/*bSoft*/);
               pat.patHandleSongSpeedChanged(true/*bPPQ*/, true/*bBPM*/);
            }
         }
      }

      ////editor.replayAlignNewPattern(editor.getEditPattern());
      editor.seq.nodeSeek(editor.seq.tick_nr);
   }

   // <method.png>
   protected method paintArg1(int _gridxA, int _gridxB, float _arg1B) {
      int t;

      // trace "xxx paintArg1: gridxA="+_gridxA+" gridxB="+_gridxB+" arg1B="+_arg1B;

      NTS_Track track <= getLockedMouseTrack();

      if(null != track)
      {
         NTS_Step *st;

         if(_gridxA == _gridxB)
         {
            st <= track.getStepByIndex(_gridxB);
            if(null != st)
            {
               st.setArg1(_arg1B);
               editor.queueUpdateStepDetails();
               return;
            }
         }

         // float cval;
         // float sval;
         int idx;
         int num;

         float _arg1A;

         st <= track.getStepByIndex(_gridxA);
         if(null == st)
         {
            return;
         }
         _arg1A = st.arg1;

         if(_gridxA > _gridxB)
         {
            idx = _gridxB;
            num = (_gridxA - _gridxB) + 1;
            // sval = (_arg1A - _arg1B) / float(num);
            // cval = _arg1B;
         }
         else
         {
            idx = _gridxA;
            num = (_gridxB - _gridxA) + 1;
            // sval = (_arg1B - _arg1A) / float(num);
            // cval = _arg1A;
         }

         loop(num)
         {
            st <= track.getStepByIndex(idx);

            if(null != st)
            {
               // trace "xxx cval="+cval+" idx="+idx;
               // st.setArg1(cval);
               st.setArg1(_arg1A);
            }

            // cval += sval;
            idx++;
         }
      }

      editor.queueUpdateStepDetails();
   }

   // <method.png>
   protected method paintMod(int _gridxA, int _gridxB, float _modB, boolean _bMod2) {
      int t;

      // trace "xxx paintMod: gridxA="+_gridxA+" gridxB="+_gridxB+" arg1B="+_arg1B;

      NTS_Track track <= getLockedMouseTrack();

      if(null != track)
      {
         NTS_Step *st;

         if(_gridxA == _gridxB)
         {
            st <= track.getStepByIndex(_gridxB);
            if(null != st)
            {
               if(_bMod2)
               {
                  st.setMod2(_modB);
                  track.queueMod2(_modB / 127.0);

                  if(_modB >= 0)
                     Global.Print("Mod 2 is "+_modB+" ("+(mathLerpf(track.mod2_min, track.mod2_max, _modB/127.0f)+" after range scaling)"));
                  else
                     Global.Print("Mod 2 is <not set>");
               }
               else
               {
                  st.setMod1(_modB);
                  track.queueMod1(_modB / 127.0);
                  if(_modB >= 0)
                     Global.Print("Mod 1 is "+_modB+" ("+(mathLerpf(track.mod1_min, track.mod1_max, _modB/127.0f)+" after range scaling)"));
                  else
                     Global.Print("Mod 1 is <not set>");
               }
               editor.queueUpdateStepDetails();
               return;
            }
         }

         int idx;
         int num;

         float modA;

         st <= track.getStepByIndex(_gridxA);
         if(null == st)
         {
            return;
         }
         modA = _bMod2 ? st.mod2 : st.mod1;

         if(_gridxA > _gridxB)
         {
            idx = _gridxB;
            num = (_gridxA - _gridxB) + 1;
         }
         else
         {
            idx = _gridxA;
            num = (_gridxB - _gridxA) + 1;
         }

         loop(num)
         {
            st <= track.getStepByIndex(idx);

            if(null != st)
            {
               if(_bMod2)
               {
                  st.setMod2(modA);
                  track.queueMod2(modA / 127.0);

                  if(modA >= 0)
                     Global.Print("Mod 2 is "+modA+" ("+(mathLerpf(track.mod2_min, track.mod2_max, modA/127.0f)+" after range scaling)"));
                  else
                     Global.Print("Mod 2 is <not set>");
               }
               else
               {
                  st.setMod1(modA);
                  track.queueMod1(modA / 127.0);

                  if(modA >= 0)
                     Global.Print("Mod 1 is "+modA+" ("+(mathLerpf(track.mod1_min, track.mod1_max, modA/127.0f)+" after range scaling)"));
                  else
                     Global.Print("Mod 1 is <not set>");
               }
            }

            // cval += sval;
            idx++;
         }
      }

      editor.queueUpdateStepDetails();
   }

   // <method.png>
   protected method paintStepTrig(int _gridxA, int _gridxB, boolean _bTrig) {
      int t;

      // trace "xxx paintStepTrig: gridxA="+_gridxA+" gridxB="+_gridxB+" bTrig="+_bTrig;

      NTS_Track track <= getLockedMouseTrack();

      if(null != track)
      {
         NTS_Step *st;

         if(_gridxA == _gridxB)
         {
            st <= track.getStepByIndex(_gridxB);
            if(null != st)
            {
               st.setEnableTrig(_bTrig);
               return;
            }
         }

         int idx;
         int num;

         if(_gridxA > _gridxB)
         {
            idx = _gridxB;
            num = (_gridxA - _gridxB) + 1;
         }
         else
         {
            idx = _gridxA;
            num = (_gridxB - _gridxA) + 1;
         }

         loop(num)
         {
            st <= track.getStepByIndex(idx);

            if(null != st)
            {
               st.setEnableTrig(_bTrig);
            }

            idx++;
         }

         editor.queueUpdateStepDetails();
      }
   }

   // <ui_timer.png>
   public method handleReplayTimer() {

      if(UI.b_fbo)
      {
         if(replay.b_playing)
            UI.CompositeAll();
      }
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {
      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          1         :   Select pipenode A (use lctrl-x z to switch between A and B)
          2         :   Select pipenode B
          c         :   Begin output capture (stops when replay is stopped)
          d         :   Toggle pattern manager
          g         :   Guess note-name profile from output port(s)
          k or l    :   Toggle KeyJazz lock
          m         :   Remap tracks to selected note-name profile
          t         :   Try revert to global output (remove individual track outputs)
          u         :   Focus node name widget
          v         :   Paste output capture buffer
          z         :   Switch between pipenodes A/B (note: 'y' on german kbd)
          F3        :   Free pattern
 LEFT/RIGHT UP/DOWN :   Inc/Dec arg2 value fine/coarse (repeats)
          RSHIFT    :   Cycle through recording modes
          RCTRL     :   Toggle recording pre-count
          BACKSPACE :   Toggle ignore-seek-prgchg-mute (per-node setting)
          TAB       :   Focus \"Play\" tab
"
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   protected virtual wantTriadKeyRepeat(Key _k) : boolean {
      switch(_k.code)
      {
         case VKEY_LEFT:
         case VKEY_RIGHT:
         case VKEY_UP:
         case VKEY_DOWN:
         case VKEY_PAGEUP:
         case VKEY_PAGEDOWN:
            return true;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      int key = _k.pressed;

      // US (reference) keyboard layout (raw keycodes)
      switch(key)
      {
         case VKEY_TAB:
            TabSwitch ts <= editor.ts_groups;
            ts.setActiveTabIndex(NodeTrigSeqEditor.TAB_PLAY);
            editor.handleViewEnter();
            return true;

         case VKEY_UP:
            incDecCursorStepArg2(4);
            return true;

         case VKEY_DOWN:
            incDecCursorStepArg2(-4);
            return true;

         case VKEY_LEFT:
            incDecCursorStepArg2(-1);
            return true;

         case VKEY_RIGHT:
            incDecCursorStepArg2(1);
            return true;

         case VKEY_F3:
            editor.handlePatternFree();
            return true;

         case VKEY_RSHIFT:
            editor.cycleRecordMode();
            return true;

         case VKEY_RCTRL:
            editor.togglePreCount();
            return true;

         case VKEY_BACKSPACE:
            editor.toggleIgnoreSeekPrgChgMute();
            return true;

         case 'c':
            editor.beginOutputCapture();
            return true;

         case 'v':
            editor.pasteOutputCapture();
            return true;

         case 'g':
            editor.guessNoteNameProfileId();
            return true;

         case 'k':
         case 'l':
            PagePipeMap pgPipeMap <= root_form.pg_pipemap;
            pgPipeMap.toggleKeyJazzLock(true/*bAlwaysVerbose*/);
            return true;

         case 'm':
            editor.remapTracksToNoteNameProfile();
            return true;

         case 't':
            editor.tryRevertToGlobalOutput(false/*bQuiet*/);
            return true;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual wantKeyRepeat(Key _k) : boolean {
      if(_k.code == 'w')
         return false;
      if(VKEY_LCTRL == _k.code)
         return false;
      return Control::wantKeyRepeat(_k);
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {

      // trace "xxx grid k.pressed="+_k.pressed;
      // trace "xxx _k.mod="+_k.mod+" pressed="+_k.pressed+" released="+_k.released;

      NodeTrigSeq seq <= editor.seq;

      if(_k.modNone())
      {
         switch(_k.pressed)
         {
            case VKEY_UP:
               cursorUp();
               showCursorStepInfo();
               return true;

            case VKEY_DOWN:
               cursorDown();
               showCursorStepInfo();
               return true;

            case VKEY_LEFT:
               cursorLeft();
               showCursorStepInfo();
               return true;

            case VKEY_RIGHT:
               cursorRight();
               showCursorStepInfo();
               return true;

            case VKEY_PAGEUP:
               cursorPageUp();
               showCursorStepInfo();
               return true;

            case VKEY_PAGEDOWN:
               cursorPageDown();
               showCursorStepInfo();
               return true;

            case VKEY_SPACE:
               toggleCursorStepTrig();
               return true;

            case VKEY_RETURN:
               if(seq.b_recording && replay.b_playing)
                  editor.queueUndoAndRecRestart();
               else
                  playCursorStep();
               return true;

            case 'j':
               randomizeTrackTrigs();
               return true;

            case 'x':
               cutCursorStep();
               return true;

            case 'c':
               copyCursorStep();
               return true;

            case 'v':
               pasteCursorStep();
               return true;

            case 'o':
               rotateTrackStepsLeft();
               return true;

            case 'p':
               rotateTrackStepsRight();
               return true;

            case 'r':
               reverseTrackSteps();
               return true;

            case 't':
               editor.showTrackSetupDialog();
               return true;

            case 'u':
               editor.handleUndoRedo( !(seq.b_recording && replay.b_playing)/*bSaveRedo*/ );
               return true;

            case VKEY_INSERT:
               insertCursorStep();
               return true;

            case VKEY_DELETE:
               deleteCursorStep();
               return true;

            case 's':
               toggleTrackSolo();
               return true;

            case 'd':
               toggleTrackMute();
               return true;

            case '1':
               setCursorStepArg1(0);
               return true;

            case '2':
               setCursorStepArg1(1);
               return true;

            case '3':
               setCursorStepArg1(2);
               return true;

            case '4':
               setCursorStepArg1(3);
               return true;

            case '5':
               editor.handleCycleStepDetailsMode(-1/*dir*/, true/*bClip*/);
               return true;

            case '6':
               editor.handleCycleStepDetailsMode( 1/*dir*/, true/*bClip*/);
               return true;

            case 'w':
               queueTrackTrigger(true/*bOn*/);
               return true;

            case VKEY_RSHIFT:
               editor.startRecordingRSHIFT();
               return true;
         }
      }
      else if(VMOD_LSHIFT == _k.mod)
      {
         switch(_k.pressed)
         {
            case 'x':
               handleTrackCut();
               return true;

            case 'c':
               handleTrackCopy();
               return true;

            case 'v':
               handleTrackPaste();
               return true;

            case 'o':
               rotatePatternStepsLeft();
               return true;

            case 'p':
               rotatePatternStepsRight();
               return true;

            case 'j':
               randomizeTrackArg1();
               return true;

            case '1':
               randomizeTrackMod1();
               return true;

            case '2':
               randomizeTrackMod2();
               return true;

            case 'k':
               loadTrackArg2Identity();
               return true;

            case 'r':
               reversePatternSteps();
               return true;

            case VKEY_LEFT:
               cursorStepMicroTimeTickIncDec(-1);
               return true;

            case VKEY_RIGHT:
               cursorStepMicroTimeTickIncDec(1);
               return true;

            case VKEY_INSERT:
               insertPatternStep();
               return true;

            case VKEY_DELETE:
               deletePatternStep();
               return true;

            case 'w':
               queueTrackStep();
               return true;

            case VKEY_HOME:
               cursorToFirstTrack();
               return true;

            case VKEY_END:
               cursorToLastTrack();
               return true;

            case VKEY_PAGEUP:
               incTrackLen();
               editor.updateTrackForms();
               return true;

            case VKEY_PAGEDOWN:
               decTrackLen();
               editor.updateTrackForms();
               return true;
         }
      }
      else if(VMOD_LCTRL == _k.mod)
      {
         switch(_k.pressed)
         {
            case VKEY_SPACE:
               toggleCursorStepRepeat();
               return true;

            case 'j':
               randomizeTrackRepeats();
               return true;

            case 'q':
               editor.focusTrackQuantAmount(cursor_y);
               return true;

            case 'h':
               editor.focusTrackSwingAmount(cursor_y);
               return true;

            case 'a':
               editor.focusTrackArg3(cursor_y);
               return true;

            case 't':
               editor.focusTrackNoteLen(cursor_y);
               return true;

            case 'l':
               editor.focusTrackNumSteps(cursor_y);
               return true;

            case 'w':
               editor.handlePatternCut();
               return true;

            case 'c':
               editor.handlePatternCopy();
               return true;

            case 'v':
               editor.handlePatternPaste();
               return true;

            case VKEY_LEFT:
               moveCursorStepLeft();
               return true;

            case VKEY_RIGHT:
               moveCursorStepRight();
               return true;

            case VKEY_UP:
               moveCursorStepUp();
               return true;

            case VKEY_DOWN:
               moveCursorStepDown();
               return true;
         }
      }
      else if(VMOD_LALT == _k.mod)
      {
         switch(_k.pressed)
         {
            case VKEY_LEFT:
               incTrackDefaultNoteDurationTicks(-1);
               return true;

            case VKEY_RIGHT:
               incTrackDefaultNoteDurationTicks(1);
               return true;

            case 'c':
               if(UI.b_key_cmd_copy_paste)
               {
                  editor.handlePatternCopy();
                  return true;
               }
               break;

            case 'v':
               if(UI.b_key_cmd_copy_paste)
               {
                  editor.handlePatternPaste();
                  return true;
               }
               break;
         }
      }

      if(_k.modCtrl())
      {
         switch(_k.pressed)
         {
            case 'j':
               if(_k.modShift())
               {
                  // (note) unused, was randomize repeats
               }
               return true;

            case 'r':
               if(_k.modShift())
               {
                  editor.handlePatternClone(true/*bSub*/);
               }
               else
               {
                  editor.handlePatternClone(false/*bSub*/);
               }
               return true;

            case 'n':
               if(_k.modShift())
               {
                  editor.handlePatternAlloc(true/*bSub*/);
               }
               else
               {
                  editor.handlePatternAlloc(false/*bSub*/);
               }
               return true;

            case 'v':
               if(_k.modShift())
               {
                  handleTrackPasteAll1();
                  return true;
               }
               break;
         }
      }

      switch(_k.released)
      {
         case 'w':
            queueTrackTrigger(false);
            return true;
      }

      return Control::onKey(_k);
   }

   // <ui_mouse.png>
   public virtual isMouseFocusLocked() : boolean {
      return (lock_mouse_track_idx >= 0);
   }

   // <method_get.png>
   public static GetPaintType() : int {
      switch(UI.GetKeyMod())
      {
         case VMOD_LCTRL:
            return 1;

         case VMOD_LSHIFT:
            return 2;

         case VMOD_LALT:
            return 3;
      }
      return 0;
   }

   // <ui_mouse.png>
   public virtual onMouse(MouseEvent _ev) : boolean {

      Integer area;
      Integer modArea;
      Float normY;

      float mouseRelX = mathClampf(_ev.mouse_rel_x, 0, getSizeX());
      float mouseRelY = mathClampf(_ev.mouse_rel_y, 0, getSizeY());

      NTS_Step st <= getStepAtXY(mouseRelX, mouseRelY, area, modArea, normY);

      if(null != st)
      {
         int paintType;

         if(DRAG_NONE == drag_mode)
            paintType = GetPaintType();  // 1=arg1, 2=mod1, 3=mod2
         else
            paintType = 0;

         if(0 != paintType)
         {
            if(-1 == lock_mouse_track_idx)
            {
               lock_mouse_track_idx = st.grid_y;
               lock_mouse_last_grid_x = st.grid_x;
               // trace "xxx start lock_mouse_track_idx="+lock_mouse_track_idx;
            }
            else
            {
               float clipMinY = lock_mouse_track_idx * getCellSy();
               float clipMaxY = (lock_mouse_track_idx + 1) * getCellSy() - 1;
               float clipY = mathClampf(_ev.mouse_rel_y, clipMinY, clipMaxY);
               st <= getStepAtXY(mouseRelX, clipY, area, modArea, normY);
            }
         }
         else
         {
            // trace "xxx end lock_mouse_track_idx="+lock_mouse_track_idx;
            lock_mouse_track_idx = -1;
         }

         int newCursorX = st.grid_x;
         int newCursorY = st.grid_y;

         boolean bNewCursorY = (newCursorY != cursor_y);

         if(_ev.current_state & (MOUSE_LBUTTON | MOUSE_RBUTTON))
         {
            float arg1Val;

            if(@(UI.GetKeyboardFocus()) != @(this))
            {
               UI.SetKeyboardFocus(this);
               redraw();
               b_skip_mb_up = true;
               return true;
            }

            if( (newCursorX != cursor_x) || bNewCursorY)
            {
               setCursorXYAndMakeVisible(newCursorX, newCursorY);
               editor.pluginHandleCursorPosChanged();
               redraw();

               if(_ev.isLeftButtonDown() && _ev.isRightButtonDown())
               {
                  if(2 == paintType)
                     clearCursorStepMod(false/*bMod2*/);
                  else if(3 == paintType)
                     clearCursorStepMod(true/*bMod2*/);
                  else
                     clearCursorStep();
               }
               else if(_ev.isLeftButtonDown())
               {
                  b_skip_mb_up = true;
                  showCursorStepInfo();
                  return true;
               }
               else if(_ev.isRightButtonDown())
               {
                  if(lock_mouse_track_idx >= 0)
                  {
                     // trace "xxx normY="+normY+" vel="+((1.0 - normY) * 3.99);
                     if(2 == paintType)
                        clearCursorStepMod(false/*bMod2*/);
                     else if(3 == paintType)
                        clearCursorStepMod(true/*bMod2*/);
                     else
                     {
                        paintStepTrig(lock_mouse_last_grid_x, st.grid_x, !st.b_trig);
                        arg1Val = mathClampf(((1.0 - normY) * 3.99), 0.0f, 3.0f);
                        paintArg1(lock_mouse_last_grid_x, st.grid_x, arg1Val);
                        lock_mouse_last_grid_x = st.grid_x;
                     }
                     redraw();
                     return true;
                  }
                  else
                  {
                     toggleCursorStepTrig();
                  }
                  return true;
               }
            }
            else
            {
               if(_ev.isLeftButtonDown() && _ev.isRightButtonDown())
               {
                  if(2 == paintType)
                     clearCursorStepMod(false/*bMod2*/);
                  else if(3 == paintType)
                     clearCursorStepMod(true/*bMod2*/);
                  else if(lock_mouse_track_idx >= 0)
                  {
                     // trace "xxx clear";
                     paintStepTrig(lock_mouse_last_grid_x, st.grid_x, false);
                     lock_mouse_last_grid_x = st.grid_x;
                     redraw();
                     return true;
                  }
                  else
                  {
                     clearCursorStep();
                  }
               }
               else if(_ev.rightButtonDown())
               {
                  if(2 == paintType)
                     clearCursorStepMod(false/*bMod2*/);
                  else if(3 == paintType)
                     clearCursorStepMod(true/*bMod2*/);
                  else
                     toggleCursorStepTrig();
                  return true;
               }
            }

            return true;
         }
         else if(_ev.leftButtonUp())
         {
            if(b_skip_mb_up)
            {
               b_skip_mb_up = false;
            }
            else
            {
               if(!bNewCursorY)
               {
                  cycleCursorStepArg1AndEnableTrig();
               }
            }
            return true;
         }
         else if(_ev.middleButtonDown())
         {
            setCursorXYAndMakeVisible(newCursorX, newCursorY);
            editor.pluginHandleCursorPosChanged();
            toggleCursorStepRepeat();
            return true;
         }
         else if(_ev.rightButtonUp())
         {
            // e.g. after clearing modulation with RMB-click
         }
         else ////if(!_ev.isRightButtonDown())
         {
            if(lock_mouse_track_idx >= 0)
            {
               // trace "xxx normY="+normY+" vel="+((1.0 - normY) * 3.99);
               float modVal;
               if(1 == paintType)
               {
                  arg1Val = mathClampf(((1.0 - normY) * 3.99), 0.0f, 3.0f);
                  paintArg1(lock_mouse_last_grid_x, st.grid_x, arg1Val);
               }
               else if(2 == paintType)
               {
                  modVal = FloatParam.ApplyPrecision(normY * 127.0, 0);
                  paintMod(lock_mouse_last_grid_x, st.grid_x, modVal, false/*bMod2*/);
               }
               else if(3 == paintType)
               {
                  modVal = FloatParam.ApplyPrecision(normY * 127.0, 0);
                  paintMod(lock_mouse_last_grid_x, st.grid_x, modVal, true/*bMod2*/);
               }
               lock_mouse_last_grid_x = st.grid_x;
               redraw();
               return true;
            }
         }

         return !_ev.isWheel();
      } // if st

      return false;
   }

   // <ui_mouse.png>
   public virtual onMouseHold(MouseEvent _ev) : boolean {
      if(_ev.isRightButton())
      {
         editor.showContextMenu(false/*bFocusFirst*/);
         return true;
      }
      return false;
   }

   // <ui_mouse.png>
   public virtual blockMouseDrag(MouseEvent _ev) : boolean {
      return (_ev.isRightButtonDown());
   }

   // <ui_mouse.png>
   public virtual onMouseBeginDrag(MouseEvent _dragStart, MouseEvent _ev) : boolean {

      // trace "xxx try onMouseBeginDrag";
      if(!_ev.isLeftButtonDown())
         return false;

      Integer area;
      Integer modArea;
      Float normY;
      NTS_Step st <= getStepAtXY(_ev.mouse_rel_x, _ev.mouse_rel_y, area, modArea, normY);
      // trace "xxx onMouseBeginDrag: area="+area+" modArea="+modArea;

      if(null != st)
      {
         // trace "xxx onMouseBeginDrag: area="+area;

         drag_step <= null;
         drag_mode = DRAG_NONE;

         if(_ev.isLeftButtonDown())
         {
            if(null != st)
            {
               drag_start_x = _dragStart.mouse_rel_x;
               drag_start_y = _dragStart.mouse_rel_y;

               editor.undoBeginTimer();

               if(1 == modArea)
               {
                  drag_mode = DRAG_MOD1;
                  drag_step <= st;
                  drag_start_mod1 = mathClampf(st.mod1, -1.0, 127.0);
                  return true;
               }
               else if(2 == modArea)
               {
                  drag_mode = DRAG_MOD2;
                  drag_step <= st;
                  drag_start_mod2 = mathClampf(st.mod2, -1.0, 127.0);
                  return true;
               }
               else if(0 == area)
               {
                  // microtime
                  drag_mode = DRAG_MICROTIME;
                  drag_step <= st;
                  drag_start_microtime = st.microtime;
                  return true;
               }
               else if(1 == area)
               {
                  // step
                  drag_mode = DRAG_STEP;
                  drag_step <= st;
                  drag_start_cursor_x = cursor_x;
                  drag_start_cursor_y = cursor_y;
                  editor.undoBegin();
                  return true;
               }
               else
               {
                  // arg2
                  drag_mode = DRAG_ARG2;
                  drag_step <= st;
                  drag_start_arg2 = st.arg2;
                  return true;
               }

            }
         }
      } // if st

      return false;
   }

   // <ui_mouse.png>
   public virtual onMouseDrag(MouseEvent _lastEv, MouseEvent _currentEv) : boolean {
      float relX;
      float relY;

      NTS_Track track <= getCursorTrack();
      float fineScl = (VMOD_LSHIFT == UI.GetKeyMod()) ? 4.0 : 1.0;

      if(DRAG_MICROTIME == drag_mode)
      {
         NodeTrigSeq seq <= editor.seq;

         relX = (_currentEv.mouse_rel_x - drag_start_x) / (getCellSx() * (1 + 4*seq.ui_b_microtime_range_limit));

         drag_step.setMicroTime(drag_start_microtime + relX);

         Global.Print("Microtime is "+drag_step.getMicroTimeString());
         editor.queueUpdateStepDetails();

         redraw();
      }
      else if(DRAG_STEP == drag_mode)
      {
         Integer area;
         Integer modArea;
         Float normY;
         NTS_Step st <= getStepAtXY(_currentEv.mouse_rel_x, _currentEv.mouse_rel_y, area, modArea, normY);

         if(null != st)
         {
            if(@(st) != @(drag_step))
            {
               if(!st.b_trig)
               {
                  st.copyFrom(drag_step);
                  drag_step.b_trig = false;
                  drag_step <= st;
                  setCursorXYAndMakeVisible(st.grid_x, st.grid_y);
                  redraw();
               }
            }
         }
      }
      else if(DRAG_ARG2 == drag_mode)
      {
         relX = (_currentEv.mouse_rel_x - drag_start_x) / (2.0 * fineScl);

         float newArg2 = int(mathClampf(drag_start_arg2, 0.0f, 999999.0f) + relX);

         if(newArg2 < 0)
         {
            newArg2 = NodeTrigSeq.INVALID_VALUE;
         }

         drag_step.setArg2(newArg2);

         Global.Print("Arg2 ("+drag_step.getArg2Label()+") is "+drag_step.getArg2String(false/*bShort*/));
         ta_redraw.schedule();
         editor.queueUpdateStepDetails();
      }
      else if(DRAG_MOD1 == drag_mode)
      {
         relY = (drag_start_y - _currentEv.mouse_rel_y) / (1.0 * fineScl);

         float newMod1 = int(mathClampf(drag_start_mod1 + relY, -1.0f, 127.0f));

         if(newMod1 < 0)
         {
            newMod1 = NodeTrigSeq.INVALID_VALUE;
         }

         drag_step.setMod1(newMod1);
         track.queueMod1(newMod1 / 127.0);

         if(drag_step.mod1 >= 0)
            Global.Print("Mod 1 is "+drag_step.mod1+" ("+(mathLerpf(track.mod1_min, track.mod1_max, drag_step.mod1/127.0f)+" after range scaling)"));
         else
            Global.Print("Mod 1 is <not set>");

         ta_redraw.schedule();
         editor.queueUpdateStepDetails();
      }
      else if(DRAG_MOD2 == drag_mode)
      {
         relY = (drag_start_y - _currentEv.mouse_rel_y) / (1.0 * fineScl);

         float newMod2 = int(mathClampf(drag_start_mod2 + relY, -1.0f, 127.0f));

         if(newMod2 < 0)
         {
            newMod2 = NodeTrigSeq.INVALID_VALUE;
         }

         drag_step.setMod2(newMod2);
         track.queueMod2(newMod2 / 127.0);

         if(drag_step.mod2 >= 0)
            Global.Print("Mod 2 is "+drag_step.mod2+" ("+(mathLerpf(track.mod2_min, track.mod2_max, drag_step.mod2/127.0f)+" after range scaling)"));
         else
            Global.Print("Mod 2 is <not set>");

         ta_redraw.schedule();
         editor.queueUpdateStepDetails();
      }

      return true;
   }

   // <ui_mouse.png>
   public virtual onMouseCancelDrag(MouseEvent _ev) {
      NTS_Track track <= getCursorTrack();

      if(DRAG_MICROTIME == drag_mode)
      {
         drag_step.setMicroTime(drag_start_microtime);
      }
      else if(DRAG_STEP == drag_mode)
      {
         setCursorXYAndMakeVisible(drag_start_cursor_x, drag_start_cursor_y);
         editor.undoEnd();
         NodeTrigSeq seq <= editor.seq;
         editor.handleUndoRedo( !(seq.b_recording && replay.b_playing)/*bSaveRedo*/ );
      }
      else if(DRAG_ARG2 == drag_mode)
      {
         drag_step.setArg2(drag_start_arg2);
      }
      else if(DRAG_MOD1 == drag_mode)
      {
         drag_step.setMod1(drag_start_mod1);
         track.queueMod1(drag_start_mod1 / 127.0);
      }
      else if(DRAG_MOD2 == drag_mode)
      {
         drag_step.setMod2(drag_start_mod2);
         track.queueMod2(drag_start_mod2 / 127.0);
      }

      drag_step <= null;
      drag_mode = DRAG_NONE;
      editor.queueUpdateStepDetails();
      ta_redraw.schedule();
   }

   // <ui_mouse.png>
   public virtual onMouseEndDrag(MouseEvent _ev) {
      drag_step <= null;
      drag_mode = DRAG_NONE;
      editor.undoEnd();
   }

   // <ui_render.png>
   public method redrawPlugin() {
      if((null != editor) && (null != editor.editor_plugin))
         editor.editor_plugin.redraw();
   }

   // <ui_render.png>
   public virtual redraw() {
      Control::redraw();
      redrawPlugin();
   }

   // <ui_render.png>
   public method queueRedraw() {
      ta_redraw.schedule();
   }

   // <ui_render.png>
   public virtual onDraw() {

      if(null == font)
         font <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);

      if(null == font_stepnr)
         font_stepnr <= UI.GetFontByName("big7");

      float sx = getSizeX();
      float sy = getSizeY();

      int c32EmptyBg        = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_EMPTY_BG);
      int c32EmptyBgNoTrigs = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_EMPTY_BG_NOTRIGS);

      int numTicks16 = current_song.getNumTicksPer16th();

      NTS_Pattern pat <= editor.getEditPattern();

      if(null != pat)
      {
         NodeTrigSeq seq <= editor.seq;

         float cellSy = getCellSy();

         int maxSteps = pat.getMaxSteps();
         float cellSx = (STConfig.node_trig_seq_grid_steps_x>0)?cell_sx : sx / maxSteps;

         float cy = 0.0f;
         int trackIdx = 0;

         int cursorX = getClippedCursorX();

         boolean bHasFocus = hasKeyboardFocus();

         NTS_Track *track;
         foreach track in pat.tracks
         {
            int stepModulo = (numTicks16 * pat.step_modulo_16th) / track.current_step_num_ticks;
            int barModulo = (numTicks16 * pat.bar_modulo_16th) / track.current_step_num_ticks;
            float cx = 0.0f;

            int stepIdx = 0;

            boolean bHasTrigs = (track.getNumTrigs() > 0);

            if(bHasTrigs)
            {
               UIRenderer.DrawFilledRectangle(0, cy, sx, cellSy, c32EmptyBg);
            }
            else
            {
               UIRenderer.DrawFilledRectangle(0, cy, sx, cellSy, c32EmptyBgNoTrigs);
            }

            loop(track.play_length)
            {
               NTS_Step st <= track.getStepByIndex(stepIdx);

               int bgColor32;

               if(st.b_trig)
               {
                  switch(int(st.arg1))
                  {
                     default:
                     case 0:
                        bgColor32 = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE0);
                        break;

                     case 1:
                        bgColor32 = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE1);
                        break;

                     case 2:
                        bgColor32 = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE2);
                        break;

                     case 3:
                        bgColor32 = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE3);
                        break;
                  }
               }
               else
               {
                  if(0 == (stepIdx % stepModulo))
                  {
                     bgColor32 = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_INACTIVE_BEAT);
                  }
                  else if(bHasFocus)
                  {
                     bgColor32 = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_INACTIVE);
                  }
                  else
                  {
                     bgColor32 = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_INACTIVE_NOFOCUS);
                  }
               }

               // Draw background
               if(!bHasTrigs)
               {
                  bgColor32 = UI.TintColor32(bgColor32, app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_NOTRIGS_TINT));
               }

               UIRenderer.DrawFilledRectangle(cx, cy, cellSx, cellSy, bgColor32);

               // Draw step-nr string
               boolean bStepNrSet = st.b_trig && STConfig.b_node_trig_seq_draw_step_nr_set;
               boolean bStepNrClr = !st.b_trig && STConfig.b_node_trig_seq_draw_step_nr_cleared;

               // Draw mod1/2
               if(st.b_trig || st.b_repeat || st.b_mod)
               {
                  float modH;
                  if(st.mod1 >= 0)
                  {
                     modH = (cellSy - 4) * (st.mod1 / 127.0f);
                     UIRenderer.DrawFilledRectangle(cx+2, cy+2 + (cellSy - 4)-modH,
                                                    (cellSx-4)*0.5, modH,
                                                    UI.TintColor32(bgColor32, app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_MOD1_TINT))
                                                    );
                  }
                  if(st.mod2 >= 0)
                  {
                     modH = (cellSy - 4) * (st.mod2 / 127.0f);
                     UIRenderer.DrawFilledRectangle(cx+2 + (cellSx-4)*0.5, cy+2 + (cellSy - 4) - modH,
                                                    (cellSx-4)*0.5, modH,
                                                    UI.TintColor32(bgColor32, app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_MOD2_TINT))
                                                    );
                  }
               }

               if(bStepNrSet || bStepNrClr)
               {
                  int stepNrColor32 = UI.TintColor32(bgColor32,
                                                     st.b_trig
                                                     ? app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_NR_TEXT_SET_TINT)
                                                     : app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_NR_TEXT_CLR_TINT)
                                                     );
                  String stepNrString = String((stepIdx % barModulo)+STConfig.node_trig_seq_step_label_offset);
                  float stepNrW = font_stepnr.stringWidth(stepNrString);
                  float stepNrH = font_stepnr.stringHeight(stepNrString);

                  UIRenderer.DrawTextClipped(stepNrString, font_stepnr,
                                             stepNrColor32, stepNrColor32,
                                             cx + (cellSx - stepNrW)*0.5,
                                             cy + (cellSy - stepNrH)*0.5 - editor.b_folded,
                                             cx, cy,
                                             cx + cellSx, cy + cellSy
                                             );
               }


               if((trackIdx == cursor_y) && (stepIdx == cursorX))
               {
                  if(st.b_trig)
                  {
                     UIRenderer.DrawRectangle(cx, cy, cellSx, cellSy, 3,
                                              seq.b_recording
                                              ? app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_BORDER_FOCUS_REC_ACTIVE)
                                              : app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_BORDER_FOCUS_ACTIVE)
                                              );
                  }
                  else
                  {
                     UIRenderer.DrawRectangle(cx, cy, cellSx, cellSy, 2,
                                              seq.b_recording
                                              ? app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_BORDER_FOCUS_REC_INACTIVE)
                                              : app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_BORDER_FOCUS_INACTIVE)
                                              );
                  }
               }
               else
               {
                  if(st.b_trig)
                  {
                     UIRenderer.DrawRectangle(cx, cy, cellSx, cellSy, 2,
                                              app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_BORDER_DEFAULT_ACTIVE)
                                              );
                  }
                  else
                  {
                     UIRenderer.DrawRectangle(cx, cy, cellSx, cellSy, 1,
                                              app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_BORDER_DEFAULT_INACTIVE)
                                              );
                  }
               }

               if(st.b_trig)
               {
                  if(st.microtime != 0.0f)
                  {
                     float cMicroTime = st.microtime * (1.0f + 4*seq.ui_b_microtime_range_limit);
                     cMicroTime = mathClampf(cMicroTime, -1, 1);

                     int c32MicroTime =
                        seq.ui_b_microtime_range_limit
                        ? app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_MICROTIME_FINE)
                        : app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_CELL_MICROTIME)
                        ;

                     if(cMicroTime < 0)
                     {
                        UIRenderer.DrawFilledRectangle(cx+cellSx*0.5+cMicroTime*(cellSx-6)*0.5,
                                                       cy+3,
                                                       -cMicroTime*(cellSx-6)*0.5,
                                                       (cellSy*0.25),
                                                       c32MicroTime
                                                       );
                     }
                     else
                     {
                        UIRenderer.DrawFilledRectangle(cx+cellSx*0.5,
                                                       cy+3,
                                                       cMicroTime*(cellSx-6)*0.5,
                                                       (cellSy*0.25),
                                                       c32MicroTime
                                                       );
                     }

                  }

                  if(st.arg2 >= 0)
                  {
                     String arg2Str <= st.getArg2String(true/*bShort*/);
                     int arg2W = font.stringWidth(arg2Str);

                     int c32Arg2Text = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_ARG2_TEXT);
                     UIRenderer.DrawText(arg2Str, font,
                                         c32Arg2Text, c32Arg2Text,
                                         cx + cellSx*0.5 - arg2W*0.5,
                                         cy + cellSy-16*UI.font_scaling-2,
                                         0/*availW*/, 0/*align*/
                                         );

                  }

               }

               if(st.b_repeat)
               {
                  UIRenderer.DrawRectangle(cx+3,
                                           cy+3,
                                           cellSx-6,
                                           cellSy-6,
                                           2/*border*/,
                                           app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_REPEAT)
                                           );
               }
               else if(st.b_mod)
               {
                  UIRenderer.DrawStippledRectangle(cx+3,
                                                   cy+3,
                                                   cellSx-6,
                                                   cellSy-6,
                                                   2/*border*/,
                                                   app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_STEP_REPEAT)
                                                   );
               }

               // Next cell
               cx += cellSx;
               stepIdx++;
            }

            // Next track
            cy += cellSy;
            trackIdx++;
         }

         if(b_make_cursor_visible_pending)
         {
            b_make_cursor_visible_pending = false;
            setCursorXYAndMakeVisible(seq.ui_cursor_x, seq.ui_cursor_y);
            editor.pluginHandleCursorPosChanged();
         }
      }
      else
      {
         // No pattern
         UIRenderer.DrawFilledRectangle(0, 0, sx, sy, c32EmptyBg);
      }

   }

   // <ui_render.png>
   public virtual onDrawOverlays() {
      // called when FBO compositing is enabled (UI.b_fbo)

      // trace "xxx NTS_TrigSeqEditor: minSize="+getMinimumSizeString();
      // trace "xxx    editor.sp_tracks.size="+(editor.sp_tracks.getSizeString())+" minSize="+(editor.sp_tracks.getMinimumSizeString());
      // trace "xxx    editor.ts_groups.size="+(editor.ts_groups.getSizeString())+" minSize="+(editor.ts_groups.getMinimumSizeString());

      if(replay.b_playing)
      {
         float sx = getSizeX();
         float sy = getSizeY();

         NTS_Pattern pat <= editor.getEditPattern();

         if(null != pat)
         {
            float cellSy = getCellSy();
            int maxSteps = pat.getMaxSteps();
            float cellSx = (STConfig.node_trig_seq_grid_steps_x>0)?cell_sx : sx / maxSteps;

            float cy = 0.0f;
            int trackIdx = 0;

            int cursorX = getClippedCursorX();

            NodeTrigSeq seq <= editor.seq;

            int c32Step = app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_REPLAY_CURSOR_BG);
            int c32StepOutline =
               seq.b_recording
               ? app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_REPLAY_CURSOR_OL_REC)
               : app_lnf.getColor(AppLookAndFeel.COLOR_TRIGSEQ_REPLAY_CURSOR_OL_DEF)
               ;

            UIRenderer.EnableBlending();

            NTS_Track *track;

            foreach track in pat.tracks
            {
               int lastStep = track.getLastPlayedStep();

               if(-1 != lastStep)
               {
                  float cx = lastStep * cellSx;
                  UIRenderer.DrawFilledRectangle(cx, cy, cellSx, cellSy, c32Step);
                  UIRenderer.DrawRectangle(cx, cy, cellSx, cellSy,
                                           app_lnf.trig_seq_replay_cursor_ol_width,
                                           c32StepOutline
                                           );
               }

               // Next track
               trackIdx++;
               cy += cellSy;
            }

            UIRenderer.DisableBlending();

         } // if pat

      } // if playing

   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      if(TA_REDRAW == acName)
      {
         redraw();
         return true;
      }

      if(TA_CHECKREDRAW == acName)
      {
         NodeTrigSeq seq <= editor.seq;

         if(null != seq)
         {
            if(seq.getQueuedRedrawAndReset())
            {
               // E.g. after note(s) were recorded
               redraw();
            }
         }
         ta_checkredraw.reschedule();
      }

      return false;
   }
}


// <class.png>
class NodeTrigSeqEditor extends NodeEditor, MIDIMapEventListener, ActionProvider, MIDIMapDefs {

   define String MMT_UNDO;
   define String MMT_TOGGLE_RECORD;
   define String MMT_UNDO_AND_RESTART_RECORDING;
   define String MMT_FORCE_STEP_RECORD;
   define String MMT_CLEAR_TRACK;
   define String MMT_CLEAR_TRACK_TRIGS;
   define String MMT_CLEAR_TRACK_MICROTIME;
   define String MMT_CLEAR_TRACK_ARGS;
   define String MMT_CLEAR_TRACK_MODS;
   define String MMT_CLEAR_TRACK_MODS_INIT;
   define String MMT_CLEAR_ALL_TRACKS;
   define String MMT_CLEAR_ALL_TRACKS_KEEP_TIMING;
   define String MMT_PATTERN_CLONE;
   define String MMT_PATTERN_CLONE_SUB;
   define String MMT_PATTERN_COPY;
   define String MMT_PATTERN_PASTE;

   define String TA_REPLAY;
   protected TimerAction *ta_replay;

   define String TA_UNDO;
   protected TimerAction *ta_undo;

   define String TA_STEPDETAILS_RELAYOUT;
   protected TimerAction *ta_stepdetails_relayout;

   define String TA_STEPDETAILS_UPDATE;
   protected TimerAction *ta_stepdetails_update;

   define int TAB_PATTERN  = 0;
   define int TAB_GRID     = 1;
   define int TAB_PLAY     = 2;

   public NodeTrigSeq *seq;

   protected Panel     *pn_groups;
   module TabSwitch *ts_groups;
   protected TextField *tf_pattern_name2;

   // Pattern:
   protected ComboBox   *cm_pattern_nr;
   protected Label      *lb_pattern_nr;
   protected TextField  *tf_pattern_name;
   protected FloatParam *fp_pattern_masterlen16th;

   protected ComboBox   *cm_notenames;
   protected Button     *bt_notenames_rescan;
   protected Button     *bt_notenames_guess;

   protected Panel      *pn_arg3_offset;
   protected Label      *lb_arg3_offset;
   protected FloatParam *fp_arg3_offset;
   protected FloatParam *fp_pb_up;
   protected FloatParam *fp_pb_down;

   protected FloatParam *fp_note_dur_offset;
   protected FloatParam *fp_swing_offset;

   protected FloatParam *fp_velocity_jitter_offset;
   protected FloatParam *fp_microtime_jitter_offset;

   protected FloatParam *fp_mod1_jitter_offset;
   protected FloatParam *fp_mod2_jitter_offset;

   protected FloatParam *fp_quant_offset;
   protected FloatParam *fp_step_highlight_modulo;
   protected FloatParam *fp_bar_modulo;

   protected Button    *bt_pattern_alloc;
   protected Button    *bt_pattern_tools;
   protected PopupMenu *pm_pattern_tools;
   protected Button    *bt_pattern_free;


   // Grid:
   ScrollPane *sp_tracks;
   NTS_Grid *grid;
   NTS_TrackForm *[] track_forms;  // NTS_TrackForm instances

   // Grid.Step Details:
   protected Button      *bt_stepdetails_mode;
   protected LayerSwitch *ls_stepdetails;
   protected Panel       *pn_stepdetails;
   protected Panel       *pn_stepdetails_outer;
   protected Panel       *pn_stepdetails_spacer;
   protected CheckBox    *cb_stepdetails_trig;
   protected CheckBox    *cb_stepdetails_repeat;
   protected Label       *lb_stepdetails_arg1;
   protected ComboBox    *cm_stepdetails_arg1;
   protected Label       *lb_stepdetails_arg2;
   protected FloatParam  *fp_stepdetails_arg2;
   protected FloatParam  *fp_stepdetails_microtime;
   protected FloatParam  *fp_stepdetails_mod1;
   protected FloatParam  *fp_stepdetails_mod2;

   protected Panel *pn_stepdetails_arg2;
   protected Panel *pn_stepdetails_mod1;
   protected Panel *pn_stepdetails_mod2;
   protected LayerSwitch *[] stepdetails_arg2_layerswitches;
   protected FloatParam  *[] stepdetails_arg2_floatparams;
   protected LayerSwitch *[] stepdetails_mod1_layerswitches;
   protected FloatParam  *[] stepdetails_mod1_floatparams;
   protected LayerSwitch *[] stepdetails_mod2_layerswitches;
   protected FloatParam  *[] stepdetails_mod2_floatparams;


   // Play:
   protected ComboBox *cm_node_class;
   protected CheckBox *cb_node_class_show;
   // (note) cm_node_class_show_in is declared in NodeEditor base class

   protected ComboBox *cm_play_out_dev;
   protected ComboBox *cm_play_out_ch;

   protected ComboBox   *cm_play_out_mode;
   protected CheckBox   *cb_play_extclk;
   protected FloatParam *fp_speed_scl_reset;
   protected Button     *bt_speed_restart;

   protected ComboBox *cm_play_repeat_start_mode;
   protected ComboBox *cm_play_repeat_start_quantization;
   protected ComboBox *cm_play_repeat_len;
   protected ComboBox *cm_play_num_repeats;

   protected ComboBox *cm_play_rec_dev;
   protected ComboBox *cm_play_rec_ch;
   protected CheckBox *cb_play_rec_enable;
   protected CheckBox *cb_play_rec_prev;
   protected CheckBox *cb_play_rec_quantize;
   protected CheckBox *cb_play_rec_mute_repeat;

   protected ComboBox *cm_play_rec_unmap;
   protected CheckBox *cb_play_rec_mod_unmap;

   protected ComboBox *cm_play_plugin_dev;
   protected ComboBox *cm_play_plugin_scene;

   protected CheckBox *cb_play_followarr;

   protected CheckBox *cb_play_stepoff;


   Dialog_DeletePattern        *dlg_deletepattern;
   NTS_TrackSetupDialog *dlg_track_setup;
   NTS_EuclidDialog            *dlg_euclid;
   NTS_ImportARDialog          *dlg_import_ar;
   NTS_ImportMonDialog         *dlg_import_mon;

   module boolean b_folded;  // true=hide swing/notelen/numsteps

   protected PopupMenu *pm_ctx;

   protected int rctrl_pressed_ms;

   protected IntArray plugin_dev_options;  // (unsorted) device indices

   NTS_EditorPlugin *editor_plugin;

   protected int restore_plugin_scene_group_idx;
   protected int restore_plugin_scene_idx;

   // -127..0..+127
   //  updated when pattern arg3 offset changes
   StringArray arg3_note_names;
   protected static float last_pat_arg3_offset;


   // <init.png>
   public virtual init() : boolean {

      local String xfmSrc;
      if(xfmSrc.load("NodeTrigSeqEditor.xfm", true))
      {
         local String trackSrcAll;
         local String trackSrc;
         if(trackSrc.load("NTS_TrackTemplate.xfm", true))
         {
            int trackIdx = 0;
            loop(NTS_Pattern.NUM_TRACKS)
            {
               String src = trackSrc;
               src.replace("$NR", String(trackIdx));
               trackSrcAll.append(src);
               trackIdx++;
            }

            xfmSrc.replace("$(TRACK_WIDGETS)", trackSrcAll);

            local String stepdetailsArg2Templ =
               "<LayerSwitch id=ls_stepdetails_arg2_$(IDX) dir=RIGHT calcsizeonlycurrent=1 autoresolve=0 padding=0;0;0;0 reqSizeYScaled=21> \n"
               "  <!-- 0: invisible -->\n"
               "  <Panel minSize=0;0 reqSize=0;0 collapse=1><Panel minSize=0;0  collapse=1 reqSize=0;0 /></Panel> \n"
               "  <!-- 1: step --> \n"
               "<FloatParam id=fp_stepdetails_arg2_$(IDX) \n"
               "            dir=LEFT padding=0;0;0;0 \n"
               "            value=0 min=-1 nominalMin=0 nominalMax=127 max=127 minLimit=-1 maxLimit=16383.0 rangeMinEditable=0 rangeMaxEditable=1 \n"
               "            step=1 \n"
               "            precision=3 \n"
               "            mousePrecision=0 \n"
               "            textAlign=RIGHT \n"
               "            align=baseline \n"
               "            cols=4 \n"
               "            toolTipCaption=\"Step Arg 2\n\n (note) lctrl-x UP/DOWN decrements/increments in coarse steps\n (note) lctrl-x LEFT/RIGHT decrements/increments in fine steps\n (note) LMB-drag in lower step area\" \n"
               "            autoresolve=0 \n"
               "            reqSizeScaled=16;21 \n"
               "            negativeText=\"-\" \n"
               "            style=flat \n"
               "            /> \n"
               "</LayerSwitch> \n"
               ;

            local String stepdetailsMod1Templ =
               "<LayerSwitch id=ls_stepdetails_mod1_$(IDX) dir=RIGHT calcsizeonlycurrent=1 autoresolve=0 padding=0;0;0;0 reqSizeYScaled=21> \n"
               "  <!-- 0: invisible -->\n"
               "  <Panel minSize=0;0 reqSize=0;0 collapse=1><Panel minSize=0;0 collapse=1 reqSize=0;0 /></Panel> \n"
               "  <!-- 1: step --> \n"
               "<FloatParam id=fp_stepdetails_mod1_$(IDX) \n"
               "            dir=LEFT padding=0;0;0;0\n"
               //"            value=0 min=-1 nominalMin=0 nominalMax=127 max=127 maxLimit=16383 rangeMinEditable=0 rangeMaxEditable=1 \n"
               "            value=0 min=-1 max=127 rangeEditable=0 \n"
               "            step=1 \n"
               "            precision=3 \n"
               "            mousePrecision=1 \n"
               "            textAlign=RIGHT \n"
               "            align=baseline \n"
               "            cols=4 \n"
               "            toolTipCaption=\"Step Mod 1\" \n"
               "            autoresolve=0 \n"
               "            reqSizeXScaled=16 \n"
               "            negativeText=\"-\" \n"
               "            style=flat \n"
               "            /> \n"
               "</LayerSwitch> \n"
               ;

            local String stepdetailsMod2Templ =
               "<LayerSwitch id=ls_stepdetails_mod2_$(IDX) dir=RIGHT calcsizeonlycurrent=1 autoresolve=0 padding=0;0;0;0 reqSizeYScaled=21> \n"
               "  <!-- 0: invisible -->\n"
               "  <Panel minSize=0;0 reqSize=0;0 collapse=1><Panel minSize=0;0 reqSize=0;0 collapse=1 /></Panel> \n"
               "  <!-- 1: step --> \n"
               "<FloatParam id=fp_stepdetails_mod2_$(IDX) \n"
               "            dir=LEFT padding=0;0;0;0 \n"
               // "            value=0 min=-1 nominalMin=0 nominalMax=127 max=127 maxLimit=16383 rangeMinEditable=0 rangeMaxEditable=1 \n"
               "            value=0 min=-1 max=127 rangeEditable=0 \n"
               "            step=1 \n"
               "            precision=3 \n"
               "            mousePrecision=1 \n"
               "            textAlign=RIGHT \n"
               "            align=baseline \n"
               "            cols=4 \n"
               "            toolTipCaption=\"Step Mod 2\" \n"
               "            autoresolve=0 \n"
               "            reqSizeXScaled=16 \n"
               "            negativeText=\"-\" \n"
               "            style=flat \n"
               "            /> \n"
               "</LayerSwitch> \n"
               ;

            int stepIdx = 0;
            local String srcSDArg2;
            local String srcSDMod1;
            local String srcSDMod2;
            loop(NTS_Track.MAX_STEPS/*64*/)
            {
               local String sdArg2 <= stepdetailsArg2Templ.replace("$(IDX)", String(stepIdx));
               local String sdMod1 <= stepdetailsMod1Templ.replace("$(IDX)", String(stepIdx));
               local String sdMod2 <= stepdetailsMod2Templ.replace("$(IDX)", String(stepIdx));
               srcSDArg2.append(sdArg2);
               srcSDMod1.append(sdMod1);
               srcSDMod2.append(sdMod2);

               // Next step
               stepIdx++;
            }

            xfmSrc.replace("$(STEPDETAILS_ARG2)", srcSDArg2);
            xfmSrc.replace("$(STEPDETAILS_MOD1)", srcSDMod1);
            xfmSrc.replace("$(STEPDETAILS_MOD2)", srcSDMod2);

            if(parseXMLForm(xfmSrc))
            {
               if(autoResolveIds(this))
               {
                  // Move pattern name textfield into TabSwitch
                  tf_pattern_name2 <= pn_groups.unlinkChildLayer(tf_pattern_name2);
                  pn_groups.removeChildLayer(tf_pattern_name2);
                  Panel pnLabels <= ts_groups.getPnLabels();
                  pnLabels.addLayer(tf_pattern_name2, Layout.RIGHT);

                  f_autodev.initAutoDeviceForm();

                  trackIdx = 0;
                  track_forms.alloc(NTS_Pattern.NUM_TRACKS);
                  loop(NTS_Pattern.NUM_TRACKS)
                  {
                     NTS_TrackForm  trackForm  <= new NTS_TrackForm;
                     NTS_TrackPanel trackPanel <= findLayerById("pn_grid_track_"+trackIdx);
                     trackPanel.editor     <= this;
                     trackForm.pn_track    <= trackPanel;
                     trackForm.bt_mute     <= findLayerById("bt_grid_mute_"+trackIdx);
                     trackForm.bt_solo     <= findLayerById("bt_grid_solo_"+trackIdx);
                     trackForm.lb_tracknr  <= findLayerById("lb_grid_tracknr_"+trackIdx);
                     trackForm.ls_arg3     <= findLayerById("ls_grid_arg3_"+trackIdx);
                     trackForm.fp_arg3     <= findLayerById("fp_grid_arg3_"+trackIdx);
                     trackForm.cm_arg3     <= findLayerById("cm_grid_arg3_"+trackIdx);
                     trackForm.tf_name     <= findLayerById("tf_grid_name_"+trackIdx);
                     trackForm.ls_hide     <= findLayerById("ls_grid_hide_"+trackIdx);
                     trackForm.fp_quant    <= findLayerById("fp_grid_quant_"+trackIdx);
                     trackForm.fp_swing    <= findLayerById("fp_grid_swing_"+trackIdx);
                     trackForm.cm_notelen  <= findLayerById("cm_grid_notelen_"+trackIdx);
                     trackForm.fp_numsteps <= findLayerById("fp_grid_numsteps_"+trackIdx);
                     track_forms.add(#(deref trackForm));

                     // Set fixed sizes to speed up layout (todo: optimize layouter..)
                     //   (note) saves ~13ms

                     if(UI.IsHiDPI())
                     {
                        // trackForm.pn_track.first_child.setRequiredSizeX(203);
                        trackForm.bt_mute.setRequiredSize2fScaled(19, 16);
                        trackForm.bt_solo.setRequiredSize2fScaled(17, 16);
                        // // trackForm.fp_arg3.setRequiredSize2f(77, 20);
                        trackForm.tf_name.setRequiredSize2fScaled(62, 16);
                        trackForm.fp_quant.setRequiredSize2fScaled(32, 16);
                        trackForm.fp_swing.setRequiredSize2fScaled(32, 16);
                        trackForm.cm_notelen.setRequiredSize2fScaled(77, 16);
                        trackForm.fp_numsteps.setRequiredSize2fScaled(62, 16);
                     }
                     else
                     {
                        // trackForm.pn_track.first_child.setRequiredSizeX(203);
                        trackForm.bt_mute.setRequiredSize2fScaled(19, 21);
                        trackForm.bt_solo.setRequiredSize2fScaled(17, 21);
                        // // trackForm.fp_arg3.setRequiredSize2f(77, 20);
                        trackForm.tf_name.setRequiredSize2fScaled(62, 20);
                        trackForm.fp_quant.setRequiredSize2fScaled(32, 20);
                        trackForm.fp_swing.setRequiredSize2fScaled(32, 20);
                        trackForm.cm_notelen.setRequiredSize2fScaled(77, 21);
                        trackForm.fp_numsteps.setRequiredSize2fScaled(62, 20);
                     }

                     trackIdx++;
                  }

                  grid.init(this);

                  stepIdx = 0;
                  loop(NTS_Track.MAX_STEPS/*64*/)
                  {
                     stepdetails_arg2_layerswitches.add(findLayerById("ls_stepdetails_arg2_"+stepIdx));
                     stepdetails_arg2_floatparams  .add(findLayerById("fp_stepdetails_arg2_"+stepIdx));
                     stepdetails_mod1_layerswitches.add(findLayerById("ls_stepdetails_mod1_"+stepIdx));
                     stepdetails_mod1_floatparams  .add(findLayerById("fp_stepdetails_mod1_"+stepIdx));
                     stepdetails_mod2_layerswitches.add(findLayerById("ls_stepdetails_mod2_"+stepIdx));
                     stepdetails_mod2_floatparams  .add(findLayerById("fp_stepdetails_mod2_"+stepIdx));
                     stepIdx++;
                  }

                  cm_pattern_nr.setOptions(Node.patnr_options);

                  cm_play_out_mode.setOptions(NodeTrigSeq.output_mode_names_short);
                  cm_play_out_mode.setOptionsLong(NodeTrigSeq.output_mode_names_long);
                  cm_play_out_mode.setToolTipCaptions(NodeTrigSeq.output_mode_tooltip_captions);

                  cm_play_repeat_start_mode.setOptions(NodeTrigSeq.repeat_start_mode_names);

                  StringArray options;
                  options.join(["-"], NTS_Track.notelen_names);
                  cm_play_repeat_start_quantization.setOptions(options);

                  options.join(["<track>"], NTS_Track.notelen_names);
                  cm_play_repeat_len.setOptions(options);

                  options = ["<track>", "inf"];
                  int numRep = 1;
                  loop(64)
                  {
                     options.add(String(numRep++));
                  }
                  cm_play_num_repeats.setOptions(options);

                  cm_play_rec_unmap.setOptions(NodeTrigSeq.rec_unmap_type_names);

                  updateNoteNameProfileOptions();

                  fp_speed_scl_reset.setPresetOptions([0.25,      0.5,    0.75,  1.0,         1.5,   2.0],
                                                      ["Quarter", "Half", "3/4", "<default>", "6/4", "Double"]
                                                      );

                  if(!initTrackSetupDialog())
                  {
                     return false;
                  }

                  if(!initEuclidDialog())
                  {
                     return false;
                  }

                  if(!initImportARDialog())
                  {
                     return false;
                  }

                  if(!initImportMonDialog())
                  {
                     return false;
                  }

                  initMMC();

                  initTimers();

                  return true;
               }
            }
         }
      }

      return false;
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_replay               <= TimerAction.New(TA_REPLAY,               this, 1000.0/60);
      ta_undo                 <= TimerAction.New(TA_UNDO,                 this, 5000);
      ta_stepdetails_relayout <= TimerAction.New(TA_STEPDETAILS_RELAYOUT, this,  100);
      ta_stepdetails_update   <= TimerAction.New(TA_STEPDETAILS_UPDATE,   this,  100);
   }

   // <ui.png>
   public virtual layoutHierarchy(local boolean _bInvalidateSizeCaches, local boolean _bLayoutFinal) {

      if(null != seq)
      {
         if(_bInvalidateSizeCaches)
         {
            updateStepDetailsFloatParamLayout(true/*bResetToMin*/);
         }
         else if(_bLayoutFinal)
         {
            updateStepDetailsFloatParamLayout(false/*bResetToMin*/);
         }
      }
      // // NodeEditor::layoutHierarchy(_bInvalidateSizeCaches, _bLayoutFinal);

      // // if(!_bLayoutFinal)
      // // {
         pn_stepdetails_spacer.setRequiredSizeX(grid.getTrackFormSx());
         bt_stepdetails_mode.setRequiredSizeX(grid.getTrackFormSx());
      // // }
         NodeEditor::layoutHierarchy(_bInvalidateSizeCaches, _bLayoutFinal);
   }

   // <ui_update.png>
   protected method updateNoteNameProfileOptions() {
      StringArray noteNameProfileOptions;
      StringArray noteNameProfileIds;
      MIDI.note_name_profiles.keysToArray(noteNameProfileIds);
      Utils.SortStringArray(noteNameProfileIds, false/*bCaseSensitive*/);
      noteNameProfileOptions.join(["- (numbers)"],
                                  noteNameProfileIds
                                  );
      cm_notenames.setOptions(noteNameProfileOptions);
   }

   // <ui_update.png>
   protected method updatePatternNrComboBox() {
      local StringArray patNrOptionsShort;
      local StringArray patNrOptionsLong;
      local IntArray patNrColors;
      Node.CalcPatNrOptions(seq, patNrOptionsShort, patNrOptionsLong, patNrColors);
      cm_pattern_nr.setOptions(patNrOptionsShort);
      cm_pattern_nr.setOptionsLong(patNrOptionsLong);
      cm_pattern_nr.setOptionBGColors(patNrColors);
   }

   // <ui_update.png>
   protected method updatePatternNoteNameProfileSelection() {
      NTS_Pattern pat <= seq.nodeGetCurrentEditPattern();

      if(null != pat)
      {
         if(null != pat.note_name_profile_id)
         {
            int noteNameProfileIdx = cm_notenames.options.indexOfObject(pat.note_name_profile_id, 0);
            cm_notenames.setSelectedOption(noteNameProfileIdx);
         }
         else
         {
            cm_notenames.setSelectedOption(0); // Numbers
         }
      }
   }

   // <ui_init.png>
   protected method initTrackSetupDialog() : boolean {
      dlg_track_setup <= new NTS_TrackSetupDialog;
      if(!dlg_track_setup.init())
      {
         Global.Error("NTS_TrackSetupDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initEuclidDialog() : boolean {
      dlg_euclid <= new NTS_EuclidDialog;
      if(!dlg_euclid.init())
      {
         Global.Error("NTS_EuclidDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initImportARDialog() : boolean {
      dlg_import_ar <= new NTS_ImportARDialog;
      if(!dlg_import_ar.init())
      {
         Global.Error("NTS_ImportARDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initImportMonDialog() : boolean {
      dlg_import_mon <= new NTS_ImportMonDialog;
      if(!dlg_import_mon.init())
      {
         Global.Error("NTS_ImportMonDialog::init() failed");
         return false;
      }
      return true;
   }

   // <midi_mmc.png>
   protected method initMMC() {

      mmcInit("NodeTrigSeqEditor");

      // From PageNode: (so these show up in the map editor)
      root_form.pg_node.addBaseMMCTargets(this);

      mmcAddTarget(MMT_UNDO,                         CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TOGGLE_RECORD,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_UNDO_AND_RESTART_RECORDING,   CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_FORCE_STEP_RECORD,            CLASS_BUTTON, SYN_BUTTON_MOD);
      mmcAddTarget(MMT_CLEAR_TRACK,                  CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_TRIGS,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_MICROTIME,        CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_ARGS,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_MODS,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_MODS_INIT,        CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_ALL_TRACKS,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_ALL_TRACKS_KEEP_TIMING, CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_CLONE,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_CLONE_SUB,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_COPY,                 CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_PASTE,                CLASS_BUTTON, SYN_BUTTON_CLICK);
   }

   // <midi_mmc.png>
   public virtual mmcHandleEvent(MIDIMapEvent _ev) : boolean {
      // trace "xxx NodeTrigSeqEditor::mmcHandleEvent";

      if(!mmcIsBindableEvent(_ev))
         return false;

      MIDIMapEvent boundEv <= mmcGetBindingByEvent(_ev);

      if(null != boundEv)
      {
         switch(boundEv.bound_target.target_name)
         {
            default:
               return root_form.pg_node.mmcHandleNodeTarget(boundEv.bound_target.target_name);

            case MMT_TOGGLE_RECORD:
               toggleRecording();
               return true;

            case MMT_UNDO_AND_RESTART_RECORDING:
               queueUndoAndRecRestart();
               return true;

            case MMT_UNDO:
               // // undoEndTimer();
               // // undoRedo(false/*bForceUndo*/);
               handleUndoRedo( !(seq.b_recording && replay.b_playing)/*bSaveRedo*/ );
               return true;

            case MMT_FORCE_STEP_RECORD:
               seq.setEnableForceStepRecord(_ev.class_type_ext); // button up/down
               redrawPlugin();
               return true;

            case MMT_CLEAR_TRACK:
               clearCursorTrack();
               return true;

            case MMT_CLEAR_TRACK_TRIGS:
               clearTrackTrigsAndRepeats();
               return true;

            case MMT_CLEAR_TRACK_MICROTIME:
               clearTrackMicrotime();
               return true;

            case MMT_CLEAR_TRACK_ARGS:
               clearTrackArgs();
               return true;

            case MMT_CLEAR_TRACK_MODS:
               clearTrackMods();
               return true;

            case MMT_CLEAR_TRACK_MODS_INIT:
               clearTrackModsInit();
               return true;

            case MMT_CLEAR_ALL_TRACKS:
               clearAllTracks(false/*bKeepTimingTrack*/);
               return true;

            case MMT_CLEAR_ALL_TRACKS_KEEP_TIMING:
               clearAllTracks(true/*bKeepTimingTrack*/);
               return true;

            case MMT_PATTERN_CLONE:
               handlePatternClone(false/*bSub*/);
               return true;

            case MMT_PATTERN_CLONE_SUB:
               handlePatternClone(true/*bSub*/);
               return true;

            case MMT_PATTERN_COPY:
               handlePatternCopy();
               return true;

            case MMT_PATTERN_PASTE:
               handlePatternPaste();
               return true;
         }
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray layers) {

      // (todo) implement me

      switch(ts_groups.getActiveTabIndex())
      {
         case TAB_PATTERN:

            layers.joinRR(layers,
                          [
                             ts_groups,
                             tf_pattern_name2,

                             cm_pattern_nr,
                             tf_pattern_name,
                             fp_pattern_masterlen16th,
                             cm_notenames,
                             bt_notenames_rescan,
                             bt_notenames_guess,

                             fp_arg3_offset,
                             fp_pb_up,
                             fp_pb_down,

                             fp_note_dur_offset,
                             fp_swing_offset,

                             fp_velocity_jitter_offset,
                             fp_microtime_jitter_offset,

                             fp_mod1_jitter_offset,
                             fp_mod2_jitter_offset,

                             fp_quant_offset,
                             fp_step_highlight_modulo,
                             fp_bar_modulo,

                             bt_pattern_alloc,
                             bt_pattern_tools,
                             bt_pattern_free
                           ]
                          );
            break;

         case TAB_GRID:
            layers.joinRR(layers,
                          [
                             ts_groups,
                             tf_pattern_name2,

                             grid
                           ]
                          );

            switch(seq.ui_stepdetails_mode)
            {
               case NodeTrigSeq.UI_STEPDETAILS_ALL:
                  layers.joinRR(layers,
                                [
                                   fp_stepdetails_arg2,
                                   fp_stepdetails_microtime,
                                   fp_stepdetails_mod1,
                                   fp_stepdetails_mod2,

                                   cm_stepdetails_arg1,
                                   cb_stepdetails_repeat,
                                   cb_stepdetails_trig,

                                   bt_stepdetails_mode,
                                 ]
                                );
                  break;

               case NodeTrigSeq.UI_STEPDETAILS_ARG2:
                  layers.joinRR(layers, stepdetails_arg2_floatparams);
                  break;

               case NodeTrigSeq.UI_STEPDETAILS_MOD1:
                  layers.joinRR(layers, stepdetails_mod1_floatparams);
                  break;

               case NodeTrigSeq.UI_STEPDETAILS_MOD2:
                  layers.joinRR(layers, stepdetails_mod2_floatparams);
                  break;
            }

            NTS_TrackForm *trackForm;
            foreach trackForm in track_forms
            {
               trackForm.addTabCycleOverrides(layers);
            }

            break;

         case TAB_PLAY:
            layers.joinRR(layers,
                          [
                             ts_groups,
                             tf_pattern_name2,

                             cm_node_class,
                             cb_node_class_show,
                             cm_node_class_show_in,

                             cm_play_out_dev,
                             cm_play_out_ch,

                             cm_play_out_mode,
                             cb_play_extclk,
                             fp_speed_scl_reset,
                             bt_speed_restart,

                             cm_play_repeat_start_mode,
                             cm_play_repeat_start_quantization,
                             cm_play_repeat_len,
                             cm_play_num_repeats,

                             cm_play_rec_dev,
                             cm_play_rec_ch,
                             cb_play_rec_enable,
                             cb_play_rec_prev,
                             cb_play_rec_quantize,
                             cb_play_rec_mute_repeat,

                             cm_play_rec_unmap,
                             cb_play_rec_mod_unmap,

                             cm_play_plugin_dev,
                             cm_play_plugin_scene,

                             cb_play_followarr,

                             cb_play_stepoff,
                           ]
                          );
            f_autodev.addTabCycleOverrides(layers);
            return layers;
      }

      return layers;
   }

   // <ui_show.png>
   public virtual showNode(NodeTrigSeq _seq) {
      seq <= _seq;

      if(null != seq)
      {
         seq.undoInvalidate();
         seq.b_force_step_record = false;
      }

      // Pattern:
      cm_pattern_nr.setSelectedOption(seq.nodeGetCurrentEditPatternNr());

      cm_play_out_dev.setOptions(MIDI.out_device_names_sorted);
      cm_play_out_dev.setOptionBGColors(MIDI.out_device_bgcolors_sorted);
      cm_play_out_dev.setSelectedOption(MIDI.UnsortedToSortedDevIdx(seq.getOutDevIdx()));
      cm_play_out_ch.setOptionsLong(MIDI.GetMIDISynthProfileCaptionOptionsByOutDevIdx(seq.getOutDevIdx(), null/*firstOptionOrNull*/));
      cm_play_out_ch.setSelectedOption(seq.getOutCh());

      cm_play_out_mode.setSelectedOption(seq.output_mode);
      cb_play_extclk.setSelected(seq.b_extclk);
      fp_speed_scl_reset.setValue(seq.rpn_com_speed_scl_reset_val);

      cm_play_repeat_start_mode.setSelectedOption(seq.repeat_start_mode);
      cm_play_repeat_start_quantization.setSelectedOption(seq.repeat_start_quantization_note_length + 1);
      cm_play_repeat_len.setSelectedOption(seq.repeat_note_length + 1);
      cm_play_num_repeats.setSelectedOption(seq.num_repeats + 1);

      updatePatArg3Label();

      local StringArray devAll;
      devAll.join(["*"], MIDI.out_device_names_sorted);
      local IntArray bgcolorsAll;
      bgcolorsAll.join([0], MIDI.out_device_bgcolors_sorted);

      cm_play_rec_dev.setOptions(devAll);
      cm_play_rec_dev.setOptionBGColors(bgcolorsAll);

      cm_play_rec_unmap.setSelectedOption(seq.rec_unmap_type);
      cb_play_rec_mod_unmap.setSelected(seq.b_rec_mod_unmap);

      // Add HW Interface plugin devices (filter by supported devices)
      local StringArray devPlugin;
      devPlugin.add("-"); // -1
      STX_MIDIOutDevice *pluginDev;
      int pluginDevIdxSorted = 0;
      plugin_dev_options.empty();
      foreach pluginDev in MIDI.out_devices_sorted
      {
         if(null != pluginDev)
         {
            MIDISynthProfile mspPlugin <= pluginDev.getMIDISynthProfile(0/*midiCh*/);
            if(null != mspPlugin)
            {
               if(null != mspPlugin.trigseq_editor_plugin)
               {
                  devPlugin.add(pluginDev.getAliasOrDeviceName());
                  plugin_dev_options.add(pluginDev.dev_idx);
               }
            }
         }
      }
      cm_play_plugin_dev.setOptions(devPlugin);
      cm_play_plugin_dev.setSelectedOption(plugin_dev_options.indexOf(seq.plugin_dev_idx, 0) + 1);

      cm_play_plugin_scene.setOptions(MIDIMorphScene.FindAllSceneNames());
      cm_play_plugin_scene.setSelectedOption(seq.plugin_scene_group_idx * MIDIMorphScene.NUM_SCENES_PER_GROUP + seq.plugin_scene_idx);

      cb_play_followarr.setSelected(STConfig.b_node_trig_seq_edit_pattern_follows_replay_pattern);

      cb_play_stepoff.setSelected(0 != STConfig.node_trig_seq_step_label_offset);

      updatePatternNrComboBox();

      handlePatternChanged(false/*bFromUI*/);

      // Grid:
      ls_stepdetails.switchToLayerNr(seq.ui_stepdetails_mode + 1/*skip hidden*/);
      updateStepDetailsButton();


      // Play:
      f_autodev.showNode(seq, devAll, bgcolorsAll);

      cm_node_class.setOptions(STConfig.node_class_names);
      updateNodeClass();
      updateNodeClassShowIn(seq);

      boolean bEnable = seq.b_rec;
      cb_play_rec_enable.setSelected(bEnable);
      cb_play_rec_prev.setSelected(seq.b_rec_prev);
      StringArray midiNotes <= MIDI.midi_notes;
      cb_play_rec_enable.setToolTipCaption("When checked, enable trig+mod recording\n\nIn mixed state, record only when node editor is visible\n\n (note) notes "+midiNotes.get(3*12/*C-3*/)+".."+midiNotes.get(4*12+3/*D#4*/)+" trigger tracks 1..16 (also see Unmap Type!)\n\n (note) lctrl-x RSHIFT");
      cb_play_rec_mute_repeat.setSelected(seq.b_rec_mute_repeat);
      cm_play_rec_dev.setSelectedOption(MIDI.UnsortedToSortedDevIdx(seq.rec_dev_idx) + 1);
      cm_play_rec_ch.setOptionsLong(MIDI.GetMIDISynthProfileCaptionOptionsByOutDevIdx(seq.rec_dev_idx, "*"/*firstOptionOrNull*/));
      cm_play_rec_ch.setSelectedOption(seq.rec_ch + 1);
      cb_play_rec_quantize.setSelected(seq.b_rec_quantize);

      MIDI.AddMIDIMapEventListener(this);

      ts_groups.setActiveTabIndex(TAB_GRID);
      handleViewEnter();
   }

   // <ui_show.png>
   public method showNodeQuiet(NodeTrigSeq _seq) {
      seq <= _seq;
   }

   // <method.png>
   public virtual showNodePost() {
      // trace "xxx NodeTrigSeqEditor::showNodePost";

      // // ta_update_state.schedule();

       // // relayout();
       // // relayout();

      if(!NodeEditor.b_lock_kbdfocus)
      {
         UI.SetKeyboardFocus(ts_groups);
      }

      handleViewEnter();

      handlePatternChanged(false/*bFromUI*/); // relayout grid/scrollpane

      grid.b_make_cursor_visible_pending = true;  // hack

      // // if(replay.b_playing)
      // // {
         ta_replay.schedule();
      // // }

      // // NTS_TrackForm tf <= track_forms.get(0);
      // // tf.pn_track.debugPrintChildLayersRecursive(0, true);

      showEditorPlugin();
   }

   // <ui_show.png>
   protected method showEditorPlugin() {
      restore_plugin_scene_group_idx = -1;
      restore_plugin_scene_idx       = -1;

      STX_MIDIOutDevice outDev <= MIDI.GetMIDIOutDeviceByIndex(seq.plugin_dev_idx);
      // trace "xxx NTS::showEditorPlugin: outDev="+#(outDev);
      if(null != outDev)
      {
         int inDevIdx = MIDI.FindInDeviceIdxForOutDeviceName(outDev.getAliasOrDeviceName());
         if(-1 != inDevIdx)
         {
            STX_MIDIInDevice inDev <= MIDI.GetMIDIInDeviceByIndex(inDevIdx);
            MIDISynthProfile msp <= outDev.getMIDISynthProfile(0/*midiCh*/);
            // trace "xxx inDevIdx="+inDevIdx+" msp="+#(msp);
            if(null != msp)
            {
               if(null != msp.trigseq_editor_plugin)
               {
                  editor_plugin <= msp.trigseq_editor_plugin;
                  // trace "xxx editor_plugin="+#(editor_plugin);
                  if(editor_plugin instanceof NTS_EditorPlugin)
                  {
                     // Select HW interface scene
                     if((seq.plugin_scene_group_idx >= 0) && (seq.plugin_scene_idx >= 0))
                     {
                        restore_plugin_scene_group_idx = seq.plugin_scene_group_idx;
                        restore_plugin_scene_idx       = MIDIMorphScene.GetCurrentSceneIdx(seq.plugin_scene_group_idx);

                        MIDIMorphScene.SelectSceneByIdx(seq.plugin_scene_group_idx,
                                                        seq.plugin_scene_idx
                                                        );
                     }

                     editor_plugin.showNode(this, inDev, outDev);
                  }
                  else
                  {
                     trace "[~~~] NodeTrigSeqEditor::showEditorPlugin: invalid msp.trigseq_editor_plugin="+#(msp.trigseq_editor_plugin);
                     editor_plugin <= null;
                  }
               }
            }
         }
         else
         {
            trace "[~~~] NodeTrigSeqEditor::showEditorPlugin: failed to resolve in device for outDev=\""+outDev.getAliasOrDeviceName()+"\"";
         }
      }
   }

   // <ui_hide.png>
   protected method leaveEditorPlugin() {
      if(null != editor_plugin)
      {
         editor_plugin.leaveNode();
         editor_plugin <= null;

         if((restore_plugin_scene_group_idx >= 0) && (restore_plugin_scene_idx >= 0))
         {
            MIDIMorphScene.SelectSceneByIdx(restore_plugin_scene_group_idx,
                                            restore_plugin_scene_idx
                                            );
         }
      }
   }

   // <ui_focus.png>
   public virtual refocusDefault() {
      if(!NodeEditor.b_lock_kbdfocus)
      {
         UI.SetKeyboardFocus(ts_groups);
         handleViewEnter();  // queues STEPDETAILS_RELAYOUT
      }
   }

   // <ui_focus.png>
   public method refocusGrid() {
      UI.SetKeyboardFocus(grid);
   }

   // <ui_update.png>
   public method updatePatArg3Label() {
      lb_arg3_offset.setCaption("Arg3 ("+(NodeTrigSeq.arg3_names.get(seq.output_mode))+") Offset:");
      pn_arg3_offset.queueRelayout();
   }

   // <ui_timer.png>
   public method queueRelayoutStepDetails() {
      ta_stepdetails_relayout.schedule();
   }

   // <ui_timer.png>
   public method queueUpdateStepDetails() {
      ta_stepdetails_update.schedule();
   }

   // <ui_update.png>
   public method updateStepDetails() {
      NTS_Step st <= grid.getCursorStep();
      boolean bEditable = (null != st);
      if(bEditable)
      {
         cb_stepdetails_trig.setSelected(st.b_trig);
         cb_stepdetails_repeat.setSelected(st.b_repeat);

         local String arg1Label <= st.getArg1Label();
         lb_stepdetails_arg1.setCaption(arg1Label+":");
         cm_stepdetails_arg1.setOptions(st.getArg1Options());

         if("Velocity" == arg1Label)
         {
            local IntArray arg1Colors;
            arg1Colors.add(app_lnf.getColorAlpha(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE0, 0x30));
            arg1Colors.add(app_lnf.getColorAlpha(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE1, 0x30));
            arg1Colors.add(app_lnf.getColorAlpha(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE2, 0x30));
            arg1Colors.add(app_lnf.getColorAlpha(AppLookAndFeel.COLOR_TRIGSEQ_STEP_BG_ACTIVE3, 0x30));
            cm_stepdetails_arg1.setOptionBGColors(arg1Colors);
         }
         else
         {
            cm_stepdetails_arg1.setOptionBGColors(null);
         }

         cm_stepdetails_arg1.setSelectedOption(st.arg1);

         lb_stepdetails_arg2.setCaption(st.getArg2Label()+":");
         if(st.arg2 < -99999)
            fp_stepdetails_arg2.setValue(-1);
         else
            fp_stepdetails_arg2.setValue(st.arg2);

         fp_stepdetails_microtime.setValue(st.microtime);

         if(st.mod1 < -99999)
            fp_stepdetails_mod1.setValue(-1);
         else
            fp_stepdetails_mod1.setValue(st.mod1);

         if(st.mod2 < -99999)
            fp_stepdetails_mod2.setValue(-1);
         else
            fp_stepdetails_mod2.setValue(st.mod2);
      }

      pn_stepdetails.recursiveSetEditable(bEditable);

      if(root_form.isLastStatusMessageOlderThan(1000))
         grid.showCursorStepInfo();
   }

   // <ui_update.png>
   public method updateStepDetailsButton() {
      local String *cap;
      NTS_Track track <= grid.getCursorTrack();

      switch(seq.ui_stepdetails_mode)
      {
         default:
         case NodeTrigSeq.UI_STEPDETAILS_ALL:
            cap <= "Step Details";
            break;

         case NodeTrigSeq.UI_STEPDETAILS_ARG2:
            NTS_Step st <= grid.getCursorStep();
            if(null != st)
            {
               cap <= "Arg 2: "+st.getArg2Label();
            }
            else
            {
               cap <= "Arg 2";
            }
            break;

         case NodeTrigSeq.UI_STEPDETAILS_MOD1:
            cap <= "Mod 1: "+((null != track) ? track.getMod1Caption(seq) : "-");
            break;

         case NodeTrigSeq.UI_STEPDETAILS_MOD2:
            cap <= "Mod 2: "+((null != track) ? track.getMod2Caption(seq) : "-");
            break;
      }
      bt_stepdetails_mode.setCaption(cap);
      pn_stepdetails_outer.relayout();
      pn_stepdetails_outer.redraw();
   }

   // <ui_update.png>
   protected method updateStepDetailsFloatParamLayout(boolean _bResetToMin) {
      // trace "xxx --------------------------------------------- updateStepDetailsFloatParamLayout: _bResetToMin="+_bResetToMin;

      NTS_Pattern pat <= seq.nodeGetCurrentEditPattern();
      int numStepsVisible = 0;
      float cellSx = 8 * UI.font_scaling;
      if(null != pat)
      {
         NTS_Track track <= grid.getCursorTrack();
         if(null != track)
         {
            numStepsVisible = track.play_length;
         }

         if(!_bResetToMin)
         {
            int maxSteps = pat.getMaxSteps();
            cellSx = (STConfig.node_trig_seq_grid_steps_x > 0) ? grid.cell_sx : grid.getSizeX() / maxSteps;
         }
      }

      // Update arg2+mod1/2 layouts
      FloatParam *fp;

      int stepIdx;
      float px;

      float minH = 21;
      if(UI.font_scaling == 2.0)
         minH = 36;
      else if(UI.font_scaling >= 1.2)
         minH = 21 * UI.font_scaling;
      float pnW = _bResetToMin ? 8*64 : grid.size_x;

      pn_stepdetails_arg2.setRequiredSizeX(pnW);
      pn_stepdetails_arg2.setSizeY(minH);
      // trace "xxx pn_stepdetails_arg2.setSizeX(pnW="+pnW+")";

      pn_stepdetails_mod1.setRequiredSizeX(pnW);
      pn_stepdetails_mod1.setSizeY(minH);

      pn_stepdetails_mod2.setRequiredSizeX(pnW);
      pn_stepdetails_mod2.setSizeY(minH);

      // // fp_stepdetails_microtime.setRequiredSizeY(minH);

      px = 0;
      foreach fp in stepdetails_arg2_floatparams
      {
         fp.setPositionX(px);
         fp.setRequiredSizeX(cellSx);
         fp.setSizeY(minH);
         px += cellSx;
      }

      px = 0;
      foreach fp in stepdetails_mod1_floatparams
      {
         fp.setPositionX(px);
         fp.setRequiredSizeX(cellSx);
         fp.setSizeY(minH);
         px += cellSx;
      }

      px = 0;
      foreach fp in stepdetails_mod2_floatparams
      {
         fp.setPositionX(px);
         fp.setRequiredSizeX(cellSx);
         fp.setSizeY(minH);
         px += cellSx;
      }

      stepIdx = 0;
      LayerSwitch *ls;
      px = 0;
      loop(numStepsVisible)
      {
         // trace "xxx nts: set stepIdx="+stepIdx+" bEditable=1";
         ls <= stepdetails_arg2_layerswitches.get(stepIdx);
         ls.invalidateSizeCaches();
         ls.setPositionX(px);
         ls.setRequiredSizeX(cellSx);
         ls.setSizeY(minH);
         ls.switchToLayerNr(1);
         ls.recursiveSetEditable(true);

         ls <= stepdetails_mod1_layerswitches.get(stepIdx);
         ls.invalidateSizeCaches();
         ls.setPositionX(px);
         ls.setRequiredSizeX(cellSx);
         ls.setSizeY(minH);
         ls.switchToLayerNr(1);
         ls.recursiveSetEditable(true);

         ls <= stepdetails_mod2_layerswitches.get(stepIdx);
         ls.invalidateSizeCaches();
         ls.setPositionX(px);
         ls.setRequiredSizeX(cellSx);
         ls.setSizeY(minH);
         ls.switchToLayerNr(1);
         ls.recursiveSetEditable(true);

         stepIdx++;
         px += cellSx;
      }
      while(stepIdx < NTS_Track.MAX_STEPS/*64*/)
      {
         // trace "xxx nts: set stepIdx="+stepIdx+" bEditable=0";
         ls <= stepdetails_arg2_layerswitches.get(stepIdx);
         ls.invalidateSizeCaches();
         ls.setPositionX(px);
         ls.setRequiredSizeX(1);
         ls.setSizeY(minH);
         ls.switchToLayerNr(0);
         ls.recursiveSetEditable(false);

         ls <= stepdetails_mod1_layerswitches.get(stepIdx);
         ls.invalidateSizeCaches();
         ls.setPositionX(px);
         ls.setRequiredSizeX(1);
         ls.setSizeY(minH);
         ls.switchToLayerNr(0);
         ls.recursiveSetEditable(false);

         ls <= stepdetails_mod2_layerswitches.get(stepIdx);
         ls.invalidateSizeCaches();
         ls.setPositionX(px);
         ls.setRequiredSizeX(1);
         ls.setSizeY(minH);
         ls.switchToLayerNr(0);
         ls.recursiveSetEditable(false);

         stepIdx++;
         px += cellSx;
      }

   }

   // <ui_update.png>
   protected method updateStepDetailsFloatParamValues() {
      NTS_Pattern pat <= seq.nodeGetCurrentEditPattern();
      if(null != pat)
      {
         NTS_Track track <= grid.getCursorTrack();
         if(null != track)
         {
            int numStepsVisible = track.play_length;

            // Update arg2+mod1/2 layouts
            FloatParam *fp;
            LayerSwitch *ls;
            int stepIdx = 0;
            int c32Cursor = #18ffff00;
            int c32Other  = #00000000;
            loop(numStepsVisible)
            {
               NTS_Step st <= track.getStepByIndex(stepIdx);

               // trace "xxx nts: update stepIdx="+stepIdx+" arg2="+st.arg2+" mod1="+st.mod1+" mod2="+st.mod2;
               ls <= stepdetails_arg2_layerswitches.get(stepIdx);
               if(1 != ls.getCurrentChildNr())
                  ls.switchToLayerNr(1);
               ls.recursiveSetEditable(true);
               fp <= stepdetails_arg2_floatparams.get(stepIdx);
               if(st.arg2 < 0)
                  fp.setValue(-1);
               else
                  fp.setValue(st.arg2);
               fp.setBackgroundTint( (grid.cursor_x == stepIdx) ? c32Cursor : c32Other );

               ls <= stepdetails_mod1_layerswitches.get(stepIdx);
               if(1 != ls.getCurrentChildNr())
                  ls.switchToLayerNr(1);
               ls.recursiveSetEditable(true);
               fp <= stepdetails_mod1_floatparams.get(stepIdx);
               if(st.mod1 < 0)
                  fp.setValue(-1);
               else
                  fp.setValue(st.mod1);
               fp.setBackgroundTint( (grid.cursor_x == stepIdx) ? c32Cursor : c32Other );

               ls <= stepdetails_mod2_layerswitches.get(stepIdx);
               if(1 != ls.getCurrentChildNr())
                  ls.switchToLayerNr(1);
               ls.recursiveSetEditable(true);
               fp <= stepdetails_mod2_floatparams.get(stepIdx);
               if(st.mod2 < 0)
                  fp.setValue(-1);
               else
                  fp.setValue(st.mod2);
               fp.setBackgroundTint( (grid.cursor_x == stepIdx) ? c32Cursor : c32Other );

               stepIdx++;
            }
            while(stepIdx < NTS_Track.MAX_STEPS/*64*/)
            {
               // trace "xxx nts: set stepIdx="+stepIdx+" bEditable=0";
               ls <= stepdetails_arg2_layerswitches.get(stepIdx);
               if(0 != ls.getCurrentChildNr())
                  ls.switchToLayerNr(0);
               ls.recursiveSetEditable(false);

               ls <= stepdetails_mod1_layerswitches.get(stepIdx);
               if(0 != ls.getCurrentChildNr())
                  ls.switchToLayerNr(0);
               ls.recursiveSetEditable(false);

               ls <= stepdetails_mod2_layerswitches.get(stepIdx);
               if(0 != ls.getCurrentChildNr())
                  ls.switchToLayerNr(0);
               ls.recursiveSetEditable(false);

               stepIdx++;
            }

         } // if track
      } // if pat
   }

   // <ui_handle.png>
   public method handleCycleStepDetailsMode(int _dir, boolean _bClip) {
      if(_bClip)
         seq.ui_stepdetails_mode = mathClampi(seq.ui_stepdetails_mode + _dir, 0, NodeTrigSeq.NUM_UI_STEPDETAILS_MODES-1);
      else
         seq.ui_stepdetails_mode = mathWrapi(seq.ui_stepdetails_mode + _dir, 0, NodeTrigSeq.NUM_UI_STEPDETAILS_MODES);
      updateStepDetailsButton();
      ls_stepdetails.switchToLayerNr(seq.ui_stepdetails_mode + 1/*skip hidden*/);
      Global.Print("Step Details Mode is "+seq.ui_stepdetails_mode+" ("+(bt_stepdetails_mode.getCaption().replace("Step Details (", "").replace(")", ""))+")");
      relayout();
      queueUpdateStepDetails();
      UI.RedrawAll();
      redrawPlugin();
      refocusDefault();
   }

   // <ui_handle.png>
   protected method handleStepDetailsTrigChanged() {
      NTS_Step st <= grid.getCursorStep();
      if(null != st)
      {
         st.setEnableTrig(cb_stepdetails_trig.isSelected());
         Global.Print("Step Trig is "+Utils.GetEnableString(st.b_trig));
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsRepeatChanged() {
      NTS_Step st <= grid.getCursorStep();
      if(null != st)
      {
         boolean bEnable = cb_stepdetails_repeat.isSelected();
         st.setEnableRepeat(true == bEnable);
         st.setEnableMod(maybe == bEnable);
         Global.Print("Step Repeat is "+Utils.GetEnableString(st.b_repeat)+", Mod is "+Utils.GetEnableString(st.b_mod));
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsArg1Changed() {
      NTS_Step st <= grid.getCursorStep();
      if(null != st)
      {
         st.setArg1(cm_stepdetails_arg1.getSelectedOption());
         Global.Print("Step Arg1 ("+st.getArg1Label()+") is "+st.arg1+" ("+(st.getArg1String().substring(3, 99))+")");
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsArg2Changed() {
      NTS_Step st <= grid.getCursorStep();
      if(null != st)
      {
         float f = fp_stepdetails_arg2.getFloatValue();
         if(f < 0)
         {
            st.setArg2(NodeTrigSeq.INVALID_VALUE);
            Global.Print("Step Arg 2 is <not set>");
         }
         else
         {
            st.setArg2(f);
            Global.Print("Step Arg 2 ("+st.getArg2Label()+") is "+st.arg2+" ("+st.getArg2String(false/*bShort*/)+")");
         }
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsArg2ChangedByIdx(int _stepIdx) {
      NTS_Step st <= grid.getCurrentTrackStepByIdx(_stepIdx);
      if(null != st)
      {
         FloatParam fp <= stepdetails_arg2_floatparams.get(_stepIdx);
         float f = fp.getFloatValue();
         if(f < 0)
         {
            st.setArg2(NodeTrigSeq.INVALID_VALUE);
            Global.Print("Step "+(_stepIdx+1)+" Arg 2 is <not set>");
         }
         else
         {
            st.setArg2(f);
            Global.Print("Step "+(_stepIdx+1)+" Arg 2 ("+st.getArg2Label()+") is "+st.arg2+" ("+st.getArg2String(false/*bShort*/)+")");
         }
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsMod1ChangedByIdx(int _stepIdx) {
      NTS_Step st <= grid.getCurrentTrackStepByIdx(_stepIdx);
      if(null != st)
      {
         FloatParam fp <= stepdetails_mod1_floatparams.get(_stepIdx);
         float f = fp.getFloatValue();
         if(f < 0)
         {
            st.setMod1(NodeTrigSeq.INVALID_VALUE);
            Global.Print("Step "+(_stepIdx+1)+" Mod 1 is <not set>");
         }
         else
         {
            st.setMod1(f);
            grid.getCursorTrack().queueMod1(f / 127.0);
            Global.Print("Step "+(_stepIdx+1)+" Mod 1 is "+st.mod1+" ("+(mathLerpf(grid.getCursorTrack().mod1_min, grid.getCursorTrack().mod1_max, st.mod1/127.0f)+" after range scaling)"));
         }
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsMod2ChangedByIdx(int _stepIdx) {
      NTS_Step st <= grid.getCurrentTrackStepByIdx(_stepIdx);
      if(null != st)
      {
         FloatParam fp <= stepdetails_mod2_floatparams.get(_stepIdx);
         float f = fp.getFloatValue();
         if(f < 0)
         {
            st.setMod2(NodeTrigSeq.INVALID_VALUE);
            Global.Print("Step "+(_stepIdx+1)+" Mod 2 is <not set>");
         }
         else
         {
            st.setMod2(f);
            grid.getCursorTrack().queueMod2(f / 127.0);
            Global.Print("Step "+(_stepIdx+1)+" Mod 2 is "+st.mod2+" ("+(mathLerpf(grid.getCursorTrack().mod2_min, grid.getCursorTrack().mod2_max, st.mod2/127.0f)+" after range scaling)"));
         }
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsMicrotimeChanged() {
      NTS_Step st <= grid.getCursorStep();
      if(null != st)
      {
         st.setMicroTime(fp_stepdetails_microtime.getFloatValue());
         Global.Print("Step microtime is "+st.getMicroTimeString());
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsMod1Changed() {
      NTS_Step st <= grid.getCursorStep();
      if(null != st)
      {
         float f = fp_stepdetails_mod1.getFloatValue();
         if(f < 0)
         {
            st.setMod1(NodeTrigSeq.INVALID_VALUE);
            Global.Print("Step Mod 1 is <not set>");
         }
         else
         {
            st.setMod1(f);
            grid.getCursorTrack().queueMod1(f / 127.0);
            Global.Print("Step Mod 1 is "+st.mod1+" ("+(mathLerpf(grid.getCursorTrack().mod1_min, grid.getCursorTrack().mod1_max, st.mod1/127.0f)+" after range scaling)"));
         }
         grid.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleStepDetailsMod2Changed() {
      NTS_Step st <= grid.getCursorStep();
      if(null != st)
      {
         float f = fp_stepdetails_mod2.getFloatValue();
         if(f < 0)
         {
            st.setMod2(NodeTrigSeq.INVALID_VALUE);
            Global.Print("Step Mod 2 is <not set>");
         }
         else
         {
            st.setMod2(f);
            grid.getCursorTrack().queueMod2(f / 127.0);
            Global.Print("Step Mod 2 is "+st.mod2+" ("+(mathLerpf(grid.getCursorTrack().mod2_min, grid.getCursorTrack().mod2_max, st.mod2/127.0f)+" after range scaling)"));
         }
         grid.redraw();
      }
   }

   // <ui_handle.png>
   public method toggleFolding() {
      b_folded = !b_folded;

      b_layout_done = false;
      updateTrackForms();
      relayout();
      redraw();
      grid.makeCursorVisible();

      Global.Print((b_folded?"Fold":"Unfold")+" tracks");
   }

   // <method_get.png>
   public method getEditPattern() : NTS_Pattern {
      if(null != seq)
      {
         return seq.nodeGetCurrentEditPattern();
      }
      return null;
   }

   // <method_get.png>
   protected method getTrackByIndex(int _trackNr) : NTS_Track {
      NTS_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         return pat.getTrackByIndex(_trackNr);
      }
      return null;
   }

   // <ui_handle.png>
   public virtual nodeHandleEditPatternChanged() {
      // trace "xxx trigseq: nodeHandleEditPatternChanged";
      handlePatternChanged(false/*bFromUI*/);
   }

   // <ui_handle.png>
   public method handlePlayPatChanged() {
      // called from UI thread
      if(STConfig.b_node_trig_seq_edit_pattern_follows_replay_pattern)
      {
         // edit pattern has changed, too
         handlePatternChanged(false/*bFromUI*/);
      }
   }

   // <method.png>
   public static Arg3StringToValue(String _s) : float {
      // Return index int arg3_note_names array
      String *s;
      int idxCol = _s.indexOfChar(':', 0);
      if(-1 != idxCol)
         s <= _s.substring(idxCol+1, 99);
      else
         s <= _s;
      int noteIdx = MIDI.midi_notes.indexOfObject(s.toUpper().trim(), 0);
      float r = 0;
      if(-1 != noteIdx)
      {
         // note name (C-0..G-A)
         r = (noteIdx - last_pat_arg3_offset) + 127;
      }
      else
      {
         noteIdx = MIDI.base_note_names.indexOfObject(s.toUpper().trim(), 0);
         if(-1 != noteIdx)
         {
            // base note name (C..B)
            int arg3Oct = int(last_pat_arg3_offset/12) * 12;
            noteIdx += arg3Oct;
            r = (noteIdx - last_pat_arg3_offset) + 127;
         }
         else
         {
            // relative offset
            r = float(s) + 127;
         }
      }
      // trace "xxx Arg3StringToValue: s=\""+s+"\" => r="+r;
      return r;
   }

   // <ui_update.png>
   protected method updateArg3NoteNames(NTS_Pattern pat) {

      // Generate option strings
      int arg3Offset = pat.arg3_offset;
      last_pat_arg3_offset = arg3Offset;

      arg3_note_names.empty();
      int off = -127;
      loop(255)
      {
         int c = arg3Offset + off;
         if(0 <= c <= 127)
         {
            arg3_note_names.add(off+": "+(MIDI.midi_notes.get(c)));
         }
         else
         {
            arg3_note_names.add(off+": -");
         }
         off++;
      }

      // Update track form widgets
      NTS_Track *track;
      int trackIdx = 0;
      foreach track in pat.tracks
      {
         NTS_TrackForm tf <= track_forms.get(trackIdx);
         FloatParam fp <= tf.fp_arg3;

         if(track.isNoteOutputMode(seq))
         {
            fp.setDisplayType(FloatParam.DISPLAY_USER);
            fp.setUserTable(arg3_note_names);
            fp.setUserStringToValueFxn(NodeTrigSeqEditor.Arg3StringToValue);
            fp.setMinMaxValues(0, 254);
            fp.setValue(track.arg3 + 127);
         }
         else
         {
            fp.setDisplayType(FloatParam.DISPLAY_FLOAT);
            fp.setUserStringToValueFxn(null);
            fp.setMinMaxValues(-127, 127);
            fp.setValue(track.arg3);
         }

         trackIdx++;
      }
   }

   // <ui_handle.png>
   public method handlePatternChanged(boolean _bFromUI) {

      NTS_Pattern pat <= seq.nodeGetCurrentEditPattern();

      updatePatternNrLabel();

      if(!_bFromUI)
      {
         cm_pattern_nr.setSelectedOption(seq.nodeGetCurrentEditPatternNr());
         cm_pattern_nr.redraw();
      }

      if(null != pat)
      {
         tf_pattern_name.setText(pat.pat_name);
         tf_pattern_name.setEditable(true);

         tf_pattern_name2.setText(pat.pat_name);
         tf_pattern_name2.setEditable(true);

         fp_pattern_masterlen16th.setValueAndEnable(pat.master_len_16th);

         fp_arg3_offset.setValueAndEnable(pat.arg3_offset);
         fp_pb_up.setValueAndEnable(pat.pitchbend_range_up);
         fp_pb_down.setValueAndEnable(pat.pitchbend_range_down);

         fp_note_dur_offset.setValueAndEnable(pat.default_note_duration_offset);

         updateArg3NoteNames(pat);

         updatePatternNoteNameProfileSelection();
         cm_notenames.setEditable(true);

         fp_velocity_jitter_offset.setValueAndEnable(pat.velocity_jitter_offset);
         fp_microtime_jitter_offset.setValueAndEnable(pat.microtime_jitter_offset);

         fp_swing_offset.setValueAndEnable(pat.swing_offset);
         fp_mod1_jitter_offset.setValueAndEnable(pat.mod1_jitter_offset);
         fp_mod2_jitter_offset.setValueAndEnable(pat.mod2_jitter_offset);

         fp_quant_offset.setValueAndEnable(pat.quantization_offset);
         fp_step_highlight_modulo.setValueAndEnable(pat.step_modulo_16th);
         fp_bar_modulo.setValueAndEnable(pat.bar_modulo_16th);

         if(STConfig.node_trig_seq_grid_steps_x > 0)
         {
            float leftW = (track_forms.get(0).pn_track.getSizePadX());
            float availWTotal = sp_tracks.getSizeX();
            float availW = (availWTotal - leftW) - 19/*hscroll*/;
            float stepW = availW / STConfig.node_trig_seq_grid_steps_x;
            int numSteps = mathMaxi(pat.getMaxSteps(),
                                    STConfig.node_trig_seq_grid_steps_x
                                    );
            // trace "xxx leftW="+leftW;
            // trace "xxx availWTotal="+availWTotal;
            // trace "xxx availW="+availW;
            // trace "xxx numSteps="+numSteps;
            // trace "xxx stepW="+stepW;
            float reqW = (stepW * numSteps);
            grid.cell_sx = stepW;
            // trace "xxx reqW="+reqW;

            grid.setRequiredSizeX(reqW);
            sp_tracks.relayout();
         }
      }
      else
      {
         tf_pattern_name.setText("");
         tf_pattern_name.setEditable(false);

         tf_pattern_name2.setText("");
         tf_pattern_name2.setEditable(false);

         fp_pattern_masterlen16th.setNonEditableText("-");
         fp_pattern_masterlen16th.setEditable(false);

         fp_arg3_offset.setNonEditableText("-");
         fp_arg3_offset.setEditable(false);

         fp_pb_up.setNonEditableText("-");
         fp_pb_up.setEditable(false);

         fp_pb_down.setNonEditableText("-");
         fp_pb_down.setEditable(false);

         fp_note_dur_offset.setNonEditableText("-");
         fp_note_dur_offset.setEditable(false);

         cm_notenames.setSelectedOption(-1);
         cm_notenames.setEditable(false);

         fp_swing_offset.setNonEditableText("-");
         fp_swing_offset.setEditable(false);

         fp_velocity_jitter_offset.setNonEditableText("-");
         fp_velocity_jitter_offset.setEditable(false);

         fp_microtime_jitter_offset.setNonEditableText("-");
         fp_microtime_jitter_offset.setEditable(false);

         fp_mod1_jitter_offset.setNonEditableText("-");
         fp_mod1_jitter_offset.setEditable(false);

         fp_mod2_jitter_offset.setNonEditableText("-");
         fp_mod2_jitter_offset.setEditable(false);

         fp_quant_offset.setNonEditableText("-");
         fp_quant_offset.setEditable(false);

         fp_step_highlight_modulo.setNonEditableText("-");
         fp_step_highlight_modulo.setEditable(false);

         fp_bar_modulo.setNonEditableText("-");
         fp_bar_modulo.setEditable(false);
      }

      updateTrackForms();
      queueRelayoutStepDetails();

      redraw();

      root_form.pg_node.handleEditPatternChanged();

      if(null != editor_plugin)
         editor_plugin.handlePatternChanged();
   }

   // <ui_update.png>
   public method updateTrackForms() {

      NTS_Pattern pat <= seq.nodeGetCurrentEditPattern();

      int trackIdx = 0;
      NTS_TrackForm *trackForm;
      foreach trackForm in track_forms
      {
         if(null != pat)
         {
            trackForm.updateTrack(seq, pat.getTrackByIndex(trackIdx), pat, b_folded);
            trackForm.setEditable(true);
         }
         else
         {
            trackForm.setEditable(false);
         }
         trackIdx++;
      }

      sp_tracks.redraw();

      redrawPlugin();
   }

   // <method.png>
   public method cancelAllTimers() {
      ta_replay.cancel();
      ta_undo.cancel();
      ta_stepdetails_relayout.cancel();
      ta_stepdetails_update.cancel();
   }

   // <ui_hide.png>
   public virtual leaveNode() {

      leaveEditorPlugin();

      if(null != seq)
         seq.b_force_step_record = false;

      undoEndTimer();

      MIDI.RemoveMIDIMapEventListener(this);

      handleViewLeave();

      cancelAllTimers();

      seq.ui_cursor_x = grid.cursor_x;
      seq.ui_cursor_y = grid.cursor_y;

      grid.handleLeaveNode();
   }

   // <ui_hide.png>
   public virtual unsetNode() {
      seq <= null;
   }

   // <midi_mmt.png>
   public virtual mmtHandleGlobalValue(float _val) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();

      return false;
   }

   // <midi_mmt.png>
   public virtual mmtHandleGlobalValueDelta(int _delta) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();

      return false;
   }

   // <ui_update.png>
   protected method updatePatternNrLabel() {
      Integer io = seq.nodeGetCurrentEditPatternNr();
      lb_pattern_nr.setCaption("Pattern:\n  ("+io.printf("0x%02x")+")");
      lb_pattern_nr.redraw();
   }

   // <ui_handle.png>
   public =replay= method handlePatternAlloc(boolean _bSub) : NTS_Pattern {
      local NTS_Pattern p;

      p.patInit(seq, 0/*patNr placeholder*/);

      int patIdx;

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         patIdx = -1;

         if(true == _bSub)
         {
            // Find unused A..D sub pattern
            patIdx = seq.nodeFindFirstUnusedPatternSub(seq.nodeGetCurrentEditPatternNr());
         }
         else if(false == _bSub)
         {
            // Find unused 1..32 pattern group
            patIdx = seq.nodeFindFirstUnusedPatternGroup(seq.nodeGetCurrentEditPatternNr());
         }

         if(-1 == patIdx)
         {
            patIdx = seq.findFirstUnusedPattern(seq.nodeGetCurrentEditPatternNr());
         }

         if(-1 == patIdx)
         {
            patIdx = seq.findFirstUnusedPattern(0);
         }
      }
      else
      {
         patIdx = seq.nodeGetCurrentEditPatternNr();
      }

      // trace "xxx findFirstUnusedPattern: patIdx="+patIdx+" currentEditNr="+seq.nodeGetCurrentEditPatternNr();

      if(-1 != patIdx)
      {
         p.pat_nr = patIdx;
         seq.nodeSetPattern(patIdx, deref p);

         seq.nodeSetCurrentEditPatternNr(patIdx);

         ////if(!replay.b_playing)
         seq.nodeSetCurrentPlayPatternNr(patIdx);

         cm_pattern_nr.setSelectedOption(patIdx);

         selectPatternByIdx(patIdx);

         replayAlignNewPattern(p);

         handlePatternChanged(false/*bFromUI*/);

         updatePatternNrComboBox();

         Global.SuccessShort("New: Allocate pattern "+cm_pattern_nr.getSelectedOptionName()+" ("+(patIdx+1)+").");
         return p;
      }
      else
      {
         Global.Error("New: All patterns in use.");
         return null;
      }
   }

   // <ui_show.png>
   protected method showPatternToolsMenu(boolean _bFocusFirst) {

      pm_pattern_tools <= PopupMenu.New(this);
      PopupMenu pm <= pm_pattern_tools;
      PopupMenuButton *pmb;

      NTS_Pattern pat <= seq.nodeGetCurrentEditPattern();
      boolean bHavePat = (null != pat);

      pmb <= pm.addDefaultButton("New pattern", "new");
      pmb.setFontByName("big6");
      pmb.setAccelerators("lctrl-n", "");

      pmb <= pm.addDefaultButton("New pattern (sub)", "new_sub");
      pmb.setFontByName("big6");
      pmb.setAccelerators("lshift-lctrl-n", "");

      pm.addSeparator();

      pmb <= pm.addDefaultButton("Copy pattern", "copy");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lctrl-c", "");

      pmb <= pm.addDefaultButton("Paste pattern", "paste");
      pmb.setFontByName("big6");
      pmb.setAccelerators("lctrl-v", "");

      if(bHavePat)
      {
         pmb.setActive(null != pat.patGetClipboard());
      }
      else
      {
         pmb.setActive(false);
      }

      pm.addSeparator();

      pmb <= pm.addDefaultButton("Clone pattern", "clone");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lctrl-r", "");

      pmb <= pm.addDefaultButton("Clone pattern (sub)", "clone_sub");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lshift-lctrl-r", "");

      // pm.addSeparator();

      pm.resizeToMinimum();
      pm.showAboveLayer(bt_pattern_tools);
      if(_bFocusFirst)
         pm.focusNextMenuItem();

      Global.Print("Show pattern tools menu.");
   }

   // <replay.png>
   module method replayAlignNewPattern(NTS_Pattern pat) {
      pat.patHandleSongSpeedChanged(true/*bPPQ*/, true/*bBPM*/);

      int tickNr = seq.tick_nr;

      seq.nodeReset(true/*bSoft*/);

      if(seq.nodeGetCurrentEditPatternNr() == seq.nodeGetCurrentPlayPatternNr())
      {
         seq.nodeSeek(tickNr);
      }
   }

   // <ui_handle.png>
   public method toggleMicrotimeLimit() {
      seq.ui_b_microtime_range_limit = !seq.ui_b_microtime_range_limit;
      Global.Print("Microtime range limit is "+Utils.GetEnableString(seq.ui_b_microtime_range_limit));
      redraw();
   }

   // <ui_handle.png>
   module =replay= method handlePatternCut() {

      NTS_Pattern pat <= getEditPattern();

      // trace "xxx nmm: handlePatternCut: pat="+#(pat);

      if(null != pat)
      {
         undoBeginTimer();
         pat.patCopyToClipboard();
         pat.clearAllStepsAndResetTrackLengths();

         handlePatternChanged(false/*bFromUI*/);

         Global.Print("Pattern cut to clipboard.");
      }
   }

   // <ui_handle.png>
   public method handlePatternCopy() {

      NTS_Pattern pat <= getEditPattern();

      // trace "xxx nmm: handlePatternCopy: pat="+#(pat);

      if(null != pat)
      {
         pat.patCopyToClipboard();

         NTS_Pattern cb <= pat.patGetOrCreateClipboard();

         if(null != cb)
         {
            cb.parent_gid = seq.getNodeGID();
         }

         Global.Print("Pattern copied to clipboard.");
      }
   }

   // <ui_handle.png>
   public method handlePatternPaste() {
      NTS_Pattern pat <= getEditPattern();

      // trace "xxx nts: handlePatternPaste: pat="+#(pat);

      undoBeginTimer();

      if(null == pat)
      {
         handlePatternAlloc(false/*bSub*/);
         pat <= getEditPattern();
      }

      if(null != pat)
      {
         if(pat.patCopyFromClipboard())
         {
            replayAlignNewPattern(pat);
            handlePatternChanged(false/*bFromUI*/);

            updatePatternNrComboBox();

            if(null != editor_plugin)
               editor_plugin.handlePatternAllocChanged();

            Global.SuccessShort("Clipboard pasted to pattern.");
         }
      }
   }

   // <ui_handle.png>
   module =replay= method handlePatternClone(boolean _bSub) {
      NTS_Pattern patSrc <= getEditPattern();

      if(null != patSrc)
      {
         // local NTS_Pattern tmp;

         // tmp.patInit(seq, 0);

         // tmp.patCopyFrom(pat, false/*bClear*/);

         if(null != handlePatternAlloc(_bSub))
         {
            NTS_Pattern pat <= getEditPattern();

            pat.patCopyFrom(patSrc, false/*bClear*/);

            replayAlignNewPattern(pat);

            handlePatternChanged(false/*bFromUI*/);

            updatePatternNrComboBox();

            if(null != editor_plugin)
               editor_plugin.handlePatternAllocChanged();

            Global.SuccessShort("Pattern cloned to "+cm_pattern_nr.getSelectedOptionName());
         }
      }
   }

   // <ui_handle.png>
   module method handlePatternFree() {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         dlg_deletepattern <= new Dialog_DeletePattern;
         dlg_deletepattern.run(this, pat.pat_name);
      }
   }

   // <ui_handle.png>
   public virtual handlePatternFree2() {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginBuffer();
         seq.nodeSetPattern(seq.edit_pattern_nr, null);

         pat <= null;

         handlePatternChanged(false/*bFromUI*/);

         updatePatternNrComboBox();

         if(null != editor_plugin)
            editor_plugin.handlePatternAllocChanged();

         Global.Print("Delete pattern");
      }
   }

   // <method.png>
   public method clearAllTracks(boolean _bKeepTimingTrack) {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         // // undoEndTimer();  // don't end undo (live record)
         undoBeginTimer();
         pat.clearAll(_bKeepTimingTrack);

         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Clear pattern"+ (_bKeepTimingTrack ? " (keep timing track)" : ""));
      }
   }

   // <method.png>
   public method clearCursorTrack() {
      NTS_Track track <= grid.getCursorTrack();

      if(null != track)
      {
         // // undoEndTimer();  // don't end undo (live record)
         undoBeginTimer();
         track.clearAll(false/*bMod*/);

         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Clear track");
      }
   }

   // <method.png>
   public method clearTrackTrigsAndRepeats() {
      NTS_Track track <= grid.getCursorTrack();

      if(null != track)
      {
         // // undoEndTimer();  // don't end undo (live record)
         undoBeginTimer();
         track.clearTrigsAndRepeats();

         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Clear track trigs+repeats");
      }
   }

   // <method.png>
   public method clearTrackMicrotime() {
      NTS_Track track <= grid.getCursorTrack();

      if(null != track)
      {
         // // undoEndTimer();  // don't end undo (live record)
         undoBeginTimer();
         track.clearMicrotime();

         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Clear track microtime");
      }
   }

   // <method.png>
   public method clearTrackArgs() {
      NTS_Track track <= grid.getCursorTrack();

      if(null != track)
      {
         // // undoEndTimer();  // don't end undo (live record)
         undoBeginTimer();
         track.clearArgs();

         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Clear track args");
      }
   }

   // <method.png>
   public method clearTrackMods() {
      NTS_Track track <= grid.getCursorTrack();

      if(null != track)
      {
         // // undoEndTimer();  // don't end undo (live record)
         undoBeginTimer();
         track.clearMods();

         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Clear track mod1+mod2");
      }
   }

   // <method.png>
   public method clearTrackModsInit() {
      // clear track and enable modulation trigs for each step
      //  (note) when track is used as mod-only (e.g. to add additional modulation to other track)
      NTS_Track track <= grid.getCursorTrack();

      if(null != track)
      {
         // // undoEndTimer();  // don't end undo (live record)
         undoBeginTimer();
         track.clearAll(true/*bMod*/);

         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Clear track + mod init");
      }
   }

   // <ui_handle.png>
   protected method handleSelectPattern() {

      // trace "xxx cm_pattern_nr.getSelectedOption()="+cm_pattern_nr.getSelectedOption();

      int patNr = cm_pattern_nr.getSelectedOption();

      seq.nodeSetCurrentEditPatternNr(patNr);
      seq.nodeSetCurrentPlayPatternNr(patNr);

      seq.nodeQueuePrgChgOut(patNr);
      // // replay.handleNodeStateChangedUI(seq, -1/*active*/, patNr/*pat*/);

      handlePatternChanged(true/*bFromUI*/);

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         Global.Print("Select pattern "+cm_pattern_nr.getSelectedOptionName()+" \""+pat.pat_name+"\".");
      }
      else
      {
         Global.Print("Select pattern "+cm_pattern_nr.getSelectedOptionName()+" <empty>.");
      }
   }

   // <method.png>
   public virtual selectPatternByIdx(int _idx) {

      cm_pattern_nr.setSelectedOption(_idx);

      handleSelectPattern();
   }

   // <method.png>
   public virtual selectPatternByUsedIdx(int _idx) {
      if(_idx >= 0)
      {
         int patNr = seq.nodeGetPatternNrByUsedIdx(_idx);

         if(-1 != patNr)
         {
            selectPatternByIdx(patNr);
         }
      }
      else
      {
         selectPatternByIdx(127); // --/
      }
   }

   // <ui_handle.png>
   protected =replay= method handleSelectPreviousPattern() {
      byte patNr = seq.nodeGetCurrentEditPatternNr();

      if(patNr > 0)
      {
         patNr--;

         seq.nodeSetCurrentEditPatternNr(patNr);
         seq.nodeSetCurrentPlayPatternNr(patNr);

         handlePatternChanged(false/*bFromUI*/);

         seq.nodeQueuePrgChgOut(patNr);
         // // replay.handleNodeStateChangedUI(seq, -1/*active*/, patNr/*pat*/);
      }
   }

   // <ui_handle.png>
   protected =replay= method handleSelectNextPattern() {
      byte patNr = seq.nodeGetCurrentEditPatternNr();

      if(patNr < 127)
      {
         patNr++;

         seq.nodeSetCurrentEditPatternNr(patNr);
         seq.nodeSetCurrentPlayPatternNr(patNr);


         handlePatternChanged(false/*bFromUI*/);

         seq.nodeQueuePrgChgOut(patNr);
         // // replay.handleNodeStateChangedUI(seq, -1/*active*/, patNr/*pat*/);
      }
   }

   // <ui_handle.png>
   protected method handleSelectPreviousUsedPattern() {
      int patIdx = seq.nodeGetCurrentEditPatternNr();
      patIdx = seq.nodeFindPreviousPatternNrByUsedIdxWithOffset(patIdx-1, 0);

      if(patIdx >= 0)
      {
         selectPatternByIdx(patIdx);
      }
   }

   // <ui_handle.png>
   protected method handleSelectNextUsedPattern() {
      int patIdx = seq.nodeGetCurrentEditPatternNr();
      patIdx = seq.nodeFindNextPatternNrByUsedIdxWithOffset(patIdx+1, 0);

      if(patIdx >= 0)
      {
         selectPatternByIdx(patIdx);
      }
   }

   // <method.png>
   public method selectTrack(int _trackIdx) {
      grid.setCursorYAndMakeVisible(_trackIdx);
   }

   // <ui_handle.png>
   protected method handlePatternNameChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.pat_name = tf_pattern_name.getText();
         tf_pattern_name2.setText(pat.pat_name);

         Global.Print("Pattern name is \""+pat.pat_name+"\".");
      }
   }

   // <ui_handle.png>
   protected method handlePatternName2Changed() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.pat_name = tf_pattern_name2.getText();
         tf_pattern_name.setText(pat.pat_name);

         Global.Print("Pattern name is \""+pat.pat_name+"\".");
      }
   }

   // <ui_handle.png>
   protected method handleMasterLen16thChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.setMasterLen16th(fp_pattern_masterlen16th.getFloatValue());

         Global.Print("Master Length (#16th) is "+pat.master_len_16th);
      }
   }

   // <ui_handle.png>
   protected method handleArg3OffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.setArg3Offset(fp_arg3_offset.getFloatValue());

         updateArg3NoteNames(pat);

         Global.Print("Arg 3 offset is "+pat.arg3_offset);
      }
   }

   // <ui_handle.png>
   protected method handlePitchbendRangeUpChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.setPitchbendRangeUp(fp_pb_up.getFloatValue());

         if(VMOD_LALT == UI.GetKeyMod())
         {
            pat.setPitchbendRangeDown(pat.pitchbend_range_up);
            fp_pb_down.setValue(pat.pitchbend_range_down);
            Global.Print("Pitchbend Range Up+Down is "+pat.pitchbend_range_up);
         }
         else
         {
            Global.Print("Pitchbend Range Up is "+pat.pitchbend_range_up);
         }
      }
   }

   // <ui_handle.png>
   protected method handlePitchbendRangeDownChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.setPitchbendRangeDown(fp_pb_down.getFloatValue());

         if(VMOD_LALT == UI.GetKeyMod())
         {
            pat.setPitchbendRangeUp(pat.pitchbend_range_down);
            fp_pb_up.setValue(pat.pitchbend_range_up);
            Global.Print("Pitchbend Range Up+Down is "+pat.pitchbend_range_down);
         }
         else
         {
            Global.Print("Pitchbend Range Down is "+pat.pitchbend_range_down);
         }
      }
   }

   // <ui_handle.png>
   protected method handleDefaultNoteDurationOffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.setDefaultNoteDurationOffset(fp_note_dur_offset.getFloatValue());

         Global.Print("Default Note Duration offset is "+pat.default_note_duration_offset);
      }
   }

   // <ui_handle.png>
   protected method handleNoteNamesChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         if(0 == cm_notenames.getSelectedOption())
         {
            pat.note_name_profile_id <= null;  // Numbers
         }
         else
         {
            pat.note_name_profile_id <= Object(cm_notenames.getSelectedOptionName());
         }

         handlePatternChanged(false/*bFromUI*/);
         grid.redraw();

         Global.Print("Note Names Profile is \""+cm_notenames.getSelectedOptionName()+"\"");
      }
   }

   // <ui_handle.png>
   protected method rescanNoteNameProfiles() {
      MIDI.InitMIDINoteNames();
      updateNoteNameProfileOptions();
      updatePatternNoteNameProfileSelection();
      Global.Print("Rescan note name profiles: found "+(MIDI.note_name_profiles.numElements)+" profile(s)");
   }

   // <ui_handle.png>
   protected method handleSwingOffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.setSwingOffset(fp_swing_offset.getFloatValue());

         Global.Print("Swing offset is "+int(100 * pat.swing_offset)+"%");
      }
   }

   // <ui_handle.png>
   protected method handleVelocityJitterOffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.setVelocityJitterOffset(fp_velocity_jitter_offset.getFloatValue());

         Global.Print("Velocity jitter offset is "+int(100 * pat.velocity_jitter_offset)+"%");
      }
   }

   // <ui_handle.png>
   protected method handleMicrotimeJitterOffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.setMicrotimeJitterOffset(fp_microtime_jitter_offset.getFloatValue());

         Global.Print("Microtime jitter offset is "+int(100 * pat.microtime_jitter_offset)+"%");
      }
   }

   // <ui_handle.png>
   protected method handleMod1JitterOffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.setMod1JitterOffset(fp_mod1_jitter_offset.getFloatValue());

         Global.Print("Mod1 jitter offset is "+int(100 * pat.mod1_jitter_offset)+"%");
      }
   }

   // <ui_handle.png>
   protected method handleMod2JitterOffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.setMod2JitterOffset(fp_mod2_jitter_offset.getFloatValue());

         Global.Print("Mod2 jitter offset is "+int(100 * pat.mod2_jitter_offset)+"%");
      }
   }

   // <ui_handle.png>
   protected method handleQuantOffsetChanged() {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.setQuantizationOffset(fp_quant_offset.getFloatValue());

         Global.Print("Quantization offset is "+int(100 * pat.quantization_offset)+"%");
      }
   }

   // <ui_handle.png>
   protected method handleBeatHighlightStepModuloChanged() {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.step_modulo_16th = fp_step_highlight_modulo.getFloatValue();

         Global.Print("Beat Highlight Step Modulo is "+pat.step_modulo_16th+" 16th");
      }
   }

   // <ui_handle.png>
   protected method handleBarModuloChanged() {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.bar_modulo_16th = fp_bar_modulo.getFloatValue();

         Global.Print("Bar Modulo is "+pat.bar_modulo_16th+" 16th");
      }
   }

   // <ui_handle.png>
   protected method handleTrackArg3ChangedFP(FloatParam fp, NTS_Track _track) {
      float c = fp.getFloatValue();
      if(FloatParam.DISPLAY_USER == fp.getDisplayType())
         c -= 127;
      _track.setArg3(c);

      grid.redraw();  // chromatic mode

      Global.Print("Track "+(_track.track_nr+1)+" arg 3 is "+_track.arg3);
   }

   // <ui_handle.png>
   protected method handleTrackArg3ChangedCM(ComboBox cm, NTS_Track _track) {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         _track.setArg3(cm.getSelectedOption() - pat.arg3_offset);
      }

      Global.Print("Track "+(_track.track_nr+1)+" arg 3 is "+_track.arg3+" ("+cm.getSelectedOptionName()+")");
   }

   // <ui_handle.png>
   protected method handleTrackPlayLengthChanged(FloatParam fp, NTS_Track _track) {
      // fp == NTS_TrackForm.fp_numsteps
      NTS_Pattern pat <= getEditPattern();
      float playLen = fp.getFloatValue();
      _track.setPlayLength(playLen, pat);

      float patTicks = (seq.nodeGetPatternNumTicks(pat.pat_nr));
      float num16th = (patTicks / current_song.getNumTicksPer16th());
      float numBeats = (patTicks / current_song.getNumTicksPerBeat());
      float numBars = (patTicks / current_song.getNumTicksPerBar());
      Global.Print("Track "+(_track.track_nr+1)+" play length is "+_track.play_length+" (patlen="+num16th+" 16th, "+numBeats+" beat"+Utils.GetPluralString(numBeats)+", "+numBars+" bar"+Utils.GetPluralString(numBars)+")");

      if(pat.master_len_16th > 0.0f)
      {
         float stepNumTicks = _track.getStepNoteLengthTicks();
         float trackNumTicks = playLen * stepNumTicks;
         float masterLenNumTicks = current_song.getNumTicksPer16th() * pat.master_len_16th;
         if(trackNumTicks > masterLenNumTicks)
            Global.Warning("Track "+(_track.track_nr+1)+" play length ticks="+trackNumTicks+" > masterLenTicks="+masterLenNumTicks);
      }

      handlePatternChanged(false/*bFromUI*/);
      grid.redraw();
      queueRelayoutStepDetails();
   }

   // <ui_handle.png>
   protected method handleTrackNameChanged(TextField tf, NTS_Track _track) {
      _track.name = tf.getText();

      Global.Print("Track "+(_track.track_nr+1)+" name is \""+_track.name+"\"");
   }

   // <ui_handle.png>
   protected method handleTrackQuantAmountChanged(FloatParam fp, NTS_Track _track) {
      _track.setQuantizationAmount(fp.getFloatValue());

      Global.Print("Track "+(_track.track_nr+1)+" quantization amount is "+int(100 * _track.quantization_amount)+"%");

      grid.redraw();
   }

   // <ui_handle.png>
   protected method handleTrackSwingAmountChanged(FloatParam fp, NTS_Track _track) {
      _track.setSwingAmount(fp.getFloatValue());

      Global.Print("Track "+(_track.track_nr+1)+" swing amount is "+int(100 * _track.swing_amount)+"%");

      grid.redraw();
   }

   // <ui_handle.png>
   protected method handleTrackNoteLenChanged(ComboBox cm, NTS_Track _track) {
      NTS_Pattern pat <= getEditPattern();
      _track.setStepNoteLength(cm.getSelectedOption(), pat);

      float patTicks = (seq.nodeGetPatternNumTicks(pat.pat_nr));
      float num16th = (patTicks / current_song.getNumTicksPer16th());
      float numBeats = (patTicks / current_song.getNumTicksPerBeat());
      float numBars = (patTicks / current_song.getNumTicksPerBar());
      Global.Print("Track "+(_track.track_nr+1)+" note length is "+cm.getSelectedOptionName()+" ("+_track.getStepNoteLengthTicks()+" ticks) (patlen="+num16th+" 16th, "+numBeats+" beat"+Utils.GetPluralString(numBeats)+", "+numBars+" bar"+Utils.GetPluralString(numBars)+")");

      grid.redraw();
   }

   // <ui_handle.png>
   protected method handleTrackMuteChanged() {
      // NTS_Track track <= getSelectedGroup();

      // if(null != grp)
      // {
      //    track.setEnableMute(cb_group.isSelected());

      //    Global.Print("Group is "+Utils.GetEnableString(grp.b_enable));
      // }
   }

   // <method.png>
   module method focusTrackNumSteps(int _trackIdx) {
      NTS_TrackForm tform <= track_forms.get(_trackIdx);
      if(null != tform)
      {
         UI.SetKeyboardFocus(tform.fp_numsteps);
         tform.fp_numsteps.selectAll();
      }
   }

   // <method.png>
   module method focusTrackQuantAmount(int _trackIdx) {
      NTS_TrackForm tform <= track_forms.get(_trackIdx);
      if(null != tform)
      {
         UI.SetKeyboardFocus(tform.fp_quant);
         tform.fp_quant.selectAll();
      }
   }

   // <method.png>
   module method focusTrackSwingAmount(int _trackIdx) {
      NTS_TrackForm tform <= track_forms.get(_trackIdx);
      if(null != tform)
      {
         UI.SetKeyboardFocus(tform.fp_swing);
         tform.fp_swing.selectAll();
      }
   }

   // <method.png>
   module method focusTrackArg3(int _trackIdx) {
      NTS_TrackForm tform <= track_forms.get(_trackIdx);
      if(null != tform)
      {
         if(0 == (tform.ls_arg3.getCurrentChildNr()))
         {
            UI.SetKeyboardFocus(tform.fp_arg3);
            tform.fp_arg3.selectAll();
         }
         else
         {
            UI.SetKeyboardFocus(tform.cm_arg3);
         }
      }
   }

   // <method.png>
   public method toggleSoloState(int _trackNr) {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.toggleSoloState(_trackNr);

         Global.Print("Toggle solo track "+(_trackNr+1));

         updateTrackForms();
      }
   }

   // <method.png>
   public method toggleMuteState(int _trackNr) {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.toggleMuteState(_trackNr);

         Global.Print("Toggle mute track "+(_trackNr+1));

         updateTrackForms();
      }
   }

   // <method.png>
   module method focusTrackNoteLen(int _trackIdx) {
      NTS_TrackForm tform <= track_forms.get(_trackIdx);
      if(null != tform)
      {
         UI.SetKeyboardFocus(tform.cm_notelen);
      }
   }

   // <ui_update.png>
   protected method updateNodeClass() {
      cm_node_class.setSelectedOption(seq.getNodeClassId());
      cb_node_class_show.setSelected(seq.getEnableNodeClassShow());
   }

   // <ui_handle.png>
   protected method handleNodeClassChanged() {
      seq.setNodeClassId(cm_node_class.getSelectedOption());

      f_autodev.handleNodeClassChanged();

      Global.Print("Node class is \""+seq.getNodeClassString()+"\"");
   }

   // <ui_handle.png>
   protected method handleNodeClassShowChanged() {
      seq.setEnableNodeClassShow(cb_node_class_show.isSelected());

      f_autodev.handleNodeClassShowChanged();

      Global.Print("Node class show is "+Utils.GetEnableString(seq.getEnableNodeClassShow()));
   }

   // <ui_handle.png>
   protected method handlePlayOutDevChanged() {

      seq.setOutDevIdx(MIDI.SortedToUnsortedDevIdx(cm_play_out_dev.getSelectedOption()));

      cm_play_out_ch.setOptionsLong(MIDI.GetMIDISynthProfileCaptionOptionsByOutDevIdx(seq.getOutDevIdx(), null/*firstOptionOrNull*/));

      Global.Print("Output dev is \""+cm_play_out_dev.getSelectedOptionName()+"\"");
   }

   // <ui_handle.png>
   protected method handlePlayOutChChanged() {

      seq.setOutCh(cm_play_out_ch.getSelectedOption());

      Global.Print("Output channel is "+cm_play_out_ch.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayOutputModeChanged() {
      seq.setOutputMode(cm_play_out_mode.getSelectedOption());
      updatePatArg3Label();

      Global.Print("Output mode is "+cm_play_out_mode.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRecUnmapTypeChanged() {
      seq.setRecUnmapType(cm_play_rec_unmap.getSelectedOption());

      Global.Print("Rec unmap type is "+cm_play_rec_unmap.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRecModUnmapChanged() {
      seq.setEnableRecModUnmap(cb_play_rec_mod_unmap.isSelected());

      Global.Print("Rec Mod Out Unmap is "+Utils.GetEnableStringMixed(seq.b_rec_mod_unmap, "enabled", "disabled", "enabled(when editor is visible)"));
   }

   // <ui_handle.png>
   protected method handlePlayExtClkChanged() {
      seq.setEnableExtClk(cb_play_extclk.isSelected());

      Global.Print("Ext.Clk is "+Utils.GetEnableString(seq.b_extclk));
   }

   // <ui_handle.png>
   protected method handleSpeedSclResetValChanged() {
      seq.setSpeedSclResetVal(fp_speed_scl_reset.getFloatValue());
      if(seq.rpn_com_speed_scl_reset_val > 0)
      {
         local Float fo = seq.rpn_com_speed_scl_reset_val;
         Global.Print("Speed reset value is "+fo.printf("%3.3f"));
      }
      else
      {
         Global.Print("Speed reset value is <not set>");
      }
   }

   // <ui_handle.png>
   protected method handlePlayRepeatStartModeChanged() {
      seq.setRepeatStartMode(cm_play_repeat_start_mode.getSelectedOption());

      Global.Print("Repeat start mode is "+cm_play_repeat_start_mode.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRepeatStartQuantizationChanged() {
      seq.setRepeatStartQuantization(cm_play_repeat_start_quantization.getSelectedOption() - 1);

      Global.Print("Repeat start quantization is "+cm_play_repeat_start_quantization.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRepeatLenChanged() {
      seq.setRepeatNoteLength(cm_play_repeat_len.getSelectedOption() - 1);

      Global.Print("Repeat length is "+cm_play_repeat_len.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayNumRepeatsChanged() {
      seq.setNumRepeats(cm_play_num_repeats.getSelectedOption() - 1);

      Global.Print("Num Repeats is "+cm_play_num_repeats.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRecEnableChanged() {
      // Recording mode (lctrl-x RSHIFT)
      seq.setEnableRec(cb_play_rec_enable.isSelected());
      if(maybe == seq.b_rec)
         Global.Print("Allow recording when node has edit focus");
      else if(false == seq.b_rec)
         Global.Print("Don't allow recording");
      else
         Global.Print("Allow recording");
   }

   // <ui_handle.png>
   protected method handlePlayRecPrevChanged() {
      seq.setEnableRecPrev(cb_play_rec_prev.isSelected());
      Global.Print("Previous output recording is "+Utils.GetEnableString(seq.b_rec_prev));
   }

   // <ui_handle.png>
   protected method handlePlayRecMuteRepeatChanged() {
      seq.setEnableRecMuteRepeat(cb_play_rec_mute_repeat.isSelected());
      Global.Print("Record mute + repeat is "+Utils.GetEnableString(seq.b_rec_mute_repeat));
   }

   // <ui_handle.png>
   protected method handlePlayRecDevChanged() {
      seq.setRecDevIdx(MIDI.SortedToUnsortedDevIdx(cm_play_rec_dev.getSelectedOption() - 1));

      cm_play_rec_ch.setOptionsLong(MIDI.GetMIDISynthProfileCaptionOptionsByOutDevIdx(seq.rec_dev_idx, "*"/*firstOptionOrNull*/));
      Global.Print("Record device is "+cm_play_rec_dev.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRecChChanged() {
      seq.setRecCh(cm_play_rec_ch.getSelectedOption() - 1);

      Global.Print("Record channel is "+cm_play_rec_ch.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRecQuantizeChanged() {
      seq.setEnableRecQuantize(cb_play_rec_quantize.isSelected());
      Global.Print("Record quantization is "+Utils.GetEnableString(seq.b_rec_quantize));
   }

   // <ui_handle.png>
   protected method handlePlayPluginDevChanged() {
      int opt = cm_play_plugin_dev.getSelectedOption();
      if(opt > 0)
         seq.setPluginDevIdx(plugin_dev_options.get(opt - 1));
      else
         seq.setPluginDevIdx(-1);

      leaveEditorPlugin();
      showEditorPlugin();

      Global.Print("Plugin device is "+cm_play_plugin_dev.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayPluginSceneChanged() {
      int k = cm_play_plugin_scene.getSelectedOption();
      seq.plugin_scene_group_idx = k / MIDIMorphScene.NUM_SCENES_PER_GROUP;
      seq.plugin_scene_idx       = k % MIDIMorphScene.NUM_SCENES_PER_GROUP;

      leaveEditorPlugin();
      showEditorPlugin();

      Global.Print("Plugin map-scene is "+cm_play_plugin_scene.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected =replay= method handlePlayFollowArrChanged() {
      STConfig.b_node_trig_seq_edit_pattern_follows_replay_pattern = cb_play_followarr.isSelected();
      Global.Print("Edit pattern follows replay is "+(STConfig.b_node_trig_seq_edit_pattern_follows_replay_pattern ? "enabled (follow arranger)" : "disabled"));
   }

   // <ui_handle.png>
   protected =replay= method handlePlayStepOffChanged() {
      STConfig.node_trig_seq_step_label_offset = cb_play_stepoff.isSelected();
      Global.Print("Step label offset is "+(STConfig.node_trig_seq_step_label_offset ? "0 (0, 1, 2, 3, 4, ..)" : "1 (1, 2, 3, 4, 5, ..)"));
   }

   // <method.png>
   public method initArg3FromPreset(int _presetIdx) {
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         StringArray a <= STConfig.node_trig_seq_preset_arg3.get(_presetIdx);

         if(null != a)
         {
            pat.initArg3FromPreset(a);

            Global.Print("Init Arg3 from preset \""+a.get(0)+"\"");

            handlePatternChanged(false/*bFromUI*/);
         }
      }
   }

   // <method.png>
   public method initTrackNamesFromMIDINoteNames() {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         int trackIdx = 0;
         loop(NTS_Pattern.NUM_TRACKS)
         {
            NTS_Track *track <= pat.getTrackByIndex(trackIdx);

            if(null != track)
            {
               StringArray noteNames <= MIDI.note_name_profiles.get(track.getCurrentNoteNameProfileId(pat));

               String noteName <= noteNames.get(track.arg3 + pat.arg3_offset);
               int idx = noteName.indexOfChar(':', 0);
               if(-1 != idx)
                  track.name = noteName.substring(idx+1, 99);
               else
                  track.name = noteName;
            }

            trackIdx++;
         }

         Global.Print("Init track names from MIDI note name profile(s)");
         handlePatternChanged(false/*bFromUI*/);
      }
   }

   // <method.png>
   public method initTrackNamesFromPreset(int _presetIdx) {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         StringArray sa <= STConfig.node_trig_seq_preset_track_names.get(_presetIdx);

         int trackIdx = 0;
         loop(NTS_Pattern.NUM_TRACKS)
         {
            NTS_Track *track <= pat.getTrackByIndex(trackIdx);

            if(null != track)
            {
               String trackName <= sa.get(trackIdx + 1);

               if(null != trackName)
               {
                  track.name = trackName;
               }
               else
               {
                  track.name = "-";
               }
            }

            trackIdx++;
         }

         Global.Print("Init track name preset \""+sa.get(0)+"\"");
         handlePatternChanged(false/*bFromUI*/);
      }
   }

   // <ui_show.png>
   module method showContextMenu(boolean _bFocusFirst) {
      // Create context-sensitive popupmenu
      pm_ctx <= PopupMenu.New(this);
      PopupMenu pm <= pm_ctx;
      PopupMenuButton *pmb;

      boolean bHavePattern = (null != getEditPattern());

      pmb <= pm.addCheckButton("Fold tracks", b_folded, "toggle_fold_tracks");
      pmb.setAccelerators("", "f");

      pm.addSeparator();

      pmb <= pm.addDefaultButton("Track Setup..", "show_track_setup");
      pmb.setAccelerators("", "t");

      pm.addSeparator();

      pmb <= pm.addDefaultButton("Euclidean Rhythm..", "show_euclid");
      pmb.setAccelerators("", "e");

      pm.addSeparator();

      pmb <= pm.addDefaultButton("Remap tracks to note-name profile", "remap_tracks");
      pmb.setActive(bHavePattern);
      pmb.setAccelerators("", "lctrl-x m");
      pmb.setToolTipCaption("Remap tracks to currently selected note-name profile\n\n (note) e.g. after Monitor pattern import\n\n (note) see Pattern tab");

      pmb <= pm.addDefaultButton("Try revert to global output", "revert_to_global_out");
      pmb.setActive(bHavePattern);
      pmb.setAccelerators("", "lctrl-x t");
      pmb.setToolTipCaption("Check if all patterns and tracks share a common output port and revert node output to that if possible\n\n (note) lctrl-x t");

      pm.addSeparator();


      StringArray *sa;
      int presetIdx = 0;
      PopupMenu *spm2;

      PopupMenu spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Init track arg 3", deref spm);

      // Arg 3 presets
      presetIdx = 0;
      foreach sa in STConfig.node_trig_seq_preset_arg3
      {
         if(sa.numElements > 1)
         {
            pmb <= spm.addDefaultButton("Init track arg 3: "+sa.get(0), "initarg3_"+presetIdx);
            pmb.setActive(bHavePattern);
         }
         presetIdx++;
      }

      pm.addSeparator();

      // Track names
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Init track names", deref spm);

      pmb <= spm.addDefaultButton("Init track names: <from MIDI note names>", "inittracknames_mnn");
      pmb.setActive(bHavePattern);

      presetIdx = 0;
      foreach sa in STConfig.node_trig_seq_preset_track_names
      {
         if(sa.numElements > 1)
         {
            pmb <= spm.addDefaultButton("Init track names: "+sa.get(0), "inittracknames_"+presetIdx);
            pmb.setActive(bHavePattern);
         }
         presetIdx++;
      }

      // Track submenu
      pm.addSeparator();
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Track", deref spm);

      spm2 <= PopupMenu.New(spm);
      pmb <= spm.addMenu("Clear", deref spm2);

      pmb <= spm2.addDefaultButton("Clear track", "track_clear");
      pmb.setAccelerators("lshift-BACKSPACE", "lctrl-f3");

      pmb <= spm2.addDefaultButton("Clear track trigs+repeats", "track_clear_trigs_and_repeats");
      pmb.setAccelerators("", "BACKSPACE");

      pmb <= spm2.addDefaultButton("Clear track microtiming", "track_clear_microtime");
      pmb.setAccelerators("", "lalt-BACKSPACE");

      pmb <= spm2.addDefaultButton("Clear track arg1+arg2", "track_clear_args");
      pmb.setAccelerators("", "lctrl-BACKSPACE");

      pmb <= spm2.addDefaultButton("Clear track mod1+mod2", "track_clear_mods");
      pmb.setAccelerators("", "lctrl-lalt-BACKSPACE");

      pmb <= spm2.addDefaultButton("Clear track + mod init", "track_clear_mod_init");
      pmb.setAccelerators("", "lshift-lalt-BACKSPACE");

      spm.addSeparator();
      spm2 <= PopupMenu.New(spm);
      pmb <= spm.addMenu("Load arg2/mod1/mod2", deref spm2);

      pmb <= spm2.addDefaultButton("Load arg2 0", "track_load_arg2_0");
      pmb <= spm2.addDefaultButton("Load arg2 identity (0,1,2,..)", "track_load_arg2_identity");
      pmb.setAccelerators("", "lshift-k");

      pmb <= spm2.addDefaultButton("Load mod1 0", "track_load_mod1_0");
      pmb <= spm2.addDefaultButton("Load mod1 64", "track_load_mod1_64");

      pmb <= spm2.addDefaultButton("Load mod2 0", "track_load_mod2_0");
      pmb <= spm2.addDefaultButton("Load mod2 64", "track_load_mod2_64");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Reverse track trigs", "track_reverse");
      pmb.setAccelerators("", "r");

      spm.addSeparator();
      spm2 <= PopupMenu.New(spm);
      pmb <= spm.addMenu("Randomize", deref spm2);

      pmb <= spm2.addDefaultButton("Randomize trigs", "track_rand_trigs");
      pmb.setAccelerators("", "j");

      pmb <= spm2.addDefaultButton("Randomize repeats", "track_rand_repeats");
      pmb.setAccelerators("", "lctrl-j");

      pmb <= spm2.addDefaultButton("Randomize arg1 (vel)", "track_rand_arg1");
      pmb.setAccelerators("", "lshift-j");

      pmb <= spm2.addDefaultButton("Randomize mod1", "track_rand_mod1");
      pmb.setAccelerators("", "lshift-1");

      pmb <= spm2.addDefaultButton("Randomize mod2", "track_rand_mod2");
      pmb.setAccelerators("", "lshift-2");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Rotate left", "track_rotate_left");
      pmb.setAccelerators("", "o");

      pmb <= spm.addDefaultButton("Rotate right", "track_rotate_right");
      pmb.setAccelerators("", "p");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Insert step", "track_insert_step");
      pmb.setAccelerators("", "INSERT");

      pmb <= spm.addDefaultButton("Delete step", "track_delete_step");
      pmb.setAccelerators("", "DELETE");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Increment length", "track_inc_len");
      pmb.setAccelerators("", "lshift-PAGEUP");
      pmb <= spm.addDefaultButton("Decrement length", "track_dec_len");
      pmb.setAccelerators("", "lshift-PAGEDOWN");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Increment def. note duration", "track_inc_notedur");
      pmb.setAccelerators("", "lalt-RIGHT");
      pmb <= spm.addDefaultButton("Decrement def. note duration", "track_dec_notedur");
      pmb.setAccelerators("", "lalt-LEFT");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Toggle solo", "track_toggle_solo");
      pmb.setAccelerators("", "s");
      pmb <= spm.addDefaultButton("Toggle mute", "track_toggle_mute");
      pmb.setAccelerators("", "d");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Focus num steps", "track_focus_num_steps");
      pmb.setAccelerators("", "lctrl-l");

      pmb <= spm.addDefaultButton("Focus swing amount", "track_focus_swing_amount");
      pmb.setAccelerators("", "lctrl-h");

      pmb <= spm.addDefaultButton("Focus note length", "track_focus_note_len");
      pmb.setAccelerators("", "lctrl-t");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Cut track to clipboard", "track_cut");
      pmb.setAccelerators("", "lshift-x");
      pmb <= spm.addDefaultButton("Copy track to clipboard", "track_copy");
      pmb.setAccelerators("", "lshift-c");
      pmb <= spm.addDefaultButton("Paste track clipboard", "track_paste");
      pmb.setAccelerators("", "lshift-v");
      pmb <= spm.addDefaultButton("Paste track clipboard to all patterns..", "track_paste_all");
      pmb.setAccelerators("", "lctrl-lshift-v");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Edit track sound", "track_editsound");
      pmb.setToolTipCaption("Edit track sound\n\n (note) SysEx, AnalogRytm, or Eureka sample / plugin\n\n (note) 'k'");
      pmb.setAccelerators("", "k");


      // Pattern submenu
      pm.addSeparator();
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Pattern", deref spm);

      pmb <= spm.addDefaultButton("Clear pattern", "pattern_clear");
      pmb.setAccelerators("lctrl-lshift-BACKSPACE", "lshift-f3");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Reverse pattern trigs", "pattern_reverse");
      pmb.setAccelerators("", "lshift-r");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Rotate left", "pattern_rotate_left");
      pmb.setAccelerators("", "lshift-o");

      pmb <= spm.addDefaultButton("Rotate right", "pattern_rotate_right");
      pmb.setAccelerators("", "lshift-p");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Insert step", "pattern_insert_step");
      pmb.setAccelerators("", "lshift-INSERT");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Delete step", "pattern_delete_step");
      pmb.setAccelerators("", "lshift-DELETE");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Cut to clipboard", "pattern_cut");
      pmb.setAccelerators("", "lctrl-w");

      pmb <= spm.addDefaultButton("Copy to clipboard", "pattern_copy");
      pmb.setAccelerators("", "lctrl-c");

      pmb <= spm.addDefaultButton("Paste clipboard", "pattern_paste");
      pmb.setAccelerators("", "lctrl-v");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Clone pattern", "pattern_clone");
      pmb.setAccelerators("", "lctrl-r");

      pmb <= spm.addDefaultButton("Clone pattern (sub)", "pattern_clone_sub");
      pmb.setAccelerators("", "lctrl-lshift-r");


      // Step submenu
      pm.addSeparator();
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Step", deref spm);

      PopupMenu sspm <= PopupMenu.New(spm);
      pmb <= spm.addMenu("Move cursor", deref sspm);

      pmb <= sspm.addDefaultButton("Move cursor left", "step_cursor_left");
      pmb.setAccelerators("", "LEFT");

      pmb <= sspm.addDefaultButton("Move cursor right", "step_cursor_right");
      pmb.setAccelerators("", "RIGHT");

      pmb <= sspm.addDefaultButton("Move cursor up", "step_cursor_up");
      pmb.setAccelerators("", "UP");

      pmb <= sspm.addDefaultButton("Move cursor down", "step_cursor_down");
      pmb.setAccelerators("", "DOWN");

      spm.addSeparator();
      sspm <= PopupMenu.New(spm);
      pmb <= spm.addMenu("Move step", deref sspm);

      pmb <= sspm.addDefaultButton("Move step left", "step_move_left");
      pmb.setAccelerators("", "lctrl-LEFT");

      pmb <= sspm.addDefaultButton("Move step right", "step_move_right");
      pmb.setAccelerators("", "lctrl-RIGHT");

      pmb <= sspm.addDefaultButton("Move step up", "step_move_up");
      pmb.setAccelerators("", "lctrl-UP");

      pmb <= sspm.addDefaultButton("Move step down", "step_move_down");
      pmb.setAccelerators("", "lctrl-DOWN");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Toggle trig", "step_toggle_trig");
      pmb.setAccelerators("", "SPACE");
      pmb.setToolTipCaption("Toggle trig\n\n (note) right mouse button click");

      pmb <= spm.addDefaultButton("Toggle repeat", "step_toggle_repeat");
      pmb.setAccelerators("", "lctrl-SPACE");
      pmb.setToolTipCaption("Toggle trig repeat\n\n (note) middle mouse button click");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Play steps", "step_play");
      pmb.setAccelerators("", "RETURN");
      pmb <= spm.addDefaultButton("Play track trigger", "track_trigger");
      pmb.setAccelerators("", "w");
      pmb <= spm.addDefaultButton("Play track step", "track_step");
      pmb.setAccelerators("", "lshift-w");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Cut step", "step_cut");
      pmb.setAccelerators("", "x");

      pmb <= spm.addDefaultButton("Copy step", "step_copy");
      pmb.setAccelerators("", "c");

      pmb <= spm.addDefaultButton("Paste step", "step_paste");
      pmb.setAccelerators("", "v");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Set step arg1 = 0", "step_arg1_0");
      pmb.setAccelerators("", "1");

      pmb <= spm.addDefaultButton("Set step arg1 = 1", "step_arg1_1");
      pmb.setAccelerators("", "2");

      pmb <= spm.addDefaultButton("Set step arg1 = 2", "step_arg1_2");
      pmb.setAccelerators("", "3");

      pmb <= spm.addDefaultButton("Set step arg1 = 3", "step_arg1_3");
      pmb.setAccelerators("", "4");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Inc step arg2 by 1", "step_arg2_inc_fine");
      pmb.setAccelerators("", "lctrl-x RIGHT");

      pmb <= spm.addDefaultButton("Inc step arg2 by 4", "step_arg2_inc_coarse");
      pmb.setAccelerators("", "lctrl-x UP");

      pmb <= spm.addDefaultButton("Dec step arg2 by 1", "step_arg2_dec_fine");
      pmb.setAccelerators("", "lctrl-x LEFT");

      pmb <= spm.addDefaultButton("Dec step arg2 by 4", "step_arg2_dec_coarse");
      pmb.setAccelerators("", "lctrl-x DOWN");


      spm.addSeparator();
      pmb <= spm.addDefaultButton("Microtime Dec 1 Tick", "step_microtime_dec");
      pmb.setAccelerators("", "lshift-LEFT");

      pmb <= spm.addDefaultButton("Microtime Inc 1 Tick", "step_microtime_inc");
      pmb.setAccelerators("", "lshift-RIGHT");

      spm.addSeparator();
      pmb <= spm.addDefaultButton("Toggle Microtime Limit", "step_microtime_limit");
      pmb.setAccelerators("", "h");


      // Capture submenu
      pm.addSeparator();
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Capture", deref spm);

      pmb <= spm.addDefaultButton("Start output capture", "capture_start");
      pmb.setAccelerators("", "lctrl-x c");
      pmb.setToolTipCaption("Start output capture\n\n (note) stops when replay is stopped\n\n (note) result can be pasted via lctrl-x v");

      pmb <= spm.addDefaultButton("Paste output capture", "capture_paste");
      pmb.setAccelerators("", "lctrl-x v");
      pmb.setToolTipCaption("Paste output capture buffer\n\n (note) capture buffer is shared between all nodes");

      pmb <= spm.addCheckButton("Use ticks instead of millisec", STConfig.b_node_monitor_capture_tick_timebase, "capture_ticks");
      pmb.setToolTipCaption("When enabled, use ticks instead of millisec as capture timebase.\n\n (note) ticks are (slightly) more precise\n (note) millisec capture timing modulations");


      // Import submenu
      pm.addSeparator();
      spm <= PopupMenu.New(pm);
      pmb <= pm.addMenu("Import", deref spm);

      pmb <= spm.addDefaultButton("Import from Analog Rytm..", "import_ar");
      pmb.setAccelerators("lshift-F7", "");

      pmb <= spm.addDefaultButton("Import from Monitor..", "import_mon");
      pmb.setAccelerators("lshift-F9", "");


      pm.addSeparator();
      pmb <= pm.addDefaultButton("Toggle MIDI live recording", "toggle_recording");
      pmb.setAccelerators("", "RCTRL");
      pmb.setToolTipCaption("Toggle MIDI live recording\n\n (note) Sets new undo state");

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Undo / redo", "undo_redo");
      pmb.setAccelerators("", "u");
      pmb.setToolTipCaption("Undo / redo\n\n (note) toggle live recording with LCTRL to set new undo state");

      pm.showAtXY(UI.GetMouseX(), UI.GetMouseY());
      if(_bFocusFirst)
         pm.focusNextMenuItem();
   }

   // <ui_show.png>
   public method showTrackSetupDialog() {

      NTS_Pattern pat <= seq.nodeGetCurrentEditPattern();

      if(null != pat)
      {
         dlg_track_setup.run(this);
      }
      else
      {
         Global.Warning("showTrackSetupDialog: pattern is not allocated.");
      }
   }

   // <ui_handle.png>
   public method undoRedo(boolean _bForceUndo, boolean _bSaveRedo) {
      // (note) NTS_EuclidDialog calls this directly to force undo w/o redo
      if(seq.b_undone && !_bForceUndo)
      {
         seq.redo();
         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Redo");
      }
      else
      {
         seq.undo(_bSaveRedo);
         handlePatternChanged(false/*bFromUI*/);
         Global.Print("Undo");
      }
   }

   // <ui_handle.png>
   public method handleUndoRedo(boolean _bSaveRedo) {
      // (note) always undo during recording (discard last take, don't redo)
      boolean bAllowRedo = !(seq.b_recording && replay.b_playing);
      if(bAllowRedo)
         undoEndTimer();
      undoRedo(!bAllowRedo/*bForceUndo*/, _bSaveRedo);
   }

   // <ui_handle.png>
   public method toggleRecording() {
      if(!seq.b_recording)
      {
         seq.startRec();
         undoBeginTimer();
         Global.Print("Recording is ACTIVE");
      }
      else
      {
         seq.stopRec();
         undoEndTimer();
         Global.Print("Recording is inactive");
      }
      grid.redraw();
      redrawPlugin();
   }

   // <method.png>
   module =replay= method startRecordingRSHIFT() {

      if(replay.b_playing)
      {
         // Stop replay + recording
         if(seq.b_recording)
         {
            Global.Print("Stop recording");
            seq.stopRec();
         }
         else
         {
            Global.Print("Stop replay");
         }
         root_form.handleToggleReplay(false/*bSendMMC*/);
      }
      else
      {
         undoBeginBuffer();  // save node state
         seq.startRec();
         root_form.handleToggleReplay(false/*bSendMMC*/);
         if(STConfig.b_pipemap_precount)
            replay.startPreCount(STConfig.pipemap_precount_num_bars);

         Global.Print("Save undo state and start recording");
      }
   }

   // <method.png>
   public method queueUndoAndRecRestart() {
      // RETURN or MMT_UNDO_AND_RESTART_RECORDING while recording
      if(seq.b_recording && replay.b_playing)
      {
         seq.undo(false/*bSaveRedo*/);
         handlePatternChanged(false/*bFromUI*/);

         Global.Print("Undo and restart recording");

         seq.queueRecordRestart();
      }
      else
         Global.Print("queueUndoAndRecRestart: not recording");
   }

   // <ui_handle.png>
   public method cycleRecordMode() {
      cb_play_rec_enable.toggleSelection();
      handlePlayRecEnableChanged();
   }

   // <ui_handle.png>
   public method togglePreCount() {
      STConfig.b_pipemap_precount = !STConfig.b_pipemap_precount;
      Global.Print("Pre-Count is "+Utils.GetEnableString(STConfig.b_pipemap_precount)+(STConfig.b_pipemap_precount?(" ("+STConfig.pipemap_precount_num_bars+" bar"+Utils.GetPluralStringFloat(STConfig.pipemap_precount_num_bars)+")"):""));
   }

   // <ui_handle.png>
   public method toggleIgnoreSeekPrgChgMute() {
      seq.nodeToggleIgnoreSeekPrgChgMute();
      Global.Print("Ignore seek-prgchg-mute is "+Utils.GetEnableString(seq.b_node_ignore_seek_prgchg_mute));
   }

   // <ui_show.png>
   protected method handleSelectTab() {
      Global.Print("Active tab is \""+ts_groups.getActiveViewCaption()+"\".");

      refocusDefault();  // calls handleViewEnter()
      // // handleViewEnter();
   }

   // <ui_handle.png>
   public method handleViewEnter() {

      // trace "xxx NodeTrigSeqEditor::handleViewEnter: ts_groups.getActiveTabIndex()="+ts_groups.getActiveTabIndex();

      if(UI.b_fbo)
      {
         root_form.removeOverlay(grid);
      }

      if(TAB_GRID == ts_groups.getActiveTabIndex())
      {
         if(UI.b_fbo)
         {
            root_form.addOverlay(grid);
         }

         UI.SetKeyboardFocus(grid);

         grid.handleViewEnter();
         grid.redraw();

         handlePatternChanged(false/*bFromUI*/); // update layout
      }

   }

   // <ui_handle.png>
   protected method handleViewLeave() {
      if(TAB_GRID == ts_groups.getActiveTabIndex())
      {
         if(UI.b_fbo)
         {
            root_form.removeOverlay(grid);
         }
      }
   }

   // <ui_show.png>
   protected method showEuclidDialog() {
      undoEndTimer();
      undoBegin();
      dlg_euclid.run(this);
   }

   // <method.png>
   public method guessNoteNameProfileId() : StringArray {
      NTS_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NTS_Track *track;
         // Guess note names from output port synth profile
         foreach track in pat.tracks
         {
            int devIdx = track.getOutDevIdx(seq);
            if(-1 != devIdx)
            {
               STX_MIDIOutDevice outDev <= MIDI.GetMIDIOutDeviceByIndex(devIdx);
               if(null != outDev)
               {
                  MIDISynthProfile msp <= outDev.getMIDISynthProfile(track.getOutCh(seq, pat));
                  if(null != msp)
                  {
                     if(null != msp.note_name_profile_id)
                     {
                        StringArray noteNames <= MIDI.GetMIDINoteNamesByProfileId(msp.note_name_profile_id);
                        if(null != noteNames)
                        {
                           Global.Print("Guess note name profile id \""+msp.note_name_profile_id+"\"");
                           pat.note_name_profile_id <= Object(msp.note_name_profile_id);
                           updatePatternNoteNameProfileSelection();
                           return noteNames;
                        }
                     }
                  }
               }
            }
         }
      }
      // Not found
      Global.Warning("Failed to guess note name profile id");
      return null;
   }

   // <method.png>
   public =replay= method remapTracksToNoteNameProfile() {

      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         // Check if all tracks use the same profile
         StringArray uniqueNoteNames <= null;
         StringArray noteNames <= null;
         NTS_Track *track;
         boolean bOk = true;
         local String *errMsg;

         foreach track in pat.tracks
         {
            noteNames <= MIDI.note_name_profiles.get(track.getCurrentNoteNameProfileId(pat));
            if(null == uniqueNoteNames)
            {
               uniqueNoteNames <= noteNames;
            }
            else
            {
               if(@(noteNames) != @(uniqueNoteNames))
               {
                  if(0 != track.getNumTrigs())
                  {
                     bOk = false;
                     errMsg <= "More than one note-name profile used";
                     break;
                  }
                  // else: quietly skip unused tracks
               }

               if(!track.isArg3NoteOffset(seq))
               {
                  bOk = false;
                  errMsg <= "Track "+(track.track_nr+1)+" arg3 is not a note offset";
               }
            }
         }

         if(bOk)
         {
            bOk = (null != noteNames);

            if(!bOk)
            {
               noteNames <= guessNoteNameProfileId();
               bOk = (null != noteNames);
            }

            if(bOk)
            {
               // Check if all notes exist in the given profile
               local IntArray remapNotes; remapNotes.alloc(NTS_Pattern.NUM_TRACKS);
               int trackNote;
               String *noteName;

               foreach track in pat.tracks
               {
                  trackNote = pat.arg3_offset + track.arg3;
                  remapNotes.add(trackNote);
                  noteName <= noteNames.get(trackNote);
                  if( (null == noteName) || ("-" == noteName ) || noteName.isBlank() )
                  {
                     if(0 != track.getNumTrigs())
                     {
                        errMsg <= "Remap: track "+(track.track_nr+1)+" note "+trackNote+" not available in profile";
                        bOk = false;
                        break;
                     }
                  }
               }

               if(bOk)
               {
                  local IntArray remapIndices; remapIndices.identity(NTS_Pattern.NUM_TRACKS);
                  remapNotes.sortByValue(remapIndices);
                  pat.tracks.rearrange(remapIndices);

                  // Assign new track names
                  int numDone = 0;
                  int trackIdx = 0;
                  foreach track in pat.tracks
                  {
                     trackNote = pat.arg3_offset + track.arg3;
                     noteName <= noteNames.get(trackNote);
                     if( (null != noteName) && ("-" != noteName ) && !noteName.isBlank() )
                     {
                        int idxColon = noteName.indexOf(":", 0);
                        if(-1 != idxColon)
                           track.name = noteName.substring(idxColon+1, -1).trim();
                        else
                           track.name = noteName.trim();
                        numDone++;
                     }
                     track.track_nr = trackIdx++;
                  }

                  updateTrackForms();
                  redraw();
                  Global.Print("Remap "+numDone+" track"+Utils.GetPluralString(numDone));
               }
            }
            else
            {
               errMsg <= "Failed to determine note-name profile";
            }
         }

         if(!bOk)
         {
            Global.Error("Remap: "+errMsg);
         }
      } // if pat
   }

   // <ui.png>
   protected method handleTrigRepeatMuteUpdates() {
      int trackIdx = 0;
      NTS_TrackForm *trackForm;
      foreach trackForm in track_forms
      {
         NTS_TrackState trackState <= seq.getTrackStateByIndex(trackIdx);
         trackForm.handleTrigRepeatMuteUpdate(trackState, this/*lnfLayer*/);
         trackIdx++;
      }
   }

   // <ui_show.png>
   protected method showImportARDialog() {
      dlg_import_ar.setRecipient(this);
      dlg_import_ar.showCenteredFirst();
   }

   // <method.png>
   protected =replay= method importARPattern() {
      // (note) see NodeTrackerEditor::cmd_pattern_import_ar_handle_ok()
      NTS_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBeginTimer();
         pat.patCopyToClipboard();

         clearAllTracks(false/*bKeepTimingTrack*/);

         boolean bDoMasterLen = dlg_import_ar.doMasterLen();
         boolean bDoChromatic = dlg_import_ar.doChromatic();
         boolean bDoSingleCh  = dlg_import_ar.doSingleCh();
         boolean bDoRetrigs   = dlg_import_ar.doRetrigs();
         boolean bDoVel       = dlg_import_ar.doVelocities();
         boolean bDoAccent    = dlg_import_ar.doAccents();
         boolean bDoDur       = dlg_import_ar.doDurations();
         boolean bDoMicro     = dlg_import_ar.doMicroTimings();
         boolean bDoNRPN      = dlg_import_ar.doNRPN();

         if(bDoChromatic)
         {
            // arg1=vel
            // arg2=note
            seq.setOutputMode(NodeTrigSeq.OUT_CHROMATIC);
         }
         else
         {
            // - arg1 is velocity
            // - arg2 is note duration
            // - arg3 is note
            seq.setOutputMode(NodeTrigSeq.OUT_SINGLECH_NOTE);
         }
         cm_play_out_mode.setSelectedOption(seq.output_mode);

         pat.arg3_offset = 0;
         fp_arg3_offset.setValue(pat.arg3_offset);

         // (todo) find by profile as fallback ?
         STX_MIDIOutDevice outDev <= MIDI.GetMIDIOutDeviceByAliasOrName(STConfig.node_trig_seq_analogrytm_device_name);
         if(null != outDev)
         {
            seq.setOutDevIdx(outDev.dev_idx);
            seq.setOutCh(0);  // overridden per track (in non-singlech mode)
            cm_play_out_dev.setSelectedOption(MIDI.UnsortedToSortedDevIdx(seq.getOutDevIdx()));
            Global.Debug("NodeTrigSeqEditor::importARPattern: map dev \""+STConfig.node_trig_seq_analogrytm_device_name+"\" => outDevIdx="+outDev.dev_idx);
         }
         else
         {
            Global.Warning("AR dev \""+STConfig.node_trig_seq_analogrytm_device_name+"\" not found. Check config !");
         }

         AR_Pattern arPat <= dlg_import_ar.ar_import_pattern;
         if(arPat.version < 5)
         {
            Global.Error("ImportAR: need version 5, have "+arPat.version);
            return;
         }

         // // int arPatSpd = raw.peekI8(0x3390);

         int trackOff = 0x4;
         NTS_Track *track;
         int trackIdx = 0;

         int maxDurTicks = current_song.ppq*4*8;
         int numTrigs = 0;

         if(bDoMasterLen)
         {
            int arMasterLen = arPat.masterLength & 255;
            if(1 != arMasterLen)
            {
               byte masterSpd = arPat.masterSpeed & 7;
               switch(masterSpd)
               {
                  case 0: // 2x
                     arMasterLen /= 2;
                     break;

                  case 1: // 3/2x
                     arMasterLen = (arMasterLen * 2) / 3;
                     break;

                  default:
                  case 2: // 1x
                     break;

                  case 3: // 3/4x
                     arMasterLen = (arMasterLen * 4) / 3;
                     break;

                  case 4: // 1/2x
                     arMasterLen *= 2;
                     break;

                  case 5: // 1/4x
                     arMasterLen *= 4;
                     break;

                  case 6: // 1/8x
                     arMasterLen *= 8;
                     break;
               }
            }
            pat.setMasterLen16th((1 == arMasterLen) ? -1/*inf*/ : arMasterLen);
         }

         loop(12)
         {
            MIDIMapEventType *modType;

            track <= pat.getTrackByIndex(trackIdx);
            track.name = NAR_Defs.track_names_short.get(trackIdx);  // "BD", "SD", ..
            track.setForcedModOutDev(-1);

            FloatArray trackVelocities <= track.velocities;  // def=[127, 96, 65, 34]

            track.setForcedOutDev(-1);
            track.setEnableForcedOut(false);

            if(bDoSingleCh)
            {
               track.setEnableForcedModOut(false);
            }
            else
            {
               track.setEnableForcedOut(true);
               track.setForcedOutCh(trackIdx);

               track.setForcedModOutCh(trackIdx);
               track.setEnableForcedModOut(true);
            }

            if(bDoChromatic)
            {
               track.setForcedOutDev(-1);
               track.setEnableForcedOut(true);
               track.setForcedOutCh(trackIdx);

               track.setMod1Min(0);
               track.setMod1Max(maxDurTicks);
               track.setMod1Reset(-1);
               modType <= track.mod1_type;
               modType.type = MIDIMapDefs.TYPEX_NOTE_DURATION;
            }
            else
            {
               // User defined (AR can map pressure to 4 destinations)
               track.setMod1Min(0);
               track.setMod1Max(127);
               track.setMod1Reset(-1);
               modType <= track.mod1_type;
               modType.type = MIDIMapDefs.TYPE_POLY_PRESSURE;
            }

            track.setMod2Min(0);
            track.setMod2Max(127);
            track.setMod2Reset(-1);
            modType <= track.mod2_type;
            if(bDoNRPN)
            {
               modType.type = MIDIMapDefs.TYPE_NRPN;
               modType.ext_type = 0 + trackIdx;  // Perf.Param 1..12
            }
            else
            {
               modType.type = MIDIMapDefs.TYPE_CC;
               modType.ext_type = 35 + trackIdx;  // Perf.Param 1..12
            }

            int arTrkNumSteps = arPat.getNumSteps(trackIdx);
            arTrkNumSteps = mathMini(64, arTrkNumSteps);
            track.setPlayLength(arTrkNumSteps, pat);

            // Set track speed (AR_SPEED_xxx)
            int arTrackSpd = arPat.getFlagsAndSpeed(trackIdx) & 7;
            int patNoteLenIdx;
            switch(arTrackSpd)
            {
               case 0: // 2x
                  patNoteLenIdx = NTS_Track.NOTELEN_32;
                  break;

               case 1: // 3/2x
                  patNoteLenIdx = NTS_Track.NOTELEN_24;
                  break;

               default:
               case 2: // 1x
                  patNoteLenIdx = NTS_Track.NOTELEN_16;
                  break;

               case 3: // 3/4x
                  patNoteLenIdx = NTS_Track.NOTELEN_12;
                  break;

               case 4: // 1/2x
                  patNoteLenIdx = NTS_Track.NOTELEN_8;
                  break;

               case 5: // 1/4x
                  patNoteLenIdx = NTS_Track.NOTELEN_4;
                  break;

               case 6: // 1/8x
                  patNoteLenIdx = NTS_Track.NOTELEN_2;
                  break;
            }

            track.setStepNoteLength(patNoteLenIdx, pat);

            if(bDoChromatic)
               track.arg3 = 12*3;  // base note offset
            else
               track.arg3 = trackIdx;  // trigger note (C-0..B-0)

            byte arDefNote = arPat.getDefaultNote(trackIdx);
            byte arDefVel  = arPat.getDefaultVelocity(trackIdx);
            byte arDefDur  = arPat.getDefaultNoteLength(trackIdx);

            float stepTicks = track.current_step_num_ticks;

            int stepIdxMaster = 0;
            int stepIdx;
            loop(arTrkNumSteps)
            {
               stepIdx = stepIdxMaster % arPat.getNumSteps(trackIdx);

               NTS_Step st <= track.getStepByIndex(stepIdx);

               short arTrigFlags = arPat.getTrig(trackIdx, stepIdx);
               byte  arNoteEvRaw = arPat.getStepNote(trackIdx, stepIdx);
               byte  arNoteEv    = arNoteEvRaw & 127;  // mask out conditional flag
               byte  tickShift   = arPat.getStepMicroTiming(trackIdx, stepIdx);  // -23..23  (1/384 ticks)
               trace "xxx tickShift="+tickShift+" noteRaw="+arNoteEvRaw+" note="+arNoteEv;
               byte  arVelEv     = arPat.getStepVelocity(trackIdx, stepIdx);  // $FF=default
               byte  arDurEv     = arPat.getStepNoteLength(trackIdx, stepIdx);  // $FF=default

               tickShift &=    0b00111111;
               if(tickShift &  0b00100000)
                  tickShift |= 0b11000000 | (0xFFFFFF << 8);  // extend sign

               trace "xxx => tickShift="+tickShift;

               if(arPat.getTrigEnable(trackIdx, stepIdx))
               {
                  int evTick;

                  if(arPat.getTrigless(trackIdx, stepIdx))
                     st.setEnableMod(true);
                  else
                     st.setEnableTrig(true);

                  numTrigs++;

                  if(bDoChromatic)
                  {
                     float evNote = -1;  // arg2

                     if(255 == arNoteEvRaw)  // default note ?
                        evNote = arDefNote - 0x3c/*60*/;
                     else
                        evNote = arNoteEv - 0x3C/*60*/;

                     st.arg2 = evNote;
                  }

                  if(bDoVel)
                  {
                     // trace "xxx trackIdx="+trackIdx+" stepIdx="+stepIdx+" arVelEv="+arVelEv+" arDefVel="+arDefVel;

                     byte evVel = (255 == arVelEv) ? arDefVel : arVelEv;

                     if(bDoAccent)
                     {
                        if(arPat.getTrigAccent(trackIdx, stepIdx))
                        {
                           evVel += 32;
                           if(evVel > 127)
                              evVel = 127;
                        }
                     }

                     int velIdx = trackVelocities.findNearestIdx1d(evVel, 0/*off*/, 1/*stride*/, 64/*maxDist*/);
                     // trace "xxx evVel="+evVel+" nearest idx="+velIdx;
                     if(-1 == velIdx)
                        velIdx = 3;
                     st.arg1 = velIdx;
                  }

                  if(bDoDur)
                  {
                     float evDur = (255 == arDurEv) ? arDefDur : arDurEv;
                     evDur = (float(current_song.ppq/4.0) * (NAR_Defs.note_dur_tbl.get(evDur)));
                     evDur = mathMini(maxDurTicks, evDur);
                     if(bDoChromatic)
                     {
                        // (note) mod1=TYPEX_NOTE_DURATION
                        st.mod1 = (127.0 * evDur) / maxDurTicks;
                     }
                     else
                     {
                        st.arg2 = evDur;
                     }
                  }
               }

               if(bDoRetrigs)
               {
                  if(arPat.getTrigRetrig(trackIdx, stepIdx))
                     st.setEnableRepeat(true);
               }

               if( bDoMicro && (st.b_trig || st.b_repeat || st.b_mod) )
               {
                  tickShift = tickShift * (current_song.ppq / 96.0)/*hardcoded in AR, smallest delay is 1/384 note*/;
                  st.microtime = tickShift / stepTicks;
               }

               // Next step
               stepIdxMaster++;
            }

            // Next track
            trackIdx++;
         }

         loop(16-12)
         {
            track <= pat.getTrackByIndex(trackIdx);
            if(track.name == "trk"+(trackIdx+1))  // default name ? (e.g. "trk13")
            {
               track.name = "-";
               track.play_length = 0;
            }
            trackIdx++;
         }


         handlePatternChanged(false/*bFromUI*/);
         queueUpdateStepDetails();

         Global.Print("Pattern imported from AR clipboard ("+numTrigs+" trig"+Utils.GetPluralString(numTrigs)+")");
      }
   }

   // <method.png>
   public =replay= method tryRevertToGlobalOutput(boolean _bQuiet) {
      boolean bOk = true;
      int uniqueDevIdx = -1;
      int uniqueMidiCh = -1;
      NTS_Track *track;
      NTS_Pattern *pat;
      foreach pat in seq.patterns
      {
         if(null != pat)
         {
            foreach track in pat.tracks
            {
               if(track.b_forced_out && (-1 != track.forced_out_dev))
               {
                  if(-1 == uniqueDevIdx)
                  {
                     uniqueDevIdx = track.forced_out_dev;
                     uniqueMidiCh = track.forced_out_ch;
                  }
                  else if((uniqueDevIdx != track.forced_out_dev) ||
                          (uniqueMidiCh != track.forced_out_ch)
                          )
                  {
                     bOk = false;
                     break;
                  }
               }

               if(track.b_forced_mod_out && (-1 != track.forced_mod_out_dev))
               {
                  if(-1 == uniqueDevIdx)
                  {
                     uniqueDevIdx = track.forced_mod_out_dev;
                     uniqueMidiCh = track.forced_mod_out_ch;
                  }
                  else if((uniqueDevIdx != track.forced_mod_out_dev) ||
                          (uniqueMidiCh != track.forced_mod_out_ch)
                          )
                  {
                     bOk = false;
                     break;
                  }
               }
            }
         }
      }

      if(bOk && (-1 != uniqueDevIdx))
      {
         // Turn off forced outputs
         foreach pat in seq.patterns
         {
            if(null != pat)
            {
               foreach track in pat.tracks
               {
                  track.b_forced_out     = false;
                  track.b_forced_mod_out = false;
               }
            }
         }

         // Use global output instead
         seq.out_dev_idx = uniqueDevIdx;
         seq.out_ch      = uniqueMidiCh;

         cm_play_out_dev.setSelectedOption(MIDI.UnsortedToSortedDevIdx(uniqueDevIdx));
         cm_play_out_ch.setSelectedOption(uniqueMidiCh);

         handlePatternChanged(false/*bFromUI*/);

         if(!_bQuiet)
         {
            Global.Print("Revert to global out (dev="+uniqueDevIdx+" ch=#"+(uniqueMidiCh+1)+")");
         }
      }
      else
      {
         if(!_bQuiet)
            Global.Warning("Can\'t revert to global out (no shared output port found)");
      }
   }

   // <ui_show.png>
   protected method showImportMonDialog() {
      dlg_import_mon.setRecipient(this);
      dlg_import_mon.showCenteredFirst();
   }

   // <method.png>
   public =replay= method importMonPattern(NM_Pattern _patMon,
                                           boolean    _bGuessNoteNameProfile,
                                           boolean    _bPreferGlobalOutput
                                           ) {
      if(null != _patMon)
      {
         NTS_Pattern pat <= getEditPattern();
         if(null == pat)
         {
            handlePatternAlloc(false/*bSub*/);
            pat <= getEditPattern();
         }

         if(null != pat)
         {
            // Create undo
            undoBeginTimer();
            pat.patCopyToClipboard();

            clearAllTracks(false/*bKeepTimingTrack*/);

            int numTrigs = 0;
            Integer trackOffset = 0;

            local IntArray uniqueDevs;
            local IntArray uniqueChs;
            _patMon.findUniqueMIDIPorts(uniqueDevs, uniqueChs);

            Global.Debug2("importMonPattern: #frames="+_patMon.getNumFrames()+" #uniquePorts="+uniqueDevs.numElements);

            float ticksToMilliSeconds = current_song.ticksToMilliSeconds(1.0);

            int patMonNumTicks;
            if(0 != _patMon.num_ticks_hint)
               patMonNumTicks = _patMon.num_ticks_hint;
            else
            {
               patMonNumTicks = _patMon.findNumMilliSec();  // finds ticks when timebase is ticks

               if(!_patMon.b_tick_timebase)
                  patMonNumTicks /= ticksToMilliSeconds;  // convert to ticks

               if(0 == patMonNumTicks)
                  patMonNumTicks = current_song.ppq * 4;  // should not be reachable
            }

            int ticks16 = current_song.ppq/4;
            patMonNumTicks = int((patMonNumTicks+ticks16-1)/ticks16) * ticks16; // align to 16th

            if(uniqueDevs.numElements > 0)
            {
               int origLockedKeyjazzNodeGID = current_song.locked_keyjazz_node_gid;
               current_song.locked_keyjazz_node_gid = -1;

               int portIdx = 0;
               loop(mathMini(NTS_Pattern.NUM_TRACKS, uniqueDevs.numElements))
               {
                  // Next port / track
                  numTrigs += pat.importMonPatternPort(pat,
                                                       _patMon,
                                                       patMonNumTicks,
                                                       uniqueDevs[portIdx],
                                                       uniqueChs[portIdx],
                                                       trackOffset
                                                       );
                  portIdx++;
               }

               pat.updateTrigCachesAndNumTicks();

               if(_bGuessNoteNameProfile)
                  guessNoteNameProfileId();

               if(_bPreferGlobalOutput)
                  tryRevertToGlobalOutput(true/*bQuiet*/);

               handlePatternChanged(false/*bFromUI*/);
               queueUpdateStepDetails();

               current_song.locked_keyjazz_node_gid = origLockedKeyjazzNodeGID;

               Global.Print("Pattern imported from Monitor clipboard ("+numTrigs+" trig"+Utils.GetPluralString(numTrigs)+")");
            }
            else
            {
               Global.Warning("ImportMon: clipboard is empty");
            }
         }
      }
   }

   // <method.png>
   public =replay= method beginOutputCapture() {
      // (note) capture stops when replay is stopped
      mon_capture.captureBegin();
      seq.b_capture = true;
      Global.Print("Start output capture");
   }

   // <method.png>
   public =replay= method pasteOutputCapture() {
      // Lazy-stop replay
      if(replay.b_playing)
         root_form.handleToggleReplay(false/*bSendMMC*/);

      NM_Pattern patMon <= mon_capture.nodeGetCurrentEditPattern();
      patMon.noteOffsToDuration();

      importMonPattern(patMon,
                       false/*bGuessNoteNameProfile*/,
                       false/*bPreferGlobalOutput*/
                       );
   }

   // <method.png>
   public method toggleOutputCaptureTicks() {
      STConfig.b_node_monitor_capture_tick_timebase = !STConfig.b_node_monitor_capture_tick_timebase;
      Global.Print("Output-Capture time base is "+(STConfig.b_node_monitor_capture_tick_timebase?"ticks":"milliseconds"));
   }

   // <method_handle.png>
   public virtual handleStartPlaying() {
      // // // seq.nodeCopyLastPatternStartSongOffsetFromEditor();
      ta_replay.schedule();
   }

   // <method_handle.png>
   public virtual handleStopPlaying(boolean _bAllowBookmark) {
      seq.stopRec();
      // // // seq.nodeCopyLastPatternStartSongOffsetFromEditor();
   }

   // <method_handle.png>
   public virtual handleSongPosSelected() {
      seq.nodeSetLastPatternStartEditorSongOffset(current_song.song_offset);
   }

   // <replay.png>
   public virtual handleReplayTick() {
      // trace "xxx NTS:handleReplayTick";
      Events.SendNodeEditorReplayTick();
   }

   // <ui_timer.png>
   public virtual handleReplayTickUI() {
      // trace "xxx NTS:handleReplayTickUI";
      if(null != editor_plugin)
         editor_plugin.handleReplayTickUI();
   }

   // <midi_mml.png>
   public virtual mmlHandleEventUI(MIDIMapEvent _ev) : boolean {

      // trace "xxx nts:mmlHandleEventUI";

      if(_ev.isReservedEvent())
         return false;

      if(null != editor_plugin)
         if(editor_plugin.mmlHandleEventUI(_ev))
            return true;

      MIDIMapEvent evXForm = _ev;
      MIDIMorphScene.TransformEvent(evXForm);
      if(evXForm.isValid())
         evXForm.echoTransformForced();

      if(dlg_track_setup.isFloatingLayerVisible())
      {
         dlg_track_setup.mmlHandleEventUI(evXForm);
      }
      else
      {
         if(STConfig.b_node_trig_seq_force_step_record_sustain_pedal)
         {
            int sustainPedal = evXForm.getSustainPedal();
            if(-1 != sustainPedal)
            {
               seq.setEnableForceStepRecord(sustainPedal >= 64);
               redrawPlugin();
            }
         }

         if(MIDIMapDefs.TYPE_NOTE_ON == evXForm.type)
         {
            if(seq.b_force_step_record)
            {
               NTS_Pattern pat <= getEditPattern();
               if(null != pat)
               {
                  NTS_Track track <= grid.getCursorTrack();
                  if(null != track)
                  {
                     int outMode = track.getActualOutputMode();
                     // (note) always match any device/ch ?
                     float note = evXForm.ext_type;
                     NTS_Step *st;
                     switch(outMode)
                     {
                        case NodeTrigSeq.OUT_CHROMATIC:
                        case NodeTrigSeq.OUT_CHROMATIC_MONO:
                           // arg2 is note, arg3 is note offset
                           note -= pat.arg3_offset;
                           note -= track.arg3;
                           if(note >= 0)
                           {
                              st <= grid.getCursorStep();
                              if(null != st)
                              {
                                 if(st.b_trig)
                                 {
                                    st.setArg2(note);
                                    Global.Print("Rec: Arg2 ("+st.getArg2Label()+") is "+st.getArg2String(false/*bShort*/));

                                    // Position cursor on next trig
                                    st <= track.findNextTrigStepAfter(st.grid_x);
                                    if(null != st)
                                    {
                                       grid.setCursorXYAndMakeVisible(st.grid_x, grid.cursor_y);
                                       pluginHandleCursorPosChanged();
                                    }

                                    grid.ta_redraw.schedule();
                                    queueUpdateStepDetails();
                                 }
                              }
                           }
                           break;
                     } // switch outMode
                  } // if track
               } // if pat
            } // if bRecNote
         }
      }

      return false;
   }

   // <ui_render.png>
   public method redrawPlugin() {
      if(null != editor_plugin)
         editor_plugin.redraw();
   }

   // <ui_handle.png>
   public method pluginHandleCursorPosChanged() {
      if(null != editor_plugin)
         editor_plugin.handleCursorPosChanged();
   }

   // <ui_render.png>
   public virtual redraw() {
      NodeEditor::redraw();
      redrawPlugin();
   }

   // <ui_timer.png>
   public virtual handleReplayTimer() {
   }

   // <ui_mouse.png>
   public virtual onMouse(MouseEvent _ev) : boolean {

      return NodeEditor::onMouse(_ev);
   }

   // <ui_kbd.png>
   protected method handlePatternKeyHome(int _kMod) {
      if((VMOD_LSHIFT|VMOD_LCTRL) == _kMod)
      {
         handleSelectNextUsedPattern();
         seq.undoInvalidatePattern();
      }
      else
      {
         if(VMOD_LCTRL == _kMod)
         {
            handleSelectNextPattern();
            handleSelectNextPattern();
            handleSelectNextPattern();
         }
         handleSelectNextPattern();
         seq.undoInvalidatePattern();
      }
   }

   // <ui_kbd.png>
   protected method handlePatternKeyEnd(int _kMod) {
      if((VMOD_LSHIFT|VMOD_LCTRL) == _kMod)
      {
         handleSelectPreviousUsedPattern();
         seq.undoInvalidatePattern();
      }
      else
      {
         if(VMOD_LCTRL == _kMod)
         {
            handleSelectPreviousPattern();
            handleSelectPreviousPattern();
            handleSelectPreviousPattern();
         }
         handleSelectPreviousPattern();
         seq.undoInvalidatePattern();
      }
   }

   // <ui_handle.png>
   protected method tryEditSound() : boolean {
      NTS_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NTS_Track track <= grid.getCursorTrack();
         if(null != track)
         {
            STX_MIDIOutDevice outDev <= track.getOutDev(seq);
            if(null != outDev)
            {
               byte outCh = track.getOutCh(seq, pat);
               MIDISynthProfile msp <= outDev.getMIDISynthProfile(outCh/*midiCh*/);
               if(null != msp)
               {
                  int noteIdxHint = track.getOutNoteHint(seq, pat);
                  Global.Debug("NodeTrigSeqEditor::tryEditSound: outDev=\""+outDev.getAliasOrDeviceName()+"\" ch="+(outCh+1)+" msp.id=\""+msp.midi_profile_id+"\" noteIdxHint="+noteIdxHint+"("+(MIDI.midi_notes.get(noteIdxHint))+")");

                  if(Global.TryEditSoundAnalogRytm(outDev, outCh, msp, noteIdxHint))
                     return true;

                  if(Global.TryEditSoundSysEx(outDev, outCh, msp, noteIdxHint))
                     return true;

                  if(Global.TryEditSoundSample(outDev, outCh, msp, noteIdxHint))
                     return true;

                  Global.Warning("tryEditSound: failed to find editor");
               }
               else
                  Global.Warning("tryEditSound: outDev msp is null");
            }
            else
               Global.Warning("tryEditSound: outDev is null");
         }
         else
            Global.Warning("tryEditSound: track is null");
      }
      else
         Global.Warning("tryEditSound: pattern is null");
      return false;
   }

   // <ui_kbd.png>
   public virtual wantKeyRepeat(Key _k) : boolean {
      if(VKEY_LCTRL == _k.code)
         return false;
      return NodeEditor::wantKeyRepeat(_k);
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {
      // see NodeEditor::onTriadKeyTimeout()
      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          1         :   Select pipenode A (use lctrl-x z to switch between A and B)
          2         :   Select pipenode B
          d         :   Toggle pattern manager
          g         :   Guess note-name profile from output port(s)
          k or l    :   Toggle KeyJazz lock
          u         :   Focus node name widget
          z         :   Switch between pipenodes A/B
          END       :   Global program change (master pipe, auto dev+ch A)
          HOME      :   Global program change (master pipe, auto dev+ch B)
"
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      int key = _k.pressed;

      // US (reference) keyboard layout (raw keycodes)
      switch(key)
      {
         case 'g':
            guessNoteNameProfileId();
            return true;

         case 'l':
            PagePipeMap pgPipeMap <= root_form.pg_pipemap;
            pgPipeMap.toggleKeyJazzLock(true/*bAlwaysVerbose*/);
            return true;
      }

      return NodeEditor::onTriadKey(_k);
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {

      // trace "xxx editor k.pressed="+_k.pressed+" k.released="+_k.released+" k.name="+_k.name;

      switch(_k.pressed)
      {
         case VKEY_ESCAPE:
            if(TAB_GRID != ts_groups.getActiveTabIndex())
            {
               ts_groups.setActiveTabIndex(TAB_GRID);
               return true;
            }
            // let PageNode handle it
            break;

         case VKEY_SPACE:
            if(_k.modShift() && _k.modCtrl() && !_k.modAlt())
            {
               cb_play_followarr.toggleSelectionAction();
               return true;
            }
            break;

         case VKEY_LCTRL:
            seq.setEnableForceStepRecord(true);
            redrawPlugin();
            return true;

         case VKEY_RCTRL:
            rctrl_pressed_ms = milliSeconds();
            seq.setEnableForceStepRecord(true);
            redrawPlugin();
            return true;

         case VKEY_F3:
            if(VMOD_LCTRL == _k.mod)
            {
               clearCursorTrack();
               return true;
            }
            break;

         case VKEY_F7:
            if(VMOD_LSHIFT == _k.mod)
            {
               showImportARDialog();
               return true;
            }
            break;

         case VKEY_F9:
            if(VMOD_LSHIFT == _k.mod)
            {
               showImportMonDialog();
               return true;
            }
            break;

         case VKEY_TAB:
            if(_k.modCtrl())
            {
               handleCycleStepDetailsMode(1/*dir*/, false/*bClamp*/);
               return true;
            }
            break;

         case VKEY_BACKSPACE:
            if(VMOD_LSHIFT == _k.mod)
            {
               clearCursorTrack();
               return true;
            }
            else if(VMOD_LCTRL == _k.mod)
            {
               clearTrackArgs();
               return true;
            }
            else if(VMOD_LALT == _k.mod)
            {
               clearTrackMicrotime();
               return true;
            }
            else if(_k.modNone())
            {
               clearTrackTrigsAndRepeats();
               return true;
            }
            else if((VMOD_LALT | VMOD_LCTRL) == _k.mod)
            {
               clearTrackMods();
               return true;
            }
            else if((VMOD_LSHIFT | VMOD_LALT) == _k.mod)
            {
               clearTrackModsInit();
               return true;
            }
            break;

         case VKEY_END:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyHome(_k.mod);
            else
               handlePatternKeyEnd(_k.mod);
            return true;

         case VKEY_HOME:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyEnd(_k.mod);
            else
               handlePatternKeyHome(_k.mod);
            return true;

         case '1':
            if(VMOD_LCTRL == _k.mod)
            {
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               handleSelectTab();
               return true;
            }
            break;

         case '2':
            if(VMOD_LCTRL == _k.mod)
            {
               ts_groups.setActiveTabIndex(TAB_GRID);
               handleSelectTab();
               return true;
            }
            break;

         case '3':
            if(VMOD_LCTRL == _k.mod)
            {
               ts_groups.setActiveTabIndex(TAB_PLAY);
               handleSelectTab();
               return true;
            }
            break;

         case 'a':
            if(TAB_PATTERN == ts_groups.getActiveTabIndex())
               showPatternToolsMenu(true/*bFocusFirst*/);
            else if(TAB_GRID == ts_groups.getActiveTabIndex())
               showContextMenu(true/*bFocusFirst*/);
            return true;

         case 'e':
            if(TAB_GRID == ts_groups.getActiveTabIndex())
            {
               showEuclidDialog();
               return true;
            }
            break;

         case 'f':
            toggleFolding();
            return true;

         case 'h':
            if(_k.modNone())
            {
               toggleMicrotimeLimit();
               return true;
            }
            break;

         case 'k':
            tryEditSound();
            return true;

         case 'n':
            if(VMOD_LSHIFT == _k.mod)
            {
               if(TAB_PATTERN == ts_groups.getActiveTabIndex())
               {
                  tf_pattern_name.onTabFocus();
               }
               else
               {
                  tf_pattern_name2.onTabFocus();
               }
               return true;
            }
            break;

         case 't':
            if(VMOD_LCTRL == _k.mod)
            {
               handleViewEnter();
               return true;
            }
            break;
      }

      if(trySelectPatternByUsedIdx(_k))
         return true;

      if(_k.modShift())
      {
         switch(_k.pressed)
         {
            case VKEY_F3:
               clearAllTracks(false/*bKeepTimingTrack*/);
               return true;

            case VKEY_BACKSPACE:
               if(_k.modCtrl())
               {
                  clearAllTracks(true/*bKeepTimingTrack*/);
                  return true;
               }
               break;
         }
      }

      switch(_k.released)
      {
         case VKEY_LCTRL:
            seq.setEnableForceStepRecord(false);
            redrawPlugin();
            break;

         case VKEY_RCTRL:
            seq.setEnableForceStepRecord(false);
            if((milliSeconds() - rctrl_pressed_ms) < 500)
               toggleRecording();
            redrawPlugin();
            return true;
      }

      return false;
   }

   // <ui_timer.png>
   public method undoBeginTimer() {
      seq.undoInvalidateBuffer();
      seq.undoBegin();
      ta_undo.reschedule();
   }

   // <ui_timer.png>
   public method undoBeginBuffer() {
      // save node state to undo buffer
      seq.undoBeginBuffer();
   }

   // <method.png>
   public method undoBegin() {
      // Used by NTS_EuclidDialog
      undoEndTimer();
      seq.undoBegin();
   }

   // <method.png>
   public method undoEnd() {
      seq.undoEnd();
   }

   // <ui_timer.png>
   public method undoEndTimer() {
      ta_undo.cancel();
      seq.undoEnd();
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      if(TA_REPLAY == acName)
      {
         grid.handleReplayTimer();

         handleTrigRepeatMuteUpdates();

         ta_replay.schedule();

         return true;
      }
      else if(TA_UNDO == acName)
      {
         if(seq.b_recording && replay.b_playing)
         {
            ta_undo.reschedule();
         }
         else
         {
            seq.undoEnd();
         }
         return true;
      }
      else if(TA_STEPDETAILS_RELAYOUT == acName)
      {
         // trace "xxx TA_STEPDETAILS_RELAYOUT";
         updateStepDetailsFloatParamLayout(false/*bResetToMin*/);
         updateStepDetails();
         updateStepDetailsFloatParamValues();
         updateStepDetailsButton();
         redraw();
         return true;
      }
      else if(TA_STEPDETAILS_UPDATE == acName)
      {
         // trace "xxx TA_STEPDETAILS_UPDATE";
         updateStepDetails();
         updateStepDetailsFloatParamValues();
         updateStepDetailsButton();
         return true;
      }

      StringAction *sac;
      FloatParam *fp;
      int stepIdx;

      stepIdx = stepdetails_arg2_floatparams.indexOfPointer(ap, 0);
      if(-1 != stepIdx)
      {
         handleStepDetailsArg2ChangedByIdx(stepIdx);
         if(FloatParam.ACTION_VALUECHANGED == acName)
         {
            refocusGrid();
         }
         return true;
      }

      stepIdx = stepdetails_mod1_floatparams.indexOfPointer(ap, 0);
      if(-1 != stepIdx)
      {
         handleStepDetailsMod1ChangedByIdx(stepIdx);
         if(FloatParam.ACTION_VALUECHANGED == acName)
            refocusGrid();
         return true;
      }

      stepIdx = stepdetails_mod2_floatparams.indexOfPointer(ap, 0);
      if(-1 != stepIdx)
      {
         handleStepDetailsMod2ChangedByIdx(stepIdx);
         if(FloatParam.ACTION_VALUECHANGED == acName)
            refocusGrid();
         return true;
      }

      switch(@(ap))
      {
         default:
            if(ap instanceof Layer)
            {
               Layer apLayer <= ap;
               String apId <= apLayer.getLayerId();
               int trackNr;
               NTS_Track *track;

               if(apId <= "fp_grid_arg3_")
               {
                  trackNr = apId.replace("fp_grid_arg3_", "");
                  track <= getTrackByIndex(trackNr);
                  if(null != track)
                  {
                     handleTrackArg3ChangedFP(ap, track);
                  }

                  if(acName == FloatParam.ACTION_VALUECHANGED)
                  {
                     UI.SetKeyboardFocus(grid);
                  }

                  return true;
               }
               else if(apId <= "cm_grid_arg3_")
               {
                  trackNr = apId.replace("cm_grid_arg3_", "");
                  track <= getTrackByIndex(trackNr);
                  if(null != track)
                  {
                     handleTrackArg3ChangedCM(ap, track);
                  }

                  refocusGrid();

                  return true;
               }
               else if(apId <= "fp_grid_numsteps_")
               {
                  trackNr = apId.replace("fp_grid_numsteps_", "");
                  track <= getTrackByIndex(trackNr);
                  if(null != track)
                  {
                     handleTrackPlayLengthChanged(ap, track);
                  }

                  if(acName == FloatParam.ACTION_VALUECHANGED)
                  {
                     UI.SetKeyboardFocus(grid);
                  }

                  return true;
               }
               else if(apId <= "tf_grid_name_")
               {
                  trackNr = apId.replace("tf_grid_name_", "");
                  track <= getTrackByIndex(trackNr);
                  if(null != track)
                  {
                     handleTrackNameChanged(ap, track);
                  }

                  if(acName == FloatParam.ACTION_TEXTENTERED)
                  {
                     UI.SetKeyboardFocus(grid);
                  }
                  return true;
               }
               else if(apId <= "fp_grid_quant_")
               {
                  trackNr = apId.replace("fp_grid_quant_", "");
                  track <= getTrackByIndex(trackNr);
                  if(null != track)
                  {
                     handleTrackQuantAmountChanged(ap, track);
                  }

                  if(acName == FloatParam.ACTION_VALUECHANGED)
                  {
                     UI.SetKeyboardFocus(grid);
                  }

                  return true;
               }
               else if(apId <= "fp_grid_swing_")
               {
                  trackNr = apId.replace("fp_grid_swing_", "");
                  track <= getTrackByIndex(trackNr);
                  if(null != track)
                  {
                     handleTrackSwingAmountChanged(ap, track);
                  }

                  if(acName == FloatParam.ACTION_VALUECHANGED)
                  {
                     UI.SetKeyboardFocus(grid);
                  }

                  return true;
               }
               else if(apId <= "cm_grid_notelen_")
               {
                  trackNr = apId.replace("cm_grid_notelen_", "");
                  track <= getTrackByIndex(trackNr);
                  if(null != track)
                  {
                     handleTrackNoteLenChanged(ap, track);
                  }

                  refocusGrid();

                  return true;
               }
               else if(apId <= "bt_grid_mute_")
               {
                  trackNr = apId.replace("bt_grid_mute_", "");
                  toggleMuteState(trackNr);

                  return true;
               }
               else if(apId <= "bt_grid_solo_")
               {
                  trackNr = apId.replace("bt_grid_solo_", "");
                  toggleSoloState(trackNr);

                  return true;
               }
            }
            break;

            // Pattern:
         case @(ts_groups):
            handleSelectTab();
            return true;

         case @(bt_pattern_alloc):
            if(Button.ACTION_HOLD_CLICK == acName)
            {
               handlePatternClone(false/*bSub*/);
            }
            else
            {
               handlePatternAlloc(false/*bSub*/);
            }
            return true;

         case @(bt_pattern_tools):
            showPatternToolsMenu(false/*bFocusFirst*/);
            return true;

         case @(pm_pattern_tools):
            Global.Debug2("nts: pm_pattern_tools acName="+acName);
            switch(acName)
            {
               case PopupMenu.ACTION_CANCEL:
               case "":
                  Global.Print("Close pattern tools menu.");
                  return true;

               default:
                  Global.Print("Select: "+acName);
                  return true;

               case "new":
                  handlePatternAlloc(false/*bSub*/);
                  return true;

               case "new_sub":
                  handlePatternAlloc(true/*bSub*/);
                  return true;

               case "copy":
                  handlePatternCopy();
                  return true;

               case "paste":
                  handlePatternPaste();
                  return true;

               case "clone":
                  handlePatternClone(false/*bSub*/);
                  return true;

               case "clone_sub":
                  handlePatternClone(true/*bSub*/);
                  return true;

            }
            return true;

         case @(bt_pattern_free):
            handlePatternFree();
            return true;

         case @(cm_pattern_nr):
            handleSelectPattern();
            return true;

         case @(tf_pattern_name):
            handlePatternNameChanged();
            updatePatternNrComboBox();

            if(TextField.ACTION_TEXTENTERED == acName)
            {
               refocusDefault();
            }
            return true;

         case @(tf_pattern_name2):
            handlePatternName2Changed();
            updatePatternNrComboBox();

            if(TextField.ACTION_TEXTENTERED == acName)
            {
               refocusDefault();
            }
            return true;

         case @(fp_pattern_masterlen16th):
            handleMasterLen16thChanged();
            return true;

         case @(fp_arg3_offset):
            handleArg3OffsetChanged();
            return true;

         case @(fp_pb_up):
            handlePitchbendRangeUpChanged();
            return true;

         case @(fp_pb_down):
            handlePitchbendRangeDownChanged();
            return true;

         case @(fp_note_dur_offset):
            handleDefaultNoteDurationOffsetChanged();
            return true;

         case @(cm_notenames):
            handleNoteNamesChanged();
            return true;

         case @(bt_notenames_rescan):
            rescanNoteNameProfiles();
            return true;

         case @(bt_notenames_guess):
            guessNoteNameProfileId();
            return true;

         case @(fp_swing_offset):
            handleSwingOffsetChanged();
            return true;

         case @(fp_velocity_jitter_offset):
            handleVelocityJitterOffsetChanged();
            return true;

         case @(fp_microtime_jitter_offset):
            handleMicrotimeJitterOffsetChanged();
            return true;

         case @(fp_mod1_jitter_offset):
            handleMod1JitterOffsetChanged();
            return true;

         case @(fp_mod2_jitter_offset):
            handleMod2JitterOffsetChanged();
            return true;

         case @(fp_quant_offset):
            handleQuantOffsetChanged();
            return true;

         case @(fp_step_highlight_modulo):
            handleBeatHighlightStepModuloChanged();
            return true;

         case @(fp_bar_modulo):
            handleBarModuloChanged();
            return true;


            // Grid:

         case @(bt_stepdetails_mode):
            if(Button.ACTION_WHEEL_UP == acName)
            {
               handleCycleStepDetailsMode(-1/*dir*/, true/*bClamp*/);
            }
            else if(Button.ACTION_WHEEL_DOWN == acName)
            {
               handleCycleStepDetailsMode(1/*dir*/, true/*bClamp*/);
            }
            else
            {
               handleCycleStepDetailsMode(1/*dir*/, false/*bClamp*/);
            }
            return true;

         case @(cb_stepdetails_trig):
            handleStepDetailsTrigChanged();
            return true;

         case @(cb_stepdetails_repeat):
            handleStepDetailsRepeatChanged();
            return true;

         case @(cm_stepdetails_arg1):
            handleStepDetailsArg1Changed();
            return true;

         case @(fp_stepdetails_arg2):
            handleStepDetailsArg2Changed();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_stepdetails_microtime):
            handleStepDetailsMicrotimeChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_stepdetails_mod1):
            handleStepDetailsMod1Changed();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_stepdetails_mod2):
            handleStepDetailsMod2Changed();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;


            // Play:
         case @(cm_node_class):
            handleNodeClassChanged();
            return true;

         case @(cb_node_class_show):
            handleNodeClassShowChanged();
            return true;

         case @(cm_node_class_show_in):
            handleNodeClassShowInChanged(seq);
            f_autodev.handleNodeClassShowChanged();
            return true;

         case @(cm_play_out_dev):
            handlePlayOutDevChanged();
            return true;

         case @(cm_play_out_ch):
            handlePlayOutChChanged();
            return true;

         case @(cm_play_out_mode):
            handlePlayOutputModeChanged();
            return true;

         case @(cb_play_extclk):
            handlePlayExtClkChanged();
            return true;

         case @(fp_speed_scl_reset):
            handleSpeedSclResetValChanged();
            return true;

         case @(bt_speed_restart):
            if(replay.b_playing)
               root_form.handleToggleReplay(false/*bShift*/);
            root_form.handleToggleReplay(false/*bShift*/);
            return true;

         case @(cm_play_repeat_start_mode):
            handlePlayRepeatStartModeChanged();
            return true;

         case @(cm_play_repeat_start_quantization):
            handlePlayRepeatStartQuantizationChanged();
            return true;

         case @(cm_play_repeat_len):
            handlePlayRepeatLenChanged();
            return true;

         case @(cm_play_num_repeats):
            handlePlayNumRepeatsChanged();
            return true;

         case @(cb_play_rec_enable):  // record mode
            handlePlayRecEnableChanged();
            return true;

         case @(cb_play_rec_prev):
            handlePlayRecPrevChanged();
            return true;

         case @(cb_play_rec_mute_repeat):
            handlePlayRecMuteRepeatChanged();
            return true;

         case @(cm_play_rec_dev):
            handlePlayRecDevChanged();
            return true;

         case @(cm_play_rec_ch):
            handlePlayRecChChanged();
            return true;

         case @(cb_play_rec_quantize):
            handlePlayRecQuantizeChanged();
            return true;

         case @(cm_play_rec_unmap):
            handlePlayRecUnmapTypeChanged();
            return true;

         case @(cb_play_rec_mod_unmap):
            handlePlayRecModUnmapChanged();
            return true;

         case @(cm_play_plugin_dev):
            handlePlayPluginDevChanged();
            return true;

         case @(cm_play_plugin_scene):
            handlePlayPluginSceneChanged();
            return true;

         case @(cb_play_followarr):
            handlePlayFollowArrChanged();
            return true;

         case @(cb_play_stepoff):
            handlePlayStepOffChanged();
            return true;

         case @(pm_ctx):
            if(!PopupMenu.IsFocusAction(_action))
               UI.SetKeyboardFocus(grid);
            switch(acName)
            {
               default:
                  if("inittracknames_mnn" == acName)
                  {
                     initTrackNamesFromMIDINoteNames();
                     return true;
                  }
                  else if(acName.startsWith("inittracknames_"))
                  {
                     initTrackNamesFromPreset(int(acName.replace("inittracknames_", "")));
                     return true;
                  }
                  else if(acName.startsWith("initarg3_"))
                  {
                     initArg3FromPreset(int(acName.replace("initarg3_", "")));
                     return true;
                  }
                  break;

               case "toggle_fold_tracks":
                  toggleFolding();
                  return true;

               case "show_track_setup":
                  showTrackSetupDialog();
                  return true;

               case "show_euclid":
                  showEuclidDialog();
                  return true;

               case "remap_tracks":
                  remapTracksToNoteNameProfile();
                  return true;

               case "revert_to_global_out":
                  tryRevertToGlobalOutput(false/*bQuiet*/);
                  return true;

               case "pattern_clear":
                  clearAllTracks(true/*bKeepTimingTrack*/);
                  return true;

               case "pattern_reverse":
                  grid.reversePatternSteps();
                  return true;

               case "pattern_rotate_left":
                  grid.rotatePatternStepsLeft();
                  return true;

               case "pattern_rotate_right":
                  grid.rotatePatternStepsRight();
                  return true;

               case "pattern_insert_step":
                  grid.insertPatternStep();
                  return true;

               case "pattern_delete_step":
                  grid.deletePatternStep();
                  return true;

               case "pattern_cut":
                  handlePatternCut();
                  return true;

               case "pattern_copy":
                  handlePatternCopy();
                  return true;

               case "pattern_paste":
                  handlePatternPaste();
                  return true;

               case "pattern_clone":
                  handlePatternClone(false/*bSub*/);
                  return true;

               case "pattern_clone_sub":
                  handlePatternClone(true/*bSub*/);
                  return true;


               case "step_cursor_left":
                  grid.cursorLeft();
                  grid.showCursorStepInfo();
                  return true;

               case "step_cursor_right":
                  grid.cursorRight();
                  grid.showCursorStepInfo();
                  return true;

               case "step_cursor_up":
                  grid.cursorUp();
                  grid.showCursorStepInfo();
                  return true;

               case "step_cursor_down":
                  grid.cursorDown();
                  grid.showCursorStepInfo();
                  return true;

               case "step_toggle_trig":
                  grid.toggleCursorStepTrig();
                  return true;

               case "step_toggle_repeat":
                  grid.toggleCursorStepRepeat();
                  return true;

               case "step_play":
                  grid.playCursorStep();
                  return true;

               case "track_trigger":
                  grid.queueTrackTrigger(maybe);
                  return true;

               case "track_step":
                  grid.queueTrackStep();
                  return true;

               case "step_cut":
                  grid.cutCursorStep();
                  return true;

               case "step_copy":
                  grid.copyCursorStep();
                  return true;

               case "step_paste":
                  grid.pasteCursorStep();
                  return true;

               case "step_arg1_0":
                  grid.setCursorStepArg1(0);
                  return true;

               case "step_arg1_1":
                  grid.setCursorStepArg1(1);
                  return true;

               case "step_arg1_2":
                  grid.setCursorStepArg1(2);
                  return true;

               case "step_arg1_3":
                  grid.setCursorStepArg1(3);
                  return true;

               case "step_arg2_inc_fine":
                  grid.incDecCursorStepArg2(1);
                  return true;

               case "step_arg2_inc_coarse":
                  grid.incDecCursorStepArg2(4);
                  return true;

               case "step_arg2_dec_fine":
                  grid.incDecCursorStepArg2(-1);
                  return true;

               case "step_arg2_dec_coarse":
                  grid.incDecCursorStepArg2(-4);
                  return true;


               case "step_microtime_dec":
                  grid.cursorStepMicroTimeTickIncDec(-1);
                  return true;

               case "step_microtime_inc":
                  grid.cursorStepMicroTimeTickIncDec(1);
                  return true;

               case "step_microtime_limit":
                  toggleMicrotimeLimit();
                  return true;

               case "step_move_left":
                  grid.moveCursorStepLeft();
                  return true;

               case "step_move_right":
                  grid.moveCursorStepRight();
                  return true;

               case "step_move_up":
                  grid.moveCursorStepUp();
                  return true;

               case "step_move_down":
                  grid.moveCursorStepDown();
                  return true;


               case "track_clear":
                  clearCursorTrack();
                  return true;

               case "track_clear_trigs_and_repeats":
                  clearTrackTrigsAndRepeats();
                  return true;

               case "track_clear_microtime":
                  clearTrackMicrotime();
                  return true;

               case "track_clear_args":
                  clearTrackArgs();
                  return true;

               case "track_clear_mods":
                  clearTrackMods();
                  return true;

               case "track_clear_mod_init":
                  clearTrackModsInit();
                  return true;

               case "track_reverse":
                  grid.reverseTrackSteps();
                  return true;

               case "track_rand_arg1":
                  grid.randomizeTrackArg1();
                  return true;

               case "track_rand_mod1":
                  grid.randomizeTrackMod1();
                  return true;

               case "track_rand_mod2":
                  grid.randomizeTrackMod2();
                  return true;

               case "track_load_arg2_0":
                  grid.initTrackArg2(0);
                  return true;

               case "track_load_arg2_identity":
                  grid.loadTrackArg2Identity();
                  return true;

               case "track_load_mod1_0":
                  grid.initTrackMod1(0.0f);
                  return true;

               case "track_load_mod1_64":
                  grid.initTrackMod1(64.0f);
                  return true;

               case "track_load_mod2_0":
                  grid.initTrackMod2(0.0f);
                  return true;

               case "track_load_mod2_64":
                  grid.initTrackMod2(64.0f);
                  return true;

               case "track_rand_trigs":
                  grid.randomizeTrackTrigs();
                  return true;

               case "track_rand_repeats":
                  grid.randomizeTrackRepeats();
                  return true;

               case "track_rotate_left":
                  grid.rotateTrackStepsLeft();
                  return true;

               case "track_rotate_right":
                  grid.rotateTrackStepsRight();
                  return true;

               case "track_insert_step":
                  grid.insertCursorStep();
                  return true;

               case "track_delete_step":
                  grid.deleteCursorStep();
                  return true;

               case "track_inc_len":
                  grid.incTrackLen();
                  updateTrackForms();
                  return true;

               case "track_dec_len":
                  grid.decTrackLen();
                  updateTrackForms();
                  return true;

               case "track_inc_notedur":
                  grid.incTrackDefaultNoteDurationTicks(1);
                  return true;

               case "track_dec_notedur":
                  grid.incTrackDefaultNoteDurationTicks(-1);
                  return true;

               case "track_toggle_solo":
                  grid.toggleTrackSolo();
                  return true;

               case "track_toggle_mute":
                  grid.toggleTrackMute();
                  return true;

               case "track_focus_num_steps":
                  focusTrackNumSteps(grid.cursor_y);
                  return true;

               case "track_focus_swing_amount":
                  focusTrackSwingAmount(grid.cursor_y);
                  return true;

               case "track_focus_note_len":
                  focusTrackNoteLen(grid.cursor_y);
                  return true;

               case "track_cut":
                  grid.handleTrackCut();
                  return true;

               case "track_copy":
                  grid.handleTrackCopy();
                  return true;

               case "track_paste":
                  grid.handleTrackPaste();
                  return true;

               case "track_paste_all":
                  grid.handleTrackPasteAll1();
                  return true;

               case "track_editsound":
                  tryEditSound();
                  return true;

               case "capture_start":
                  beginOutputCapture();
                  return true;

               case "capture_paste":
                  pasteOutputCapture();
                  return true;

               case "capture_ticks":
                  toggleOutputCaptureTicks();
                  return true;

               case "import_ar":
                  showImportARDialog();
                  return true;

               case "import_mon":
                  showImportMonDialog();
                  return true;

               case "toggle_recording":
                  toggleRecording();
                  return true;

               case "undo_redo":
                  // // undoEndTimer();
                  // // undoRedo(false/*bForceUndo*/);
                  handleUndoRedo( !(seq.b_recording && replay.b_playing)/*bSaveRedo*/ );
                  return true;
            }
            return true;

         case @(dlg_import_ar):
            if(NTS_ImportARDialog.ACTION_AR_IMPORT == acName)
            {
               importARPattern();
            }
            return true;

         case @(dlg_import_mon):
            if(NTS_ImportMonDialog.ACTION_MON_IMPORT == acName)
            {
               importMonPattern(dlg_import_mon.import_pattern,
                                dlg_import_mon.doGuessNoteNameProfile(),
                                dlg_import_mon.doPreferGlobalOut()
                                );
            }
            return true;

      }

      return XMLForm::consumeAction(_action);
   }

}
