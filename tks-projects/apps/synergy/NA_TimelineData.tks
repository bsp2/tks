// ----
// ---- file   : NA_TimelineData.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2017-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 11Apr2017
// ---- changed: 12Apr2017, 13Apr2017, 14Apr2017, 15Apr2017, 16Apr2017, 17Apr2017, 19Apr2017
// ----          20Apr2017, 25Apr2017, 27Apr2017, 30Apr2017, 26May2017, 14Jul2017, 15Jul2017
// ----          10Aug2017, 12Aug2017, 19Aug2017, 20Aug2017, 12Oct2017, 13Oct2017, 02Jan2018
// ----          03Jan2018, 04Jan2018, 05Jan2018, 06Jan2018, 05Apr2018, 22Jun2018, 17Nov2018
// ----          18Nov2018, 19Nov2018, 24Nov2018, 25Nov2018, 27Nov2018, 28Nov2018, 31May2019
// ----          19Aug2019, 21Sep2019, 22Sep2019, 31Oct2019, 01Nov2019, 09Nov2019, 26Apr2020
// ----          13May2021, 22May2021, 27May2021, 24Jul2021, 12Feb2022, 13Feb2022, 18Mar2022
// ----          11Aug2022, 12Aug2022, 11Feb2023, 15Mar2023, 21Sep2023, 03Oct2023, 05Oct2023
// ----          08Oct2023, 19Oct2023, 21Oct2023, 29Oct2023, 11Nov2023, 16Nov2023, 17Nov2023
// ----          02Feb2024, 03Feb2024, 22Mar2024, 24Mar2024, 02Oct2024, 15Nov2024, 06Jan2025
// ----          07Jan2025, 24Jan2025, 25Jan2025, 26Jan2025, 31Jan2025, 28Feb2025, 07Mar2025
// ----          08Mar2025, 09Mar2025, 22May2025, 11Sep2025, 12Sep2025, 17Sep2025
// ----
// ----
// ----

module MNA_TimelineData;

use namespace ui;
use namespace st2;


// <class.png>
class NA_TimelineData : Control {

   define int TOP_SY = 16;

   NA_TimelineForm *parent_form;
   NodeArranger    *parent_node;

   NA_State *tstate;

   float current_track_sy;
   static IntArray track_size_tbl = [23, 25, 27, 31, 35, 39, 43, 49, 57, 63, 74, 87];

   // see NA_Defs.GRID_UNIT_xxx
   static StringArray grid_unit_names = [
      "Tick",   // 0
      "1/16",   // 1
      "1/8",    // 2
      "1/4",    // 3
      "1/2",    // 4
      "1/1",    // 5
      "Beat",   // 6
      "Bar"     // 7
                                         ];

   // see NA_State.EDIT_MODE_xxx
   static StringArray edit_mode_names = [
      "Select",
      "Draw",
      "Erase",
      "Razor",
      "Mute"
                                         ];

   // see NA_State.PLAY_MODE_xxx
   static StringArray play_mode_names = [
      "Infinite",       // PLAY_MODE_NO_LOOP          = 0
      "Start->Loop",    // PLAY_MODE_START_LOOP       = 1
      "Loop Only",      // PLAY_MODE_LOOP_ONLY        = 2
      "Loop Once",      // PLAY_MODE_LOOP_ONCE        = 3
      "Mrk: Change",    // PLAY_MODE_MARKER_CHANGE    = 4
      "Mrk: Reset",     // PLAY_MODE_MARKER_RESET     = 5
      "Mrk: Reset All"  // PLAY_MODE_MARKER_RESET_ALL = 6
                                         ];

   static StringArray play_mode_tooltips = [
      /* 0 */ "Infinite: continue playing indefinitely\n\n (note) 'p' / 'lshift-p' cycles through play modes",
      /* 1 */ "Start->Loop: start at the beginning, then loop\n\n (note) 'p' / 'lshift-p' cycles through play modes",
      /* 2 */ "Loop Only: only play the loop region\n\n (note) 'p' / 'lshift-p' cycles through play modes",
      /* 3 */ "Loop Once: play loop region once, then stop\n\n (note) audio recording will continue until end of sample area\n\n (note) 'p' / 'lshift-p' cycles through play modes",
      /* 4 */ "Mrk: Change: play last selected marker region, immediately change into next marker region via modulo offset\n\n (note) 'p' / 'lshift-p' cycles through play modes",
      /* 5 */ "Mrk: Reset: play last selected marker region, restart next marker region\n\n (note) 'p' / 'lshift-p' cycles through play modes",
      /* 6 */ "Mrk: Reset All: play last selected marker region, restart next marker region, force clip start offsets\n\n (note) 'p' / 'lshift-p' cycles through play modes"
                                            ];

   define int DRAG_NONE       =  0;
   define int DRAG_SCROLLX    =  1;
   define int DRAG_SCROLLY    =  2;
   define int DRAG_SELECT     =  3;
   define int DRAG_MOVECLIPS  =  4;
   define int DRAG_CLIPSTART  =  5;
   define int DRAG_CLIPEND    =  6;
   define int DRAG_NEWCLIP    =  7;
   define int DRAG_MUTE       =  8;
   define int DRAG_LOOPL      =  9;
   define int DRAG_LOOPR      = 10;
   int drag_mode;
   int drag_start_ticks;
   int drag_end_ticks;
   int drag_start_track;
   int drag_start_track_before_expand_y;
   int drag_end_track;
   int drag_start_ticks_sorted;
   int drag_end_ticks_sorted;
   int drag_start_track_sorted;   // also used as current cursor track index
   int drag_end_track_sorted;
   int grid_cursor_track_hint;    // updated in setGridCursorTrack(). used for e.g. lalt-y (selectClipsAtEditOffset())
   int drag_delta_ticks;
   float drag_start_mouse_y;
   float drag_start_view_offset_y;

   boolean b_drag_overlap;
   boolean b_drag_top;  // true=drag started in top region (=> all tracks)
   int drag_start_tick_offset; // DRAG_SCROLLX
   IntArray clip_selection;  // node_gid / clip_uid tuples
   boolean b_allow_empty_selection;

   define int DRAG_THRESHOLD_PX = 3;

   define int CLIP_MULTI_START        = (1 << 0);
   define int CLIP_MULTI_END          = (1 << 1);
   define int CLIP_MULTI_PATTERNNR    = (1 << 2);
   define int CLIP_MULTI_OFFSET       = (1 << 3);
   define int CLIP_MULTI_OFFSETUNIT   = (1 << 4);
   define int CLIP_MULTI_OFFSETENABLE = (1 << 5);
   define int CLIP_MULTI_MUTE         = (1 << 6);
   define int CLIP_MULTI_ALL          = 127;

   protected Font *font;

   protected Icon *icon_locator_l;
   protected Icon *icon_locator_r;

   protected ComboBoxPopup *cmp_pattern_nr;  // PatterNr or Sample selector ('g' key)
   protected IntArray cmp_lut;  // maps option index to (valid) pattern nr

   protected static NA_Clip *[] clipboard;
   protected static int clipboard_ticks;

   public static int queued_marker_clip_selection_idx;  // when selecting clips via note-ons and editor is visible (-1=none)

   public static NA_ClipCtlDialog *dlg_clipctl;


   // <method_init.png>
   public method init(NA_TimelineForm _parentForm) : boolean {
      parent_form   <= _parentForm;

      current_track_sy = NA_TrackForm.DEFAULT_TRACK_SY;

      icon_locator_l <= UI.GetIcon("locator_l");
      icon_locator_r <= UI.GetIcon("locator_r");

      b_editable = true;  // so that tab-cycle works

      queued_marker_clip_selection_idx = -1;

      dlg_clipctl <= new NA_ClipCtlDialog();
      if(!dlg_clipctl.init())
      {
         trace "[---] NA_TimelineData::init: failed to init NA_ClipCtlDialog";
         return false;
      }

      return true;
   }

   // <ui.png>
   public virtual isTabCycleMember() : boolean {
      return true;
   }

   // <method_get.png>
   public static GetTopSY() : int {
      return TOP_SY * UI.font_scaling;
   }

   // <method_get.png>
   public method getCurrentTrackSYScaled() : int {
      int r = current_track_sy * UI.font_scaling;
      if(UI.font_scaling == 2.0)
         r = r * 0.9;
      return r;
   }

   // <method_get.png>
   public static GetDragThresholdPX() : int {
      return DRAG_THRESHOLD_PX * UI.icon_scaling;
   }

   // <ui_show.png>
   public method showNode(NodeArranger _node) {

      queued_marker_clip_selection_idx = -1;

      if(null != cmp_pattern_nr && cmp_pattern_nr.isFloatingLayerVisible())
         cmp_pattern_nr.hide();

      parent_node <= _node;
      tstate <= parent_node.timeline;

      // // block_start_indicator_ticks = -1;
      // // block_end_indicator_ticks = -1;
      // // block_start_indicator_py = -1;
      // // selectNone();
      drag_mode = DRAG_NONE;

      boolean bForceMarkerClipSelection = false;
      NA_Clip *clip;

      if(-1 != parent_node.edit_clip_start_ticks)
      {
         // Editor started from Arranger (marker mode)
         clip <= tstate.findMarkerClipByPatternNr(parent_node.nodeGetCurrentPlayPatternNr());
         if(null != clip)
         {
            tstate.queueMarkerPatNr(parent_node.nodeGetCurrentPlayPatternNr());
            makeRegionVisible(clip.start_ticks, clip.end_ticks);
            tstate.edit_offset = clip.start_ticks;
            bForceMarkerClipSelection = true;
         }
      }

      // Restore selection
      if(bForceMarkerClipSelection)
      {
         // Select marker clip (e.g. after editing arranger clip from other arranger)
         clip_selection.empty();
         clip_selection.add(clip.node_gid);
         clip_selection.add(clip.clip_uid);
      }
      else if(0 != (parent_node.restore_clip_selection.numElements))
      {
         // // trace "xxx arr: restore clip_selection="+#(clip_selection);
         clip_selection = parent_node.restore_clip_selection;
         parent_node.restore_clip_selection.empty();
      }

      toggleOrSetGridCursorMode(tstate.b_grid_cursor_mode, false/*bUpdateSelection*/, true/*bVerbose*/);
      toggleOrSetEdgeSelectionMode(tstate.b_edge_selection_mode);

      tstate.ui_pre_switch_marker_track_nr = drag_start_track_sorted;
      tstate.b_ui_pre_switch_show_marker = tstate.b_show_marker;

      tstate.updateEmptyFlags();

      // Restore drag selection (== cursor pos in grid cursor mode)
      drag_start_ticks = tstate.ui_bak_drag_start_ticks;
      drag_end_ticks   = tstate.ui_bak_drag_end_ticks;
      drag_start_track = tstate.ui_bak_drag_start_track;
      drag_end_track   = tstate.ui_bak_drag_end_track;
      sortDragSelection();

      if(parent_node.nodeIsMaster())
      {
         setEditOffsetToTicks(getGridAlignedTicks(current_song.song_offset));
         centerReplayOffset();
      }
   }

   // <method.png>
   public method showNodeQuiet(NodeArranger _arranger) {
      parent_node <= _arranger;
      tstate <= parent_node.timeline;
   }

   // <ui_hide.png>
   public method leaveNode() {

      Global.Debug("NA_TimelineData::leaveNode");
      if(null != parent_node)
      {
         // Save drag selection (== cursor pos in grid cursor mode)
         tstate.ui_bak_drag_start_ticks = drag_start_ticks;
         tstate.ui_bak_drag_end_ticks   = drag_end_ticks;
         tstate.ui_bak_drag_start_track = drag_start_track;
         tstate.ui_bak_drag_end_track   = drag_end_track;

         // Save clip selection
         parent_node.restore_clip_selection = clip_selection;

         if(null != cmp_pattern_nr && cmp_pattern_nr.isFloatingLayerVisible())
            cmp_pattern_nr.hide();

         parent_node <= null;
         drag_mode = DRAG_NONE;
      }
   }

   // <ui_show.png>
   protected method showClipCtlDialog(NA_Clip _clip) {

      if(tstate.clip_edit_mode < NA_State.CLIP_EDIT_MODE_INITCTL_MW)
         tstate.clip_edit_mode = NA_State.CLIP_EDIT_MODE_INITCTL_MW;

      dlg_clipctl.showClipCtlDialog(parent_form.parent_editor,
                                    parent_node,
                                    _clip,
                                    (tstate.clip_edit_mode - 1)/*ctlIdx*/
                                    );
   }

   // <ui_show.png>
   public method editFirstSelectedClipCtl(boolean _bWarpMouse, Key _k) : boolean {
      NA_Clip firstClip <= getFirstSelectedClip();
      if(null != firstClip)
      {
         if(!firstClip.isMarker())
         {
            if(_bWarpMouse)
               warpMouseToEditCursor(true/*bBelow*/);

            showClipCtlDialog(firstClip);

            if(null != _k)
            {
               Layer lFocus <= UI.GetKeyboardFocus();
               if(null != lFocus)
                  lFocus.onKey(_k);
            }

            return true;
         }
         else
         {
            Global.Warning("Marker clip has no initial controllers");
         }
      }
      return false;
   }

   // <ui_handle.png>
   public method cycleClipEditMode(int _delta) {
      tstate.clip_edit_mode = mathClampi(tstate.clip_edit_mode + _delta, 0, NA_State.NUM_CLIP_EDIT_MODES-1);
      redraw();
      Global.Print("Clip edit mode is \'"+(NA_State.clip_edit_mode_names.get(tstate.clip_edit_mode))+"\'");
   }

   // <method.png>
   public method selectNone() {
      if(clip_selection.numElements > 0)
         redraw();
      clip_selection.empty();

      b_allow_empty_selection = tstate.b_grid_cursor_mode;

      handleSelectionChanged();
   }

   // <method.png>
   protected method selectTrack(int _trackIdx) {
      // (note) 0=marker track
      drag_start_track                 = _trackIdx;
      drag_start_track_sorted          = _trackIdx;
      drag_end_track                   = _trackIdx;
      drag_end_track_sorted            = _trackIdx;
      drag_start_track_before_expand_y = _trackIdx;
      // // trace "[trc] selectTrack("+_trackIdx+")";
   }

   // <method.png>
   public method setGridCursorTrack(int _trackIdx) {
      // Called when moving between clips with cursor keys
      drag_start_track        = _trackIdx;
      drag_end_track          = _trackIdx;
      drag_start_track_sorted = _trackIdx;
      drag_end_track_sorted   = _trackIdx;
      grid_cursor_track_hint  = _trackIdx;
      // // trace "[trc] setGridCursorTrack("+_trackIdx+")";
   }

   // <method_get.png>
   protected method isCursorOnMarkerTrack() : boolean {
      return tstate.b_show_marker && (0 == drag_start_track);
   }

   // <method.png>
   public method getSelectedTrackIndices(IntArray _retTrackArray) {
      _retTrackArray.empty();
      int i = 0;
      loop(clip_selection.numElements / 2)
      {
         // Already counted ?
         int nodeGID = clip_selection.get(i);
         int j = 0;
         boolean bFound = false;
         while(j < i)
         {
            if(clip_selection.get(j) == nodeGID)
            {
               bFound = true;
               break;
            }

            j += 2;
         }
         if(!bFound)
         {
            NA_Track track <= tstate.findTrackByGID(nodeGID);
            if(null != track)
            {
               int trackIdx = tstate.getTrackIdxByTrack(track);
               _retTrackArray.add(trackIdx);
            }
         }

         i += 2;
      }
   }

   // <method.png>
   public method getNumSelectedTracks() : int {
      IntArray trackIndices;
      getSelectedTrackIndices(trackIndices);
      return trackIndices.numElements;
   }

   // <method.png>
   protected method reverseSelection() {
      if(clip_selection.numElements >  0)
      {
         local IntArray newSelection;
         int selIdx = clip_selection.numElements - 2;
         loop(clip_selection.numElements / 2)
         {
            newSelection.add(clip_selection.get(selIdx+0));
            newSelection.add(clip_selection.get(selIdx+1));
            selIdx -= 2;
         }
         clip_selection = newSelection;
         handleSelectionChanged();
      }
   }

   // <method.png>
   public method removeMarkerTrackClipsFromSelection() {
      IntArray newSelection;
      newSelection.empty();

      int i = 0;
      loop(clip_selection.numElements / 2)
      {
         if(clip_selection[i+0] != NA_Track.NODE_GID_MARKER)
         {
            newSelection.add(clip_selection[i+0]);  // nodeGID
            newSelection.add(clip_selection[i+1]);  // clipUID
         }

         i += 2;
      }

      clip_selection = newSelection;

      handleSelectionChanged();
   }

   // <method.png>
   namespace method lazySelectGridCursorClips() {
      if(tstate.b_grid_cursor_mode && !haveSelection())
         selectClips(false/*bAllowToggle*/, false/*bAdd*/);
   }

   // <method.png>
   public method haveSelection() : boolean {
      return (clip_selection.numElements > 0);
   }

   // <method.png>
   public static DoesSelectionContain(IntArray _selection, int _nodeGID, int _clipUID) : boolean {
      int i = 0;
      loop(_selection.numElements / 2)
      {
         if(_selection[i+0] == _nodeGID)
         {
            if(_selection[i+1] == _clipUID)
               return true;
         }
         i += 2;
      }
      return false;
   }

   // <method.png>
   public static DoesSelectionContainMarkerClip(IntArray _selection) : boolean {
      // (note) could also use getFirstSelectedMarkerClip()
      int i = 0;
      loop(_selection.numElements / 2)
      {
         if(_selection[i+0] == NA_Track.NODE_GID_MARKER)
            return true;
         i += 2;
      }
      return false;
   }

   // <method.png>
   public static CompareSelections(IntArray _selectionA, IntArray _selectionB) : boolean {
      if(_selectionA.numElements == _selectionB.numElements)
      {
         int i = 0;
         loop(_selectionA.numElements / 2)
         {
            int nodeGID = _selectionA[i+0];
            int clipGID = _selectionA[i+1];

            boolean bFound = false;
            int j = 0;
            loop(_selectionB.numElements / 2)
            {
               if(_selectionB[j+0] == nodeGID &&
                  _selectionB[j+1] == clipGID
                  )
               {
                  bFound = true;
                  break;
               }
               j += 2;
            }

            if(!bFound)
               return false;

            i += 2;
         }
         return true;
      }
      return false;
   }

   // <method.png>
   public static RemoveFromSelection(IntArray _selection, int _nodeGID, int _clipUID) {
      int i = 0;
      loop(_selection.numElements / 2)
      {
         if(_selection[i+0] == _nodeGID)
         {
            if(_selection[i+1] == _clipUID)
            {
               _selection.delete(i);
               _selection.delete(i);
               i -= 2;
            }
         }
         i += 2;
      }
   }

   // <method.png>
   protected method reduceSelectionToFirstMarkerClip() : boolean {
      int i = 0;
      int bestUID = -1;
      int bestT = 99999999;
      loop(clip_selection.numElements / 2)
      {
         if(clip_selection[i+0] == NA_Defs.NODE_GID_MARKER)
         {
            int clipUID = clip_selection[i+1];
            NA_Clip clip <= tstate.findMarkerClipByUID(clipUID);
            if(clip.start_ticks < bestT)
            {
               bestT = clip.start_ticks;
               bestUID = clipUID;
            }
         }
         i += 2;
      }

      if(bestUID >= 0)
      {
         clip_selection.empty();
         clip_selection.add(NA_Defs.NODE_GID_MARKER);
         clip_selection.add(bestUID);
         handleSelectionChanged();
         return true;
      }

      return false;
   }

   // <method.png>
   protected method reduceSelectionToLastMarkerClip() : boolean {
      int i = 0;
      int bestUID = -1;
      int bestT = 0;
      loop(clip_selection.numElements / 2)
      {
         if(clip_selection[i+0] == NA_Defs.NODE_GID_MARKER)
         {
            int clipUID = clip_selection[i+1];
            NA_Clip clip <= tstate.findMarkerClipByUID(clipUID);
            if(clip.start_ticks >= bestT)
            {
               bestT = clip.start_ticks;
               bestUID = clipUID;
            }
         }
         i += 2;
      }

      if(bestUID >= 0)
      {
         clip_selection.empty();
         clip_selection.add(NA_Defs.NODE_GID_MARKER);
         clip_selection.add(bestUID);
         handleSelectionChanged();
         return true;
      }

      return false;
   }

   // <method.png>
   public method sortDragSelection() {
      if(drag_start_ticks > drag_end_ticks)
      {
         drag_start_ticks_sorted = drag_end_ticks;
         drag_end_ticks_sorted = drag_start_ticks;
      }
      else
      {
         drag_start_ticks_sorted = drag_start_ticks;
         drag_end_ticks_sorted = drag_end_ticks;
      }

      if(drag_start_track > drag_end_track)
      {
         drag_start_track_sorted = drag_end_track;
         drag_end_track_sorted = drag_start_track;
      }
      else
      {
         drag_start_track_sorted = drag_start_track;
         drag_end_track_sorted = drag_end_track;
      }
   }

   // <method_get.png>
   protected isClipSelected(int _gid, int _clipUID) : boolean {
      int i = 0;
      loop(clip_selection.numElements / 2)
      {
         if(clip_selection[i + 0] == _gid)
         {
            if(clip_selection[i + 1] == _clipUID)
               return true;
         }
         i += 2;
      }
   }

   // <method_get.png>
   protected method getGridAlignedTicks(int _ticks) : int {
      int ret = _ticks;
      if(tstate.grid_snap)
      {
         int gridTicks = tstate.calcGridTicks();
         ret = (ret / gridTicks) * gridTicks;
      }
      return ret;
   }

   // <method_get.png>
   public method getPxForTickOffset(int _ticks) : float {
      float sx = getSizeX();
      sx -= 2*2;
      float pixPerTick = sx / tstate.vis_ticks;
      return (_ticks - tstate.view_offset) * pixPerTick;
   }

   // <method_get.png>
   protected method getTickOffsetForPx(int _px) : int {
      float sx = getSizeX() - 2*2;
      float pixPerTick = sx / tstate.vis_ticks;
      int ret = ((_px-2) / pixPerTick) + tstate.view_offset;
      return ret;
   }

   // <method_get.png>
   protected method getGridAlignedTickOffsetForPx(int _px) : int {
      int ret = getTickOffsetForPx(_px);
      if(tstate.grid_snap)
      {
         int gridTicks = tstate.calcGridTicks();
         ret = (ret / gridTicks) * gridTicks;
      }
      return ret;
   }

   // <method_get.png>
   protected method getSelectionGridAlignedTickOffsetForPx(int _px) : int {
      int ret = getTickOffsetForPx(_px);
      if(tstate.grid_snap)
      {
         int gridTicks = tstate.calcGridTicks();
         ret = ((ret + gridTicks/2) / gridTicks) * gridTicks;
      }
      return ret;
   }

   // <method.png>
   public method zoomIn(float _px) {

      int visTicks = tstate.vis_ticks;
      int totalTicks = tstate.calcCanvasSizeTicks();

      int ticksAtPx = getTickOffsetForPx(_px);

      if(visTicks > 16)
      {
         visTicks *= 0.85;

         if(visTicks < 16)
            visTicks = 16;

         float sx = getSizeX() - 2*2;
         float ticksPerPix = visTicks / sx;

         tstate.vis_ticks = visTicks;

         if(_px >= (sx*0.85))
         {
            // Align right
            tstate.view_offset = (ticksAtPx + visTicks*0.15) - ((_px-2) * ticksPerPix);
            if( (tstate.view_offset + visTicks) > totalTicks )
               tstate.view_offset = totalTicks - visTicks;
         }
         else if(_px < (sx*0.15))
         {
            // Align left
            tstate.view_offset = (ticksAtPx - visTicks*0.15) - ((_px-2) * ticksPerPix);
            if(tstate.view_offset < 0)
               tstate.view_offset = 0;
         }
         else
         {
            // Align center
            tstate.view_offset = ticksAtPx - ((_px-2) * ticksPerPix);
         }

         parent_form.redraw();
         parent_form.b_update_knob_size = true;
      }
   }

   // <method.png>
   public method zoomOut(float _px) {

      int visTicks = tstate.vis_ticks;
      int totalTicks = tstate.calcCanvasSizeTicks();

      int ticksAtPx = getTickOffsetForPx(_px);

      if(visTicks < totalTicks)
      {
         visTicks *= 1.15;
         // // trace "xxx visTicks="+visTicks+" mpat.num_ticks="+mpat.num_ticks;

         if(visTicks > totalTicks)
         {
            visTicks = totalTicks;
            tstate.vis_ticks = visTicks;
            tstate.view_offset = 0;
         }
         else
         {
            float sx = getSizeX() - 2*2;
            float ticksPerPix = visTicks / sx;

            tstate.vis_ticks = visTicks;

            if(_px >= (sx*0.85))
            {
               // Align right
               tstate.view_offset = (ticksAtPx + visTicks*0.15) - ((_px-2) * ticksPerPix);
               if( (tstate.view_offset + visTicks) > totalTicks )
                  tstate.view_offset = totalTicks - visTicks;
            }
            else if(_px < (sx*0.15))
            {
               // Align left
               tstate.view_offset = (ticksAtPx - visTicks*0.15) - ((_px-2) * ticksPerPix);
               if(tstate.view_offset < 0)
                  tstate.view_offset = 0;
            }
            else
            {
               // Align center
               tstate.view_offset = ticksAtPx - ((_px-2) * ticksPerPix);
            }

            // // parent_node.envelope_view_tick_offset = ticksAtPx - ((_px-2) * ticksPerPix);

            if(tstate.view_offset < 0)
               tstate.view_offset = 0;
            else if( (tstate.view_offset + visTicks) > totalTicks )
               tstate.view_offset = totalTicks - visTicks;
            // // trace "xxx new visTicks="+visTicks+" view_offset="+parent_node.envelope_view_tick_offset;
         }

         parent_form.redraw();
         parent_form.b_update_knob_size = true;
      }
   }

   // <method.png>
   namespace method clipTickOffset() {
      // Clip right
      if((tstate.view_offset + tstate.vis_ticks) >= tstate.calcCanvasSizeTicks())
         tstate.view_offset = tstate.calcCanvasSizeTicks() - tstate.vis_ticks;

      if(tstate.view_offset < 0)
         tstate.view_offset = 0;
   }

   // <method.png>
   namespace method makeRegionVisible(int _startTicks, int _endTicks) {

      // don't place cursor at screen border
      _endTicks *= 1.1;

      int numTicks = (_endTicks - _startTicks);

      // // trace "[dbg] makeRegionVisible(start="+_startTicks+" end="+_endTicks+") vis_ticks="+tstate.vis_ticks;

      if( (tstate.view_offset <= _startTicks) && ((tstate.view_offset + tstate.vis_ticks) >= _endTicks) )
      {
         // nothing to do, clip/region is already visible
      }
      else
      {
         if(tstate.vis_ticks >= numTicks)
         {
            // ok, can make the region visible by simply adjusting the scroll offset
            // // trace "xxx adjust offset start="+_startTicks+" end="+_endTicks+" vis="+tstate.vis_ticks+" numTicks="+numTicks;
            tstate.view_offset = _startTicks - ((tstate.vis_ticks - numTicks) / 2);
            // // trace "xxx ==> offset="+tstate.view_offset;
         }
         else
         {
            // need to zoom out
            tstate.view_offset = _startTicks;
            tstate.vis_ticks = (_endTicks - _startTicks);
         }

         clipTickOffset();

         parent_form.redraw();
         parent_form.b_update_knob_size = true;
      }
   }

   // <method.png>
   protected method makeEditOffsetVisible() {
      int gridTicks = tstate.calcGridTicks();
      int editOffset = (tstate.edit_offset / gridTicks) * gridTicks;
      makeRegionVisible(tstate.edit_offset, tstate.edit_offset + gridTicks);
   }

   // <method.png>
   namespace method makeSelectionVisible() {
      if(clip_selection.numElements > 0)
      {
         int minTicks = 9999999;
         int maxTicks = 0;

         int selIdx = 0;
         while(selIdx < clip_selection.numElements)
         {
            NA_Track *ctrack;
            ctrack <= tstate.findTrackByGID(clip_selection.get(selIdx + 0));
            if(null != ctrack)
            {
               NA_Clip clip <= ctrack.findClipByUID(clip_selection.get(selIdx + 1));

               if(null != clip)
               {
                  if(clip.start_ticks < minTicks)
                     minTicks = clip.start_ticks;

                  if(clip.end_ticks > maxTicks)
                     maxTicks = clip.end_ticks;
               }
            }

            selIdx += 2;
         }

         makeRegionVisible(minTicks, maxTicks);
      }
   }

   // <method.png>
   namespace method toggleShowAll() {
      int totalTicks = tstate.calcCanvasSizeTicks();

      if((0 == tstate.view_offset) && (totalTicks == tstate.vis_ticks))
      {
         // Restore previous view
         tstate.view_offset = tstate.prev_view_offset;
         tstate.vis_ticks   = tstate.prev_vis_ticks;
      }
      else
      {
         // Save current view
         tstate.prev_view_offset = tstate.view_offset;
         tstate.prev_vis_ticks   = tstate.vis_ticks;

         tstate.view_offset = 0;
         tstate.vis_ticks = totalTicks;
      }

      if(tstate.b_grid_cursor_mode)
         makeRegionVisible(drag_start_ticks_sorted, drag_end_ticks_sorted);

      parent_form.redraw();
      parent_form.b_update_knob_size = true;
   }

   // <method.png>
   namespace =replay= method centerReplayOffset() {
      tstate.view_offset = tstate.play_offset;
      tstate.view_offset -= tstate.vis_ticks / 2;
      if(tstate.view_offset < 0)
         tstate.view_offset = 0;
      parent_form.redraw();
      parent_form.b_update_knob_size = true;
   }

   // <method.png>
   namespace method centerEditOffset() {
      tstate.view_offset = tstate.edit_offset;
      tstate.view_offset -= tstate.vis_ticks / 2;
      if(tstate.view_offset < 0)
         tstate.view_offset = 0;
      parent_form.redraw();
      parent_form.b_update_knob_size = true;
   }

   // <method.png>
   namespace method toggleFollowMode() {
      tstate.b_follow = (true == tstate.b_follow) ? maybe : (maybe == tstate.b_follow) ? false : true;
      Global.Print("Follow mode is "+((maybe == tstate.b_follow)?"enabled (smooth)" : (true == tstate.b_follow) ? "enabled (paging)" : "disabled"));
      if(maybe == tstate.b_follow)
         centerReplayOffset();
   }

   // <method.png>
   namespace method seekToEditOffsetAndPlayTickIfMaster() {
      if(parent_node.nodeIsMaster())
      {
         current_song.seek(tstate.edit_offset);
         current_song.setSongOffset(tstate.edit_offset); // update ui_song_offset
         root_form.updateReplayTimeLabel(false/*bForceUpdate*/);

         if(!replay.b_playing)
            replay.playTicks(1, tstate.edit_offset, true/*bMuted*/);  // [17Nov2023] send mute/pattern selection
      }
   }

   // <method.png>
   namespace method gotoStart() {
      tstate.undoAddMini(clip_selection);
      tstate.edit_offset = 0;
      tstate.view_offset = 0;
      tstate.queuePlayOffset(0, false/*bReplay*/);

      // // if(parent_node.nodeIsMaster())
      // // {
      // //    current_song.seek(tstate.edit_offset);
      // //    current_song.setSongOffset(tstate.edit_offset); // update ui_song_offset
      // //    root_form.updateReplayTimeLabel(false/*bForceUpdate*/);
      // // }
      seekToEditOffsetAndPlayTickIfMaster();

      tstate.undoEnd(clip_selection);
      parent_form.redraw();
      parent_form.b_update_knob_size = true;
   }

   // <method.png>
   namespace method gotoLoopStart() {
      tstate.undoAddMini(clip_selection);
      tstate.edit_offset = tstate.loop_start;
      tstate.view_offset = tstate.loop_start - tstate.vis_ticks*0.3;

      // Clip right
      if((tstate.view_offset + tstate.vis_ticks) >= tstate.calcCanvasSizeTicks())
         tstate.view_offset = tstate.calcCanvasSizeTicks() - tstate.vis_ticks;
      else if(tstate.view_offset < 0)
         tstate.view_offset = 0;

      tstate.queuePlayOffset(tstate.loop_start, false/*bReplay*/);

      // // if(parent_node.nodeIsMaster())
      // // {
      // //    current_song.seek(tstate.edit_offset);
      // //    current_song.setSongOffset(tstate.edit_offset); // update ui_song_offset
      // //    root_form.updateReplayTimeLabel(false/*bForceUpdate*/);
      // // }
      seekToEditOffsetAndPlayTickIfMaster();

      tstate.undoEnd(clip_selection);
      parent_form.redraw();
      parent_form.b_update_knob_size = true;
   }

   // <method.png>
   protected method setEditOffsetToPx(float _px) {
      // Set edit position
      int ticks = getGridAlignedTickOffsetForPx(_px);
      tstate.edit_offset = ticks;

      if(!replay.b_playing)
      {
         tstate.queuePlayOffset(getGridAlignedTickOffsetForPx(_px), false/*bReplay*/);

         // // if(parent_node.nodeIsMaster())
         // // {
         // //    current_song.seek(tstate.edit_offset);
         // //    current_song.setSongOffset(tstate.edit_offset); // update ui_song_offset
         // //    root_form.updateReplayTimeLabel(false/*bForceUpdate*/);
         // // }
         seekToEditOffsetAndPlayTickIfMaster();
      }

      compositeAll();
   }

   // <method.png>
   namespace method setEditOffsetToTicks(int ticks) {
      // trace "xxx setEditOffsetToTicks("+ticks+")";
      // Set edit position
      tstate.edit_offset = ticks;

      if(!replay.b_playing)
      {
         tstate.queuePlayOffset(ticks, false/*bReplay*/);

         // // if(parent_node.nodeIsMaster())
         // // {
         // //    current_song.seek(tstate.edit_offset);
         // //    current_song.setSongOffset(tstate.edit_offset); // update ui_song_offset
         // //    root_form.updateReplayTimeLabel(false/*bForceUpdate*/);
         // //    replay.playTicks(1);  // [17Nov2023] send mute/pattern selection
         // // }
         seekToEditOffsetAndPlayTickIfMaster();
      }

      compositeAll();
   }

   // <method_set.png>
   public method setLeftLoopLocatorToEditOffset() {
      tstate.setLoopRange(tstate.edit_offset, tstate.loop_end);
      redraw();
      Global.Print("Set left loop locator to "+tstate.loop_start);
   }

   // <method_set.png>
   public method setRightLoopLocatorToEditOffset() {
      tstate.setLoopRange(tstate.loop_start, tstate.edit_offset);
      redraw();
      Global.Print("Set right loop locator to "+tstate.loop_end);
   }

   // <method.png>
   protected method autoscrollAtBorders(MouseEvent _currentEv) {
      if(_currentEv.mouse_rel_x >= (getSizeX() - 32))
      {
         if(parent_form.scrollRightDrag())
            parent_form.redraw();
      }
      else if(_currentEv.mouse_rel_x < 32)
      {
         if(parent_form.scrollLeftDrag())
            parent.redraw();
      }
   }

   // <method_get.png>
   protected method getTrackIndexAtPy(float _mouseRelY) : int {
      float py = _mouseRelY - GetTopSY();
      int trackIdx = int(py / getCurrentTrackSYScaled());
      if(trackIdx < 0)
         trackIdx = 0;
      if(!tstate.b_show_marker)
         trackIdx++;
      return trackIdx;
   }

   // <ui_mouse.png>
   protected method handleDragScrollX() {
      float sx = getSizeX() - 2*2;
      float ticksPerPix = tstate.vis_ticks / sx;
      int tickOff = drag_start_tick_offset - (UI.mouse_grab_relx * ticksPerPix);
      int totalTicks = tstate.calcCanvasSizeTicks();

      if(tickOff < 0)
      {
         // Clip left
         tickOff = 0;
      }
      else if((tickOff + tstate.vis_ticks) > totalTicks)
      {
         // Clip right
         tickOff = totalTicks - tstate.vis_ticks;
      }

      tstate.view_offset = tickOff;
      parent_form.b_update_knob_size = true;  // update scroller position
      parent_form.redraw();
   }

   // <ui_mouse.png>
   protected method handleDragScrollY(float _relY) {
      _relY -= drag_start_mouse_y;

      ScrollPane sp <= parent_form.sp_data;
      sp.setViewOffsetY(drag_start_view_offset_y - _relY);
   }

   // <method_set.png>
   protected method setDragStartFromEv(MouseEvent _ev) {
      boolean bAllTracks = (_ev.mouse_rel_y < GetTopSY());
      drag_start_ticks = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);

      if(bAllTracks)
         drag_start_track = tstate.b_show_marker ? 0 : 1;
      else
         drag_start_track = getTrackIndexAtPy(_ev.mouse_rel_y);
   }

   // <method_set.png>
   protected method setDragEndFromEv(MouseEvent _ev) {
      boolean bAllTracks = b_drag_top;
      int ticksAtPx = getSelectionGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
      drag_end_ticks = ticksAtPx;

      if(bAllTracks)
      {
         if(tstate.b_show_marker)
         {
            drag_start_track = 0;
            drag_end_track = tstate.getNumTracks() - 1;
         }
         else
         {
            drag_start_track = 1;
            drag_end_track = tstate.getNumTracks() - 1;
         }
      }
      else
      {
         drag_end_track = getTrackIndexAtPy(_ev.mouse_rel_y);
      }

      sortDragSelection();
      autoscrollAtBorders(_ev);
      compositeAll();
      // // trace "xxx setDragEndFromEv: ticks=("+drag_start_ticks_sorted+";"+drag_end_ticks_sorted+")";
   }

   // <method_set.png>
   protected method setDragStartEndFromDblClickEv(MouseEvent _ev) {
      int ticksAtPx;
      boolean bAllTracks = (_ev.mouse_rel_y < GetTopSY());
      ticksAtPx = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
      drag_start_ticks_sorted = ticksAtPx;
      drag_end_ticks_sorted   = ticksAtPx + tstate.calcDefaultLenTicks();
      drag_start_track_sorted = getTrackIndexAtPy(_ev.mouse_rel_y);
      drag_end_track_sorted   = bAllTracks ? (tstate.getNumTracks() - 1) : drag_start_track_sorted;
   }

   // <method_set.png>
   protected method setDragDeltaFromEv(MouseEvent _ev) {
      int ticksAtPx = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
      drag_delta_ticks = ticksAtPx - drag_start_ticks;

      autoscrollAtBorders(_ev);
      compositeAll();
      // // trace "xxx setDragDeltaFromEv: ticks="+drag_delta_ticks;
   }

   // <method.png>
   public method moveToPreviousMarker() {

      int oldCursorTrack = drag_start_track_sorted;

      NA_Track track <= tstate.getTrackByIdx(0); // 0=marker track
      if(null != track)
      {
         NA_Clip clip <= track.findClipBefore(tstate.edit_offset);
         if(null == clip)
            clip <= track.getClipByIdx(0);

         if(null != clip)
         {
            if(tstate.b_grid_cursor_mode)
            {
               setEditOffsetToTicks(clip.start_ticks);
               drag_start_ticks = clip.start_ticks;
               drag_end_ticks = drag_start_ticks + tstate.calcGridTicks();
               sortDragSelection();
               makeRegionVisible(clip.start_ticks, clip.end_ticks);
               redraw();
            }
            else
            {
               NA_Clip firstClip <= getFirstSelectedClip();
               setEditOffsetToTicks(clip.start_ticks);
               if(null != firstClip)
               {
                  int trackIdx = getFirstSelectedTrackIdx();

                  // Prefer drag selection start track (stay on same track)
                  selectClipsAtEditOffset(tstate.calcGridTicks(), drag_start_track_sorted);

                  if(!haveSelection())
                  {
                     selectClipsAtEditOffset(tstate.calcGridTicks(), trackIdx);
                  }

                  if(!haveSelection())
                  {
                     // Select on last seen drag selection track
                     selectClipsAtEditOffset(clip.end_ticks - clip.start_ticks, drag_start_track_sorted);
                  }
                  if(!haveSelection())
                  {
                     // Select in marker range
                     selectClipsAtEditOffset(clip.end_ticks - clip.start_ticks, trackIdx);
                  }
               }
               makeRegionVisible(clip.start_ticks, clip.end_ticks);
               drag_start_ticks = drag_end_ticks;
               sortDragSelection();
               if(!haveSelection())
               {
                  // Select marker clip
                  selectClipsAtEditOffset(1/*range*/, 0/*trackIdx*/);
               }
            }
         }
      }

      drag_start_track_sorted = oldCursorTrack;
      drag_start_track = oldCursorTrack;
      // trace "xxx prev marker: restore drag_start_track="+drag_start_track;
   }

   // <method.png>
   public method moveToNextMarker() {

      int oldCursorTrack = drag_start_track_sorted;

      NA_Track track <= tstate.getTrackByIdx(0); // 0=marker track
      if(null != track)
      {
         NA_Clip clip <= track.findClipAfter(tstate.edit_offset);
         if(null != clip)
         {
            if(tstate.b_grid_cursor_mode)
            {
               setEditOffsetToTicks(clip.start_ticks);
               drag_start_ticks = clip.start_ticks;
               drag_end_ticks = drag_start_ticks + tstate.calcGridTicks();
               sortDragSelection();
               makeRegionVisible(clip.start_ticks, clip.end_ticks);
               redraw();
            }
            else
            {
               NA_Clip firstClip <= getFirstSelectedClip();
               setEditOffsetToTicks(clip.start_ticks);
               if(null != firstClip)
               {
                  int trackIdx = getFirstSelectedTrackIdx();

                  // Prefer drag selection start track (stay on same track)
                  selectClipsAtEditOffset(tstate.calcGridTicks(), drag_start_track_sorted);

                  if(!haveSelection())
                  {
                     selectClipsAtEditOffset(tstate.calcGridTicks(), trackIdx);
                  }
                  if(!haveSelection())
                  {
                     // Select on last seen drag selection track
                     selectClipsAtEditOffset(clip.end_ticks - clip.start_ticks, drag_start_track_sorted);
                  }
                  if(!haveSelection())
                  {
                     // Select in marker range
                     selectClipsAtEditOffset(clip.end_ticks - clip.start_ticks, trackIdx);
                  }
               }
               makeRegionVisible(clip.start_ticks, clip.end_ticks);
               drag_start_ticks = drag_end_ticks;
               sortDragSelection();
               if(!haveSelection())
               {
                  // Select marker clip
                  selectClipsAtEditOffset(1/*range*/, 0/*trackIdx*/);
               }
            }
         }
      }

      drag_start_track_sorted = oldCursorTrack;
      drag_start_track = oldCursorTrack;
      // // trace "xxx next marker: restore drag_start_track="+drag_start_track;
   }

   // <method.png>
   protected method removeSelectionDuplicates() {
      // Remove duplicates from selection and filter out marker track clips when marker track is hidden
      int nodeGID;
      int clipUID;
      int i;

      NA_Track *track;
      NA_Clip *clip;

      IntArray newSelection;
      newSelection.empty();
      i = 0;

      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         boolean bSkip = false;

         if(!tstate.b_show_marker && (NA_Defs.NODE_GID_MARKER == nodeGID))
         {
            bSkip = true;
         }

         if(!bSkip)
         {
            int k = 0;

            loop(newSelection.numElements / 2)
            {
               if(newSelection[k + 0] == nodeGID)
               {
                  if(newSelection[k + 1] == clipUID)
                  {
                     bSkip = true;
                     break;
                  }
               }

               k += 2;
            }
         }

         if(!bSkip)
         {
            newSelection.add(nodeGID);
            newSelection.add(clipUID);
         }

         i += 2;
      }

      clip_selection = newSelection;
      newSelection.free();
   }

   // <ui_handle.png>
   public method handleSelectionChanged() {
      if(clip_selection.numElements > 0)
      {
         int nodeGID;
         int clipUID;
         int i;

         NA_Track *track;
         NA_Clip *clip;

         removeSelectionDuplicates();

         // Set multi flags (remove caps when clips properties differ)
         int clipMultiFlags = CLIP_MULTI_ALL;

         if(!(parent_form.cb_clip_force_multi_all.isSelected()))
         {
            // Check if multi-editing is allowed (all pattern start at the same position and have the same length)
            if(clip_selection.numElements > 2)
            {
               int commonStart = -1;
               int commonEnd;
               byte commonPatternNr = -1;
               boolean commonMute = maybe;
               int commonOffset = -1;
               byte commonOffsetUnit = -1;
               boolean commonOffsetEnable = maybe;
               i = 0;

               loop(clip_selection.numElements / 2)
               {
                  nodeGID = clip_selection[i + 0];
                  clipUID = clip_selection[i + 1];

                  // // trace "xxx check nodeGID="+nodeGID+" clipUID="+clipUID+" commonStart="+commonStart;

                  track <= tstate.findTrackByGID(nodeGID);
                  if(null != track)
                  {
                     clip <= track.findClipByUID(clipUID);
                     if(null != clip)
                     {
                        if(-1 == commonStart)
                        {
                           commonStart = clip.start_ticks;
                           commonEnd   = clip.end_ticks;
                        }
                        else
                        {
                           if(clip.start_ticks != commonStart)
                              clipMultiFlags &= ~CLIP_MULTI_START;

                           if(clip.end_ticks != commonEnd)
                              clipMultiFlags &= ~CLIP_MULTI_END;
                        }

                        if(-1 == commonPatternNr)
                           commonPatternNr = clip.pattern_nr;
                        else if(clip.pattern_nr != commonPatternNr)
                           clipMultiFlags &= ~CLIP_MULTI_PATTERNNR;

                        if(maybe == commonMute)
                           commonMute = clip.b_mute;
                        else if(clip.b_mute != commonMute)
                           clipMultiFlags &= ~CLIP_MULTI_MUTE;

                        if(-1 == commonOffset)
                           commonOffset = clip.calcOffsetTicks();
                        else if(clip.calcOffsetTicks() != commonOffset)
                           clipMultiFlags &= ~CLIP_MULTI_OFFSET;

                        if(-1 == commonOffsetUnit)
                           commonOffsetUnit = clip.offset_unit;
                        else if(clip.offset_unit != commonOffsetUnit)
                           clipMultiFlags &= ~CLIP_MULTI_OFFSETUNIT;

                        if(-1 == commonOffsetEnable)
                           commonOffsetEnable = clip.b_offset;
                        else if(clip.b_offset != commonOffsetEnable)
                           clipMultiFlags &= ~CLIP_MULTI_OFFSETENABLE;
                     }
                  }

                  // Next clip
                  i += 2;
               }
            }
         }

         // Get first selected clip
         nodeGID = clip_selection[0];
         clipUID = clip_selection[1];

         track <= tstate.findTrackByGID(nodeGID);

         if(null != track)
         {
            clip <= track.findClipByUID(clipUID);
            if(null != clip)
            {
               parent_form.updateClip(clip, clipMultiFlags);
               return;
            }
         }
      }

      parent_form.updateClip(null, 0);
   }

   // <method.png>
   namespace method selectClips(boolean _bAllowToggle, boolean _bAdd) {

      Global.Debug2("NA_TimelineData::selectClips: bAllowToggle="+_bAllowToggle+" bAdd="+_bAdd);

      IntArray oldSelection = clip_selection;

      if(!_bAdd)
         clip_selection.empty();

      int trackIdx = drag_start_track_sorted;
      int numTracks = drag_end_track_sorted - drag_start_track_sorted + 1;

      loop(numTracks)
      {
         NA_Track track <= tstate.getTrackByIdx(trackIdx);

         if(null != track) // should never be null
         {
            boolean bAdd = true;

            IntArray newClipSelection;
            newClipSelection.empty();
            track.addClipsToSelection(newClipSelection, drag_start_ticks_sorted, drag_end_ticks_sorted);
            // // trace "xxx newClipSelection="+#(newClipSelection);

            if(newClipSelection.numElements > 0)
            {
               if(_bAllowToggle)
               {
                  if(oldSelection.numElements > 0)
                  {
                     bAdd = false;

                     int newSelIdx = 0;

                     loop(newClipSelection.numElements / 2)
                     {
                        int newNodeGID = newClipSelection[newSelIdx+0];
                        int newClipUID = newClipSelection[newSelIdx+1];

                        if(DoesSelectionContain(oldSelection, newNodeGID, newClipUID))
                        {
                           if(_bAdd)
                           {
                              RemoveFromSelection(clip_selection, newNodeGID, newClipUID);
                           }
                           // else: don't re-add to new clip_selection
                        }
                        else
                        {
                           clip_selection.add(newNodeGID);
                           clip_selection.add(newClipUID);
                        }

                        newSelIdx += 2;
                     }
                  }
               } // if bAllowToggle
            } // if newClipSelection

            if(bAdd)
            {
               // trace "xxx join newClipSelection="+#(newClipSelection)+" to clip_selection="+#(clip_selection);
               clip_selection.join(clip_selection, newClipSelection);
            }
         } // if track

         trackIdx++;
      }

      // // trace "xxx selectClips: 2";

      handleSelectionChanged();

      // // trace "xxx selectClips: 3";

      Global.Print("Select "+(clip_selection.numElements/2)+" clip"+Utils.GetPluralString(clip_selection.numElements/2)+" within tick range=("+drag_start_ticks_sorted+";"+drag_end_ticks_sorted+")");

      // trace "xxx selectClips: 4 (END)";

      redraw();
   }

   // <method.png>
   protected method selectClipAtEv(MouseEvent _ev, boolean _bAllowToggle, boolean _bAdd) {

      if(_ev.mouse_rel_y < GetTopSY())
      {
         drag_start_track_sorted = 0;
         drag_end_track_sorted = tstate.getNumTracks() - 1;
      }
      else
      {
         drag_start_track_sorted = getTrackIndexAtPy(_ev.mouse_rel_y);
         drag_end_track_sorted = drag_start_track_sorted;
      }

      drag_start_ticks_sorted = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
      // // // drag_end_ticks_sorted = drag_start_ticks_sorted + 1;
      drag_end_ticks_sorted = drag_start_ticks_sorted + (tstate.grid_snap ? tstate.calcGridTicks() : 1);

      selectClips(_bAllowToggle/*bAllowToggle*/, _bAdd);
   }

   // <method.png>
   namespace method selectFirstClipNearTicks(int _ticks, boolean _bDown, boolean _bSetEditOffset) : boolean {
      // returns true when clip has been selected

      // bDown: true=prefer lower tracks, false=prefer upper tracks
      clip_selection.empty();

      NA_Clip clip <= null;

      // Prefer drag_start_track
      NA_Track track <= tstate.getTrackByIdx(drag_start_track);
      if(null != track)
         clip <= track.findClipNear(_ticks);

      if(null == clip)
         clip <= tstate.findClipNear(_ticks, _bDown);

      if(null != clip)
      {
         clip_selection.add(clip.node_gid);
         clip_selection.add(clip.clip_uid);

         makeRegionVisible(clip.start_ticks, clip.end_ticks);

         if(_bSetEditOffset)
            setEditOffsetToTicks(clip.start_ticks);
      }

      handleSelectionChanged();
      redraw();

      return (null != clip);
   }

   // <method.png>
   protected method trySelectClipAtEditOffset() {
      toggleOrSetGridCursorMode(maybe, true/*bUpdateSelection*/, false/*bVerbose*/);
      toggleOrSetGridCursorMode(maybe, true/*bUpdateSelection*/, false/*bVerbose*/);
   }

   // <method.png>
   namespace method extendSelectionToEv(MouseEvent _ev) {

      if(clip_selection.numElements > 0)
      {
         int trackIdx = getTrackIndexAtPy(_ev.mouse_rel_y);

         NA_Track track <= tstate.getTrackByIdx(trackIdx);

         if(null != track)
         {
            drag_start_track_sorted = trackIdx;
            drag_end_track_sorted   = trackIdx;

            // Find first selected track
            int selIdx = 0;
            NA_Track *ctrack;

            while(selIdx < clip_selection.numElements)
            {
               ctrack <= tstate.findTrackByGID(clip_selection.get(selIdx + 0));

               if(null != ctrack)
               {
                  int ctrackIdx = tstate.getTrackIdxByTrack(ctrack);

                  if(ctrackIdx < drag_start_track_sorted)
                     drag_start_track_sorted = ctrackIdx;

                  if(ctrackIdx > drag_end_track_sorted)
                     drag_end_track_sorted = ctrackIdx;
               }

               selIdx += 2;
            }

            // Get clip range
            int allStart = 9999999;
            int allEnd = 0;

            selIdx = 0;
            while(selIdx < clip_selection.numElements)
            {
               ctrack <= tstate.findTrackByGID(clip_selection.get(selIdx + 0));
               if(null != ctrack)
               {
                  NA_Clip clip <= ctrack.findClipByUID(clip_selection.get(selIdx + 1));
                  if(null != clip)
                  {
                     if(clip.start_ticks < allStart)
                        allStart = clip.start_ticks;

                     if(clip.end_ticks > allEnd)
                        allEnd = clip.end_ticks;
                  }
               }

               selIdx += 2;
            }

            int mouseTicks = getTickOffsetForPx(_ev.mouse_rel_x);
            if(mouseTicks < allStart)
               allStart = mouseTicks;
            if(mouseTicks > allEnd)
               allEnd = mouseTicks;

            drag_start_ticks_sorted = allStart;
            drag_end_ticks_sorted = allEnd;
            selectClips(false/*bAllowToggle*/, true/*bAdd*/);

            handleSelectionChanged();
            redraw();
         }
      }
   }

   // <method.png>
   protected method haveClipAtEv(MouseEvent _ev, boolean _bMustBeSelected) : boolean {

      int ticksAtPx = getTickOffsetForPx(_ev.mouse_rel_x);
      int trackIdx = getTrackIndexAtPy(_ev.mouse_rel_y);

      NA_Track track <= tstate.getTrackByIdx(trackIdx);

      if(null != track)
      {
         NA_Clip *clip;
         foreach clip in track.clips
         {
            if(clip.start_ticks <= ticksAtPx < clip.end_ticks)
            {
               if(_bMustBeSelected)
               {
                  int i = 0;
                  loop(clip_selection.numElements / 2)
                  {
                     if((clip_selection[i + 0] == clip.node_gid) &&
                        (clip_selection[i + 1] == clip.clip_uid)
                        )
                     {
                        return true;
                     }

                     i += 2;
                  }
               }
               else
               {
                  return true;
               }
            }
         }
      }

      return false;
   }

   // <method.png>
   public =replay= method createMarkerClipForSelection() {
      if(haveSelection())
      {
         tstate.undoAdd(clip_selection);
         local Integer minTicks;
         local Integer maxTicks;
         findSelectionMinMaxTicks(minTicks, maxTicks);
         int numTicks = maxTicks - minTicks;
         NA_Track track <= tstate.getTrackByIdx(0/*marker*/);
         NA_Clip oldClip <= track.findClipWithinRange(minTicks, maxTicks);
         track.deleteRange(minTicks, maxTicks);
         NA_Clip newClip <= track.newClip(minTicks, maxTicks, true/*bSort*/);
         int patNr = 0;
         if(null != oldClip)
         {
            patNr = oldClip.pattern_nr;
         }
         else
         {
            // auto-assign pattern nr (returns -1 when all are used)
            patNr = track.findUnusedMarkerPatternNr(0);
         }
         newClip.pattern_nr = patNr & 127;
         Global.Print("Create marker for selection range=("+minTicks+";"+maxTicks+")");
         redraw();
         clip_selection.empty();
         clip_selection.add(NA_Defs.NODE_GID_MARKER);
         clip_selection.add(newClip.clip_uid);
         tstate.undoEnd(clip_selection);
         handleSelectionChanged();
      }
      else
         Global.Warning("CreateMarker: no selection");
   }

   // <method.png>
   protected method selectClipsUnderMarker(boolean _bIncludingMarkerClip) : NA_Clip {
      clip_selection.empty();
      NA_Clip markerClip <= tstate.findMarkerClipByTickOffset(tstate.edit_offset);
      if(null != markerClip)
      {
         int trackIdx = 1;  // 0=marker track
         int numTracks = tstate.getNumTracks();
         while(trackIdx < numTracks)
         {
            NA_Track track <= tstate.getTrackByIdx(trackIdx);
            track.addClipsToSelection(clip_selection, markerClip.start_ticks, markerClip.end_ticks);
            // Next track
            trackIdx++;
         }

         if(_bIncludingMarkerClip)
         {
            clip_selection.add(markerClip.node_gid/*-2*/);
            clip_selection.add(markerClip.clip_uid);
         }
      }
      handleSelectionChanged();
      if(!clip_selection.isEmpty())
      {
         // // sortSelectionMarkerLast();
         // trace "xxx selectClipsUnderMarker: clip_selection="+#(clip_selection);
         tstate.edit_offset = markerClip.start_ticks;  // make next cursor left stay on marker track

         makeSelectionVisible();
         Global.Print("Select "+(clip_selection.numElements/2)+" clip"+Utils.GetPluralString(clip_selection.numElements/2)+" under marker range=("+markerClip.start_ticks+";"+markerClip.end_ticks+")");
      }
      else
         Global.Print("No clips under marker (or no marker)");
      redraw();
      return markerClip;
   }

   // <method.png>
   protected method areAllClipsUnderMarkerSelected(boolean _bIncludingMarkerClip, boolean _bRestoreSelection) : boolean {
      local IntArray origSelection = clip_selection;
      selectClipsUnderMarker(_bIncludingMarkerClip);
      boolean r = CompareSelections(origSelection, clip_selection);
      if(_bRestoreSelection)
         clip_selection = origSelection;
      return r;
   }

   // // // <method.png>
   // // // (note) currently unused (+ there's already reverseSelection() which also calls handleSelectionChanged())
   // // protected method reverseSelectionInt() {
   // //    local IntArray newSel;
   // //    int numClips = clip_selection.numElements / 2;
   // //    int clipIdx = numClips;
   // //    loop(numClips)
   // //    {
   // //       clipIdx--;
   // //       newSel.add2(clip_selection.get(clipIdx*2 + 0),  // node gid
   // //                   clip_selection.get(clipIdx*2 + 1)   // clip uid
   // //                   );
   // //    }
   // //    clip_selection = deref newSel;
   // // }

   // <method.png>
   protected method sortSelectionMarkerFirst() {
      int idx = 0;
      loop(clip_selection.numElements / 2)
      {
         if(NA_Defs.NODE_GID_MARKER == clip_selection.get(idx))
         {
            int clipUID = clip_selection.get(idx + 1);
            clip_selection.delete2(idx);
            clip_selection.insert(0, clipUID);
            clip_selection.insert(0, NA_Defs.NODE_GID_MARKER);
            handleSelectionChanged();
            break;
         }
         idx += 2;
      }
   }

   // <method.png>
   protected method sortSelectionMarkerLast() {
      int idx = 0;
      loop(clip_selection.numElements / 2)
      {
         if(NA_Track.NODE_GID_MARKER == clip_selection.get(idx))
         {
            int clipUID = clip_selection.get(idx + 1);
            clip_selection.delete2(idx);
            clip_selection.add(NA_Track.NODE_GID_MARKER);
            clip_selection.add(clipUID);
            handleSelectionChanged();
            break;
         }
         idx += 2;
      }
   }

   // <method.png>
   public method cloneCurrentMarkerSection() {
      if(tstate.b_show_marker)
      {
         local IntArray oldSel = clip_selection;

         // // trace "xxx cloneCurrentMarkerSection: clip_selection="+#(clip_selection);

         // Already have a selection that includes a marker clip ?
         NA_Clip markerClip <= getFirstSelectedMarkerClip();
         if(null != markerClip)
            tstate.edit_offset = markerClip.start_ticks;
         markerClip <= selectClipsUnderMarker(true/*bIncludingMarkerClip*/);
         if(!clip_selection.isEmpty())
         {
            // Set cursor y to marker track
            selectTrack(0/*marker*/);
            tstate.edit_offset = markerClip.start_ticks;

            // Copy clips, go to end of marker section, paste clips
            copySelectedClipsToClipboard(false/*bCut*/);
            tstate.edit_offset = markerClip.end_ticks;
            pasteClipboard(true/*bInsertSilence*/);  // selects new clips

            sortSelectionMarkerLast();

            // // NA_Track track <= getLastSelectedTrack();
            // // trace "xxx last track="+#(track);
            // // if(null != track)
            // //    trace "xxx last sel isMarker="+track.isMarker();
            handleSelectionChanged();
            redraw();

            // // // Create new marker clip and assign unique patnr
            // // NA_Track track <= tstate.getTrackByIdx(0/*marker*/);
            // // NA_Clip markerClipNew <= track.newClip(markerClip.end_ticks,
            // //                                                         markerClip.end_ticks + (markerClip.end_ticks - markerClip.start_ticks),
            // //                                                         true/*bSort*/
            // //                                                         );

            Global.Print("Clone marker section ("+(clip_selection.numElements/2)+" clip"+Utils.GetPluralString(clip_selection.numElements/2)+" in range=("+markerClip.start_ticks+";"+markerClip.end_ticks+"))");
         }
         else
         {
            // Nothing changed, restore selection
            clip_selection = oldSel;
            Global.Print("clone: no marker section");
         }
      }
      else
      {
         Global.Print("clone: marker track not visible (press 'm' first)");
      }
   }

   // <method.png>
   protected method findTrackClipsInCurrentMarkerSection(IntArray _retSelection) {
      _retSelection.empty();
      NA_Clip markerClip <= tstate.findMarkerClipByTickOffset(tstate.edit_offset);
      if(null != markerClip)
      {
         NA_Track track <= tstate.getTrackByIdx(drag_start_track_sorted); // 0=marker track
         if(null != track)
         {
            if(!track.isMarker())
               track.findAllClipsWithinRange(markerClip.start_ticks, markerClip.end_ticks, _retSelection);
         }
      }
   }

   // <method.png>
   protected method selectAll() {
      NA_Track *track;
      NA_Clip *clip;

      boolean bSelectAll = true;

      int numSelected = (clip_selection.numElements / 2);

      if(numSelected > 0)
      {
         bSelectAll = false;

         // Check if all selected clips reference the same track
         boolean bSameTrack = true;
         int i = 0;
         int nodeGID = clip_selection[0];

         loop(numSelected)
         {
            if(clip_selection[i + 0] != nodeGID)
            {
               bSameTrack = false;
               break;
            }

            i += 2;
         }

         track <= tstate.findTrackByGID(clip_selection[0]);
         if(null != track)
         {
            if(bSameTrack)
            {
               // Check if all track clips are already selected
               if(numSelected == (track.clips.numElements))
               {
                  bSelectAll = true;
               }
               else
               {
                  // Check if all track clips within marker section are already selected
                  local IntArray selSection;
                  findTrackClipsInCurrentMarkerSection(selSection);
                  if(!selSection.isEmpty() && numSelected != selSection.numElements/2)
                  {
                     clip_selection = selSection;
                     makeSelectionVisible();
                  }
                  else
                  {
                     // Select all track clips
                     clip_selection.empty();

                     foreach clip in track.clips
                     {
                        clip_selection.add(track.node_gid);
                        clip_selection.add(clip.clip_uid);
                     }
                  }
               }
            }
            else
            {
               bSelectAll = true;
            }
         }
      }

      if(bSelectAll)
      {
         // (note) must first select clips w/o marker to avoid collision with "sametrack" selection behaviour
         bSelectAll = areAllClipsUnderMarkerSelected(true/*bIncludingMarkerClip*/, true/*bRestoreSelection*/);
         if(!bSelectAll)
         {
            bSelectAll = areAllClipsUnderMarkerSelected(false/*bIncludingMarkerClip*/, true/*bRestoreSelection*/);
            if(!bSelectAll)
               bSelectAll = areAllClipsUnderMarkerSelected(true/*bIncludingMarkerClip*/, false/*bRestoreSelection*/);
         }
         else
         {
            bSelectAll = areAllClipsUnderMarkerSelected(false/*bIncludingMarkerClip*/, false/*bRestoreSelection*/);
         }

         if(bSelectAll)
         {
            int totalNumClips = 0;

            foreach track in tstate.tracks
            {
               if((tstate.b_show_marker && track.isMarker()) || !track.isMarker())
                  totalNumClips += track.clips.numElements;
            }

            // Select _all_ tracks
            clip_selection.empty();

            if(numSelected != totalNumClips)
            {
               foreach track in tstate.tracks
               {
                  if((tstate.b_show_marker && track.isMarker()) || !track.isMarker()) // paranoia
                  {
                     foreach clip in track.clips
                     {
                        clip_selection.add(track.node_gid);
                        clip_selection.add(clip.clip_uid);
                     }
                  }
               }
            }
            // else: select none
         }
         else
         {
            // Marker section selected
            makeSelectionVisible();
         }
      }

      handleSelectionChanged();
      // // // makeSelectionVisible();
      redraw();
   }

   // <method.png>
   namespace method toggleExpandClipSelectionY(boolean _bUp) {
      if(haveSelection())
      {
         Integer minTicks;
         Integer maxTicks;
         findSelectionMinMaxTicks(minTicks, maxTicks);

         if(getNumSelectedTracks() > 1)
         {
            // Select clip(s) on single track
            NA_Track track <= getFirstSelectedTrack();
            int trackIdx = tstate.getTrackIdxByTrack(track);
            if(trackIdx >= 0)
            {
               drag_start_ticks = minTicks;
               drag_end_ticks = maxTicks;
               drag_start_track = trackIdx;
               drag_end_track = trackIdx;
               sortDragSelection();
               selectClips(false/*bAllowToggle*/, false/*bAdd*/);
               drag_start_ticks = drag_end_ticks;
               drag_start_ticks_sorted = drag_end_ticks_sorted;
            }
         }
         else
         {
            // Select on all tracks
            drag_start_ticks = minTicks;
            drag_end_ticks = maxTicks;
            drag_start_track = tstate.b_show_marker ? 0 : 1;
            drag_end_track = tstate.getNumTracks() - 1;
            sortDragSelection();
            selectClips(false/*bAllowToggle*/, false/*bAdd*/);
            drag_start_ticks = drag_end_ticks;
            drag_start_ticks_sorted = drag_end_ticks_sorted;
            if(_bUp)
               reverseSelection(); // marker clip first so next left/right moves on marker track
         }
      }
   }

   // // <method.png>
   // //       // if((track.isMarker() && tstate.b_show_marker) || !track.isMarker())
   // // protected method selectFirstVisibleClip(boolean _bAdd) {
   // //    NA_Track *track;
   // //    NA_Clip clip <= null;
   // //    int nodeGID;
   // //    int clipUID;

   // //    foreach track in tstate.tracks
   // //    {
   // //       clip <= track.findClipNear(tstate.view_offset);

   // //       if(null != clip)
   // //       {
   // //          nodeGID = track.node_gid;
   // //          clipUID = clip.clip_uid;
   // //          break;
   // //       }
   // //    }

   // //    if(null == clip)
   // //    {
   // //       foreach track in tstate.tracks
   // //       {
   // //          clip <= track.clips.get(0);

   // //          if(null != clip)
   // //          {
   // //             nodeGID = track.node_gid;
   // //             clipUID = clip.clip_uid;
   // //             break;
   // //          }
   // //       }
   // //    }

   // //    if(!_bAdd)
   // //    {
   // //       clip_selection.empty();
   // //    }

   // //    if(null != clip)
   // //    {
   // //       clip_selection.add(nodeGID);
   // //       clip_selection.add(clipUID);
   // //    }
   // // }

   // <method.png>
   protected method getFirstSelectedTrack() : NA_Track {
      if(clip_selection.numElements > 0)
      {
         int nodeGID = clip_selection.get(0);
         int clipUID = clip_selection.get(1);
         NA_Track track <= tstate.findTrackByGID(nodeGID);
         return track;
      }
      return null;
   }

   // <method.png>
   namespace method getLastSelectedTrackIdx() : int {
      int r = 0;
      if(clip_selection.numElements > 0)
      {
         int nodeGID = clip_selection.getRev(1);
         int clipUID = clip_selection.getRev(0);
         NA_Track track <= tstate.findTrackByGID(nodeGID);
         if(null != track)
            r = tstate.getTrackIdxByTrack(track);
      }
      return r;
   }

   // <method.png>
   namespace method getFirstSelectedTrackIdx() : int {
      int r = 0;
      if(clip_selection.numElements > 0)
      {
         int nodeGID = clip_selection.get(0);
         int clipUID = clip_selection.get(1);
         NA_Track track <= tstate.findTrackByGID(nodeGID);
         if(null != track)
            r = tstate.getTrackIdxByTrack(track);
      }
      return r;
   }

   // <method.png>
   protected method getLastSelectedTrack() : NA_Track {
      if(clip_selection.numElements > 0)
      {
         int nodeGID = clip_selection.get(clip_selection.numElements - 2);
         int clipUID = clip_selection.get(clip_selection.numElements - 1);
         NA_Track track <= tstate.findTrackByGID(nodeGID);
         return track;
      }
      return null;
   }

   // <method.png>
   namespace method getFirstSelectedSortedTrackIdx() : int {
      int r = 0;
      int selIdx = 0;
      int minTrackIdx = -1;
      loop(clip_selection.numElements / 2)
      {
         int nodeGID = clip_selection.get(selIdx + 0);
         int clipUID = clip_selection.get(selIdx + 1);
         NA_Track track <= tstate.findTrackByGID(nodeGID);
         if(null != track)
         {
            r = tstate.getTrackIdxByTrack(track);
            if( (-1 == minTrackIdx) || (r < minTrackIdx) )
               minTrackIdx = r;
         }
         selIdx += 2;
      }
      return (-1 == minTrackIdx) ? 0 : minTrackIdx;
   }

   // <method_get.png>
   protected method getSelectedClipByIndex(int _selIdx) : NA_Clip {
      if(0 <= (_selIdx*2+1) < clip_selection.numElements )
      {
         int nodeGID = clip_selection.get(_selIdx*2 + 0);
         int clipUID = clip_selection.get(_selIdx*2 + 1);
         NA_Track track <= tstate.findTrackByGID(nodeGID);

         if(null != track)
         {
            NA_Clip clip <= track.findClipByUID(clipUID);
            return clip;
         }
      }
      return null;
   }

   // <method.png>
   namespace method getFirstSelectedClip() : NA_Clip {
      return getSelectedClipByIndex(0);
   }

   // <method.png>
   namespace method getFirstSelectedMarkerClip() : NA_Clip {
      int idx = 0;
      loop(clip_selection.numElements / 2)
      {
         if(NA_Track.NODE_GID_MARKER == clip_selection.get(idx))
            return tstate.findMarkerClipByUID(clip_selection.get(idx+1)/*clipUID*/);
         idx += 2;
      }
      return null;
   }

   // <method.png>
   protected method isFirstSelectedClipAudio() : boolean {
      NA_Clip clip <= getFirstSelectedClip();
      if(null != clip)
         return clip.isAudio();
      return false;
   }

   // <method.png>
   namespace method getSecondSelectedTrackClip() : NA_Clip {
      NA_Clip firstClip <= getFirstSelectedClip();
      if(null != firstClip)
      {
         int idx = 1*2;
         int nodeGIDFirst = firstClip.node_gid;
         while(idx < clip_selection.numElements)
         {
            int nodeGID = clip_selection.get(idx + 0);
            if(nodeGID != nodeGIDFirst)
               return getSelectedClipByIndex(idx / 2);
            idx += 2;
         }
      }
      return null;
   }

   // <method.png>
   protected method getLastSelectedClip() : NA_Clip {
      return getSelectedClipByIndex(clip_selection.numElements/2 - 1);
   }

   // <method_find.png>
   protected method findLastSelectedSortedClipByNodeGID(int _nodeGID) : NA_Clip {
      int selIdx = 0;
      NA_Track bestClip <= null;
      int bestStartTicks = -1;
      NA_Track track <= tstate.findTrackByGID(_nodeGID);
      if(null != track)
      {
         loop(clip_selection.numElements / 2)
         {
            int nodeGID = clip_selection.get(selIdx + 0);
            if(nodeGID == _nodeGID)
            {
               int clipUID = clip_selection.get(selIdx + 1);
               NA_Clip clip <= track.findClipByUID(clipUID);
               if(null != clip)
               {
                  if(clip.start_ticks > bestStartTicks)
                  {
                     bestClip <= clip;
                     bestStartTicks = clip.start_ticks;
                  }
               }
            }

            selIdx += 2;
         }
      }
      return bestClip;
   }

   // <method.png>
   protected method sortSelectedClipsByStartTicks() {
      int numSelected = clip_selection.numElements / 2;
      Global.Debug3("NA_TimelineData::sortSelectedClipsByStartTicks: numSelected="+numSelected);
      if(numSelected > 1)
      {
         local IntArray newIdx;
         newIdx.identity(numSelected);

         // good ole bubble sort
         int sortedIdx;
         boolean bSwapped;
         boolean bAnySwapped = false;
         do
         {
            bSwapped = false;
            sortedIdx = 0;
            loop(numSelected - 1)
            {
               int clipIdxL = newIdx[sortedIdx];
               int clipIdxR = newIdx[sortedIdx + 1];
               NA_Clip clipL <= getSelectedClipByIndex(clipIdxL);
               NA_Clip clipR <= getSelectedClipByIndex(clipIdxR);
               if(clipL.start_ticks > clipR.start_ticks)
               {
                  newIdx.swap(sortedIdx, sortedIdx + 1);
                  bSwapped = true;
                  bAnySwapped = true;
               }
               sortedIdx++;
            }
         }
         while(bSwapped);

         if(bAnySwapped)
         {
            // Create new selection
            local IntArray newSel;
            sortedIdx = 0;
            loop(numSelected)
            {
               int selIdx = newIdx[sortedIdx];
               int nodeGID = clip_selection.get(selIdx*2 + 0);
               int clipUID = clip_selection.get(selIdx*2 + 1);
               newSel.add(nodeGID);
               newSel.add(clipUID);
               sortedIdx++;
            }
            clip_selection = deref newSel;
            Global.Debug2("NA_TimelineData::sortSelectedClipsByStartTicks: sorted "+numSelected+" clip(s)");
         }
      }
   }

   // <method.png>
   protected method selectAllClipsAtEditOffset(int _range) {
      drag_start_ticks_sorted = tstate.edit_offset;
      drag_end_ticks_sorted = tstate.edit_offset + _range;
      drag_start_track_sorted = 0;
      drag_end_track_sorted = tstate.getNumTracks() - 1;
      selectClips(false/*bAllowToggle*/, false/*bAdd*/);
      handleSelectionChanged();
      makeSelectionVisible();
   }

   // <method.png>
   protected method selectClipsAtEditOffset(int _range, int _trackIdx) {
      // // trace "xxx selectClipsAtEditOffset: range="+_range+" track="+_trackIdx;
      drag_start_ticks_sorted = tstate.edit_offset;
      drag_end_ticks_sorted = tstate.edit_offset + _range;
      drag_start_track_sorted = _trackIdx;
      drag_end_track_sorted = _trackIdx;
      selectClips(false/*bAllowToggle*/, false/*bAdd*/);
      handleSelectionChanged();
      makeSelectionVisible();
   }

   // <method.png>
   protected method selectClipUpNearSelection(boolean _bAdd) : boolean {

      boolean ret = false;
      int trackIdx;
      local IntArray newSelection;
      int gridTicks = tstate.calcGridTicks();

      if(haveSelection())
      {
         NA_Track track <= getLastSelectedTrack();
         if(null != track)
         {
            trackIdx = tstate.getTrackIdxByTrack(track);

            local Integer minTicks;
            local Integer maxTicks;
            findSelectionMinMaxTicks(minTicks, maxTicks);

            while(--trackIdx >= 0)
            {
               if(0 == trackIdx && !tstate.b_show_marker)
                  break;

               track <= tstate.getTrackByIdx(trackIdx);
               if(null != track)
               {
                  track.addClipsToSelection(newSelection,
                                            minTicks,
                                            maxTicks + ((tstate.edit_offset == maxTicks)?gridTicks:0)
                                            );

                  if(newSelection.numElements > 0)
                  {
                     setGridCursorTrack(trackIdx);
                     break;
                  }
               }
            }
         }
      }
      else
      {
         // No selection, try to select near grid cursor
         trackIdx = drag_start_track;
         while(--trackIdx >= 0)
         {
            if(0 == trackIdx && !tstate.b_show_marker)
               break;

            track <= tstate.getTrackByIdx(trackIdx);
            if(null != track)
            {
               track.addClipsToSelection(newSelection,
                                         tstate.edit_offset,
                                         tstate.edit_offset + gridTicks
                                         );

               if(newSelection.numElements > 0)
               {
                  setGridCursorTrack(trackIdx);
                  break;
               }
            }
         }
      }

      ret = (newSelection.numElements > 0);
      if(ret)
      {
         if(_bAdd)
            clip_selection.join(clip_selection, newSelection);
         else
            clip_selection = newSelection;

         handleSelectionChanged();
         makeSelectionVisible();
         // // centerFirstSelectedTrack();
         centerTrackByIdx(drag_start_track);
         redraw();
      }

      return ret;
   }

   // <method.png>
   protected method tryMoveCursorToClipBoundaryUp() : boolean {
      int trackIdx = drag_start_track_sorted;
      while(--trackIdx >= 0)
      {
         if(trackIdx <= 0 && !tstate.b_show_marker)
            return false;

         NA_Track track <= tstate.getTrackByIdx(trackIdx);
         if(null != track)
         {
            NA_Clip clip <= track.findClipAt(tstate.edit_offset);
            if(null == clip)
               clip <= track.findClipBefore(tstate.edit_offset);
            if(null != clip)
            {
               if(clip.start_ticks == tstate.edit_offset || clip.end_ticks == tstate.edit_offset)
               {
                  setGridCursorTrack(trackIdx);
                  centerTrackByIdx(drag_start_track);
                  selectNone();
                  trySelectClipAtEditOffset();
                  return true;
               }
            }
         }
      }
      return false;
   }

   // <method.png>
   protected method selectClipUp(boolean _bAdd) {

      if(!_bAdd && tstate.b_edge_selection_mode)
      {
         if(tryMoveCursorToClipBoundaryUp())
            return;
      }

      if(!selectClipUpNearSelection(_bAdd))
      {
         if(null == getLastSelectedClip())
         {
            selectFirstClipNearTicks(tstate.edit_offset, false/*bDown*/, true/*bSetEditOffset*/);
            centerFirstSelectedTrack();
            return;
         }

         NA_Track track <= getLastSelectedTrack();

         if(null != track)
         {
            int trackIdx = tstate.getTrackIdxByTrack(track);
            if(trackIdx > 0)
            {
               NA_Clip clip <= getLastSelectedClip();

               boolean bTryPrevTrack;
               do
               {
                  bTryPrevTrack = false;

                  track <= tstate.getTrackByIdx(trackIdx - 1);
                  if(null != track)
                  {
                     if((track.getNumClips() > 0) && ((track.isMarker() && tstate.b_show_marker) || !track.isMarker()))
                     {
                        clip <= track.findClipNearUICursor(clip.start_ticks, clip.end_ticks);
                        if(null != clip)
                        {
                           if(!_bAdd)
                              clip_selection.empty();

                           clip_selection.add(track.node_gid);
                           clip_selection.add(clip.clip_uid);

                           if(false)
                           {
                              setEditOffsetToTicks(clip.start_ticks);
                              makeRegionVisible(clip.start_ticks, clip.end_ticks);
                           }

                           setGridCursorTrack(trackIdx - 1);
                           handleSelectionChanged();
                           redraw();
                        }
                     }
                     else
                     {
                        bTryPrevTrack = (trackIdx - 2) >= 0;
                        trackIdx--;
                     }
                  }
                  else
                  {
                     bTryPrevTrack = (trackIdx - 2) >= 0;
                     trackIdx--;
                  }
               }
               while(bTryPrevTrack);

               makeSelectionVisible();
               centerFirstSelectedTrack();

            } // if trackIdx > 0
         } // if track
      }

   }

   // <method.png>
   protected method selectClipDownNearSelection(boolean _bAdd) : boolean {
      boolean ret = false;
      int gridTicks = tstate.calcGridTicks();

      if(haveSelection())
      {
         NA_Track track <= getLastSelectedTrack();

         if(null != track)
         {
            int trackIdx = tstate.getTrackIdxByTrack(track);

            local Integer minTicks;
            local Integer maxTicks;
            findSelectionMinMaxTicks(minTicks, maxTicks);

            local IntArray newSelection;

            while(trackIdx < tstate.getNumTracks())
            {
               track <= tstate.getTrackByIdx(++trackIdx);
               if(null != track)
               {
                  track.addClipsToSelection(newSelection,
                                            minTicks,
                                            maxTicks + ((tstate.edit_offset == maxTicks)?gridTicks:0)
                                            );

                  if(newSelection.numElements > 0)
                  {
                     setGridCursorTrack(trackIdx);
                     break;
                  }
               }
            }

            ret = (newSelection.numElements > 0);

            if(ret)
            {
               if(_bAdd)
                  clip_selection.join(clip_selection, newSelection);
               else
                  clip_selection = newSelection;

               handleSelectionChanged();
               makeSelectionVisible();
               // // // centerFirstSelectedTrack();
               centerTrackByIdx(drag_start_track);
               redraw();
            }
         }
      }

      return ret;
   }

   // <method.png>
   protected method tryMoveCursorToClipBoundaryDown() : boolean {
      int trackIdx = drag_start_track_sorted;
      while(++trackIdx < (tstate.tracks.numElements))
      {
         NA_Track track <= tstate.getTrackByIdx(trackIdx);
         if(null != track)
         {
            NA_Clip clip <= track.findClipAt(tstate.edit_offset);
            if(null == clip)
               clip <= track.findClipBefore(tstate.edit_offset);
            if(null != clip)
            {
               if(clip.start_ticks == tstate.edit_offset || clip.end_ticks == tstate.edit_offset)
               {
                  setGridCursorTrack(trackIdx);
                  centerTrackByIdx(trackIdx);
                  selectNone();
                  trySelectClipAtEditOffset();
                  return true;
               }
            }
         }
      }
      return false;
   }

   // <method.png>
   protected method selectClipDown(boolean _bAdd) {

      if(!_bAdd && tstate.b_edge_selection_mode)
      {
         if(tryMoveCursorToClipBoundaryDown())
            return;
      }

      if(!selectClipDownNearSelection(_bAdd))
      {
         if(null == getLastSelectedClip())
         {
            selectFirstClipNearTicks(tstate.edit_offset, true/*bDown*/, true/*bSetEditOffset*/);
            centerFirstSelectedTrack();
            return;
         }

         NA_Track track <= getLastSelectedTrack();

         if(null != track)
         {
            int trackIdx = tstate.getTrackIdxByTrack(track);

            if((trackIdx+1) < (tstate.tracks.numElements))
            {
               NA_Clip clip <= getLastSelectedClip();

               if(null != clip)
               {
                  boolean bTryNextTrack;
                  do
                  {
                     bTryNextTrack = false;

                     track <= tstate.getTrackByIdx(trackIdx + 1);

                     if(null != track)
                     {
                        if((track.getNumClips() > 0) && ((track.isMarker() && tstate.b_show_marker) || !track.isMarker()))
                        {
                           clip <= track.findClipNearUICursor(clip.start_ticks, clip.end_ticks);

                           if(null != clip)
                           {
                              if(!_bAdd)
                                 clip_selection.empty();

                              clip_selection.add(track.node_gid);
                              clip_selection.add(clip.clip_uid);

                              if(false)
                              {
                                 setEditOffsetToTicks(clip.start_ticks);
                                 makeRegionVisible(clip.start_ticks, clip.end_ticks);
                              }

                              setGridCursorTrack(trackIdx + 1);
                              handleSelectionChanged();
                              redraw();
                           }
                        }
                        else
                        {
                           bTryNextTrack = ((trackIdx + 2) < (tstate.tracks.numElements));
                           trackIdx++;
                        }
                     }
                     else
                     {
                        bTryNextTrack = ((trackIdx + 2) < (tstate.tracks.numElements));
                        trackIdx++;
                     }
                  }
                  while(bTryNextTrack);

                  makeSelectionVisible();
                  centerFirstSelectedTrack();
               } // if clip
            } // if have next track
         } // if track
      }

   }

   // <method.png>
   protected method selectClipFirstOrLeft() {
      if(clip_selection.numElements >= 2*2)
      {
         sortSelectedClipsByStartTicks();

         int nodeGID = clip_selection[0];
         int clipUID = clip_selection[1];

         clip_selection.empty();
         clip_selection.add(nodeGID);
         clip_selection.add(clipUID);

         int trackIdx = getFirstSelectedTrackIdx();
         setGridCursorTrack(trackIdx);

         NA_Clip clip <= getFirstSelectedClip();
         setEditOffsetToTicks(clip.start_ticks);
         makeRegionVisible(clip.start_ticks, clip.end_ticks);

         clip_selection.empty();
         handleSelectionChanged();

         // select clip at edit offset
         trySelectClipAtEditOffset();

         redraw();
      }
      else
      {
         selectClipLeft(false/*bAdd*/, false/*bAllTracks*/);
      }
   }

   // <method.png>
   protected method selectClipLeft(boolean _bAdd, boolean _bAllTracks) {
      if(null == getLastSelectedClip())
      {
         if(!selectFirstClipNearTicks(tstate.edit_offset, false/*bDown*/, true/*bSetEditOffset*/))
         {
            // No clips
            setEditOffsetToTicks(0);
            selectNone();
         }
         return true;
      }

      // trace "xxx selectClipLeft";

      // NA_Track track <= getLastSelectedTrack();
      NA_Track track <= _bAdd ? getLastSelectedTrack() : getFirstSelectedTrack();

      boolean bClipSelected = false;

      if(null != track)
      {
         // // trace "xxx selectClipLeft: track.node_gid="+track.node_gid+" track.audio_track_name=\""+track.audio_track_name+"\"";
         NA_Clip *clip;

         if(!_bAdd)
         {
            sortSelectedClipsByStartTicks();
            clip <= getFirstSelectedClip();
         }
         else
         {
            clip <= getLastSelectedClip();
         }

         int clipIdx;
         boolean bDone = false;

         if(null != clip)
         {
            if(!_bAdd && tstate.b_edge_selection_mode)
            {
               if(clip.start_ticks < tstate.edit_offset)
               {
                  // Move to clip start first
                  setEditOffsetToTicks(clip.start_ticks);
                  makeRegionVisible(clip.start_ticks, clip.end_ticks);
                  clip_selection.empty();
                  clip_selection.add(clip.node_gid);
                  clip_selection.add(clip.clip_uid);
                  handleSelectionChanged();
                  redraw();
                  bClipSelected = true;
                  bDone = true;
                  track <= getLastSelectedTrack();
               }
               else
               {
                  clipIdx = track.getClipIdxByClip(clip);
                  if(clipIdx > 0)
                  {
                     NA_Clip clipL <= track.getClipByIdx(clipIdx - 1);
                     if(clipL.end_ticks != clip.start_ticks)
                     {
                        if(tstate.edit_offset > clipL.end_ticks)
                        {
                           // Move to previous clip end first
                           setEditOffsetToTicks(clipL.end_ticks);
                           makeRegionVisible(clipL.start_ticks, clipL.end_ticks);
                           clip_selection.empty();
                           clip_selection.add(track.node_gid);
                           clip_selection.add(clipL.clip_uid);
                           handleSelectionChanged();
                           redraw();
                           bClipSelected = true;
                           bDone = true;
                        }
                     }
                  }
               }
            }

            if(!bDone)
            {
               clipIdx = track.getClipIdxByClip(clip);

               // // trace "xxx selectClipLeft: bAdd="+_bAdd+" clipIdx="+clipIdx;

               if(clipIdx > 0)
               {
                  clip <= track.getClipByIdx(clipIdx - 1);

                  if(!_bAdd)
                     clip_selection.empty();

                  clip_selection.add(track.node_gid);
                  clip_selection.add(clip.clip_uid);

                  // // trace "xxx setEditOffsetToTicks(clip.start_ticks="+clip.start_ticks+")";

                  setEditOffsetToTicks(clip.start_ticks);

                  if(_bAllTracks)
                  {
                     Integer minTicks;
                     Integer maxTicks;
                     findSelectionMinMaxTicks(minTicks, maxTicks);
                     drag_start_ticks = clip.start_ticks;
                     drag_end_ticks = maxTicks;
                     drag_start_track = 0;
                     drag_end_track = tstate.getNumTracks() - 1;
                     sortDragSelection();
                     selectClips(false/*bAllowToggle*/, _bAdd);
                     // // // reverseSelection();
                  }

                  makeRegionVisible(clip.start_ticks, clip.end_ticks);

                  handleSelectionChanged();
                  bClipSelected = true;
                  redraw();
               }
               else
               {
                  setEditOffsetToTicks(clip.start_ticks);
                  makeRegionVisible(clip.start_ticks, clip.end_ticks);
                  if(!_bAdd)
                     selectClipsAtEditOffset(1/*range*/, tstate.getTrackIdxByTrack(track));
                  handleSelectionChanged();
                  bClipSelected = true;
                  redraw();
               }
            }

            drag_end_ticks = drag_start_ticks;
            drag_start_track = tstate.getTrackIdxByTrack(track);
            drag_end_track = drag_start_track;
            sortDragSelection();
         } // if clip

         if(!bClipSelected && !_bAdd)
         {
            // No clips or pressing LEFT on first clip
            setEditOffsetToTicks(0);
            selectNone();
         }
      } // if track
   }

   // <method.png>
   protected method selectClipLastOrRight() {
      if(clip_selection.numElements >= 2*2)
      {
         sortSelectedClipsByStartTicks();

         int nodeGID = clip_selection.getRev(1);
         int clipUID = clip_selection.getRev(0);

         // // trace "xxx selectClipLastOrRight: clip_selection="+clip_selection;

         clip_selection.empty();
         clip_selection.add(nodeGID);
         clip_selection.add(clipUID);

         int trackIdx = getLastSelectedTrackIdx();
         setGridCursorTrack(trackIdx);

         NA_Clip clip <= getLastSelectedClip();
         setEditOffsetToTicks(clip.end_ticks);
         makeRegionVisible(clip.start_ticks, clip.end_ticks);

         clip_selection.empty();
         handleSelectionChanged();

         // select clip at edit offset
         trySelectClipAtEditOffset();

         redraw();
      }
      else
      {
         selectClipRight(false/*bAdd*/, false/*bAllTracks*/);
      }
   }

   // <method.png>
   protected method trySelectClipAfterEditOffset() : boolean {
      NA_Track track <= tstate.getTrackByIdx(drag_start_track_sorted);
      if(null != track)
      {
         NA_Clip clip <= track.findClipAfter(tstate.edit_offset);
         if(null != clip)
         {
            setEditOffsetToTicks(clip.start_ticks);
            selectNone();
            trySelectClipAtEditOffset();
            makeEditOffsetVisible();
            return true;
         }
      }
      return false;
   }

   // <method.png>
   protected method selectClipRight(boolean _bAdd, boolean _bAllTracks) {
      if(null == getLastSelectedClip())
      {
         if(trySelectClipAfterEditOffset())
            return;

         if(!selectFirstClipNearTicks(tstate.edit_offset, false/*bDown*/, true/*bSetEditOffset*/))
         {
            // No clips
            setEditOffsetToTicks(0);
            selectNone();
         }
         return;
      }

      NA_Track track <= getLastSelectedTrack();

      boolean bClipSelected = false;

      if(null != track)
      {
         if(!_bAdd)
            sortSelectedClipsByStartTicks();

         NA_Clip clip <= getLastSelectedClip();

         if(null != clip)
         {
            Integer minTicks;
            Integer maxTicks;
            int clipIdx;
            boolean bDone = false;

            if(!_bAdd && tstate.b_edge_selection_mode)
            {
               // // if(clip.start_ticks > tstate.edit_offset)
               // // {
               // //    // Move to clip start first
               // //    setEditOffsetToTicks(clip.start_ticks);
               // //    makeRegionVisible(clip.start_ticks, clip.end_ticks);
               // //    clip_selection.empty();
               // //    clip_selection.add(clip.node_gid);
               // //    clip_selection.add(clip.clip_uid);
               // //    handleSelectionChanged();
               // //    redraw();
               // //    bClipSelected = true;
               // //    bDone = true;
               // // }
               // // else if(tstate.edit_offset == clip.start_ticks)
               if(clip.start_ticks <= tstate.edit_offset < clip.end_ticks)
               {
                  clipIdx = track.getClipIdxByClip(clip);

                  if((clipIdx+1) < (track.clips.numElements))
                  {
                     NA_Clip clipR <= track.getClipByIdx(clipIdx + 1);
                     if(clipR.start_ticks != clip.end_ticks)
                     {
                        // Move to clip end first
                        setEditOffsetToTicks(clip.end_ticks);
                        makeRegionVisible(clip.start_ticks, clip.end_ticks);
                        clip_selection.empty();
                        clip_selection.add(clip.node_gid);
                        clip_selection.add(clip.clip_uid);
                        handleSelectionChanged();
                        makeRegionVisible(clip.start_ticks, clip.end_ticks + tstate.calcGridTicks());
                        // // centerEditOffset(); // so cursor remains visible when clip ends on right screen border
                        redraw();
                        bClipSelected = true;
                        bDone = true;
                     }
                     // else: RHS clip start = this clip end
                  }
                  else
                  {
                     // No right-hand-side clip, move to clip end
                     setEditOffsetToTicks(clip.end_ticks);
                     makeRegionVisible(clip.start_ticks, clip.end_ticks);
                     selectClipsAtEditOffset(1/*range*/, tstate.getTrackIdxByTrack(track));  // select none
                     handleSelectionChanged();
                     redraw();
                     bClipSelected = true;
                     bDone = true;
                  }
               }
            }

            if(!bDone)
            {
               clipIdx = track.getClipIdxByClip(clip);

               if((clipIdx+1) < (track.clips.numElements))
               {
                  clip <= track.getClipByIdx(clipIdx + 1);

                  if(!_bAdd)
                     clip_selection.empty();

                  clip_selection.add(track.node_gid);
                  clip_selection.add(clip.clip_uid);

                  setEditOffsetToTicks(clip.start_ticks);

                  if(_bAllTracks)
                  {
                     findSelectionMinMaxTicks(minTicks, maxTicks);
                     drag_start_ticks_sorted = minTicks;
                     drag_end_ticks_sorted = clip.end_ticks;
                     drag_start_track_sorted = 0;
                     drag_end_track_sorted = tstate.getNumTracks() - 1;
                     selectClips(false/*bAllowToggle*/, _bAdd);
                  }

                  makeRegionVisible(clip.start_ticks, clip.end_ticks);

                  bClipSelected = true;
                  handleSelectionChanged();
                  redraw();
               }
               else
               {
                  if(tstate.edit_offset == clip.start_ticks)
                  {
                     // Move cursor right after last clip
                     // // // clip_selection.empty();
                     setEditOffsetToTicks(clip.end_ticks);
                  }
                  else
                  {
                     setEditOffsetToTicks(clip.start_ticks);
                  }
                  makeRegionVisible(clip.start_ticks, clip.end_ticks);
                  handleSelectionChanged();
                  redraw();
                  bClipSelected = true;
               }
            }

            drag_end_ticks = drag_start_ticks;
            drag_start_track = tstate.getTrackIdxByTrack(track);
            drag_end_track = drag_start_track;
            sortDragSelection();
         } // if clip

         if(!bClipSelected && !_bAdd)
         {
            // No clips
            setEditOffsetToTicks(0);
            selectNone();
         }
      } // if track
   }

   // <method.png>
   protected method checkNewClipAnyClipsWithinRange() : boolean {
      // Create new clip(s)
      int trackIdx = drag_start_track_sorted;
      int numTracks = drag_end_track_sorted - drag_start_track_sorted + 1;
      int numCreated = 0;

      loop(numTracks)
      {
         NA_Track track <= tstate.getTrackByIdx(trackIdx);

         if(null != track) // should never be null
         {
            if(track.anyClipsWithinRange(drag_start_ticks_sorted, drag_end_ticks_sorted))
               return true;
         }

         trackIdx++;
      }

      return false;
   }

   // <method_find.png>
   protected method findSelectionMinMaxTicks(Integer _retMinTicks, _retMaxTicks) {
      int nodeGID;
      int clipUID;
      int i = 0;
      _retMinTicks = 9999999;
      _retMaxTicks = 0;

      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         NA_Track track <= tstate.findTrackByGID(nodeGID);

         if(null != track)
         {
            NA_Clip clip <= track.findClipByUID(clipUID);

            if(null != clip)
            {
               if(clip.start_ticks < _retMinTicks)
                  _retMinTicks = clip.start_ticks;

               if(clip.end_ticks > _retMaxTicks)
                  _retMaxTicks = clip.end_ticks;
            }
         }

         // Next selected clip
         i += 2;
      }
   }

   // <method.png>
   protected method editFirstSelectedClip(boolean _bEditSample) {

      lazySelectGridCursorClips();

      if(haveSelection())
      {
         PageNode pgNode <= root_form.pg_node;

         NA_Clip clip <= getFirstSelectedClip();

         if(null != clip)
         {
            if(tstate.clip_edit_mode >= NA_State.CLIP_EDIT_MODE_INITCTL_MW)
               if(editFirstSelectedClipCtl(true/*bWarpMouse*/, null/*k*/))
                  return true;

            if(clip.isSeq())
            {
               if(!replay.b_playing && parent_node.nodeIsMaster())
                  current_song.seek(tstate.edit_offset);

               Node node <= current_song.findNodeByGID(clip.node_gid);
               Node nodeOther <= null;
               NA_Clip clipOther <= null;

               if(null != node)
               {
                  clipOther <= getSecondSelectedTrackClip();
                  // // trace "xxx clipOther="+#(clipOther);
                  if(null != clipOther)
                  {
                     nodeOther <= current_song.findNodeByGID(clipOther.node_gid);
                     // // trace "xxx node2="+#(node2);
                     if(null != nodeOther)  // should not be null
                     {
                        // Set quick-jump pipe+node A+B
                        pgNode.setAPipeAndNode(node.nodeGetPipeIdx(), node.nodeGetPipeNodeIdx());
                        pgNode.setBPipeAndNode(nodeOther.nodeGetPipeIdx(), nodeOther.nodeGetPipeNodeIdx());
                        // // trace "xxx clip2.pattern_nr="+clip2.pattern_nr;
                        nodeOther.nodeSetCurrentPlayPatternNr(clipOther.pattern_nr);
                        nodeOther.nodeSetCurrentEditPatternNr(clipOther.pattern_nr);
                     }
                  }
                  else
                  {
                     nodeOther <= node.nodeFindOtherQuickJumpNode();
                     // // trace "xxx nodeOther="+#(nodeOther);
                  }

                  if(!replay.b_playing)
                  {
                     // (note) when NodeEditor is shown it sets the edit pattern to the current play pattern
                     node.nodeSetCurrentPlayPatternNr(clip.pattern_nr);
                  }

                  node.edit_clip_start_ticks  = clip.start_ticks;
                  int startOff = clip.calcOffsetTicks();

                  int patLenTicks = node.nodeGetCurrentPlayPatternNumTicks();
                  if(patLenTicks > 0)
                     startOff = startOff % patLenTicks;

                  node.edit_clip_parent_arranger_gid = parent_node.getNodeGID();
                  int relEditOff = startOff + tstate.edit_offset - clip.start_ticks;

                  if(_bEditSample)
                  {
                     // Try edit audio sample in Eureka
                     if(node instanceof NodeTracker)
                     {
                        NodeTracker nodeTracker <= node;
                        nodeTracker.tryEditAudioPatternSampleInEureka(clip.pattern_nr, relEditOff, true/*bShowEurekaWindow*/);
                     }
                     return;
                  }

                  // // // pgNode.handlePipeNodeASet();

                  // // // // (todo) why is this saved here and not in leaveNode() ?
                  // // // // parent_node.restore_clip_selection = clip_selection;

                  // // // // node.edit_clip_start_offset = startOff;
                  node.edit_clip_start_offset = relEditOff;
                  node.nodeSetCurrentEditPatternNr(clip.pattern_nr);
                  if(!replay.b_playing)
                     node.nodeSetCurrentPlayPatternNr(clip.pattern_nr);
                  // // trace "xxx clip.pattern_nr="+clip.pattern_nr;
                  node.nodeSetLastPatternStartEditorSongOffset(clip.start_ticks - startOff);
                  node.nodeSetLastPatternStartSongOffset(clip.start_ticks - startOff);
                  node.nodeSetRelativeEditOffset(relEditOff);
                  Global.Debug("NA_TimelineData::editFirstSelectedClip: set edit_clip_start_ticks="+node.edit_clip_start_ticks+" relEditOff="+relEditOff);
                  // Update ghost node
                  if(!replay.b_playing)
                  {
                     if(null != nodeOther)
                     {
                        NA_Track trackOther <= tstate.findTrackByGID(nodeOther.getNodeGID());
                        if(null != trackOther)
                        {
                           clipOther <= trackOther.findClipBefore(tstate.edit_offset + 1);
                           // // trace "xxx findClipBefore clipOther="+#(clipOther)+" tstate.edit_offset="+tstate.edit_offset;
                           if(null != clipOther)
                           {
                              // // trace "xxx clipOther.pattern_nr="+clipOther.pattern_nr;
                              nodeOther.nodeSetCurrentPlayPatternNr(clipOther.pattern_nr);
                              nodeOther.nodeSetCurrentEditPatternNr(clipOther.pattern_nr);
                              int startOff2 = clipOther.calcOffsetTicks();
                              int patLenTicks2 = nodeOther.nodeGetCurrentPlayPatternNumTicks();
                              if(patLenTicks2 > 0)
                                 startOff2 = startOff2 % patLenTicks2;
                              nodeOther.nodeSetLastPatternStartSongOffset(clipOther.start_ticks - startOff2);
                           }
                        }
                     }
                  }

                  pgNode.showPipeNodeByIdx(node.parent_pipe.pipeIdx,
                                           node.parent_pipenode.nodeIdx
                                           );

                  // // pgNode.handlePipeNodeBSet();
               }
            }
            else
            {
               // // Global.Warning("Marker clips cannot be edited");
               Global.Debug2("NA_TimelineData::editFirstSelectedClip: queue marker clip patnr="+clip.pattern_nr);
               if(!replay.b_playing)
                  parent_form.startReplay();
               tstate.queueMarkerPatNr(clip.pattern_nr);
            }
         }
      }
   }

   // <method.png>
   protected method createAudioSampleForNewClip(NA_Track track, NA_Clip clip) {
      if!(track.audio_default_namespace.isBlank())
      {
         String suggestedSmpName = track.audio_default_namespace+" clip 1";
         Global.Debug("NA_TimelineData::createAudioSampleForNewClip: alloc sample: suggested name=\""+suggestedSmpName+"\"");
         // // // SysExLiveRecInstance lri <= AudioLiveRecForm.FindLiveRecInstanceByDevIdxAndCh(track.audio_dev_idx, track.audio_midi_ch);
         SysExTrack sysTrack <= AudioLiveRecForm.FindTrackByDevIdxAndMidiCh(track.audio_dev_idx, track.audio_midi_ch);
         if(null != sysTrack)
         {
            // // // float smpMillisec = current_song.ticksToMilliSeconds(newEndTicks - newStartTicks);
            float smpMillisec = current_song.ticksToMilliSeconds(clip.end_ticks - clip.start_ticks);
            boolean bForceStereo = false;
            if(null != dlg_audio_liverec)
            {
               int extra16ths = dlg_audio_liverec.getExtra16ths();
               if(extra16ths > 0)
                  smpMillisec += current_song.sixteenthToMilliSeconds(extra16ths);
               bForceStereo = dlg_audio_liverec.getEnableForceStereo();
            }
            int nspIdx = AudioLiveRecForm.GetSampleNamespaceIdByName(track.audio_default_namespace);
            if(-1 != nspIdx)
            {
               SysEx.QueueSendSmpLiveRecCreate(smpMillisec,
                                               (sysTrack.b_stereo_input || bForceStereo) ? 2 : 1/*numCh*/,
                                               STConfig.node_arranger_audio_clip_level/*levelDB*/,
                                               nspIdx,
                                               suggestedSmpName
                                               );
               if(SysEx.WaitForSmpLiveRecCreate())
               {
                  clip.audio_smp_uid = SysEx.queued_recv_liverec_sample_create_reply_smp_uid;
                  Global.Debug("createAudioSampleForNewClip: created sample uid="+clip.audio_smp_uid+" ms="+smpMillisec+" nspIdx="+nspIdx+"(\""+track.audio_default_namespace+"\") b_stereo="+sysTrack.b_stereo_input);
                  f_audio_liverec.handleQuery();
               }
            }
            else
            {
               Global.Warning("createAudioSampleForNewClip: alloc sample: nspIdx not found (nspName=\""+track.audio_default_namespace+"\")");
            }
         }
         else
         {
            Global.Warning("createAudioSampleForNewClip: alloc sample: sysTrack not found (dev="+track.audio_dev_idx+" ch="+track.audio_midi_ch+")");
         }
      }
      else
      {
         Global.Warning("createNewClips: alloc sample: track.audio_default_namespace is not set (skipping..)");
      }
   }

   // <method.png>
   protected method createPatternForNewClip(NA_Clip clip, NA_Clip lastClip/*or null*/, boolean _bAllocPatternSub, boolean _bClonePattern) {
      // Start search at clipboard pattern
      Node node <= current_song.findNodeByGID(clip.node_gid);
      if(null != node)
      {
         int newPatNr;

         if(null != lastClip)
            newPatNr = lastClip.pattern_nr;
         else
            newPatNr = findHighestClipboardClipPatternNrForNodeGID(clip.node_gid);

         if(newPatNr < 0)
            newPatNr = 0;
         else if(newPatNr >= Node.SCRATCH_PAT_NR)
            newPatNr = 0;

         if(_bAllocPatternSub)
            newPatNr = node.nodeFindFirstUnusedPatternSub(newPatNr/*startOff*/);
         else
            newPatNr = node.nodeFindFirstUnusedPatternGroup(newPatNr/*startOff*/);

         if(newPatNr < 0)
         {
            Global.Warning("Failed to find unused pattern for node gid="+clip.node_gid);
            newPatNr = Node.EMPTY_PAT_NR; // failed to alloc pattern (all in use)
         }
         else
         {
            NodePattern newPat <= node.nodeGetPatternByIdx(newPatNr);
            if(null == newPat)
            {
               // Lazy-Allocate pattern
               newPat <= node.nodeNewPattern(newPatNr);
            }
            else
            {
               if(!newPat.patIsEmpty())
                  newPat <= null;
            }

            // // trace "xxx trackIdx="+trackIdx+" newPat="+#(newPat);

            if( (null != newPat) && _bClonePattern && (null != lastClip) )
            {
               NodePattern oldPat <= node.nodeGetPatternByIdx(lastClip.pattern_nr);
               // // trace "xxx trackIdx="+trackIdx+" oldPat="+#(oldPat);
               if(null != oldPat)
               {
                  NodePattern patCB <= oldPat.patGetOrCreateClipboard();/////NodePattern.PatGetClipboardForClass(node.nodeGetPatternClassName());
                  // // trace "xxx trackIdx="+trackIdx+" patCB="+#(patCB);
                  if(null != patCB)
                  {
                     patCB.patCopyFrom(oldPat, false/*bClear*/);
                     newPat.patCopyFrom(patCB, false/*bClear*/);
                     newPat.patReset(true/*bSoft*/);
                     newPat.patHandleSongSpeedChanged(true/*bPPQ*/, true/*bBPM*/);
                  }
               }
            }
         }

         clip.setPatternNr(newPatNr);
      }
   }

   // <method.png>
   protected method replaceSelectedClipSamplesAndPatterns(boolean _bAllocPatternSub, boolean _bClonePattern) : int {
      int numReplaced = 0;

      // Replace selected clips (clone samples / patterns)
      NA_Clip *clip;
      NA_Track *track;
      int i = 0;
      loop(clip_selection.numElements / 2)
      {
         int nodeGID = clip_selection[i + 0];
         int clipUID = clip_selection[i + 1];

         track <= tstate.findTrackByGID(nodeGID);
         if(null != track)
         {
            clip <= track.findClipByUID(clipUID);

            if(null != clip)
            {
               if(clip.isAudio())
                  createAudioSampleForNewClip(track, clip);
               else if(NA_Track.NODE_GID_MARKER == nodeGID)
                  clip.pattern_nr = track.findUnusedMarkerPatternNr(0);
               else
                  createPatternForNewClip(clip, clip/*lastClip*/, _bAllocPatternSub, _bClonePattern);

               numReplaced++;
            }
         }

         i += 2;
      }

      return numReplaced;
   }

   // <method.png>
   protected /*=replay=*/ method createNewClips(boolean _bAllocPattern,
                                                boolean _bAllocPatternSub,
                                                boolean _bAllowFindLastClip,
                                                boolean _bClonePattern,
                                                boolean _bAllowReplaceClips
                                                ) {
      // Create new clip(s)
      int trackIdxStart;
      int numTracks;
      if(_bAllowFindLastClip && haveSelection())
      {
         trackIdxStart = getFirstSelectedSortedTrackIdx();
         numTracks = getNumSelectedTracks();
      }
      else
      {
         trackIdxStart = drag_start_track_sorted;
         numTracks = drag_end_track_sorted - drag_start_track_sorted + 1;
      }

      // // trace "xxx createNewClips: trackIdx="+trackIdx+" numTracks="+numTracks;
      int trackIdx;
      int numCreated = 0;
      int firstClipTicks = -1;
      int lastClipTicks = -1;
      NA_Clip *clip;
      NA_Track *track;

      Global.Debug("NA_TimelineData::createNewClips: numTracks="+numTracks);

      boolean bCanCreate = true;
      boolean bClipsWithinRange;
      int newStartTicks;
      int newEndTicks;
      local NA_Clip *lastClip;

      local IntArray newSelection;
      newSelection.empty();

      Integer selMinTicks;
      Integer selMaxTicks;
      findSelectionMinMaxTicks(selMinTicks, selMaxTicks);
      int selNumTicks = mathMaxi(0, selMaxTicks - selMinTicks);

      if(_bAllowReplaceClips && (selNumTicks > 0))
      {
         // Check if there already are any clips after the selected range and
         //  create new patterns / samples (replace clip patterns) in that case
         newStartTicks = selMinTicks + selNumTicks;
         newEndTicks   = selMaxTicks + selNumTicks;
         bClipsWithinRange = false;
         trackIdx = trackIdxStart;
         loop(numTracks)
         {
            track <= tstate.getTrackByIdx(trackIdx);
            bClipsWithinRange = track.anyClipsWithinRange(newStartTicks, newEndTicks);
            if(bClipsWithinRange)
               break;
            trackIdx++;
         }

         if(bClipsWithinRange)
         {
            numCreated = replaceSelectedClipSamplesAndPatterns(_bAllocPatternSub, _bClonePattern);
            Global.Debug("NA_TimelineData::createNewClips: replace "+numCreated+" clips/samples");

            newSelection = clip_selection;
         }
      }


      // Try fallback (create new clips in selected range or right after)
      if( 0 == numCreated && drag_start_ticks_sorted != drag_end_ticks_sorted )
      {
         trackIdx = trackIdxStart;
         loop(numTracks)
         {
            track <= tstate.getTrackByIdx(trackIdx);

            Global.Debug("NA_TimelineData::createNewClips: track="+#(track)+" trackIdx="+trackIdx);

            if(null != track) // should never be null
            {
               bClipsWithinRange = (_bAllowFindLastClip && selNumTicks > 0) || track.anyClipsWithinRange(drag_start_ticks_sorted, drag_end_ticks_sorted);

               // // trace "xxx trackIdx="+trackIdx+" bClipsWithinRange="+bClipsWithinRange;
               if(_bAllowFindLastClip || _bClonePattern)
                  lastClip <= findLastSelectedSortedClipByNodeGID(track.node_gid);
               else
                  lastClip <= null;

               if(bClipsWithinRange && _bAllowFindLastClip)
               {
                  // // trace "xxx lastClip="+#(lastClip);
                  if(null != lastClip)
                  {
                     // (note) when multiple clips are selected on a single track, both this variants are moderately useful. revert to copy/paste instead ?
                     if(selNumTicks > 0)
                     {
                        // new clip dur = duration of selected clips
                        newStartTicks = selMaxTicks;
                        newEndTicks   = newStartTicks + selNumTicks;
                     }
                     else
                     {
                        // new clip dur = duration of last clip
                        newStartTicks = lastClip.end_ticks;
                        newEndTicks   = newStartTicks + (lastClip.end_ticks - lastClip.start_ticks);
                     }
                     // // trace "xxx trackIdx="+trackIdx+" newStartTicks="+newStartTicks+" newEndTicks="+newEndTicks;
                     bCanCreate = !track.anyClipsWithinRange(newStartTicks, newEndTicks);
                  }
                  else
                  {
                     bCanCreate = false;
                  }
               }
               else if(bClipsWithinRange)
               {
                  bCanCreate = false;
               }
               else
               {
                  newStartTicks = drag_start_ticks_sorted;
                  newEndTicks   = drag_end_ticks_sorted;
                  bCanCreate = true;
               }

               // // trace "xxx trackIdx="+trackIdx+" bCanCreate="+bCanCreate;

               if(bCanCreate)
               {
                  clip <= track.newClip(newStartTicks, newEndTicks, true/*bSort*/);

                  if(_bAllowFindLastClip) // not called from mouse-drag ?
                  {
                     if(-1 == firstClipTicks)
                     {
                        firstClipTicks = newStartTicks;
                        lastClipTicks = newEndTicks;
                     }
                     else
                     {
                        if(newStartTicks < firstClipTicks)
                           firstClipTicks = newStartTicks;
                        if(newEndTicks > lastClipTicks)
                           lastClipTicks = newEndTicks;
                     }
                  }

                  if(clip.isAudio())
                  {
                     if(tstate.b_edit_draw_audio)
                        createAudioSampleForNewClip(track, clip);
                  }
                  else if(_bAllocPattern)
                  {
                     createPatternForNewClip(clip, lastClip, _bAllocPatternSub, _bClonePattern);
                  }

                  newSelection.add(clip.node_gid);
                  newSelection.add(clip.clip_uid);

                  numCreated++;
               }
               else
               {
                  Global.Warning("Skip new clip (track#"+(trackIdx+1)+"): clip already exists");
               }
            }

            trackIdx++;
         } // loop numTracks
      }

      if(numCreated > 0)
      {
         tstate.updateEmptyFlags();

         clip_selection = newSelection;
         handleSelectionChanged();

         if(firstClipTicks >= 0)
         {
            makeRegionVisible(firstClipTicks, lastClipTicks);
            setEditOffsetToTicks(firstClipTicks);
            // // // tstate.edit_offset = firstClipTicks;
         }

         Global.Print("Create "+numCreated+" new clip"+Utils.GetPluralString(numCreated)+" ticks=("+drag_start_ticks_sorted+";"+drag_end_ticks_sorted+")");
      }
   }

   // <method.png>
   protected method moveResizeClipsClipDelta(boolean _bMove, boolean _bEnd) {
      if(0 != drag_delta_ticks)
      {
         int nodeGID;
         int clipUID;
         int numMoved = 0;
         NA_Track *track;
         NA_Clip *clip;
         int i;

         int gridTicks = tstate.calcGridTicks();

         // Limit delta_ticks (clip left)
         i = 0;
         loop(clip_selection.numElements / 2)
         {
            nodeGID = clip_selection[i + 0];
            clipUID = clip_selection[i + 1];

            track <= tstate.findTrackByGID(nodeGID);

            if(null != track) // should never be null
            {
               clip <= track.findClipByUID(clipUID);

               if(null != clip)
               {
                  if(_bMove)
                  {
                     if( (clip.start_ticks + drag_delta_ticks) < 0)
                        drag_delta_ticks = - (clip.start_ticks / gridTicks) * gridTicks;
                  }
                  else if(_bEnd)
                  {
                     // Move clip end
                     if( (clip.end_ticks + drag_delta_ticks) <= clip.start_ticks)
                     {
                        b_drag_overlap = true;
                     }
                  }
                  else
                  {
                     // Move clip start
                     if( (clip.start_ticks + drag_delta_ticks) < 0)
                        drag_delta_ticks = - (clip.start_ticks / gridTicks) * gridTicks;

                     if( (clip.start_ticks + drag_delta_ticks) >= clip.end_ticks)
                        b_drag_overlap = true;
                  }
               }
            }

            // Next selected clip
            i += 2;
         }
      }
   }

   // <method.png>
   protected method moveResizeClipsCheckOverlap(boolean _bMove, boolean _bResizeEnd) : boolean {
      if(0 != drag_delta_ticks)
      {
         int nodeGID;
         int clipUID;
         int numMoved = 0;
         NA_Track *track;
         NA_Clip *clip;
         int i;

         int gridTicks = tstate.calcGridTicks();

         // Find overlapping clips
         i = 0;
         loop(clip_selection.numElements / 2)
         {
            nodeGID = clip_selection[i + 0];
            clipUID = clip_selection[i + 1];

            track <= tstate.findTrackByGID(nodeGID);

            if(null != track) // should never be null
            {
               clip <= track.findClipByUID(clipUID);

               if(null != clip)
               {
                  NA_Clip *clipOther;

                  foreach clipOther in track.clips
                  {
                     if(!isClipSelected(track.node_gid, clipOther.clip_uid))
                     {
                        // trace "xxx check overlap: clip=("+clip.start_ticks+";"+clip.end_ticks+") other=("+(clipOther.start_ticks - drag_delta_ticks)+";"+(clipOther.end_ticks - drag_delta_ticks)+")";
                        // if(clipOther.withinTicks(clip.start_ticks + drag_delta_ticks, clip.end_ticks + drag_delta_ticks))

                        if(_bMove)
                        {
                           if(clipOther.intersectTicks(clip.start_ticks + drag_delta_ticks, clip.end_ticks + drag_delta_ticks))
                           {
                              // Cannot move, moved clip would intersect with clipOther
                              return true;
                           }
                        }
                        else if(_bResizeEnd)
                        {
                           if(clipOther.intersectTicks(clip.start_ticks, clip.end_ticks + drag_delta_ticks))
                           {
                              // Cannot move end, moved clip would intersect with clipOther
                              return true;
                           }
                        }
                        else
                        {
                           if(clipOther.intersectTicks(clip.start_ticks + drag_delta_ticks, clip.end_ticks))
                           {
                              // Cannot move start, moved clip would intersect with clipOther
                              return true;
                           }
                        }
                     }
                  }
               }
            }

            // Next selected clip
            i += 2;
         }
      }

      return false;
   }

   // <method.png>
   protected =replay= method moveResizeClips_sync(boolean _bMove, boolean _bEnd, boolean _bDuplicate) : int {
      // returns number of moved/duplicated clips
      if(0 != drag_delta_ticks)
      {
         int nodeGID;
         int clipUID;
         int numMoved = 0;
         NA_Track *track;
         NA_Clip *clip;
         int i;

         int gridTicks = tstate.calcGridTicks();

         IntArray newSelectionAfterDuplicate;
         newSelectionAfterDuplicate.free();

         // Move clips
         if(0 != drag_delta_ticks)
         {
            i = 0;
            loop(clip_selection.numElements / 2)
            {
               nodeGID = clip_selection[i + 0];
               clipUID = clip_selection[i + 1];

               track <= tstate.findTrackByGID(nodeGID);

               if(null != track) // should never be null
               {
                  clip <= track.findClipByUID(clipUID);

                  if(null != clip)
                  {
                     if(_bDuplicate)
                     {
                        clip <= track.duplicateClip(clip);
                        newSelectionAfterDuplicate.add(track.node_gid);
                        newSelectionAfterDuplicate.add(clip.clip_uid);
                     }

                     if(_bMove || !_bEnd)
                        clip.start_ticks = clip.start_ticks + drag_delta_ticks;

                     if(_bMove || _bEnd)
                        clip.end_ticks   = clip.end_ticks + drag_delta_ticks;

                     numMoved++;
                  }
               }

               // Next selected clip
               i += 2;
            }

            // Sort clips
            foreach track in tstate.tracks
            {
               track.sortClipsByStartTime();
            }

            if(0 != numMoved)
            {
               Global.Print("Moved "+numMoved+" clip"+((_bMove && (numMoved > 1)) ? "s":"")+((!_bMove && (numMoved > 1)) ? (_bEnd ? " ends":" starts") : (!_bMove && (1 == numMoved)) ? (_bEnd ? " end":" start") : "") + " by "+drag_delta_ticks+" ticks");
               redraw();

               if(_bDuplicate)
               {
                  clip_selection = newSelectionAfterDuplicate;
                  newSelectionAfterDuplicate.free();
               }

               handleSelectionChanged();

               return numMoved;
            }
         }
      }

      return 0;
   }

   // <method.png>
   protected method moveResizeClips(boolean _bMove, boolean _bEnd, boolean _bDuplicate, boolean _bCloneSample) {
      if(moveResizeClips_sync(_bMove, _bEnd, _bDuplicate) > 0)
      {
         if(_bCloneSample)
         {
            cloneSelectedAudioClipSamples();
            handleSelectionChanged();
         }
      }
   }

   // <method.png>
   public method cloneSelectedAudioClipSamples() {
      int selIdx = 0;
      int nodeGID;
      int clipUID;

      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection.get(selIdx + 0);
         clipUID = clip_selection.get(selIdx + 1);

         NA_Track track <= tstate.findTrackByGID(nodeGID);
         if(null != track)
         {
            if(track.isAudio())
            {
               SysExSamplerInstance lri <= AudioLiveRecForm.FindSamplerInstanceByDevIdxAndCh(track.audio_dev_idx, track.audio_midi_ch);
               if(null != lri)
               {
                  f_audio_liverec.selectInstanceById(lri.instance_id, false/*bAllowEdit*/);

                  NA_Clip clip <= track.findClipByUID(clipUID);
                  if(null != clip)
                  {
                     SysExSample sysSmp <= AudioLiveRecForm.FindSampleByUniqueId(clip.audio_smp_uid);
                     if(null != sysSmp)
                     {
                        int origSmpUID = clip.audio_smp_uid;
                        f_audio_liverec.selectSampleByUniqueId(origSmpUID,
                                                               false/*bAllowEdit*/,
                                                               0/*selStartMS*/, -1/*selLenMS*/,
                                                               false/*bForceEdit*/
                                                               );
                        int clonedSmpUID = f_audio_liverec.handleClone(false/*bAllowEdit*/);  // (selIdx == (clip_selection.numElements-2))
                        clip.setAudioSmpUID(clonedSmpUID);
                        sysSmp <= AudioLiveRecForm.FindSampleByUniqueId(clonedSmpUID);
                        if(null != sysSmp)
                           clip.cached_audio_smp_name = sysSmp.name;
                        Global.Debug("cloneSelectedAudioClipSamples: origSmpUID="+origSmpUID+" => clonedSmpUID="+clonedSmpUID+" (\""+clip.cached_audio_smp_name+"\")");
                     }
                  }
               }
            }
         }

         // Next clip
         selIdx += 2;
      }
   }

   // <method.png>
   public =replay= method setClipLengthsToPatternLengths() {
      if(haveSelection())
      {
         local IntArray newLengths;
         local PointerArray tracks;
         local PointerArray clips;

         // Pass 1: Find pattern lengths
         int selIdx = 0;
         int nodeGID;
         int clipUID;
         Node *node;
         NA_Clip *clip;
         NA_Track *track;
         int patLen;
         boolean bOk = true;
         int minTicks = 999999999;
         int maxTicks = 0;
         int gridTicks = tstate.calcGridTicks();

         loop(clip_selection.numElements / 2)
         {
            nodeGID = clip_selection.get(selIdx + 0);
            clipUID = clip_selection.get(selIdx + 1);

            track <= tstate.findTrackByGID(nodeGID);
            if(null != track)
            {
               clip <= track.findClipByUID(clipUID);

               if(null != clip)
               {
                  if(clip.isMarker())
                  {
                     trace "[trc] NA_TimelineData::setClipLengthsToPatternLengths: skip marker clipUID="+clipUID;
                  }
                  else if(clip.isAudio())
                  {
                     // Convert audio sample duration to ticks and align to grid size
                     SysExSample syxSmp <= clip.findAudioSample();
                     if(null != syxSmp)
                     {
                        patLen = current_song.milliSecondsToTicks(syxSmp.millisecs);
                        if(patLen > 0)
                        {
                           patLen = ((patLen + gridTicks-1) / gridTicks) * gridTicks;
                           tracks.add(track);
                           clips.add(clip);
                           newLengths.add(patLen);
                        }
                     }
                     else
                     {
                        Global.Warning("failed to resolve audio smp uid="+clip.audio_smp_uid);
                     }
                  }
                  else
                  {
                     node <= current_song.findNodeByGID(nodeGID);

                     if(null != node)
                     {
                        patLen = node.nodeGetPatternNumTicks(clip.pattern_nr);
                        if(patLen > 0)
                        {
                           // nodes.add(node);
                           tracks.add(track);
                           clips.add(clip);
                           newLengths.add(patLen);
                        }
                        else
                        {
                           // Node does not support query or pattern is empty
                           if(node.nodeIsPatternEmpty(clip.pattern_nr))
                           {
                              Global.Error("Pattern "+(Node.patnr_options.get(clip.pattern_nr))+" does not exist (can't query length)");
                           }
                           else
                           {
                              Global.Error("Node type \""+node.nodeGetTypeName()+"\" does not support pattern length queries");
                           }
                           bOk = false;
                           break;
                        }
                     }
                     else
                     {
                        // May have been deleted
                        Global.Error("Failed to resolve node for nodeGID="+nodeGID);
                        bOk = false;
                        break;
                     }
                  }
               }
               else
               {
                  // Unlikely (should not be reachable)
                  Global.Error("Failed to resolve clip for clipUID="+clipUID);
                  bOk = false;
                  break;
               }
            }
            else
            {
               // Unlikely (should not be reachable)
               Global.Error("Failed to resolve track for nodeGID="+nodeGID);
               bOk = false;
               break;
            }

            // Next selected clip
            selIdx += 2;

         } // loop clip_selection

         if(bOk)
         {
            // Pass 2: check if resized patterns fit
            int i = 0;
            foreach patLen in newLengths
            {
               track <= tracks.get(i);
               clip <= clips.get(i);

               int origEnd = clip.end_ticks;
               clip.end_ticks = clip.start_ticks+1;
               if(track.anyClipsWithinRange(clip.start_ticks+1, clip.start_ticks + patLen))
               {
                  Global.Error("Overlap detected (clip.start="+clip.start_ticks+" patLen="+patLen+")");
                  bOk = false;
               }
               clip.end_ticks = origEnd;

               if(!bOk)
                  break;

               // Next clip
               i++;
            }

            // Pass 3: resize clips
            if(bOk)
            {
               tstate.undoAdd(clip_selection);
               i = 0;
               foreach patLen in newLengths
               {
                  track <= tracks.get(i);
                  clip <= clips.get(i);

                  if(clip.start_ticks < minTicks)
                     minTicks = clip.start_ticks;
                  if(clip.start_ticks > maxTicks)
                     maxTicks = clip.start_ticks;

                  clip.end_ticks = clip.start_ticks + patLen;

                  if(clip.end_ticks > maxTicks)
                     maxTicks = clip.end_ticks;

                  // Next clip
                  i++;
               }

               makeRegionVisible(minTicks, maxTicks);
               tstate.undoEnd(clip_selection);

               Global.Print("Updated "+newLengths.numElements+" clip length"+Utils.GetPluralString(newLengths.numElements));
               redraw();
            }
         }
      }
      else
      {
         Global.Warning("setClipLengthsToPatternLengths: no clips selected");
      }
   }

   // <method_get.png>
   protected method isMouseNearSelectionClip(MouseEvent _ev, boolean _bEnd) : boolean {
      int nodeGID;
      int clipUID;
      NA_Track *track;
      NA_Clip *clip;
      int i;

      int gridTicks = tstate.calcGridTicks();

      float sx = getSizeX() - 2*2;
      float pixPerTick = sx / tstate.vis_ticks;
      float px;

      int tickOffset = tstate.view_offset;
      int mouseTrackIdx = getTrackIndexAtPy(_ev.mouse_rel_y);

      // Check clips
      i = 0;
      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         track <= tstate.findTrackByGID(nodeGID);

         if(null != track) // should never be null
         {
            if(mouseTrackIdx == tstate.getTrackIdxByTrack(track))
            {
               clip <= track.findClipByUID(clipUID);

               if(null != clip)
               {
                  px = ((_bEnd ? clip.end_ticks : clip.start_ticks) - tickOffset) * pixPerTick;

                  if( (px - GetDragThresholdPX()) <= (_ev.mouse_rel_x-2) <= (px + GetDragThresholdPX()) )
                     return true;
               }
            }
         }

         // Next selected clip
         i += 2;
      }

      return false;
   }

   // <method_get.png>
   protected method isMouseNearClip(MouseEvent _ev, boolean _bEnd, Integer _retTrackGID, Integer _retClipUID) : boolean {
      NA_Track *track;
      NA_Clip *clip;

      int gridTicks = tstate.calcGridTicks();

      float sx = getSizeX() - 2*2;
      float pixPerTick = sx / tstate.vis_ticks;
      float px;

      int tickOffset = tstate.view_offset;
      int mouseTrackIdx = getTrackIndexAtPy(_ev.mouse_rel_y);
      int trackIdx = 0;

      foreach track in tstate.tracks
      {
         if(trackIdx == mouseTrackIdx)
         {
            foreach clip in track.clips
            {
               if(maybe == _bEnd)
               {
                  px = (clip.start_ticks - tickOffset) * pixPerTick;

                  if( (px - GetDragThresholdPX()) <= (_ev.mouse_rel_x-2) <= (px + GetDragThresholdPX()) )
                  {
                     _retTrackGID = track.node_gid;
                     _retClipUID  = clip.clip_uid;
                     return true;
                  }

                  px = (clip.end_ticks - tickOffset) * pixPerTick;

                  if( (px - GetDragThresholdPX()) <= (_ev.mouse_rel_x-2) <= (px + GetDragThresholdPX()) )
                  {
                     _retTrackGID = track.node_gid;
                     _retClipUID  = clip.clip_uid;
                     return true;
                  }
               }
               else
               {
                  px = ((_bEnd ? clip.end_ticks : clip.start_ticks) - tickOffset) * pixPerTick;

                  if( (px - GetDragThresholdPX()) <= (_ev.mouse_rel_x-2) <= (px + GetDragThresholdPX()) )
                  {
                     _retTrackGID = track.node_gid;
                     _retClipUID  = clip.clip_uid;
                     return true;
                  }
               }
            }
         }

         trackIdx++;
      }

      return false;
   }

   // <method_get.png>
   protected method isMouseOverClip(MouseEvent _ev, Integer _retTrackGID, Integer _retClipUID) : boolean {
      NA_Track *track;
      NA_Clip *clip;

      int gridTicks = tstate.calcGridTicks();

      float sx = getSizeX() - 2*2;
      float pixPerTick = sx / tstate.vis_ticks;

      int tickOffset = tstate.view_offset;
      int mouseTrackIdx = getTrackIndexAtPy(_ev.mouse_rel_y);
      int trackIdx = 0;

      foreach track in tstate.tracks
      {
         if(trackIdx == mouseTrackIdx)
         {
            foreach clip in track.clips
            {
               float pxStart = (clip.start_ticks - tickOffset) * pixPerTick;
               float pxEnd = (clip.end_ticks - tickOffset) * pixPerTick;

               if(pxStart <= (_ev.mouse_rel_x-2) < pxEnd)
               {
                  if(null != _retTrackGID)
                     _retTrackGID = track.node_gid;

                  if(null != _retClipUID)
                     _retClipUID  = clip.clip_uid;

                  return true;
               }
            }
         }

         trackIdx++;
      }

      return false;
   }

   // <method_get.png>
   protected method isMouseOverSelectionClip(MouseEvent _ev) : boolean {
      int nodeGID;
      int clipUID;
      NA_Track *track;
      NA_Clip *clip;
      int i;

      int gridTicks = tstate.calcGridTicks();

      float sx = getSizeX() - 2*2;
      float pixPerTick = sx / tstate.vis_ticks;

      int tickOffset = tstate.view_offset;
      int mouseTrackIdx = getTrackIndexAtPy(_ev.mouse_rel_y);

      // Check clips
      i = 0;
      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         track <= tstate.findTrackByGID(nodeGID);

         if(null != track) // should never be null
         {
            if(mouseTrackIdx == tstate.getTrackIdxByTrack(track))
            {
               clip <= track.findClipByUID(clipUID);

               if(null != clip)
               {
                  float pxStart = (clip.start_ticks - tickOffset) * pixPerTick;
                  float pxEnd  = (clip.end_ticks - tickOffset) * pixPerTick;

                  if(pxStart <= (_ev.mouse_rel_x-2) <= pxEnd)
                  {
                     return true;
                  }
               }
            }
         }

         // Next selected clip
         i += 2;
      }

      return false;
   }

   // <method_get.png>
   protected method isMouseNearLoopLocatorHandle(MouseEvent _ev) : int {
      // Return 0=not near handle, 1=near left handle, 2=near right handle

      if(_ev.mouse_rel_y < GetTopSY())
      {
         float sx = getSizeX() - 2*2;
         float pixPerTick = sx / tstate.vis_ticks;
         float px;

         int tickOffset = tstate.view_offset;

         px = (tstate.loop_start - tickOffset) * pixPerTick;

         if( (px - GetDragThresholdPX()) <= (_ev.mouse_rel_x-2) <= (px + GetDragThresholdPX()) )
            return 1;

         px = (tstate.loop_end - tickOffset) * pixPerTick;

         if( (px - GetDragThresholdPX()) <= (_ev.mouse_rel_x-2) <= (px + GetDragThresholdPX()) )
            return 2;
      }

      return 0;
   }

   // <ui_mouse.png>
   namespace method selectCursorByEditMode(boolean _bForce) {
      // trace "xxx selectCursorByEditMode: mouse_layer="+#(UI.GetMouseFocus());
      UI.ShowCursor(UIConstants.CURSOR_NORMAL);  // force cursor update
      if(isMouseOver() || _bForce)
      {
         if(DRAG_MOVECLIPS == drag_mode)
         {
            UI.ShowCursor(UIConstants.CURSOR_MOVE);
         }
         else
         {
            switch(tstate.edit_mode)
            {
               case NA_State.EDIT_MODE_SELECT:
                  UI.ShowCursor(UIConstants.CURSOR_NORMAL);
                  break;

               case NA_State.EDIT_MODE_DRAW:
                  UI.ShowCursor(UIConstants.CURSOR_PENCIL);
                  break;

               case NA_State.EDIT_MODE_ERASE:
                  UI.ShowCursor(UIConstants.CURSOR_NOPENCIL);
                  break;

               case NA_State.EDIT_MODE_RAZOR:
                  UI.ShowCursor(UIConstants.CURSOR_SPLITX);
                  break;

               case NA_State.EDIT_MODE_MUTE:
                  // (todo) show mute cursor
                  UI.ShowCursor(UIConstants.CURSOR_NORMAL);
                  break;
            }
         }
      }
   }

   // <method.png>
   protected method deleteSelectedClips(boolean _bMoveClips, boolean _bMutedOnly) {
      int nodeGID;
      int clipUID;
      int i = 0;

      IntArray newSelection; newSelection.empty();

      int bbMinTicks = 99999999;
      int bbMaxTicks = 0;
      int minTrackIdx = 999999;
      int maxTrackIdx = 0;
      int trackIdx;
      NA_Track *track;

      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         track <= tstate.findTrackByGID(nodeGID);

         if(null != track)
         {
            trackIdx = tstate.getTrackIdxByTrack(track);
            if(trackIdx < minTrackIdx)
               minTrackIdx = trackIdx;
            if(trackIdx > maxTrackIdx)
               maxTrackIdx = trackIdx;
            NA_Clip clip <= track.findClipByUID(clipUID);

            if(null != clip)
            {
               if((_bMutedOnly && clip.b_mute) || !_bMutedOnly)
               {
                  int clipStart = clip.start_ticks;
                  int clipLen   = clip.end_ticks - clip.start_ticks;

                  if(clipStart < bbMinTicks)
                     bbMinTicks = clipStart;
                  if(clip.end_ticks > bbMaxTicks)
                     bbMaxTicks = clip.end_ticks;

                  NA_Clip nextClip <= track.findClipAfterUID(clipUID);

                  if(null == nextClip)
                     nextClip <= track.findClipBeforeUID(clipUID);

                  if(null != nextClip)
                  {
                     if(!DoesSelectionContain(clip_selection, nextClip.node_gid, nextClip.clip_uid))
                     {
                        newSelection.empty();
                        newSelection.add(nextClip.node_gid);
                        newSelection.add(nextClip.clip_uid);
                     }
                  }

                  track.deleteClip(clip);

                  // // if(_bMoveClips)
                  // // {
                  // //    track.insertSilence(clipStart, -clipLen);
                  // // }
               }
            }
         }

         // Next selected clip
         i += 2;
      }

      if(_bMoveClips && bbMaxTicks > bbMinTicks)
      {
         tstate.deleteRange(minTrackIdx, maxTrackIdx,
                            bbMinTicks, bbMaxTicks,
                            true/*bMoveClips*/
                            );
      }

      clip_selection = newSelection;
   }

   // <method.png>
   namespace method deleteSelection(boolean _bMoveClips, boolean _bMutedOnly) {

      tstate.undoAdd(clip_selection);

      if(haveSelection())
      {
         // Delete selected clips
         deleteSelectedClips(_bMoveClips, _bMutedOnly);
      }
      else if(!_bMutedOnly)
      {
         _bMoveClips |= !tstate.anyClipsWithinRange(drag_start_track_sorted, drag_end_track_sorted,
                                                    drag_start_ticks_sorted, drag_end_ticks_sorted
                                                    );

         tstate.deleteRange(drag_start_track_sorted, drag_end_track_sorted,
                            drag_start_ticks_sorted, drag_end_ticks_sorted,
                            _bMoveClips
                            );
      }

      tstate.undoEnd(clip_selection);

      drag_mode = DRAG_NONE;
      handleSelectionChanged();
      redraw();

      Global.Print("Delete region tracks=("+drag_start_track_sorted+";"+drag_end_track_sorted+") tick=("+drag_start_ticks_sorted+";"+drag_end_ticks_sorted+")");
   }

   // <method.png>
   namespace method deleteDragSelectEmptySpace() {
      tstate.undoAdd(clip_selection);
      tstate.deleteRange(drag_start_track_sorted, drag_end_track_sorted,
                         drag_start_ticks_sorted, drag_end_ticks_sorted,
                         true/*bMoveClips*/
                         );
      tstate.undoEnd(clip_selection);
      redraw();
      Global.Print("Delete empty: tracks=("+drag_start_track_sorted+";"+drag_end_track_sorted+") tick=("+drag_start_ticks_sorted+";"+drag_end_ticks_sorted+")");
   }

   // <method.png>
   protected method toggleMuteSelectedClips(boolean _bSelectClips, boolean _bSelectClipAtMouse, MouseEvent _evOrNull) {

      tstate.undoAdd(clip_selection);

      if(_bSelectClips)
      {
         selectClips(false/*bAllowToggle*/, false/*bAdd*/);
      }
      else if(_bSelectClipAtMouse)
      {
         selectClipAtEv(_evOrNull, false/*bAllowToggle*/, false/*bAdd*/);
      }

      int nodeGID;
      int clipUID;
      int i = 0;

      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         NA_Track track <= tstate.findTrackByGID(nodeGID);

         if(null != track)
         {
            NA_Clip clip <= track.findClipByUID(clipUID);

            if(null != clip)
               clip.setEnableMute(!clip.b_mute);
         }

         // Next selected clip
         i += 2;
      }

      redraw();

      tstate.undoEnd(clip_selection);
   }

   // <method.png>
   public method toggleMuteDragSelection() {
      // called in grid_cursor_mode when 't' is pressed

      selectClips(false/*bAllowToggle*/, false/*bAdd*/);
      toggleMuteSelectedClips(false/*bSelectClips*/, false/*bSelectClipAtMouse*/, null/*MouseEvent*/);
   }

   // <method.png>
   public method expandGridCursorSelectionY() {
      if(tstate.getNumTracks() > 1)
      {
         drag_start_track = (tstate.b_show_marker ? 0 : 1);
         drag_end_track = tstate.getNumTracks() - 1;
         sortDragSelection();
         UI.CompositeAll();
      }
   }

   // <method.png>
   public method toggleExpandGridCursorSelectionY() {
      if(tstate.getNumTracks() > 1)
      {
         if( (drag_start_track_sorted == (tstate.b_show_marker ? 0 : 1)) &&
             (drag_end_track_sorted == (tstate.getNumTracks() - 1))
             )
         {
            drag_start_track = drag_start_track_before_expand_y;
            drag_end_track = drag_start_track;
         }
         else
         {
            drag_start_track_before_expand_y = drag_start_track;
            expandGridCursorSelectionY();
         }
         sortDragSelection();
         redraw();
      }
   }

   // <method.png>
   public method moveGridCursorLeft(boolean _bAdd) {
      if(_bAdd)
      {
         // Move end
         if(drag_end_ticks > 0)
         {
            drag_end_ticks -= tstate.calcGridTicks();
            if(drag_end_ticks < 0)
               drag_end_ticks = 0;

            if(drag_start_ticks == drag_end_ticks)
            {
               drag_start_ticks = drag_end_ticks + tstate.calcGridTicks();
               drag_end_ticks -= tstate.calcGridTicks();
               if(drag_end_ticks < 0)
                  drag_end_ticks = 0;
            }
         }
      }
      else
      {
         // Move start
         if(tstate.edit_offset > 0)
         {
            tstate.edit_offset -= tstate.calcGridTicks();
            if(tstate.edit_offset < 0)
               tstate.edit_offset = 0;
            drag_start_ticks = tstate.edit_offset;
            drag_end_ticks = drag_start_ticks + tstate.calcGridTicks();
         }
      }
      sortDragSelection();

      setEditOffsetToTicks(drag_start_ticks_sorted);

      makeRegionVisible(drag_start_ticks_sorted, drag_end_ticks_sorted);
      selectNone();
      redraw();
   }

   // <method.png>
   public method moveGridCursorRight(boolean _bAdd) {
      if(_bAdd)
      {
         // Move end
         drag_end_ticks += tstate.calcGridTicks();
         if(drag_end_ticks == drag_start_ticks)
         {
            drag_start_ticks -= tstate.calcGridTicks();
            drag_end_ticks += tstate.calcGridTicks();
         }
      }
      else
      {
         // Move start
         tstate.edit_offset += tstate.calcGridTicks();
         drag_start_ticks = tstate.edit_offset;
         drag_end_ticks = drag_start_ticks + tstate.calcGridTicks();
      }

      sortDragSelection();

      setEditOffsetToTicks(drag_start_ticks_sorted);

      makeRegionVisible(drag_start_ticks_sorted, drag_end_ticks_sorted);
      selectNone();
      redraw();
   }

   // <method.png>
   public method moveGridCursorUp(boolean _bAdd) {
      // trace "xxx moveGridCursorUp: drag_start_track="+drag_start_track;
      if(_bAdd)
      {
         if(drag_end_track > (tstate.b_show_marker ? 0 : 1))
            drag_end_track--;
      }
      else
      {
         if(drag_start_track > (tstate.b_show_marker ? 0 : 1))
         {
            drag_start_track--;
            drag_end_track = drag_start_track;
            centerTrackByIdx(drag_start_track);
         }
      }
      sortDragSelection();
      selectNone();
      redraw();
   }

   // <method.png>
   public method moveGridCursorDown(boolean _bAdd) {
      if(_bAdd)
      {
         if((drag_end_track+1) < tstate.getNumTracks())
            drag_end_track++;
      }
      else
      {
         if((drag_start_track+1) < tstate.getNumTracks())
         {
            drag_start_track++;
            drag_end_track = drag_start_track;
            centerTrackByIdx(drag_start_track);
         }
      }

      sortDragSelection();
      selectNone();
      redraw();
   }

   // <method.png>
   public method invertTrackLocks() {

      NA_Track *track;
      foreach track in tstate.tracks
         track.setEnableLock(!track.b_lock);

      parent_form.updateMuteSoloLockStates();

      Global.Print("Invert track locks");
   }

   // <method.png>
   public method clearTrackLocks() {

      NA_Track *track;
      foreach track in tstate.tracks
         track.setEnableLock(false);

      parent_form.updateMuteSoloLockStates();

      Global.Print("Clear track locks");
   }

   // <method.png>
   public method toggleTrackLock() {
      NA_Track *track;

      if(tstate.b_grid_cursor_mode)
         track <= tstate.getTrackByIdx(drag_start_track);
      else
         track <= getLastSelectedTrack();

      if(null != track)
      {
         track.setEnableLock(!track.b_lock);

         parent_form.updateMuteSoloLockStates();

         Global.Print("Toggle track lock");
      }
   }

   // <method.png>
   public method toggleTrackMute(NA_Track track) {

      if(null == track)
      {
         if(tstate.b_grid_cursor_mode)
            track <= tstate.getTrackByIdx(drag_start_track);
         else
            track <= getLastSelectedTrack();
      }

      if(null != track)
      {
         track.setEnableMute(!track.b_mute);
         track.b_mute_pre_solo = track.b_mute;
         parent_form.updateMuteSoloLockStates();
         track.queueMuteSoloUpdate();

         seekToEditOffsetAndPlayTickIfMaster();  // [17Nov2023] update node mute state(s)

         Global.Print("Toggle track mute");
      }
   }

   // <method.png>
   public method toggleMuteAllTracks() {
      boolean bAllMuted = true;
      int numChanged = 0;
      NA_Track *track;
      foreach track in tstate.tracks
      {
         if(!track.b_solo)
            bAllMuted = bAllMuted && track.b_mute;
      }

      foreach track in tstate.tracks
      {
         if(!track.b_solo)
         {
            track.setEnableMute(!bAllMuted);
            track.queueMuteSoloUpdate();
            numChanged++;
         }
      }

      parent_form.updateMuteSoloLockStates();

      seekToEditOffsetAndPlayTickIfMaster();  // [17Nov2023] update node mute state(s)

      Global.Print(((bAllMuted)?"Unmute" : "Mute")+" "+numChanged+" track"+Utils.GetPluralString(numChanged));
   }

   // <method.png>
   public method toggleTrackSolo(NA_Track track) {

      if(null == track)
      {
         if(tstate.b_grid_cursor_mode)
            track <= tstate.getTrackByIdx(drag_start_track);
         else
            track <= getLastSelectedTrack();
      }

      if(null != track)
      {
         if(track.b_solo)
         {
            if(1 == tstate.getNumSoloTracks())
            {
               // Last solo'd track, restore pre solo mute states
               tstate.restoreTrackPreSoloMuteStates();
            }
         }
         else if(0 == tstate.getNumSoloTracks())
         {
            // First solo'd track, save pre solo mute states
            tstate.saveTrackPreSoloMuteStatesAndMute();
         }
         track.setEnableMute(false);
         track.setEnableSolo(!track.b_solo);
         parent_form.updateMuteSoloLockStates();
         track.queueMuteSoloUpdate();

         seekToEditOffsetAndPlayTickIfMaster();  // [17Nov2023] update node mute state(s)

         Global.Print("Toggle track solo");
      }
   }

   // <method.png>
   namespace =replay= method alignSelectedClipsToGrid() {

      tstate.undoAdd(clip_selection);

      int nodeGID;
      int clipUID;
      int i = 0;

      int gridTicks = tstate.calcGridTicks();

      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         NA_Track track <= tstate.findTrackByGID(nodeGID);

         if(null != track)
         {
            NA_Clip clip <= track.findClipByUID(clipUID);

            if(null != clip)
            {
               clip.start_ticks = (clip.start_ticks / gridTicks) * gridTicks;
               clip.end_ticks   = (clip.end_ticks / gridTicks) * gridTicks;
            }
         }

         // Next selected clip
         i += 2;
      }

      redraw();

      tstate.undoEnd(clip_selection);
   }

   // <method.png>
   protected method splitAtEditOffset(int _trackIdx) {
      // called when splitting via mouse
      // (note) -1 = all tracks
      int trackIdx;
      int numTracks;

      if(-1 == _trackIdx)
      {
         if(tstate.b_show_marker)
         {
            trackIdx = 0;
            numTracks = tstate.getNumTracks();
         }
         else
         {
            trackIdx = 1;
            numTracks = tstate.getNumTracks() - 1;
         }
      }
      else
      {
         trackIdx = _trackIdx;
         numTracks = 1;
      }

      tstate.undoAdd(clip_selection);

      loop(numTracks)
      {
         NA_Track track <= tstate.getTrackByIdx(trackIdx);
         if(null != track)
            track.splitAt(tstate.edit_offset);

         trackIdx++;
      }

      tstate.undoEnd(clip_selection);

      Global.Print("Split at "+tstate.edit_offset);

      redraw();
   }

   // <method.png>
   protected method splitDragSelection() {
      // called in grid_cursor_mode when 'r' is pressed
      tstate.undoAdd(clip_selection);
      int trackIdx = drag_start_track_sorted;
      while(trackIdx <= drag_end_track_sorted)
      {
         NA_Track track <= tstate.getTrackByIdx(trackIdx);
         if(null != track)
            track.splitAt(tstate.edit_offset);

         trackIdx++;
      }
      tstate.undoEnd(clip_selection);

      Global.Print("Split at "+tstate.edit_offset);

      redraw();
   }

   // <ui_show.png>
   namespace method showComboBoxPopupPatternNrOrSampleDialog(boolean _bWarpMouse) {
      // 'g' key

      if(_bWarpMouse)
         warpMouseToEditCursor(false/*bBelow*/);

      NA_Track track <= getFirstSelectedTrack();
      NA_Clip  clip  <= getFirstSelectedClip();

      if(null != clip)
      {
         int patNr = 0;

         StringArray aOpt; aOpt.empty();  // (note) must not be local
         IntArray aOptColors; aOptColors.empty();
         local String s;
         int defOpt;

         if(clip.isMarker())
         {
            // (note) could show all available marker clip pattern nrs (but why)
            Global.Warning("cannot show selector on marker track");
            return;
         }

         if(clip.isAudio())
         {
            if(SysEx.IsAudioConnected())
            {
               aOpt = f_audio_liverec.getSampleOptions();
               aOptColors.allocAndFill(aOpt.numElements, 0);
               defOpt = AudioLiveRecForm.GetFilteredSampleIndexByUniqueId(clip.audio_smp_uid);
            }
            else
               Global.Warning("audio host not connected");
         }
         else
         {
            // (todo) handle marker track clip name overrides

            defOpt = clip.pattern_nr;

            Node node <= current_song.findNodeByGID(track.node_gid);

            Global.Debug2("showComboBoxPopupPatternNrOrSampleDialog: track.node_gid="+track.node_gid+" node="+#(node));
            cmp_lut.free();

            loop(Node.NUM_PATTERNS/*128*/)
            {
               s = Node.patnr_options.get(patNr);
               s.append(": ");
               boolean bEmpty = true;

               if(null != node)
               {
                  if(!node.nodeIsPatternEmpty(patNr))
                  {
                     s.append(node.nodeGetPatternNameByIdx(patNr));
                     aOpt.add(s);
                     aOptColors.add(Node.patnr_colors.get(patNr));
                     bEmpty = false;
                     cmp_lut.add(patNr);
                  }
               }

               if(0 && bEmpty)  // [25Jan2025] don't show empty patterns
               {
                  int c32 = Node.patnr_colors.get(patNr);
                  cmp_lut.add(patNr);
                  aOpt.add(s);
                  if(Node.EMPTY_PAT_NR/*127*/ == patNr)
                  {
                     aOptColors.add(c32);
                  }
                  else
                  {
                     s.append("-");
                     // // patNrColors.add(UI.TintColor32Alpha(c32, #80ffffff, #90)); //(c32>>24)&255)
                     aOptColors.add(#50ff0000);
                  }
               }

               patNr++;
            }
         }

         if(aOpt.numElements > 0)
         {
            ComboBoxPopup cmp <= ComboBoxPopup.NewComboBoxPopup(this,
                                                                null/*fontOrNull*/,
                                                                aOpt,
                                                                null/*optionsLongOrNull*/,
                                                                defOpt,
                                                                150*UI.font_scaling/*prefSx*/,
                                                                null/*toolTipCaptions*/,
                                                                aOptColors/*optionBGColors*/,
                                                                null/*option_fgtints*/
                                                                );

            cmp.showNearMouse(0,
                              _bWarpMouse ? getCurrentTrackSYScaled() : 0
                              );
            cmp.centerRow();
            cmp.focusFirstTabCycleMember();
            cmp.setEnableHideOnFirstEntryUp(false);
            cmp.setPageSize(4);
            cmp.setPopupCancelKey('g');
            cmp_pattern_nr <= deref cmp;
         }
         else
         {
            Global.Warning("no clip samples found");
         }
      }
   }

   // <ui_handle.png>
   namespace method updatePatternNrOfSelectedClips(int _idx) {
      // trace "xxx updatePatternNrOfSelectedClips: idx="+_idx;

      int nodeGID;
      int clipUID;
      int i = 0;
      int numChanged = 0;

      tstate.undoAddMini(clip_selection);

      loop(clip_selection.numElements / 2)
      {
         nodeGID = clip_selection[i + 0];
         clipUID = clip_selection[i + 1];

         NA_Track track <= tstate.findTrackByGID(nodeGID);

         if(null != track)
         {
            NA_Clip clip <= track.findClipByUID(clipUID);

            if(null != clip)
            {
               clip.setPatternNr(_idx);
               numChanged++;
            }
         }

         // Next selected clip
         i += 2;
      }

      tstate.undoEnd(clip_selection);

      if(numChanged > 0)
         tstate.updateEmptyFlags();

      Global.Print("Select pattern nr "+(Node.patnr_options.get(_idx)));
      handleSelectionChanged();
      redraw();
   }

   // <ui_handle.png>
   namespace =replay= method updateAudioSmpUIDOfSelectedClipsByFilteredSampleIndex(short _idx) {
      trace "[dbg] updateAudioSmpUIDOfSelectedClipsByFilteredSampleIndex: idx="+_idx;

      SysExSample smp <= AudioLiveRecForm.GetFilteredSampleByIndex(_idx);
      if(null != smp)
      {
         int nodeGID;
         int clipUID;
         int i = 0;
         int numChanged = 0;

         tstate.undoAddMini(clip_selection);

         loop(clip_selection.numElements / 2)
         {
            nodeGID = clip_selection[i + 0];
            clipUID = clip_selection[i + 1];

            NA_Track track <= tstate.findTrackByGID(nodeGID);

            if(null != track)
            {
               NA_Clip clip <= track.findClipByUID(clipUID);

               if(null != clip)
               {
                  if(clip.isAudio())
                  {
                     clip.audio_smp_uid              = smp.unique_id;
                     clip.cached_audio_smp_name      = smp.name;
                     clip.b_queued_audio_clip_change = true;  // continue with new sample
                     numChanged++;
                  }
               }
            }

            // Next selected clip
            i += 2;
         }

         tstate.undoEnd(clip_selection);

         if(numChanged > 0)
            tstate.updateEmptyFlags();

         Global.Print("Select sample uid="+smp.unique_id+"(\""+smp.name+"\")");
         handleSelectionChanged();
         redraw();
      }
      else
         trace "[---] updateAudioSmpUIDOfSelectedClipsByFilteredSampleIndex: failed to resolve smp idx="+_idx;
   }

   // <method_get.png>
   public method isClipNrEditable() : boolean {
      return parent_form.isClipNrEditable();
   }

   // <ui_handle.png>
   namespace method incDecPatternNrOfSelectedClips(int _delta) {
      if(isClipNrEditable())
      {
         NA_Clip clip <= getFirstSelectedClip();

         if(null != clip)
         {
            byte newPatternNr;

            if(Node.EMPTY_PAT_NR/*127*/ == clip.pattern_nr)  // --/ ?
            {
               if(_delta > 0)
                  newPatternNr = 0;
               else
                  newPatternNr = (-4 == _delta) ? 124 : 126;
            }
            else
            {
               newPatternNr = mathWrapi(clip.pattern_nr + _delta, 0, 128);
            }

            updatePatternNrOfSelectedClips(newPatternNr);
         }
      }
   }

   // <ui_handle.png>
   namespace method incDecUsedPatternNrOfSelectedClips(int _delta) {
      if(isClipNrEditable())
      {
         NA_Clip clip <= getFirstSelectedClip();

         if(null != clip)
         {
            Node node <= current_song.findNodeByGID(clip.node_gid);

            if(null != node)
            {
               byte newPatternNr = -1;

               if(_delta >= 0)
                  newPatternNr = node.nodeFindNextPatternNrByUsedIdxWithOffset(clip.pattern_nr, _delta);
               else
                  newPatternNr = node.nodeFindPreviousPatternNrByUsedIdxWithOffset(clip.pattern_nr, -_delta);

               if(newPatternNr >= 0)
                  updatePatternNrOfSelectedClips(newPatternNr);
            }
         }
      }
   }

   // <method.png>
   namespace method loopSelectedClips() {
      if(haveSelection())
      {
         tstate.undoAdd(clip_selection);

         Integer minTicks;
         Integer maxTicks;
         findSelectionMinMaxTicks(minTicks, maxTicks);

         if((tstate.loop_start == minTicks) &&
            (tstate.loop_end   == maxTicks)
            )
         {
            tstate.setLoopRange(0, tstate.calcCanvasSizeTicks());
            Global.Print("Loop all (0;"+tstate.calcCanvasSizeTicks()+")");
         }
         else
         {
            tstate.setLoopRange(minTicks, maxTicks);
            Global.Print("Loop selected clips in range ("+minTicks+";"+maxTicks+")");
         }

         tstate.undoEnd(clip_selection);

         redraw();
      }
      else
      {
         // Loop all
         tstate.setLoopRange(0, tstate.calcCanvasSizeTicks());
         Global.Print("Loop all (0;"+tstate.calcCanvasSizeTicks()+")");
         redraw();
      }
   }

   // <method.png>
   namespace method copySelectedClipsToClipboard(boolean _bCut) {
      if(haveSelection())
      {
         int nodeGID;
         int clipUID;
         int i = 0;

         if(_bCut)
            tstate.undoAdd(clip_selection);

         clipboard.free();

         Integer minTicks;
         Integer maxTicks;
         findSelectionMinMaxTicks(minTicks, maxTicks);

         clipboard_ticks = (maxTicks - minTicks);

         int numCopied = 0;

         loop(clip_selection.numElements / 2)
         {
            nodeGID = clip_selection[i + 0];
            clipUID = clip_selection[i + 1];

            NA_Track track <= tstate.findTrackByGID(nodeGID);

            if(null != track)
            {
               NA_Clip clip <= track.findClipByUID(clipUID);

               if(null != clip)
               {
                  NA_Clip clipCopy <= new NA_Clip;
                  clipCopy.copyFrom(clip);
                  clipCopy.start_ticks -= minTicks;
                  clipCopy.end_ticks   -= minTicks;
                  clipboard.add(#(deref clipCopy));

                  if(_bCut)
                  {
                     track.deleteClip(clip);
                     track.sortClipsByStartTime();
                  }

                  numCopied++;
               }
            }

            // Next selected clip
            i += 2;
         }

         if(_bCut)
         {
            clip_selection.free();
            handleSelectionChanged();
            parent_form.redraw();
            parent_form.b_update_knob_size = true;

            tstate.undoEnd(clip_selection);
         }

         Global.Print((_bCut ? "Cut ":"Copy ")+numCopied+" clip"+Utils.GetPluralString(numCopied)+" to clipboard");
      }
   }

   // <method.png>
   namespace =replay= method pasteClipboard(boolean _bInsertSilence) {
      if(clipboard.numElements > 0)
      {
         tstate.undoAdd(clip_selection);

         if(_bInsertSilence)
            tstate.insertSilenceAllTracks(tstate.edit_offset, clipboard_ticks);

         NA_Clip *clipCopy;

         clip_selection.free();

         int numPasted = 0;

         foreach clipCopy in clipboard
         {
            NA_Track track <= tstate.findTrackByGID(clipCopy.node_gid);

            if(null != track)
            {
               if(null != track.findClipAt(tstate.edit_offset + clipCopy.start_ticks))
               {
                  // Corner case: pasting exactly at clip start => make some room for pasted clip
                  track.insertSilence(tstate.edit_offset + clipCopy.start_ticks, (clipCopy.end_ticks - clipCopy.start_ticks));
               }
               NA_Clip clip <= track.newClip(0, 16, false/*bSort*/);
               clip.copyFrom(clipCopy);
               // // trace "xxx clipCopy.node_gid="+clipCopy.node_gid;
               // // trace "xxx clipCopy.start_ticks="+clipCopy.start_ticks;
               // // trace "xxx clipCopy.end_ticks="+clipCopy.end_ticks;
               track.updateClipTicks(clip,
                                     clipCopy.start_ticks + tstate.edit_offset,
                                     clipCopy.end_ticks   + tstate.edit_offset
                                     );
               clip_selection.add(clip.node_gid);
               clip_selection.add(clip.clip_uid);
               // // trace "xxx paste: clip.clip_uid="+clip.clip_uid+" clipCopy.uid="+clipCopy.clip_uid;
               numPasted++;
            }
         }

         // trace "xxx post paste: #sel="+(clip_selection.numElements/2);

         tstate.lazyUpdateTracksFromGIDs(parent_form.parent_editor.available_gids);
         tstate.undoEnd(clip_selection);
         tstate.updateEmptyFlags();

         parent_form.showNode(parent_node, true/*bUndoRedo*/);

         makeRegionVisible(tstate.edit_offset, tstate.edit_offset + clipboard_ticks);

         handleSelectionChanged();
         parent_form.relayout();
         parent_form.redraw();
         parent_form.b_update_knob_size = true;

         Global.Print("Paste "+numPasted+" clip"+Utils.GetPluralString(numPasted));
      }
   }

   // <method.png>
   namespace method findHighestClipboardClipPatternNrForNodeGID(int _nodeGID) : int {
      int maxPat = -1;
      if(null != clipboard)
      {
         NA_Clip *clip;
         foreach clip in clipboard
         {
            if(clip.node_gid == _nodeGID)
            {
               if(clip.pattern_nr > maxPat)
                  maxPat = clip.pattern_nr;
            }
         }
      }
      return maxPat;
   }

   // <method.png>
   namespace method toggleZoomToSelectedClips() {
      if(haveSelection())
      {
         Integer minTicks;
         Integer maxTicks;
         findSelectionMinMaxTicks(minTicks, maxTicks);

         // // trace "xxx toggleZoomToSelectedTicks: minmax=("+minTicks+";"+maxTicks+")";

         int totalTicks = tstate.calcCanvasSizeTicks();
         int newVisTicks = (maxTicks - minTicks) * 4;
         int newTickOff = minTicks - newVisTicks*0.5;

         if(newTickOff < 0)
         {
            // Clip left
            newTickOff = 0;
         }

         if((newTickOff + newVisTicks) > totalTicks)
         {
            // Clip right
            newTickOff = totalTicks - newVisTicks;
         }

         if((tstate.view_offset == newTickOff) &&
            (tstate.vis_ticks   == newVisTicks)
            )
         {
            // Restore previous view
            tstate.view_offset = tstate.prev_view_offset;
            tstate.vis_ticks   = tstate.prev_vis_ticks;
         }
         else
         {
            // Save current view
            tstate.prev_view_offset = tstate.view_offset;
            tstate.prev_vis_ticks   = tstate.vis_ticks;

            tstate.view_offset = newTickOff;
            tstate.vis_ticks   = newVisTicks;
         }

         clipTickOffset();

         parent_form.redraw();
         parent_form.b_update_knob_size = true;
      }
   }

   // <ui_undo.png>
   namespace method undo() {
      tstate.undo(clip_selection);

      tstate.lazyUpdateTracksFromGIDs(parent_form.parent_editor.available_gids);

      parent_form.showNode(parent_node, true/*bUndoRedo*/);
      handleSelectionChanged();
      parent_form.redraw();
      parent_form.b_update_knob_size = true;
      parent_form.relayout();

      Global.Print("Undo (stack index is now "+tstate.getUndoStackIndex()+")");
   }

   // <method.png>
   namespace method toggleOrSetScratch(boolean _bSet) {
      boolean bScratch = _bSet;
      if(maybe == bScratch)
      {
         bScratch = !tstate.b_scratch;
         parent_form.cb_scratch.setSelected(bScratch);
      }

      // Remember previous selection region
      boolean bHaveSelection = haveSelection();

      Integer minTicks;
      Integer maxTicks;
      if(bHaveSelection)
      {
         if(!tstate.b_grid_cursor_mode)
         {
            findSelectionMinMaxTicks(minTicks, maxTicks);
            drag_start_track = getFirstSelectedTrackIdx();
         }
      }

      if(bScratch)
      {
         tstate.selectScratch();
         tstate.updateEmptyFlags();
         redraw();
      }
      else
      {
         tstate.selectMain();
         tstate.updateEmptyFlags();
         redraw();
      }

      if(bHaveSelection)
      {
         if(!tstate.b_grid_cursor_mode)
         {
            // Try to select clips in previous selection region
            drag_start_ticks = minTicks;
            drag_end_ticks = maxTicks;
            drag_end_track = drag_start_track;
            sortDragSelection();
            selectClips(false/*bAllowToggle*/, false/*bAdd*/);
            drag_start_ticks = drag_end_ticks;
            sortDragSelection();
         }
      }

      if(bScratch)
         Global.Print("Select scratchpad timeline");
      else
         Global.Print("Select main timeline");
   }

   // <method.png>
   namespace method toggleOrSetGridCursorMode(boolean _bSet, boolean _bUpdateSelection, boolean _bVerbose) {

      if(maybe == _bSet)
      {
         tstate.b_grid_cursor_mode = !tstate.b_grid_cursor_mode;
         parent_form.cb_cursor.setSelected(tstate.b_grid_cursor_mode);
      }
      else
      {
         tstate.b_grid_cursor_mode = _bSet;
      }

      if(_bUpdateSelection)
      {
         if(tstate.b_grid_cursor_mode)
         {
            // Activate grid-cursor-mode
            if(haveSelection())
            {
               trace "xxx activate selection-cursor-mode  drag_start_track="+drag_start_track+" drag_end_track="+drag_end_track;
               // Set initial cursor position to first select clip
               NA_Clip clip <= getFirstSelectedClip();
               if(null != clip)
               {
                  NA_Track track <= tstate.findTrackByGID(clip.node_gid);
                  if(null != track)
                  {
                     int trackIdx = tstate.getTrackIdxByTrack(track);
                     drag_start_track = trackIdx;
                     drag_end_track = trackIdx;
                     drag_start_ticks = tstate.edit_offset;//clip.start_ticks;
                     drag_end_ticks = drag_start_ticks + tstate.calcGridTicks();
                  }
               }
               selectNone();
            }
            else
            {
               drag_start_ticks = tstate.edit_offset;
               drag_end_ticks = drag_start_ticks + tstate.calcGridTicks();
            }

            b_allow_empty_selection = true;

            if(tstate.b_show_marker)
            {
               drag_start_track = mathClampi(drag_start_track, 0, tstate.getNumTracks());
               drag_end_track = mathClampi(drag_end_track, 0, tstate.getNumTracks());
            }
            else
            {
               drag_start_track = mathClampi(drag_start_track, 1, tstate.getNumTracks());
               drag_end_track = mathClampi(drag_end_track, 1, tstate.getNumTracks());
            }

            sortDragSelection();
         }
         else
         {
            // Deactivate selection-cursor-mode
            selectClips(false/*bAllowToggle*/, false/*bAdd*/);
            drag_start_ticks = drag_end_ticks;
            drag_start_ticks_sorted = drag_end_ticks_sorted;
         }
      }

      if(tstate.b_grid_cursor_mode)
         centerTrackByIdx(drag_start_track);

      redraw();
      if(_bVerbose)
         Global.Print("Grid cursor mode is "+Utils.GetEnableString(tstate.b_grid_cursor_mode));
   }

   // <method.png>
   namespace method toggleOrSetEdgeSelectionMode(boolean _bSet) {
      if(maybe == _bSet)
      {
         tstate.b_edge_selection_mode = !tstate.b_edge_selection_mode;
         parent_form.cb_edge.setSelected(tstate.b_edge_selection_mode);
      }
      else
      {
         tstate.b_edge_selection_mode = _bSet;
      }

      Global.Print("Edge selection mode is "+Utils.GetEnableString(tstate.b_edge_selection_mode));
   }

   // <method.png>
   namespace method switchBetweenMarkerAndRegularTrack() {
      Global.Debug("arr: switchBetweenMarkerAndRegularTrack");

      boolean bSelected = false;
      int selTrack = 1;
      int curTrack = 99999999;
      NA_Track *track;

      Integer minTicks;
      Integer maxTicks;
      findSelectionMinMaxTicks(minTicks, maxTicks);

      if(tstate.b_grid_cursor_mode)
      {
         curTrack = drag_start_track_sorted;
      }
      else
      {
         track <= getFirstSelectedTrack();
         if(null != track)
            curTrack = tstate.getTrackIdxByTrack(track);
      }

      if(curTrack > 0)
      {
         // Switch to marker track
         tstate.ui_pre_switch_marker_track_nr = curTrack;
         tstate.b_ui_pre_switch_show_marker = tstate.b_show_marker;

         // Lazy-show marker track
         if(!tstate.b_show_marker)
            parent_form.handleToggleShowMarkerTrack();

         selTrack = 0;
         bSelected = true;
      }
      else
      {
         // Switch to regular track
         int trackIdx = tstate.ui_pre_switch_marker_track_nr;

         if(trackIdx < 1)
            trackIdx = 1;

         if(trackIdx >= tstate.getNumTracks())
            trackIdx = 1;

         if(!tstate.b_grid_cursor_mode)
         {
            // Skip tracks that don't have clip(s) in the marker clip range
            if(1 <= trackIdx < tstate.getNumTracks())
            {
               if(haveSelection()) // usually true since clips are autoselected
               {
                  while(trackIdx < tstate.getNumTracks())
                  {
                     track <= tstate.getTrackByIdx(trackIdx);
                     if(track.anyClipsWithinRange(minTicks, maxTicks))
                        break;
                     trackIdx++;
                  }
               }
            }
         }
         // // else
         // // {
         // //    // Skip empty track(s)
         // //    if(1 <= trackIdx < tstate.getNumTracks())
         // //    {
         // //       track <= tstate.getTrackByIdx(trackIdx);
         // //       trace "xxx trackIdx="+trackIdx+" track.getNumClips()="+track.getNumClips();
         // //       if(0 == track.getNumClips())
         // //       {
         // //          // Find first non-empty track
         // //          trackIdx = 1;
         // //          while(trackIdx < tstate.getNumTracks())
         // //          {
         // //             track <= tstate.getTrackByIdx(trackIdx);
         // //             if(0 != track.getNumClips())
         // //                break;
         // //             trackIdx++;
         // //          }
         // //       }
         // //    }
         // // }

         if(trackIdx >= 1)
         {
            if(trackIdx < tstate.getNumTracks())
            {
               selTrack = trackIdx;
               bSelected = true;

               // Show/hide marker
               if(tstate.b_ui_pre_switch_show_marker ^ tstate.b_show_marker)
                  parent_form.handleToggleShowMarkerTrack();
            }
         }
      }

      // trace "xxx bSelected="+bSelected+" selTrack="+selTrack;

      if(bSelected)
      {
         if(!tstate.b_grid_cursor_mode)
         {
            // Try to select clips at edit offset
            //   ! usually selects single clip if grid size is 1 beat
            drag_start_ticks = tstate.edit_offset;
            drag_end_ticks = drag_start_ticks + tstate.calcGridTicks();
            drag_start_track = selTrack;
            drag_end_track = drag_start_track;
            sortDragSelection();
            selectClips(false/*bAllowToggle*/, false/*bAdd*/);

            if(!haveSelection())
            {
               // Try to select clip(s) in previous selection range
               drag_start_ticks = minTicks;
               drag_end_ticks = maxTicks;
               drag_start_track = selTrack;
               drag_end_track = drag_start_track;
               sortDragSelection();
               selectClips(false/*bAllowToggle*/, false/*bAdd*/);
            }

            drag_start_ticks = drag_end_ticks; // empty drag selection
            sortDragSelection();
            makeSelectionVisible();
         }
         else
         {
            if(drag_start_ticks_sorted == drag_end_ticks_sorted)
            {
               // Lazy-create new selection
               drag_start_ticks = tstate.edit_offset;
               drag_end_ticks = tstate.calcGridTicks();
            }
            drag_start_track = selTrack;
            drag_end_track = drag_start_track;
            sortDragSelection();
         }
         redraw();
      }
   }

   // <method.png>
   protected method editNameOfFirstSelectedClip() {

      lazySelectGridCursorClips();

      NA_Clip clip <= getFirstSelectedClip();
      if(null != clip)
      {
         // Reduce selection to single clip
         clip_selection.empty();
         clip_selection.add(clip.node_gid);
         clip_selection.add(clip.clip_uid);
         handleSelectionChanged();

         UI.SetKeyboardFocus(parent_form.tf_clip_name);
         parent_form.tf_clip_name.selectAll();

         Global.Print("Edit clip name");
      }
   }

   // <ui_undo.png>
   namespace method redo() {
      tstate.redo(clip_selection);

      tstate.lazyUpdateTracksFromGIDs(parent_form.parent_editor.available_gids);

      parent_form.showNode(parent_node, true/*bUndoRedo*/);
      handleSelectionChanged();
      parent_form.redraw();
      parent_form.b_update_knob_size = true;
      parent_form.relayout();

      Global.Print("Redo (stack index is now "+tstate.getRedoStackIndex()+")");
   }

   // <method.png>
   protected method queuePlayOffset(int _playOffset) {
      tstate.queuePlayOffset(_playOffset, false/*bReplay*/);
      Global.Print("Queue play offset "+_playOffset+" ("+(_playOffset / (current_song.ppq/4))+" 16th / "+RootForm.GetSongPosString(_playOffset)+")");
      compositeAll();
   }

   // <method.png>
   protected method queuePlayOffsetAtEv(MouseEvent _ev) {
      // Queue play offset (align to 16th notes)
      int playOffset = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
      queuePlayOffset(playOffset);
   }

   // <method.png>
   public method centerTrackByIdx(int _trackIdx) {
      ScrollPane sp <= parent_form.sp_data;
      sp.setViewOffsetY( _trackIdx * getCurrentTrackSYScaled() - sp.getSizeY()*0.5 + getCurrentTrackSYScaled()*0.5);
   }

   // <method.png>
   public method centerFirstSelectedTrack() {
      if(haveSelection())
      {
         int trackIdx = getFirstSelectedTrackIdx();
         if(trackIdx >= 0)
            centerTrackByIdx(trackIdx);
      }
      else if(tstate.b_grid_cursor_mode)
      {
         centerTrackByIdx(drag_start_track);
      }
   }

   // <method.png>
   public method incTrackSizeY() {
      int idx = mathMaxi(0, track_size_tbl.indexOf(current_track_sy, 0));
      idx = mathMini(track_size_tbl.numElements-1, idx + 1);
      current_track_sy = track_size_tbl[idx];

      parent_form.updateTrackForms();
      parent_form.updateMuteSoloLockStates();
      parent_form.relayout();
      UI.RedrawAll();

      centerFirstSelectedTrack();

      Global.Print("Inc: Track size is "+idx);
   }

   // <method.png>
   public method decTrackSizeY() {
      int idx = mathMaxi(0, track_size_tbl.indexOf(current_track_sy, 0));
      idx = mathMaxi(0, idx - 1);
      current_track_sy = track_size_tbl[idx];

      parent_form.updateTrackForms();
      parent_form.updateMuteSoloLockStates();
      parent_form.relayout();
      UI.RedrawAll();

      centerFirstSelectedTrack();

      Global.Print("Dec: Track size is "+idx);
   }

   // <method.png>
   protected method warpMouseToEditCursor(boolean _bBelow) {
      float sx = getSizeX() - 2*2;
      float sy = getSizeY() - 2*2;
      int visTicks = tstate.vis_ticks;
      float pixPerTick = sx / visTicks;
      float shiftX = 2+2;
      float shiftY = 1 + 2 + GetTopSY();
      float currentTrackSY = getCurrentTrackSYScaled();
      int tickOffset = tstate.view_offset;
      float px = (tstate.edit_offset - tickOffset) * pixPerTick;  // relative to shiftX
      float py = (drag_start_track + _bBelow) * currentTrackSY;
      trace "[dbg] warpMouseToEditCursor: p=("+px+";"+py+") edit_offset="+tstate.edit_offset+" trackIdx="+drag_start_track;
      warpTo(px + shiftX, py + shiftY);
   }

   // <method.png>
   protected method getClipInitCtlString(NA_Clip _clip, int _ctlIdx) {
      return dlg_clipctl.getInitCtlString(_clip, _ctlIdx);
   }

   // <ui_render.png>
   public virtual onDrawOverlays() {

      int c32;

      float sx = getSizeX();
      float sy = getSizeY();
      sx -= 2*2;
      sy -= 2*2;

      // // trace "xxx NA_TimelineData::onDrawOverlays";
      // // trace "xxx NA_TimelineData::onDrawOverlays: current_track_sy="+current_track_sy;

      // glPushAttrib(GL_ALL_ATTRIB_BITS);

      Point2f abspos;
      calcAbsolutePositionFBO(abspos);

      sdvg_PushScissor(abspos.x+0.5, abspos.y+0.5, size_x+0.5, size_y+0.5);
      sdvg_EnableScissor();

      int visTicks = tstate.vis_ticks;
      float currentTrackSY = getCurrentTrackSYScaled();

      if(visTicks > 0)
      {
         float px;
         float py;
         float pw;
         float ph;
         float t;

         float pixPerTick = sx / visTicks;

         float shiftX = 2+2;
         float shiftY = 1 + 2 + GetTopSY();

         if((true == tstate.b_follow) && replay.b_playing)
         {
            int playOff = tstate.getPlayOffset();

            // // makeRegionVisible(playOff, playOff + tstate.vis_ticks/2);
            // // makeRegionVisible(playOff, playOff + (tstate.vis_ticks*3)/4);
            makeRegionVisible(playOff - tstate.vis_ticks*STConfig.node_arranger_follow_paging_percent,
                              playOff + tstate.vis_ticks*STConfig.node_arranger_follow_paging_percent
                              );

            // // if(playOff < tstate.view_offset)
            // // {
            // //    // Center
            // //    playOff -= tstate.vis_ticks/2;
            // //    makeRegionVisible(playOff, playOff + tstate.vis_ticks);
            // //    visTicks = tstate.vis_ticks;
            // // }
            // // else if(playOff >= (tstate.view_offset + tstate.vis_ticks))
            // // {
            // //    // Scroll 64 pixels
            // //    int scrollTicks = 64 / pixPerTick;
            // //    playOff = tstate.view_offset + scrollTicks;
            // //    makeRegionVisible(playOff, playOff + tstate.vis_ticks);
            // //    visTicks = tstate.vis_ticks;
            // // }
         }

         int tickOffset = tstate.view_offset;

         UIRenderer.EnableBlending();

         int numTicksPerNote = current_song.ppq * 4;
         float numTicksPerBeat = (numTicksPerNote / float(current_song.sig_notelen));
         float numTicksPerBar = numTicksPerBeat * current_song.sig_beats;

         float gridWidth = tstate.calcGridTicks() * pixPerTick;
         float playWidth = (current_song.ppq / 4.0)/*16th*/ * pixPerTick;
         if(playWidth < 2.0)
            playWidth = 2.0;

         // Draw edit position marker
         px = (tstate.edit_offset - tickOffset) * pixPerTick;

         if(((px + gridWidth) >= 0) && (px < sx))
         {
            c32 = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_EDIT_MARKER);

            UIRenderer.DrawFilledRectangle(px + shiftX, shiftY,
                                           gridWidth, (sy-GetTopSY()),
                                           c32
                                           );

            if(hasKeyboardFocus())
            {
               c32 = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_EDIT_KBD_MARKER);
               UIRenderer.DrawRectangle(px + shiftX, shiftY,
                                        gridWidth, (sy-GetTopSY()),
                                        2,
                                        c32
                                        );
            }
         }

         // Draw play position marker
         // // if(replay.b_playing)
         if(1)
         {
            px = (tstate.play_offset - tickOffset) * pixPerTick;

            if((px + playWidth) >= 0)
            {
               if(px < sx)
               {
                  c32 = app_lnf.getColor(replay.b_playing
                                         ? AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_PLAYPOS_MARKER
                                         : AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_PLAYPOS_IDLE_MARKER
                                         );
                  // // glEnable(GL_POLYGON_SMOOTH);
                  UIRenderer.DrawFilledRectangle(px + shiftX, shiftY, playWidth, (sy-16), c32);
                  // // glDisable(GL_POLYGON_SMOOTH);
               }
            }
         }

         // Draw clip selection region
         boolean bDrawRegion =
            ((DRAG_SELECT  == drag_mode) || b_allow_empty_selection) ||
            (DRAG_NEWCLIP == drag_mode) ||
            (DRAG_MUTE == drag_mode);

         // // trace "xxx drag_mode="+drag_mode+" b_allow_empty_selection="+b_allow_empty_selection+" bDrawRegion="+bDrawRegion;

         py = drag_start_track_sorted * currentTrackSY;
         if(!tstate.b_show_marker)
            py -= currentTrackSY;
         if(py < 0)
            py = 0;

         if(bDrawRegion)
         {
            px = (drag_start_ticks_sorted - tickOffset) * pixPerTick;
            pw = (drag_end_ticks_sorted - tickOffset) * pixPerTick;
            pw = pw - px;

            ph = (drag_end_track_sorted + 1 - drag_start_track_sorted) * currentTrackSY;

            if(!tstate.b_show_marker && (0 == drag_start_track_sorted))
               ph -= currentTrackSY;

            // trace "xxx drawRegion py="+py+" pw="+pw+" ph="+ph;

            if(pw > 0 && ph > 0)
            {
               int c32Sel =
                  b_drag_overlap
                  ? app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_SELECTION_DRAG_OVERLAP)
                  : (DRAG_NEWCLIP == drag_mode)
                  ? app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_SELECTION_DRAG_NEWCLIP)
                  : app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_SELECTION)
                  ;

               UIRenderer.DrawFilledRectangle(px + shiftX, py + shiftY,
                                              pw, ph - 2,
                                              c32Sel
                                              );
            }
            else
            {
               // e.g. after toggling grid cursor mode on and off again
               bDrawRegion = false;
            }
         }

         if(!bDrawRegion)
         {
            px = (tstate.edit_offset - tickOffset) * pixPerTick;
            pw = gridWidth;
            ph = currentTrackSY;
            UIRenderer.DrawFilledRectangle(px + shiftX, py + shiftY,
                                           pw, ph - 2,
                                           app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_GRID_POS)
                                           );
         }

         UIRenderer.DrawFilledRectangle(px + shiftX - 1, py + shiftY,
                                        2, ph - 2,
                                        app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_OVERLAY_GRID_POS_START)
                                        );

         UIRenderer.DisableBlending();
      }

      // // UI.PopScissors();
      sdvg_PopScissor();
      sdvg_DisableScissor();

      // glPopAttrib();

      // // // if(replay.b_playing)
      // // //    UI.CompositeAll();
   }

   // <ui_render.png>
   public virtual onDraw() {

      if(-1 != queued_marker_clip_selection_idx)
      {
         // Select marker clip (via auto-dev note-on)
         NA_Clip markerClip <= tstate.findMarkerClipByIdx(queued_marker_clip_selection_idx);
         if(null != markerClip)
         {
            clip_selection.empty();
            clip_selection.add(markerClip.node_gid);
            clip_selection.add(markerClip.clip_uid);
            handleSelectionChanged();
            makeRegionVisible(markerClip.start_ticks,
                              markerClip.end_ticks
                              );
            tstate.edit_offset = markerClip.start_ticks;
         }
         queued_marker_clip_selection_idx = -1;
      }

      float sx = getSizeX();
      float sy = getSizeY();
      UIRenderer.DrawDefaultBackground(0, 0, sx, sy);

      if(app_lnf.b_arranger_timeline_border)
         UIRenderer.DrawDefaultSunkenBorder(0, 0, sx, sy);

      Point2f abspos;
      calcAbsolutePositionFBO(abspos);

      // glPushAttrib(GL_ALL_ATTRIB_BITS);

      // // UI.PushScissors(abspos.x+0.5+1+1+1, abspos.y+0.5, size_x+0.5-1+1, size_y+0.5);
      sdvg_PushScissor(abspos.x+0.5+1+1+1, abspos.y+0.5, size_x+0.5-1+1, size_y+0.5);
      sdvg_EnableScissor();

      sx -= 2*2;
      sy -= 2*2;

      float shiftX = 2+2  -1;
      float shiftY = 1 + 2 + GetTopSY();

      int tickOffset = tstate.view_offset;
      int visTicks = tstate.vis_ticks;

      float currentTrackSY = getCurrentTrackSYScaled();

      int c32WindowBgTint = lnf_colors.get(LookAndFeel.COLOR_WINDOW_BG);
      c32WindowBgTint &= 0x00FFFFFF;
      int c32LineTint = c32WindowBgTint;
      c32WindowBgTint |= STConfig.arranger_canvas_fade_window_bg << 24;
      c32LineTint     |= STConfig.arranger_dividers_fade_window_bg << 24;

      if(visTicks > 0)
      {
         int numTicksPerNote = current_song.ppq * 4;
         float numTicksPerBeat = (numTicksPerNote / float(current_song.sig_notelen));
         float numTicksPerBar = numTicksPerBeat * current_song.sig_beats;

         float pixPerTick = sx / visTicks;
         float ticksPerPix = visTicks / sx;

         int gridTicks = tstate.calcGridTicks();
         float valueWidth = gridTicks * pixPerTick;

         if(valueWidth < 4)
            valueWidth = int(0.5 + valueWidth);
         if(valueWidth < 1)
            valueWidth = 1;

         NA_Track *track;
         int highlightTrackIdx = -1;

         track <= getFirstSelectedTrack();

         if(tstate.b_grid_cursor_mode)
            highlightTrackIdx = drag_start_track;
         else if(null != track)
            highlightTrackIdx = tstate.getTrackIdxByTrack(track);
         else
            highlightTrackIdx = drag_start_track;  // [24Jan2025] highlight track also when cursor is at end of clip

         int t;
         float ct;
         int c32;

         // Draw background
         float px = ((-tickOffset) % gridTicks) * pixPerTick;
         int gridIdx = -tickOffset / gridTicks;

         int c32BgE;
         int c32BgO;

         if(tstate.b_scratch)
         {
            c32BgE = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BG_EVEN_SCRATCH);
            c32BgO = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BG_ODD_SCRATCH);
         }
         else
         {
            c32BgE = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BG_EVEN_MAIN);
            c32BgO = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BG_ODD_MAIN);
         }

         c32BgE = UI.TintColor32(c32BgE, c32WindowBgTint);
         c32BgO = UI.TintColor32(c32BgO, c32WindowBgTint);

         int c32Tick = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TICK);

         while(px < sx)
         {
            float nx = px + pixPerTick * gridTicks;
            int c32Bg = (gridIdx&1) ? c32BgO : c32BgE;
            UIRenderer.DrawFilledRectangle(px + shiftX, shiftY, nx - px, (sy-GetTopSY()), c32Bg);
            // // if(gridIdx&1)
            // // {
            // // UIRenderer.DrawFilledRectangle(px + 2, 2+15, nx - px, 1, c32Tick);
            UIRenderer.DrawFilledRectangle(px + shiftX, 2+14*UI.font_scaling, 1, 2, c32Tick);
            // // }
            px = nx;
            gridIdx++;
         }

         // Draw beat marker
         int c32Beat = app_lnf.getTintedColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BEAT_MARKER, c32LineTint);
         boolean bDrawBeatLabel = (visTicks < (numTicksPerBeat * 16));
         int beatModulo = (sx / (numTicksPerBeat * pixPerTick)) / 40;
         if(beatModulo < 1)
            beatModulo = 1;
         else if(beatModulo & 1)
            beatModulo++;
         if(null == font)
            font <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);
         int beatIdx;
         UIRenderer.SetLineWidth(2.0f);
         // // glLineStipple(2.0f, 0xaaaa);
         // // glEnable(GL_LINE_STIPPLE);

         beatIdx = int((tickOffset + numTicksPerBeat - 1) / numTicksPerBeat);

         int c32BeatLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BEAT_LABEL);
         if(bDrawBeatLabel)
         {
            t = beatIdx * numTicksPerBeat;
            ct = (t - tickOffset);
            px = ct * pixPerTick;
            while(px < sx)
            {
               if(0 == (beatIdx % beatModulo))
               {
                  if(px >= 0)
                  {
                     UIRenderer.DrawLine(px+shiftX, 2, px+shiftX, 2+sy, c32Beat);
                     String beatLabel = (STConfig.arranger_beatbar_label_offset + (beatIdx / current_song.sig_beats))+"."+(STConfig.arranger_beatbar_label_offset + (beatIdx % current_song.sig_beats));
                     float beatLabelWidth = 2 + font.stringWidth(beatLabel);
                     UIRenderer.EnableBlending();
                     // // UIRenderer.DrawFilledRectangle(px + 4, 2, barLabelWidth, 2 + 14, #bfafafaf);
                     UIRenderer.DrawText(beatLabel, font, c32BeatLabel, c32BeatLabel, px + shiftX + 2 + 1, 2, 0/*availW*/, 0/*align*/);
                     UIRenderer.DisableBlending();
                  }
               }
               ct += numTicksPerBeat;
               px = ct * pixPerTick;
               beatIdx++;
            }
         }
         else
         {
            // No labels
            t = int((tickOffset + numTicksPerBeat - 1) / numTicksPerBeat) * numTicksPerBeat;
            ct = (t - tickOffset);
            px = ct * pixPerTick;
            while(px < sx)
            {
               if(0 == (beatIdx % beatModulo))
               {
                  if(px >= 0)
                     UIRenderer.DrawLine(px+shiftX, 2, px+shiftX, 2+sy, c32Beat);
               }
               ct += numTicksPerBeat;
               px = ct * pixPerTick;
               beatIdx++;
            }
         }
         // // glDisable(GL_LINE_STIPPLE);

         // Draw bar marker
         // // int c32Bar = #ff000000;
         int barModulo = (sx / (numTicksPerBar * pixPerTick)) / 10;
         if(barModulo < 1)
            barModulo = 1;
         else if(barModulo & 1)
            barModulo++;

         int c32Bar = app_lnf.getTintedColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BAR_MARKER, c32LineTint);
         int barIdx = int((tickOffset + numTicksPerBar - 1) / numTicksPerBar);
         barIdx--;
         t = barIdx * numTicksPerBar;
         ct = (t - tickOffset);
         px = ct * pixPerTick;
         int c32WinBG = lnf_colors.get(LookAndFeel.COLOR_WINDOW_BG);
         float numPixPerBeat = numTicksPerBeat * pixPerTick;

         // // trace "\n-------- draw bar labels start_px="+px;
         int c32BarLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_BAR_LABEL);
         while(px < sx)
         {
            boolean bRenderBarLabel = (0 == (barIdx % barModulo));
            // // trace "xxx barLabel px="+px;
            // // if(bRenderBarLabel && (px >= 0))
            if(bRenderBarLabel && (px >= -30))
            {
               UIRenderer.DrawLine(px + shiftX, 2, px + shiftX, 2+sy, c32Bar);
               String sBar = String(barIdx + STConfig.arranger_beatbar_label_offset);
               float barLabelWidth = 2 + font.stringWidth(sBar);
               if(!bDrawBeatLabel)
               {
                  if(numPixPerBeat < 40)
                     UIRenderer.DrawFilledRectangle(px + shiftX+2, 2, barLabelWidth, 2 + 14, c32WinBG); // #bfafafaf
                  UIRenderer.EnableBlending();
                  UIRenderer.DrawText(sBar, font, c32BarLabel, c32BarLabel, px + shiftX+2 + 1, 2, 0/*availW*/, 0/*align*/);
                  UIRenderer.DisableBlending();
               }
            }
            barIdx++;
            ct += numTicksPerBar;
            px = ct * pixPerTick;
         }

         UIRenderer.SetLineWidth(1.0f);

         // Draw clips
         // // UI.PushScissors(abspos.x+0.5 + 3, abspos.y+0.5 + 2 + GetTopSY(), size_x+0.5-3, size_y+0.5 -3-GetTopSY());
         sdvg_PushScissor(abspos.x+0.5 + 3, abspos.y+0.5 + 2 + GetTopSY(), size_x+0.5-3, size_y+0.5 -3-GetTopSY());

         float py = 2 + GetTopSY();
         int trackIdx = 0;
         float pw;
         float labelOffY = font.stringHeight("01A");
         // labelOffY = (currentTrackSY - labelOffY) * 0.5 - 2;
         labelOffY = 3;

         int c32HighlightTrack = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_HL_TRACK);

         int numVisTracks = tstate.tracks.numElements;

         if(!tstate.b_show_marker)
         {
            numVisTracks--;
            trackIdx++;
         }

         int c32BorderTint = (c32BgE & 0x00FFffFF) | (32 << 24);

         loop(numVisTracks)
         {
            track <= tstate.getTrackByIdx(trackIdx);

            if(null != track) // should never be null
            {
               int clipIdx = 0;
               int numClips = track.clips.numElements;

               boolean bDrawRPNSmp = false;
               NodeTracker nodeTracker <= current_song.findNodeByGID(track.node_gid);
               Envelope *envRPNSmpPeak;

               if(trackIdx == highlightTrackIdx)
               {
                  UIRenderer.EnableBlending();
                  UIRenderer.DrawFilledRectangle(shiftX, py, sx, currentTrackSY, c32HighlightTrack);
                  UIRenderer.DisableBlending();
               }

               loop(numClips)
               {
                  NA_Clip clip <= track.getClipByIdx(clipIdx);
                  px = (clip.start_ticks - tickOffset) * pixPerTick;
                  pw = (clip.end_ticks - tickOffset) * pixPerTick;

                  boolean bCull = ((pw < 0) || (px > size_x)) && (DRAG_NONE == drag_mode);

                  if(!bCull)
                  {
                     pw = pw - px;

                     int c32Clip;
                     int c32ClipLabel;

                     int patNumTicksRPNSmpPeak;
                     if(nodeTracker instanceof NodeTracker)
                     {
                        envRPNSmpPeak <= nodeTracker.getFirstTrackRPNSmpPeakEnvelope(clip.pattern_nr);
                        NT_MetaPattern nodeTrackerPat <= nodeTracker.nodeGetPatternByIdx(clip.pattern_nr);
                        patNumTicksRPNSmpPeak = nodeTrackerPat.num_ticks;
                     }
                     else
                     {
                        envRPNSmpPeak <= null;
                     }

                     boolean bIsSelected = isClipSelected(track.node_gid, clip.clip_uid);

                     if(bIsSelected)
                     {
                        if(clip.isMarker())
                        {
                           c32Clip = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_MARKER_CLIP_SELECT_BG);
                           c32ClipLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_MARKER_CLIP_SELECT_FG);
                        }
                        else
                        {
                           c32Clip = app_lnf.getColor( ( (null != envRPNSmpPeak) ||  clip.isAudio())
                                                       ? AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_SELECT_BG_AUDIO
                                                       : AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_SELECT_BG
                                                       );
                           if(clip.isAudio())
                              c32ClipLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_SELECT_FG_AUDIO);
                           else
                              c32ClipLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_SELECT_FG);
                        }
                     }
                     else
                     {
                        if(clip.isMarker())
                        {
                           c32Clip = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_MARKER_CLIP_BG);
                           c32ClipLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_MARKER_CLIP_LABEL_FG);
                        }
                        else
                        {
                           c32Clip = app_lnf.getColor( ((null != envRPNSmpPeak) ||  clip.isAudio())
                                                       ? AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_BG_AUDIO
                                                       : AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_BG
                                                       );
                           if(clip.isAudio())
                              c32ClipLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_LABEL_FG_AUDIO);
                           else
                              c32ClipLabel = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_LABEL_FG);
                        }
                     }

                     if(clip.b_ui_empty_hint)
                     {
                        c32Clip = UI.TintColor32(c32Clip, app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_EMPTY_TINT));
                     }

                     // Draw clip background
                     UIRenderer.DrawFilledRectangle(px + shiftX,
                                                    py,
                                                    pw,
                                                    currentTrackSY,
                                                    c32Clip
                                                    );

                     float cx;
                     float cy;
                     float lx;
                     float ly;

                     if(null != envRPNSmpPeak)
                     {
                        // trace "xxx NA_TimelineData: draw envRPNSmpPeak";
                        UIRenderer.SetLineWidth(1.0f);
                        UIRenderer.SetColorARGB(app_lnf.getColor(bIsSelected
                                                                 ? AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_AUDIO_SELECT_FG
                                                                 : AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_AUDIO_FG
                                                                 )
                                                );
                        ly = py + currentTrackSY - 2;
                        float envT = -(clip.calcOffsetTicks() % patNumTicksRPNSmpPeak);
                        float envOffX = px + shiftX + 1;
                        float envOffY = currentTrackSY - 2;
                        float envH = currentTrackSY - 4;
                        float envRelOffX = 1;
                        float envLenShiftX = envT * pixPerTick;
                        lx = envLenShiftX;
                        // // int clipNumTicks = clip.end_ticks - clip.start_ticks;
                        float envPatW = patNumTicksRPNSmpPeak * pixPerTick;
                        // // int envCurNumTicks = mathMini(clipNumTicks, patNumTicksRPNSmpPeak);
                        float envClipR = mathMinf(envPatW + lx, pw-2);
                        // // glEnable(GL_LINE_SMOOTH);
                        // // sdvg_ReturnToGL();
                        UIRenderer.EnableBlending();
                        if(UIRenderer.BeginLinesAA( (envRPNSmpPeak.numElements / 2) * 2 ))
                        {
                           do
                           {
                              int envIdx = 0;
                              loop(envRPNSmpPeak.numElements / 2)
                              {
                                 envT += envRPNSmpPeak[envIdx];
                                 cy = py + envOffY - (envRPNSmpPeak[envIdx+1] * envH) / 255.0;
                                 cx = (envT * pixPerTick);
                                 if(cx >= 0.0)
                                 {
                                    if(lx < 0.0)
                                    {
                                       // Clip left
                                       // y(x) = ly + x*cy/(cx - lx)
                                       // // trace "xxx clipL: lx="+lx+" cx="+cx;
                                       ly = ly + (-lx)*(cy-ly)/(cx - lx);
                                       lx = 0;
                                       // // trace "xxx clipL:  => cx="+cx+" cy="+cy;
                                       // // trace "xxx env["+envIdx+"] t="+envT+" cx="+cx+" cy="+cy;
                                       UIRenderer.Vertex2f(lx + envOffX, ly);
                                       UIRenderer.Vertex2f(cx + envOffX, cy);
                                    }
                                    else if(cx >= envClipR)
                                    {
                                       // Clip right
                                       cy = ly + (envClipR - lx)*(cy-ly)/(cx - lx);
                                       cx = envClipR;
                                       // // trace "xxx clipR:  => envOffX="+envOffX+" cx="+cx+" cy="+cy;
                                       // // trace "xxx env["+envIdx+"] t="+envT+" cx="+cx+" cy="+cy;
                                       UIRenderer.Vertex2f(lx + envOffX, ly);
                                       UIRenderer.Vertex2f(cx + envOffX, cy);
                                       break;
                                    }
                                    else
                                    {
                                       // // trace "xxx env["+envIdx+"] envOffX="+envOffX+" t="+envT+" cx="+cx+" cy="+cy;
                                       UIRenderer.Vertex2f(lx + envOffX, ly);
                                       UIRenderer.Vertex2f(cx + envOffX, cy);
                                    }
                                 }
                                 lx = cx;
                                 ly = cy;
                                 envIdx += 2;
                              }

                              // Loop pattern
                              envOffX += envPatW + envLenShiftX;
                              envRelOffX += envPatW + envLenShiftX;
                              envLenShiftX = 0;
                              envClipR = mathMinf(envPatW, (pw-2)-envRelOffX);
                              envT = 0;
                              lx = 0;
                           }
                           while(envRelOffX < (pw-2));
                           UIRenderer.End();
                        }
                        // glDisable(GL_LINE_SMOOTH);
                        UIRenderer.DisableBlending();
                     }
                     else if(clip.isAudio() && !track.isAudioTimeline())
                     {
                        FloatArray smpPeaks <= AudioLiveRecForm.FindSamplePeaksByUniqueId(clip.audio_smp_uid);
                        if(null != smpPeaks)
                        {
                           // (note) numElements == #millisec (peak interval=1ms)
                           int numPeakTicks = current_song.milliSecondsToTicks(smpPeaks.numElements);
                           int offTicks = clip.calcOffsetTicks();
                           numPeakTicks = mathMaxi(0, numPeakTicks - offTicks);
                           numPeakTicks = mathMini(clip.end_ticks - clip.start_ticks, numPeakTicks);
                           if(numPeakTicks > 1)
                           {
                              UIRenderer.SetLineWidth(1.0f);
                              UIRenderer.SetColorARGB(app_lnf.getColor(bIsSelected
                                                                       ? AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_AUDIO_SELECT_FG
                                                                       : AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_AUDIO_FG
                                                                       )
                                                      );
                              cx = px + shiftX + 1;
                              lx = cx;
                              float msPerPix = current_song.ticksToMilliSeconds(ticksPerPix);
                              float smpPeakIdx = current_song.ticksToMilliSeconds(offTicks);
                              float peakOffY = (currentTrackSY/2.0);
                              float peakAmp = (currentTrackSY - 4)/2.0;
                              int numPeakPix = numPeakTicks * pixPerTick;
                              if(numPeakPix > 0)
                                 numPeakPix--;
                              // // glDisable(GL_LINE_SMOOTH);
                              // // sdvg_ReturnToGL();
                              UIRenderer.EnableBlending();
                              if(UIRenderer.BeginLinesAA(numPeakPix*2))
                              {
                                 loop(numPeakPix)
                                 {
                                    cy = smpPeaks.winLinear(smpPeakIdx) * peakAmp;
                                    ly = cy + peakOffY + py;
                                    cy = -cy + peakOffY + py;

                                    // trace "xxx smpPeakIdx="+smpPeakIdx+" cx="+cx+" cy="+cy+" ly="+ly;
                                    if(int(ly) != int(cy))
                                    {
                                       UIRenderer.Vertex2f(cx, ly);
                                       UIRenderer.Vertex2f(cx, cy);
                                    }
                                    else
                                    {
                                       UIRenderer.Vertex2f(cx, cy+1);
                                       UIRenderer.Vertex2f(cx, cy);
                                    }

                                    // lx = cx;
                                    // ly = cy;
                                    cx++;
                                    smpPeakIdx += msPerPix;
                                 }
                                 UIRenderer.End();
                                 UIRenderer.DisableBlending();
                              }
                              // // glDisable(GL_LINE_SMOOTH);
                           }
                        }
                     }

                     // Draw clip border
                     if(app_lnf.b_arranger_timeline_clip_border)
                     {
                        if(1)
                        {
                           // old: bevel border
                           UIRenderer.DrawDefaultRaisedBorderTint(px + shiftX,
                                                                  py,
                                                                  pw,
                                                                  currentTrackSY,
                                                                  c32BorderTint
                                                                  );
                        }
                        else
                        {
                           // new: [11Aug2022] filled rectangle border
                           UIRenderer.DrawRectangle(px + shiftX,
                                                    py,
                                                    pw,
                                                    currentTrackSY,
                                                    2,
                                                    c32BorderTint
                                                    );
                        }
                     }
                     else
                     {
                        int c32ClipStartFlat = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_START_FLAT);
                        if(0 != c32ClipStartFlat)
                        {
                           UIRenderer.DrawLine(px + shiftX, py, px + shiftX, py+currentTrackSY, c32ClipStartFlat);
                        }
                     }

                     // (todo) show pattern name (or clip name override)
                     String clipLabel;
                     boolean bDefLabel = true;
                     if(!clip.isMarker() && tstate.clip_edit_mode >= NA_State.CLIP_EDIT_MODE_INITCTL_MW)
                     {
                        clipLabel = getClipInitCtlString(clip, tstate.clip_edit_mode - NA_State.CLIP_EDIT_MODE_INITCTL_MW);
                        bDefLabel = false;
                     }
                     if(bDefLabel)
                     {
                        if(clip.isAudio() && !track.isAudioTimeline())
                        {
                           clipLabel = clip.getName();
                           // trace "xxx audio clipLabel=\""+clipLabel+"\"";
                        }
                        else
                        {
                           clipLabel = Node.patnr_options_short.get(clip.pattern_nr);

                           if(tstate.b_show_pattern_names)
                           {
                              String clipName = clip.getName();
                              if(!clipName.isBlank())
                              {
                                 clipLabel.append(":");
                                 clipLabel.append(clipName);
                              }
                           }
                        }
                     }

                     UIRenderer.DrawTextClipped(clipLabel,
                                                font,
                                                c32ClipLabel, c32ClipLabel,
                                                px + shiftX + 2,
                                                py + 2 + labelOffY,
                                                px + shiftX +2/*clipLeft*/,
                                                py + 2/*clipTop*/,
                                                px + shiftX + pw - 2/*clipRight*/,
                                                py + currentTrackSY - 2/*clipBottom*/
                                                );

                     if(clip.b_mute)
                     {
                        int c32Mute = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_MUTE_LINE);
                        // // glEnable(GL_LINE_SMOOTH);
                        UIRenderer.SetLineWidth(2.0f);

                        UIRenderer.EnableBlending();
                        UIRenderer.DrawLineAA(px + shiftX + 2,
                                              py + 2,
                                              px + shiftX + pw - 2,
                                              py + 2 + currentTrackSY - 4,
                                              c32Mute
                                              );
                        UIRenderer.DrawLineAA(px + shiftX + 2,
                                              py + 2 + currentTrackSY - 4,
                                              px + shiftX + pw - 2,
                                              py + 2,
                                              c32Mute
                                              );
                        UIRenderer.DisableBlending();
                        // // glDisable(GL_LINE_SMOOTH);
                        UIRenderer.SetLineWidth(1.0f);
                     }

                     if(bIsSelected)
                     {
                        if(b_drag_overlap)
                           c32Clip = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_DRAG_OVERLAP);
                        else
                           c32Clip = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_CLIP_DRAG);

                        if(DRAG_MOVECLIPS == drag_mode)
                        {
                           UIRenderer.DrawStippledRectangle(px + shiftX + (drag_delta_ticks * pixPerTick),
                                                            py,
                                                            pw,
                                                            currentTrackSY,
                                                            2,
                                                            c32Clip
                                                            );
                        }
                        else if(DRAG_CLIPSTART == drag_mode)
                        {
                           UIRenderer.DrawStippledRectangle(px + shiftX + (drag_delta_ticks * pixPerTick),
                                                            py,
                                                            pw - (drag_delta_ticks * pixPerTick),
                                                            currentTrackSY,
                                                            2,
                                                            c32Clip
                                                            );
                        }
                        else if(DRAG_CLIPEND == drag_mode)
                        {
                           UIRenderer.DrawStippledRectangle(px + shiftX,
                                                            py,
                                                            pw + (drag_delta_ticks * pixPerTick),
                                                            currentTrackSY,
                                                            2,
                                                            c32Clip
                                                            );
                        }
                     }
                  } // if !bCull

                  // Next clip
                  clipIdx++;
               }
            }

            // Next track
            trackIdx++;
            py += currentTrackSY;
         }

         // // UI.PopScissors();
         sdvg_PopScissor();

         // Draw loop locators
         px = (tstate.loop_start - tickOffset) * pixPerTick;
         int c32LocTint = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_LOCATOR_ICON_TINT);
         int c32LocDragTint = app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_LOCATOR_ICON_DRAG_TINT);
         icon_locator_l.setShaderType((icon_locator_l.isMono() && lnf.b_icon_invert_mono) ? Icon.SHADER_INVERTCOLOR : 0);
         icon_locator_l.drawIconScaledC32(px + shiftX, 1,
                                          UI.icon_scaling, UI.icon_scaling,
                                          c32LocTint
                                          );
         if(DRAG_LOOPL == drag_mode)
         {
            px = (tstate.loop_start - tickOffset + drag_delta_ticks) * pixPerTick;
            icon_locator_l.drawIconScaledC32(px + shiftX, 1,
                                             UI.icon_scaling, UI.icon_scaling,
                                             c32LocDragTint
                                             );
         }

         px = (tstate.loop_end - tickOffset) * pixPerTick;
         icon_locator_r.setShaderType((icon_locator_r.isMono() && lnf.b_icon_invert_mono) ? Icon.SHADER_INVERTCOLOR : 0);
         icon_locator_r.drawIconScaledC32(px + shiftX - 16*UI.icon_scaling, 1,
                                          UI.icon_scaling, UI.icon_scaling,
                                          c32LocTint
                                          );
         if(DRAG_LOOPR == drag_mode)
         {
            px = (tstate.loop_end - tickOffset + drag_delta_ticks) * pixPerTick;
            icon_locator_r.drawIconScaledC32(px + shiftX - 16*UI.icon_scaling, 1,
                                             UI.icon_scaling, UI.icon_scaling,
                                             c32LocDragTint
                                             );
         }
      }

      sdvg_PopScissor();
      sdvg_DisableScissor();

      // glPopAttrib();

      if(replay.b_playing && maybe == tstate.b_follow)
         centerReplayOffset();
   }

   // <ui_kbd.png>
   protected method handlePatternKeyHome(boolean _bShift, boolean _bCtrl) {
      if(_bShift)
      {
         if(_bCtrl)
         {
            lazySelectGridCursorClips();
            incDecUsedPatternNrOfSelectedClips(1/*delta*/);
         }
         else
         {
            gotoStart();
         }
      }
      else if(_bCtrl)
      {
         lazySelectGridCursorClips();
         incDecPatternNrOfSelectedClips(4/*delta*/);
      }
      else
      {
         lazySelectGridCursorClips();
         incDecPatternNrOfSelectedClips(1/*delta*/);
      }
   }

   // <ui_kbd.png>
   protected method handlePatternKeyEnd(boolean _bShift, boolean _bCtrl) {
      if(_bShift)
      {
         if(_bCtrl)
         {
            lazySelectGridCursorClips();
            incDecUsedPatternNrOfSelectedClips(-1/*delta*/);
         }
         else
         {
            gotoLoopStart();
         }
      }
      else if(_bCtrl)
      {
         lazySelectGridCursorClips();
         incDecPatternNrOfSelectedClips(-4/*delta*/);
      }
      else
      {
         lazySelectGridCursorClips();
         incDecPatternNrOfSelectedClips(-1/*delta*/);
      }
   }

   // <ui_kbd.png>
   public virtual wantTriadKeyRepeat(Key _k) : boolean {
      switch(_k.code)
      {
         case VKEY_LEFT:
         case VKEY_RIGHT:
         case VKEY_UP:
         case VKEY_DOWN:
               return true;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {
      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          1         :   Select pipenode A (use lctrl-x z to switch between A and B)
          2         :   Select pipenode B
          a         :   Set clip length(s) to pattern length(s)
          d         :   Toggle pattern manager
          e         :   Toggle edge-selection mode
          f         :   Toggle multi-clip force-property-override mode
          l         :   Set left loop locator
          q         :   Create new audio track
          r         :   Set right loop locator
          s         :   Toggle scratchpad timeline
          t         :   Create new track (/pipe /node)
          u         :   Focus node name widget
          z         :   Switch between pipenodes A/B
          END       :   Global program change (master pipe, auto dev+ch A)
          HOME      :   Global program change (master pipe, auto dev+ch B)
          UP        :   Increase clip length(s)
          DOWN      :   Decrease clip length(s)
          LEFT      :   Move clip(s) left
          RIGHT     :   Move clip(s) right
"
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      // trace "xxx arr::onTriadKey: _k.pressed="+_k.pressed+" _k.code="+_k.code;
      int key = _k.pressed;
      boolean r = false;
      Integer minTicks;
      Integer maxTicks;

      loop(2) // first pass for raw keycode, second pass for unicode
      {
         // US (reference) keyboard layout (raw keycodes)
         switch(key)
         {
            case VKEY_LEFT:
               if(DRAG_NONE == drag_mode)
               {
                  if(!haveSelection())
                  {
                     selectClips(false/*bAllowToggle*/, false/*bAdd*/);
                     handleSelectionChanged();
                  }
                  if(haveSelection())
                  {
                     drag_mode = DRAG_MOVECLIPS;
                     drag_delta_ticks = 0;
                  }
               }
               if(DRAG_MOVECLIPS == drag_mode)
               {
                  drag_delta_ticks -= tstate.calcGridTicks();
                  b_drag_overlap = moveResizeClipsCheckOverlap(true/*bMove*/, false/*bEnd*/);
                  findSelectionMinMaxTicks(minTicks, maxTicks);
                  makeRegionVisible(minTicks + drag_delta_ticks, maxTicks + drag_delta_ticks);
                  redraw();
               }
               r = true;
               break;

            case VKEY_RIGHT:
               if(DRAG_NONE == drag_mode)
               {
                  if(!haveSelection())
                  {
                     selectClips(false/*bAllowToggle*/, false/*bAdd*/);
                     handleSelectionChanged();
                  }
                  if(haveSelection())
                  {
                     drag_mode = DRAG_MOVECLIPS;
                     drag_delta_ticks = 0;
                  }
               }
               if(DRAG_MOVECLIPS == drag_mode)
               {
                  drag_delta_ticks += tstate.calcGridTicks();
                  b_drag_overlap = moveResizeClipsCheckOverlap(true/*bMove*/, false/*bEnd*/);
                  findSelectionMinMaxTicks(minTicks, maxTicks);
                  makeRegionVisible(minTicks + drag_delta_ticks, maxTicks + drag_delta_ticks);
                  redraw();
               }
               r = true;
               break;

            case VKEY_DOWN:
               if(DRAG_NONE == drag_mode)
               {
                  if(!haveSelection())
                  {
                     selectClips(false/*bAllowToggle*/, false/*bAdd*/);
                     handleSelectionChanged();
                  }
                  if(haveSelection())
                  {
                     drag_mode = DRAG_CLIPEND;
                     drag_delta_ticks = 0;
                  }
               }
               if(DRAG_CLIPEND == drag_mode)
               {
                  drag_delta_ticks -= tstate.calcGridTicks();
                  b_drag_overlap = moveResizeClipsCheckOverlap(false/*bMove*/, true/*bEnd*/);
                  findSelectionMinMaxTicks(minTicks, maxTicks);
                  makeRegionVisible(minTicks + drag_delta_ticks, maxTicks + drag_delta_ticks);
                  redraw();
               }
               r = true;
               break;

            case VKEY_UP:
               if(DRAG_NONE == drag_mode)
               {
                  if(!haveSelection())
                  {
                     selectClips(false/*bAllowToggle*/, false/*bAdd*/);
                     handleSelectionChanged();
                  }
                  if(haveSelection())
                  {
                     drag_mode = DRAG_CLIPEND;
                     drag_delta_ticks = 0;
                  }
               }
               if(DRAG_CLIPEND == drag_mode)
               {
                  drag_delta_ticks += tstate.calcGridTicks();
                  b_drag_overlap = moveResizeClipsCheckOverlap(false/*bMove*/, true/*bEnd*/);
                  findSelectionMinMaxTicks(minTicks, maxTicks);
                  makeRegionVisible(minTicks + drag_delta_ticks, maxTicks + drag_delta_ticks);
                  redraw();
               }
               r = true;
               break;

            case 'e':
               toggleOrSetEdgeSelectionMode(maybe);
               r = true;
               break;

            case 'f':
               parent_form.toggleClipForceMultiAll();
               r = true;
               break;

            case 'l':
               setLeftLoopLocatorToEditOffset();
               r = true;
               break;

            case 'q':
               parent_form.handleCreateAudioTrack();
               r = true;
               break;

            case 'r':
               setRightLoopLocatorToEditOffset();
               r = true;
               break;

            case 's':
               toggleOrSetScratch(maybe);
               r = true;
               break;

            case 't':
               PagePipeMap pgPipeMap <= root_form.pg_pipemap;
               pgPipeMap.createNewTrack1(this/*recipient*/, false/*bCurrentPipe*/, maybe/*bShowAllNodeTypes*/);
               r = true;
               break;

            case 'a':
               setClipLengthsToPatternLengths();
               r = true;
               break;

            default:
               r = maybe; break;
         }

         if(true == r)
         {
            return true;
         }
         else if(maybe == r)
         {
            Global.Print("");
         }

         // see above
         key = _k.unicode;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onEndTriadKeyMode(Key _k) : boolean {
      // // trace "xxx onEndTriadKeyMode";
      if(DRAG_MOVECLIPS == drag_mode)
      {
         if(!b_drag_overlap)
         {
            tstate.undoAdd(clip_selection);
            moveResizeClips(true/*bMove*/, false/*bEnd*/, false/*bDuplicate*/, false/*bCloneSample*/);
            tstate.undoEnd(clip_selection);
            if(tstate.b_grid_cursor_mode)
            {
               drag_start_ticks += drag_delta_ticks;
               drag_end_ticks   += drag_delta_ticks;
               drag_start_ticks_sorted += drag_delta_ticks;
               drag_end_ticks_sorted   += drag_delta_ticks;
               tstate.edit_offset += drag_delta_ticks;
            }
         }
         drag_mode = DRAG_NONE;
         b_drag_overlap = false;
         redraw();
      }
      else if(DRAG_CLIPEND == drag_mode)
      {
         if(!b_drag_overlap)
         {
            tstate.undoAdd(clip_selection);
            moveResizeClips(false/*bMove*/, true/*bEnd*/, false/*bDuplicate*/, false/*bCloneSample*/);
            tstate.undoEnd(clip_selection);
         }
         drag_mode = DRAG_NONE;
         b_drag_overlap = false;
         redraw();
      }
   }

   // <ui_kbd.png>
   public virtual onKeyboardFocus() {
      compositeAll();
      return Control::onKeyboardFocus();
   }

   // <ui_kbd.png>
   public virtual onKeyboardFocusLost(boolean _bQuiet) {
      compositeAll();
      return Control::onKeyboardFocusLost(_bQuiet);
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {
      // // trace "xxx NA_TimelineData::onKey: _k.pressed="+_k.pressed+" _k.mod="+_k.mod;

      switch(_k.released)
      {
         case 'g':  // prevent RootForm from handling mmcForceGlobalEnd()
            return true;
      }

      switch(_k.pressed)
      {
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '0':
         case '.':
         case '-':
         case '/':
            if(_k.modNone())
            {
               editFirstSelectedClipCtl(true/*bWarpMouse*/, _k);
               return true;
            }
            break;

         case 91: // '[' (us), 'ue' (de)
            if(_k.modShift())
            {
               zoomOut(getPxForTickOffset(tstate.edit_offset));
               return true;
            }
            break;

         case 93: // ']' (us), 'ue' (de)
            if(_k.modShift())
            {
               zoomIn(getPxForTickOffset(tstate.edit_offset));
               return true;
            }
            else if(_k.modCtrl())
            {
               incTrackSizeY();
               return true;
            }
            break;

         case VKEY_PAGEUP:
            cycleClipEditMode(1);
            return true;

         case VKEY_PAGEDOWN:
            cycleClipEditMode(-1);
            return true;

         case '/':  // '-' (de)
            if(_k.modCtrl())
            {
               decTrackSizeY();
               return true;
            }
            break;

         case VKEY_RETURN:
            editFirstSelectedClip(_k.modShift()/*bEditSample*/);
            return true;

         case VKEY_INSERT:
            parent_form.handleInsertSilence(_k.modShift()/*bAllTracks*/);
            return true;

         case VKEY_DELETE:
            if(!tstate.b_grid_cursor_mode && !haveSelection())
            {
               tstate.undoAdd(clip_selection);
               tstate.deleteRange(tstate.b_show_marker ? 0 : 1, tstate.getNumTracks(),
                                  tstate.edit_offset, tstate.edit_offset + tstate.calcGridTicks(),
                                  true/*bMoveClips*/
                                  );
               tstate.undoEnd(clip_selection);
               redraw();
            }
            else if(tstate.b_grid_cursor_mode && _k.modShift() && !haveSelection())
            {
               int delStartTrackOld = drag_start_track;
               int delEndTrackOld = drag_end_track;
               // // expandGridCursorSelectionY();  // [25Jan2025] removed => delete/move on selected tracks only
               deleteSelection(true/*bMoveClips*/, false/*bMutedOnly*/);
               drag_start_track = delStartTrackOld;
               drag_end_track = delEndTrackOld;
               sortDragSelection();
            }
            else
            {
               deleteSelection(_k.modShift()/*bMoveClips*/, _k.modCtrl()/*bMutedOnly*/);
               selectNone();
            }
            return true;

         case 'a':
            if(_k.modCtrl())
            {
               if(_k.modShift())
                  selectNone();
               else
                  selectAll();
               return true;
            }
            else if(_k.modShiftOnly())
            {
               if(clip_selection.numElements >= 2*2 && null != getFirstSelectedMarkerClip())
                  selectClipsUnderMarker(false/*bIncludingMarkerClip*/);
               else
                  selectClipsUnderMarker(true/*bIncludingMarkerClip*/);
               return true;
            }
            break;

         case VKEY_UP:
            if(tstate.b_grid_cursor_mode)
            {
               if(_k.modCtrl())
               {
                  expandGridCursorSelectionY();
               }
               else
               {
                  moveGridCursorUp(_k.modShift()/*bAdd*/);
               }
               return true;
            }
            else
            {
               if(!_k.modCtrl())
               {
                  selectClipUp(_k.modShift()/*bAdd*/);
                  return true;
               }
               else if(!_k.modShift())
               {
                  if(haveSelection())
                  {
                     toggleExpandClipSelectionY(true/*bUp*/);
                  }
                  else
                  {
                     selectAllClipsAtEditOffset(1/*range*/);
                  }
                  return true;
               }
            }
            return false;

         case VKEY_DOWN:
            if(tstate.b_grid_cursor_mode)
            {
               if(_k.modCtrl())
               {
                  expandGridCursorSelectionY();
               }
               else
               {
                  moveGridCursorDown(_k.modShift()/*bAdd*/);
               }
               return true;
            }
            else
            {
               if(!_k.modCtrl())
               {
                  selectClipDown(_k.modShift()/*bAdd*/);
                  return true;
               }
               else if(!_k.modShift())
               {
                  if(haveSelection())
                  {
                     toggleExpandClipSelectionY(false/*bUp*/);
                  }
                  else
                  {
                     selectAllClipsAtEditOffset(1/*range*/);
                  }
                  return true;
               }
            }
            return false;

         case VKEY_LEFT:
            if(_k.modAlt())
            {
               if(_k.modCtrl())
               {
                  moveToPreviousMarker();
                  return true;
               }
            }
            else
            {
               if(tstate.b_grid_cursor_mode)
               {
                  if(_k.modCtrl())
                  {
                     if(_k.modShift())
                     {
                        moveGridCursorLeft(true/*bAdd*/);
                        if(0 != ((drag_end_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorLeft(true/*bAdd*/);
                        if(0 != ((drag_end_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorLeft(true/*bAdd*/);
                        if(0 != ((drag_end_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorLeft(true/*bAdd*/);
                     }
                     else
                     {
                        moveGridCursorLeft(false/*bAdd*/);
                        if(0 != ((drag_start_ticks_sorted / tstate.calcGridTicks()) % 4))
                           moveGridCursorLeft(false/*bAdd*/);
                        if(0 != ((drag_start_ticks_sorted / tstate.calcGridTicks()) % 4))
                           moveGridCursorLeft(false/*bAdd*/);
                        if(0 != ((drag_start_ticks_sorted / tstate.calcGridTicks()) % 4))
                           moveGridCursorLeft(false/*bAdd*/);
                     }
                     return true;
                  }
                  else
                  {
                     moveGridCursorLeft(_k.modShift()/*bAdd*/);
                     return true;
                  }
               }
               else
               {
                  // (note) lctrl-lshift-cursor is reserved for node navigation
                  if(_k.modCtrl())
                  {
                     if(!_k.modShift())
                     {
                        moveToPreviousMarker();
                        return true;
                     }
                  }
                  else
                  {
                     if(tstate.b_show_marker && _k.modNone() && isCursorOnMarkerTrack() &&
                        (clip_selection.numElements >= 1*2) &&
                        DoesSelectionContainMarkerClip(clip_selection)
                        )
                     {
                        reduceSelectionToFirstMarkerClip();
                        selectClipLeft(false/*bAdd*/, false/*bAllTracks*/);
                        return true;
                     }

                     if(_k.modNone())
                        selectClipFirstOrLeft();
                     else
                        selectClipLeft(_k.modShift()/*bAdd*/, false/*bAllTracks*/);
                     return true;
                  }
               }
            }
            return false;

         case VKEY_RIGHT:
            if(_k.modAlt())
            {
               if(_k.modCtrl())
               {
                  moveToNextMarker();
                  return true;
               }
            }
            else
            {
               if(tstate.b_grid_cursor_mode)
               {
                  if(_k.modCtrl())
                  {
                     if(_k.modShift())
                     {
                        moveGridCursorRight(true/*bAdd*/);
                        if(0 != ((drag_end_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorRight(true/*bAdd*/);
                        if(0 != ((drag_end_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorRight(true/*bAdd*/);
                        if(0 != ((drag_end_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorRight(true/*bAdd*/);
                     }
                     else
                     {
                        moveGridCursorRight(false/*bAdd*/);
                        if(0 != ((drag_start_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorRight(false/*bAdd*/);
                        if(0 != ((drag_start_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorRight(false/*bAdd*/);
                        if(0 != ((drag_start_ticks / tstate.calcGridTicks()) % 4))
                           moveGridCursorRight(false/*bAdd*/);
                     }
                     return true;
                  }
                  else
                  {
                     moveGridCursorRight(_k.modShift()/*bAdd*/);
                     return true;
                  }
               }
               else
               {
                  // (note) lctrl-lshift-cursor is reserved for node navigation
                  if(_k.modCtrl())
                  {
                     if(!_k.modShift())
                     {
                        moveToNextMarker();
                        return true;
                     }
                  }
                  else
                  {
                     if(tstate.b_show_marker && _k.modNone() && isCursorOnMarkerTrack() &&
                        (clip_selection.numElements >= 1*2) &&
                        DoesSelectionContainMarkerClip(clip_selection)
                        )
                     {
                        reduceSelectionToLastMarkerClip();
                        selectClipRight(false/*bAdd*/, false/*bAllTracks*/);
                        return true;
                     }

                     if(_k.modNone())
                        selectClipLastOrRight();
                     else
                        selectClipRight(_k.modShift()/*bAdd*/, false/*bAllTracks*/);
                     return true;
                  }
               }
            }
            return false;

         //    // (note) never reached:
         // // case VKEY_LCTRL:
         // //    trace "xxx VKEY_LCTRL";
         // //    if(DRAG_MOVECLIPS == drag_mode)
         // //    {
         // //       UI.ShowCursor(UIConstants.CURSOR_ADD);
         // //    }
         // //    break;

         case 'c':
            if(!_k.modShift())
            {
               if( _k.modCtrl() || (_k.modCmd() && UI.b_key_cmd_copy_paste) )
               {
                  lazySelectGridCursorClips();

                  copySelectedClipsToClipboard(false/*bCut*/);
                  return true;
               }
            }
            return false;

         case 'l':
            if(_k.modShift())
            {
               invertTrackLocks();
            }
            else if(_k.modCtrl())
            {
               clearTrackLocks();
            }
            else
            {
               toggleTrackLock();
            }
            return true;

         case 'q':
            if( _k.modNone() && tstate.b_grid_cursor_mode )
            {
               selectClips(false/*bAllowToggle*/, false/*bAdd*/);
               return false;  // let parent layer process edit mode selection key
            }
            if(_k.modCtrlOnly())
            {
               toggleMuteSelectedClips(false/*bSelectClips*/, false/*bSelectClipAtMouse*/, null/*evOrNull*/);
               return true;
            }
            if(_k.modCtrl() && _k.modShift())
            {
               // Query instances, samples, sample-peaks
               if(null != dlg_audio_liverec)
                  dlg_audio_liverec.handleQuery();
               return true;
            }
            break;

         case 'n':
            if(_k.modNone())
            {
               editNameOfFirstSelectedClip();
               return true;
            }
            else if(_k.modCtrl())
            {
               tstate.undoAdd(clip_selection);
               if(!tstate.b_grid_cursor_mode)
               {
                  drag_start_ticks = tstate.edit_offset;
                  drag_end_ticks   = tstate.edit_offset + tstate.calcGridTicks();
                  sortDragSelection();
               }
               createNewClips(true/*bAllocPattern*/,
                              _k.modShift()/*bAllocPatternSub*/,
                              true/*bAllowFindLastClip*/,
                              false/*bClonePattern*/,
                              true/*bAllowReplaceClips*/
                              );
               tstate.undoEnd(clip_selection);
               redraw();
               return true;
            }
            break;

         case 'w':
            if(_k.modCtrlOnly())
            {
               copySelectedClipsToClipboard(true/*bCut*/);
               return true;
            }
            else if( _k.modNone() && tstate.b_grid_cursor_mode )
            {
               tstate.undoAdd(clip_selection);
               createNewClips(false/*bAllocPattern*/,
                              false/*bAllocPatternSub*/,
                              false/*bAllowFindLastClip*/,
                              false/*bClonePattern*/,
                              false/*bAllowReplaceClips*/
                              );
               tstate.undoEnd(clip_selection);
               redraw();
               return false; // let parent layer process edit mode selection key
            }
            break;

         case 'r':
            if( _k.modNone() && (tstate.b_grid_cursor_mode || (NA_State.EDIT_MODE_RAZOR == tstate.edit_mode)) )
            {
               tstate.undoAdd(clip_selection);
               splitDragSelection();
               tstate.undoEnd(clip_selection);
               redraw();
               return false; // let parent layer process edit mode selection key
            }
            if(_k.modCtrl())
            {
               if(clip_selection.numElements >= 2*2 &&
                  areAllClipsUnderMarkerSelected(true/*bIncludingMarkerClip*/, true/*bRestoreSelection*/)
                  )
               {
                  // same as lshift-r when clips under marker are selected
                  cloneCurrentMarkerSection();
                  return true;
               }

               tstate.undoAdd(clip_selection);
               if(!tstate.b_grid_cursor_mode)
               {
                  drag_start_ticks = tstate.edit_offset;
                  drag_end_ticks   = tstate.edit_offset + tstate.calcGridTicks();
                  sortDragSelection();
               }
               createNewClips(true/*bAllocPattern*/,
                              _k.modShift()/*bAllocPatternSub*/,
                              true/*bAllowFindLastClip*/,
                              true/*bClonePattern*/,
                              true/*bAllowReplaceClips*/
                              );
               tstate.undoEnd(clip_selection);
               redraw();
               return true;
            }
            if(_k.modShiftOnly())
            {
               cloneCurrentMarkerSection();
               return true;
            }
            break;

         case 't':
            if(_k.modNone())
            {
               if(tstate.b_grid_cursor_mode)
               {
                  toggleMuteDragSelection(); // handles undo
                  redraw();
                  return false; // let parent layer process edit mode selection key
               }
               else if(haveSelection() && (NA_State.EDIT_MODE_MUTE == tstate.edit_mode))
               {
                  toggleMuteSelectedClips(false/*bSelectClips*/, false/*bSelectClipAtMouse*/, null/*ev*/);
                  return true;
               }
            }
            break;

         case 'v':
            if( _k.modCtrl() || (_k.modCmd() && UI.b_key_cmd_copy_paste) )
            {
               pasteClipboard(_k.modShift()/*bInsertSilence*/);
               return true;
            }
            break;

         case 'g':
            if(_k.modCtrl())
            {
               if(_k.modShift())
               {
                  if(SysEx.IsAudioConnected())
                  {
                     f_audio_liverec.handleRecord();
                  }
                  else
                  {
                     Global.Warning("record: audio process not connected");
                  }
               }
               else
               {
                  if(SysEx.IsAudioConnected())
                  {
                     f_audio_liverec.handleClear();
                     f_audio_liverec.handleRecord();
                  }
                  else
                  {
                     Global.Warning("clear sample + record: audio process not connected");
                  }
               }
            }
            else
            {
               lazySelectGridCursorClips();
               showComboBoxPopupPatternNrOrSampleDialog(true/*bWarpMouse*/);
            }
            return true;

         case VKEY_HOME:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyEnd(_k.modShift(), _k.modCtrl());
            else
               handlePatternKeyHome(_k.modShift(), _k.modCtrl());
            return true;

         case VKEY_END:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyHome(_k.modShift(), _k.modCtrl());
            else
               handlePatternKeyEnd(_k.modShift(), _k.modCtrl());
            return true;

         case 'z':  // de:y
            if(_k.modShift())
            {
               if(tstate.b_grid_cursor_mode)
               {
                  toggleExpandGridCursorSelectionY();
               }
               else
               {
                  // e.g. select all clips below marker
                  toggleExpandClipSelectionY(true/*bUp*/);
               }
               return true;
            }
            else if(_k.modAlt())
            {
               // (note) same shortcut as in Davinci Resolve
               if(!haveSelection() || getNumSelectedTracks() >= 2)
                  selectClipsAtEditOffset(999999/*range*/, grid_cursor_track_hint);
               else
                  selectAllClipsAtEditOffset(999999/*range*/);
               return true;
            }
            break;

         case 'x':
            if(_k.modNone())
            {
               toggleOrSetGridCursorMode(maybe/*bSet=toggle*/, true/*bUpdateSelection*/, true/*bVerbose*/);
               return true;
            }
            break;

         case VKEY_SPACE:
            if(_k.modShift())
            {
               if(!replay.b_playing)
                  parent_form.startReplay();
               else
                  queuePlayOffset(tstate.edit_offset);
               return true;
            }
            return false; // let parent form process replay start/stop
      }

      // // // switch(_k.released)
      // // // {
      // // //    case VKEY_LCTRL:
      // // //       selectCursorByEditMode(true/*bForce*/);
      // // //       break;
      // // // }

      return Control::onKey(_k);
   }

   // <ui_mouse.png>
   public virtual onMouseLeave(MouseEvent _ev) : boolean {
      UI.ShowCursor(UIConstants.CURSOR_NORMAL);
   }

   // <ui_mouse.png>
   public virtual onMouseEnter(MouseEvent _ev) : boolean {
      selectCursorByEditMode(true/*bForce*/);
      grabKeyboardFocus();
   }

   // <ui_mouse.png>
   public virtual isMouseFocusLocked() : boolean {
      return UI.b_mouse_grab;
   }

   // <ui_mouse.png>
   public virtual wantOnMouseClickAfterOnMouseWasHandled() : boolean {
      return true;
   }

   // <ui_mouse.png>
   public virtual onMouse(MouseEvent _ev) : boolean {

      if(_ev.isWheel())
      {
         if(_ev.wheelUp())
         {
            if(VMOD_LSHIFT == UI.GetKeyMod())
            {
               parent_form.scrollLeft();
            }
            else if(VMOD_LCTRL == UI.GetKeyMod())
            {
               incDecPatternNrOfSelectedClips(4);
            }
            else if((VMOD_LCTRL|VMOD_LSHIFT) == UI.GetKeyMod())
            {
               if(!haveSelection() || isFirstSelectedClipAudio())
                  incTrackSizeY();
               else
                  incDecPatternNrOfSelectedClips(1);
            }
            else
            {
               zoomIn(_ev.mouse_rel_x);
            }
         }
         else if(_ev.wheelDown())
         {
            if(VMOD_LSHIFT == UI.GetKeyMod())
            {
               parent_form.scrollRight();
            }
            else if(VMOD_LCTRL == UI.GetKeyMod())
            {
               incDecPatternNrOfSelectedClips(-4);
            }
            else if((VMOD_LCTRL|VMOD_LSHIFT) == UI.GetKeyMod())
            {
               if(!haveSelection() || isFirstSelectedClipAudio())
                  decTrackSizeY();
               else
                  incDecPatternNrOfSelectedClips(-1);
            }
            else
            {
               zoomOut(_ev.mouse_rel_x);
            }
         }
      }
      else
      {
         int loopHandleNr = isMouseNearLoopLocatorHandle(_ev);
         if(0 != loopHandleNr)
         {
            UI.ShowCursor(UIConstants.CURSOR_MOVEX);
         }
         else
         {
            selectCursorByEditMode(true/*bForce*/);

            if(NA_State.EDIT_MODE_SELECT == tstate.edit_mode)
            {
               Integer trackGID;
               Integer clipUID;
               if(isMouseNearClip(_ev, maybe/*bEnd*/, trackGID, clipUID))
               {
                  UI.ShowCursor(UIConstants.CURSOR_MOVEX);
               }
               else
               {
                  selectCursorByEditMode(true/*bForce*/);
               }
            }
            else if(NA_State.EDIT_MODE_RAZOR == tstate.edit_mode)
            {
               int oldEditOffset = tstate.edit_offset;
               setEditOffsetToPx(_ev.mouse_rel_x);
               if(tstate.edit_offset != oldEditOffset)
                  compositeAll();
            }
         }
      }

      return true;
   }

   // <ui_mouse.png>
   public virtual onMouseClick(MouseEvent _ev) : boolean {
      UI.SetKeyboardFocus(this);

      if(null != parent_node)
      {
         if(_ev.mouse_rel_y < GetTopSY())
         {
            int ticksAtPx;

            if(VMOD_LSHIFT == UI.GetKeyMod())
            {
               queuePlayOffsetAtEv(_ev);
               return true;
            }

            if(UI.GetKeyMod() == VMOD_LCTRL)
            {
               // Set left loop marker
               ticksAtPx = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
               tstate.undoAdd(clip_selection);
               tstate.setLoopRange(ticksAtPx, tstate.loop_end);
               tstate.undoEnd(clip_selection);

               Global.Print("Loop range is ("+tstate.loop_start+";"+tstate.loop_end+") ticks");

               redraw();
               return true;
            }
            else if(UI.GetKeyMod() == VMOD_LALT)
            {
               // Set right loop marker
               ticksAtPx = getSelectionGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
               tstate.undoAdd(clip_selection);
               tstate.setLoopRange(tstate.loop_start, ticksAtPx);
               tstate.undoEnd(clip_selection);

               Global.Print("Loop range is ("+tstate.loop_start+";"+tstate.loop_end+") ticks");

               redraw();
               return true;
            }

            if(NA_State.EDIT_MODE_ERASE == tstate.edit_mode)
            {
               selectNone();
               if(tstate.getNumTracks() > 0)
               {
                  drag_start_track_sorted = 0;
                  if(!tstate.b_show_marker)
                     drag_start_track_sorted++;
                  drag_end_track_sorted   = tstate.getNumTracks() - 1;
                  if(tstate.b_show_marker || (drag_end_track_sorted > 0))
                  {
                     drag_start_ticks_sorted = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
                     drag_end_ticks_sorted   = drag_start_ticks_sorted + tstate.calcDefaultLenTicks();
                     deleteSelection(false/*bMoveClips*/, false/*bMutedOnly*/);
                  }
                  selectNone();
               }
               setEditOffsetToPx(_ev.mouse_rel_x);
               return true;
            }

            if(NA_State.EDIT_MODE_MUTE == tstate.edit_mode)
            {
               selectNone();
               // // if(tstate.getNumTracks() > 0)
               // // {
               // //    drag_start_track_sorted = 0;
               // //    drag_end_track_sorted   = tstate.getNumTracks() - 1;
               // //    drag_start_ticks_sorted = getGridAlignedTickOffsetForPx(_ev.mouse_rel_x);
               // //    drag_end_ticks_sorted   = drag_start_ticks_sorted + tstate.calcDefaultLenTicks();
               // //    toggleMuteSelectedClips(true/*bSelectClips*/, false/*bSelectClipAtMouse*/, null/*MouseEvent*/);
               // //    selectNone();
               // // }
               setEditOffsetToPx(_ev.mouse_rel_x);
               return true;
            }

            if(NA_State.EDIT_MODE_RAZOR == tstate.edit_mode)
            {
               selectNone();
               setEditOffsetToPx(_ev.mouse_rel_x);
               if(tstate.getNumTracks() > 0)
               {
                  splitAtEditOffset(-1/*bAllTracks*/);
               }
               return true;
            }
         } // if y < GetTopSY()

         if(VMOD_LSHIFT == UI.GetKeyMod())
         {
            if(haveSelection())
            {
               extendSelectionToEv(_ev);
               return true;
            }
         }

         setEditOffsetToPx(_ev.mouse_rel_x);
         compositeAll();

         if(_ev.isRightButton())
         {
            // Edit clip sequence
            selectNone();
            selectClipAtEv(_ev, false/*bAllowToggle*/, (VMOD_LCTRL == UI.GetKeyMod())/*bAdd*/);
            editFirstSelectedClip(false/*bEditSample*/);
            return true;
         }
         else if(_ev.isMiddleButton())
         {
            // Edit "audio pattern" sample in Eureka
            selectNone();
            selectClipAtEv(_ev, false/*bAllowToggle*/, (VMOD_LCTRL == UI.GetKeyMod())/*bAdd*/);
            editFirstSelectedClip(true/*bEditSample*/);
            return true;
         }

         if(tstate.getNumTracks() > 0)
         {
            if( NA_State.EDIT_MODE_SELECT == tstate.edit_mode || NA_State.EDIT_MODE_DRAW == tstate.edit_mode )
            {
               // Select clip at mouse
               if(_ev.mouse_rel_y < GetTopSY())
               {
                  selectNone();
               }
               else
               {
                  selectClipAtEv(_ev,
                                 (false/*STConfig.b_arranger_toggle_selection*/ || (VMOD_LCTRL == UI.GetKeyMod()))/*bAllowToggle*/,
                                 (VMOD_LCTRL == UI.GetKeyMod())/*bAdd*/
                                 );
               }
               redraw();
            }
            else if(NA_State.EDIT_MODE_ERASE == tstate.edit_mode)
            {
               if(haveSelection() && isMouseOverSelectionClip(_ev))
               {
                  // Delete selected clip(s)
                  deleteSelection(false/*bMoveClips*/, false/*bMutedOnly*/);
               }
               else
               {
                  if((DRAG_SELECT == drag_mode) || b_allow_empty_selection)
                  {
                     selectClips(false/*bAllowToggle*/, false/*bAdd*/);
                     if(!haveSelection())
                     {
                        // No clips in selected area, delete empty space and move clips
                        deleteDragSelectEmptySpace();
                     }
                  }
                  else
                  {
                     // Select+delete single clip
                     selectNone();
                     if(_ev.mouse_rel_y >= GetTopSY())
                     {
                        selectClipAtEv(_ev, false/*bAllowToggle*/, false/*bAdd*/);
                        deleteSelection(false/*bMoveClips*/, false/*bMutedOnly*/);
                     }
                  }
               }
               selectNone();
            }
            else if(NA_State.EDIT_MODE_MUTE == tstate.edit_mode)
            {
               if(VMOD_LCTRL == UI.GetKeyMod())
               {
                  selectClipAtEv(_ev, true/*bAllowToggle*/, true/*bAdd*/);
               }
               else if(haveSelection() && isMouseOverSelectionClip(_ev))
               {
                  // trace "xxx MUTE: toggleMuteSelectedClips";
                  toggleMuteSelectedClips(false/*bSelectClips*/, false/*bSelectClipAtMouse*/, null/*MouseEvent*/);
               }
               else
               {
                  // Toggle mute clip under mouse
                  // trace "xxx MUTE: toggleMute clip under mouse";
                  selectNone();
                  toggleMuteSelectedClips(false/*bSelectClips*/, true/*bSelectClipAtMouse*/, _ev);
                  selectNone();
               }
            }
            else if(NA_State.EDIT_MODE_RAZOR == tstate.edit_mode)
            {
               selectNone();
               splitAtEditOffset(getTrackIndexAtPy(_ev.mouse_rel_y));
               return true;
            }
            else
            {
               selectNone();
            }
         }
         else
         {
            selectNone();
         }

         return true;
      }

      return true;
   }

   // <ui_mouse.png>
   public virtual onMouseDoubleClick(MouseEvent _ev) : boolean {

      // // trace "xxx onMouseDoubleClick";

      // // // showBlockStartIndicatorForMouseX(-1);
      // // // showBlockEndIndicatorForMouseX(-1);
      // // // showBlockStartValueIndicatorForMouseY(-1);

      selectNone();

      if(0 == UI.GetKeyMod())
      {
         setEditOffsetToPx(_ev.mouse_rel_x);

         if(!replay.b_playing)
            parent_form.startReplay();

         queuePlayOffsetAtEv(_ev);

         return true;
      }


      // (todo) edit clip node in select mode

      // (todo) remove this (lctrl-click already used to set loop start marker)
      // // if(VMOD_LCTRL == UI.GetKeyMod())
      // // {
      // //    if(NA_State.EDIT_MODE_SELECT == tstate.edit_mode)
      // //    {
      // //       // Select clip(s) within default length
      // //       setDragStartEndFromDblClickEv(_ev);
      // //       selectClips(false/*bAllowToggle*/, false/*bAdd*/);
      // //       b_allow_empty_selection = true;
      // //       redraw();
      // //    }
      // //    else if(NA_State.EDIT_MODE_DRAW == tstate.edit_mode)
      // //    {
      // //       // Create new clip(s) with default length
      // //       setDragStartEndFromDblClickEv(_ev);
      // //       tstate.undoAdd(clip_selection);
      // //       createNewClips();
      // //       tstate.undoEnd(clip_selection);
      // //       redraw();
      // //    }
      // // }

      compositeAll();
      return true;
   }

   // <ui_mouse.png>
   public virtual onMouseBeginDrag(MouseEvent _dragStart, MouseEvent _ev) : boolean {

      Integer trackGID;
      Integer clipUID;

      b_drag_top = (_ev.mouse_rel_y < GetTopSY());

      if(b_drag_top)
      {
         int loopHandleNr = isMouseNearLoopLocatorHandle(_dragStart);

         if(1 == loopHandleNr)
         {
            // Drag left loop marker
            drag_mode = DRAG_LOOPL;
            drag_start_ticks = tstate.loop_start;
            drag_delta_ticks = 0;
            return true;
         }
         else if(2 == loopHandleNr)
         {
            // Drag right loop marker
            drag_mode = DRAG_LOOPR;
            drag_start_ticks = tstate.loop_end;
            drag_delta_ticks = 0;
            return true;
         }

         selectNone();
      }

      if(_ev.isRightButtonDown())
      {
         if(abs(_dragStart.mouse_rel_x - _ev.mouse_rel_x) >= abs(_dragStart.mouse_rel_y - _ev.mouse_rel_y))
         {
            drag_start_tick_offset = tstate.view_offset;
            drag_mode = DRAG_SCROLLX;
         }
         else
         {
            drag_mode = DRAG_SCROLLY;
            drag_start_mouse_y = _dragStart.mouse_rel_y;
            ScrollPane sp <= parent_form.sp_data;
            drag_start_view_offset_y = sp.getViewOffsetY();
         }
         UI.GrabMouse();
         Global.Print("RMB scroll begin");
         return true;
      }
      else if(tstate.getNumTracks() > 0)
      {
         b_drag_overlap = false;

         if(NA_State.EDIT_MODE_SELECT == tstate.edit_mode)
         {
            b_allow_empty_selection = false;

            setDragStartFromEv(_dragStart);

            if(haveSelection())
            {
               if(isMouseNearSelectionClip(_dragStart, true/*bEnd*/))
               {
                  drag_mode = DRAG_CLIPEND;
               }
               else if(isMouseNearSelectionClip(_dragStart, false/*bEnd*/))
               {
                  drag_mode = DRAG_CLIPSTART;
               }
               else
               {
                  if(isMouseNearClip(_dragStart, true/*bEnd*/, trackGID, clipUID))
                  {
                     clip_selection.add(trackGID);
                     clip_selection.add(clipUID);
                     handleSelectionChanged();
                     drag_mode = DRAG_CLIPEND;
                     redraw();
                  }
                  else if(isMouseNearClip(_dragStart, false/*bEnd*/, trackGID, clipUID))
                  {
                     clip_selection.add(trackGID);
                     clip_selection.add(clipUID);
                     handleSelectionChanged();
                     drag_mode = DRAG_CLIPSTART;
                     redraw();
                  }
                  else if(haveClipAtEv(_dragStart, true/*bMustBeSelected*/))
                  {
                     drag_mode = DRAG_MOVECLIPS;
                  }
                  else
                  {
                     drag_mode = DRAG_SELECT;
                     selectNone();
                  }
               }
               drag_delta_ticks = 0;
               selectCursorByEditMode(true/*bForce*/);  // show MOVE cursor
            }
            else
            {
               if(isMouseNearClip(_dragStart, true/*bEnd*/, trackGID, clipUID))
               {
                  clip_selection.add(trackGID);
                  clip_selection.add(clipUID);
                  handleSelectionChanged();
                  drag_mode = DRAG_CLIPEND;
                  redraw();
               }
               else if(isMouseNearClip(_dragStart, false/*bEnd*/, trackGID, clipUID))
               {
                  clip_selection.add(trackGID);
                  clip_selection.add(clipUID);
                  handleSelectionChanged();
                  drag_mode = DRAG_CLIPSTART;
                  redraw();
               }
               else
               {
                  drag_mode = DRAG_SELECT;
                  selectNone();
               }
            }

            return true;
         }
         else if(NA_State.EDIT_MODE_DRAW == tstate.edit_mode)
         {
            selectNone();
            drag_mode = DRAG_NEWCLIP;

            setDragStartFromEv(_dragStart);
            return true;
         }
         else if(NA_State.EDIT_MODE_MUTE == tstate.edit_mode)
         {
            selectNone();
            drag_mode = DRAG_MUTE;

            setDragStartFromEv(_dragStart);
            return true;
         }
      }

      return false;
   }

   // <ui_mouse.png>
   public virtual onMouseDrag(MouseEvent _lastEv, MouseEvent _currentEv) : boolean {
      // // trace "xxx onMouseDrag: mouse_grab_relx="+UI.mouse_grab_relx+" currentEv.mouse_rel_x="+_currentEv.mouse_rel_x;

      int oldDragDelta = drag_delta_ticks;

      if(DRAG_SCROLLX == drag_mode)
      {
         // // trace "xxx DRAG_SCROLL: mouse_grab_relx="+UI.mouse_grab_relx;
         handleDragScrollX();
         return true;
      }
      else if(DRAG_SCROLLY == drag_mode)
      {
         // // trace "xxx DRAG_SCROLLY: mouse_grab_rely="+UI.mouse_grab_rely;
         handleDragScrollY(_currentEv.mouse_rel_y);
         return true;
      }
      else if((DRAG_SELECT == drag_mode) || (DRAG_MUTE == drag_mode))
      {
         setDragEndFromEv(_currentEv);

         return true;
      }
      else if(DRAG_CLIPSTART == drag_mode)
      {
         setDragDeltaFromEv(_currentEv);
         b_drag_overlap = false;
         moveResizeClipsClipDelta(false/*bMove*/, false/*bEnd*/);
         b_drag_overlap |= moveResizeClipsCheckOverlap(false/*bMove*/, false/*bEnd*/);

         if(drag_delta_ticks != oldDragDelta)
            redraw();

         return true;
      }
      else if(DRAG_CLIPEND == drag_mode)
      {
         setDragDeltaFromEv(_currentEv);
         b_drag_overlap = false;
         moveResizeClipsClipDelta(false/*bMove*/, true/*bEnd*/);
         b_drag_overlap |= moveResizeClipsCheckOverlap(false/*bMove*/, true/*bEnd*/);

         if(drag_delta_ticks != oldDragDelta)
            redraw();

         return true;
      }
      else if(DRAG_MOVECLIPS == drag_mode)
      {
         setDragDeltaFromEv(_currentEv);
         b_drag_overlap = false;
         moveResizeClipsClipDelta(true/*bMove*/, false/*bEnd*/);
         b_drag_overlap |= moveResizeClipsCheckOverlap(true/*bMove*/, false);

         if(drag_delta_ticks != oldDragDelta)
            redraw();

         return true;
      }
      else if(DRAG_NEWCLIP == drag_mode)
      {
         setDragEndFromEv(_currentEv);

         b_drag_overlap = checkNewClipAnyClipsWithinRange();

         return true;
      }
      else if((DRAG_LOOPL == drag_mode) || (DRAG_LOOPR == drag_mode))
      {
         setDragDeltaFromEv(_currentEv);

         if(drag_delta_ticks != oldDragDelta)
            redraw();

         return true;
      }
   }

   // <ui_mouse.png>
   public virtual onMouseEndDrag(MouseEvent _ev) {

      if( (DRAG_SCROLLX == drag_mode) || (DRAG_SCROLLY == drag_mode) )
      {
         UI.UngrabMouse();
         Global.Print("RMB scroll end");
      }
      else if(DRAG_SELECT == drag_mode)
      {
         IntArray oldSelection = clip_selection;

         selectClips(false/*bAllowToggle*/, false/*bAdd*/);

         if(0 == clip_selection.numElements)
            b_allow_empty_selection = true; // keep on showing selection (delete silence)
      }
      else if(DRAG_MOVECLIPS == drag_mode)
      {
         if(!b_drag_overlap)
         {
            tstate.undoAdd(clip_selection);
            moveResizeClips(true/*bMove*/,
                            false/*bEnd*/,
                            (UI.GetKeyMod() & VMOD_LCTRL)/*bDuplicate*/,
                            (UI.GetKeyMod() & VMOD_LSHIFT)/*bCloneSample*/
                            );
            tstate.undoEnd(clip_selection);
         }
         redraw();
      }
      else if(DRAG_CLIPSTART == drag_mode)
      {
         if(!b_drag_overlap)
         {
            tstate.undoAdd(clip_selection);
            moveResizeClips(false/*bMove*/, false/*bEnd*/, false/*bDuplicate*/, false/*bCloneSample*/);
            tstate.undoEnd(clip_selection);
         }
         redraw();
      }
      else if(DRAG_CLIPEND == drag_mode)
      {
         if(!b_drag_overlap)
         {
            tstate.undoAdd(clip_selection);
            moveResizeClips(false/*bMove*/, true/*bEnd*/, false/*bDuplicate*/, false/*bCloneSample*/);
            tstate.undoEnd(clip_selection);
         }
         redraw();
      }
      else if(DRAG_NEWCLIP == drag_mode)
      {
         tstate.undoAdd(clip_selection);
         createNewClips((UI.GetKeyMod() & VMOD_LCTRL)/*bAllocPattern*/,
                        (UI.GetKeyMod() & VMOD_LSHIFT)/*bAllocPatternSub*/,
                        false/*bAllowFindLastClip*/,
                        false/*bClonePattern*/,
                        false/*bAllowReplaceClips*/
                        );
         tstate.undoEnd(clip_selection);
      }
      else if(DRAG_MUTE == drag_mode)
      {
         // Just select
         // // trace "xxx DRAG_MUTE select clips";
         selectClips(false/*bAllowToggle*/, false/*bAdd*/);
         b_allow_empty_selection = false;
      }
      else if(DRAG_LOOPL == drag_mode)
      {
         tstate.undoAdd(clip_selection);
         tstate.setLoopRange(drag_start_ticks + drag_delta_ticks, tstate.loop_end);
         tstate.undoEnd(clip_selection);
      }
      else if(DRAG_LOOPR == drag_mode)
      {
         tstate.undoAdd(clip_selection);
         tstate.setLoopRange(tstate.loop_start, drag_start_ticks + drag_delta_ticks);
         tstate.undoEnd(clip_selection);
      }

      drag_mode = DRAG_NONE;
      redraw();
      compositeAll();
      selectCursorByEditMode(true/*bForce*/);
   }

   // <ui_mouse.png>
   public virtual onMouseCancelDrag(MouseEvent _ev) {
      // (todo) undo
      if( (DRAG_SCROLLX == drag_mode) || (DRAG_SCROLLY == drag_mode) )
         UI.UngrabMouse();

      drag_mode = DRAG_NONE;
      selectCursorByEditMode(true/*bForce*/);
      redraw();
   }

   // <ui_mouse.png>
   public virtual blockMouseDrag(MouseEvent _ev) : boolean {
      return false;
   }

   // <ui_mouse.png>
   public virtual onMouseHold(MouseEvent _startEv) : boolean {
      selectNone();
      selectClipAtEv(_startEv, false/*bAllowToggle*/, false/*bAdd*/);
      showComboBoxPopupPatternNrOrSampleDialog(false/*bWarpMouse*/);
      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      StringAction *sac;
      IntAction *iac;

      // // trace "[>>>] NA_TimelineData::consumeAction: acName="+acName+" ap="+#(ap);

      switch(@(ap))
      {
         case @(cmp_pattern_nr):
            if(ComboBoxPopup.ACTION_OPTIONSELECTED == acName)
            {
               iac <= _action;
               if(isFirstSelectedClipAudio())
                  updateAudioSmpUIDOfSelectedClipsByFilteredSampleIndex(iac.getIntValue());
               else
                  updatePatternNrOfSelectedClips(cmp_lut.get(iac.getIntValue()));
            }
            UI.SetKeyboardFocus(this);
            return true;

         case @(root_form.pg_pipemap.dlg_new_track):
            if(NewTrackDialog.ACTION_CREATE_NEW_TRACK == acName)
            {
               PagePipeMap pgPipeMap <= root_form.pg_pipemap;
               pgPipeMap.createNewTrack2();
               parent_form.parent_editor.scanPipeNodes();
               parent_form.updateTrackForms();
            }
            else
            {
               Global.Debug("NewTrackDialog was canceled.");
            }
            return true;
      }

      return Control::consumeAction(_action);
   }

}
