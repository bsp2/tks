// ----
// ---- file   : Matrix1000.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2016-2023 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----          also see: <http://wolzow.mindworks.ee/analog/m1k-midi-spec.htm>
// ----
// ---- changed: 02Feb2016, 03Feb2016, 06Feb2016, 07Feb2016, 08Feb2016, 11Feb2016, 09May2017
// ----          04Jan2018, 07Mar2018, 26Jan2019, 01Oct2022, 11Feb2023
// ----
// ----
// ----
module MMatrix1000;

use namespace ui;
use namespace st2;


// <class.png>
class Matrix1000_Defs {
   define int OFF_PATCH_NAME        =   0;
   define int OFF_KEYBOARD_MODE     =   8;
   define int OFF_DCO1_INIT_FREQ    =   9;
   define int OFF_DCO1_INIT_SHAPE   =  10;
   define int OFF_DCO1_INIT_PW      =  11;
   define int OFF_DCO1_FIXMOD       =  12;  // Bit0=Lever 1  Bit1=Vibrato
   define int OFF_DCO1_WAVE_ENABLE  =  13;  // Bit0=Pulse  Bit1=Wave
   define int OFF_DCO2_INIT_FREQ    =  14;
   define int OFF_DCO2_INIT_SHAPE   =  15;
   define int OFF_DCO2_INIT_PW      =  16;
   define int OFF_DCO2_FIXMOD       =  17;  // Bit0=Lever 1  Bit1=Vibrato
   define int OFF_DCO2_WAVE_ENABLE  =  18;  // Bit0=Pulse  Bit1=Wave  Bit2=Noise
   define int OFF_DCO2_DETUNE       =  19;
   define int OFF_MIX               =  20;
   define int OFF_DCO1_FIXMOD_2     =  21;  // Bit0=Portamento  Bit1=Not used
   define int OFF_DCO1_CLICK        =  22;
   define int OFF_DCO2_FIXMOD_2     =  23;  // Bit0=Portamento  Bit1=Keyboard
   define int OFF_DCO2_CLICK        =  24;
   define int OFF_DCO_SYNC          =  25;
   define int OFF_VCF_INIT_FREQ     =  26;
   define int OFF_VCF_INIT_RES      =  27;
   define int OFF_VCF_FIXMOD        =  28;  // Bit0=Lever 1  Bit1=Vibrato
   define int OFF_VCF_KEYMOD        =  29;  // Bit0=Portamento  Bit1=Keyboard
   define int OFF_VCF_FM_INIT_AMT   =  30;
   define int OFF_VCA1_INIT_AMT     =  31;
   define int OFF_PORTA_INIT_RATE   =  32;
   define int OFF_LAG_MODE          =  33;  // 0=Constant Speed 1=Constant Time 2,3=Exponential
   define int OFF_PORTA_LEGATO      =  34;
   define int OFF_LFO1_INIT_SPEED   =  35;
   define int OFF_LFO1_TRIG         =  36;  // 0=No Trigger  1=Single Trigger  2=Multi Trigger  3=External Trigger
   define int OFF_LFO1_LAG          =  37;
   define int OFF_LFO1_SHAPE        =  38;
   define int OFF_LFO1_RETRIG       =  39;
   define int OFF_LFO1_SMPSRC       =  40;
   define int OFF_LFO1_INIT_AMP     =  41;
   define int OFF_LFO2_INIT_SPEED   =  42;
   define int OFF_LFO2_TRIG         =  43;  // 0=No Trigger  1=Single Trigger  2=Multi Trigger  3=External Trigger
   define int OFF_LFO2_LAG          =  44;
   define int OFF_LFO2_SHAPE        =  45;
   define int OFF_LFO2_RETRIG       =  46;
   define int OFF_LFO2_SMPSRC       =  47;
   define int OFF_LFO2_INIT_AMP     =  48;
   define int OFF_ENV1_TRIG_MODE    =  49;  // Bit0=Reset  Bit1=Multi Trigger  Bit2=External Trigger
   define int OFF_ENV1_INIT_DELAY   =  50;
   define int OFF_ENV1_INIT_ATTACK  =  51;
   define int OFF_ENV1_INIT_DECAY   =  52;
   define int OFF_ENV1_SUSTAIN      =  53;
   define int OFF_ENV1_INIT_RELEASE =  54;
   define int OFF_ENV1_INIT_AMP     =  55;
   define int OFF_ENV1_LFO_TRIG     =  56;  // Bit0=Gated  Bit1=LFO Trigger
   define int OFF_ENV1_MODE         =  57;  // Bit0=DADR Mode  Bit1=Freerun
   define int OFF_ENV2_TRIG_MODE    =  58;  // Bit0=Reset  Bit1=Multi Trigger  Bit2=External Trigger
   define int OFF_ENV2_INIT_DELAY   =  59;
   define int OFF_ENV2_INIT_ATTACK  =  60;
   define int OFF_ENV2_INIT_DECAY   =  61;
   define int OFF_ENV2_SUSTAIN      =  62;
   define int OFF_ENV2_INIT_RELEASE =  63;
   define int OFF_ENV2_INIT_AMP     =  64;
   define int OFF_ENV2_LFO_TRIG     =  65;  // Bit0=Gated  Bit1=LFO Trigger
   define int OFF_ENV2_MODE         =  66;  // Bit0=DADR Mode  Bit1=Freerun
   define int OFF_ENV3_TRIG_MODE    =  67;  // Bit0=Reset  Bit1=Multi Trigger  Bit2=External Trigger
   define int OFF_ENV3_INIT_DELAY   =  68;
   define int OFF_ENV3_INIT_ATTACK  =  69;
   define int OFF_ENV3_INIT_DECAY   =  70;
   define int OFF_ENV3_SUSTAIN      =  71;
   define int OFF_ENV3_INIT_RELEASE =  72;
   define int OFF_ENV3_INIT_AMP     =  73;
   define int OFF_ENV3_LFO_TRIG     =  74;  // Bit0=Gated  Bit1=LFO Trigger
   define int OFF_ENV3_MODE         =  75;  // Bit0=DADR Mode  Bit1=Freerun
   define int OFF_TRK_SRC           =  76;
   define int OFF_TRK_P1            =  77;
   define int OFF_TRK_P2            =  78;
   define int OFF_TRK_P3            =  79;
   define int OFF_TRK_P4            =  80;
   define int OFF_TRK_P5            =  81;
   define int OFF_RAMP1_RATE        =  82;
   define int OFF_RAMP1_MODE        =  83;  //  0=Single Trigger  1=Multi Trigger  2=External Trigger  3=External Gated
   define int OFF_RAMP2_RATE        =  84;
   define int OFF_RAMP2_MODE        =  85;  //  0=Single Trigger  1=Multi Trigger  2=External Trigger  3=External Gated
   define int OFF_DCO1_FREQ_LFO1    =  86;
   define int OFF_DCO1_PW_LFO2      =  87;
   define int OFF_DCO2_FREQ_LFO1    =  88;
   define int OFF_DCO2_PW_LFO2      =  89;
   define int OFF_VCF_FREQ_ENV1     =  90;
   define int OFF_VCF_FREQ_PRESS    =  91;
   define int OFF_VCA1_VEL          =  92;
   define int OFF_VCA2_ENV2         =  93;
   define int OFF_ENV1_AMP_VEL      =  94;
   define int OFF_ENV2_AMP_VEL      =  95;
   define int OFF_ENV3_AMP_VEL      =  96;
   define int OFF_LFO1_AMP_RAMP1    =  97;
   define int OFF_LFO2_AMP_RAMP2    =  98;
   define int OFF_PORTA_RATE_VEL    =  99;
   define int OFF_VCF_FM_AMT_ENV3   = 100;
   define int OFF_VCF_FM_AMT_PRESS  = 101;
   define int OFF_LFO1_SPEED_PRESS  = 102;
   define int OFF_LFO2_SPEED_KBD    = 103;
   define int OFF_MOD0_SRC          = 104;
   define int OFF_MOD0_AMT          = 105;
   define int OFF_MOD0_DST          = 106;
   define int OFF_MOD1_SRC          = 107;
   define int OFF_MOD1_AMT          = 108;
   define int OFF_MOD1_DST          = 109;
   define int OFF_MOD2_SRC          = 110;
   define int OFF_MOD2_AMT          = 111;
   define int OFF_MOD2_DST          = 112;
   define int OFF_MOD3_SRC          = 113;
   define int OFF_MOD3_AMT          = 114;
   define int OFF_MOD3_DST          = 115;
   define int OFF_MOD4_SRC          = 116;
   define int OFF_MOD4_AMT          = 117;
   define int OFF_MOD4_DST          = 118;
   define int OFF_MOD5_SRC          = 119;
   define int OFF_MOD5_AMT          = 120;
   define int OFF_MOD5_DST          = 121;
   define int OFF_MOD6_SRC          = 122;
   define int OFF_MOD6_AMT          = 123;
   define int OFF_MOD6_DST          = 124;
   define int OFF_MOD7_SRC          = 125;
   define int OFF_MOD7_AMT          = 126;
   define int OFF_MOD7_DST          = 127;
   define int OFF_MOD8_SRC          = 128;
   define int OFF_MOD8_AMT          = 129;
   define int OFF_MOD8_DST          = 130;
   define int OFF_MOD9_SRC          = 131;
   define int OFF_MOD9_AMT          = 132;
   define int OFF_MOD9_DST          = 133;

}


// <class.png>
class Matrix1000_Patch : Matrix1000_Defs {
   EditMIDISynthFormOberheimMatrix1000 *parent_editor;

   String patch_name;     // truncated to 8 chars during upload (ignored my M1K anyway)
   int    patch_category; // None, Bass, Lead, .. (see xfm)
   Buffer patch_data;     // 134 bytes


   // <method_init.png>
   public method init(EditMIDISynthFormOberheimMatrix1000 _editor) {
      parent_editor <= _editor;

      patch_data.size = 134;
      patch_data.fillZero();
      patch_name = "<empty>";
   }

   // <method.png>
   public method copyFrom(Matrix1000_Patch _o) {
      patch_data = _o.patch_data;
      patch_name = _o.patch_name;
      patch_category = _o.patch_category;
   }

   // <method.png>
   public method downloadPatch(short _patchNr) : boolean {

      // firmware 1.03 bugs / difference to MIDI spec:
      // (note) patchNr >= 256 download requires patch num to be set to 1 (otherwise patchnr=256 returns bank0:00)
      // (note) patchNr field in request must be set to 0 for patchNr <= 255
      // (note) seems that the patchNr fields acts as a bank select (patchNr >> 8)

      parent_editor.midiSelectPatch(_patchNr);

      Buffer b;
      b.size = 1024;
      b.offset = 0;

      b.i8 = 0xF0;
      b.i8 = 0x10;
      b.i8 = 0x06;
      b.i8 = 0x04; // Request data
      b.i8 = 0x01; // Single patch from current bank
      b.i8 = (_patchNr >> 8);//(_patchNr % 100);
      b.i8 = 0xF7;

      Global.Debug2("Matrix1000: send download request:");
      Utils.HexDump(b, 0, 7);

      Global.Debug("Matrix1000: downloadPatch("+_patchNr+"): pn%100="+(_patchNr % 100));

      parent_editor.sendBuffer(b);

      if(parent_editor.waitForSysEx())
      {
         Global.Debug2("Matrix1000_Patch::download: got sysex");

         Utils.HexDump(parent_editor.sysex_buffer, 0, parent_editor.sysex_buffer.size);

         if(decodeSysexToPatchData())
         {
            Global.Debug("Matrix1000_Patch::download: patch data decoded OK");

            patch_name = "        ";
            patch_name[0] = patch_data.peekI8(0);
            patch_name[1] = patch_data.peekI8(1);
            patch_name[2] = patch_data.peekI8(2);
            patch_name[3] = patch_data.peekI8(3);
            patch_name[4] = patch_data.peekI8(4);
            patch_name[5] = patch_data.peekI8(5);
            patch_name[6] = patch_data.peekI8(6);
            patch_name[7] = patch_data.peekI8(7);

            return true;
         }
         else
         {
            trace "[---] Matrix1000_Patch::download: FAILED to decode patch data";
         }

      }

      return false;
   }

   // <method.png>
   public method uploadToEditBuffer() : boolean {

      // (note) Crashes the synth on firmware 1.03

      Buffer ob;
      ob.size = 275;
      ob.offset = 0;

      ob.i8 = 0xF0;
      ob.i8 = 0x10;
      ob.i8 = 0x06;
      ob.i8 = 0x0D; // Single Patch Data to Edit Buffer
      ob.i8 = 0x00; //

      patch_data.offset = 0;

      byte checksum = 0;

      loop(134)
      {
         byte b = patch_data.u8;
         ob.i8 = b & 15;
         ob.i8 = (b >> 4) & 15;
         checksum += b;
      }

      ob.i8 = checksum;

      ob.i8 = 0xF7;

      parent_editor.sendBuffer(ob);

      TKS.sleep(300);
   }

   // <method.png>
   public method uploadToPatch(short _patchNr) : boolean {
      parent_editor.midiSelectPatch(_patchNr);

      Buffer ob;
      ob.size = 275;
      ob.offset = 0;

      ob.i8 = 0xF0;
      ob.i8 = 0x10;
      ob.i8 = 0x06;
      ob.i8 = 0x01; // Single Patch Data
      ob.i8 = _patchNr % 100;

      Global.Debug("Matrix1000: uploadToPatch("+_patchNr+"): pn%100="+(_patchNr % 100));

      // patch_data[27] = 50; // xxxx set VCF Initial Resonance
      // patch_data[26] = 0; // xxxx set VCF Initial Frequency
      // // patch_data[54] = 5; // xxxx set Env1 Initial Release Time (Filter Env)
      // patch_data[53] = 48; // xxxx set Env 1 Sustain Level
      // patch_data[63] = 5; // xxxx set Env2 Initial Release Time (Filter Env)

      patch_data.offset = 0;

      byte checksum = 0;

      loop(134)
      {
         byte b = patch_data.u8;
         ob.i8 = b & 15;
         ob.i8 = (b >> 4) & 15;
         checksum += b;
      }

      ob.i8 = checksum & 127;

      ob.i8 = 0xF7;

      Global.Debug2("Matrix1000: send patch: ob.offset="+ob.offset+" ob.size="+ob.size);
      // patch_data.offset = 0;
      Utils.HexDump(ob, 0, 275);

      parent_editor.sendBuffer(ob);

      TKS.sleep(300);

      return true;
   }

   // <method.png>
   protected method decodeSysexToPatchData() : boolean {
      boolean ret = false;
      Buffer ib <= parent_editor.sysex_buffer;
      patch_data.size = 134;
      ib.offset = 0;

      if(0x10 == ib.u8)
      {
         if(0x06 == ib.u8)
         {
            if(0x01 == ib.u8) // Single patch data
            {
               byte patchNr = ib.u8;
               byte expChecksum = 0;
               loop(134)
               {
                  byte b = ib.u8; // LSB
                  b |= (ib.u8 << 4);
                  expChecksum += b;
                  patch_data.i8 = b;
               }
               expChecksum &= 127;
               byte haveChecksum = ib.u8;
               Global.Debug2("Matrix1000::decodeSysexToPatchdata: expChecksum="+expChecksum+" haveChecksum="+haveChecksum);
               ret = (expChecksum == haveChecksum);

               Utils.HexDump(patch_data, 0, 134);
            }
         }
      }

      return ret;
   }

   // <save.png>
   public method save(Stream _ofs) {
      // Version
      _ofs.i16 = 1;

      // Patch name
      Utils.WriteString(_ofs, patch_name);

      // Patch category
      _ofs.i8 = patch_category;

      // Patch data
      _ofs.writeBuffer(patch_data, 0, patch_data.size);
   }

   // <load.png>
   public method load(Stream _ifs) : boolean {
      short ver = _ifs.u16;

      if(ver >= 1)
      {
         Utils.ReadString(_ifs, patch_name);

         patch_category = _ifs.u8;

         patch_data.fillZero();
         _ifs.readBuffer(patch_data, 0, patch_data.size, false/*bResize*/);

         return true;
      }

      return false;
   }
}


// <class.png>
class MIDISynthProfileDataOberheimMatrix1000 : MIDISynthProfileData {

   PointerArray patches;  // 1001 Matrix1000_Patch instances  (the 1001th patch is the init patch)

   short current_patch_nr;
   short first_patch_nr;
   short last_patch_nr;
   boolean b_autosend;


   // <method_init.png>
   public virtual init(MIDISynthProfile _profile) {
      MIDISynthProfileData::init(_profile);

      patches.alloc(1001);

      loop(1001)
      {
         Matrix1000_Patch patch <= new Matrix1000_Patch;
         patch.init(midi_profile.edit_form);
         patches.add(#(deref patch));
      }

      current_patch_nr = 0;
      first_patch_nr = 0;
      first_patch_nr = 0;
      b_autosend = true;
   }

   // <save.png>
   public virtual saveMIDIProfileData(Stream _ofs) {
      // Version
      _ofs.i16 = 1;

      _ofs.i16 = current_patch_nr;
      _ofs.i16 = first_patch_nr;
      _ofs.i16 = last_patch_nr;
      _ofs.i8  = b_autosend;

      int patchIdx = 0;
      loop(1001)
      {
         Matrix1000_Patch p <= patches.get(patchIdx);
         p.save(_ofs);
         patchIdx++;
      }
   }

   // <load.png>
   public virtual loadMIDIProfileData(Stream _ifs, boolean _bFromUI) : boolean {
      short ver = _ifs.u16;

      if(ver >= 1)
      {
         if(!_bFromUI)
         {
            current_patch_nr = _ifs.u16;
         }
         else
         {
            int skip0 = _ifs.u16;
         }

         first_patch_nr = _ifs.u16;
         last_patch_nr = _ifs.u16;
         b_autosend = _ifs.b8;

         int patchIdx = 0;
         loop(1001)
         {
            Matrix1000_Patch p <= patches.get(patchIdx);
            if(!p.load(_ifs))
            {
               trace "[---] failed to load Matrix1000 patch "+patchIdx;
               return false;
            }
            patchIdx++;
         }

         return true;
      }

      return false;
   }

   // <save.png>
   public virtual saveProjectMIDIProfileData(Stream _ofs) {
      // Version
      _ofs.i16 = 1;

   }

   // <load.png>
   public virtual loadProjectMIDIProfileData(Stream _ifs) : boolean {
      short ver = _ifs.u16;

      if(ver >= 1)
      {
         return true;
      }

      return false;
   }
}


// <class.png>
class EditMIDISynthFormOberheimMatrix1000 : EditMIDISynthForm, ActionProvider, MIDIMapEventListener, Matrix1000_Defs {

   define String TA_MIDISEND;

   MIDISynthProfileDataOberheimMatrix1000 *data;
   Matrix1000_Patch *patch;  // Reference to current patch in data.patches[]. never null.
   STX_MIDIInDevice *in_dev;
   STX_MIDIOutDevice *out_dev;
   byte midi_ch;
   boolean b_have_sysex;
   Buffer sysex_buffer;

   short current_midi_patch_nr = -1; // to avoid unnecessary (and slow) MIDI bank+program selects
   short queued_midi_patch_nr = -1;
   boolean b_queued_midi_send_patch;

   Matrix1000_Patch *patch_clipboard;

   protected TabSwitch *ts_groups;

   // Patch
   protected CheckBox   *cb_patch_autosend;
   protected FloatParam *fp_patch_nr;
   protected TextField  *tf_patch_name;
   protected ComboBox   *cm_patch_category;
   protected Button     *bt_patch_catprev;
   protected Button     *bt_patch_catnext;
   protected ComboBox   *cm_patch_voicemode;
   protected FloatParam *fp_patch_nr_midi;
   protected CheckBox   *cb_patch_midi_follow;

   // Patch Utils
   protected FloatParam *fp_patch_first;
   protected FloatParam *fp_patch_last;
   protected Button     *bt_patch_send;
   protected Button     *bt_patch_receive;

   // Patch Utils C'N'P
   protected Button *bt_patch_copy;
   protected Button *bt_patch_paste;
   protected Button *bt_patch_init;
   protected Button *bt_patch_saveinit;

   // DCO
   protected ComboBox   *cm_dco_sync;
   protected FloatParam *fp_dco2_detune;
   protected FloatParam *fp_dco_mix;
   protected CheckBox   *cb_dco1_click;
   protected CheckBox   *cb_dco1_sawtri;
   protected FloatParam *fp_dco1_shape;
   protected FloatParam *fp_dco1_freq;
   protected CheckBox   *cb_dco1_pulse;
   protected FloatParam *fp_dco1_pw;
   protected FloatParam *fp_dco1_lfo1amt;
   protected FloatParam *fp_dco1_lfo2amt;
   protected CheckBox   *cb_dco1_portamento;
   protected CheckBox   *cb_dco1_vibrato;
   protected CheckBox   *cb_dco1_lever1; // pb

   protected CheckBox   *cb_dco2_click;
   protected CheckBox   *cb_dco2_sawtri;
   protected FloatParam *fp_dco2_shape;
   protected FloatParam *fp_dco2_freq;
   protected CheckBox   *cb_dco2_pulse;
   protected CheckBox   *cb_dco2_noise;
   protected FloatParam *fp_dco2_pw;
   protected FloatParam *fp_dco2_lfo1amt;
   protected FloatParam *fp_dco2_lfo2amt;
   protected CheckBox   *cb_dco2_keytrack;
   protected CheckBox   *cb_dco2_portamento;
   protected CheckBox   *cb_dco2_vibrato;
   protected CheckBox   *cb_dco2_lever1; // pb

   // Env1
   protected FloatParam *fp_env1_fmenv3;
   protected FloatParam *fp_env1_fmpressure;
   protected FloatParam *fp_env1_fm;
   protected FloatParam *fp_env1_res;
   protected FloatParam *fp_env1_velocity;
   protected FloatParam *fp_env1_pressure;
   protected FloatParam *fp_env1_amount;
   protected FloatParam *fp_env1_cutoff;
   protected CheckBox   *cb_env1_key;
   protected CheckBox   *cb_env1_portamento;
   protected CheckBox   *cb_env1_vibrato;
   protected CheckBox   *cb_env1_pb; // aka lever 1
   protected FloatParam *fp_env1_release;
   protected FloatParam *fp_env1_sustain;
   protected FloatParam *fp_env1_decay;
   protected FloatParam *fp_env1_attack;
   protected FloatParam *fp_env1_level;
   protected FloatParam *fp_env1_delay;
   protected CheckBox   *cb_env1_free;
   protected CheckBox   *cb_env1_dadr;
   protected CheckBox   *cb_env1_lfotrig;
   protected CheckBox   *cb_env1_lfogate;
   protected CheckBox   *cb_env1_ext;
   protected CheckBox   *cb_env1_multitrig;
   protected CheckBox   *cb_env1_reset;

   // Env2
   protected FloatParam *fp_env2_velocity;
   protected FloatParam *fp_env2_amount;
   protected FloatParam *fp_env2_vca1velocity;
   protected FloatParam *fp_env2_vca1amount;
   protected FloatParam *fp_env2_release;
   protected FloatParam *fp_env2_sustain;
   protected FloatParam *fp_env2_decay;
   protected FloatParam *fp_env2_attack;
   protected FloatParam *fp_env2_level;
   protected FloatParam *fp_env2_delay;
   protected CheckBox   *cb_env2_free;
   protected CheckBox   *cb_env2_dadr;
   protected CheckBox   *cb_env2_lfotrig;
   protected CheckBox   *cb_env2_lfogate;
   protected CheckBox   *cb_env2_ext;
   protected CheckBox   *cb_env2_multitrig;
   protected CheckBox   *cb_env2_reset;

   // Env3
   protected FloatParam *fp_env3_velocity;
   protected FloatParam *fp_env3_release;
   protected FloatParam *fp_env3_sustain;
   protected FloatParam *fp_env3_decay;
   protected FloatParam *fp_env3_attack;
   protected FloatParam *fp_env3_level;
   protected FloatParam *fp_env3_delay;
   protected CheckBox   *cb_env3_free;
   protected CheckBox   *cb_env3_dadr;
   protected CheckBox   *cb_env3_lfotrig;
   protected CheckBox   *cb_env3_lfogate;
   protected CheckBox   *cb_env3_ext;
   protected CheckBox   *cb_env3_multitrig;
   protected CheckBox   *cb_env3_reset;

   // LFO1
   protected ComboBox   *cm_lfo1_trig;
   protected CheckBox   *cb_lfo1_lag;
   protected FloatParam *fp_lfo1_retrig;
   protected ComboBox   *cm_lfo1_shape;
   protected FloatParam *fp_lfo1_amp;
   protected FloatParam *fp_lfo1_speed;
   protected FloatParam *fp_lfo1_speedpressure;
   protected FloatParam *fp_lfo1_ramp1amp;
   protected ComboBox   *cm_lfo1_smpsrc;

   // LFO2
   protected ComboBox   *cm_lfo2_trig;
   protected CheckBox   *cb_lfo2_lag;
   protected FloatParam *fp_lfo2_retrig;
   protected ComboBox   *cm_lfo2_shape;
   protected FloatParam *fp_lfo2_amp;
   protected FloatParam *fp_lfo2_speed;
   protected FloatParam *fp_lfo2_speedkeyboard;
   protected FloatParam *fp_lfo2_ramp2amp;
   protected ComboBox   *cm_lfo2_smpsrc;

   // Trk/Rmp/Lag
   protected ComboBox   *cm_ramp1_mode;
   protected FloatParam *fp_ramp1_rate;
   protected ComboBox   *cm_ramp2_mode;
   protected FloatParam *fp_ramp2_rate;
   protected FloatParam *fp_trk_p5;
   protected FloatParam *fp_trk_p4;
   protected FloatParam *fp_trk_p3;
   protected FloatParam *fp_trk_p2;
   protected FloatParam *fp_trk_p1;
   protected ComboBox   *cm_trk_src;
   protected CheckBox   *cb_trk_legato;
   protected FloatParam *fp_trk_lagvelrate;
   protected FloatParam *fp_trk_lagrate;
   protected ComboBox   *cm_trk_lagmode;

   // Mod Bus 0..9
   protected FloatParam *fp_mod0_amount;
   protected ComboBox   *cm_mod0_dst;
   protected ComboBox   *cm_mod0_src;

   protected FloatParam *fp_mod1_amount;
   protected ComboBox   *cm_mod1_dst;
   protected ComboBox   *cm_mod1_src;

   protected FloatParam *fp_mod2_amount;
   protected ComboBox   *cm_mod2_dst;
   protected ComboBox   *cm_mod2_src;

   protected FloatParam *fp_mod3_amount;
   protected ComboBox   *cm_mod3_dst;
   protected ComboBox   *cm_mod3_src;

   protected FloatParam *fp_mod4_amount;
   protected ComboBox   *cm_mod4_dst;
   protected ComboBox   *cm_mod4_src;

   protected FloatParam *fp_mod5_amount;
   protected ComboBox   *cm_mod5_dst;
   protected ComboBox   *cm_mod5_src;

   protected FloatParam *fp_mod6_amount;
   protected ComboBox   *cm_mod6_dst;
   protected ComboBox   *cm_mod6_src;

   protected FloatParam *fp_mod7_amount;
   protected ComboBox   *cm_mod7_dst;
   protected ComboBox   *cm_mod7_src;

   protected FloatParam *fp_mod8_amount;
   protected ComboBox   *cm_mod8_dst;
   protected ComboBox   *cm_mod8_src;

   protected FloatParam *fp_mod9_amount;
   protected ComboBox   *cm_mod9_dst;
   protected ComboBox   *cm_mod9_src;


   protected TimerAction *ta_midisend;

   protected boolean b_patch_midi_follow;


   // <method_init.png>
   public virtual init(MIDISynthProfile _profile) : boolean {

      if(initPakFile("Matrix1000.xfm"))
      {
         if(autoResolveIds(this))
         {
            initMMC();

            initTimers();

            patch_clipboard <= new Matrix1000_Patch;
            patch_clipboard.init(this);

            return true;
         }
      }

      return false;
   }

   // <midi_mmc.png>
   protected method initMMC() {

      mmcInit("EditMIDISynthFormOberheimMatrix1000");

      ////addBaseMMCTargets(this);
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_midisend <= TimerAction.New(TA_MIDISEND, this, 1000);
   }

   // <ui_show.png>
   public virtual showData(MIDISynthProfileDataOberheimMatrix1000 _data,
                           STX_MIDIInDevice  _inDev,
                           STX_MIDIOutDevice _outDev,
                           byte              _midiCh
                           ) {
      data    <= _data;
      in_dev  <= _inDev;
      out_dev <= _outDev;
      midi_ch  = _midiCh;

      patch <= _data.patches.get(_data.current_patch_nr);

      updateUIFromPatch();

      if(null == in_dev)
      {
         Global.Error("Matrix1000: input device not configured or found");
      }

      if(null == out_dev)
      {
         Global.Error("Matrix1000: output device not configured or found");
      }
      else
      {
         if(-1 == current_midi_patch_nr)
         {
            midiSelectPatch(0);
         }
      }


   }

   // <ui_show.png>
   public virtual enter() {
      b_queued_midi_send_patch = false;
      MIDI.AddMIDIMapEventListener(this);
   }

   // <ui_show.png>
   public virtual leave() {
      b_queued_midi_send_patch = false;
      MIDI.RemoveMIDIMapEventListener(this);
      ta_midisend.cancel();
   }

   // <method.png>
   protected static signextend(byte _val) : byte {
      if(_val >= 64)
         return -128 + _val;
      else
         return _val;
   }

   // <ui_update.png>
   protected method updateUIFromPatch() {
      Global.Debug2("Matrix1000::updateUIFromPatch: patch_nr="+data.current_patch_nr);

      Buffer pd <= patch.patch_data;

      fp_patch_first.setValue(data.first_patch_nr);
      fp_patch_last .setValue(data.last_patch_nr);

      // Patch
      fp_patch_nr_midi  .setValue(         current_midi_patch_nr);
      fp_patch_nr       .setValue(         data.current_patch_nr);
      cb_patch_autosend .setSelected(      data.b_autosend);
      tf_patch_name     .setText(          patch.patch_name);
      cm_patch_category .setSelectedOption(patch.patch_category);
      cm_patch_voicemode.setSelectedOption(pd.peekI8(OFF_KEYBOARD_MODE));
      cb_patch_midi_follow .setSelected (b_patch_midi_follow);

      // DCO
      cm_dco_sync       .setSelectedOption(pd.peekI8(OFF_DCO_SYNC));
      fp_dco2_detune    .setValue(         signextend(pd.peekI8(OFF_DCO2_DETUNE)));
      fp_dco_mix        .setValue(         pd.peekI8(OFF_MIX));
      cb_dco1_click     .setSelected(      pd.peekI8(OFF_DCO1_CLICK));
      cb_dco1_sawtri    .setSelected(      pd.peekI8(OFF_DCO1_WAVE_ENABLE) & 2);
      fp_dco1_shape     .setValue(         pd.peekI8(OFF_DCO1_INIT_SHAPE));
      fp_dco1_freq      .setValue(         pd.peekI8(OFF_DCO1_INIT_FREQ));
      cb_dco1_pulse     .setSelected(      pd.peekI8(OFF_DCO1_WAVE_ENABLE) & 1);
      fp_dco1_pw        .setValue(         pd.peekI8(OFF_DCO1_INIT_PW));
      fp_dco1_lfo1amt   .setValue(         pd.peekI8(OFF_DCO1_FREQ_LFO1));
      fp_dco1_lfo2amt   .setValue(         pd.peekI8(OFF_DCO1_PW_LFO2));
      cb_dco1_portamento.setSelected(      pd.peekI8(OFF_DCO1_FIXMOD_2) & 1);
      cb_dco1_vibrato   .setSelected(      pd.peekI8(OFF_DCO1_FIXMOD) & 2);
      cb_dco1_lever1    .setSelected(      pd.peekI8(OFF_DCO1_FIXMOD) & 1);

      cb_dco2_click     .setSelected(pd.peekI8(OFF_DCO2_CLICK));
      cb_dco2_sawtri    .setSelected(pd.peekI8(OFF_DCO2_WAVE_ENABLE) & 2);
      fp_dco2_shape     .setValue(   pd.peekI8(OFF_DCO2_INIT_SHAPE));
      fp_dco2_freq      .setValue(   pd.peekI8(OFF_DCO2_INIT_FREQ));
      cb_dco2_pulse     .setSelected(pd.peekI8(OFF_DCO2_WAVE_ENABLE) & 1);
      cb_dco2_noise     .setSelected(pd.peekI8(OFF_DCO2_WAVE_ENABLE) & 4);
      fp_dco2_pw        .setValue(   pd.peekI8(OFF_DCO2_INIT_PW));
      fp_dco2_lfo1amt   .setValue(   pd.peekI8(OFF_DCO2_FREQ_LFO1));
      fp_dco2_lfo2amt   .setValue(   pd.peekI8(OFF_DCO2_PW_LFO2));
      cb_dco2_portamento.setSelected(pd.peekI8(OFF_DCO2_FIXMOD_2) & 1);
      cb_dco2_vibrato   .setSelected(pd.peekI8(OFF_DCO2_FIXMOD) & 2);
      cb_dco2_lever1    .setSelected(pd.peekI8(OFF_DCO2_FIXMOD) & 1);

      // Env1 (filter)
      fp_env1_fmenv3    .setValue(   signextend(pd.peekI8(OFF_VCF_FM_AMT_ENV3)));
      fp_env1_fmpressure.setValue(   signextend(pd.peekI8(OFF_VCF_FM_AMT_PRESS)));
      fp_env1_fm        .setValue(   signextend(pd.peekI8(OFF_VCF_FM_INIT_AMT)));
      fp_env1_res       .setValue(   pd.peekI8(OFF_VCF_INIT_RES));
      fp_env1_velocity  .setValue(   signextend(pd.peekI8(OFF_ENV1_AMP_VEL)));
      fp_env1_pressure  .setValue(   signextend(pd.peekI8(OFF_VCF_FREQ_PRESS)));
      fp_env1_amount    .setValue(   signextend(pd.peekI8(OFF_VCF_FREQ_ENV1)));
      fp_env1_cutoff    .setValue(   pd.peekI8(OFF_VCF_INIT_FREQ));
      cb_env1_key       .setSelected(pd.peekI8(OFF_VCF_KEYMOD) & 2);
      cb_env1_portamento.setSelected(pd.peekI8(OFF_VCF_KEYMOD) & 1);
      cb_env1_vibrato   .setSelected(pd.peekI8(OFF_VCF_FIXMOD) & 2);
      cb_env1_pb        .setSelected(pd.peekI8(OFF_VCF_FIXMOD) & 1);
      fp_env1_release   .setValue(   pd.peekI8(OFF_ENV1_INIT_RELEASE));
      fp_env1_sustain   .setValue(   pd.peekI8(OFF_ENV1_SUSTAIN));
      fp_env1_decay     .setValue(   pd.peekI8(OFF_ENV1_INIT_DECAY));
      fp_env1_attack    .setValue(   pd.peekI8(OFF_ENV1_INIT_ATTACK));
      fp_env1_level     .setValue(   pd.peekI8(OFF_ENV1_INIT_AMP));
      fp_env1_delay     .setValue(   pd.peekI8(OFF_ENV1_INIT_DELAY));
      cb_env1_free      .setSelected(pd.peekI8(OFF_ENV1_MODE) & 2);
      cb_env1_dadr      .setSelected(pd.peekI8(OFF_ENV1_MODE) & 1);
      cb_env1_lfotrig   .setSelected(pd.peekI8(OFF_ENV1_LFO_TRIG) & 2);
      cb_env1_lfogate   .setSelected(pd.peekI8(OFF_ENV1_LFO_TRIG) & 1);
      cb_env1_ext       .setSelected(pd.peekI8(OFF_ENV1_TRIG_MODE) & 4);
      cb_env1_multitrig .setSelected(pd.peekI8(OFF_ENV1_TRIG_MODE) & 2);
      cb_env1_reset     .setSelected(pd.peekI8(OFF_ENV1_TRIG_MODE) & 1);

      // Env2 (amp)
      fp_env2_velocity    .setValue(   signextend(pd.peekI8(OFF_ENV2_AMP_VEL)));
      fp_env2_amount      .setValue(   signextend(pd.peekI8(OFF_VCA2_ENV2)));
      fp_env2_vca1velocity.setValue(   signextend(pd.peekI8(OFF_VCA1_VEL)));
      fp_env2_vca1amount  .setValue(   pd.peekI8(OFF_VCA1_INIT_AMT));
      fp_env2_release     .setValue(   pd.peekI8(OFF_ENV2_INIT_RELEASE));
      fp_env2_sustain     .setValue(   pd.peekI8(OFF_ENV2_SUSTAIN));
      fp_env2_decay       .setValue(   pd.peekI8(OFF_ENV2_INIT_DECAY));
      fp_env2_attack      .setValue(   pd.peekI8(OFF_ENV2_INIT_ATTACK));
      fp_env2_level       .setValue(   pd.peekI8(OFF_ENV2_INIT_AMP));
      fp_env2_delay       .setValue(   pd.peekI8(OFF_ENV2_INIT_DELAY));
      cb_env2_free        .setSelected(pd.peekI8(OFF_ENV2_MODE) & 2);
      cb_env2_dadr        .setSelected(pd.peekI8(OFF_ENV2_MODE) & 1);
      cb_env2_lfotrig     .setSelected(pd.peekI8(OFF_ENV2_LFO_TRIG) & 2);
      cb_env2_lfogate     .setSelected(pd.peekI8(OFF_ENV2_LFO_TRIG) & 1);
      cb_env2_ext         .setSelected(pd.peekI8(OFF_ENV2_TRIG_MODE) & 4);
      cb_env2_multitrig   .setSelected(pd.peekI8(OFF_ENV2_TRIG_MODE) & 2);
      cb_env2_reset       .setSelected(pd.peekI8(OFF_ENV2_TRIG_MODE) & 1);

      // Env3 (aux)
      fp_env3_velocity .setValue(   signextend(pd.peekI8(OFF_ENV3_AMP_VEL)));
      fp_env3_release  .setValue(   pd.peekI8(OFF_ENV3_INIT_RELEASE));
      fp_env3_sustain  .setValue(   pd.peekI8(OFF_ENV3_SUSTAIN));
      fp_env3_decay    .setValue(   pd.peekI8(OFF_ENV3_INIT_DECAY));
      fp_env3_attack   .setValue(   pd.peekI8(OFF_ENV3_INIT_ATTACK));
      fp_env3_level    .setValue(   pd.peekI8(OFF_ENV3_INIT_AMP));
      fp_env3_delay    .setValue(   pd.peekI8(OFF_ENV3_INIT_DELAY));
      cb_env3_free     .setSelected(pd.peekI8(OFF_ENV3_MODE) & 2);
      cb_env3_dadr     .setSelected(pd.peekI8(OFF_ENV3_MODE) & 1);
      cb_env3_lfotrig  .setSelected(pd.peekI8(OFF_ENV3_LFO_TRIG) & 2);
      cb_env3_lfogate  .setSelected(pd.peekI8(OFF_ENV3_LFO_TRIG) & 1);
      cb_env3_ext      .setSelected(pd.peekI8(OFF_ENV3_TRIG_MODE) & 4);
      cb_env3_multitrig.setSelected(pd.peekI8(OFF_ENV3_TRIG_MODE) & 2);
      cb_env3_reset    .setSelected(pd.peekI8(OFF_ENV3_TRIG_MODE) & 1);

      // LFO1
      cm_lfo1_trig         .setSelectedOption(pd.peekI8(OFF_LFO1_TRIG) & 3);
      cb_lfo1_lag          .setSelected(      pd.peekI8(OFF_LFO1_LAG));
      fp_lfo1_retrig       .setValue(         pd.peekI8(OFF_LFO1_RETRIG));
      cm_lfo1_shape        .setSelectedOption(pd.peekI8(OFF_LFO1_SHAPE));
      fp_lfo1_amp          .setValue(         pd.peekI8(OFF_LFO1_INIT_AMP));
      fp_lfo1_speed        .setValue(         pd.peekI8(OFF_LFO1_INIT_SPEED));
      fp_lfo1_speedpressure.setValue(         signextend(pd.peekI8(OFF_LFO1_SPEED_PRESS)));
      fp_lfo1_ramp1amp     .setValue(         signextend(pd.peekI8(OFF_LFO1_AMP_RAMP1)));
      cm_lfo1_smpsrc       .setSelectedOption(pd.peekI8(OFF_LFO1_SMPSRC));

      // LFO2
      cm_lfo2_trig         .setSelectedOption(pd.peekI8(OFF_LFO2_TRIG) & 3);
      cb_lfo2_lag          .setSelected(      pd.peekI8(OFF_LFO2_LAG));
      fp_lfo2_retrig       .setValue(         pd.peekI8(OFF_LFO2_RETRIG));
      cm_lfo2_shape        .setSelectedOption(pd.peekI8(OFF_LFO2_SHAPE));
      fp_lfo2_amp          .setValue(         pd.peekI8(OFF_LFO2_INIT_AMP));
      fp_lfo2_speed        .setValue(         pd.peekI8(OFF_LFO2_INIT_SPEED));
      fp_lfo2_speedkeyboard.setValue(         signextend(pd.peekI8(OFF_LFO2_SPEED_KBD)));
      fp_lfo2_ramp2amp     .setValue(         signextend(pd.peekI8(OFF_LFO2_AMP_RAMP2)));
      cm_lfo2_smpsrc       .setSelectedOption(pd.peekI8(OFF_LFO2_SMPSRC));

      // Trk/Rmp/Lag
      cm_ramp1_mode    .setSelectedOption(pd.peekI8(OFF_RAMP1_MODE));
      fp_ramp1_rate    .setValue(         pd.peekI8(OFF_RAMP1_RATE));
      cm_ramp2_mode    .setSelectedOption(pd.peekI8(OFF_RAMP2_MODE));
      fp_ramp2_rate    .setValue(         pd.peekI8(OFF_RAMP2_RATE));
      fp_trk_p5        .setValue(         pd.peekI8(OFF_TRK_P5));
      fp_trk_p4        .setValue(         pd.peekI8(OFF_TRK_P4));
      fp_trk_p3        .setValue(         pd.peekI8(OFF_TRK_P3));
      fp_trk_p2        .setValue(         pd.peekI8(OFF_TRK_P2));
      fp_trk_p1        .setValue(         pd.peekI8(OFF_TRK_P1));
      cm_trk_src       .setSelectedOption(pd.peekI8(OFF_TRK_SRC) - 1);
      cb_trk_legato    .setSelected(      pd.peekI8(OFF_PORTA_LEGATO));
      fp_trk_lagvelrate.setValue(         signextend(pd.peekI8(OFF_PORTA_RATE_VEL)));
      fp_trk_lagrate   .setValue(         pd.peekI8(OFF_PORTA_INIT_RATE));
      cm_trk_lagmode   .setSelectedOption(pd.peekI8(OFF_LAG_MODE));

      // Mod Bus 0..9
      fp_mod0_amount.setValue(         pd.peekI8(OFF_MOD0_AMT));
      cm_mod0_dst   .setSelectedOption(pd.peekI8(OFF_MOD0_DST));
      cm_mod0_src   .setSelectedOption(pd.peekI8(OFF_MOD0_SRC));

      fp_mod1_amount.setValue(         pd.peekI8(OFF_MOD1_AMT));
      cm_mod1_dst   .setSelectedOption(pd.peekI8(OFF_MOD1_DST));
      cm_mod1_src   .setSelectedOption(pd.peekI8(OFF_MOD1_SRC));

      fp_mod2_amount.setValue(         pd.peekI8(OFF_MOD2_AMT));
      cm_mod2_dst   .setSelectedOption(pd.peekI8(OFF_MOD2_DST));
      cm_mod2_src   .setSelectedOption(pd.peekI8(OFF_MOD2_SRC));

      fp_mod3_amount.setValue(         pd.peekI8(OFF_MOD3_AMT));
      cm_mod3_dst   .setSelectedOption(pd.peekI8(OFF_MOD3_DST));
      cm_mod3_src   .setSelectedOption(pd.peekI8(OFF_MOD3_SRC));

      fp_mod4_amount.setValue(         pd.peekI8(OFF_MOD4_AMT));
      cm_mod4_dst   .setSelectedOption(pd.peekI8(OFF_MOD4_DST));
      cm_mod4_src   .setSelectedOption(pd.peekI8(OFF_MOD4_SRC));

      fp_mod5_amount.setValue(         pd.peekI8(OFF_MOD5_AMT));
      cm_mod5_dst   .setSelectedOption(pd.peekI8(OFF_MOD5_DST));
      cm_mod5_src   .setSelectedOption(pd.peekI8(OFF_MOD5_SRC));

      fp_mod6_amount.setValue(         pd.peekI8(OFF_MOD6_AMT));
      cm_mod6_dst   .setSelectedOption(pd.peekI8(OFF_MOD6_DST));
      cm_mod6_src   .setSelectedOption(pd.peekI8(OFF_MOD6_SRC));

      fp_mod7_amount.setValue(         pd.peekI8(OFF_MOD7_AMT));
      cm_mod7_dst   .setSelectedOption(pd.peekI8(OFF_MOD7_DST));
      cm_mod7_src   .setSelectedOption(pd.peekI8(OFF_MOD7_SRC));

      fp_mod8_amount.setValue(         pd.peekI8(OFF_MOD8_AMT));
      cm_mod8_dst   .setSelectedOption(pd.peekI8(OFF_MOD8_DST));
      cm_mod8_src   .setSelectedOption(pd.peekI8(OFF_MOD8_SRC));

      fp_mod9_amount.setValue(         pd.peekI8(OFF_MOD9_AMT));
      cm_mod9_dst   .setSelectedOption(pd.peekI8(OFF_MOD9_DST));
      cm_mod9_src   .setSelectedOption(pd.peekI8(OFF_MOD9_SRC));

      redraw();
   }

   // <ui_midi.png>
   public =replay= method midiSelectPatch(short _patch) {
      if(_patch < 1000)
      {
         if(current_midi_patch_nr != _patch)
         {
            boolean bSendBank = true;

            if(-1 != current_midi_patch_nr)
            {
               bSendBank = (current_midi_patch_nr / 100) != (_patch / 100);
            }

            if(bSendBank)
            {
               out_dev.ctlChange(midi_ch, 1, 127); // modwheel up (enable bank select)
               out_dev.send(milliSeconds());
               TKS.sleep(100);

               out_dev.programChange(midi_ch, (_patch / 100));
               out_dev.send(milliSeconds());
               TKS.sleep(100);

               out_dev.ctlChange(midi_ch, 1, 0); // modwheel down (disable bank select)
               out_dev.send(milliSeconds());
               TKS.sleep(100);
            }

            out_dev.programChange(midi_ch, (_patch % 100));
            out_dev.send(milliSeconds());
            TKS.sleep(100);

            current_midi_patch_nr = _patch;

            fp_patch_nr_midi.setValue(_patch);
            fp_patch_nr_midi.redraw();
         }
      }

   }

   // <ui_midi.png>
   public =replay= method midiRemoteParamEdit(byte _param, byte _value) {
      // (note) apparently not supported by FW 1.03
      Buffer b;
      b.size = 7;
      b.offset = 0;
      b.i8 = 0xF0;
      b.i8 = 0x10;
      b.i8 = 0x06;
      b.i8 = 0x06;
      b.i8 = _param;
      b.i8 = _value;
      b.i8 = 0xF7;

      sendBuffer(b);
   }

   // <ui_midi.png>
   =replay= public method sendBuffer(Buffer _b) {
      out_dev.addBuffer(_b);
      out_dev.send(milliSeconds());
   }

   // <ui_midi.png>
   public virtual mmlHandleEventUI(MIDIMapEvent _ev) : boolean {
      Global.Debug2("Matrix1000::mmlHandleEventUI");
      if(@(_ev.dev) == @(in_dev))
      {
         Global.Debug2("Matrix1000::mmlHandleEventUI: is in_dev");

         if(MIDIMapDefs.TYPE_SYSEX == _ev.type)
         {
            sysex_buffer = _ev.sysex_buffer;
            b_have_sysex = true;
         }
      }
      return false;
   }

   // <ui_midi.png>
   public method waitForSysEx() : boolean {
      b_have_sysex = false;

      Global.Debug("Matrix1000::waitForSysEx: in_dev="+#(in_dev));

      if(null != in_dev)
      {
         Global.Debug("Matrix1000::waitForSysEx: in_dev.aliasOrDevName=\""+in_dev.getAliasOrDeviceName()+"\"");

         // 1 second timeout
         loop(10)
         {
            replay.processMidiMapUIEventQueue();

            if(b_have_sysex)
            {
               break;
            }

            TKS.sleep(100);
         }
      }

      return b_have_sysex;
   }

   // <ui_handle.png>
   protected method handlePatchAutosendChanged() {
      data.b_autosend = cb_patch_autosend.isSelected();
      Global.Print("Autosend is "+Utils.GetEnableString(data.b_autosend));

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }
   }

   // <ui_handle.png>
   protected method handlePatchNrChanged() {
      data.current_patch_nr = fp_patch_nr.getFloatValue();
      data.first_patch_nr = data.current_patch_nr;
      data.last_patch_nr = data.current_patch_nr;
      patch <= data.patches.get(data.current_patch_nr);
      Global.Print("Select patch "+data.current_patch_nr);
      updateUIFromPatch();

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }
      else if(b_patch_midi_follow)
      {
         queued_midi_patch_nr = data.current_patch_nr;
         scheduleMIDISend();
      }
   }

   // <ui_handle.png>
   protected method handleMIDIPatchNrChanged() {
      int patchNr = fp_patch_nr_midi.getFloatValue();
      queued_midi_patch_nr = patchNr;
      data.first_patch_nr = patchNr;
      data.last_patch_nr = patchNr;
      fp_patch_first.setValue(patchNr);
      fp_patch_first.redraw();
      fp_patch_last.setValue(patchNr);
      fp_patch_last.redraw();
      scheduleMIDISend();
   }

   // <ui_handle.png>
   protected method handlePatchMIDIFollowChanged() {
      b_patch_midi_follow = cb_patch_midi_follow.isSelected();
      Global.Print("MIDI follow is "+Utils.GetEnableString(b_patch_midi_follow));

      if(b_patch_midi_follow && !data.b_autosend)
      {
         queued_midi_patch_nr = data.current_patch_nr;
         scheduleMIDISend();
      }
   }

   // <ui_timer.png>
   protected method scheduleMIDISendPatch() {
      b_queued_midi_send_patch = true;
      ta_midisend.cancel();
      ta_midisend.schedule();
   }

   // <ui_timer.png>
   protected method scheduleMIDISendPatchAuto() {
      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }
   }

   // <ui_timer.png>
   protected method scheduleMIDISend() {
      ta_midisend.cancel();
      ta_midisend.schedule();
   }

   // <ui_timer.png>
   protected method handleMIDISendTimer() {
      if(-1 != queued_midi_patch_nr)
      {
         midiSelectPatch(queued_midi_patch_nr);
         queued_midi_patch_nr = -1;
      }

      if(b_queued_midi_send_patch)
      {
         b_queued_midi_send_patch = false;

         if(1)
         {
            midiSelectPatch(0); // Select edit buffer
            patch.uploadToPatch(0);
            // if(data.current_patch_nr == current_midi_patch_nr)
            // {
            //    patch.uploadToPatch(data.current_patch_nr);
            // }
         }

         // // midiRemoteParamEdit(0xa, 32); // DCO1 freq
      }
   }

   // <method.png>
   public virtual handlePostReload() {

      if(data.b_autosend)
      {
         handlePatchNrChanged();
      }

   }

   // <ui_handle.png>
   protected method handlePatchNameChanged() {
      patch.patch_name = tf_patch_name.getText();
      Buffer pd <= patch.patch_data;
      pd.pokeI8(0, patch.patch_name.getc(0));
      pd.pokeI8(1, patch.patch_name.getc(1));
      pd.pokeI8(2, patch.patch_name.getc(2));
      pd.pokeI8(3, patch.patch_name.getc(3));
      pd.pokeI8(4, patch.patch_name.getc(4));
      pd.pokeI8(5, patch.patch_name.getc(5));
      pd.pokeI8(6, patch.patch_name.getc(6));
      pd.pokeI8(7, patch.patch_name.getc(7));
      Global.Print("Patch name is \""+patch.patch_name+"\"");
      // (note) dont send patch, name is ignored by synth
   }

   // <ui_handle.png>
   protected method handlePatchCategoryChanged() {
      patch.patch_category = cm_patch_category.getSelectedOption();
      Global.Print("Patch category is \""+cm_patch_category.getSelectedOptionName()+"\"");
   }

   // <ui_handle.png>
   protected method handlePatchCategoryPrev() {
      // (todo)
   }

   // <ui_handle.png>
   protected method handlePatchCategoryNext() {
      // (todo)
   }

   // <ui_handle.png>
   protected method handlePatchFirstChanged() {
      data.first_patch_nr = fp_patch_first.getFloatValue();
      data.last_patch_nr = data.first_patch_nr;
      fp_patch_last.setValue(data.first_patch_nr);
      fp_patch_last.redraw();
      Global.Print("Set first+last patch nr to "+data.first_patch_nr);
   }

   // <ui_handle.png>
   protected method handlePatchLastChanged() {
      data.last_patch_nr = fp_patch_last.getFloatValue();
      Global.Print("Set last patch nr to "+data.last_patch_nr);
   }

   // <ui_handle.png>
   protected method handlePatchReceive() {

      while(data.first_patch_nr <= data.last_patch_nr)
      {
         Matrix1000_Patch dlPatch <= data.patches.get(data.first_patch_nr);

         if(dlPatch.downloadPatch(data.first_patch_nr))
         {
            Global.Success("Download patch "+data.first_patch_nr);

            if(@(dlPatch) == @(patch))
            {
               updateUIFromPatch();
            }

            if(data.first_patch_nr != data.last_patch_nr)
            {
               data.first_patch_nr++;
            }
            else
            {
               return;
            }
         }
         else
         {
            Global.Error("Failed to download patch "+data.first_patch_nr);
            return;
         }
      }
   }

   // <ui_handle.png>
   protected method handlePatchSend() {
      Matrix1000_Patch ulPatch <= data.patches.get(data.first_patch_nr);

      if(ulPatch.uploadToPatch(data.first_patch_nr))
      {
         Global.Success("Upload patch "+data.first_patch_nr);
      }

      // (todo) send first..last
   }

   // <ui_handle.png>
   protected method handlePatchCopy() {

      patch_clipboard.copyFrom(patch);

      Global.Print("Copy patch to clipboard");
   }

   // <ui_handle.png>
   protected method handlePatchPaste() {

      patch.copyFrom(patch_clipboard);

      updateUIFromPatch();

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }

      Global.Print("Paste patch clipboard");
   }

   // <ui_handle.png>
   protected method handlePatchInit() {

      Matrix1000_Patch initPatch <= data.patches.get(1000);

      patch.copyFrom(initPatch);

      updateUIFromPatch();

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }

      Global.Print("Initialize patch");
   }

   // <ui_handle.png>
   protected method handlePatchSaveInit() {

      Matrix1000_Patch initPatch <= data.patches.get(1000);

      initPatch.copyFrom(patch);

      Global.Print("Save Init patch");
   }

   // <method_update.png>
   protected method updatePatchByte(int _off, byte _byte) {
      Buffer pd <= patch.patch_data;
      Byte ioOld = pd.peekI8(_off);
      pd.pokeI8(_off, _byte & 127);
      String constName = TKS.scriptClassConstantToString(#(_off), Matrix1000_Defs, "OFF_");
      Byte io = _byte;
      Global.Print(constName+" is "+_byte+" ("+io.printf("$%02x")+", old="+ioOld.printf("$%02x")+")");
      scheduleMIDISendPatchAuto();
   }

   // <method_update.png>
   protected method updatePatchByteMask(int _off, byte _mask, boolean _bSet) {
      Buffer pd <= patch.patch_data;
      byte cur = pd.peekI8(_off);
      if(_bSet)
         cur |= _mask;
      else
         cur &= ~_mask;
      updatePatchByte(_off, cur);
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {

      Global.Debug2("Matrix1000::onKey: code="+_k.code+" pressed="+_k.pressed+" mod="+_k.mod);

      if(_k.modCtrl())
      {
         switch(_k.pressed)
         {
            case 's':
               Global.Debug("Matrix1000: send patch manually");
               queued_midi_patch_nr = 0;
               scheduleMIDISendPatch();
               return true;
         }
      }

      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      StringAction *sac;

      // trace "[trc] Matrix1000::consumeAction: acName="+acName+" ap="+#(ap);

      if(TA_MIDISEND == acName)
      {
         handleMIDISendTimer();
         return true;
      }

      switch(@(ap))
      {
         case @(cb_patch_autosend):
            handlePatchAutosendChanged();
            return true;

         case @(fp_patch_nr):
            handlePatchNrChanged();
            return true;

         case @(tf_patch_name):
            handlePatchNameChanged();
            return true;

         case @(cm_patch_category):
            handlePatchCategoryChanged();
            return true;

         case @(bt_patch_catprev):
            handlePatchCategoryPrev();
            return true;

         case @(bt_patch_catnext):
            handlePatchCategoryNext();
            return true;

         case @(cm_patch_voicemode):
            updatePatchByte(OFF_KEYBOARD_MODE, cm_patch_voicemode.getSelectedOption());
            return true;

         case @(fp_patch_nr_midi):
            handleMIDIPatchNrChanged();
            return true;

         case @(cb_patch_midi_follow):
            handlePatchMIDIFollowChanged();
            return true;

         case @(fp_patch_first):
            handlePatchFirstChanged();
            return true;

         case @(fp_patch_last):
            handlePatchLastChanged();
            return true;

         case @(bt_patch_receive):
            handlePatchReceive();
            return true;

         case @(bt_patch_send):
            handlePatchSend();
            return true;

         case @(bt_patch_copy):
            handlePatchCopy();
            return true;

         case @(bt_patch_paste):
            handlePatchPaste();
            return true;

         case @(bt_patch_init):
            handlePatchInit();
            return true;

         case @(bt_patch_saveinit):
            handlePatchSaveInit();
            return true;

            // DCO
         case @(cm_dco_sync):
            updatePatchByte(OFF_DCO_SYNC, cm_dco_sync.getSelectedOption());
            return true;

         case @(fp_dco2_detune):
            updatePatchByte(OFF_DCO2_DETUNE, fp_dco2_detune.getFloatValue());
            return true;

         case @(fp_dco_mix):
            updatePatchByte(OFF_MIX, fp_dco_mix.getFloatValue());
            return true;

         case @(cb_dco1_click):
            updatePatchByte(OFF_DCO1_CLICK, cb_dco1_click.isSelected());
            return true;

         case @(cb_dco1_sawtri):
            updatePatchByteMask(OFF_DCO1_WAVE_ENABLE, 2, cb_dco1_sawtri.isSelected());
            return true;

         case @(fp_dco1_shape):
            updatePatchByte(OFF_DCO1_INIT_SHAPE, fp_dco1_shape.getFloatValue());
            return true;

         case @(fp_dco1_freq):
            updatePatchByte(OFF_DCO1_INIT_FREQ, fp_dco1_freq.getFloatValue());
            return true;

         case @(cb_dco1_pulse):
            updatePatchByteMask(OFF_DCO1_WAVE_ENABLE, 1, cb_dco1_pulse.isSelected());
            return true;

         case @(fp_dco1_pw):
            updatePatchByte(OFF_DCO1_INIT_PW, fp_dco1_pw.getFloatValue());
            return true;

         case @(fp_dco1_lfo1amt):
            updatePatchByte(OFF_DCO1_FREQ_LFO1, fp_dco1_lfo1amt.getFloatValue());
            return true;

         case @(fp_dco1_lfo2amt):
            updatePatchByte(OFF_DCO1_PW_LFO2, fp_dco1_lfo2amt.getFloatValue());
            return true;

         case @(cb_dco1_portamento):
            updatePatchByteMask(OFF_DCO1_FIXMOD_2, 1, cb_dco1_portamento.isSelected());
            return true;

         case @(cb_dco1_vibrato):
            updatePatchByteMask(OFF_DCO1_FIXMOD, 2, cb_dco1_vibrato.isSelected());
            return true;

         case @(cb_dco1_lever1):
            updatePatchByteMask(OFF_DCO1_FIXMOD, 1, cb_dco1_lever1.isSelected());
            return true;

            // DCO2
         case @(cb_dco2_click):
            updatePatchByte(OFF_DCO2_CLICK, cb_dco2_click.isSelected());
            return true;

         case @(cb_dco2_sawtri):
            updatePatchByteMask(OFF_DCO2_WAVE_ENABLE, 2, cb_dco2_sawtri.isSelected());
            return true;

         case @(fp_dco2_shape):
            updatePatchByte(OFF_DCO2_INIT_SHAPE, fp_dco2_shape.getFloatValue());
            return true;

         case @(fp_dco2_freq):
            updatePatchByte(OFF_DCO2_INIT_FREQ, fp_dco2_freq.getFloatValue());
            return true;

         case @(cb_dco2_pulse):
            updatePatchByteMask(OFF_DCO2_WAVE_ENABLE, 1, cb_dco2_pulse.isSelected());
            return true;

         case @(cb_dco2_noise):
            updatePatchByteMask(OFF_DCO2_WAVE_ENABLE, 4, cb_dco2_noise.isSelected());
            return true;

         case @(fp_dco2_pw):
            updatePatchByte(OFF_DCO2_INIT_PW, fp_dco2_pw.getFloatValue());
            return true;

         case @(fp_dco2_lfo1amt):
            updatePatchByte(OFF_DCO2_FREQ_LFO1, fp_dco2_lfo1amt.getFloatValue());
            return true;

         case @(fp_dco2_lfo2amt):
            updatePatchByte(OFF_DCO2_PW_LFO2, fp_dco2_lfo2amt.getFloatValue());
            return true;

         case @(cb_dco2_portamento):
            updatePatchByteMask(OFF_DCO2_FIXMOD_2, 1, cb_dco2_portamento.isSelected());
            return true;

         case @(cb_dco2_vibrato):
            updatePatchByteMask(OFF_DCO2_FIXMOD, 2, cb_dco2_vibrato.isSelected());
            return true;

         case @(cb_dco2_lever1):
            updatePatchByteMask(OFF_DCO2_FIXMOD, 1, cb_dco2_lever1.isSelected());
            return true;

            // Env1 (filter)
         case @(fp_env1_fmenv3):
            updatePatchByte(OFF_VCF_FM_AMT_ENV3, fp_env1_fmenv3.getFloatValue());
            return true;

         case @(fp_env1_fmpressure):
            updatePatchByte(OFF_VCF_FM_AMT_PRESS, fp_env1_fmpressure.getFloatValue());
            return true;

         case @(fp_env1_fm):
            updatePatchByte(OFF_VCF_FM_INIT_AMT, fp_env1_fm.getFloatValue());
            return true;

         case @(fp_env1_res):
            updatePatchByte(OFF_VCF_INIT_RES, fp_env1_res.getFloatValue());
            return true;

         case @(fp_env1_velocity):
            updatePatchByte(OFF_ENV1_AMP_VEL, fp_env1_velocity.getFloatValue());
            return true;

         case @(fp_env1_pressure):
            updatePatchByte(OFF_VCF_FREQ_PRESS, fp_env1_pressure.getFloatValue());
            return true;

         case @(fp_env1_amount):
            updatePatchByte(OFF_VCF_FREQ_ENV1, fp_env1_amount.getFloatValue());
            return true;

         case @(fp_env1_cutoff):
            updatePatchByte(OFF_VCF_INIT_FREQ, fp_env1_cutoff.getFloatValue());
            return true;

         case @(cb_env1_key):
            updatePatchByteMask(OFF_VCF_KEYMOD, 2, cb_env1_key.isSelected());
            return true;

         case @(cb_env1_portamento):
            updatePatchByteMask(OFF_VCF_KEYMOD, 1, cb_env1_portamento.isSelected());
            return true;

         case @(cb_env1_vibrato):
            updatePatchByteMask(OFF_VCF_FIXMOD, 2, cb_env1_vibrato.isSelected());
            return true;

         case @(cb_env1_pb):
            updatePatchByteMask(OFF_VCF_FIXMOD, 1, cb_env1_pb.isSelected());
            return true;

         case @(fp_env1_release):
            updatePatchByte(OFF_ENV1_INIT_RELEASE, fp_env1_release.getFloatValue());
            return true;

         case @(fp_env1_sustain):
            updatePatchByte(OFF_ENV1_SUSTAIN, fp_env1_sustain.getFloatValue());
            return true;

         case @(fp_env1_decay):
            updatePatchByte(OFF_ENV1_INIT_DECAY, fp_env1_decay.getFloatValue());
            return true;

         case @(fp_env1_attack):
            updatePatchByte(OFF_ENV1_INIT_ATTACK, fp_env1_attack.getFloatValue());
            return true;

         case @(fp_env1_level):
            updatePatchByte(OFF_ENV1_INIT_AMP, fp_env1_level.getFloatValue());
            return true;

         case @(fp_env1_delay):
            updatePatchByte(OFF_ENV1_INIT_DELAY, fp_env1_delay.getFloatValue());
            return true;

         case @(cb_env1_free):
            updatePatchByteMask(OFF_ENV1_MODE, 2, cb_env1_free.isSelected());
            return true;

         case @(cb_env1_dadr):
            updatePatchByteMask(OFF_ENV1_MODE, 1, cb_env1_dadr.isSelected());
            return true;

         case @(cb_env1_lfotrig):
            updatePatchByteMask(OFF_ENV1_LFO_TRIG, 2, cb_env1_lfotrig.isSelected());
            return true;

         case @(cb_env1_lfogate):
            updatePatchByteMask(OFF_ENV1_LFO_TRIG, 1, cb_env1_lfogate.isSelected());
            return true;

         case @(cb_env1_ext):
            updatePatchByteMask(OFF_ENV1_TRIG_MODE, 4, cb_env1_ext.isSelected());
            return true;

         case @(cb_env1_multitrig):
            updatePatchByteMask(OFF_ENV1_TRIG_MODE, 2, cb_env1_multitrig.isSelected());
            return true;

         case @(cb_env1_reset):
            updatePatchByteMask(OFF_ENV1_TRIG_MODE, 1, cb_env1_reset.isSelected());
            return true;

            // Env2 (amp)
         case @(fp_env2_velocity):
            updatePatchByte(OFF_ENV2_AMP_VEL, fp_env2_velocity.getFloatValue());
            return true;

         case @(fp_env2_amount):
            updatePatchByte(OFF_VCA2_ENV2, fp_env2_amount.getFloatValue());
            return true;

         case @(fp_env2_vca1velocity):
            updatePatchByte(OFF_VCA1_VEL, fp_env2_vca1velocity.getFloatValue());
            return true;

         case @(fp_env2_vca1amount):
            updatePatchByte(OFF_VCA1_INIT_AMT, fp_env2_vca1amount.getFloatValue());
            return true;

         case @(fp_env2_release):
            updatePatchByte(OFF_ENV2_INIT_RELEASE, fp_env2_release.getFloatValue());
            return true;

         case @(fp_env2_sustain):
            updatePatchByte(OFF_ENV2_SUSTAIN, fp_env2_sustain.getFloatValue());
            return true;

         case @(fp_env2_decay):
            updatePatchByte(OFF_ENV2_INIT_DECAY, fp_env2_decay.getFloatValue());
            return true;

         case @(fp_env2_attack):
            updatePatchByte(OFF_ENV2_INIT_ATTACK, fp_env2_attack.getFloatValue());
            return true;

         case @(fp_env2_level):
            updatePatchByte(OFF_ENV2_INIT_AMP, fp_env2_level.getFloatValue());
            return true;

         case @(fp_env2_delay):
            updatePatchByte(OFF_ENV2_INIT_DELAY, fp_env2_delay.getFloatValue());
            return true;

         case @(cb_env2_free):
            updatePatchByteMask(OFF_ENV2_MODE, 2, cb_env2_free.isSelected());
            return true;

         case @(cb_env2_dadr):
            updatePatchByteMask(OFF_ENV2_MODE, 1, cb_env2_dadr.isSelected());
            return true;

         case @(cb_env2_lfotrig):
            updatePatchByteMask(OFF_ENV2_LFO_TRIG, 2, cb_env2_lfotrig.isSelected());
            return true;

         case @(cb_env2_lfogate):
            updatePatchByteMask(OFF_ENV2_LFO_TRIG, 1, cb_env2_lfogate.isSelected());
            return true;

         case @(cb_env2_ext):
            updatePatchByteMask(OFF_ENV2_TRIG_MODE, 4, cb_env2_ext.isSelected());
            return true;

         case @(cb_env2_multitrig):
            updatePatchByteMask(OFF_ENV2_TRIG_MODE, 2, cb_env2_multitrig.isSelected());
            return true;

         case @(cb_env2_reset):
            updatePatchByteMask(OFF_ENV2_TRIG_MODE, 1, cb_env2_reset.isSelected());
            return true;

            // Env3 (aux)
         case @(fp_env3_velocity):
            updatePatchByte(OFF_ENV3_AMP_VEL, fp_env3_velocity.getFloatValue());
            return true;

         case @(fp_env3_release):
            updatePatchByte(OFF_ENV3_INIT_RELEASE, fp_env3_release.getFloatValue());
            return true;

         case @(fp_env3_sustain):
            updatePatchByte(OFF_ENV3_SUSTAIN, fp_env3_sustain.getFloatValue());
            return true;

         case @(fp_env3_decay):
            updatePatchByte(OFF_ENV3_INIT_DECAY, fp_env3_decay.getFloatValue());
            return true;

         case @(fp_env3_attack):
            updatePatchByte(OFF_ENV3_INIT_ATTACK, fp_env3_attack.getFloatValue());
            return true;

         case @(fp_env3_level):
            updatePatchByte(OFF_ENV3_INIT_AMP, fp_env3_level.getFloatValue());
            return true;

         case @(fp_env3_delay):
            updatePatchByte(OFF_ENV3_INIT_DELAY, fp_env3_delay.getFloatValue());
            return true;

         case @(cb_env3_free):
            updatePatchByteMask(OFF_ENV3_MODE, 2, cb_env3_free.isSelected());
            return true;

         case @(cb_env3_dadr):
            updatePatchByteMask(OFF_ENV3_MODE, 1, cb_env3_dadr.isSelected());
            return true;

         case @(cb_env3_lfotrig):
            updatePatchByteMask(OFF_ENV3_LFO_TRIG, 2, cb_env3_lfotrig.isSelected());
            return true;

         case @(cb_env3_lfogate):
            updatePatchByteMask(OFF_ENV3_LFO_TRIG, 1, cb_env3_lfogate.isSelected());
            return true;

         case @(cb_env3_ext):
            updatePatchByteMask(OFF_ENV3_TRIG_MODE, 4, cb_env3_ext.isSelected());
            return true;

         case @(cb_env3_multitrig):
            updatePatchByteMask(OFF_ENV3_TRIG_MODE, 2, cb_env3_multitrig.isSelected());
            return true;

         case @(cb_env3_reset):
            updatePatchByteMask(OFF_ENV3_TRIG_MODE, 1, cb_env3_reset.isSelected());
            return true;

            // LFO1
         case @(cm_lfo1_trig):
            updatePatchByte(OFF_LFO1_TRIG, cm_lfo1_trig.getSelectedOption() & 3);
            return true;

         case @(cb_lfo1_lag):
            updatePatchByte(OFF_LFO1_LAG, cb_lfo1_lag.isSelected());
            return true;

         case @(fp_lfo1_retrig):
            updatePatchByte(OFF_LFO1_RETRIG, fp_lfo1_retrig.getFloatValue());
            return true;

         case @(cm_lfo1_shape):
            updatePatchByte(OFF_LFO1_SHAPE, cm_lfo1_shape.getSelectedOption());
            return true;

         case @(fp_lfo1_amp):
            updatePatchByte(OFF_LFO1_INIT_AMP, fp_lfo1_amp.getFloatValue());
            return true;

         case @(fp_lfo1_speed):
            updatePatchByte(OFF_LFO1_INIT_SPEED, fp_lfo1_speed.getFloatValue());
            return true;

         case @(fp_lfo1_speedpressure):
            updatePatchByte(OFF_LFO1_SPEED_PRESS, fp_lfo1_speedpressure.getFloatValue());
            return true;

         case @(fp_lfo1_ramp1amp):
            updatePatchByte(OFF_LFO1_AMP_RAMP1, fp_lfo1_ramp1amp.getFloatValue());
            return true;

         case @(cm_lfo1_smpsrc):
            updatePatchByte(OFF_LFO1_SMPSRC, cm_lfo1_smpsrc.getSelectedOption());
            return true;

            // LFO2
         case @(cm_lfo2_trig):
            updatePatchByte(OFF_LFO2_TRIG, cm_lfo2_trig.getSelectedOption() & 3);
            return true;

         case @(cb_lfo2_lag):
            updatePatchByte(OFF_LFO2_LAG, cb_lfo2_lag.isSelected());
            return true;

         case @(fp_lfo2_retrig):
            updatePatchByte(OFF_LFO2_RETRIG, fp_lfo2_retrig.getFloatValue());
            return true;

         case @(cm_lfo2_shape):
            updatePatchByte(OFF_LFO2_SHAPE, cm_lfo2_shape.getSelectedOption());
            return true;

         case @(fp_lfo2_amp):
            updatePatchByte(OFF_LFO2_INIT_AMP, fp_lfo2_amp.getFloatValue());
            return true;

         case @(fp_lfo2_speed):
            updatePatchByte(OFF_LFO2_INIT_SPEED, fp_lfo2_speed.getFloatValue());
            return true;

         case @(fp_lfo2_speedkeyboard):
            updatePatchByte(OFF_LFO2_SPEED_KBD, fp_lfo2_speedkeyboard.getFloatValue());
            return true;

         case @(fp_lfo2_ramp2amp):
            updatePatchByte(OFF_LFO2_AMP_RAMP2, fp_lfo2_ramp2amp.getFloatValue());
            return true;

         case @(cm_lfo2_smpsrc):
            updatePatchByte(OFF_LFO2_SMPSRC, cm_lfo2_smpsrc.getSelectedOption());
            return true;

            // Trk/Rmp/Lag
         case @(cm_ramp1_mode):
            updatePatchByte(OFF_RAMP1_MODE, cm_ramp1_mode.getSelectedOption());
            return true;

         case @(fp_ramp1_rate):
            updatePatchByte(OFF_RAMP1_RATE, fp_ramp1_rate.getFloatValue());
            return true;

         case @(cm_ramp2_mode):
            updatePatchByte(OFF_RAMP2_MODE, cm_ramp2_mode.getSelectedOption());
            return true;

         case @(fp_ramp2_rate):
            updatePatchByte(OFF_RAMP2_RATE, fp_ramp2_rate.getFloatValue());
            return true;

         case @(fp_trk_p5):
            updatePatchByte(OFF_TRK_P5, fp_trk_p5.getFloatValue());
            return true;

         case @(fp_trk_p4):
            updatePatchByte(OFF_TRK_P4, fp_trk_p4.getFloatValue());
            return true;

         case @(fp_trk_p3):
            updatePatchByte(OFF_TRK_P3, fp_trk_p3.getFloatValue());
            return true;

         case @(fp_trk_p2):
            updatePatchByte(OFF_TRK_P2, fp_trk_p2.getFloatValue());
            return true;

         case @(fp_trk_p1):
            updatePatchByte(OFF_TRK_P1, fp_trk_p1.getFloatValue());
            return true;

         case @(cm_trk_src):
            updatePatchByte(OFF_TRK_SRC, cm_trk_src.getSelectedOption() + 1);
            return true;

         case @(cb_trk_legato):
            updatePatchByte(OFF_PORTA_LEGATO, cb_trk_legato.isSelected());
            return true;

         case @(fp_trk_lagvelrate):
            updatePatchByte(OFF_PORTA_RATE_VEL, fp_trk_lagvelrate.getFloatValue());
            return true;

         case @(fp_trk_lagrate):
            updatePatchByte(OFF_PORTA_INIT_RATE, fp_trk_lagrate.getFloatValue());
            return true;

         case @(cm_trk_lagmode):
            updatePatchByte(OFF_LAG_MODE, cm_trk_lagmode.getSelectedOption());
            return true;

            // Mod Bus 0
         case @(fp_mod0_amount):
            updatePatchByte(OFF_MOD0_AMT, fp_mod0_amount.getFloatValue());
            return true;

         case @(cm_mod0_dst):
            updatePatchByte(OFF_MOD0_DST, cm_mod0_dst.getSelectedOption());
            return true;

         case @(cm_mod0_src):
            updatePatchByte(OFF_MOD0_SRC, cm_mod0_src.getSelectedOption());
            return true;

            // Mod Bus 1
         case @(fp_mod1_amount):
            updatePatchByte(OFF_MOD1_AMT, fp_mod1_amount.getFloatValue());
            return true;

         case @(cm_mod1_dst):
            updatePatchByte(OFF_MOD1_DST, cm_mod1_dst.getSelectedOption());
            return true;

         case @(cm_mod1_src):
            updatePatchByte(OFF_MOD1_SRC, cm_mod1_src.getSelectedOption());
            return true;

            // Mod Bus 2
         case @(fp_mod2_amount):
            updatePatchByte(OFF_MOD2_AMT, fp_mod2_amount.getFloatValue());
            return true;

         case @(cm_mod2_dst):
            updatePatchByte(OFF_MOD2_DST, cm_mod2_dst.getSelectedOption());
            return true;

         case @(cm_mod2_src):
            updatePatchByte(OFF_MOD2_SRC, cm_mod2_src.getSelectedOption());
            return true;

            // Mod Bus 3
         case @(fp_mod3_amount):
            updatePatchByte(OFF_MOD3_AMT, fp_mod3_amount.getFloatValue());
            return true;

         case @(cm_mod3_dst):
            updatePatchByte(OFF_MOD3_DST, cm_mod3_dst.getSelectedOption());
            return true;

         case @(cm_mod3_src):
            updatePatchByte(OFF_MOD3_SRC, cm_mod3_src.getSelectedOption());
            return true;

            // Mod Bus 4
         case @(fp_mod4_amount):
            updatePatchByte(OFF_MOD4_AMT, fp_mod4_amount.getFloatValue());
            return true;

         case @(cm_mod4_dst):
            updatePatchByte(OFF_MOD4_DST, cm_mod4_dst.getSelectedOption());
            return true;

         case @(cm_mod4_src):
            updatePatchByte(OFF_MOD4_SRC, cm_mod4_src.getSelectedOption());
            return true;

            // Mod Bus 5
         case @(fp_mod5_amount):
            updatePatchByte(OFF_MOD5_AMT, fp_mod5_amount.getFloatValue());
            return true;

         case @(cm_mod5_dst):
            updatePatchByte(OFF_MOD5_DST, cm_mod5_dst.getSelectedOption());
            return true;

         case @(cm_mod5_src):
            updatePatchByte(OFF_MOD5_SRC, cm_mod5_src.getSelectedOption());
            return true;

            // Mod Bus 6
         case @(fp_mod6_amount):
            updatePatchByte(OFF_MOD6_AMT, fp_mod6_amount.getFloatValue());
            return true;

         case @(cm_mod6_dst):
            updatePatchByte(OFF_MOD6_DST, cm_mod6_dst.getSelectedOption());
            return true;

         case @(cm_mod6_src):
            updatePatchByte(OFF_MOD6_SRC, cm_mod6_src.getSelectedOption());
            return true;

            // Mod Bus 7
         case @(fp_mod7_amount):
            updatePatchByte(OFF_MOD7_AMT, fp_mod7_amount.getFloatValue());
            return true;

         case @(cm_mod7_dst):
            updatePatchByte(OFF_MOD7_DST, cm_mod7_dst.getSelectedOption());
            return true;

         case @(cm_mod7_src):
            updatePatchByte(OFF_MOD7_SRC, cm_mod7_src.getSelectedOption());
            return true;

            // Mod Bus 8
         case @(fp_mod8_amount):
            updatePatchByte(OFF_MOD8_AMT, fp_mod8_amount.getFloatValue());
            return true;

         case @(cm_mod8_dst):
            updatePatchByte(OFF_MOD8_DST, cm_mod8_dst.getSelectedOption());
            return true;

         case @(cm_mod8_src):
            updatePatchByte(OFF_MOD8_SRC, cm_mod8_src.getSelectedOption());
            return true;

            // Mod Bus 9
         case @(fp_mod9_amount):
            updatePatchByte(OFF_MOD9_AMT, fp_mod9_amount.getFloatValue());
            return true;

         case @(cm_mod9_dst):
            updatePatchByte(OFF_MOD9_DST, cm_mod9_dst.getSelectedOption());
            return true;

         case @(cm_mod9_src):
            updatePatchByte(OFF_MOD9_SRC, cm_mod9_src.getSelectedOption());
            return true;
      }

      return XMLForm::consumeAction(_action);
   }

}


// <debug.png>
// function Test_Matrix1000() {
//    // Called from RootForm.onKey() (F11)

//    Matrix1000 m1k;
//    trace "\n\n\n-- BEGIN Test_Matrix1000 --------------------------------------";

//    if(m1k.init(MIDI.GetMIDIInDeviceByAliasOrName("MIDISPORT 4x4 Anniversary In B"),
//                MIDI.GetMIDIOutDeviceByAliasOrName("MIDISPORT 4x4 Anniversary Out B"),
//                0/*midiCh*/
//                )
//       )
//    {
//       m1k.enter();

//       Matrix1000_Patch patch <= m1k.newPatch();
//       if(patch.downloadPatch(648))
//          //if(patch.downloadPatch(0))
//       {
//          //////patch.uploadToEditBuffer();
//          patch.uploadToPatch(0);
//       }

//       m1k.leave();
//    }
//    trace "-- END Test_Matrix1000 ----------------------------------------\n\n\n";
// }
