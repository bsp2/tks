// ----
// ---- file   : NodeAnalogRytm.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2016-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----          also see: <http://wolzow.mindworks.ee/analog/m1k-midi-spec.htm>
// ----
// ---- changed: 27Feb2016, 28Feb2016, 29Feb2016, 01Mar2016, 02Mar2016, 03Mar2016, 04Mar2016
// ----          05Mar2016, 06Mar2016, 07Mar2016, 08Mar2016, 09Mar2016, 13Mar2016, 29Mar2016
// ----          31Mar2016, 04Apr2016, 09Apr2016, 09Jul2016, 12Jul2016, 24Nov2016, 21Jan2017
// ----          15Apr2017, 07Jul2017, 08Jul2017, 09Jul2017, 21Aug2017, 03Sep2017, 04Jan2018
// ----          07Mar2018, 17Jun2018, 31Mar2019, 18May2019, 21Oct2019, 25Oct2019, 27Oct2019
// ----          28Oct2019, 05Nov2019, 07Nov2019, 20Feb2020, 26Oct2020, 10Nov2020, 21Jun2021
// ----          28Jul2021, 01Jan2022, 25Nov2022, 25Sep2023, 24Nov2023, 25Nov2023, 26Nov2023
// ----          27Nov2023, 01Dec2023, 02Dec2023, 14Mar2025
// ----
// ----
// ----
module MNodeAnalogRytm;

use namespace ui;
use namespace st2;

boolean b_debug_diff = true;
//boolean b_debug_diff = false;

// boolean b_debug_sendrecv = true;
boolean b_debug_sendrecv = false;


// <class.png>
class NAR_Base {
   int uid;
   String name;

   public method getUIDDecHexString() : String {
      Integer io = uid;
      String r = uid + " / "+io.printf("0x%x");
      return r;
   }
}


// <class.png>
class NAR_Pattern : NAR_Base {

   AR_Pattern *ar_pattern;

   static StringArray state_names = [ "-", "SYX", "RAW" ];

   byte remote_pattern_nr;


   // <method_init.png>
   public method init() {
      ar_pattern <= new AR_Pattern;

      name = "new pattern "+Utils.GetCurrentDateTimeStringNumeric();

      uid = -1;

      remote_pattern_nr = 127;
   }

   // <method.png>
   public method copyFrom(NAR_Pattern _o) {
      name              = _o.name;
      ar_pattern        = _o.ar_pattern;
      remote_pattern_nr = _o.remote_pattern_nr;
   }

   // <method_get.png>
   public method getCurrentStateName() : String {
      return state_names.get(ar_pattern.getCurrentDataIdx());
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 3;

      // Write UID (v3+)
      _ofs.i32 = uid;

      // Write pattern name
      Utils.WriteString(_ofs, name);

      byte curDataIdx = ar_pattern.getCurrentDataIdx();
      _ofs.i8 = curDataIdx;

      switch(curDataIdx)
      {
         default:
            break;

         case 1: // syx
            ar_pattern.saveSyxToStream(_ofs);
            break;

         case 2: // raw
            ar_pattern.saveRawToStream(_ofs);
            break;
      }

      // Write remote pattern nr (v2+)
      _ofs.i8 = remote_pattern_nr;
   }

   // <load.png>
   public method loadState(Stream _ifs) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Read UID (v3+)
         if(ver >= 3)
         {
            uid = _ifs.i32;
         }

         // Read pattern name
         Utils.ReadString(_ifs, name);

         byte curDataIdx = _ifs.s8;

         switch(curDataIdx)
         {
            default:
               break;

            case 1: // syx
               if(!ar_pattern.loadSyxFromStream(_ifs))
               {
                  trace "[---] NAR_Pattern::loadState: failed to read syx.";
                  return false;
               }
               break;

            case 2: // raw
               if(!ar_pattern.loadRawFromStream(_ifs))
               {
                  trace "[---] NAR_Pattern::loadState: failed to read raw.";
                  return false;
               }
               break;
         }

         if(ver >= 2)
         {
            remote_pattern_nr = _ifs.u8 & 127;
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] NAR_Pattern::loadState: bad ver="+ver;
      }

      return false;
   }
}


// <class.png>
class NAR_Kit : NAR_Base {

   AR_Kit *ar_kit;

   byte remote_kit_nr;

   static StringArray state_names = [ "-", "SYX", "RAW" ];


   // <method_init.png>
   public method init() {

      uid = -1;

      name = "new kit "+Utils.GetCurrentDateTimeStringNumeric();

      ar_kit <= new AR_Kit;

      remote_kit_nr = 127;
   }

   // <method.png>
   public method copyFrom(NAR_Kit _o) {
      name          = _o.name;
      ar_kit        = _o.ar_kit;
      remote_kit_nr = _o.remote_kit_nr;
   }

   // <method_get.png>
   public method getCurrentStateName() : String {
      return state_names.get(ar_kit.getCurrentDataIdx());
   }

   // <method.png>
   public method debugPrintNames() {
      if(2/*RAW*/ == ar_kit.currentDataIdx)
      {
         int trackIdx = 0;
         local AR_Sound arSound;
         loop(12)
         {
            if(ar_kit.getSoundRefByIndex(trackIdx, arSound))
            {
               trace "[...] NAR_Kit: track["+trackIdx+"] machine=\""+arSound.machineName+"\"";
               int paramIdx = 0;
               loop(8)
               {
                  trace "[...] NAR_Kit: track["+trackIdx+"] machine_param["+paramIdx+"]=\""+arSound.getMachineParamShortName(paramIdx)+"\"";
                  paramIdx++;
               }
               trace "[...] NAR_Kit: track["+trackIdx+"] lfo_dest=\""+arSound.lfoDestName+"\"";
            }

            // Next track sound
            trackIdx++;
         }
      }
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 3;

      // Write UID (v3+)
      _ofs.i32 = uid;

      // Write kit name
      Utils.WriteString(_ofs, name);

      byte curDataIdx = ar_kit.getCurrentDataIdx();
      _ofs.i8 = curDataIdx;

      switch(curDataIdx)
      {
         default:
            break;

         case 1: // syx
            ar_kit.saveSyxToStream(_ofs);
            break;

         case 2: // raw
            ar_kit.saveRawToStream(_ofs);
            break;
      }

      // Write remote kit nr (v2+)
      _ofs.i8 = remote_kit_nr;

   }

   // <load.png>
   public method loadState(Stream _ifs) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         if(ver >= 3)
         {
            uid = _ifs.i32;
         }

         // Read kit name
         Utils.ReadString(_ifs, name);

         byte curDataIdx = _ifs.s8;

         switch(curDataIdx)
         {
            default:
               break;

            case 1: // syx
               if(!ar_kit.loadSyxFromStream(_ifs))
               {
                  trace "[---] NAR_Kit::loadState: failed to read syx.";
                  return false;
               }
               break;

            case 2: // raw
               if(!ar_kit.loadRawFromStream(_ifs))
               {
                  trace "[---] NAR_Kit::loadState: failed to read raw.";
                  return false;
               }
               break;
         }

         if(ver >= 2)
         {
            remote_kit_nr = _ifs.u8 & 127;
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] NAR_Kit::loadState: bad ver="+ver;
      }

      return false;
   }
}


// <class.png>
class NAR_Mute : NAR_Base {

   IntArray mute_state; // 12 entries (boolean), 1=muted, 0=unmuted


   // <method_init.png>
   public method init() {

      mute_state.allocAndFill(12, false);

      name = "new mute "+Utils.GetCurrentDateTimeStringNumeric();

      uid = -1;
   }

   // <method.png>
   public method copyFrom(NAR_Mute _o) {
      name        = _o.name;
      mute_state  = _o.mute_state;
   }

   // <method_get.png>
   public method getStateString() : String {

      int trkIdx = 8;
      String r = "";

      loop(3)
      {
         int x =0;

         loop(4)
         {
            if(x++ > 0)
               r.append("  ");

            r.append(NAR_Defs.track_names_short.get(trkIdx));
            r.append(": ");

            if(mute_state.get(trkIdx++))
               r.append("X");
            else
               r.append(".");
         }

         if(trkIdx == 12)
            r.append("\n");
         else if(trkIdx == 8)
            r.append("\n");

         trkIdx -= 8;
      }

      return r;
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 1;

      // Write UID
      _ofs.i32 = uid;

      // Write mute state name
      Utils.WriteString(_ofs, name);

      // Write mute states
      Utils.WriteIntArray(_ofs, mute_state);
   }

   // <load.png>
   public method loadState(Stream _ifs) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Read UID
         uid = _ifs.i32;

         // Read mute state name
         Utils.ReadString(_ifs, name);

         // Read mute states
         Utils.ReadIntArray(_ifs, mute_state);

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] NAR_Mute::loadState: bad ver="+ver;
      }

      return false;
   }
}


// <class.png>
class NAR_Perf : NAR_Base {

   IntArray perf_state; // 12 entries (0..127, -1=unused)


   // <method_init.png>
   public method init() {

      perf_state.allocAndFill(12, -1);

      name = "new perf "+Utils.GetCurrentDateTimeStringNumeric();

      uid = -1;
   }

   // <method_get.png>
   public method getStateString() : String {

      int perfIdx = 0;
      int numUsed = 0;

      loop(12)
      {
         if(perf_state.get(perfIdx++) >= 0)
            numUsed++;
      }

      return numUsed+" ctl"+ (((0 == numUsed) || (numUsed > 1)) ? "s" : "");
   }

   // <method.png>
   public method copyFrom(NAR_Perf _o) {
      name        = _o.name;
      perf_state  = _o.perf_state;
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 1;

      // Write UID
      _ofs.i32 = uid;

      // Write perf state name
      Utils.WriteString(_ofs, name);

      // Write perf states
      Utils.WriteIntArray(_ofs, perf_state);
   }

   // <load.png>
   public method loadState(Stream _ifs) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Read UID
         uid = _ifs.i32;

         // Read perf state name
         Utils.ReadString(_ifs, name);

         // Read perf states
         Utils.ReadIntArray(_ifs, perf_state);

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] NAR_Perf::loadState: bad ver="+ver;
      }

      return false;
   }
}


// <class.png>
class NAR_MapAction {

   boolean b_enable;

   String name;
   boolean b_name_edited;

   define int AC_SNAPSHOT_SELECT      =  0;  // arg1=snapshot nr
   define int AC_SNAPSHOT_SELECT_PREV =  1;  //
   define int AC_SNAPSHOT_SELECT_NEXT =  2;  //
   define int AC_PAT_SELECT           =  3;  // arg1=pat uid
   define int AC_PAT_SELECT_PREV      =  4;  //
   define int AC_PAT_SELECT_NEXT      =  5;  //
   define int AC_PAT_RECV             =  6;  // arg1=pat uid, 0=use current
   define int AC_PAT_SEND             =  7;  // arg1=pat uid, 0=use current
   define int AC_KIT_SELECT           =  8;  // arg1=kit uid
   define int AC_KIT_SELECT_PREV      =  9;  //
   define int AC_KIT_SELECT_NEXT      = 10;  //
   define int AC_KIT_RECV             = 11;  // arg1=kit uid, 0=use current
   define int AC_KIT_SEND             = 12;  // arg1=kit uid, 0=use current
   define int AC_MUTE_SELECT          = 13;  // arg1=mute uid
   define int AC_MUTE_SELECT_PREV     = 14;  //
   define int AC_MUTE_SELECT_NEXT     = 15;  //
   define int AC_MUTE_STORE           = 16;  // arg1=mute uid, 0=use current
   define int AC_MUTE_RECALL          = 17;  // arg1=mute uid, 0=use current
   define int AC_MUTE                 = 18;  // arg1=tracknr (1..12)
   define int AC_UNMUTE               = 19;  // arg1=tracknr (1..12)
   define int AC_MUTE_TOGGLE          = 20;  // arg1=tracknr (1..12) (v3+)
   define int AC_PERF_SELECT          = 21;  // arg1=perf uid
   define int AC_PERF_SELECT_PREV     = 22;  //
   define int AC_PERF_SELECT_NEXT     = 23;  //
   define int AC_PERF_STORE           = 24;  // arg1=perf uid, 0=use current
   define int AC_PERF_RECALL          = 25;  // arg1=perf uid, 0=use current
   define int AC_PERF_TRANSITION      = 26;  // arg1=transition target (uid), arg2=transition time in 16ths, (todo) arg3=curve type
   define int AC_SCENE_SELECT         = 27;  // arg1=scene nr (0..11)
   define int AC_GROUP_SELECT         = 28;  // arg1=grp uid
   define int AC_GROUP_SELECT_PREV    = 29;  //
   define int AC_GROUP_SELECT_NEXT    = 30;  //
   define int AC_EXT_PRGCHG           = 31;  // arg1=prg#
   define int AC_EXT_NOTEON           = 32;  // arg1=note#, arg2=velocity, arg3=duration
   define int AC_EXT_NOTEOFF          = 33;  // arg1=note#, arg2=velocity
   define int AC_EXT_CC               = 34;  // arg1=cc#, arg2=ccval
   define int AC_EXT_NRPN             = 35;  // arg1=nrpn#, arg2=nrpnval

   static StringArray action_names = [
      "Snapshot Select",        //  0
      "Snapshot Previous",      //  1
      "Snapshot Next",          //  2
      "Pattern Select",         //  3
      "Pattern Previous",       //  4
      "Pattern Next",           //  5
      "Pattern Receive",        //  6
      "Pattern Send",           //  7
      "Kit Select",             //  8
      "Kit Previous",           //  9
      "Kit Next",               // 10
      "Kit Receive",            // 11
      "Kit Send",               // 12
      "Mute State Select",      // 13
      "Mute State Previous",    // 14
      "Mute State Next",        // 15
      "Mute State Store",       // 16
      "Mute State Recall",      // 17
      "Mute Track",             // 18
      "Unmute Track",           // 19
      "Toggle Mute Track",      // 20
      "Perf. State Select",     // 21
      "Perf. State Previous",   // 22
      "Perf. State Next",       // 23
      "Perf. State Store",      // 24
      "Perf. State Recall",     // 25
      "Perf. State Transition", // 26
      "Scene Select",           // 27
      "Group Select",           // 28
      "Group Previous",         // 29
      "Group Next",             // 30
      "Ext: Program Change",    // 31
      "Ext: Note On",           // 32
      "Ext: Note off",          // 33
      "Ext: CC",                // 34
      "Ext: NRPN"               // 35
                                      ];

   int action_id;

   float action_arg1;  // e.g. pat/kit nr, transition target, or CC/note#
   float action_arg2;  // e.g. transition time (16ths), or note velocity, or CC/NRPN value
   float action_arg3;  // note duration (#16ths)

   float quantization;  // #16th, 0=off
   float duration;      // #16th, 0=off

   int ext_dev_idx;
   int ext_midi_ch;


   // <method_init.png>
   public method init() {
      b_enable = true;

      name = "new action "+Utils.GetCurrentDateTimeStringNumeric();

      action_id   = AC_KIT_SEND;
      action_arg1 = 127;
      action_arg2 = 100;
      action_arg3 = 0.25; // 1/64th

      quantization = 0;
      duration = 0;

      ext_dev_idx = -1;
      ext_midi_ch = 0;
   }

   // <method.png>
   public method copyFrom(NAR_MapAction _o) {
      b_enable        = _o.b_enable;
      name            = _o.name;
      b_name_edited   = _o.b_name_edited;
      action_id       = _o.action_id;
      action_arg1     = _o.action_arg1;
      action_arg2     = _o.action_arg2;
      action_arg3     = _o.action_arg3;
      quantization    = _o.quantization;
      duration        = _o.duration;
      ext_dev_idx     = _o.ext_dev_idx;
      ext_midi_ch     = _o.ext_midi_ch;
   }

   // <method_set.png>
   public =replay= method setEnable(boolean _bEnable) {
      b_enable = _bEnable;
   }

   // <method_get.png>
   public method getActionString() : String {
      // for TM
      return action_names.get(action_id);
   }

   // <method_set.png>
   public =replay= method setActionId(int _actionId) {
      action_id = _actionId;
   }

   // <method_set.png>
   public =replay= method setActionArg1(float _actionArg1) {
      action_arg1 = _actionArg1;
   }

   // <method_set.png>
   public =replay= method setActionArg2(float _actionArg2) {
      action_arg2 = _actionArg2;
   }

   // <method_set.png>
   public =replay= method setActionArg3(float _actionArg3) {
      action_arg3 = _actionArg3;
   }

   // <method_set.png>
   public =replay= method setExtDevIdx(int _devIdx) {
      ext_dev_idx = _devIdx;
   }

   // <method_set.png>
   public =replay= method setExtMidiCh(byte _ch) {
      ext_midi_ch = _ch;
   }

   // <method.png>
   public method replaceKitUID(int _oldUID, int _newUID) {
      switch(action_id)
      {
         case AC_KIT_SELECT: // arg1=kit uid
         case AC_KIT_RECV:   // arg1=kit uid, 0=use current
         case AC_KIT_SEND:   // arg1=kit uid, 0=use current
            if(_oldUID == action_arg1)
            {
               Global.Debug("NAR_MapAction::replaceKitUID: old="+_oldUID+" new="+_newUID);
               action_arg1 = _newUID;
            }
            break;

         case AC_KIT_SELECT_PREV:
         case AC_KIT_SELECT_NEXT:
            break;
      }
   }

   // <method.png>
   public method replacePatternUID(int _oldUID, int _newUID) {
      switch(action_id)
      {
         case AC_PAT_SELECT: // arg1=kit uid
         case AC_PAT_RECV:   // arg1=kit uid, 0=use current
         case AC_PAT_SEND:   // arg1=kit uid, 0=use current
            if(_oldUID == action_arg1)
            {
               Global.Debug("NAR_MapAction::replacePatternUID: old="+_oldUID+" new="+_newUID);
               action_arg1 = _newUID;
            }
            break;

         case AC_PAT_SELECT_PREV:
         case AC_PAT_SELECT_NEXT:
            break;
      }
   }

   // <method.png>
   public method replacePerfUID(int _oldUID, int _newUID) {
      switch(action_id)
      {
         case AC_PERF_SELECT:  // arg1=perf uid
         case AC_PERF_STORE:   // arg1=perf uid, 0=use current
         case AC_PERF_RECALL:  // arg1=perf uid, 0=use current
         case AC_PERF_TRANSITION: // arg1=transition target (uid)
            if(_oldUID == action_arg1)
            {
               Global.Debug("NAR_MapAction::replacePerfUID: old="+_oldUID+" new="+_newUID);
               action_arg1 = _newUID;
            }
            break;

         case AC_PERF_SELECT_PREV:
         case AC_PERF_SELECT_NEXT:
            break;
      }
   }


   // <method.png>
   public method replaceMuteUID(int _oldUID, int _newUID) {
      switch(action_id)
      {
         case AC_MUTE_SELECT:  // arg1=kit uid
         case AC_MUTE_STORE:   // arg1=kit uid, 0=use current
         case AC_MUTE_RECALL:  // arg1=kit uid, 0=use current
            if(_oldUID == action_arg1)
            {
               Global.Debug("NAR_MapAction::replaceMuteUID: old="+_oldUID+" new="+_newUID);
               action_arg1 = _newUID;
            }
            break;

         case AC_MUTE_SELECT_PREV:
         case AC_MUTE_SELECT_NEXT:
            break;
      }
   }


   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 3;

      // Enabled
      _ofs.i8 = b_enable;

      // Write action name
      Utils.WriteString(_ofs, name);

      // Name edited (v2+)
      _ofs.i8 = b_name_edited;

      // Action id
      _ofs.i8 = action_id;

      // Action arg1
      _ofs.f32 = action_arg1;

      // Action arg2
      _ofs.f32 = action_arg2;

      // Action arg3
      _ofs.f32 = action_arg3;

      // Quantization
      _ofs.f32 = quantization;

      // Duration
      _ofs.f32 = duration;

      // Ext: Device index
      _ofs.i8 = ext_dev_idx;

      // Ext: Midi channel
      _ofs.i8 = ext_midi_ch;

   }

   // <load.png>
   public method loadState(Stream _ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Enabled
         b_enable = _ifs.b8;

         // Read entry name
         Utils.ReadString(_ifs, name);

         if(ver >= 2)
         {
            b_name_edited = _ifs.b8; // v2+
         }

         // Action id
         action_id = _ifs.u8;

         if(ver < 3)
         {
            if(action_id >= AC_MUTE_TOGGLE)
               action_id++;  // AC_MUTE_TOGGLE inserted since v3
         }

         // Action arg1
         action_arg1 = _ifs.f32;

         // Action arg2
         action_arg2 = _ifs.f32;

         // Action arg3
         action_arg3 = _ifs.f32;

         // Quantization
         quantization = _ifs.f32;

         // Duration
         duration = _ifs.f32;

         // Ext: Device index
         ext_dev_idx = _ifs.i8;

         // Ext: Midi channel
         ext_midi_ch = _ifs.i8;

         if(-1 != ext_dev_idx)
         {
            _outDevUseCount.inc(ext_dev_idx);

            ext_dev_idx = _outDevIdxMap.get(ext_dev_idx);
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] NAR_MapEntry::loadState: bad ver="+ver;
      }

      return false;
   }
}


// <class.png>
class NAR_MapEntry {

   boolean b_enable;

   String name;

   define int IN_NONE  = 0;  // arg1=trig#  (0..15)
   define int IN_TRIG  = 1;  // arg1=trig#  (0..15)
   define int IN_MUTE  = 2;  // arg1=mute#  (0..11)
   define int IN_PERF  = 3;  // arg1=perf#  (0..11)
   define int IN_SCENE = 4;  // arg1=scene# (0..11)
   define int IN_NRPN  = 5;

   static StringArray input_names = [
      "-",
      "Trig",
      "Mute",
      "Perf",
      "Scene",
      "NRPN"
                                     ];

   int input_id1;
   int input_arg1;        // e.g. trig#

   int input_id2;
   int input_arg2;        // e.g. perf#

   NAR_MapAction *[] actions;  // NAR_MapAction instances



   // <method_init.png>
   public method init() {
      b_enable = true;

      name = "new entry "+Utils.GetCurrentDateTimeStringNumeric();

      input_id1  = IN_TRIG;
      input_arg1 = 0;

      input_id2  = IN_NONE;
      input_arg2 = 0;
   }

   // <method.png>
   public method copyFrom(NAR_MapEntry _o) {
      b_enable          = _o.b_enable;
      name              = _o.name;
      input_id1         = _o.input_id1;
      input_arg1        = _o.input_arg1;
      input_id2         = _o.input_id2;
      input_arg2        = _o.input_arg2;

      actions.free();

      NAR_MapAction *ac;
      NAR_MapAction *oac;
      foreach oac in _o.actions
      {
         ac <= new NAR_MapAction;
         ac.init();
         ac.copyFrom(oac);
         actions.add(#(deref ac));
      }

   }

   // <method_set.png>
   public =replay= method setEnable(boolean _bEnable) {
      b_enable = _bEnable;
   }

   // <method_get.png>
   public method getInputString() : String {
      // for TM
      if(IN_NONE != input_id2)
      {
         return input_names.get(input_id1) + " " + getArg1String()+ " + " + input_names.get(input_id2)+ " " + getArg2String();
      }
      else
      {
         return input_names.get(input_id1) + " " + getArg1String();
      }
   }

   // <method_get.png>
   public method getActionString() : String {
      // for TM
      if(actions.numElements >= 2)
      {
         return "multi: <"+actions.numElements+">";
      }
      else if(actions.numElements == 1)
      {
         NAR_MapAction ac <= actions.get(0);
         return ac.getActionString();
      }
      else
      {
         return "-";
      }
   }

   // <method_get.png>
   public method getArg1String() : String {
      // for TM
      switch(input_id1)
      {
         default:
         case IN_NRPN:
            return String(input_arg1);

         case IN_TRIG:
         case IN_MUTE:
         case IN_PERF:
         case IN_SCENE:
            return String(input_arg1 + 1);
      }
   }

   // <method_get.png>
   public method getArg2String() : String {
      // for TM
      switch(input_id2)
      {
         default:
            return "";

         case IN_NRPN:
            return String(input_arg2);

         case IN_TRIG:
         case IN_MUTE:
         case IN_PERF:
         case IN_SCENE:
            return String(input_arg2 + 1);
      }
   }

   // <method_set.png>
   public =replay= method setInputId1(int _inputId1) {
      input_id1 = _inputId1;
   }

   // <method_set.png>
   public =replay= method setInputId2(int _inputId2) {
      input_id2 = _inputId2;
   }

   // <method_set.png>
   public =replay= method setInputArg1(float _arg1) {
      input_arg1 = _arg1;
   }

   // <method_set.png>
   public =replay= method setInputArg2(float _arg2) {
      input_arg2 = _arg2;
   }

   // <method_set.png>
   public =replay= method setInputArg1FromUI(float _arg1) {
      switch(input_id1)
      {
         default:
         break;

         case IN_TRIG:
            input_arg1 = _arg1 - 1;
            break;

         case IN_MUTE:
         case IN_PERF:
         case IN_SCENE:
            input_arg1 = _arg1 - 1;
            break;

         case IN_NRPN:
            input_arg1 = _arg1;
            break;
      }

   }

   // <method_set.png>
   public =replay= method setInputArg2FromUI(float _arg2) {
      switch(input_id2)
      {
         default:
         break;

         case IN_TRIG:
            input_arg2 = _arg2 - 1;
            break;

         case IN_MUTE:
         case IN_PERF:
         case IN_SCENE:
            input_arg2 = _arg2 - 1;
            break;

         case IN_NRPN:
            input_arg2 = _arg2;
            break;
      }

   }

   // <method_add.png>
   public =replay= method addMapAction(int _rowHint) : NAR_MapAction {
      NAR_MapAction mapac <= new NAR_MapAction;
      mapac.init();

      if((-1 == _rowHint) || (_rowHint >= actions.numElements))
      {
         actions.add(#(deref mapac));
      }
      else
      {
         actions.insert(_rowHint + 1, #(deref mapac));
      }

      return mapac;
   }

   // <method_remove.png>
   public =replay= method removeMapActionByIdx(int _idx) {
      if(_idx >= 0)
      {
         if(_idx < actions.numElements)
         {
            NAR_MapAction mapac <= actions.get(_idx);

            if(null != mapac)
            {
               actions.delete(_idx);
            }
         }
      }
   }

   // <method.png>
   public =replay= method moveMapActionUp(int _idx) : boolean {
      if(0 < _idx < actions.numElements)
      {
         actions.swap(_idx, _idx - 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public =replay= method moveMapActionDown(int _idx) : boolean {
      if(0 <= _idx < (actions.numElements - 1))
      {
         actions.swap(_idx, _idx + 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public method autoUpdateActionNames() {
      NAR_MapAction *mapac;
      foreach mapac in actions
      {
         if(!mapac.b_name_edited)
            mapac.name = name;
      }
   }

   // <method_get.png>
   public method getMapActionIdx(NAR_MapAction _mapac) : int {
      return actions.indexOfPointer(_mapac, 0);
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 2;

      // Enabled
      _ofs.i8 = b_enable;

      // Write entry name
      Utils.WriteString(_ofs, name);

      // Input id 1
      _ofs.i8 = input_id1;

      // Input id 2 (v2+)
      _ofs.i8 = input_id2;

      // Input arg1
      _ofs.i8 = input_arg1;

      // Input arg2 (v2+)
      _ofs.i8 = input_arg2;

      // Write actions
      _ofs.i16 = actions.numElements;

      NAR_MapAction *action;
      foreach action in actions
         action.saveState(_ofs);
   }

   // <load.png>
   public method loadState(Stream _ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Read enabled
         b_enable = _ifs.b8;

         // Read entry name
         Utils.ReadString(_ifs, name);

         // Read input id 1
         input_id1 = _ifs.u8;

         if(ver >= 2)
         {
            // Read input id 2 (v2+)
            input_id2 = _ifs.u8;
         }

         // Read input arg1
         input_arg1 = _ifs.u8;

         if(ver >= 2)
         {
            // Read input arg2
            input_arg2 = _ifs.u8;
         }

         // Read actions
         int numActions = _ifs.i16;

         if(actions.alloc(numActions))
         {
            int actionIdx = 0;

            loop(numActions)
            {
               NAR_MapAction action <= new NAR_MapAction;
               action.init();

               if(!action.loadState(_ifs, _outDevIdxMap, _outDevUseCount))
               {
                  trace "[---] NAR_MapEntry::loadState: failed to load action idx="+actionIdx+" (num="+numActions+")";
                  return false;
               }

               actions.add(#(deref action));

               // Next action
               actionIdx++;
            }
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] NAR_MapEntry::loadState: bad ver="+ver;
      }

      return false;
   }
}


// <class.png>
class NAR_MapGroup : NAR_Base {

   boolean b_enable;
   boolean b_global;


   PointerArray entries;  // NAR_MapEntry instances


   // <method_init.png>
   public method init() {
      uid = -1;

      name = "new group "+Utils.GetCurrentDateTimeStringNumeric();

      b_enable = true;
   }

   // <method.png>
   public method copyFrom(NAR_MapGroup _o) {
      // // uid       = _o.uid;  // reassign new one after clone()
      b_enable  = _o.b_enable;
      b_global  = _o.b_global;
      name      = _o.name;

      entries.free();

      NAR_MapEntry *en;
      NAR_MapEntry *oen;
      foreach oen in _o.entries
      {
         en <= new NAR_MapEntry;
         en.init();
         en.copyFrom(oen);
         entries.add(#(deref en));
      }

   }

   // <method_set.png>
   public =replay= method setEnable(boolean _bEnable) {
      b_enable = _bEnable;
   }

   // <method_set.png>
   public =replay= method setGlobal(boolean _bGlobal) {
      b_global = _bGlobal;
   }

   // <method_add.png>
   public =replay= method addMapEntry(int _rowHint) : NAR_MapEntry {
      NAR_MapEntry mapen <= new NAR_MapEntry;
      mapen.init();

      if((-1 == _rowHint) || (_rowHint >= entries.numElements))
      {
         entries.add(#(deref mapen));
      }
      else
      {
         entries.insert(_rowHint + 1, #(deref mapen));
      }

      return mapen;
   }

   // <method_remove.png>
   public =replay= method removeMapEntryByIdx(int _idx) {
      if(0 <= _idx < entries.numElements)
      {
         NAR_MapEntry mapen <= entries.get(_idx);
         if(null != mapen)
            entries.delete(_idx);
      }
   }

   // <method.png>
   public =replay= method moveMapEntryUp(int _idx) : boolean {
      if(0 < _idx < entries.numElements)
      {
         entries.swap(_idx, _idx - 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public =replay= method moveMapEntryDown(int _idx) : boolean {
      if(0 <= _idx < (entries.numElements - 1))
      {
         entries.swap(_idx, _idx + 1);
         return true;
      }
      return false;
   }

   // <method_get.png>
   public method getMapEntryIdx(NAR_MapEntry _mapen) : int {
      return entries.indexOfPointer(_mapen, 0);
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 2;

      // Write UID
      _ofs.i32 = uid;

      // Write enable
      _ofs.i8 = b_enable;

      // Write global (v2+)
      _ofs.i8 = b_global;

      // Write map group name
      Utils.WriteString(_ofs, name);

      // Write entries
      _ofs.i16 = entries.numElements;

      NAR_MapEntry *entry;
      foreach entry in entries
         entry.saveState(_ofs);
   }

   // <load.png>
   public method loadState(Stream _ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Read UID
         uid = _ifs.i32;

         // Read enable
         b_enable = _ifs.b8;

         if(ver >= 2)
         {
            // Read global (v2+)
            b_global = _ifs.b8;
         }

         // Read map group name
         Utils.ReadString(_ifs, name);

         // Read entries
         int numEntries = _ifs.i16;

         // trace "xxx NAR_MapGroup::loadState: numEntries="+numEntries;

         if(entries.alloc(numEntries))
         {
            int entryIdx = 0;

            loop(numEntries)
            {
               NAR_MapEntry entry <= new NAR_MapEntry;
               entry.init();

               if(!entry.loadState(_ifs, _outDevIdxMap, _outDevUseCount))
               {
                  trace "[---] NAR_MapGroup::loadState: failed to load entry idx="+entryIdx+" (num="+numEntries+")";
                  return false;
               }

               entries.add(#(deref entry));

               // Next entry
               entryIdx++;
            }
         }

         // Succeeded
         return true;
      }
      else
      {
         trace "[---] NAR_MapGroup::loadState: bad ver="+ver;
      }

      return false;
   }
}



// <class.png>
class NodeAnalogRytmPattern : NodePattern {

   // aka "snapshot"

   NodeAnalogRytm *parent_node;

   PointerArray nar_patterns;  // NAR_Pattern instances
   PointerArray nar_kits;      // NAR_Kit instances
   PointerArray nar_mutes;     // NAR_Mute instances
   PointerArray nar_perfs;     // NAR_Perf instances

   PointerArray groups;    // NAR_MapGroup instances

   int current_pattern_idx;
   int current_kit_idx;
   int current_mute_idx;
   int current_perf_idx;
   int current_group_idx;

   int next_pattern_uid;
   int next_kit_uid;
   int next_mute_uid;
   int next_perf_uid;
   int next_group_uid;

   StringArray sample_names;  // 128 entries. idx 0 = "000: OFF"


   // <method_get.png>
   public method allocPatternUID() : int {

      int uid = 1;

      // trace "xxx allocPatternUID: numPat="+nar_patterns.numElements;

      loop(255)
      {
         NAR_Pattern *narPattern;
         boolean bUsed = false;

         foreach narPattern in nar_patterns
         {
            if(narPattern.uid == uid)
            {
               bUsed = true;
               break;
            }
         }

         if(!bUsed)
            break;

         uid++;
      }

      return uid;
   }

   // <method.png>
   public method replaceActionsPatternUID(int _oldUID, int _newUID) {
      NAR_MapGroup *grp;
      foreach grp in groups
      {
         NAR_MapEntry *en;
         foreach en in grp.entries
         {
            NAR_MapAction *ac;
            foreach ac in en.actions
            {
               ac.replacePatternUID(_oldUID, _newUID);
            }
         }
      }
   }

   // <method.png>
   public =replay= method reEnumeratePatternUIDs(int _baseUID) {
      int uid = _baseUID;

      NAR_Pattern *narPattern;
      foreach narPattern in nar_patterns
      {
         replaceActionsPatternUID(narPattern.uid, uid);

         narPattern.uid = uid++;
      }
   }

   // <method_get.png>
   public method allocKitUID() : int {
      int uid = 1;
      loop(255)
      {
         boolean bUsed = false;
         NAR_Kit *narKit;
         foreach narKit in nar_kits
         {
            if(narKit.uid == uid)
            {
               bUsed = true;
               break;
            }
         }

         if(!bUsed)
            break;

         uid++;
      }

      return uid;
   }

   // <method.png>
   public method replaceActionsKitUID(int _oldUID, int _newUID) {
      NAR_MapGroup *grp;
      foreach grp in groups
      {
         NAR_MapEntry *en;
         foreach en in grp.entries
         {
            NAR_MapAction *ac;
            foreach ac in en.actions
            {
               ac.replaceKitUID(_oldUID, _newUID);
            }
         }
      }
   }

   // <method.png>
   public =replay= method reEnumerateKitUIDs(int _baseUID) {
      int uid = _baseUID;

      NAR_Kit *narKit;
      foreach narKit in nar_kits
      {
         replaceActionsKitUID(narKit.uid, uid);
         narKit.uid = uid++;
      }
   }

   // <method_get.png>
   public method allocPerfUID() : int {
      int uid = 1;
      loop(255)
      {
         boolean bUsed = false;
         NAR_Perf *narPerf;
         foreach narPerf in nar_perfs
         {
            if(narPerf.uid == uid)
            {
               bUsed = true;
               break;
            }
         }

         if(!bUsed)
            break;

         uid++;
      }

      return uid;
   }

   // <method.png>
   public method replaceActionsPerfUID(int _oldUID, int _newUID) {
      NAR_MapGroup *grp;
      foreach grp in groups
      {
         NAR_MapEntry *en;
         foreach en in grp.entries
         {
            NAR_MapAction *ac;
            foreach ac in en.actions
            {
               ac.replacePerfUID(_oldUID, _newUID);
            }
         }
      }
   }

   // <method.png>
   public =replay= method reEnumeratePerfUIDs(int _baseUID) {
      int uid = _baseUID;

      NAR_Perf *narPerf;
      foreach narPerf in nar_perfs
      {
         replaceActionsPerfUID(narPerf.uid, uid);

         narPerf.uid = uid++;
      }
   }

   // <method_get.png>
   public method allocMuteUID() : int {
      int uid = 1;

      loop(255)
      {
         NAR_Mute *narMute;
         boolean bUsed = false;

         foreach narMute in nar_mutes
         {
            if(narMute.uid == uid)
            {
               bUsed = true;
               break;
            }
         }

         if(!bUsed)
            break;

         uid++;
      }

      return uid;
   }

   // <method.png>
   public method replaceActionsMuteUID(int _oldUID, int _newUID) {
      NAR_MapGroup *grp;
      foreach grp in groups
      {
         NAR_MapEntry *en;
         foreach en in grp.entries
         {
            NAR_MapAction *ac;
            foreach ac in en.actions
            {
               ac.replaceMuteUID(_oldUID, _newUID);
            }
         }
      }
   }

   // <method.png>
   public =replay= method reEnumerateMuteUIDs(int _baseUID) {
      int uid = _baseUID;

      NAR_Mute *narMute;
      foreach narMute in nar_mutes
      {
         replaceActionsMuteUID(narMute.uid, uid);

         narMute.uid = uid++;
      }
   }

   // <method_get.png>
   public method allocMapGroupUID() : int {
      int uid = 1;

      loop(255)
      {
         boolean bUsed = false;
         NAR_MapGroup *mapgrp;
         foreach mapgrp in groups
         {
            if(mapgrp.uid == uid)
            {
               bUsed = true;
               break;
            }
         }

         if(!bUsed)
            break;

         uid++;
      }

      return uid;
   }

   // <method_set.png>
   public method setCurrentPatternIdx(int _idx) {
      if(_idx >= 0)
      {
         if(_idx < nar_patterns.numElements)
         {
            current_pattern_idx = _idx;
         }
      }
   }

   // <method_set.png>
   public method setCurrentKitIdx(int _idx) {
      if(0 <= _idx < nar_kits.numElements)
      {
         current_kit_idx = _idx;
      }
   }

   // <method_set.png>
   public method setCurrentMuteIdx(int _idx) {
      if(0 <= _idx < nar_mutes.numElements)
      {
         current_mute_idx = _idx;
      }
   }

   // <method_set.png>
   public method setCurrentPerfIdx(int _idx) {
      if(0 <= _idx < nar_perfs.numElements)
      {
         current_perf_idx = _idx;
      }
   }

   // <method_set.png>
   public method setCurrentGroupIdx(int _idx) {
      if(0 <= _idx < groups.numElements)
      {
         current_group_idx = _idx;
      }
   }

   // <method_get.png>
   public method getCurrentNARPattern() : NAR_Pattern {
      return nar_patterns.get(current_pattern_idx);
   }

   // <method_get.png>
   public method getCurrentARPattern() : AR_Pattern {
      NAR_Pattern narPat <= nar_patterns.get(current_pattern_idx);
      if(null != narPat)
         return narPat.ar_pattern;
      return null;
   }

   // <method_get.png>
   public method getCurrentNARKit() : NAR_Kit {
      return nar_kits.get(current_kit_idx);
   }

   // <method_get.png>
   public method getCurrentARKit() : AR_Kit {
      NAR_Kit narKit <= nar_kits.get(current_kit_idx);
      if(null != narKit)
         return narKit.ar_kit;
      return null;
   }

   // <method_get.png>
   public method getCurrentNARMute() : NAR_Mute {
      return nar_mutes.get(current_mute_idx);
   }

   // <method_get.png>
   public method getCurrentNARPerf() : NAR_Perf {
      return nar_perfs.get(current_perf_idx);
   }

   // <method_get.png>
   public method getCurrentMapGroup() : NAR_MapGroup {
      return groups.get(current_group_idx);
   }

   // <method_add.png>
   public =replay= method addKit(int _rowHint) : NAR_Kit {
      NAR_Kit kit <= new NAR_Kit;
      kit.init();
      kit.uid = allocKitUID();

      if((-1 == _rowHint) || (_rowHint >= nar_kits.numElements))
      {
         nar_kits.add(#(deref kit));
      }
      else
      {
         nar_kits.insert(_rowHint + 1, #(deref kit));
      }

      return kit;
   }

   // <method_remove.png>
   public =replay= method removeKitByIdx(int _idx) {
      if(0 <= _idx < nar_kits.numElements)
      {
         NAR_Kit narKit <= nar_kits.get(_idx);
         if(null != narKit)
         {
            parent_node.handleRemoveARKit(narKit.ar_kit);

            nar_kits.delete(_idx);
         }
      }
   }

   // <method.png>
   public =replay= method moveKitUp(int _idx) : boolean {
      if(0 < _idx < nar_kits.numElements)
      {
         nar_kits.swap(_idx, _idx - 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public =replay= method moveKitDown(int _idx) : boolean {
      if(0 <= _idx < (nar_kits.numElements - 1))
      {
         nar_kits.swap(_idx, _idx + 1);
         return true;
      }
      return false;
   }

   // <method_get.png>
   public method getKitIdx(NAR_Kit _kit) : int {
      return nar_kits.indexOfPointer(_kit, 0);
   }

   // <method_get.png>
   public method getKitByIdx(int _idx) : NAR_Kit {
      return nar_kits.get(_idx);
   }

   // <method_get.png>
   public method getKitByUID(int _uid) : NAR_Kit {
      NAR_Kit *kit;
      foreach kit in nar_kits
      {
         if(kit.uid == _uid)
            return kit;
      }
      return null;
   }

   // <method_add.png>
   public =replay= method addPattern(int _rowHint) : NAR_Pattern {
      NAR_Pattern pattern <= new NAR_Pattern;
      pattern.init();
      pattern.uid = allocPatternUID();

      if((-1 == _rowHint) || (_rowHint >= nar_patterns.numElements))
      {
         nar_patterns.add(#(deref pattern));
      }
      else
      {
         nar_patterns.insert(_rowHint + 1, #(deref pattern));
      }

      return pattern;
   }

   // <method_remove.png>
   public =replay= method removePatternByIdx(int _idx) {
      if(0 <= _idx < nar_patterns.numElements)
      {
         NAR_Pattern narPattern <= nar_patterns.get(_idx);

         if(null != narPattern)
         {
            parent_node.handleRemoveARPattern(narPattern.ar_pattern);

            nar_patterns.delete(_idx);
         }
      }
   }

   // <method.png>
   public =replay= method movePatternUp(int _idx) : boolean {
      if(0 < _idx < nar_patterns.numElements)
      {
         nar_patterns.swap(_idx, _idx - 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public =replay= method movePatternDown(int _idx) : boolean {
      if(0 <= _idx < (nar_patterns.numElements - 1))
      {
         nar_patterns.swap(_idx, _idx + 1);
         return true;
      }
      return false;
   }

   // <method_get.png>
   public method getPatternIdx(NAR_Pattern _pattern) : int {
      return nar_patterns.indexOfPointer(_pattern, 0);
   }

   // <method_get.png>
   public method getPatternByIdx(int _idx) : NAR_Pattern {
      return nar_patterns.get(_idx);
   }

   // <method_get.png>
   public method getPatternByUID(int _uid) : NAR_Pattern {
      NAR_Pattern *pat;
      foreach pat in nar_patterns
      {
         if(pat.uid == _uid)
            return pat;
      }
      return null;
   }

   // <method_add.png>
   public =replay= method addMapGroup(int _rowHint) : NAR_MapGroup {
      NAR_MapGroup mapgrp <= new NAR_MapGroup;
      mapgrp.init();
      mapgrp.uid = allocMapGroupUID();

      if((-1 == _rowHint) || (_rowHint >= groups.numElements))
      {
         groups.add(#(deref mapgrp));
      }
      else
      {
         groups.insert(_rowHint + 1, #(deref mapgrp));
      }

      return mapgrp;
   }

   // <method_remove.png>
   public =replay= method removeMapGroupByIdx(int _idx) {
      if(0 <= _idx < groups.numElements)
      {
         NAR_MapGroup mapgrp <= groups.get(_idx);
         if(null != mapgrp)
         {
            // // parent_node.handleRemoveARPattern(narPattern.ar_pattern);
            groups.delete(_idx);
         }
      }
   }

   // <method.png>
   public =replay= method moveMapGroupUp(int _idx) : boolean {
      if(0 < _idx < groups.numElements)
      {
         groups.swap(_idx, _idx - 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public =replay= method moveMapGroupDown(int _idx) : boolean {
      if(0 <= _idx < (groups.numElements - 1))
      {
         groups.swap(_idx, _idx + 1);
         return true;
      }
      return false;
   }

   // <method_get.png>
   public method getMapGroupIdx(NAR_MapGroup _mapgrp) : int {
      return groups.indexOfPointer(_mapgrp, 0);
   }

   // <method_get.png>
   public method getMapGroupByIdx(int _idx) : NAR_MapGroup {
      return groups.get(_idx);
   }

   // <method_get.png>
   public method getMapGroupByUID(int _uid) : NAR_MapGroup {
      NAR_MapGroup *mapGroup;
      foreach mapGroup in groups
      {
         if(mapGroup.uid == _uid)
            return mapGroup;
      }
      return null;
   }

   // <method_add.png>
   public =replay= method addMute(int _rowHint) : NAR_Mute {
      NAR_Mute mute <= new NAR_Mute;
      mute.init();
      mute.uid = allocMuteUID();

      if((-1 == _rowHint) || (_rowHint >= nar_mutes.numElements))
      {
         nar_mutes.add(#(deref mute));
      }
      else
      {
         nar_mutes.insert(_rowHint + 1, #(deref mute));
      }

      return mute;
   }

   // <method_remove.png>
   public =replay= method removeMuteByIdx(int _idx) {
      if(0 <= _idx < nar_mutes.numElements)
      {
         NAR_Mute narMute <= nar_mutes.get(_idx);
         if(null != narMute)
            nar_mutes.delete(_idx);
      }
   }

   // <method.png>
   public =replay= method moveMuteUp(int _idx) : boolean {
      if(0 < _idx < nar_mutes.numElements)
      {
         nar_mutes.swap(_idx, _idx - 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public =replay= method moveMuteDown(int _idx) : boolean {
      if(0 <= _idx < (nar_mutes.numElements - 1))
      {
         nar_mutes.swap(_idx, _idx + 1);
         return true;
      }
      return false;
   }

   // <method_get.png>
   public method getMuteIdx(NAR_Mute _mute) : int {
      return nar_mutes.indexOfPointer(_mute, 0);
   }

   // <method_get.png>
   public method getMuteByIdx(int _idx) : NAR_Mute {
      return nar_mutes.get(_idx);
   }

   // <method_get.png>
   public method getMuteByUID(int _uid) : NAR_Mute {
      NAR_Mute *mute;
      foreach mute in nar_mutes
      {
         if(mute.uid == _uid)
            return mute;
      }
      return null;
   }

   // <method_add.png>
   public =replay= method addPerf(int _rowHint) : NAR_Perf {
      NAR_Perf perf <= new NAR_Perf;
      perf.init();
      perf.uid = allocPerfUID();

      if((-1 == _rowHint) || (_rowHint >= nar_perfs.numElements))
      {
         nar_perfs.add(#(deref perf));
      }
      else
      {
         nar_perfs.insert(_rowHint + 1, #(deref perf));
      }

      return perf;
   }

   // <method_remove.png>
   public =replay= method removePerfByIdx(int _idx) {
      if(0 <= _idx < nar_perfs.numElements)
      {
         NAR_Perf narPerf <= nar_perfs.get(_idx);
         if(null != narPerf)
         {
            nar_perfs.delete(_idx);
         }
      }
   }

   // <method.png>
   public =replay= method movePerfUp(int _idx) : boolean {
      if(0 < _idx < nar_perfs.numElements)
      {
         nar_perfs.swap(_idx, _idx - 1);
         return true;
      }
      return false;
   }

   // <method.png>
   public =replay= method movePerfDown(int _idx) : boolean {
      if(0 <= _idx < (nar_perfs.numElements - 1))
      {
         nar_perfs.swap(_idx, _idx + 1);
         return true;
      }
      return false;
   }

   // <method_get.png>
   public method getPerfIdx(NAR_Perf _perf) : int {
      return nar_perfs.indexOfPointer(_perf, 0);
   }

   // <method_get.png>
   public method getPerfByIdx(int _idx) : NAR_Perf {
      return nar_perfs.get(_idx);
   }

   // <method_get.png>
   public method getPerfByUID(int _uid) : NAR_Perf {
      NAR_Perf *perf;
      foreach perf in nar_perfs
      {
         if(perf.uid == _uid)
            return perf;
      }
      return null;
   }

   // <method_init.png>
   public virtual patInit(Node _parent, int _patNr) {
      NodePattern::patInit(_parent, _patNr);

      parent_node <= _parent;

      nar_patterns.free();
      nar_kits.free();
      nar_mutes.free();
      nar_perfs.free();
      groups.free();

      next_pattern_uid = 1;
      next_kit_uid     = 1;
      next_mute_uid    = 1;
      next_perf_uid    = 1;
      next_group_uid   = 1;

      NAR_Pattern pat <= new NAR_Pattern;
      pat.init();
      pat.uid = allocPatternUID();
      nar_patterns.add(#(deref pat));

      NAR_Kit kit <= new NAR_Kit;
      kit.init();
      pat.uid = allocKitUID();
      nar_kits.add(#(deref kit));

      NAR_Mute mute <= new NAR_Mute;
      mute.init();
      mute.uid = allocMuteUID();
      nar_mutes.add(#(deref mute));

      NAR_Perf perf <= new NAR_Perf;
      perf.init();
      perf.uid = allocPerfUID();
      nar_perfs.add(#(deref perf));

      NAR_MapGroup mapgrp <= new NAR_MapGroup;
      mapgrp.init();
      mapgrp.uid = allocMapGroupUID();
      groups.add(#(deref mapgrp));

      current_pattern_idx = 0;
      current_kit_idx     = 0;
      current_mute_idx    = 0;
      current_perf_idx    = 0;
      current_group_idx   = 0;

      sample_names.empty();
      sample_names.add("000: OFF");
      local Integer smpNr = 1;
      loop(127)
      {
         sample_names.add(smpNr.printf("%03d")+":");
         smpNr++;
      }
   }

   // <method.png>
   public virtual patCopyFrom(NodePattern _o, boolean _bClear) {
      patCopyFromGeneric(_o);
   }

   // <save.png>
   public virtual patSaveState(Stream ofs) {

      NodePattern::patSaveState(ofs);

      // Write version
      ofs.i16 = 5;

      // Save "next uid"s (v2+)
      ofs.i32 = next_pattern_uid;
      ofs.i32 = next_kit_uid;
      ofs.i32 = next_mute_uid; // v4+
      ofs.i32 = next_perf_uid; // v4+
      ofs.i32 = next_group_uid;

      // Save patterns
      ofs.i32 = nar_patterns.numElements;

      NAR_Pattern *pat;
      foreach pat in nar_patterns
      {
         if(null != pat)
         {
            ofs.i8 = true;
            pat.saveState(ofs);
         }
         else
         {
            // Unused pattern slot
            ofs.i8 = false;
         }
      }

      // Save kits
      ofs.i32 = nar_kits.numElements;

      NAR_Kit *kit;
      foreach kit in nar_kits
      {
         if(null != kit)
         {
            ofs.i8 = true;
            kit.saveState(ofs);
         }
         else
         {
            // Unused kit slot
            ofs.i8 = false;
         }
      }

      // Save mute states (v4+)
      ofs.i32 = nar_mutes.numElements;

      NAR_Mute *mute;
      foreach mute in nar_mutes
      {
         if(null != mute)
         {
            ofs.i8 = true;
            mute.saveState(ofs);
         }
         else
         {
            // Unused mute state slot
            ofs.i8 = false;
         }
      }

      // Save perf states (v4+)
      ofs.i32 = nar_perfs.numElements;

      NAR_Perf *perf;
      foreach perf in nar_perfs
      {
         if(null != perf)
         {
            ofs.i8 = true;
            perf.saveState(ofs);
         }
         else
         {
            // Unused perf state slot
            ofs.i8 = false;
         }
      }

      // Save groups (v3+)
      ofs.i32 = groups.numElements;

      NAR_MapGroup *mapgrp;
      foreach mapgrp in groups
      {
         if(null != mapgrp)
         {
            ofs.i8 = true;
            mapgrp.saveState(ofs);
         }
         else
         {
            // Unused mapgrp slot
            ofs.i8 = false;
         }
      }

      ofs.i16 = current_pattern_idx;
      ofs.i16 = current_kit_idx;
      ofs.i16 = current_mute_idx;  // v4+
      ofs.i16 = current_perf_idx;  // v4+
      ofs.i16 = current_group_idx; // v2+

      // Sample names (v5+)
      int smpIdx = 0;
      loop(128)
         Utils.WriteString(ofs, sample_names.get(smpIdx++));
   }

   // <load.png>
   public virtual patLoadState(Stream ifs, short _ver, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {

      if(NodePattern::patLoadState(ifs, _ver, _outDevIdxMap, _outDevUseCount))
      {
         short ver = ifs.i16;

         if(ver >= 1)
         {
            boolean bUsed;

            // Read "next uid"s
            if(ver >= 2)
            {
               next_pattern_uid = ifs.i32;
               next_kit_uid     = ifs.i32;
               if(ver >= 4)
               {
                  next_mute_uid = ifs.i32;
                  next_perf_uid = ifs.i32;
               }
               next_group_uid   = ifs.i32;
            }

            // Read AR patterns
            int numPat = ifs.i32;

            if(Configuration.debugLevel >= 2)
               Global.Debug2("AR::patLoadState: read numPat="+numPat);

            if(numPat > 0)
            {
               if(nar_patterns.alloc(numPat))
               {
                  loop(numPat)
                  {
                     bUsed = ifs.u8;

                     if(bUsed)
                     {
                        NAR_Pattern pat <= new NAR_Pattern;
                        pat.init();
                        nar_patterns.add(#(deref pat));

                        if(pat.loadState(ifs))
                        {
                           if(-1 == pat.uid)
                           {
                              pat.uid = next_pattern_uid++;
                           }
                        }
                        else
                        {
                           trace "[---] NodeAnalogRytmPattern::patLoadState: failed to read pattern (patIdx="+(nar_patterns.numElements-1)+")";
                           return false;
                        }
                     }
                     else
                     {
                        nar_patterns.add(null);
                     }
                  }
               }
               else
               {
                  trace "[---] NodeAnalogRytmPattern::patLoadState: failed to allocate "+numPat+" patterns.";
                  return false;
               }
            }

            // Read AR kits
            int numKits = ifs.i32;

            if(Configuration.debugLevel >= 2)
               Global.Debug2("AR::patLoadState: read numKits="+numKits);

            if(numKits > 0)
            {
               if(nar_kits.alloc(numKits))
               {
                  loop(numKits)
                  {
                     bUsed = ifs.u8;

                     if(bUsed)
                     {
                        NAR_Kit kit <= new NAR_Kit;
                        kit.init();
                        nar_kits.add(#(deref kit));

                        if(kit.loadState(ifs))
                        {
                           if(-1 == kit.uid)
                           {
                              kit.uid = next_kit_uid++;
                           }
                        }
                        else
                        {
                           trace "[---] NodeAnalogRytmPattern::patLoadState: failed to read kit (kitIdx="+(nar_kits.numElements-1)+")";
                           return false;
                        }
                     }
                     else
                     {
                        nar_kits.add(null);
                     }
                  }
               }
               else
               {
                  trace "[---] NodeAnalogRytmPattern::patLoadState: failed to allocate "+numKits+" kits.";
                  return false;
               }
            }

            if(ver >= 4)
            {
               // Read mute states
               int numMutes = ifs.i32;

               if(Configuration.debugLevel >= 2)
                  Global.Debug2("AR::patLoadState: read numMuteStates="+numMutes);

               if(numMutes > 0)
               {
                  if(nar_mutes.alloc(numMutes))
                  {
                     loop(numMutes)
                     {
                        bUsed = ifs.u8;

                        if(bUsed)
                        {
                           NAR_Mute mute <= new NAR_Mute;
                           mute.init();
                           nar_mutes.add(#(deref mute));

                           if(mute.loadState(ifs))
                           {
                              if(-1 == mute.uid)
                              {
                                 mute.uid = next_mute_uid++;
                              }
                           }
                           else
                           {
                              trace "[---] NodeAnalogRytmPattern::patLoadState: failed to read mute state (muteIdx="+(nar_mutes.numElements-1)+")";
                              return false;
                           }
                        }
                        else
                        {
                           nar_mutes.add(null);
                        }
                     }
                  }
                  else
                  {
                     trace "[---] NodeAnalogRytmPattern::patLoadState: failed to allocate "+numMutes+" mute states.";
                     return false;
                  }
               }


               // Read perf states
               int numPerfs = ifs.i32;

               if(Configuration.debugLevel >= 2)
                  Global.Debug2("AR::patLoadState: read numPerfStates="+numPerfs);

               if(numPerfs > 0)
               {
                  if(nar_perfs.alloc(numPerfs))
                  {
                     loop(numPerfs)
                     {
                        bUsed = ifs.u8;

                        if(bUsed)
                        {
                           NAR_Perf perf <= new NAR_Perf;
                           perf.init();
                           nar_perfs.add(#(deref perf));

                           if(perf.loadState(ifs))
                           {
                              if(-1 == perf.uid)
                              {
                                 perf.uid = next_perf_uid++;
                              }
                           }
                           else
                           {
                              trace "[---] NodeAnalogRytmPattern::patLoadState: failed to read perf state (perfIdx="+(nar_perfs.numElements-1)+")";
                              return false;
                           }
                        }
                        else
                        {
                           nar_perfs.add(null);
                        }
                     }
                  }
                  else
                  {
                     trace "[---] NodeAnalogRytmPattern::patLoadState: failed to allocate "+numPerfs+" perf states.";
                     return false;
                  }
               }
            }

            if(ver >= 3)
            {
               // Read Map Groups
               int numGroups = ifs.i32;

               if(Configuration.debugLevel >= 2)
                  Global.Debug2("AR::patLoadState: read numGroups="+numGroups);

               if(numGroups > 0)
               {
                  if(groups.alloc(numGroups))
                  {
                     loop(numGroups)
                     {
                        bUsed = ifs.u8;

                        if(bUsed)
                        {
                           NAR_MapGroup mapgrp <= new NAR_MapGroup;
                           mapgrp.init();
                           groups.add(#(deref mapgrp));

                           if(mapgrp.loadState(ifs, _outDevIdxMap, _outDevUseCount))
                           {
                              if(-1 == mapgrp.uid)
                              {
                                 mapgrp.uid = next_group_uid++;
                              }
                           }
                           else
                           {
                              trace "[---] NodeAnalogRytmPattern::patLoadState: failed to read group (groupIdx="+(groups.numElements-1)+")";
                              return false;
                           }
                        }
                        else
                        {
                           groups.add(null);
                        }
                     }
                  }
                  else
                  {
                     trace "[---] NodeAnalogRytmPattern::patLoadState: failed to allocate "+numGroups+" groups.";
                     return false;
                  }
               }
            }


            current_pattern_idx = ifs.s16;
            current_kit_idx     = ifs.s16;

            if(ver >= 4)
            {
               current_mute_idx = ifs.s16;
               current_perf_idx = ifs.s16;
            }

            if(ver >= 2)
            {
               current_group_idx = ifs.s16;
            }

            if(ver >= 5)
            {
               // Sample names (v5+)
               sample_names.empty();
               loop(128)
               {
                  local String smpName;
                  Utils.ReadString(ifs, smpName);
                  sample_names.add(smpName);
               }
            }

            return true;
         }
         else
         {
            trace "[---] NodeAnalogRytmPattern::patLoadState: invalid version ("+ver+").";
         }
      }

      return false;
   }
}


// <class.png>
class NodeAnalogRytm : Node {

   // define int PAT_SYX_DEFAULT_NUM_PARTS = 4;  // used to work in v1.45b, or maybe a Windows update broke it ??
   define int PAT_SYX_DEFAULT_NUM_PARTS = 1;

   define int RPN_ANALOGRYTM_SNAPSHOT      = RPN_ANALOGRYTM_BASE + 0;
   define int RPN_ANALOGRYTM_KIT_SEND      = RPN_ANALOGRYTM_BASE + 1;
   define int RPN_ANALOGRYTM_KIT_MIX       = RPN_ANALOGRYTM_BASE + 2;
   define int RPN_ANALOGRYTM_KIT_SEND_BD1  = RPN_ANALOGRYTM_BASE + 10;
   define int RPN_ANALOGRYTM_KIT_SEND_SD2  = RPN_ANALOGRYTM_BASE + 11;
   define int RPN_ANALOGRYTM_KIT_SEND_RS3  = RPN_ANALOGRYTM_BASE + 12;
   define int RPN_ANALOGRYTM_KIT_SEND_CP4  = RPN_ANALOGRYTM_BASE + 13;
   define int RPN_ANALOGRYTM_KIT_SEND_BT5  = RPN_ANALOGRYTM_BASE + 14;
   define int RPN_ANALOGRYTM_KIT_SEND_LT6  = RPN_ANALOGRYTM_BASE + 15;
   define int RPN_ANALOGRYTM_KIT_SEND_MT7  = RPN_ANALOGRYTM_BASE + 16;
   define int RPN_ANALOGRYTM_KIT_SEND_HT8  = RPN_ANALOGRYTM_BASE + 17;
   define int RPN_ANALOGRYTM_KIT_SEND_CH9  = RPN_ANALOGRYTM_BASE + 18;
   define int RPN_ANALOGRYTM_KIT_SEND_OH10 = RPN_ANALOGRYTM_BASE + 19;
   define int RPN_ANALOGRYTM_KIT_SEND_CY11 = RPN_ANALOGRYTM_BASE + 20;
   define int RPN_ANALOGRYTM_KIT_SEND_CB12 = RPN_ANALOGRYTM_BASE + 21;

   byte    in_dev;
   byte    in_ch;
   boolean b_in_en;

   byte    out_dev;
   byte    out_ch;
   boolean b_out_en;

   static NodeAnalogRytmEditor *editor;

   protected STX_MIDIOutDevice *cached_in_dev;
   protected STX_MIDIOutDevice *cached_out_dev;

   define int ST_IO_NONE              = 0;
   define int ST_IO_REQUEST_KITX      = 1;
   define int ST_IO_DUMP_KITX         = 2;
   define int ST_IO_REQUEST_PATX      = 3;
   define int ST_IO_DUMP_PATX         = 4;
   define int ST_IO_DUMP_PATX_1       = 5;
   define int ST_IO_DUMP_PATX_LAST    = 500;
   define int ST_IO_REQUEST_SOUNDX    = 600;
   define int ST_IO_DUMP_SOUNDX       = 601;
   define int ST_IO_DUMP_KITX_SOUND   = 602;
   define int ST_IO_REQUEST_GLOBALX   = 700;
   define int ST_IO_DUMP_GLOBALX      = 701;
   define int ST_IO_REQUEST_SETTINGSX = 800;
   define int ST_IO_DUMP_SETTINGSX    = 801;
   define int ST_IO_DUMP_MUTE         = 1000;
   define int ST_IO_DUMP_PERF         = 2000;
   define int ST_IO_TRANSITION_PERF   = 2001;

   define int KIT_PARTIAL_ALL    = ~0;
   define int KIT_PARTIAL_PERF   = (1 << 0);
   define int KIT_PARTIAL_SCENE  = (1 << 1);
   define int KIT_PARTIAL_FX     = (1 << 2);
   define int KIT_PARTIAL_TRK_1  = (1 << 3);
   define int KIT_PARTIAL_TRK_2  = (1 << 4);
   define int KIT_PARTIAL_TRK_3  = (1 << 5);
   define int KIT_PARTIAL_TRK_4  = (1 << 6);
   define int KIT_PARTIAL_TRK_5  = (1 << 7);
   define int KIT_PARTIAL_TRK_6  = (1 << 8);
   define int KIT_PARTIAL_TRK_7  = (1 << 9);
   define int KIT_PARTIAL_TRK_8  = (1 << 10);
   define int KIT_PARTIAL_TRK_9  = (1 << 11);
   define int KIT_PARTIAL_TRK_10 = (1 << 12);
   define int KIT_PARTIAL_TRK_11 = (1 << 13);
   define int KIT_PARTIAL_TRK_12 = (1 << 14);

   int kit_recv_partial_flags;
   int queued_kit_recv_partial_flags;

   int pattern_recv_state;
   int kit_recv_state;
   int sound_recv_state;
   int global_recv_state;
   int settings_recv_state;

   int pattern_send_state;
   int kit_send_state;
   int sound_send_state;
   int global_send_state;
   int settings_send_state;
   int mute_send_state;
   int perf_send_state;

   int last_part_send_off;

   int ui_pattern_num_parts;

   int current_pattern_syx_part_sz;
   int current_pattern_num_parts;

   PointerArray patterns; // NodeAnalogRytmPattern instances

   AR_Pattern  *current_send_pattern;
   boolean      b_current_send_pattern_valid;
   byte         remote_send_pattern_nr;
   byte         queued_remote_send_pattern_nr;
   AR_Pattern  *queued_send_pattern;
   boolean      b_queued_send_pattern_valid;

   AR_Kit      *current_send_kit;
   boolean      b_current_send_kit_valid;
   boolean      b_current_send_kitsound_valid;
   byte         remote_send_kit_nr;          // also used as trackIdx when sending single kit sounds
   byte         queued_remote_send_kit_nr;   // also used as trackIdx when sending single kit sounds
   AR_Kit      *queued_send_kit;
   boolean      b_queued_send_kit_valid;
   boolean      b_queued_send_kitsound_valid;

   AR_Global   *current_send_global;
   boolean      b_current_send_global_valid;
   byte         remote_send_global_nr;
   byte         queued_remote_send_global_nr;
   AR_Global   *queued_send_global;
   boolean      b_queued_send_global_valid;

   AR_Settings *current_send_settings;
   boolean      b_current_send_settings_valid;
   AR_Settings *queued_send_settings;
   boolean      b_queued_send_settings_valid;


   //
   // Receive
   //

   AR_Pattern  *current_recv_pattern;
   byte         remote_recv_pattern_nr;
   AR_Pattern  *queued_recv_pattern;
   byte         queued_remote_recv_pattern_nr;

   AR_Kit      *current_recv_kit;
   byte         remote_recv_kit_nr;
   AR_Kit      *queued_recv_kit;
   byte         queued_remote_recv_kit_nr;

   AR_Sound    *current_recv_sound;
   byte         remote_recv_sound_nr;
   AR_Sound    *queued_recv_sound;
   byte         queued_remote_recv_sound_nr;

   AR_Global   *current_recv_global;
   byte         remote_recv_global_nr;
   AR_Global   *queued_recv_global;
   byte         queued_remote_recv_global_nr;

   AR_Settings *current_recv_settings;
   byte         remote_recv_settings_nr;
   AR_Settings *queued_recv_settings;
   byte         queued_remote_recv_settings_nr;

   IntArray   *current_send_mute;
   boolean     b_current_send_mute_valid;
   IntArray   *queued_send_mute;
   boolean     b_queued_send_mute_valid;

   IntArray   *current_send_perf;
   boolean     b_current_send_perf_valid;
   IntArray   *queued_send_perf;
   boolean     b_queued_send_perf_valid;

   Buffer pattern_syx; // for multi-part pattern sends

   public int learn_mode; // see NodeAnalogRytmEditor. If != 0, do not record midi events.

   protected int     current_input_id1;
   protected boolean b_current_input_id1_used;  // true=avoid single after combo
   protected float   current_input_arg1;
   protected int     current_input_id2;
   protected float   current_input_arg2;
   protected int     input_last_cc1;
   protected int     input_last_cc2;

   public boolean b_ui_update_queued;

   public AR_Kit    current_kit_state;      // debug
   public AR_Sound  current_sound_state;    // debug
   public AR_Global current_global_state;   // debug
   public AR_Global current_settings_state; // debug

   public IntArray current_mute_state;
   public IntArray current_perf_state;

   public IntArray current_perf_state_transition_start;  // transition
   public IntArray current_perf_state_transition_end;    // transition
   public float perf_send_time_cur_ticks;                // transition
   public float perf_send_time_dur_ticks;                // transition

   public boolean b_mute_note;
   public boolean b_skip_mute;
   public boolean b_skip_perf;

   // [25Sep2023] relocated to synergy.tks (st2 namespace) while moving remaining AR code to "node_analogrytm/"
   // static AR_Pattern ar_pattern_clipboard;  // last selected or received pattern

   boolean b_lock_perf;
   boolean b_lock_scene;
   boolean b_lock_fx;
   boolean b_lock_trk_1;
   boolean b_lock_trk_2;
   boolean b_lock_trk_3;
   boolean b_lock_trk_4;
   boolean b_lock_trk_5;
   boolean b_lock_trk_6;
   boolean b_lock_trk_7;
   boolean b_lock_trk_8;
   boolean b_lock_trk_9;
   boolean b_lock_trk_10;
   boolean b_lock_trk_11;
   boolean b_lock_trk_12;

   boolean b_lock_perf_resetval;
   boolean b_lock_scene_resetval;
   boolean b_lock_fx_resetval;
   boolean b_lock_trk_1_resetval;
   boolean b_lock_trk_2_resetval;
   boolean b_lock_trk_3_resetval;
   boolean b_lock_trk_4_resetval;
   boolean b_lock_trk_5_resetval;
   boolean b_lock_trk_6_resetval;
   boolean b_lock_trk_7_resetval;
   boolean b_lock_trk_8_resetval;
   boolean b_lock_trk_9_resetval;
   boolean b_lock_trk_10_resetval;
   boolean b_lock_trk_11_resetval;
   boolean b_lock_trk_12_resetval;

   boolean b_kit_editor_visible;

   define int KIT_NOTE_REDIRECT_OFF            = 0;
   define int KIT_NOTE_REDIRECT_CHROMA         = 1;  // redirect to current track (center note=C-5)
   define int KIT_NOTE_REDIRECT_TRIG           = 2;  // redirect any octave to trig note
   int kit_note_redirect_mode;
   byte kit_editor_track_idx;         // current editor track (0..11, for note redirection)
   boolean b_note_redirect_pressure;  // false=delete channel+polypressure events

   boolean b_kit_editor_trkswitch ;  // true=auto-switch tracks when trig note (C0..B0) is received from AR
   int queued_kit_editor_track_idx;  // -1=none, 0..12 otherwise


   // <init.png>
   public virtual nodeInit(MIDIPipe _pipe, MIDIPipeNode _node) : boolean {

      Node::nodeInit(_pipe, _node);

      b_auto_filter_a = false;
      auto_dev_filter_a = -1;
      auto_ch_filter_a = -1;

      pattern_recv_state = ST_IO_NONE;
      pattern_send_state = ST_IO_NONE;

      kit_recv_state = ST_IO_NONE;
      kit_send_state = ST_IO_NONE;

      sound_recv_state = ST_IO_NONE;
      sound_send_state = ST_IO_NONE;

      global_recv_state = ST_IO_NONE;
      global_send_state = ST_IO_NONE;

      patterns.alloc(128);
      patterns.useAll();

      edit_pattern_nr = 0;
      play_pattern_nr = 0;

      current_send_pattern <= new AR_Pattern;
      queued_send_pattern  <= new AR_Pattern;

      current_send_kit     <= new AR_Kit;
      queued_send_kit      <= new AR_Kit;

      current_recv_pattern <= null;
      queued_recv_pattern  <= null;

      current_recv_kit     <= null;
      queued_recv_kit      <= null;

      current_recv_sound   <= null;
      queued_recv_sound    <= null;

      current_recv_global  <= null;
      queued_recv_global   <= null;

      ui_pattern_num_parts = PAT_SYX_DEFAULT_NUM_PARTS;

      current_send_mute    <= new IntArray;
      current_send_mute.allocAndFill(12, true);
      queued_send_mute     <= new IntArray;
      queued_send_mute.allocAndFill(12, false);

      current_send_perf    <= new IntArray;
      current_send_perf.allocAndFill(12, -1);

      queued_send_perf     <= new IntArray;
      queued_send_perf.allocAndFill(12, -1);

      current_mute_state   <= new IntArray;
      current_mute_state.allocAndFill(12, false);

      current_perf_state   <= new IntArray;
      current_perf_state.allocAndFill(12, -1);

      b_mute_note = false;
      b_skip_mute = false;
      b_skip_perf = false;

      kit_note_redirect_mode = KIT_NOTE_REDIRECT_CHROMA;
      b_note_redirect_pressure = true;

      b_kit_editor_trkswitch = true;
      queued_kit_editor_track_idx = -1;

      return true;
   }

   // <ui_init.png>
   public virtual nodeUIInit() {

      Node::nodeUIInit();

      NodeAnalogRytmPattern pat <= new NodeAnalogRytmPattern;
      pat.patInit(this, 0/*patIdx*/);
      patterns[0] = deref pat;
   }

   // <method_get.png>
   public virtual nodeGetTypeNameShort() : String {
      return "AR";
   }

   // <method_get.png>
   public virtual nodeGetEditor() : NodeEditor {
      if(null == editor)
      {
         editor <= new NodeAnalogRytmEditor;

         if(!editor.init())
         {
            editor <= null;
            return false;
         }
      }
      return editor;
   }

   // <method_get.png>
   public virtual nodeGetEditorIfExists() : NodeEditor {
      return editor;
   }

   // <method_get.png>
   public virtual nodeGetIcon() : Icon {
      if(LookAndFeel.IDX_MONO == STConfig.lnf_idx)
         return UI.GetIcon("node_analogrytm_mono");
      else
         return UI.GetIcon("node_analogrytm");
   }


   // <method.png>
   public virtual nodeGetPatternClassName() : String {
      return "NodeAnalogRytmPattern";
   }

   // <method.png>
   public virtual nodeReset(boolean _bSoft) {

      updateCachedDevs();

      pattern_recv_state = ST_IO_NONE;
      pattern_send_state = ST_IO_NONE;

      kit_recv_state = ST_IO_NONE;
      kit_send_state = ST_IO_NONE;

      sound_recv_state = ST_IO_NONE;
      sound_send_state = ST_IO_NONE;

      global_recv_state = ST_IO_NONE;
      global_send_state = ST_IO_NONE;

      mute_send_state = ST_IO_NONE;
      perf_send_state = ST_IO_NONE;

      current_input_id1        = NAR_MapEntry.IN_NONE;
      b_current_input_id1_used = false;
      current_input_arg1       = 0;
      current_input_id2        = NAR_MapEntry.IN_NONE;
      current_input_arg2       = 0;
      input_last_cc1           = -1;
      input_last_cc2           = -1;

      b_lock_perf   = b_lock_perf_resetval;
      b_lock_scene  = b_lock_scene_resetval;
      b_lock_fx     = b_lock_fx_resetval;
      b_lock_trk_1  = b_lock_trk_1_resetval;
      b_lock_trk_2  = b_lock_trk_2_resetval;
      b_lock_trk_3  = b_lock_trk_3_resetval;
      b_lock_trk_4  = b_lock_trk_4_resetval;
      b_lock_trk_5  = b_lock_trk_5_resetval;
      b_lock_trk_6  = b_lock_trk_6_resetval;
      b_lock_trk_7  = b_lock_trk_7_resetval;
      b_lock_trk_8  = b_lock_trk_8_resetval;
      b_lock_trk_9  = b_lock_trk_9_resetval;
      b_lock_trk_10 = b_lock_trk_10_resetval;
      b_lock_trk_11 = b_lock_trk_11_resetval;
      b_lock_trk_12 = b_lock_trk_12_resetval;
   }

   // <replay.png>
   public =replay= virtual nodeSeek(int _ticks) {
   }

   // <method_get.png>
   public virtual nodeGetPatternsGeneric() : PointerArray {
      return patterns;
   }

   // <method_get.png>
   public virtual nodeIsPatternEmpty(int _patNr) : boolean {
      return (null == patterns.get(_patNr));
   }

   // <method_get.png>
   public virtual nodeGetPatternByIdx(int _idx) : NodeAnalogRytmPattern {
      return patterns.get(_idx);
   }

   // <method_get.png>
   public =replay= virtual nodeGetCurrentPlayPattern() : NodeAnalogRytmPattern {
      return patterns.get(play_pattern_nr);
   }

   // <method_get.png>
   public =replay= virtual nodeGetCurrentEditPattern() : NodeAnalogRytmPattern {
      return patterns.get(edit_pattern_nr);
   }

   // <method_get.png>
   public method findFirstUnusedPattern(int _startOff) : int {
      int patIdx = patterns.indexOfPointer(null, _startOff);

      return patIdx;
   }

   // <method_set.png>
   public =replay= virtual nodeSetPattern(int _idx, NodeAnalogRytmPattern _pat) {
      patterns[_idx & 127] = deref _pat;
   }

   // // <method_set.png>
   // // (note) relocated to Global when moving AR code to node_analogrytm/
   // // public static =replay= method SetARPatternClipboard(AR_Pattern _pat) {
   // //    ar_pattern_clipboard = _pat;
   // // }

   // // <method_set.png>
   // // (note) relocated to Global when moving AR code to node_analogrytm/
   // // public static =replay= method GetARPatternClipboard() : AR_Pattern {
   // //    if(2 == ar_pattern_clipboard.currentDataIdx)
   // //    {
   // //       return ar_pattern_clipboard;
   // //    }
   // //    return null;
   // // }

   // <method_update.png>
   protected method updateCachedDevs() {
      cached_in_dev  <= b_in_en   ? (MIDI.GetMIDIOutDeviceByIndex(in_dev))  : null;
      cached_out_dev <= b_out_en  ? (MIDI.GetMIDIOutDeviceByIndex(out_dev)) : null;

      // trace "xxx AR: updateCachedDevs: in="+#(cached_in_dev)+" out="+#(cached_out_dev);
   }

   // <method_get.png>
   public =replay= method getQueuedKitEditorTrackIdxAndReset() : int {
      int r = queued_kit_editor_track_idx;
      queued_kit_editor_track_idx = -1;
      return r;
   }

   // <ui_handle.png>
   public =replay= method ioReset() {
      current_perf_state.fill(-1);
      current_input_id1  = NAR_MapEntry.IN_NONE;
      current_input_id2  = NAR_MapEntry.IN_NONE;
      current_input_arg1 = 0;
      current_input_arg2 = 0;
      input_last_cc1     = -1;
      input_last_cc2     = -1;
   }

   // <method_get.png>
   protected method getCurrentARPattern() : AR_Pattern {
      NodeAnalogRytmPattern npat <= nodeGetCurrentEditPattern();
      if(null != npat)
         return npat.getCurrentARPattern();
      return null;
   }

   // <method_get.png>
   protected method getCurrentARKit() : AR_Kit {
      NodeAnalogRytmPattern npat <= nodeGetCurrentEditPattern();
      if(null != npat)
         return npat.getCurrentARKit();
      return null;
   }

   // <method.png>
   public method handleRemoveARKit(AR_Kit _arKit) {
      if(@(current_recv_kit) == @(_arKit))
      {
         current_recv_kit <= queued_recv_kit;

         if(null != current_recv_kit)
         {
            if(@(current_recv_kit) == @(_arKit))
            {
               current_recv_kit <= null;
               kit_recv_state = ST_IO_NONE;
            }
            else
            {
               queued_recv_kit <= null;
               kit_recv_state = ST_IO_DUMP_KITX;
            }
         }
         else
         {
            kit_recv_state = ST_IO_NONE;
         }
      }

      if(@(queued_recv_kit) == @(_arKit))
      {
         queued_recv_kit <= null;
      }
   }

   // <method.png>
   public =replay= method handleRemoveARPattern(AR_Pattern _arPattern) {
      if(@(current_recv_pattern) == @(_arPattern))
      {
         current_recv_pattern <= queued_recv_pattern;

         if(null != current_recv_pattern)
         {
            if(@(current_recv_pattern) == @(_arPattern))
            {
               current_recv_pattern <= null;
               pattern_recv_state = ST_IO_NONE;
            }
            else
            {
               queued_recv_pattern <= null;
               pattern_recv_state = ST_IO_DUMP_PATX_1;
            }
         }
         else
         {
            pattern_recv_state = ST_IO_NONE;
         }
      }

      if(@(queued_recv_pattern) == @(_arPattern))
      {
         queued_recv_pattern <= null;
      }
   }

   // <method_set.png>
   public =replay= method setEnableIn(boolean _bEnabled) {
      b_in_en = _bEnabled;

      updateCachedDevs();
   }

   // <method_set.png>
   public =replay= method setInDev(byte _devIdx) {
      in_dev = _devIdx;

      updateCachedDevs();
   }

   // <method_set.png>
   public =replay= method setInCh(byte _ch) {
      in_ch = _ch;
   }

   // <method_set.png>
   public =replay= method setEnableOut(boolean _bEnabled) {
      b_out_en = _bEnabled;

      updateCachedDevs();
   }

   // <method_set.png>
   public =replay= method setOutDev(byte _devIdx) {
      out_dev = _devIdx;

      updateCachedDevs();
   }

   // <method_set.png>
   public =replay= method setOutCh(byte _ch) {
      out_ch = _ch;
   }

   // <method_set.png>
   public =replay= method setUIPatternNumParts(int _num) {
      ui_pattern_num_parts = _num;
   }

   // <method_set.png>
   public =replay= method setEnableMuteNote(boolean _bEnable) {
      b_mute_note = _bEnable;
   }

   // <method_set.png>
   public =replay= method setEnableSkipMute(boolean _bEnable) {
      b_skip_mute = _bEnable;
   }

   // <method_set.png>
   public =replay= method setEnableSkipPerf(boolean _bEnable) {
      b_skip_perf = _bEnable;
   }

   // <save.png>
   public virtual nodeSaveState(Stream ofs) {
      ofs.i16 = 8; // Version

      Node::nodeSaveState(ofs);

      // Input
      ofs.i8 = in_dev;
      ofs.i8 = in_ch;
      ofs.i8 = b_in_en;

      // Output 1
      ofs.i8 = out_dev;
      ofs.i8 = out_ch;
      ofs.i8 = b_out_en;

      ofs.i8 = ui_pattern_num_parts; // v3+

      // Write patterns (v2+)
      NodeAnalogRytmPattern *pat;
      int patIdx = 0;
      loop(128)
      {
         pat <= patterns.get(patIdx);

         if(null != pat)
         {
            ofs.i8 = true; // bUsed

            pat.patSaveState(ofs);
         }
         else
         {
            // Unused
            ofs.i8 = false; // bUsed
         }

         // Next pattern
         patIdx++;
      }

      // Write skip mute (v5+)
      ofs.i8 = b_mute_note;

      // Write skip mute (v4+)
      ofs.i8 = b_skip_mute;

      // Write skip perf (v4+)
      ofs.i8 = b_skip_perf;

      // Write soundlock mask (v6+)
      ofs.i8 = b_lock_perf_resetval;
      ofs.i8 = b_lock_scene_resetval;
      ofs.i8 = b_lock_fx_resetval;
      ofs.i8 = b_lock_trk_1_resetval;
      ofs.i8 = b_lock_trk_2_resetval;
      ofs.i8 = b_lock_trk_3_resetval;
      ofs.i8 = b_lock_trk_4_resetval;
      ofs.i8 = b_lock_trk_5_resetval;
      ofs.i8 = b_lock_trk_6_resetval;
      ofs.i8 = b_lock_trk_7_resetval;
      ofs.i8 = b_lock_trk_8_resetval;
      ofs.i8 = b_lock_trk_9_resetval;
      ofs.i8 = b_lock_trk_10_resetval;
      ofs.i8 = b_lock_trk_11_resetval;
      ofs.i8 = b_lock_trk_12_resetval;

      // Write kit note redirection (v7+)
      ofs.i8 = kit_note_redirect_mode;

      // Redirect channel+polypressure (v8+)
      ofs.i8 = b_note_redirect_pressure;

      // Write kit editor track idx (v7+)
      ofs.i8 = kit_editor_track_idx;

      // Write kit editor auto trkswitch (v7+)
      ofs.i8 = b_kit_editor_trkswitch;
   }

   // <load.png>
   public virtual nodeLoadState(Stream ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      short ver = ifs.i16;

      if(ver >= 1)
      {
         if(!Node::nodeLoadState(ifs, _outDevIdxMap, _outDevUseCount))
         {
            return false;
         }

         b_auto_filter_a = false;
         b_auto_filter_b = false;

         // Input
         in_dev  = ifs.s8;
         in_ch   = ifs.u8;
         b_in_en = ifs.u8;

         if(-1 != in_dev)
         {
            _outDevUseCount.inc(in_dev);

            in_dev = _outDevIdxMap.get(in_dev);
         }

         // Output
         out_dev  = ifs.s8;
         out_ch   = ifs.u8;
         b_out_en = ifs.u8;

         if(-1 != out_dev)
         {
            _outDevUseCount.inc(out_dev);

            out_dev = _outDevIdxMap.get(out_dev);
         }

         if(ver >= 3)
         {
            ui_pattern_num_parts = ifs.u8;
         }

         if(ver >= 2)
         {
            // Read patterns
            int patIdx = 0;
            loop(128)
            {
               boolean bUsed = ifs.i8;

               // trace "xxx try read patIdx="+patIdx+" bUsed="+bUsed;

               if(bUsed)
               {
                  NodeAnalogRytmPattern pat <= new NodeAnalogRytmPattern;

                  pat.patInit(this, patIdx);

                  patterns[patIdx] = deref pat;

                  if(!pat.patLoadState(ifs, 1, _outDevIdxMap, _outDevUseCount))
                  {
                     return false;
                  }
               }
               else
               {
                  // Unused pattern slot
                  patterns[patIdx] = null;
               }

               patIdx++;
            }
         }

         if(ver >= 5)
         {
            b_mute_note = ifs.b8;  // v5+
         }

         if(ver >= 4)
         {
            b_skip_mute = ifs.b8;
            b_skip_perf = ifs.b8;
         }

         if(ver >= 6)
         {
            // Read soundlock mask (v6+)
            b_lock_perf_resetval   = ifs.b8;
            b_lock_scene_resetval  = ifs.b8;
            b_lock_fx_resetval     = ifs.b8;
            b_lock_trk_1_resetval  = ifs.b8;
            b_lock_trk_2_resetval  = ifs.b8;
            b_lock_trk_3_resetval  = ifs.b8;
            b_lock_trk_4_resetval  = ifs.b8;
            b_lock_trk_5_resetval  = ifs.b8;
            b_lock_trk_6_resetval  = ifs.b8;
            b_lock_trk_7_resetval  = ifs.b8;
            b_lock_trk_8_resetval  = ifs.b8;
            b_lock_trk_9_resetval  = ifs.b8;
            b_lock_trk_10_resetval = ifs.b8;
            b_lock_trk_11_resetval = ifs.b8;
            b_lock_trk_12_resetval = ifs.b8;
         }

         if(ver >= 7)
         {
            // Read kit note redirection (v7+)
            kit_note_redirect_mode = ifs.u8;

            if(ver >= 8)
            {
               // Redirect channel+polypressure (v8+)
               b_note_redirect_pressure = ifs.b8;
            }

            // Read kit editor track idx (v7+)
            kit_editor_track_idx = ifs.u8 % 12;

            // Read kit editor auto trkswitch (v7+)
            b_kit_editor_trkswitch = ifs.b8;
         }

         // Fix pre (node state) v4 "show in arranger" bug
         b_node_class_show = false;

         return true;
      }

      return false;
   }

   // <midi.png>
   protected method requestKitX(MIDIPipeFrame _frame, byte _kitNr) {
      Global.Debug2("AR::requestKitX: kitNr="+_kitNr);

      if(null != cached_out_dev)
      {
         Buffer req;
         req.size = 16;
         req.offset = 0;

         if(null != current_recv_kit)
         {
            if(current_recv_kit.addKitRequestX(req, 0/*devId*/, _kitNr))
            {
               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, req);

               // // cached_out_dev.addBuffer(req);
               Global.Debug2("AR: send KITX request, kitNr="+_kitNr);

               kit_recv_state = ST_IO_DUMP_KITX;
            }
            else
            {
               trace "[---] NodeAnalogRytm::requestKitX: addKitRequestX() failed.";
               current_recv_kit <= queued_recv_kit;

               if(null != current_recv_kit)
               {
                  kit_recv_state = ST_IO_REQUEST_KITX;
               }
               else
               {
                  kit_recv_state = ST_IO_NONE;
               }
            }
         }
         else
         {
            trace "[---] NodeAnalogRytm::requestKitX: nowhere to store received data.";
         }
      }
      else
      {
         trace "[---] NodeAnalogRytm::requestKitX: invalid output device.";
         kit_recv_state = ST_IO_NONE;
      }
   }

   // <midi.png>
   protected method sendKitX(MIDIPipeFrame _frame, byte _kitNr) {
      // trace "xxx AR::sendKitX: kitNr="+_kitNr;

      if(b_current_send_kit_valid)
      {
         if(null != cached_out_dev)
         {
            Buffer syx;
            syx.size = current_send_kit.getRequiredSizeSyx(); // need 3095 bytes
            syx.offset = 0;

            if(current_send_kit.sendKitX(syx, 0/*devId*/, _kitNr))
            {
               Global.Debug2("AR: send KITX kitNr="+_kitNr+", syx.offset="+syx.offset);

               current_kit_state = current_send_kit;

               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, syx);

               // trace "xxx AR::sendKitX: _frame.numEventsSysEx="+_frame.getNumEventsSysEx();

               // // cached_out_dev.addBuffer(syx);

               if(b_debug_sendrecv)
                  Utils.SaveBufferToFile("ar_kit_send_debug.syx", syx, 0, syx.offset);
            }
            else
            {
               trace "[---] sendKitX: kit.sendKitX() failed.";
            }
         }
      }
   }

   // <midi.png>
   protected method sendKitXSound(MIDIPipeFrame _frame, byte _trackIdx) {
      // trace "xxx AR::sendKitXSound: trackIdx="+_trackIdx;

      if(b_current_send_kitsound_valid)
      {
         if(null != cached_out_dev)
         {
            Buffer syx;
            syx.size = AR_SOUND_SYX_SZ; // need 207 bytes
            syx.offset = 0;

            if(current_send_kit.sendSoundX(syx, 0/*devId*/, _trackIdx))
            {
               // trace "[trc] AR: send KITX soundNr="+_trackIdx+", syx.offset="+syx.offset;

               current_kit_state = current_send_kit;

               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, syx);

               // trace "xxx AR::sendKitX: _frame.numEventsSysEx="+_frame.getNumEventsSysEx();

               if(b_debug_sendrecv)
                  Utils.SaveBufferToFile("ar_sound_send_debug.syx", syx, 0, syx.offset);
            }
            else
            {
               trace "[---] sendKitX: kit.sendKitX() failed.";
            }
         }
      }
   }

   // <midi.png>
   protected method requestSoundX(MIDIPipeFrame _frame, byte _soundNr) {
      Global.Debug2("AR::requestSoundX: soundNr="+_soundNr);

      if(null != cached_out_dev)
      {
         Buffer req;
         req.size = 16;
         req.offset = 0;

         if(null != current_recv_sound)
         {
            if(current_recv_sound.addSoundRequestX(req, 0/*devId*/, _soundNr))
            {
               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, req);

               Global.Debug2("AR: send SOUNDX request, soundNr="+_soundNr);

               sound_recv_state = ST_IO_DUMP_SOUNDX;
            }
            else
            {
               trace "[---] requestSoundX_KitQuery: addSoundRequestX() failed.";
               current_recv_sound <= queued_recv_sound;

               if(null != current_recv_sound)
               {
                  sound_recv_state = ST_IO_REQUEST_SOUNDX;
               }
               else
               {
                  sound_recv_state = ST_IO_NONE;
               }
            }
         }
         else
         {
            trace "[---] NodeAnalogRytm::requestSoundX: nowhere to store received data.";
         }
      }
      else
      {
         trace "[---] NodeAnalogRytm::requestSoundX: invalid output device.";
         sound_recv_state = ST_IO_NONE;
      }
   }

   // <midi.png>
   protected method sendGlobalX(MIDIPipeFrame _frame, byte _globalSlot) {
      trace "xxx AR::sendGlobalX: globalSlot="+_globalSlot;

      if(b_current_send_global_valid)
      {
         if(null != cached_out_dev)
         {
            Buffer syx;
            syx.size = current_send_global.getRequiredSizeSyx();
            syx.offset = 0;

            if(current_send_global.sendGlobal(syx, 0/*devId*/, _globalSlot, true/*bEditBuf*/))
            {
               Global.Debug2("AR: send GLOBALX globalSlot="+_globalSlot+", syx.offset="+syx.offset);

               current_global_state = current_send_global;

               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, syx);

               // trace "xxx AR::sendGlobalX: _frame.numEventsSysEx="+_frame.getNumEventsSysEx();

               // // cached_out_dev.addBuffer(syx);

               if(b_debug_sendrecv)
                  Utils.SaveBufferToFile("ar_global_send_debug.syx", syx, 0, syx.offset);
            }
            else
            {
               trace "[---] sendGlobalX: kit.sendGlobalX() failed.";
            }
         }
      }
   }

   // <midi.png>
   protected method requestGlobalX(MIDIPipeFrame _frame, byte _globalSlot) {
      Global.Debug2("AR::requestGlobalX: globalSlot="+_globalSlot);

      if(null != cached_out_dev)
      {
         Buffer req;
         req.size = 16;
         req.offset = 0;

         if(null != current_recv_global)
         {
            if(current_recv_global.addGlobalRequestX(req, 0/*devId*/, _globalSlot))
            {
               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, req);

               Global.Debug2("AR: send GLOBALX request, globalSlot="+_globalSlot);

               global_recv_state = ST_IO_DUMP_GLOBALX;
            }
            else
            {
               trace "[---] requestGlobalX: addGlobalRequestX() failed.";
               current_recv_global <= queued_recv_global;

               if(null != current_recv_global)
               {
                  global_recv_state = ST_IO_REQUEST_GLOBALX;
               }
               else
               {
                  global_recv_state = ST_IO_NONE;
               }
            }
         }
         else
         {
            trace "[---] NodeAnalogRytm::requestGlobalX: nowhere to store received data.";
         }
      }
      else
      {
         trace "[---] NodeAnalogRytm::requestGlobalX: invalid output device.";
         global_recv_state = ST_IO_NONE;
      }
   }

   // <midi.png>
   protected method sendSettingsX(MIDIPipeFrame _frame) {
      trace "xxx AR::sendSettingsX";

      if(b_current_send_settings_valid)
      {
         if(null != cached_out_dev)
         {
            Buffer syx;
            syx.size = current_send_settings.getRequiredSizeSyx();
            syx.offset = 0;

            if(current_send_settings.sendSettings(syx, 0/*devId*/))
            {
               Global.Debug2("AR: send SETTINGSX syx.offset="+syx.offset);

               current_settings_state = current_send_settings;

               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, syx);

               // trace "xxx AR::sendSettingsX: _frame.numEventsSysEx="+_frame.getNumEventsSysEx();

               // // cached_out_dev.addBuffer(syx);

               if(b_debug_sendrecv)
                  Utils.SaveBufferToFile("ar_settings_send_debug.syx", syx, 0, syx.offset);
            }
            else
            {
               trace "[---] sendSettingsX: kit.sendGlobalX() failed.";
            }
         }
      }
   }

   // <midi.png>
   protected method requestSettingsX(MIDIPipeFrame _frame) {
      Global.Debug2("AR::requestSettingsX");

      if(null != cached_out_dev)
      {
         Buffer req;
         req.size = 16;
         req.offset = 0;

         if(null != current_recv_settings)
         {
            if(current_recv_settings.addSettingsRequest(req, 0/*devId*/))
            {
               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, req);

               Global.Debug2("AR: send SETTINGSX request");

               settings_recv_state = ST_IO_DUMP_SETTINGSX;
            }
            else
            {
               trace "[---] requestSettingsX: addSettingsRequest() failed.";
               current_recv_settings <= queued_recv_settings;

               if(null != current_recv_settings)
               {
                  settings_recv_state = ST_IO_REQUEST_SETTINGSX;
               }
               else
               {
                  settings_recv_state = ST_IO_NONE;
               }
            }
         }
         else
         {
            trace "[---] NodeAnalogRytm::requestSettingsX: nowhere to store received data.";
         }
      }
      else
      {
         trace "[---] NodeAnalogRytm::requestSettingsX: invalid output device.";
         settings_recv_state = ST_IO_NONE;
      }
   }

   // <midi.png>
   protected method sendMute(MIDIPipeFrame _frame) {

      if(b_current_send_mute_valid)
      {
         if(null != cached_out_dev)
         {
            int trkIdx = 0;

            loop(12)
            {
               if(current_send_mute.get(trkIdx))
               {
                  // Muted
                  _frame.cc(true/*bSet*/, out_dev, trkIdx/*midiCh*/, 94/*ccId*/, 1/*value*/);
               }
               else
               {
                  // Not muted
                  _frame.cc(true/*bSet*/, out_dev, trkIdx/*midiCh*/, 94/*ccId*/, 0/*value*/);
               }

               trkIdx++;
            }

            current_mute_state = current_send_mute;
         }
      }
   }

   // <midi.png>
   protected method sendPerf(MIDIPipeFrame _frame) {

      if(b_current_send_perf_valid)
      {
         if(null != cached_out_dev)
         {
            int perfIdx = 0;

            loop(12)
            {
               int perfVal = current_send_perf.get(perfIdx);

               // trace "xxx sendPerf: perf["+perfIdx+"] = "+perfVal;

               if(perfVal >= 0)
               {
                  if(perfVal > 127)
                     perfVal = 127;

                  byte ccId = 35 + perfIdx;

                  if(ccId >= 39)
                     ccId++;

                  _frame.cc(true/*bSet*/, out_dev, 14/*midiCh*/, ccId/*ccId*/, perfVal/*value*/);
               }

               perfIdx++;
            }

            current_perf_state = current_send_perf;
         }
      }
   }

   // <midi.png>
   protected method requestPatternX(MIDIPipeFrame _frame, byte _patternNr) {
      Global.Debug("NAR::requestPatternX: patternNr="+_patternNr);

      if(null != current_recv_pattern)
      {
         if(null != cached_out_dev)
         {
            Buffer req;
            req.size = 16;
            req.offset = 0;

            if(current_recv_pattern.addPatternRequestX(req, 0/*devId*/, _patternNr))
            {
               _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, req);
               // trace "xxx requestPatternX: req.offset="+req.offset+" => frame.numEventsSysEx="+_frame.numEventsSysEx;

               Global.Debug2("AR: send PATX request patternNr="+_patternNr);

               pattern_recv_state = ST_IO_DUMP_PATX;
            }
            else
            {
               trace "[---] NodeAnalogRytm::requestPatternX: addPatternRequestX() failed.";

               current_recv_pattern <= queued_recv_pattern;

               if(null != current_recv_pattern)
               {
                  pattern_recv_state = ST_IO_REQUEST_PATX;
               }
               else
               {
                  pattern_recv_state = ST_IO_NONE;
               }
            }
         }
         else
         {
            trace "[---] NodeAnalogRytm::requestPatternX: invalid device.";
            pattern_recv_state = ST_IO_NONE;
         }
      }
      else
      {
         trace "[---] NodeAnalogRytm::requestPatternX: nowhere to store received data.";
      }
   }

   // <midi.png>
   protected method sendPatternX(MIDIPipeFrame _frame, byte _patternNr, short _syxOff, short _syxSz) {
      Global.Debug2("AR::sendPatternX: patternNr="+_patternNr+" off="+_syxOff+" sz="+_syxSz);

      if(null != current_send_pattern)
      {
         if(null != cached_out_dev)
         {
            Buffer syxArea;

            if(0 == _syxOff)
            {
               pattern_syx.size = current_send_pattern.getRequiredSizeSyx(); // need 15090(v1)/15107(v4) bytes
               pattern_syx.offset = 0;

               // // // if(pat.sendPatternX(syx, 0/*devId*/, _patternNr))

               // (note) [21Oct2019] in v1.50, AR does not accept obj_nr=127
               // // if(current_send_pattern.sendPattern(pattern_syx, 0/*devId*/, _patternNr, true/*bEditBuf*/))
               if(current_send_pattern.sendPattern(pattern_syx, 0/*devId*/, 2/*patternNr*/, true/*bEditBuf*/))
               {
                  // trace "xxx AR: send PATX, syx.offset="+syx.offset;

                  if(_syxSz > pattern_syx.offset)
                     _syxSz = pattern_syx.offset;

                  if(_syxSz < pattern_syx.offset)
                  {
                     // Send pattern part

                     if(syxArea.visit(pattern_syx, _syxOff, _syxSz))
                     {
                        syxArea.offset = syxArea.size;
                        Global.Debug("AR::sendPatternX: send "+syxArea.offset+" area bytes");
                        _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, syxArea);
                     }
                  }
                  else
                  {
                     // Send entire pattern
                     Global.Debug("AR::sendPatternX: send "+pattern_syx.offset+" bytes");
                     _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, pattern_syx);
                  }

                  // trace "xxx AR::sendPattern: _frame.numEventsSysEx="+_frame.getNumEventsSysEx();

                  if(b_debug_sendrecv)
                     Utils.SaveBufferToFile("ar_pat_send_debug.syx", pattern_syx, 0, pattern_syx.offset);
               }
               else
               {
                  trace "[---] sendPatternX: pat.sendPattern() failed.";
               }
            }
            else if(pattern_syx.offset > 0)
            {
               if((_syxOff + _syxSz) > pattern_syx.offset)
               {
                  // Send last part
                  _syxSz = pattern_syx.offset - _syxOff;
               }

               if((_syxOff + _syxSz) <= pattern_syx.offset)
               {
                  // Send pattern part 2/3/4/5/..

                  if(syxArea.visit(pattern_syx, _syxOff, _syxSz))
                  {
                     syxArea.offset = syxArea.size;
                     Global.Debug("AR::sendPatternX: send "+syxArea.offset+" area bytes (offset="+_syxOff+")");
                     _frame.sysex(true/*bSet*/, out_dev/*devIdx*/, syxArea);
                  }
               }
            }
            else
            {
               trace "[---] NodeAnalogRytm::sendPatternX: pattern_syx.offset is 0 !!!";
            }
         }
      }
      else
      {
         trace "[---] NodeAnalogRytm::sendPatternX: no pattern to send.";
      }
   }

   // <debug.png>
   protected static SaveKitAsRaw(AR_Kit _kit, String _filename) {
      local File f;
      local String filename <= Utils.ToNativePathName(_filename);
      if(f.openLocal(filename, IOS_OUT))
      {
         // writes 4 bytes header (ver + size)
         _kit.saveRawToStream(f);

         f.close();
      }
   }

   // <midi.png>
   protected method handleSyxReceive(MIDIPipeFrame _frame) {
      MIDIPipeEvent pev;
      Buffer bufOld;  // debug
      Buffer bufNew;  // debug

      // // int numSyx1 = _frame.getNumEventsSysExByFlt(-1);
      // // if(numSyx1 > 0)
      // // {
      // //    trace "[trc] NodeAnalogRytm::handleSyxReceive: 1 numSyx="+numSyx1;
      // // }

      if(-1 != in_dev)
      {
         int numSyx = _frame.getNumEventsSysExByFlt(in_dev);

         if(numSyx > 0)
         {
            Global.Debug2("NodeAnalogRytm::handleSyxReceive: numSyx="+numSyx);

            if(_frame.getEventByIdxAndFlt(0, pev, MIDIPIPE_EVENT_TYPE_SYSEX, in_dev, -1/*ch,ignored*/))
            {
               Buffer pevSyx <= pev.getSysExBuffer();

               if(null != pevSyx)
               {
                  Global.Debug2("NodeAnalogRytm::handleSyxReceive: pevSyx.offset="+pevSyx.offset+" (maxBufSz="+pevSyx.size+")");
                   // Utils.HexDump(pevSyx, 0, pevSyx.offset);

                  switch(kit_recv_state)
                  {
                     case ST_IO_NONE:
                     default:
                        // trace "[~~~] NodeAR: got SYX but expecting none";
                        break;

                     case ST_IO_DUMP_KITX:
                        AR_Kit tempKit;

                        if(null != current_recv_kit)
                        {
                           if(b_debug_sendrecv)
                              Utils.SaveBufferToFile("ar_kit_recv_debug.syx", pevSyx, 0, pevSyx.offset);

                           if(tempKit.syxToRaw(pevSyx))
                           {
                              trace "[...] NodeAR: KITX syx converted to raw.";

                              // // Utils.SaveBufferToFile("debug_kit.dat", pevSyx, 0, pevSyx.size);
                              // SaveKitAsRaw(current_recv_kit, "debug_kit.dat");

                              if(b_debug_diff)
                              {
                                 current_kit_state.getRawBuffer(bufOld);
                                 tempKit.getRawBuffer(bufNew);
                                 // trace "xxx save \"ar_debug_kit.dat\" bufNew.offset="+bufNew.offset+" bufNew.size="+bufNew.size;
                                 // Utils.SaveBufferToFile("ar_debug_kit.dat", bufNew, 0, bufNew.size);
                                 Utils.BufferDiffARKit(bufOld, bufNew, true/*bVerbose*/);
                              }

                              // // bufNew.pokeI8(0x7f, 0x50); // amp decay lsb?
                              // // bufNew.pokeI8(0x6f, 0x50); // flt decay lsb?

                              boolean bAll =
                                 (2/*RAW*/ != current_kit_state.getCurrentDataIdx()) ||
                                 (2/*RAW*/ != current_recv_kit.getCurrentDataIdx())  ||
                                 (KIT_PARTIAL_ALL == kit_recv_partial_flags)         ;

                              if(bAll)
                              {
                                 trace "xxx NAR: ST_IO_DUMP_KITX: bAll=true";
                                 current_recv_kit  = tempKit;
                                 current_kit_state = current_recv_kit;
                              }
                              else
                              {
                                 trace "xxx NAR: ST_IO_DUMP_KITX: partialFlags="+kit_recv_partial_flags;
                                 if(kit_recv_partial_flags & KIT_PARTIAL_PERF)
                                 {
                                    current_recv_kit .copyPerfCtlFrom(tempKit);
                                    current_kit_state.copyPerfCtlFrom(tempKit);
                                 }
                                 if(kit_recv_partial_flags & KIT_PARTIAL_SCENE)
                                 {
                                    current_recv_kit .copySceneCtlFrom(tempKit);
                                    current_kit_state.copySceneCtlFrom(tempKit);
                                 }
                                 if(kit_recv_partial_flags & KIT_PARTIAL_FX)
                                 {
                                    current_recv_kit .copyFXFrom(tempKit);
                                    current_kit_state.copyFXFrom(tempKit);
                                 }
                                 int trackIdx = 0;
                                 loop(12)
                                 {
                                    if(kit_recv_partial_flags & (KIT_PARTIAL_TRK_1 << trackIdx))
                                    {
                                       trace "xxx copy partial trackIdx="+trackIdx;
                                       current_recv_kit .copyTrackSoundFrom(trackIdx, tempKit, trackIdx);
                                       current_kit_state.copyTrackSoundFrom(trackIdx, tempKit, trackIdx);
                                    }
                                    trackIdx++;
                                 }

                              }

                              current_recv_kit <= queued_recv_kit;
                              queued_recv_kit <= null;

                              if(null != current_recv_kit)
                              {
                                 kit_recv_state         = ST_IO_REQUEST_KITX;
                                 remote_recv_kit_nr     = queued_remote_recv_kit_nr;
                                 kit_recv_partial_flags = queued_kit_recv_partial_flags;
                              }
                              else
                              {
                                 kit_recv_state = ST_IO_NONE;
                              }
                           }
                           else
                           {
                              // Failed to decode RAW
                              current_recv_kit <= null;
                              queued_recv_kit  <= null;
                              kit_recv_state    = ST_IO_NONE;
                           }
                        }
                        else
                        {
                           trace "[...] NodeAR: KITX syx discarded (current_recv_kit is null).";
                           current_recv_kit <= queued_recv_kit;
                           queued_recv_kit <= null;

                           if(null != current_recv_kit)
                           {
                              kit_recv_state         = ST_IO_REQUEST_KITX;
                              remote_recv_kit_nr     = queued_remote_recv_kit_nr;
                              kit_recv_partial_flags = queued_kit_recv_partial_flags;
                           }
                           else
                           {
                              kit_recv_state = ST_IO_NONE;
                           }
                        }
                        break;

                  }

                  switch(pattern_recv_state)
                  {
                     case ST_IO_NONE:
                     default:
                        // trace "[~~~] NodeAR: got SYX but expecting none";
                        break;

                     case ST_IO_DUMP_PATX:
                        if(null != current_recv_pattern)
                        {
                           if(b_debug_sendrecv)
                              Utils.SaveBufferToFile("ar_pat_recv_debug.syx", pevSyx, 0, pevSyx.offset);

                           if(b_debug_diff)
                           {
                              current_recv_pattern.getRawBuffer(bufNew); // get ref
                              bufOld = bufNew;
                           }

                           if(current_recv_pattern.syxToRaw(pevSyx))
                           {
                              trace "[...] NodeAR: PATX syx converted to raw.";

                              Global.SetARPatternClipboard(current_recv_pattern);

                              if(b_debug_diff)
                              {
                                 current_recv_pattern.getRawBuffer(bufNew);
                                 // trace "xxx save \"ar_debug_pattern.dat\" bufNew.offset="+bufNew.offset+" bufNew.size="+bufNew.size;
                                 // Utils.SaveBufferToFile("ar_debug_pattern.dat", bufNew, 0, bufNew.size);
                                 // Utils.BufferDiff(bufOld, bufNew, true/*bVerbose*/);
                                 Utils.BufferDiffARPattern(bufOld, bufNew, true/*bVerbose*/);
                                 bufNew.byteOrder = YAC_BIG_ENDIAN;

                                 // Integer io = bufNew.peekI16(4);
                                 // trace "xxx track 1/step1 trigFlags="+io.printf("0x%04x");
                              }

                              current_recv_pattern <= queued_recv_pattern;

                              if(null != current_recv_pattern)
                              {
                                 pattern_recv_state     = ST_IO_REQUEST_PATX;
                                 remote_recv_pattern_nr = queued_remote_recv_pattern_nr;
                              }
                              else
                              {
                                 pattern_recv_state = ST_IO_NONE;
                              }
                           }
                           else
                           {
                              // Failed to decode RAW
                              current_recv_pattern <= null;
                              queued_recv_pattern <= null;
                              pattern_recv_state = ST_IO_NONE;
                           }
                        }
                        else
                        {
                           trace "[...] NodeAR: PAT syx discarded (current_recv_pattern is null).";

                           current_recv_pattern <= queued_recv_pattern;

                           if(null != current_recv_pattern)
                           {
                              pattern_recv_state     = ST_IO_REQUEST_PATX;
                              remote_recv_pattern_nr = queued_remote_recv_pattern_nr;
                           }
                           else
                           {
                              pattern_recv_state = ST_IO_NONE;
                           }
                        }
                        break;
                  }


                  switch(sound_recv_state)
                  {
                     case ST_IO_DUMP_SOUNDX:
                        AR_Sound tempSound;

                        if(null != current_recv_sound)
                        {
                           if(b_debug_sendrecv)
                              Utils.SaveBufferToFile("ar_sound_recv_debug.syx", pevSyx, 0, pevSyx.offset);

                           if(tempSound.syxToRaw(pevSyx))
                           {
                              trace "[...] NodeAR: SOUNDX syx converted to raw.";

                              // // Utils.SaveBufferToFile("debug_kit.dat", pevSyx, 0, pevSyx.size);
                              // SaveKitAsRaw(current_recv_kit, "debug_kit.dat");

                              if(b_debug_diff)
                              {
                                 current_sound_state.getRawBuffer(bufOld);
                                 tempSound.getRawBuffer(bufNew);
                                 Utils.BufferDiff(bufOld, bufNew, true/*bVerbose*/);
                              }

                              // // bufNew.pokeI8(0x7f, 0x50); // amp decay lsb?
                              // // bufNew.pokeI8(0x6f, 0x50); // flt decay lsb?

                              current_recv_sound  = tempSound;
                              current_sound_state = current_recv_sound;

                              current_recv_sound <= queued_recv_sound;
                              queued_recv_sound <= null;

                              if(null != current_recv_sound)
                              {
                                 sound_recv_state      = ST_IO_REQUEST_SOUNDX;
                                 remote_recv_sound_nr  = queued_remote_recv_sound_nr;
                              }
                              else
                              {
                                 sound_recv_state = ST_IO_NONE;
                              }
                           }
                           else
                           {
                              // Failed to decode RAW
                              current_recv_sound <= null;
                              queued_recv_sound  <= null;
                              sound_recv_state    = ST_IO_NONE;
                           }
                        }
                        else
                        {
                           trace "[...] NodeAR: SOUNDX syx discarded (current_recv_sound is null).";
                           current_recv_sound <= queued_recv_sound;
                           queued_recv_sound <= null;

                           if(null != current_recv_sound)
                           {
                              sound_recv_state         = ST_IO_REQUEST_SOUNDX;
                              remote_recv_sound_nr     = queued_remote_recv_sound_nr;
                           }
                           else
                           {
                              sound_recv_state = ST_IO_NONE;
                           }
                        }
                        break;
                  }


                  switch(global_recv_state)
                  {
                     case ST_IO_DUMP_GLOBALX:
                        AR_Global tempGlobal;

                        if(null != current_recv_global)
                        {
                           if(b_debug_sendrecv)
                              Utils.SaveBufferToFile("ar_global_recv_debug.syx", pevSyx, 0, pevSyx.offset);

                           if(tempGlobal.syxToRaw(pevSyx))
                           {
                              trace "[...] NodeAR: GLOBALX syx converted to raw.";

                              // // Utils.SaveBufferToFile("debug_global.dat", pevSyx, 0, pevSyx.size);
                              // SaveKitAsRaw(current_recv_kit, "debug_global.dat");

                              if(b_debug_diff)
                              {
                                 current_global_state.getRawBuffer(bufOld);
                                 tempGlobal.getRawBuffer(bufNew);
                                 Utils.BufferDiff(bufOld, bufNew, true/*bVerbose*/);
                              }

                              current_recv_global  = tempGlobal;
                              current_global_state = current_recv_global;

                              // trace "xxx tempGlobal.currentDataIdx="+tempGlobal.currentDataIdx;
                              // trace "xxx current_recv_global.currentDataIdx="+current_recv_global.currentDataIdx;

                              current_recv_global <= queued_recv_global;
                              queued_recv_global <= null;

                              if(null != current_recv_global)
                              {
                                 global_recv_state      = ST_IO_REQUEST_GLOBALX;
                                 remote_recv_global_nr  = queued_remote_recv_global_nr;
                              }
                              else
                              {
                                 global_recv_state = ST_IO_NONE;
                              }
                           }
                           else
                           {
                              // Failed to decode RAW
                              current_recv_global <= null;
                              queued_recv_global  <= null;
                              global_recv_state    = ST_IO_NONE;
                           }
                        }
                        else
                        {
                           trace "[...] NodeAR: GLOBALX syx discarded (current_recv_global is null).";
                           current_recv_global <= queued_recv_global;
                           queued_recv_global  <= null;

                           if(null != current_recv_global)
                           {
                              global_recv_state     = ST_IO_REQUEST_GLOBALX;
                              remote_recv_global_nr = queued_remote_recv_global_nr;
                           }
                           else
                           {
                              global_recv_state = ST_IO_NONE;
                           }
                        }
                        break;
                  }


                  switch(settings_recv_state)
                  {
                     case ST_IO_DUMP_SETTINGSX:
                        AR_Settings tempSettings;

                        if(null != current_recv_settings)
                        {
                           if(b_debug_sendrecv)
                              Utils.SaveBufferToFile("ar_settings_recv_debug.syx", pevSyx, 0, pevSyx.offset);

                           if(tempSettings.syxToRaw(pevSyx))
                           {
                              trace "[...] NodeAR: SETTINGS syx converted to raw.";

                              // // Utils.SaveBufferToFile("debug_settings.dat", pevSyx, 0, pevSyx.size);
                              // SaveKitAsRaw(current_recv_kit, "debug_settings.dat");

                              if(b_debug_diff)
                              {
                                 current_settings_state.getRawBuffer(bufOld);
                                 tempSettings.getRawBuffer(bufNew);
                                 Utils.HexDump(bufNew, 0, bufNew.offset);
                                 Utils.BufferDiff(bufOld, bufNew, true/*bVerbose*/);
                              }

                              current_recv_settings  = tempSettings;
                              current_settings_state = current_recv_settings;

                              // trace "xxx tempSettings.currentDataIdx="+tempSettings.currentDataIdx;
                              // trace "xxx current_recv_settings.currentDataIdx="+current_recv_settings.currentDataIdx;

                              current_recv_settings <= queued_recv_settings;
                              queued_recv_settings  <= null;

                              if(null != current_recv_settings)
                              {
                                 settings_recv_state = ST_IO_REQUEST_SETTINGSX;
                              }
                              else
                              {
                                 settings_recv_state = ST_IO_NONE;
                              }
                           }
                           else
                           {
                              // Failed to decode RAW
                              current_recv_settings <= null;
                              queued_recv_settings  <= null;
                              settings_recv_state    = ST_IO_NONE;
                           }
                        }
                        else
                        {
                           trace "[...] NodeAR: SETTINGSX syx discarded (current_recv_settings is null).";
                           current_recv_settings <= queued_recv_settings;
                           queued_recv_settings <= null;

                           if(null != current_recv_settings)
                           {
                              settings_recv_state = ST_IO_REQUEST_SETTINGSX;
                           }
                           else
                           {
                              settings_recv_state = ST_IO_NONE;
                           }
                        }
                        break;
                  }
               }
               else
               {
                  trace "[---] NodeAR: getSysExBuffer() failed";
               }
            }
            else
            {
               trace "[---] NodeAR: getEventByIdxAndFlt() failed";
            }
         }
      }
   }

   // <method.png>
   protected method execMapAction(NAR_MapAction _mapac, MIDIPipeFrame _frameOut) {
      // trace "xxx execMapAction";

      NodeAnalogRytmPattern pat <= nodeGetCurrentPlayPattern();
      if(null == pat)
         return;

      NAR_Pattern  *narPattern;
      NAR_Kit      *narKit;
      NAR_Mute     *narMute;
      NAR_Perf     *narPerf;
      NAR_MapGroup *mapgrp;

      switch(_mapac.action_id)
      {
         case NAR_MapAction.AC_SNAPSHOT_SELECT:       // arg1=snapshot nr
            if(0 <= _mapac.action_arg1 <= 127)
            {
               nodeSetCurrentPlayPatternNr(_mapac.action_arg1);
               nodeSetCurrentEditPatternNr(_mapac.action_arg1);
               b_ui_update_queued = true;
            }
            break;

         case NAR_MapAction.AC_SNAPSHOT_SELECT_PREV:  //
            if(play_pattern_nr >= 0)
            {
               int prevSnapNr = play_pattern_nr - 1;
               nodeSetCurrentPlayPatternNr(prevSnapNr);
               nodeSetCurrentEditPatternNr(prevSnapNr);
               b_ui_update_queued = true;
            }
            break;

         case NAR_MapAction.AC_SNAPSHOT_SELECT_NEXT:  //
            if(play_pattern_nr < 127)
            {
               int nextSnapNr = play_pattern_nr + 1;
               nodeSetCurrentPlayPatternNr(nextSnapNr);
               nodeSetCurrentEditPatternNr(nextSnapNr);
               b_ui_update_queued = true;
            }
            break;

         case NAR_MapAction.AC_PAT_SELECT:            // arg1=pat uid
            narPattern <= pat.getPatternByUID(_mapac.action_arg1);
            if(null != narPattern)
            {
               pat.setCurrentPatternIdx(pat.getPatternIdx(narPattern));
               b_ui_update_queued = true;
            }
            break;

         case NAR_MapAction.AC_PAT_SELECT_PREV:       //
            pat.setCurrentPatternIdx(pat.current_pattern_idx - 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_PAT_SELECT_NEXT:       //
            pat.setCurrentPatternIdx(pat.current_pattern_idx + 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_PAT_RECV:              // arg1=pat uid, 0=use current
            if(0 == _mapac.action_arg1)
            {
               narPattern <= pat.getCurrentNARPattern();

               if(null != narPattern)
               {
                  queuePatternQuery(narPattern.ar_pattern, narPattern.remote_pattern_nr);
               }
            }
            else
            {
               narPattern <= pat.getPatternByUID(_mapac.action_arg1);

               if(null != narPattern)
               {
                  queuePatternQuery(narPattern.ar_pattern, narPattern.remote_pattern_nr);
               }
            }
            break;

         case NAR_MapAction.AC_PAT_SEND:              // arg1=pat uid, 0=use current
            if(0 == _mapac.action_arg1)
            {
               narPattern <= pat.getCurrentNARPattern();

               if(null != narPattern)
               {
                  queuePatternSend(narPattern.ar_pattern, narPattern.remote_pattern_nr);
               }
            }
            else
            {
               narPattern <= pat.getPatternByUID(_mapac.action_arg1);

               if(null != narPattern)
               {
                  queuePatternSend(narPattern.ar_pattern, narPattern.remote_pattern_nr);
               }
            }
            break;

         case NAR_MapAction.AC_KIT_SELECT:            // arg1=kit uid
            narKit <= pat.getKitByUID(_mapac.action_arg1);
            if(null != narKit)
            {
               pat.setCurrentKitIdx(pat.getKitIdx(narKit));
               b_ui_update_queued = true;
            }
            break;

         case NAR_MapAction.AC_KIT_SELECT_PREV:       //
            pat.setCurrentKitIdx(pat.current_kit_idx - 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_KIT_SELECT_NEXT:       //
            pat.setCurrentKitIdx(pat.current_kit_idx + 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_KIT_RECV:              // arg1=kit uid, 0=use current
            if(0 == _mapac.action_arg1)
            {
               narKit <= pat.getCurrentNARKit();

               if(null != narKit)
               {
                  queueKitQuery(narKit.ar_kit, narKit.remote_kit_nr);
               }
            }
            else
            {
               narKit <= pat.getKitByUID(_mapac.action_arg1);

               if(null != narKit)
               {
                  queueKitQuery(narKit.ar_kit, narKit.remote_kit_nr);
               }
            }
            break;

         case NAR_MapAction.AC_KIT_SEND:              // arg1=kit uid, 0=use current
            if(0 == _mapac.action_arg1)
            {
               narKit <= pat.getCurrentNARKit();

               if(null != narKit)
               {
                  queueKitSend(narKit.ar_kit, narKit.remote_kit_nr);
               }
            }
            else
            {
               narKit <= pat.getKitByUID(_mapac.action_arg1);

               if(null != narKit)
               {
                  queueKitSend(narKit.ar_kit, narKit.remote_kit_nr);
               }
            }
            break;

         case NAR_MapAction.AC_MUTE_SELECT:           // arg1=mute uid
            narMute <= pat.getMuteByUID(_mapac.action_arg1);
            if(null != narMute)
            {
               pat.setCurrentMuteIdx(pat.getMuteIdx(narMute));
               b_ui_update_queued = true;
            }
            break;

         case NAR_MapAction.AC_MUTE_SELECT_PREV:      //
            pat.setCurrentMuteIdx(pat.current_mute_idx - 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_MUTE_SELECT_NEXT:      //
            pat.setCurrentMuteIdx(pat.current_mute_idx + 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_MUTE_STORE:            // arg1=mute uid, 0=use current
            if(0 == _mapac.action_arg1)
            {
               narMute <= pat.getCurrentNARMute();

               if(null != narMute)
               {
                  queueMuteStore(narMute.mute_state);
                  b_ui_update_queued = true;
               }
            }
            else
            {
               narMute <= pat.getMuteByUID(_mapac.action_arg1);

               if(null != narMute)
               {
                  queueMuteStore(narMute.mute_state);
                  b_ui_update_queued = true;
               }
            }
            break;

         case NAR_MapAction.AC_MUTE_RECALL:           // arg1=mute uid, 0=use current
            if(0 == _mapac.action_arg1)
            {
               narMute <= pat.getCurrentNARMute();

               if(null != narMute)
               {
                  queueMuteSend(narMute.mute_state);
               }
            }
            else
            {
               narMute <= pat.getMuteByUID(_mapac.action_arg1);

               if(null != narMute)
               {
                  queueMuteSend(narMute.mute_state);
               }
            }
            break;

         case NAR_MapAction.AC_MUTE:                  // arg1=tracknr (1..12)
            if(1 <= _mapac.action_arg1 <= 12)
            {
               _frameOut.cc(true/*bSet*/, out_dev, (_mapac.action_arg1 - 1)/*midiCh*/, 94/*ccId*/, 1/*value*/);
               current_mute_state[_mapac.action_arg1 - 1] = true;
            }
            break;

         case NAR_MapAction.AC_UNMUTE:                // arg1=tracknr (1..12)
            if(1 <= _mapac.action_arg1 <= 12)
            {
               _frameOut.cc(true/*bSet*/, out_dev, (_mapac.action_arg1 - 1)/*midiCh*/, 94/*ccId*/, 0/*value*/);
               current_mute_state[_mapac.action_arg1 - 1] = false;
            }
            break;

         case NAR_MapAction.AC_MUTE_TOGGLE:           // arg1=tracknr (1..12)
            if(1 <= _mapac.action_arg1 <= 12)
            {
               if(true == current_mute_state.get(_mapac.action_arg1 - 1))
               {
                  // Unmute
                  _frameOut.cc(true/*bSet*/, out_dev, (_mapac.action_arg1 - 1)/*midiCh*/, 94/*ccId*/, 0/*value*/);
                  current_mute_state[_mapac.action_arg1 - 1] = false;
               }
               else
               {
                  // Mute
                  _frameOut.cc(true/*bSet*/, out_dev, (_mapac.action_arg1 - 1)/*midiCh*/, 94/*ccId*/, 1/*value*/);
                  current_mute_state[_mapac.action_arg1 - 1] = true;
               }
            }
            break;

         case NAR_MapAction.AC_PERF_SELECT:           // arg1=perf uid
            narPerf <= pat.getPerfByUID(_mapac.action_arg1);
            if(null != narPerf)
            {
               pat.setCurrentPerfIdx(pat.getPerfIdx(narPerf));
               b_ui_update_queued = true;
            }
            break;

         case NAR_MapAction.AC_PERF_SELECT_PREV:      //
            pat.setCurrentPerfIdx(pat.current_perf_idx - 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_PERF_SELECT_NEXT:      //
            pat.setCurrentPerfIdx(pat.current_perf_idx + 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_PERF_STORE:            // arg1=perf uid, 0=use current
            if(0 == _mapac.action_arg1)
            {
               narPerf <= pat.getCurrentNARPerf();

               if(null != narPerf)
               {
                  queuePerfStore(narPerf.perf_state);
                  b_ui_update_queued = true;
               }
            }
            else
            {
               narPerf <= pat.getPerfByUID(_mapac.action_arg1);

               if(null != narPerf)
               {
                  queuePerfStore(narPerf.perf_state);
                  b_ui_update_queued = true;
               }
            }
            break;

         case NAR_MapAction.AC_PERF_RECALL:           // arg1=perf uid, 0=use current
            // trace "xxx AC_PERF_RECALL: arg1="+_mapac.action_arg1;

            if(0 == _mapac.action_arg1)
            {
               narPerf <= pat.getCurrentNARPerf();

               if(null != narPerf)
               {
                  queuePerfSend(narPerf.perf_state);
               }
            }
            else
            {
               narPerf <= pat.getPerfByUID(_mapac.action_arg1);

               // trace "xxx AC_PERF_RECALL: narPerf="+#(narPerf);

               if(null != narPerf)
               {
                  queuePerfSend(narPerf.perf_state);
               }
            }
            break;

         case NAR_MapAction.AC_PERF_TRANSITION:       // arg1=transition target (uid), arg2=transition time in 16ths
            if(0 == _mapac.action_arg1)
            {
               narPerf <= pat.getCurrentNARPerf();
            }
            else
            {
               narPerf <= pat.getPerfByUID(_mapac.action_arg1);
            }

            if(null != narPerf)
            {
               Global.Debug2("NAR: start transition, 16th="+_mapac.action_arg2);
               queuePerfTransition(narPerf.perf_state, _mapac.action_arg2/*time*/);
            }
            else
            {
               // Abort transition
               perf_send_state = ST_IO_NONE;
               Global.Debug2("NAR: abort transition");
            }
            break;

         case NAR_MapAction.AC_SCENE_SELECT:          // arg1=scene nr (0..11)
            if(1 <= _mapac.action_arg1 <= 12)
            {
               _frameOut.cc(true/*bSet*/, out_dev, 1/*midiCh*/, 92/*ccId*/, _mapac.action_arg1/*value*/);
            }
            break;

         case NAR_MapAction.AC_GROUP_SELECT:          // arg1=grp uid
            mapgrp <= pat.getMapGroupByUID(_mapac.action_arg1);
            if(null != mapgrp)
            {
               pat.setCurrentGroupIdx(pat.getMapGroupIdx(mapgrp));
               b_ui_update_queued = true;
               // trace "xxx select group UID="+_mapac.action_arg1;
            }
            break;

         case NAR_MapAction.AC_GROUP_SELECT_PREV:     //
            pat.setCurrentGroupIdx(pat.current_group_idx - 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_GROUP_SELECT_NEXT:     //
            pat.setCurrentGroupIdx(pat.current_group_idx + 1);
            b_ui_update_queued = true;
            break;

         case NAR_MapAction.AC_EXT_PRGCHG:            // arg1=prg#
            if(-1 != _mapac.ext_dev_idx)
            {
               _frameOut.prgChg(true/*bSet*/,
                                _mapac.ext_dev_idx,
                                _mapac.ext_midi_ch,
                                int(_mapac.action_arg1)&127/*prg*/
                                );
            }
            break;

         case NAR_MapAction.AC_EXT_NOTEON:            // arg1=note#, arg2=velocity, arg3=duration
            if(-1 != _mapac.ext_dev_idx)
            {
               _frameOut.noteOn(true/*bSet*/,
                                _mapac.ext_dev_idx,
                                _mapac.ext_midi_ch,
                                int(_mapac.action_arg1)&127/*note*/,
                                int(_mapac.action_arg2)&127/*vel*/,
                                int(_mapac.action_arg3)&127/*dur*/
                                );
            }
            break;

         case NAR_MapAction.AC_EXT_NOTEOFF:           // arg1=note#, arg2=velocity
            if(-1 != _mapac.ext_dev_idx)
            {
               _frameOut.noteOff(true/*bSet*/,
                                 _mapac.ext_dev_idx,
                                 _mapac.ext_midi_ch,
                                 int(_mapac.action_arg1)&127/*note*/,
                                 int(_mapac.action_arg2)&127/*vel*/
                                 );
            }
            break;

         case NAR_MapAction.AC_EXT_CC:                // arg1=cc#, arg2=ccval
            if(-1 != _mapac.ext_dev_idx)
            {
               _frameOut.cc(true/*bSet*/,
                            _mapac.ext_dev_idx,
                            _mapac.ext_midi_ch/*midiCh*/,
                            int(_mapac.action_arg1)&127/*ccId*/,
                            int(_mapac.action_arg2)&127/*ccValue*/
                            );
            }
            break;

         case NAR_MapAction.AC_EXT_NRPN:              // arg1=nrpn#, arg2=nrpnval
            if(-1 != _mapac.ext_dev_idx)
            {
               _frameOut.nrpn(true/*bSet*/,
                              _mapac.ext_dev_idx,
                              _mapac.ext_midi_ch/*midiCh*/,
                              int(_mapac.action_arg1)&16383/*nrpn*/,
                              int(_mapac.action_arg2)&16383/*value*/
                              );
            }
            break;

      }
   }

   // <method.png>
   protected method findMapGroupEntryAndExec(NAR_MapGroup grp, MIDIPipeFrame _frameOut) {
      if(null != grp)
      {
         if(grp.b_enable)
         {
            NAR_MapEntry *mapen;
            foreach mapen in grp.entries
            {
               // trace "xxx try mapen=\""+mapen.name+"\" mapen.input_id1="+mapen.input_id1+" mapen.input_id2="+mapen.input_id2+" mapen.input_arg1="+mapen.input_arg1+" mapen.input_arg2="+mapen.input_arg2;

               if(mapen.b_enable)
               {
                  if(mapen.input_id1 == current_input_id1)
                  {
                     if(mapen.input_arg1 == current_input_arg1)
                     {
                        if(mapen.input_id2 == current_input_id2)
                        {
                           if( (mapen.input_arg2 == current_input_arg2) || (NAR_MapEntry.IN_NONE == mapen.input_id2) )
                           {
                              Global.Debug2("AR: found map entry name=\""+mapen.name+"\"");

                              NAR_MapAction *mapac;
                              foreach mapac in mapen.actions
                              {
                                 if(mapac.b_enable)
                                 {
                                    execMapAction(mapac, _frameOut);
                                 }
                              }
                              return true;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      return false;
   }

   // <method.png>
   protected method findEntryAndExec(MIDIPipeFrame _framePlay, boolean _bFirstTry) : boolean {
      boolean ret = false;

      if(NAR_MapEntry.IN_NONE != current_input_id1)
      {
         // trace "[trc] AR::findEntryAndExec: id1="+current_input_id1+" arg1="+current_input_arg1+" id2="+current_input_id2+" arg2="+current_input_arg2;
         NodeAnalogRytmPattern pat <= nodeGetCurrentPlayPattern();

         if(null != pat)
         {
            NAR_MapGroup grp <= pat.getCurrentMapGroup();

            boolean bDone = findMapGroupEntryAndExec(grp, _framePlay);

            if(!bDone)
            {
               foreach grp in pat.groups
               {
                  if(grp.b_enable)
                  {
                     if(grp.b_global)
                     {
                        bDone = findMapGroupEntryAndExec(grp, _framePlay);
                        if(bDone)
                           break;
                     }
                  }
               }
            }

            ret = bDone;
         }

         if(!_bFirstTry)
         {
            b_current_input_id1_used = true;

            if(NAR_MapEntry.IN_MUTE == current_input_id1)
            {
               // Reset
               current_input_id1  = NAR_MapEntry.IN_NONE;
               current_input_arg1 = 0;
            }
         }

      }

      return ret;
   }

   // <method_handle.png>
   protected method handleKitRedirectNotes(MIDIPipeFrame _frame, MIDIPipeFrame _frameOut) {
      MIDIPipeEvent pev;
      int pevIdx;
      int numEv;

      if(KIT_NOTE_REDIRECT_OFF != kit_note_redirect_mode)
      {
         if(b_note_redirect_pressure)
         {
            // Channel pressure (from any device)
            numEv = _frame.getNumEventsChPressureByFlt(-1/*dev*/, -1/*ch*/);
            pevIdx = 0;
            loop(numEv)
            {
               if(_frame.getEventByIdxAndFlt(pevIdx,
                                             pev,
                                             MIDIPIPE_EVENT_TYPE_CHPRESSURE,
                                             -1/*dev*/,
                                             -1/*ch*/
                                             )
                  )
               {
                  if(pev.devIdx != in_dev)
                  {
                     _frameOut.chPressure(true/*bSet*/,
                                          out_dev,
                                          kit_editor_track_idx/*midiCh*/,
                                          pev.chPressure
                                          );
                  }
               }

               // Next Channel Pressure event
               pevIdx++;
            }


            // Poly pressure (from any device)
            numEv = _frame.getNumEventsPolyPressureByFlt(-1/*dev*/, -1/*ch*/);
            pevIdx = 0;
            loop(numEv)
            {
               if(_frame.getEventByIdxAndFlt(pevIdx,
                                             pev,
                                             MIDIPIPE_EVENT_TYPE_POLYPRESSURE,
                                             -1/*dev*/,
                                             -1/*ch*/
                                             )
                  )
               {
                  if(pev.devIdx != in_dev)
                  {
                     if((pev.polyPressureNote < 12) || (KIT_NOTE_REDIRECT_TRIG == kit_note_redirect_mode))
                     {
                        // Redirect any octave to AR trig note
                        _frameOut.polyPressure(true/*bSet*/,
                                               out_dev,
                                               (pev.polyPressureNote%12)/*midiCh*/,
                                               (pev.polyPressureNote%12)+(12*3),
                                               pev.polyPressureValue
                                               );
                     }
                     else
                     {
                        // Redirect chromatic note to AR track and center around C-5
                        // trace "xxx NOTE_ON: kit_editor_track_idx="+kit_editor_track_idx;
                        _frameOut.polyPressure(true/*bSet*/,
                                               out_dev,
                                               kit_editor_track_idx/*midiCh*/,
                                               mathClampi((pev.polyPressureNote - (12*5))+(12*3), 0, 127),
                                               pev.polyPressureValue
                                               );
                     }
                  }
               }

               // Next Poly Pressure event
               pevIdx++;
            }
         }

         // Note-On (from any device)
         numEv = _frame.getNumEventsNoteOnByFlt(-1/*dev*/, -1/*ch*/);
         pevIdx = 0;
         loop(numEv)
         {
            if(_frame.getEventByIdxAndFlt(pevIdx,
                                          pev,
                                          MIDIPIPE_EVENT_TYPE_NOTE_ON,
                                          -1/*dev*/,
                                          -1/*ch*/
                                          )
               )
            {
               if(pev.devIdx != in_dev)
               {
                  if((pev.note < 12) || (KIT_NOTE_REDIRECT_TRIG == kit_note_redirect_mode))
                  {
                     // Redirect any octave to AR trig note
                     _frameOut.noteOn(true/*bSet*/,
                                      out_dev,
                                      (pev.note%12)/*midiCh*/,
                                      (pev.note%12)+(12*3),
                                      pev.velocity,
                                      pev.duration
                                      );
                  }
                  else
                  {
                     // Redirect chromatic note to AR track and center around C-5
                     // trace "xxx NOTE_ON: kit_editor_track_idx="+kit_editor_track_idx;
                     _frameOut.noteOn(true/*bSet*/,
                                      out_dev,
                                      kit_editor_track_idx/*midiCh*/,
                                      mathClampi((pev.note - (12*5))+(12*3), 0, 127),
                                      pev.velocity,
                                      pev.duration
                                      );
                  }
               }
            }

            // Next Note-On
            pevIdx++;
         }


         // Note-Off (from any device)
         numEv = _frame.getNumEventsNoteOffByFlt(-1/*dev*/, -1/*ch*/);
         pevIdx = 0;
         loop(numEv)
         {
            if(_frame.getEventByIdxAndFlt(pevIdx,
                                          pev,
                                          MIDIPIPE_EVENT_TYPE_NOTE_OFF,
                                          -1/*dev*/,
                                          -1/*ch*/
                                          )
               )
            {
               if(pev.devIdx != in_dev)
               {
                  if((pev.note < 12) || (KIT_NOTE_REDIRECT_TRIG == kit_note_redirect_mode))
                  {
                     // Redirect any octave to AR trig note
                     _frameOut.noteOff(true/*bSet*/,
                                       out_dev,
                                       (pev.note%12)/*midiCh*/,
                                       (pev.note%12)+(12*3),
                                       pev.velocity
                                       );
                  }
                  else
                  {
                     // Redirect chromatic note to AR track and center around C-5
                     _frameOut.noteOff(true/*bSet*/,
                                       out_dev,
                                       kit_editor_track_idx/*midiCh*/,
                                       mathClampi((pev.note - (12*5))+(12*3), 0, 127),
                                       pev.velocity
                                       );
                  }
               }
            }

            // Next Note-Off
            pevIdx++;
         }

         _frame.deleteNoteOffsByFlt(-1, -1);
         _frame.deleteNoteOnsByFlt(-1, -1);

         _frame.deleteChPressureByFlt(-1, -1);
         _frame.deletePolyPressureByFlt(-1, -1);
      }
   }

   // <method_handle.png>
   protected method handleMapEvents(MIDIPipeFrame _frame, MIDIPipeFrame _frameOut) {

      // (todo) check if event is potentially handled and delete it from frame

      MIDIPipeEvent pev;
      int pevIdx;
      int numEv;

      // Note-On (from AR)
      numEv = _frame.getNumEventsNoteOnByFlt(in_dev, -1/*ch*/);
      pevIdx = 0;
      loop(numEv)
      {
         if(_frame.getEventByIdxAndFlt(pevIdx,
                                       pev,
                                       MIDIPIPE_EVENT_TYPE_NOTE_ON,
                                       in_dev,
                                       -1/*ch*/
                                       )
            )
         {
            if(pev.midiCh < 13)
            {
               if(b_kit_editor_trkswitch)
               {
                  if(nodeIsEditorVisible())
                     queued_kit_editor_track_idx = pev.midiCh;
               }

               if(b_kit_editor_visible)
               {
                  // do nothing
               }
               else
               {
                  if(NAR_MapEntry.IN_NONE == current_input_id1)
                  {
                     current_input_id1  = NAR_MapEntry.IN_TRIG;
                     current_input_arg1 = pev.midiCh;

                     if(findEntryAndExec(_frameOut, true/*bFirstTry*/))
                     {
                        current_input_id1  = NAR_MapEntry.IN_NONE;
                        current_input_arg1 = 0;

                        _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_NOTE_ON);
                        pevIdx--;
                     }
                  }
                  else
                  {
                     current_input_id2  = NAR_MapEntry.IN_TRIG;
                     current_input_arg2 = pev.midiCh;

                     if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                     {
                        _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_NOTE_ON);
                        pevIdx--;
                     }
                  }
               }
            }
         }

         // Next Note-On
         pevIdx++;
      }

      // Note-Off (from AR)
      numEv = _frame.getNumEventsNoteOffByFlt(in_dev, -1/*ch*/);
      pevIdx = 0;
      loop(numEv)
      {
         if(_frame.getEventByIdxAndFlt(pevIdx,
                                       pev,
                                       MIDIPIPE_EVENT_TYPE_NOTE_OFF,
                                       in_dev,
                                       -1/*ch*/
                                       )
            )
         {
            if(pev.midiCh < 13)
            {
               if(b_kit_editor_visible)
               {
               }
               else
               {
                  // // findEntryAndExec();

                  if(NAR_MapEntry.IN_TRIG == current_input_id1)
                  {
                     if(current_input_arg1 == pev.midiCh)
                     {
                        if(!b_current_input_id1_used)
                        {
                           if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                           {
                              _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_NOTE_OFF);
                              pevIdx--;
                           }
                        }

                        // Reset
                        current_input_id1        = NAR_MapEntry.IN_NONE;
                        b_current_input_id1_used = false;
                        current_input_arg1       = 0;
                     }
                  }

                  if(NAR_MapEntry.IN_TRIG == current_input_id2)
                  {
                     if(current_input_arg2 == pev.midiCh)
                     {
                        // Reset
                        current_input_id2  = NAR_MapEntry.IN_NONE;
                        current_input_arg2 = 0;
                     }
                  }
               }
            }
         }

         // Next Note-Off
         pevIdx++;
      }

      // CC
      numEv = _frame.getNumEventsCCByFlt(in_dev, -1/*ch*/);
      pevIdx = 0;
      // // trace "xxx numEv<CC>="+numEv;
      loop(numEv)
      {
         if(_frame.getEventByIdxAndFlt(pevIdx,
                                       pev,
                                       MIDIPIPE_EVENT_TYPE_CC,
                                       in_dev,
                                       -1/*ch*/
                                       )
            )
         {
            // trace "xxx pev.midiCh="+pev.midiCh+" pev.ccId="+pev.ccId+" pev.ccValue="+pev.ccValue;

            if(94 == pev.ccId) // Mute
            {
               if(pev.midiCh < 12)
               {
                  current_mute_state[pev.midiCh] = (pev.ccValue > 0);
               }

               if(!b_skip_mute)
               {
                  if(NAR_MapEntry.IN_NONE == current_input_id1)
                  {
                     current_input_id1  = NAR_MapEntry.IN_MUTE;
                     current_input_arg1 = pev.midiCh;

                     if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                     {
                        _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_CC);
                        pevIdx--;
                     }

                     // Reset
                     current_input_id2  = NAR_MapEntry.IN_NONE;
                     current_input_arg2 = 0;
                  }
                  else
                  {
                     current_input_id2  = NAR_MapEntry.IN_MUTE;
                     current_input_arg2 = pev.midiCh;

                     if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                     {
                        _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_CC);
                        pevIdx--;
                     }

                     // Reset
                     current_input_id2  = NAR_MapEntry.IN_NONE;
                     current_input_arg2 = 0;
                  }
               }
            }
            else if(35 <= pev.ccId <= 47) // PerfCtl
            {
               // trace "xxx PerfCtl val="+pev.ccValue;

               if(14 == pev.midiCh)
               {
                  int perfIdx = pev.ccId - 35;

                  if(pev.ccId >= 39)
                     perfIdx--;

                  current_perf_state[perfIdx] = pev.ccValue;
               }

               if(!b_skip_perf)
               {
                  if(input_last_cc1 == pev.ccId)
                  {
                     // trace "xxx cc1: pev.ccValue="+pev.ccValue;

                     if(0 == pev.ccValue) // Release
                     {
                        // trace "xxx release cc1  id1="+current_input_id1+" arg1="+current_input_arg1+" pev.arg1="+((pev.ccId >= 39) ? (pev.ccId - 36) : (pev.ccId - 35));

                        input_last_cc1 = -1;

                        if(NAR_MapEntry.IN_PERF == current_input_id1)
                        {
                           if(current_input_arg1 == ((pev.ccId >= 39) ? (pev.ccId - 36) : (pev.ccId - 35)))
                           {
                              if(!b_current_input_id1_used)
                              {
                                 if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                                 {
                                    _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_CC);
                                    pevIdx--;
                                 }
                              }

                              // Reset
                              current_input_id1        = NAR_MapEntry.IN_NONE;
                              b_current_input_id1_used = false;
                              current_input_arg1       = 0;

                              // // current_input_id2        = NAR_MapEntry.IN_NONE;
                              // // current_input_arg2       = 0;
                           }
                        }

                     }
                  }
                  else if((NAR_MapEntry.IN_NONE == current_input_id1) && (pev.ccId != input_last_cc2))
                  {
                     current_input_id1  = NAR_MapEntry.IN_PERF;
                     current_input_arg1 = (pev.ccId >= 39) ? (pev.ccId - 36) : (pev.ccId - 35);

                     if(findEntryAndExec(_frameOut, true/*bFirstTry*/))
                     {
                        current_input_id1  = NAR_MapEntry.IN_NONE;
                        current_input_arg1 = 0;

                        _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_CC);
                        pevIdx--;
                     }

                     // trace "xxx id1: pev.ccId="+pev.ccId;

                     input_last_cc1 = pev.ccId;
                  }
                  else
                  {
                     if(input_last_cc2 == pev.ccId)
                     {
                        if(0 == pev.ccValue) // Release
                        {
                           // trace "xxx release cc2";
                           input_last_cc2 = -1;

                           // // input_last_cc1 = -1;

                           // // if(NAR_MapEntry.IN_PERF == current_input_id2)
                           // // {
                           // //    if(current_input_arg2 == (pev.ccId - 35))
                           // //    {
                           // //       // Never reached ?!
                           // //       findEntryAndExec();

                           // //       // Reset
                           // //       current_input_id2  = NAR_MapEntry.IN_NONE;
                           // //       current_input_arg2 = 0;
                           // //    }
                           // // }
                        }
                     }
                     else
                     {
                        // trace "xxx id2: pev.ccId="+pev.ccId;

                        current_input_id2  = NAR_MapEntry.IN_PERF;
                        current_input_arg2 = (pev.ccId >= 39) ? (pev.ccId - 36) : (pev.ccId - 35);

                        input_last_cc2 = pev.ccId;

                        if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                        {
                           _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_CC);
                           pevIdx--;
                        }

                        // Reset
                        current_input_id2  = NAR_MapEntry.IN_NONE;
                        current_input_arg2 = 0;
                     }
                  }

               } // if !b_skip_perf
            }
            else if(92 == pev.ccId) // Scene
            {
               if(1 <= pev.ccValue <= 12)
               {
                  if(NAR_MapEntry.IN_NONE == current_input_id1)
                  {
                     current_input_id1  = NAR_MapEntry.IN_SCENE;
                     current_input_arg1 = pev.ccValue - 1;

                     if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                     {
                        _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_CC);
                        pevIdx--;
                     }

                     // Reset
                     current_input_id1  = NAR_MapEntry.IN_NONE;
                     current_input_arg1 = 0;
                  }
                  else
                  {
                     current_input_id2  = NAR_MapEntry.IN_SCENE;
                     current_input_arg2 = pev.ccValue - 1;

                     if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
                     {
                        _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_CC);
                        pevIdx--;
                     }

                     // Reset
                     current_input_id2  = NAR_MapEntry.IN_NONE;
                     current_input_arg2 = 0;
                  }
               }
            }
         }

         // Next CC
         pevIdx++;
      }

      // NRPN
      numEv = _frame.getNumEventsNRPNByFlt(in_dev, -1/*ch*/);
      pevIdx = 0;
      loop(numEv)
      {
         if(_frame.getEventByIdxAndFlt(pevIdx,
                                       pev,
                                       MIDIPIPE_EVENT_TYPE_NRPN,
                                       in_dev,
                                       -1/*ch*/
                                       )
            )
         {
            if(NAR_MapEntry.IN_NONE == current_input_id1)
            {
               current_input_id1  = NAR_MapEntry.IN_NRPN;
               current_input_arg1 = pev.nrpn;

               if(findEntryAndExec(_frameOut, false/*bFirstTry*/))
               {
                  _frame.deleteEventByIdx(pevIdx, MIDIPIPE_EVENT_TYPE_NRPN);
                  pevIdx--;
               }

               current_input_id1  = NAR_MapEntry.IN_NONE;
               current_input_arg1 = 0;
            }
         }

         // Next NRPN
         pevIdx++;
      }
   }

   // <method.png>
   protected method calcPerfTransition(float _t) {

      int perfIdx = 0;
      loop(12)
      {
         float sval = current_perf_state_transition_start.get(perfIdx);

         float eval = current_perf_state_transition_end.get(perfIdx);

         if(eval >= 0)
         {
            if(sval < 0)
            {
               sval = 0;
            }

            if(eval < 0)
            {
               eval = 0;
            }

            float ival = sval + (eval - sval) * _t;

            current_perf_state[perfIdx] = ival;
         }

         perfIdx++;
      }

      current_send_perf = current_perf_state;
   }

   // <method.png>
   protected method filterMuteNotes(MIDIPipeFrame _framePlay) {
      int evIdx = 0;
      int numNoteOn = _framePlay.getNumEventsNoteOn();

      while(numNoteOn > 0)
      {
         MIDIPipeEvent pev;

         if(_framePlay.getEventByIdx(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_ON))
         {
            if(pev.devIdx == out_dev)
            {
               boolean bDelete = false;

               if((14-1) == pev.midiCh) // auto
               {
                  bDelete = current_mute_state.get(pev.note);
               }
               else if(pev.midiCh < 12)
               {
                  bDelete = current_mute_state.get(pev.midiCh);
               }

               if(bDelete)
               {
                  // trace "xxx NAR::filterMuteNotes: delete evIdx="+evIdx;
                  _framePlay.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_NOTE_ON);
                  evIdx--;
               }
            }
         }

         numNoteOn--;
         evIdx++;
      }
   }

   // <method_get.png>
   public virtual nodeGetSupportedRPNs() : IntArray {
      return [RPN_COMMON_UI_PRGCHG,
              RPN_COMMON_MUTE_TEMP, // see Node::nodeParseRPN_Mute()
              RPN_COMMON_MUTE_TEMP_TOGGLE,
              RPN_COMMON_MUTE_TEMP_1_8,
              RPN_COMMON_MUTE_TEMP_9_16,
              RPN_COMMON_SOLO_TEMP_1_8,
              RPN_COMMON_SOLO_TEMP_9_16,
              RPN_COMMON_UI_NODE_MUTE,
              RPN_COMMON_UI_NODE_SOLO,
              RPN_COMMON_UI_PIPE_MUTE,
              RPN_COMMON_UI_PIPE_SOLO,

              RPN_ANALOGRYTM_SNAPSHOT,
              RPN_ANALOGRYTM_KIT_SEND,
              RPN_ANALOGRYTM_KIT_MIX,
              RPN_ANALOGRYTM_KIT_SEND_BD1,
              RPN_ANALOGRYTM_KIT_SEND_SD2,
              RPN_ANALOGRYTM_KIT_SEND_RS3,
              RPN_ANALOGRYTM_KIT_SEND_CP4,
              RPN_ANALOGRYTM_KIT_SEND_BT5,
              RPN_ANALOGRYTM_KIT_SEND_LT6,
              RPN_ANALOGRYTM_KIT_SEND_MT7,
              RPN_ANALOGRYTM_KIT_SEND_HT8,
              RPN_ANALOGRYTM_KIT_SEND_CH9,
              RPN_ANALOGRYTM_KIT_SEND_OH10,
              RPN_ANALOGRYTM_KIT_SEND_CY11,
              RPN_ANALOGRYTM_KIT_SEND_CB12,
              ];
   }

   // <replay.png>
   public virtual nodeProcessFrame(MIDIPipeFrame _framePlay,
                                   MIDIPipeFrame _frameRec,
                                   boolean       _bMuted,
                                   boolean       _bPlaySeq
                                   ) {

      // if(ST_IO_NONE != recv_state)
      //    trace "xxx recv_state="+recv_state;

      MIDIPipeFrame frameOut;
      frameOut.empty();

      nodeSendQueuedPrgChgOut(_framePlay);

      handleSyxReceive(_framePlay);
      handleSyxReceive(_frameRec);

      if((_framePlay.numEventsRPN > 0) || (_frameRec.numEventsRPN > 0))
      {
         short t;
         NodeAnalogRytmPattern *pat;
         NAR_Kit *kit;

         // Handle MUTE, MUTE_TOGGLE, MUTE_TEMP, MUTE_TEMP_TOGGLE
         nodeParseRPN_Mute(_framePlay, _frameRec);
         // // t = getRPN(_framePlay, _frameRec, RPN_COMMON_MUTE_TEMP);
         // // if(-1 != t)
         // // {
         // //    b_mute_temp = t;
         // //    _bMuted |= node_b_mute_temp;
         // // }

         _bMuted |= nodeHandleQueuedMuteTemp();

         t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_SNAPSHOT);
         if(-1 != t)
         {
            nodeSetCurrentPlayPatternNr(t & 127);
         }

         if(!_bMuted)
         {
            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSend(kit.ar_kit, 127);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_MIX);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitMix(kit.ar_kit);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_BD1);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     // // trace "xxx RPN_ANALOGRYTM_KIT_SEND_BD1";
                     queueKitSendSoundX(kit.ar_kit, 0/*bd1*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_SD2);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 1/*sd2*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_RS3);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 2/*rs3*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_CP4);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 3/*cp4*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_BT5);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 4/*bt5*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_LT6);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 5/*lt6*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_MT7);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 6/*mt7*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_HT8);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 7/*ht8*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_CH9);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 8/*ch9*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_OH10);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 9/*oh10*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_CY11);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 10/*cy11*/);
                  }
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_ANALOGRYTM_KIT_SEND_CB12);
            if(-1 != t)
            {
               pat <= nodeGetCurrentPlayPattern();

               if(null != pat)
               {
                  kit <= pat.getKitByUID(t);

                  if(null != kit)
                  {
                     queueKitSendSoundX(kit.ar_kit, 11/*cb12*/);
                  }
               }
            }

         }
      }
      else
      {
         _bMuted |= nodeHandleQueuedMuteTemp();
      }

      // boolean bClock = (0 == int(replay.midi_timing_ticks) % (current_song.ppq / 24));
      boolean bClock = false;

      switch(kit_recv_state)
      {
         default:
            break;

         case ST_IO_REQUEST_KITX:
            requestKitX(_framePlay, remote_recv_kit_nr);
            break;
      }

      switch(kit_send_state)
      {
         default:
            break;

         case ST_IO_NONE:
            break;

         case ST_IO_DUMP_KITX:
            if(b_current_send_kit_valid)
            {
               sendKitX(frameOut, remote_send_kit_nr);

               b_current_send_kit_valid = b_queued_send_kit_valid;

               if(b_queued_send_kit_valid)
               {
                  current_send_kit        = queued_send_kit;
                  remote_send_kit_nr      = queued_remote_send_kit_nr;
                  b_queued_send_kit_valid = false;
                  kit_send_state = ST_IO_DUMP_KITX;
               }
               else
               {
                  kit_send_state = ST_IO_NONE;
               }
            }
            break;

         case ST_IO_DUMP_KITX_SOUND:
            // trace "xxx ST_IO_DUMP_KITX_SOUND: b_current_send_kitsound_valid="+b_current_send_kitsound_valid;
            if(b_current_send_kitsound_valid)
            {
               sendKitXSound(frameOut, remote_send_kit_nr/*trackIdx*/);

               b_current_send_kitsound_valid = b_queued_send_kitsound_valid;

               if(b_queued_send_kitsound_valid)
               {
                  current_send_kit        = queued_send_kit;
                  remote_send_kit_nr      = queued_remote_send_kit_nr;
                  b_queued_send_kitsound_valid = false;
                  kit_send_state = ST_IO_DUMP_KITX_SOUND;
               }
               else
               {
                  kit_send_state = ST_IO_NONE;
               }
            }
            break;

      }

      switch(pattern_recv_state)
      {
         default:
            break;

         case ST_IO_REQUEST_PATX:
            requestPatternX(frameOut, remote_recv_pattern_nr);
            break;
      }

      switch(pattern_send_state)
      {
         default:
            if(!bClock)
            {
               if((ST_IO_DUMP_PATX_1+1) <= pattern_send_state <= ST_IO_DUMP_PATX_LAST)
               {
                  if(pattern_send_state == (ST_IO_DUMP_PATX_1 + (current_pattern_num_parts - 1)))
                  {
                     last_part_send_off = (pattern_send_state - ST_IO_DUMP_PATX_1) * current_pattern_syx_part_sz;
                     sendPatternX(frameOut, remote_send_pattern_nr, last_part_send_off/*syxOff*/, 999999/*syxSz*/);

                     Global.Debug2("NAR: pattern sent ("+current_pattern_num_parts+" part(s))");

                     b_current_send_pattern_valid = b_queued_send_pattern_valid;

                     if(b_queued_send_pattern_valid)
                     {
                        current_send_pattern        = queued_send_pattern;
                        remote_send_pattern_nr      = queued_remote_send_pattern_nr;
                        b_queued_send_pattern_valid = false;
                        pattern_send_state = ST_IO_DUMP_PATX_1;
                     }
                     else
                     {
                        pattern_send_state = ST_IO_NONE;
                     }

                     if(null != cached_out_dev)
                     {
                        cached_out_dev.endSysExLock();
                     }
                  }
                  else
                  {
                     last_part_send_off = (pattern_send_state - ST_IO_DUMP_PATX_1) * current_pattern_syx_part_sz;
                     sendPatternX(frameOut, remote_send_pattern_nr, last_part_send_off/*syxOff*/, current_pattern_syx_part_sz/*syxSz*/);
                     pattern_send_state++;
                  }
               }
            }
            break;

         case ST_IO_NONE:
            break;

         case ST_IO_DUMP_PATX_1:

            current_pattern_num_parts = ui_pattern_num_parts;

            if(current_pattern_num_parts < 1)
               current_pattern_num_parts = 1;
            else if(current_pattern_num_parts > 30)
               current_pattern_num_parts = 30;

            // (note) last part will contain all remaining data
            current_pattern_syx_part_sz = 0x3B03/*v4*/ / current_pattern_num_parts;

            Global.Debug2("NodeAnalogRytm: starting pattern transfer ("+current_pattern_num_parts+" parts, psz="+current_pattern_syx_part_sz+")");

            if(!bClock || (1 == current_pattern_num_parts))
            {
               if(null != cached_out_dev)
               {
                  if(b_current_send_pattern_valid)
                  {
                     if(current_pattern_num_parts > 1)
                     {
                        cached_out_dev.beginSysExLock();
                     }

                     sendPatternX(frameOut, remote_send_pattern_nr, 0*current_pattern_syx_part_sz/*syxOff*/, current_pattern_syx_part_sz/*syxSz*/);

                     if(current_pattern_num_parts > 1)
                     {
                        pattern_send_state++;
                        last_part_send_off = 0;
                     }
                     else
                     {
                        b_current_send_pattern_valid = b_queued_send_pattern_valid;

                        if(b_queued_send_pattern_valid)
                        {
                           current_send_pattern        = queued_send_pattern;
                           remote_send_pattern_nr      = queued_remote_send_pattern_nr;
                           b_queued_send_pattern_valid = false;
                           pattern_send_state = ST_IO_DUMP_PATX_1;
                        }
                        else
                        {
                           pattern_send_state = ST_IO_NONE;
                        }
                     }
                  }
                  else
                  {
                     trace "[---] NodeAnalogRytm::nodeProcessFrame: ST_IO_DUMP_PATX_1: nothing to send.";
                     pattern_send_state = ST_IO_NONE;
                  }
               }
               else
               {
                  pattern_send_state = ST_IO_NONE;
                  b_current_send_pattern_valid = false;
               }
            }
            break;
      }


      switch(sound_recv_state)
      {
         default:
            break;

         case ST_IO_REQUEST_SOUNDX:
            requestSoundX(_framePlay, remote_recv_sound_nr);
            break;
      }


      switch(global_recv_state)
      {
         default:
            break;

         case ST_IO_REQUEST_GLOBALX:
            requestGlobalX(_framePlay, remote_recv_global_nr);
            break;
      }

      switch(global_send_state)
      {
         default:
            break;

         case ST_IO_NONE:
            break;

         case ST_IO_DUMP_GLOBALX:
            if(b_current_send_global_valid)
            {
               sendGlobalX(frameOut, remote_send_global_nr);

               b_current_send_global_valid = b_queued_send_global_valid;

               if(b_queued_send_global_valid)
               {
                  current_send_global        = queued_send_global;
                  remote_send_global_nr      = queued_remote_send_global_nr;
                  b_queued_send_global_valid = false;
                  global_send_state = ST_IO_DUMP_GLOBALX;
               }
               else
               {
                  global_send_state = ST_IO_NONE;
               }
            }
            break;
      }


      switch(settings_recv_state)
      {
         default:
            break;

         case ST_IO_REQUEST_SETTINGSX:
            requestSettingsX(_framePlay);
            break;
      }

      switch(settings_send_state)
      {
         default:
            break;

         case ST_IO_NONE:
            break;

         case ST_IO_DUMP_SETTINGSX:
            if(b_current_send_settings_valid)
            {
               sendSettingsX(frameOut);

               b_current_send_settings_valid = b_queued_send_settings_valid;

               if(b_queued_send_settings_valid)
               {
                  current_send_settings        = queued_send_settings;
                  b_queued_send_settings_valid = false;
                  settings_send_state = ST_IO_DUMP_SETTINGSX;
               }
               else
               {
                  settings_send_state = ST_IO_NONE;
               }
            }
            break;
      }


      switch(mute_send_state)
      {
         default:
            break;

         case ST_IO_DUMP_MUTE:
            if(b_current_send_mute_valid)
            {
               sendMute(frameOut);

               b_current_send_mute_valid = b_queued_send_mute_valid;

               if(b_queued_send_mute_valid)
               {
                  current_send_mute        = queued_send_mute;
                  b_queued_send_mute_valid = false;
                  mute_send_state = ST_IO_DUMP_MUTE;
               }
               else
               {
                  mute_send_state = ST_IO_NONE;
               }
            }
            break;
      }


      switch(perf_send_state)
      {
         default:
            break;

         case ST_IO_DUMP_PERF:
            if(b_current_send_perf_valid)
            {
               sendPerf(frameOut);

               b_current_send_perf_valid = b_queued_send_perf_valid;

               if(b_queued_send_perf_valid)
               {
                  current_send_perf        = queued_send_perf;
                  b_queued_send_perf_valid = false;
                  perf_send_state = ST_IO_DUMP_PERF;
               }
               else
               {
                  perf_send_state = ST_IO_NONE;
               }
            }
            break;

         case ST_IO_TRANSITION_PERF:
            perf_send_time_cur_ticks += 1.0f;

            float transT;

            if(perf_send_time_cur_ticks >= perf_send_time_dur_ticks)
            {
               // End of transition
               current_perf_state = current_perf_state_transition_end;
               b_current_send_perf_valid = true;
               sendPerf(frameOut);
               b_current_send_perf_valid = false;

               current_perf_state = current_perf_state_transition_end;

               b_current_send_perf_valid = false;
               perf_send_state = ST_IO_NONE;
            }
            else
            {
               transT = perf_send_time_cur_ticks / perf_send_time_dur_ticks;
               calcPerfTransition(transT);

               b_current_send_perf_valid = true;
               sendPerf(frameOut);
               b_current_send_perf_valid = false;
            }
            break;
      }


      if(!_bMuted)
      {
         if(NodeAnalogRytmEditor.LEARN_NONE == learn_mode)
         {
            if(-1 != in_dev)
            {
               handleMapEvents(_framePlay, frameOut);
               handleMapEvents(_frameRec,  frameOut);

               // Redirect kit notes
               if((-1 != out_dev) && nodeIsEditorVisible())
                  handleKitRedirectNotes(_frameRec, frameOut);
            }
         }

         if(b_mute_note && b_out_en)
         {
            filterMuteNotes(_framePlay);
         }
      }

      if(frameOut.hasEvents())
      {
         // trace "xxx frameOut has "+frameOut.numEvents+" events";
         _framePlay.mergeFrame(frameOut);

         // if(frameOut.numEventsSysEx > 0)
         // {
         //    trace "xxx frameOut has "+frameOut.numEventsSysEx+" sysex events";
         //    trace "xxx framePlay has "+_framePlay.numEventsSysEx+" sysex events";
         // }
      }

   }

   // // public =replay= method runTest_PatQuery() {
   // //    send_state = ST_IO_REQUEST_PATX;
   // // }

   // // public =replay= method runTest_PatSend() {
   // //    send_state = ST_IO_DUMP_PATX_1;
   // // }

   // // public =replay= method runTest_KitQuery() {
   // //    queueKitQuery(getCurrentARKit(), 127/*remoteKitNr*/);
   // // }

   // // public =replay= method runTest_KitSend() {
   // //    queueKitSend(getCurrentARKit(), 127/*remoteKitNr*/);
   // // }

   // <method.png>
   public =replay= method queueKitQuery(AR_Kit _kit, byte _remoteKitNr) {
      Global.Debug("NAR::queueKitQuery: kit="+#(_kit)+" remoteKitNr="+_remoteKitNr+" current_recv_kit="+#(current_recv_kit));

      if(null == current_recv_kit)
      {
         current_recv_kit      <= _kit;
         remote_recv_kit_nr     = _remoteKitNr & 127;
         kit_recv_state         = ST_IO_REQUEST_KITX;
         kit_recv_partial_flags = KIT_PARTIAL_ALL;
      }
      else
      {
         queued_recv_kit              <= _kit;
         queued_remote_recv_kit_nr     = _remoteKitNr;
         queued_kit_recv_partial_flags = KIT_PARTIAL_ALL;
      }
   }

   // <method.png>
   public =replay= method queueKitQueryPartial(AR_Kit _kit, int _partialFlags) {
      Global.Debug("NAR::queueKitQueryPartial: kit="+#(_kit)+" partialFlags="+_partialFlags+" current_recv_kit="+#(current_recv_kit));

      if(null == current_recv_kit)
      {
         current_recv_kit       <= _kit;
         remote_recv_kit_nr      = 127;
         kit_recv_state          = ST_IO_REQUEST_KITX;
         kit_recv_partial_flags |= _partialFlags;
      }
      else
      {
         queued_recv_kit               <= _kit;
         queued_remote_recv_kit_nr      = 127;
         queued_kit_recv_partial_flags |= _partialFlags;

      }
   }

   // <method.png>
   public =replay= method queueKitSend(AR_Kit _kit, byte _remoteKitNr) {
      if(!b_current_send_kit_valid)
      {
         current_send_kit         = _kit;
         b_current_send_kit_valid = true;
         remote_send_kit_nr       = _remoteKitNr & 127;
         kit_send_state           = ST_IO_DUMP_KITX;
      }
      else
      {
         queued_send_kit           = _kit;
         b_queued_send_kit_valid   = true;
         queued_remote_send_kit_nr = _remoteKitNr & 127;
      }

      b_current_send_kitsound_valid = false;
      b_queued_send_kitsound_valid = false;

   }

   // <method.png>
   public =replay= method queueKitSendSoundX(AR_Kit _kit, byte _trackIdx) {
      if(!b_current_send_kitsound_valid)
      {
         current_send_kit         = _kit;
         b_current_send_kitsound_valid = true;
         remote_send_kit_nr       = _trackIdx;
         kit_send_state           = ST_IO_DUMP_KITX_SOUND;
      }
      else
      {
         queued_send_kit               = _kit;
         b_queued_send_kitsound_valid  = true;
         queued_remote_send_kit_nr = _trackIdx;
      }

      b_current_send_kit_valid = false;
      b_queued_send_kit_valid = false;
   }

   // <method_get.png>
   public method getLockString() : String {
      String r; r.empty();
      r.append(b_lock_perf   ? "P" : "-");
      r.append(b_lock_scene  ? "S" : "-");
      r.append(b_lock_fx     ? "F" : "-");
      r.append(b_lock_trk_1  ? "1" : "-");
      r.append(b_lock_trk_2  ? "2" : "-");
      r.append(b_lock_trk_3  ? "3" : "-");
      r.append(b_lock_trk_4  ? "4" : "-");
      r.append(b_lock_trk_5  ? "5" : "-");
      r.append(b_lock_trk_6  ? "6" : "-");
      r.append(b_lock_trk_7  ? "7" : "-");
      r.append(b_lock_trk_8  ? "8" : "-");
      r.append(b_lock_trk_9  ? "9" : "-");
      r.append(b_lock_trk_10 ? "A" : "-");
      r.append(b_lock_trk_11 ? "B" : "-");
      r.append(b_lock_trk_12 ? "c" : "-");
      return r;
   }

   // <method.png>
   public =replay= method queueKitMix(AR_Kit _kit) {
      // trace "xxx queueKitMix: b_lock_trk_1="+b_lock_trk_1+" b_lock_trk_2="+b_lock_trk_2;

      if(2/*RAW*/ != current_kit_state.getCurrentDataIdx())
      {
         queueKitSend(_kit, 127);
         return;
      }

      if(!b_lock_perf)
         current_kit_state.copyPerfCtlFrom(_kit);

      if(!b_lock_scene)
         current_kit_state.copySceneCtlFrom(_kit);

      if(!b_lock_fx)
         current_kit_state.copyFXFrom(_kit);

      if(!b_lock_trk_1)
         current_kit_state.copyTrackSoundFrom(0, _kit, 0);

      if(!b_lock_trk_2)
         current_kit_state.copyTrackSoundFrom(1, _kit, 1);

      if(!b_lock_trk_3)
         current_kit_state.copyTrackSoundFrom(2, _kit, 2);

      if(!b_lock_trk_4)
         current_kit_state.copyTrackSoundFrom(3, _kit, 3);

      if(!b_lock_trk_5)
         current_kit_state.copyTrackSoundFrom(4, _kit, 4);

      if(!b_lock_trk_6)
         current_kit_state.copyTrackSoundFrom(5, _kit, 5);

      if(!b_lock_trk_7)
         current_kit_state.copyTrackSoundFrom(6, _kit, 6);

      if(!b_lock_trk_8)
         current_kit_state.copyTrackSoundFrom(7, _kit, 7);

      if(!b_lock_trk_9)
         current_kit_state.copyTrackSoundFrom(8, _kit, 8);

      if(!b_lock_trk_10)
         current_kit_state.copyTrackSoundFrom(9, _kit, 9);

      if(!b_lock_trk_11)
         current_kit_state.copyTrackSoundFrom(10, _kit, 10);

      if(!b_lock_trk_12)
         current_kit_state.copyTrackSoundFrom(11, _kit, 11);

      if(!b_current_send_kit_valid)
      {
         current_send_kit         = current_kit_state;
         b_current_send_kit_valid = true;
         remote_send_kit_nr       = 127;
         kit_send_state           = ST_IO_DUMP_KITX;
      }
      else
      {
         queued_send_kit           = current_kit_state;
         b_queued_send_kit_valid   = true;
         queued_remote_send_kit_nr = 127;
      }

   }

   // <method.png>
   public =replay= method queuePatternQuery(AR_Pattern _pattern, byte _remotePatternNr) {
      if(null == current_recv_pattern)
      {
         current_recv_pattern   <= _pattern;
         remote_recv_pattern_nr  = _remotePatternNr & 127;
         pattern_recv_state      = ST_IO_REQUEST_PATX;
      }
      else
      {
         queued_recv_pattern           <= _pattern;
         queued_remote_recv_pattern_nr  = _remotePatternNr;
      }
   }

   // <method.png>
   public =replay= method queuePatternSend(AR_Pattern _pattern, byte _remotePatternNr) {
      if(!b_current_send_pattern_valid)
      {
         current_send_pattern         = _pattern;
         b_current_send_pattern_valid = true;
         remote_send_pattern_nr       = _remotePatternNr & 127;
         pattern_send_state           = ST_IO_DUMP_PATX_1;
      }
      else
      {
         queued_send_pattern           = _pattern;
         b_queued_send_pattern_valid   = true;
         queued_remote_send_pattern_nr = _remotePatternNr & 127;
      }

   }

   // <method.png>
   public =replay= method queueSoundQuery(AR_Sound _sound, byte _remoteSoundNr) {
      trace "xxx NAR::queueSoundQuery: sound="+#(_sound)+" remoteSoundNr="+_remoteSoundNr+" current_recv_sound="+#(current_recv_sound);

      if(null == current_recv_sound)
      {
         current_recv_sound    <= _sound;
         remote_recv_sound_nr   = _remoteSoundNr & 127;
         sound_recv_state       = ST_IO_REQUEST_SOUNDX;
      }
      else
      {
         queued_recv_sound            <= _sound;
         queued_remote_recv_sound_nr   = _remoteSoundNr;
      }
   }

   // <method.png>
   public =replay= method queueGlobalQuery(AR_Global _global, byte _globalSlot) {
      trace "xxx NAR::queueGlobalQuery: global="+#(_global)+" globalSlot="+_globalSlot+" current_recv_global="+#(current_recv_global);

      if(null == current_recv_global)
      {
         current_recv_global    <= _global;
         remote_recv_global_nr   = _globalSlot & 127;
         global_recv_state       = ST_IO_REQUEST_GLOBALX;
      }
      else
      {
         queued_recv_global            <= _global;
         queued_remote_recv_global_nr   = _globalSlot;
      }
   }

   // <method.png>
   public =replay= method queueSettingsQuery(AR_Settings _settings) {
      trace "xxx NAR::queueGlobalQuery: settings="+#(_settings)+" current_recv_settings="+#(current_recv_settings);

      if(null == current_recv_settings)
      {
         current_recv_settings <= _settings;
         settings_recv_state    = ST_IO_REQUEST_SETTINGSX;
      }
      else
      {
         queued_recv_settings  <= _settings;
      }
   }

   // <method.png>
   public =replay= method queueMuteStore(IntArray _muteState) {
      NodeAnalogRytmPattern pat <= nodeGetCurrentEditPattern();
      if(null != pat)
      {
         NAR_Mute narMute <= pat.getCurrentNARMute();
         if(null != narMute)
            narMute.mute_state = current_mute_state;
      }
   }

   // <method.png>
   public =replay= method queueMuteSend(IntArray _muteState) {
      if(!b_current_send_mute_valid)
      {
         current_send_mute         = _muteState;
         b_current_send_mute_valid = true;
         mute_send_state           = ST_IO_DUMP_MUTE;
      }
      else
      {
         queued_send_mute          = _muteState;
         b_queued_send_mute_valid   = true;
      }

   }

   // <method.png>
   public =replay= method queuePerfStore(IntArray _perfState) {
      NodeAnalogRytmPattern pat <= nodeGetCurrentEditPattern();
      if(null != pat)
      {
         NAR_Perf narPerf <= pat.getCurrentNARPerf();
         if(null != narPerf)
            narPerf.perf_state = current_perf_state;
      }
   }

   // <method.png>
   public =replay= method queuePerfSend(IntArray _perfState) {
      if(!b_current_send_perf_valid)
      {
         current_send_perf         = _perfState;
         b_current_send_perf_valid = true;
         perf_send_state           = ST_IO_DUMP_PERF;
      }
      else
      {
         queued_send_perf          = _perfState;
         b_queued_send_perf_valid  = true;
      }

   }

   // <method.png>
   public =replay= method queuePerfTransition(IntArray _perfState, float _time16th) {

      current_perf_state_transition_start = current_perf_state;
      current_perf_state_transition_end   = _perfState;

      perf_send_time_cur_ticks = 0;
      perf_send_time_dur_ticks = (current_song.ppq * 0.25) * _time16th;

      // trace "xxx perf_send_time_dur_ticks="+perf_send_time_dur_ticks;

      if(perf_send_time_dur_ticks >= 1)
      {
         perf_send_state = ST_IO_TRANSITION_PERF;
      }
      else
      {
         current_send_perf         = _perfState;
         b_current_send_perf_valid = true;
         perf_send_state = ST_IO_DUMP_PERF;
      }

   }

   // <method.png>
   public =replay= method resetKitRecvState() {
      kit_recv_state          = ST_IO_NONE;
      kit_send_state          = ST_IO_NONE;
      current_recv_kit       <= null;
      kit_recv_partial_flags  = KIT_PARTIAL_ALL;
   }

   // <method.png>
   public =replay= method resetPatternRecvState() {
      current_recv_pattern <= null;
      pattern_recv_state    = ST_IO_NONE;
      pattern_send_state    = ST_IO_NONE;
   }

   // <method.png>
   public =replay= method resetGlobalRecvState() {
      global_recv_state    = ST_IO_NONE;
      global_send_state    = ST_IO_NONE;
      current_recv_global <= null;
   }

   // <method.png>
   public =replay= method resetSettingsRecvState() {
      settings_recv_state    = ST_IO_NONE;
      settings_send_state    = ST_IO_NONE;
      current_recv_settings <= null;
   }

   // <method.png>
   public virtual nodeHandleEditSound(int _trackIdxHint, int _noteIdxHint) {
      // edit kit via 'k' keyboard shortcut in NodeTrigSeq/NodeTracker/NodeSeq
      //  (note) called from UI thread when NodeAnalogRytmEditor is already visible
      if(-1 != _trackIdxHint)
         editor.selectTrackByIdx(_trackIdxHint);
      editor.handleKitEdit();
   }


}
