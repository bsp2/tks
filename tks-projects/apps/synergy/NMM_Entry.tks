// ----
// ---- file   : NMM_Entry.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2015-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 30Oct2015, 31Oct2015, 01Nov2015, 02Nov2015, 03Nov2015, 04Nov2015, 06Nov2015
// ----          07Nov2015, 08Nov2015, 09Nov2015, 21Dec2015, 26Jan2016, 31Jan2016, 09Apr2016
// ----          02Jul2016, 08Jul2016, 09Jul2016, 31Jan2017, 11Feb2017, 06Mar2017, 09Mar2017
// ----          10Mar2017, 11Mar2017, 12Mar2017, 14Mar2017, 12Aug2017, 25Aug2017, 03Sep2017
// ----          22Sep2017, 04Jan2018, 07Mar2018, 28Apr2018, 21May2018, 27May2018, 17Jun2018
// ----          22Feb2019, 19May2019, 08Jun2019, 09Jun2019, 25Jun2019, 29Aug2019, 19Oct2019
// ----          07Nov2019, 30Oct2020, 10Nov2020, 26Jan2021, 27Jan2021, 29Jan2021, 30May2021
// ----          01Jun2021, 20Jun2021, 21Jun2021, 01Jan2022, 18Mar2022, 21Nov2022, 07Apr2023
// ----          23Jun2023, 15Oct2023, 20Oct2023, 07Oct2024, 28Feb2025
// ----
// ----
// ----

module MNMM_Entry;

use namespace ui;
use namespace st2;


// <class.png>
class NMM_Entry {

   NMM_Pattern *parent_pat;
   NodeModMatrix *parent_node;

   boolean b_op; // true=enable op

   String name;

   NMM_Arg *arg_dst;
   NMM_Arg *arg_1;
   NMM_Arg *arg_2;
   NMM_Arg *arg_3;
   NMM_Arg *arg_4;

   define int OP_COPY            =  0;   // Dst = Src
   define int OP_TEST            =  1;   // Dst = (0 != Src) ? 1 : 0
   define int OP_NOT             =  2;   // Dst = (0 == Src) ? 1 : 0
   define int OP_ADD             =  3;   // Dst = Src1 + Src2
   define int OP_SUB             =  4;   // Dst = Src1 - Src2 (v15+)
   define int OP_MIX             =  5;   // Dst = Src1*Src2 + Src3*Src4
   define int OP_MUL             =  6;   // Dst = Src1 * Src2 * Src3
   define int OP_MUL_DIV         =  7;   // Dst = (Src1 * Src2) / Src3
   define int OP_BLEND           =  8;   // Dst = Src1 + ( (Src2 - Src3) * Src4 )
   define int OP_SCALE_FROM      =  9;   // Dst = Src1 [Src2..Src3] => [0..1]
   define int OP_SCALE_TO        = 10;   // Dst = Src1 [0..1] => [Src2..Src3]
   define int OP_AND             = 11;   // Dst = Src1 & Src2
   define int OP_OR              = 12;   // Dst = Src1 | Src2
   define int OP_EOR             = 13;   // Dst = Src1 ^ Src2
   define int OP_MOD             = 14;   // Dst = Src1 % Src2
   define int OP_MOD_DIV         = 15;   // Dst = (Src1 % Src2) / Src2  (v18+)
   define int OP_STEP            = 16;   // Divide Src1 into Src2 steps and quantize value
   define int OP_SIN             = 17;   // Dst = sin(Src1 + Src2) * Src3 + Src4
   define int OP_TRI             = 18;   // Dst = tri(Src1 + Src2) * Src3 + Src4
   define int OP_CLAMP           = 19;   // Dst = clamp(Src, [Src2..Src3])  (..min(max(Src1,Src2), Src3)..)
   define int OP_WRAP            = 20;   // Dst = wrap(Src, [Src2..Src3])
   define int OP_SELECT_EQ       = 21;   // Dst = (Src1 == Src2) ? Src3 : Src4
   define int OP_SELECT_NE       = 22;   // Dst = (Src1 != Src2) ? Src3 : Src4
   define int OP_SELECT_LT       = 23;   // Dst = (Src1 <  Src2) ? Src3 : Src4
   define int OP_SELECT_LE       = 24;   // Dst = (Src1 <= Src2) ? Src3 : Src4
   define int OP_SELECT_GT       = 25;   // Dst = (Src1 >  Src2) ? Src3 : Src4
   define int OP_SELECT_GE       = 26;   // Dst = (Src1 >= Src2) ? Src3 : Src4
   define int OP_SELECT_AND      = 27;   // Dst = (Src1 && Src2) ? Src3 : Src4
   define int OP_SELECT_OR       = 28;   // Dst = (Src1 || Src2) ? Src3 : Src4
   define int OP_SELECT_EOR      = 29;   // Dst = (Src1 ^^ Src2) ? Src3 : Src4
   define int OP_POW             = 30;   // Dst = pow(Src1, Src2) (v7+)
   define int OP_SQRT            = 31;   // Dst = sqrt(Src1) (v7+)
   define int OP_LOG             = 32;   // Dst = log(Src1) / log(Src2) (v7+)
   define int OP_RANGE_OUT       = 33;   // Dst = (Src1 <= Src2 <= Src3) ? Src2 : Src4  (v8+)
   define int OP_RANGE_IN        = 34;   // Dst = (Src1 <= Src2 <= Src3) ? Src4 : Src2  (v14+)
   define int OP_IDIV_MUL        = 35;   // Dst = int(Src1 / Src3) * Src3  (v9+)
   define int OP_SCALE_IDX_OCT   = 36;   // Dst = scale(idx=Src1 [] Key=Src2 [] mode=Src3 []) (v10+)
   define int OP_WHITE_TO_IDX    = 37;   // Dst = (note:Src1 [] base:Src2 []) (v11+) (V11+)
   define int OP_SCALE_IDX_REP   = 38;   // Dst = scale(idx=Src1 [] Key=Src2 [] mode=Src3 []) (v12+)
   define int OP_SCALE_NOTE_UP   = 39;   // Dst = scale_up(idx=Src1 [] Key=Src2 [] mode=Src3 []) (v13+)
   define int OP_SCALE_NOTE_DOWN = 40;   // Dst = scale_dn(idx=Src1 [] Key=Src2 [] mode=Src3 []) (v13+)
   define int OP_SCALE_NOTE_DROP = 41;   // Dst = scale_dr(idx=Src1 [] Key=Src2 [] mode=Src3 []) (v13+)
   define int OP_PAN_LINEAR_L    = 42;   // Dst = pan between src1 and src2 according to src3 (left out) (v16+)
   define int OP_PAN_LINEAR_R    = 43;   // Dst = pan between src1 and src2 according to src3 (right out) (v16+)
   define int OP_PAN_LERP_L      = 44;   // Dst = pan between src1 and src2 according to src3 (left out) (v16+)
   define int OP_PAN_LERP_R      = 45;   // Dst = pan between src1 and src2 according to src3 (right out) (v16+)
   define int OP_PAN_SQRT_L      = 46;   // Dst = pan between src1 and src2 according to src3 (left out) (v16+)
   define int OP_PAN_SQRT_R      = 47;   // Dst = pan between src1 and src2 according to src3 (right out) (v16+)
   define int OP_PAN_COS_L       = 48;   // Dst = pan between src1 and src2 according to src3 (left out) (v16+)
   define int OP_PAN_COS_R       = 49;   // Dst = pan between src1 and src2 according to src3 (right out) (v16+)
   define int OP_PAN_POW_L       = 50;   // Dst = pan between src1 and src2 according to src3 (left out) (v16+)
   define int OP_PAN_POW_R       = 51;   // Dst = pan between src1 and src2 according to src3 (right out) (v16+)
   define int OP_NEG_HARMONY     = 52;   // Dst = negative_harmony(Note:Src1 Key:Src2 (v17+)
   define int OP_CURVE           = 53;   // Dst = curve<Src1>[Src2][Src3], Src1:clamp/wrap mode (v19+)
   define int OP_SLEW            = 54;   // Dst = Arg1 rateUp=Arg2 (0..1) rateDn=Arg3 (0..1) (v20+)

   define int NUM_OPS            = 55;

   int op;

   static StringArray op_names = [
      "Copy",        //  0
      "Test",        //  1
      "Not",         //  2
      "Add",         //  3
      "Sub",         //  4
      "Mix",         //  5
      "Mul",         //  6
      "Mul/Div",     //  7
      "Blend",       //  8
      "Scale From",  //  9
      "Scale To",    // 10
      "And",         // 11
      "Or",          // 12
      "Eor",         // 13
      "Mod",         // 14
      "Mod/Div",     // 15  v18+
      "Step",        // 16
      "Sin",         // 17
      "Tri",         // 18
      "Clamp",       // 19
      "Wrap",        // 20
      "Select ==",   // 21
      "Select !=",   // 22
      "Select <",    // 23
      "Select <=",   // 24
      "Select >",    // 25
      "Select >=",   // 26
      "Select &&",   // 27
      "Select ||",   // 28
      "Select ^^",   // 29
      "Pow",         // 30
      "Sqrt",        // 31
      "Log",         // 32
      "Range Out",   // 33
      "Range In",    // 34
      "IDiv/Mul",    // 35
      "SclIdxOct",   // 36
      "WhiteIdx",    // 37
      "SclIdxRep",   // 38
      "SclNtUp",     // 39
      "SclNtDown",   // 40
      "SclNtDrop",   // 41
      "PanLin_L",    // 42
      "PanLin_R",    // 43
      "PanLerp_L",   // 44
      "PanLerp_R",   // 45
      "PanSqrt_L",   // 46
      "PanSqrt_R",   // 47
      "PanCos_L",    // 48
      "PanCos_R",    // 49
      "PanPow_L",    // 50
      "PanPow_R",    // 51
      "NegHarmony",  // 52
      "Curve",       // 53  v19+
      "Slew",        // 54  v20+
                                  ];

   static StringArray script_op_names = [
      "=",           //  0   r1 = r2
      "test",        //  1
      "!",           //  2
      "+",           //  3
      "-",           //  4
      "mix",         //  5
      "*",           //  6
      "*/",          //  7
      "blend",       //  8
      "from",        //  9
      "to",          // 10
      "&",           // 11
      "|",           // 12
      "^",           // 13
      "%",           // 14
      "%/",          // 15  v18+
      "step",        // 16
      "sin",         // 17
      "tri",         // 18
      "clamp",       // 19
      "wrap",        // 20
      "==",          // 21
      "!=",          // 22
      "<",           // 23
      "<=",          // 24
      ">",           // 25
      ">=",          // 26
      "&&",          // 27
      "||",          // 28
      "^^",          // 29
      "pow",         // 30
      "sqrt",        // 31
      "log",         // 32
      "rangeout",    // 33
      "rangein",     // 34
      "i/*",         // 35
      "sclidxoct",   // 36
      "whiteidx",    // 37
      "sclidxrep",   // 38
      "sclntup",     // 39
      "sclntdown",   // 40
      "sclntdrop",   // 41
      "panlin_l",    // 42
      "panlin_r",    // 43
      "panlerp_l",   // 44
      "panlerp_r",   // 45
      "pansqrt_l",   // 46
      "pansqrt_r",   // 47
      "pancos_l",    // 48
      "pancos_r",    // 49
      "panpow_l",    // 50
      "panpow_r",    // 51
      "negharmony",  // 52
      "curve",       // 53  v19+
      "slew",        // 54  v20+
                                  ];

   static StringArray op_tooltips = [
      " 0: Dst = Arg1",                               //  0: OP_COPY
      " 1: Dst = (0 != Arg1) ? 1 : 0",                //  1: OP_TEST
      " 2: Dst = (0 == Arg1) ? 1 : 0",                //  2: OP_NOT
      " 3: Dst = Arg1 + Arg2",                        //  3: OP_ADD
      " 4: Dst = Arg1 - Arg2",                        //  4: OP_SUB
      " 5: Dst = Arg1*Arg2 + Arg3*Arg4",              //  5: OP_MIX
      " 6: Dst = Arg1 * Arg2 * Arg3",                 //  6: OP_MUL
      " 7: Dst = (Arg1 * Arg2) / Arg3",               //  7: OP_MUL_DIV
      " 8: Dst = Arg1 + ( (Arg2 - Arg3) * Arg4 )",    //  8: OP_BLEND
      " 9: Dst = Arg1 [Arg2..Arg3] => [0..1]",        //  9: OP_SCALE_FROM
      "10: Dst = Arg1 [0..1] => [Arg2..Arg3]",        // 10: OP_SCALE_TO
      "11: Dst = Arg1 & Arg2",                        // 11: OP_AND
      "12: Dst = Arg1 | Arg2",                        // 12: OP_OR
      "13: Dst = Arg1 ^ Arg2",                        // 13: OP_EOR
      "14: Dst = Arg1 % Arg2",                        // 14: OP_MOD
      "15: Dst = (Arg1 % Arg2) / Arg2",               // 15: OP_MOD_DIV  v18+
      "16: Divide Arg1 into Arg2 steps and quantize value", // 16: OP_STEP
      "17: Dst = sin(Arg1 + Arg2) * Arg3 + Arg4",     // 17: OP_SIN
      "18: Dst = tri(Arg1 + Arg2) * Arg3 + Arg4",     // 18: OP_TRI
      "19: Dst = clamp(Arg1, [Arg2..Arg3])  (..min(max(Arg1,Arg2), Arg3)..)",  // 19: OP_CLAMP
      "20: Dst = wrap(Arg1, [Arg2..Arg3])",           // 20: OP_WRAP
      "21: Dst = (Arg1 == Arg2) ? Arg3 : Arg4",       // 21: OP_SELECT_EQ
      "22: Dst = (Arg1 != Arg2) ? Arg3 : Arg4",       // 22: OP_SELECT_NE
      "23: Dst = (Arg1 <  Arg2) ? Arg3 : Arg4",       // 23: OP_SELECT_LT
      "24: Dst = (Arg1 <= Arg2) ? Arg3 : Arg4",       // 24: OP_SELECT_LE
      "25: Dst = (Arg1 >  Arg2) ? Arg3 : Arg4",       // 25: OP_SELECT_GT
      "26: Dst = (Arg1 >= Arg2) ? Arg3 : Arg4",       // 26: OP_SELECT_GE
      "27: Dst = (Arg1 && Arg2) ? Arg3 : Arg4",       // 27: OP_SELECT_AND
      "28: Dst = (Arg1 || Arg2) ? Arg3 : Arg4",       // 28: OP_SELECT_OR
      "29: Dst = (Arg1 ^^ Arg2) ? Arg3 : Arg4",       // 29: OP_SELECT_EOR
      "30: Dst = pow(Arg1, Arg2)",                    // 30: OP_POW
      "31: Dst = sqrt(Arg1)",                         // 31: OP_SQRT
      "32: Dst = log(Arg1) / log(Arg2)",              // 32: OP_LOG
      "33: Dst = (Arg1 <= Arg2 <= Arg3) ? Arg2 : Arg4",           // 33: OP_RANGE_OUT
      "34: Dst = (Arg1 <= Arg2 <= Arg3) ? Arg4 : Arg2",           // 34: OP_RANGE_IN
      "35: Dst = int(Arg1 / Arg3) * Arg3",                        // 35: OP_IDIV_MUL
      "36: Dst = scale(idx=Arg1 [] Key=Arg2 [] mode=Arg3 [])",    // 36: OP_SCALE_IDX_OCT
      "37: Dst = (note:Arg1 [] base:Arg2 [])",                    // 37: OP_WHITE_TO_IDX
      "38: Dst = scale(idx=Arg1 [] Key=Arg2 [] mode=Arg3 [])",    // 38: OP_SCALE_IDX_REP
      "39: Dst = scale_up(idx=Arg1 [] Key=Arg2 [] mode=Arg3 [])", // 39: OP_SCALE_NOTE_UP
      "40: Dst = scale_dn(idx=Arg1 [] Key=Arg2 [] mode=Arg3 [])", // 40: OP_SCALE_NOTE_DOWN
      "41: Dst = scale_dr(idx=Arg1 [] Key=Arg2 [] mode=Arg3 [])", // 41: OP_SCALE_NOTE_DROP
      "42: Pan Linear (Left Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",   // 42: OP_PAN_LINEAR_L
      "43: Pan Linear (Right Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",  // 43: OP_PAN_LINEAR_R
      "44: Pan Lerp (Left Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",     // 44: OP_PAN_LERP_L
      "45: Pan Lerp (Right Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",    // 45: OP_PAN_LERP_R
      "46: Pan Sqrt (Left Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",     // 46: OP_PAN_SQRT_L
      "47: Pan Sqrt (Right Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",    // 47: OP_PAN_SQRT_R
      "48: Pan Cos (Left Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",      // 48: OP_PAN_COS_L
      "49: Pan Cos (Right Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",     // 49: OP_PAN_COS_R
      "50: Pan Pow (Left Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",      // 50: OP_PAN_POW_L
      "51: Pan Pow (Right Ch Output). Arg1:Min (e.g. 0), Arg2:Max (e.g. 127), Arg3:Pan (-1..1)",     // 51: OP_PAN_POW_R
      "52: Negative Harmony. Arg1:Note, Arg2:Key (C..B)",                                            // 52: OP_NEGHARMONY
      "53: Curve. Arg1:Mode (0:clamp,1:repeat,2:mirrored_repeat), Arg2:CurveIdx (0..3), Arg3: X-Pos (0..1)",  // 53: OP_CURVE
      "54: Slew. Arg1:Value, Arg2:RateUp (0..1), Arg3:RateDn (0..1)",       // 54: OP_SLEW

                                     ];

   PointerArray op_args; // Array of IntArrays, // 0=dst, 1..4 = args 1..4

   static PointerArray op_def_args;  // see init()

   float slew_cval;
   float slew_dval;


   // <method_init.png>
   public method init(NMM_Pattern _parentPat) {

      parent_pat <= _parentPat;

      if(null != parent_pat) // can be null for clipboard entries
      {
         parent_node <= parent_pat.parent_node;
      }

      arg_dst <= new NMM_Arg;
      arg_dst.init(this, parent_pat, false/*bMacro*/, true/*bDst*/);

      arg_1 <= new NMM_Arg;
      arg_1.init(this, parent_pat, false/*bMacro*/, false/*bDst*/);

      arg_2 <= new NMM_Arg;
      arg_2.init(this, parent_pat, false/*bMacro*/, false/*bDst*/);

      arg_3 <= new NMM_Arg;
      arg_3.init(this, parent_pat, false/*bMacro*/, false/*bDst*/);

      arg_4 <= new NMM_Arg;
      arg_4.init(this, parent_pat, false/*bMacro*/, false/*bDst*/);

      b_op = true;
      op = OP_COPY;

      op_def_args = [
         [1],           //  0: Copy
         [1],           //  1: Test
         [1],           //  2: Not
         [1, 2],        //  3: Add
         [1, 2],        //  4: Sub
         [1, 2, 3, 4],  //  5: Mix
         [1, 2, 3],     //  6: Mul
         [1, 2, 3],     //  7: Mul/Div
         [1, 2, 1, 3],  //  8: Blend
         [1, 2, 3],     //  9: Scale From
         [1, 2, 3],     // 10: Scale To
         [1, 2],        // 11: And
         [1, 2],        // 12: Or
         [1, 2],        // 13: Eor
         [1, 2],        // 14: Mod
         [1, 2, 2],     // 15: Mod/Div  v18+
         [1, 2],        // 16: Step
         [1, 2, 3, 4],  // 17: Sin
         [1, 2, 3, 4],  // 18: Tri
         [1, 2, 3],     // 19: Clamp
         [1, 2, 3],     // 20: Wrap
         [1, 2, 3, 4],  // 21: Select ==
         [1, 2, 3, 4],  // 22: Select !=
         [1, 2, 3, 4],  // 23: Select <
         [1, 2, 3, 4],  // 24: Select <=
         [1, 2, 3, 4],  // 25: Select >
         [1, 2, 3, 4],  // 26: Select >=
         [1, 2, 3, 4],  // 27: Select &&
         [1, 2, 3, 4],  // 28: Select ||
         [1, 2, 3, 4],  // 29: Select ^^
         [1, 2],        // 30: Pow
         [1],           // 31: Sqrt
         [1, 2],        // 32: Log
         [1, 2, 3, 4],  // 33: Range Out
         [1, 2, 3, 4],  // 34: Range In
         [1, 2, 3],     // 35: IDiv/Mul
         [1, 2, 3],     // 36: ScaleIdxOct
         [1, 2],        // 37: WhiteToIdx
         [1, 2, 3],     // 38: ScaleIdxRep
         [1, 2, 3],     // 39: ScaleNoteUp
         [1, 2, 3],     // 40: ScaleNoteDown
         [1, 2, 3],     // 41: ScaleNoteDrop
         [1, 2, 3],     // 42: PanLin_L
         [1, 2, 3],     // 43: PanLin_R
         [1, 2, 3],     // 44: PanLerp_L
         [1, 2, 3],     // 45: PanLerp_R
         [1, 2, 3],     // 46: PanSqrt_L
         [1, 2, 3],     // 47: PanSqrt_R
         [1, 2, 3],     // 48: PanCos_L
         [1, 2, 3],     // 49: PanCos_R
         [1, 2, 3],     // 50: PanPow_L
         [1, 2, 3],     // 51: PanPow_R,
         [1, 2],        // 52: NegHarmony
         [1, 2, 3],     // 53: Curve
         [1, 2, 3],     // 54: Slew
                           ];

      // Copy default op args
      op_args.alloc(NUM_OPS);
      int opaIdx = 0;
      loop(NUM_OPS)
      {
         IntArray opa <= new IntArray;
         op_args.add(#(deref opa));
         opa = op_def_args.yacArrayGet(opaIdx);
         opaIdx++;
      }

      // trace "xxx op_args="+#(op_args);
   }

   // <method.png>
   public method copyFrom(NMM_Entry _o) {

      name = _o.name;

      arg_dst.copyFrom(_o.arg_dst, false/*bMacroCtlOnly*/);
      arg_1.copyFrom(_o.arg_1, false/*bMacroCtlOnly*/);
      arg_2.copyFrom(_o.arg_2, false/*bMacroCtlOnly*/);
      arg_3.copyFrom(_o.arg_3, false/*bMacroCtlOnly*/);
      arg_4.copyFrom(_o.arg_4, false/*bMacroCtlOnly*/);

      b_op = _o.b_op;
      op = _o.op;

      IntArray *opa;
      int opIdx = 0;
      foreach opa in _o.op_args
      {
         op_args[opIdx] = opa;
         opIdx++;
      }
   }

   // <method_update.png>
   public method updateMacroEntryRefs() {
      arg_dst.updateMacroEntryRefs();
      arg_1.updateMacroEntryRefs();
      arg_2.updateMacroEntryRefs();
      arg_3.updateMacroEntryRefs();
      // // trace "xxx arg_4.updateMacroEntryRefs:";
      arg_4.updateMacroEntryRefs();
   }

   // <method_get.png>
   public method getDstAliasOrDeviceName() : String {

      if(0 <= arg_dst.disp_dev_idx <= 3)
      {
         return "Macro "+(arg_dst.disp_dev_idx + 1)+" Dev";
      }
      else
      {
         STX_MIDIOutDevice dev <= MIDI.GetMIDIOutDeviceByIndex(arg_dst.dev_idx);

         if(null != dev)
         {
            return dev.getAliasOrDeviceName();
         }

         return "-";
      }
   }

   // <method_get.png>
   public method getDstName() : String {

      switch(arg_dst.disp_type)
      {
         case NMM_Arg.TYPE_NOTE:
         case NMM_Arg.TYPE_NOTE_ADD:
         case NMM_Arg.TYPE_NOTE_ON:
         case NMM_Arg.TYPE_NOTE_ON_ADD:
         case NMM_Arg.TYPE_NOTE_OFF:
         case NMM_Arg.TYPE_NOTE_OFF_ADD:
         case NMM_Arg.TYPE_VELOCITY:
         case NMM_Arg.TYPE_VELOCITY_ADD:
         case NMM_Arg.TYPE_DURATION:
         case NMM_Arg.TYPE_DURATION_ADD:
         case NMM_Arg.TYPE_POLYPRESSURE:
         case NMM_Arg.TYPE_POLYPRESSURE_ADD:
         case NMM_Arg.TYPE_CC:
         case NMM_Arg.TYPE_PRGCHG:
         case NMM_Arg.TYPE_CHPRESSURE:
         case NMM_Arg.TYPE_PITCHBEND:
         case NMM_Arg.TYPE_RPN:
         case NMM_Arg.TYPE_NRPN:
            return "" + (NMM_Arg.type_names.get(arg_dst.disp_type - NMM_Arg.NUM_SRC_TYPES))+": "+getDstAliasOrDeviceName();

         case NMM_Arg.TYPE_BPM:
            return "BPM / Tempo";

         case NMM_Arg.TYPE_GROOVE:
            return "Groove / PipeDelay";

         case NMM_Arg.TYPE_REG1:
         case NMM_Arg.TYPE_REG2:
         case NMM_Arg.TYPE_REG3:
         case NMM_Arg.TYPE_REG4:
         case NMM_Arg.TYPE_REG5:
         case NMM_Arg.TYPE_REG6:
         case NMM_Arg.TYPE_REG7:
         case NMM_Arg.TYPE_REG8:
            return "Reg "+(arg_dst.disp_type - NMM_Arg.TYPE_REG1 + 1);

         case NMM_Arg.TYPE_MACRO1:
         case NMM_Arg.TYPE_MACRO2:
         case NMM_Arg.TYPE_MACRO3:
         case NMM_Arg.TYPE_MACRO4:
            return "" + (NMM_Arg.type_names.get(arg_dst.type - NMM_Arg.NUM_SRC_TYPES))+": "+"Macro "+(arg_dst.disp_type - NMM_Arg.TYPE_MACRO1 + 1);
      }
   }

   // <method_get.png>
   public method getTypesString() : String {
      String r = "";

      r.append(NMM_Arg.type_names.get(arg_dst.type - NMM_Arg.NUM_SRC_TYPES));

      r.append(", ");

      if(arg_1.type >= NMM_Arg.NUM_SRC_TYPES)
         r.append(NMM_Arg.type_names.get(arg_1.type - NMM_Arg.NUM_SRC_TYPES));
      else if(arg_1.type >= NMM_Arg.NUM_SRCDST_TYPES)
         r.append(NMM_Arg.extra_macro_type_names.get(arg_1.type - NMM_Arg.NUM_SRCDST_TYPES));
      else
         r.append(NMM_Arg.extra_src_type_names.get(arg_1.type));

      r.append(", ");

      if(arg_2.type >= NMM_Arg.NUM_SRC_TYPES)
         r.append(NMM_Arg.type_names.get(arg_2.type - NMM_Arg.NUM_SRC_TYPES));
      else if(arg_2.type >= NMM_Arg.NUM_SRCDST_TYPES)
         r.append(NMM_Arg.extra_macro_type_names.get(arg_2.type - NMM_Arg.NUM_SRCDST_TYPES));
      else
         r.append(NMM_Arg.extra_src_type_names.get(arg_2.type));

      r.append(", ");

      if(arg_3.type >= NMM_Arg.NUM_SRC_TYPES)
         r.append(NMM_Arg.type_names.get(arg_3.type - NMM_Arg.NUM_SRC_TYPES));
      else if(arg_3.type >= NMM_Arg.NUM_SRCDST_TYPES)
         r.append(NMM_Arg.extra_macro_type_names.get(arg_3.type - NMM_Arg.NUM_SRCDST_TYPES));
      else
         r.append(NMM_Arg.extra_src_type_names.get(arg_3.type));

      r.append(", ");

      if(arg_4.type >= NMM_Arg.NUM_SRC_TYPES)
         r.append(NMM_Arg.type_names.get(arg_4.type - NMM_Arg.NUM_SRC_TYPES));
      else if(arg_4.type >= NMM_Arg.NUM_SRCDST_TYPES)
         r.append(NMM_Arg.extra_macro_type_names.get(arg_4.type - NMM_Arg.NUM_SRCDST_TYPES));
      else
         r.append(NMM_Arg.extra_src_type_names.get(arg_4.type));

      return r;
   }

   // <method_set.png>
   public =replay= method setEnableOp(boolean _bEnabled) {
      b_op = _bEnabled;
   }

   // <method_set.png>
   public =replay= method setOp(int _op) {
      op = _op;
   }

   // <method_set.png>
   public =replay= method setOpArg1(int _arg1) {
      IntArray opa <= op_args.get(op);
      if(null != opa)
         opa[0] = _arg1;
   }

   // <method_get.png>
   public method getOpArg1() : int {
      int ret = -1;
      IntArray opa <= op_args.get(op);
      if(null != opa)
         ret = opa.get(0);
      return ret;
   }

   // <method_set.png>
   public =replay= method setOpArg2(int _arg1) {
      IntArray opa <= op_args.get(op);
      if(null != opa)
         opa[1] = _arg1;
   }

   // <method_get.png>
   public method getOpArg2() : int {
      int ret = -1;
      IntArray opa <= op_args.get(op);
      if(null != opa)
         ret = opa.get(1);
      return ret;
   }

   // <method_set.png>
   public =replay= method setOpArg3(int _arg1) {
      IntArray opa <= op_args.get(op);
      if(null != opa)
         opa[2] = _arg1;
   }

   // <method_get.png>
   public method getOpArg3() : int {
      int ret = -1;
      IntArray opa <= op_args.get(op);
      if(null != opa)
         ret = opa.get(2);
      return ret;
   }

   // <method_set.png>
   public =replay= method setOpArg4(int _arg1) {
      IntArray opa <= op_args.get(op);
      if(null != opa)
         opa[3] = _arg1;
   }

   // <method_get.png>
   public method getOpArg4() : int {
      int ret = -1;
      IntArray opa <= op_args.get(op);
      if(null != opa)
         ret = opa.get(3);
      return ret;
   }

   // <method_get.png>
   protected method getOpArgObj(int _arg) : NMM_Arg {
      int argNr = 1;
      switch(_arg)
      {
         case 1:
            argNr = getOpArg1();
            break;

         case 2:
            argNr = getOpArg2();
            break;

         case 3:
            argNr = getOpArg3();
            break;

         case 4:
            argNr = getOpArg4();
            break;
      }

      switch(argNr)
      {
         default:
         case 0:
            return arg_dst;

         case 1:
            return arg_1;

         case 2:
            return arg_2;

         case 3:
            return arg_3;

         case 4:
            return arg_4;
      }
   }

   // <replay.png>
   public method reset() {
      // trace "xxx arg_dst.reset() dst="+#(arg_dst);
      arg_dst.reset();
      arg_1.reset();
      arg_2.reset();
      arg_3.reset();
      arg_4.reset();
      slew_cval = NMM_Arg.INVALID_VALUE;
      slew_dval = NMM_Arg.INVALID_VALUE;
   }

   // <method.png>
   protected method getArgVal(int _argIdx) : float {

      switch(_argIdx)
      {
         default:
         case 0: // dst
            return arg_dst.cur_val;

         case 1: // arg1
            return arg_1.cur_val;

         case 2: // arg2
            return arg_2.cur_val;

         case 3: // arg3
            return arg_3.cur_val;

         case 4: // arg4
            return arg_4.cur_val;
      }

      return NMM_Arg.INVALID_VALUE;
   }

   // <method.png>
   public method getIndexedArg(int _argIdx) : NMM_Arg {
      // Used by script parser
      int argIdx = 0;

      IntArray opa <= op_args.get(op);
      if(null != opa) // should never be null
         argIdx = opa.get(_argIdx);

      // trace "xxx NMM_Entry::getIndexedArg: argIdx="+_argIdx+" => argIdx="+argIdx;

      switch(argIdx)
      {
         default:
         case 0: // dst
            return arg_dst;

         case 1: // arg1
            return arg_1;

         case 2: // arg2
            return arg_2;

         case 3: // arg3
            return arg_3;

         case 4: // arg4
            return arg_4;
      }

   }

   // <replay.png>
   protected method calcOp(MIDIPipeFrame _frame, NMM_Reg _ovalExt) : float {

      float oval = NMM_Arg.INVALID_VALUE;

      IntArray opa <= op_args.get(op);
      if(null == opa)
      {
         // Should not be reachable
         return oval;
      }

      float av1 = NMM_Arg.INVALID_VALUE;
      float av2 = NMM_Arg.INVALID_VALUE;
      float av3 = NMM_Arg.INVALID_VALUE;
      float av4 = NMM_Arg.INVALID_VALUE;

      if(opa.numElements > 0)
         av1 = getArgVal(opa.get(0));

      if(opa.numElements > 1)
         av2 = getArgVal(opa.get(1));

      if(opa.numElements > 2)
         av3 = getArgVal(opa.get(2));

      if(opa.numElements > 3)
         av4 = getArgVal(opa.get(3));

      float t;

      switch(op)
      {
         default:
         case OP_COPY:
            oval = av1;
            _ovalExt.val = 1;
            break;

         case OP_TEST:
            if(NMM_Arg.INVALID_VALUE == av1)
               av1 = 0;
            oval = (av1 != 0) ? 1 : 0;
            break;

         case OP_NOT:
            if(NMM_Arg.INVALID_VALUE == av1)
               av1 = 0;
            oval = (av1 == 0) ? 1 : 0;
            break;

         case OP_ADD:
            // // trace "xxx OP_ADD: av1="+av1+" av2="+av2;

            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = av1 + av2;
                  _ovalExt.val = 1;
               }
            }
            break;

         case OP_SUB:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = av1 - av2;
                  _ovalExt.val = 1;
               }
            }
            break;

         case OP_MIX:
            // // trace "xxx OP_MIX: av1="+av1+" av2="+av2;

            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(NMM_Arg.INVALID_VALUE != av4)
                     {
                        oval = av1*av2 + av3*av4;
                     }
                  }
               }
            }
            break;

         case OP_MUL:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (av1 * av2 * av3);
                  }
               }
            }
            break;

         case OP_MUL_DIV:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (av1 * av2) / av3;
                     // // trace "xxx OP_MUL_DIV: av1="+av1+" av2="+av2+" av3="+av3+" oval="+oval;
                  }
               }
            }
            break;

         case OP_BLEND:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(NMM_Arg.INVALID_VALUE != av4)
                     {
                        oval = av1 + (av2 - av3) * av4;
                        // // trace "xxx OP_BLEND: av1="+av1+" av2="+av2+" av3="+av3+" av4="+av4+" oval="+oval;
                        // // trace "xxx oval="+oval;
                     }
                  }
               }
            }
            break;

         case OP_SCALE_FROM:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(av2 > av3)
                     {
                        t = av2;
                        av2 = av3;
                        av3 = t;
                     }
                     oval = (av1 - av2) / (av3 - av2);
                     oval = mathClampf(oval, 0.0, 1.0);
                  }
               }
            }
            break;

         case OP_SCALE_TO:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     av1 = mathClampf(av1, 0.0, 1.0);
                     if(av2 > av3)
                     {
                        t = av2;
                        av2 = av3;
                        av3 = t;
                     }
                     oval = av2 + (av3 - av2) * av1;
                  }
               }
            }
            break;

         case OP_AND:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = int(av1) & int(av2);
               }
            }
            break;

         case OP_OR:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = int(av1) | int(av2);
               }
            }
            break;

         case OP_EOR:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = int(av1) ^ int(av2);
               }
            }
            break;

         case OP_MOD:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(av1 >= 0)
                  {
                     oval = int(av1) % int(av2);
                  }
                  else
                  {
                     oval = - (int(-av1) % int(av2));
                  }
               }
            }
            break;

         case OP_MOD_DIV:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(av1 >= 0)
                     {
                        oval = int(av1) % int(av2);
                     }
                     else
                     {
                        oval = - (int(-av1) % int(av2));
                     }
                     oval /= av3;
                  }
               }
            }
            break;

         case OP_STEP:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  // pre 13Aug2017:
                  // // t = (1.0 / av2);
                  // // oval = int(av1 / t) * t;

                  t = av2;
                  oval = int(av1 / t) * t;
               }
            }
            break;

         case OP_SIN:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(NMM_Arg.INVALID_VALUE != av4)
                     {
                        oval = sin(2PI * (av1 + av2)) * av3 + av4;
                     }
                  }
               }
            }
            break;

         case OP_TRI:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(NMM_Arg.INVALID_VALUE != av4)
                     {
                        t = frac(av1 + av2);
                        if(t >= 0.5)
                        {
                           oval = 1.0 - (t-0.5)*4;
                        }
                        else
                        {
                           oval = -1 + t*4;
                        }
                        oval = oval*av3 + av4;
                     }
                  }
               }
            }
            break;

         case OP_CLAMP:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(av2 > av3)
                     {
                        t = av2;
                        av2 = av3;
                        av3 = t;
                     }
                     if(av1 < av2)
                        oval = av2;
                     else if(av1 > av3)
                        oval = av3;
                     else
                        oval = av1;
                  }
               }
            }
            break;

         case OP_WRAP:
            // // trace "xxx OP_WRAP av1="+av1+" av2="+av2+" av3="+av3;
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(av2 > av3)
                     {
                        t = av2;
                        av2 = av3;
                        av3 = t;
                     }
                     loop(4)
                     {
                        if(av1 < av2)
                           av1 = av3 + (av1 - av2);
                        else if(av1 >= av3)
                           av1 = av2 + (av1 - av3);
                     }
                     oval = av1;
                  }
               }
            }
            break;

         case OP_SELECT_EQ:
            // // trace "xxx OP_SELECT_EQ: av1="+av1+" av2="+av2+" av3="+av3+" av4="+av4;
            // // // oval = (av1 == av2) ? av3 : av4;
            if(av1 == av2)
            {
               oval = av3;
               _ovalExt.val = 3;
            }
            else
            {
               oval = av4;
               _ovalExt.val = 4;
            }
            break;

         case OP_SELECT_NE:
            // // trace "xxx OP_SELECT_NE: av1="+av1+" av2="+av2;
            // // // oval = (av1 != av2) ? av3 : av4;
            if(av1 != av2)
            {
               oval = av3;
               _ovalExt.val = 3;
            }
            else
            {
               oval = av4;
               _ovalExt.val = 4;
            }
            break;

         case OP_SELECT_LT:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  // // oval = (av1 < av2) ? av3 : av4;
                  if(av1 < av2)
                  {
                     oval = av3;
                     _ovalExt.val = 3;
                  }
                  else
                  {
                     oval = av4;
                     _ovalExt.val = 4;
                  }
               }
            }
            break;

         case OP_SELECT_LE:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  // // oval = (av1 <= av2) ? av3 : av4;
                  if(av1 <= av2)
                  {
                     oval = av3;
                     _ovalExt.val = 3;
                  }
                  else
                  {
                     oval = av4;
                     _ovalExt.val = 4;
                  }
               }
            }
            break;

         case OP_SELECT_GT:
            // // trace "xxx OP_SELECT_GT: av1="+av1+" av2="+av2;
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  // // oval = (av1 > av2) ? av3 : av4;
                  if(av1 > av2)
                  {
                     oval = av3;
                     _ovalExt.val = 3;
                  }
                  else
                  {
                     oval = av4;
                     _ovalExt.val = 4;
                  }
               }
            }
            break;

         case OP_SELECT_GE:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  // // oval = (av1 >= av2) ? av3 : av4;
                  if(av1 >= av2)
                  {
                     oval = av3;
                     _ovalExt.val = 3;
                  }
                  else
                  {
                     oval = av4;
                     _ovalExt.val = 4;
                  }
               }
            }
            break;

         case OP_SELECT_AND:
            if(NMM_Arg.INVALID_VALUE == av1)
               av1 = 0;
            if(NMM_Arg.INVALID_VALUE == av2)
               av2 = 0;

            // // trace "xxx SELECT_AND: av1="+av1+" av2="+av2+" av3="+av3+" av4="+av4;
            // // // oval = ((0 != av1) && (0 != av2)) ? av3 : av4;
            if(0 != av1 && 0 != av2)
            {
               oval = av3;
               _ovalExt.val = 3;
            }
            else
            {
               oval = av4;
               _ovalExt.val = 4;
            }
            break;

         case OP_SELECT_OR:
            if(NMM_Arg.INVALID_VALUE == av1)
               av1 = 0;
            if(NMM_Arg.INVALID_VALUE == av2)
               av2 = 0;
            // // oval = ((0 != av1) || (0 != av2)) ? av3 : av4;
            if(0 != av1 || 0 != av2)
            {
               oval = av3;
               _ovalExt.val = 3;
            }
            else
            {
               oval = av4;
               _ovalExt.val = 4;
            }
            break;

         case OP_SELECT_EOR:
            if(NMM_Arg.INVALID_VALUE == av1)
               av1 = 0;
            if(NMM_Arg.INVALID_VALUE == av2)
               av2 = 0;
            // // oval = ((0 != av1) ^ (0 != av2)) ? av3 : av4;
            if( (0 != av1) ^ (0 != av2) )
            {
               oval = av3;
               _ovalExt.val = 3;
            }
            else
            {
               oval = av4;
               _ovalExt.val = 4;
            }
            break;

         case OP_POW:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = mathPowerf(av1, av2);
               }
            }
            break;

         case OP_SQRT:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(av1 > 0)
                  oval = sqrt(av1);
               else
                  oval = 0;
            }
            break;

         case OP_LOG:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = log(av2) / log(av1);
               }
            }
            break;

         case OP_RANGE_OUT:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (av1 <= av2 <= av3) ? av2 : av4;
                  }
               }
            }
            break;

         case OP_RANGE_IN:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (av1 <= av2 <= av3) ? av4 : av2;
                  }
               }
            }
            break;

         case OP_IDIV_MUL:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = int(av1 / av2) * av3;
                  }
               }
            }
            break;

         case OP_SCALE_IDX_OCT:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = Scale.ScaleIndexOct(av1/*idx*/, av2/*key*/, av3/*mode*/);

                     if(oval < 0)
                     {
                        oval = NMM_Arg.INVALID_VALUE;
                     }
                  }
               }
            }
            break;

         case OP_WHITE_TO_IDX:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = Scale.WhiteToIndex(av1/*note*/, av2/*base*/);

                  if(oval < 0)
                  {
                     oval = NMM_Arg.INVALID_VALUE;
                  }
               }
            }
            break;

         case OP_SCALE_IDX_REP:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = Scale.ScaleIndexRep(av1/*idx*/, av2/*key*/, av3/*mode*/);

                     if(oval < 0)
                     {
                        oval = NMM_Arg.INVALID_VALUE;
                     }
                  }
               }
            }
            break;

         case OP_SCALE_NOTE_UP:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = Scale.ScaleNoteUp(av1/*note*/, av2/*key*/, av3/*mode*/);

                     if(oval < 0)
                     {
                        oval = NMM_Arg.INVALID_VALUE;
                     }
                  }
               }
            }
            break;

         case OP_SCALE_NOTE_DOWN:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = Scale.ScaleNoteDown(av1/*note*/, av2/*key*/, av3/*mode*/);

                     if(oval < 0)
                     {
                        oval = NMM_Arg.INVALID_VALUE;
                     }
                  }
               }
            }
            break;

         case OP_SCALE_NOTE_DROP:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = Scale.ScaleNoteDrop(av1/*note*/, av2/*key*/, av3/*mode*/);

                     if(oval < 0)
                     {
                        oval = NMM_Arg.INVALID_VALUE;
                     }
                  }
               }
            }
            break;

         case OP_PAN_LINEAR_L:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (av3 < 0.0f) ? 1.0f : (1.0f - av3);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_LINEAR_R:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (av3 > 0.0f) ? 1.0f : (1.0f + av3);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_LERP_L:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = ((1.0f - av3) * 0.5f);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_LERP_R:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = ((1.0f - av3) * 0.5f);
                     oval = (1.0f - oval);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_SQRT_L:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (0.5f + av3*0.5f);
                     oval = sqrt(1.0f - oval);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_SQRT_R:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (0.5f + av3*0.5f);
                     oval = sqrt(oval);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_COS_L:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (0.25f + av3*0.25f) * PI;
                     oval = cos(oval);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_COS_R:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (0.25f + av3*0.25f) * PI;
                     oval = cos(PI*0.5 - oval);
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_POW_L:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (0.5f + av3*0.5f);
                     oval = mathPowerf(E, (1.0f - oval) * 0.6931) - 1.0f;
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_PAN_POW_R:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     oval = (0.5f + av3*0.5f);
                     oval = mathPowerf(E, oval * 0.6931) - 1.0f;
                     oval = av1 + (av2 - av1) * oval;
                  }
               }
            }
            break;

         case OP_NEG_HARMONY:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  oval = Scale.NegativeHarmony(av1/*note*/, av2/*key*/);
               }
            }
            break;

         case OP_CURVE:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     if(av2 >= 0)
                     {
                        Envelope curveEnv <= parent_pat.curve_envs.get(int(av2) % NMM_Pattern.NUM_CURVES);
                        if(null != curveEnv)
                        {
                           switch(int(av1) & 3)
                           {
                              default:
                              case 0:  // clamp
                                 av3 = mathClampf(av3, 0.0f, 1.0f);
                                 break;

                              case 1:  // wrap
                                 av3 = mathWrapf(av3, 0.0f, 1.0f);
                                 break;

                              case 2:  // mirrored repeat
                                 int curveRep;
                                 if(av3 >= 0.0f)
                                 {
                                    curveRep = int(av3);
                                    av3 = frac(av3);
                                    if(curveRep & 1)
                                       av3 = 1.0f - av3;
                                 }
                                 else
                                 {
                                    curveRep = int(-av3);
                                    av3 = frac(-av3);
                                    if!(curveRep & 1)
                                       av3 = 1.0f - av3;
                                 }
                                 break;
                           }
                           curveEnv.time = av3;
                           oval = curveEnv.get();

                           parent_node.b_queued_redraw_overlays = true; // redraw CurveForm (when visible)
                        }
                     }
                  }
               }
            }
            break;

         case OP_SLEW:
            if(NMM_Arg.INVALID_VALUE != av1)
            {
               // New target value
               if(NMM_Arg.INVALID_VALUE == slew_dval)
               {
                  // First target value
                  slew_dval = av1;
                  slew_cval = slew_dval;
                  oval = av1;
               }
               else
               {
                  // Next target value
                  slew_dval = av1;
               }
            }
            if(NMM_Arg.INVALID_VALUE != slew_dval)
            {
               if(NMM_Arg.INVALID_VALUE != av2)
               {
                  if(NMM_Arg.INVALID_VALUE != av3)
                  {
                     float slewAmt;
                     if(slew_dval >= slew_cval)
                        slewAmt = av2 * av2 * av2;  // up
                     else
                        slewAmt = av3 * av3 * av3;  // down
                     oval = slew_cval + (slew_dval - slew_cval) * slewAmt;

                     if(oval == slew_cval)
                        oval = NMM_Arg.INVALID_VALUE;  // unchanged
                     else
                        slew_cval = oval;
                  }
               }
            }
            break;
      }

      if((NMM_Arg.SH_NONE  != arg_dst.sh_type) &&
         (NMM_Arg.SH_RESET != arg_dst.sh_type) &&
         (NMM_Arg.SH_INF   != arg_dst.sh_type)
         )
      {
         // Reduce output rate (e.g. save MIDI bandwidth)
         int shTicks = arg_dst.getShQuantTicks();
         // // trace "xxx modmatrix: arg_dst.shTicks="+shTicks+" oval="+oval;
         if(0 != (parent_node.tick_nr % shTicks))
            oval = NMM_Arg.INVALID_VALUE;  // discard
      }

      return oval;
   }

   // <replay.png>
   // static int xxx_cnt = 0;
   public method processFrame(MIDIPipeFrame _frame,
                              MIDIPipeFrame _framePlus,
                              boolean       _bMuted,
                              boolean       _bPlaySeq,
                              int           _evIdx,
                              Boolean       _bReadMore
                              ) {
      // // int evIdx = 0;

      // (todo) track each note individually / support different modulation values per note ?
      //         (e.g. different randomization)
      //         maybe add a splitter node that splits a chord into multiple channels
      // trace "xxx nmm: entry processFrame";

      // // MIDIPipeFrame frInput = _frame; // avoid "recursion" when notes are added

      // // Boolean bReadMore = false;

      loop(1) // (note) note/polypressure event loop is in previous stackframe
      {
         boolean bReadNewEv = false;

         bReadNewEv |= arg_dst.readCurrentVal(_frame, _evIdx, _bReadMore);
         // trace "xxx dst bReadNewEv="+bReadNewEv;
         // trace "xxx arg_dst cur_val="+arg_dst.cur_val;
         bReadNewEv |= arg_1.readCurrentVal(_frame, _evIdx, _bReadMore);
         // trace "xxx 1 bReadNewEv="+bReadNewEv;
         bReadNewEv |= arg_2.readCurrentVal(_frame, _evIdx, _bReadMore);
         // trace "xxx 2 bReadNewEv="+bReadNewEv;
         bReadNewEv |= arg_3.readCurrentVal(_frame, _evIdx, _bReadMore);
         // trace "xxx 3 bReadNewEv="+bReadNewEv;
         arg_4.b_debug = true;
         // if((0 == evIdx) && ((++xxx_cnt & 511) == 0))
         // {
         //    trace "xxx arg_4.dev_idx="+arg_4.dev_idx+" dev_ch="+arg_4.dev_ch;
         // }
         bReadNewEv |= arg_4.readCurrentVal(_frame, _evIdx, _bReadMore);
          // trace "xxx 4 bReadNewEv="+bReadNewEv;

         // if(0 == evIdx)
         // {
         //    trace "xxx evIdx="+evIdx+" bReadNewEv="+bReadNewEv;
         //    trace "xxx      dst:"+arg_dst.cur_val;
         //    trace "xxx    arg_1:"+arg_1.cur_val;
         //    trace "xxx    arg_2:"+arg_2.cur_val;
         //    trace "xxx    arg_3:"+arg_3.cur_val;
         //    trace "xxx    arg_4:"+arg_4.cur_val;
         // }

         if(parent_pat.b_event)
            if(!bReadNewEv)
               break;

         // Special case: copy notes (copy orig_* as well)
         // // if(OP_COPY == op)
         // // {
         // //    NMM_Arg ra1 <= getOpArgObj(1);
         // //    // if(NMM_Arg.INVALID_VALUE == arg_dst.cur_val)
         // //    if(@(ra1) != @(arg_dst))
         // //    {
         // //       if(ra1.isMultiType())
         // //       {
         // //          if(arg_dst.isMultiType())
         // //          {
         // //             arg_dst.orig_note         = ra1.orig_note;
         // //             arg_dst.b_orig_note_state = ra1.b_orig_note_state;
         // //             arg_dst.orig_vel          = ra1.orig_vel;
         // //             arg_dst.orig_dur          = ra1.orig_dur;
         // //          }
         // //          else if(arg_dst.isRegType())
         // //          {
         // //             // Copy arg to register
         // //             parent_pat.copyMultiArgToReg(arg_dst.type - NMM_Arg.TYPE_REG1, ra1);
         // //          }
         // //       }
         // //       else if(ra1.isRegType())
         // //       {
         // //          if(arg_dst.isMultiType())
         // //          {
         // //             // Copy register to arg
         // //             parent_pat.copyRegToMultiArg(ra1.type - NMM_Arg.TYPE_REG1, arg_dst);
         // //          }
         // //          else if(arg_dst.isRegType())
         // //          {
         // //             parent_pat.copyRegToReg(arg_dst.type - NMM_Arg.TYPE_REG1/*dst*/,
         // //                                     ra1.type - NMM_Arg.TYPE_REG1/*src*/
         // //                                     );
         // //          }
         // //       }
         // //    }
         // // }

         NMM_Reg ovalExt;
         ovalExt.val = -1;
         arg_dst.tmp_force_dst_ch = -1;
         float nval = calcOp(_frame, ovalExt);
         // trace "xxx modmatrix: nval="+nval;

         // if(bReadNewEv)
         //    trace "xxx modmatrix: bReadNewEv=true calcOp returned nval="+nval;

         if(ovalExt.val >= 0)
         {
            // Get extended result from select/copy OP (copy orig_* note vel/dur/state)
            NMM_Arg ra <= getOpArgObj(ovalExt.val);

            if(@(ra) != @(arg_dst))
            {
               // trace "xxx arg_dst.dev_ch="+arg_dst.dev_ch+" ra.orig_ch="+ra.orig_ch+" arg_dst.orig_ch="+arg_dst.orig_ch;
               if(-1 == arg_dst.dev_ch)
               {
                  if(-1 != ra.orig_ch)
                     arg_dst.tmp_force_dst_ch = ra.orig_ch;
                  else
                  {
                     // [30May2021] e.g. when writing "none" to NOTE_ON dst ch=*
                     arg_dst.tmp_force_dst_ch = arg_dst.orig_ch;
                  }
               }

               if(ra.isMultiType())
               {
                  if(arg_dst.isMultiType())
                  {
                     arg_dst.orig_note         = ra.orig_note;
                     arg_dst.b_orig_note_state = ra.b_orig_note_state;
                     arg_dst.orig_vel          = ra.orig_vel;
                     arg_dst.orig_dur          = ra.orig_dur;
                  }
                  else if(arg_dst.isRegType())
                  {
                     // Copy arg to register
                     parent_pat.copyMultiArgToReg(arg_dst.type - NMM_Arg.TYPE_REG1, ra);
                  }
               }
               else if(ra.isRegType())
               {
                  if(arg_dst.isMultiType())
                  {
                     // Copy register to arg
                     parent_pat.copyRegToMultiArg(ra.type - NMM_Arg.TYPE_REG1, arg_dst);
                  }
                  else if(arg_dst.isRegType())
                  {
                     parent_pat.copyRegToReg(arg_dst.type - NMM_Arg.TYPE_REG1/*dst*/,
                                             ra.type - NMM_Arg.TYPE_REG1/*src*/
                                             );
                  }
               }
            }
         }
         // // else
         // // {
         // //    if(-1 == arg_dst.midi_ch)
         // //    {
         // //       // Get extended result from select/copy OP (copy orig_* note vel/dur/state)
         // //       NMM_Arg ra <= getOpArgObj(ovalExt.val);
         // //       arg_dst.tmp_midi_ch = ra.orig_ch;
         // //    }
         // // }

         if(!_bMuted)
         {
             // trace "xxx evIdx="+evIdx+" output nval="+nval;
            arg_dst.outputVal(_frame, _framePlus, nval);
            // trace "xxx  ==> out_val="+arg_dst.out_val+" ui_out_val="+arg_dst.ui_out_val;
         }
         else
         {
            // // arg_dst.out_val = NMM_Arg.INVALID_VALUE;
         }

         // // if(!bReadMore)
         // //    break;

         // // evIdx++;
      }

      arg_dst.uiOutputValDecay();

      // if(!_bMuted)
      //    trace "xxx  processFrame: ui_out_val="+arg_dst.ui_out_val;
   }

   // <method.png>
   public method appendToScript(String _script) {
      arg_dst.appendToScript(_script);
      _script.append(" ");
      _script.append(script_op_names.get(op));
      _script.append(" ");

      IntArray opArgs <= op_args.get(op);

      if(null != opArgs)
      {
         NMM_Arg *arg;
         PointerArray uniqueArgs;
         uniqueArgs.empty();
         uniqueArgs.add(arg_dst);
         int argIdx = 0;

         loop(opArgs.numElements)
         {
            arg <= getIndexedArg(argIdx);
            if(!uniqueArgs.containsPointer(arg))
               uniqueArgs.add(arg);
            argIdx++;
         }

         uniqueArgs.delete(0); // Remove dst

         if(uniqueArgs.numElements >= 1)
         {
            arg <= uniqueArgs.get(0);
            arg.appendToScript(_script);

            if(uniqueArgs.numElements >= 2)
            {
               _script.append(" ");
               arg <= uniqueArgs.get(1);
               arg.appendToScript(_script);

               if(uniqueArgs.numElements >= 3)
               {
                  _script.append(" ");
                  arg <= uniqueArgs.get(2);
                  arg.appendToScript(_script);

                  if(uniqueArgs.numElements >= 4)
                  {
                     _script.append(" ");
                     arg <= uniqueArgs.get(3);
                     arg.appendToScript(_script);
                  }
               }
            }
         }
      }
      else
      {
         // Should not be reachable
         _script.append("<ill_op>");
      }
   }

   // <save.png>
   public method saveState(Stream ofs) {

      ofs.i16 = 20; // Version

      Utils.WriteString(ofs, name);

      arg_dst.saveState(ofs);
      arg_1.saveState(ofs);
      arg_2.saveState(ofs);
      arg_3.saveState(ofs);
      arg_4.saveState(ofs);

      ofs.i8 = b_op; // v4+
      ofs.i8 = op;

      // Op args
      IntArray *opa;
      int opaOffset = ofs.offset;
      ofs.i32 = 0;
      foreach opa in op_args
      {
         Utils.WriteIntArray(ofs, opa);
      }
      Utils.FixChunkSize(ofs, opaOffset);

   }

   // <load.png>
   public method loadState(Stream ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount, boolean _bPreset) : boolean {
      short ver = ifs.i16;

      if(ver >= 1)
      {
         // Name
         Utils.ReadString(ifs, name);

         if(ver >= 2)
         {
            if(!arg_dst.loadState(ifs, _outDevIdxMap, _outDevUseCount, _bPreset, false/*bMacro*/))
               return false;

            if(!arg_1.loadState(ifs, _outDevIdxMap, _outDevUseCount, _bPreset, false/*bMacro*/))
               return false;

            if(!arg_2.loadState(ifs, _outDevIdxMap, _outDevUseCount, _bPreset, false/*bMacro*/))
               return false;

            if(!arg_3.loadState(ifs, _outDevIdxMap, _outDevUseCount, _bPreset, false/*bMacro*/))
               return false;

            if(!arg_4.loadState(ifs, _outDevIdxMap, _outDevUseCount, _bPreset, false/*bMacro*/))
               return false;

            if(ver >= 4)
            {
               b_op = ifs.b8;
            }

            op = ifs.u8;

            if((ver < 14) && (op >= OP_RANGE_IN))
            {
               op++;
            }

            if((ver < 15) && (op >= OP_SUB))
            {
               op++;
            }

            if((ver < 18) && (op >= OP_MOD_DIV))
            {
               op++;
            }

            if(ver <= 2)
            {
               ifs.getU8(); // v2 (arg_1_idx)
               ifs.getU8(); // v2 (arg_2_idx)
               ifs.getU8(); // v2 (arg_3_idx)
               ifs.getU8(); // v2 (arg_4_idx)
            }

            if(ver >= 3)
            {
               IntArray *opa;
               int opStartOff = ifs.offset;
               int opaSz = ifs.i32;
               int opIdx = 0;
               foreach opa in op_args
               {
                  // if(ifs.offset >= (opStartOff + opaSz))
                  //    break;
                  if(
                     ((OP_SUB             != opIdx) || (ver >= 15)) &&
                     ((OP_MIX             != opIdx) || (ver >= 5))  &&
                     ((OP_MUL             != opIdx) || (ver >= 6))  &&
                     ((OP_MOD_DIV         != opIdx) || (ver >= 18)) &&
                     (((OP_POW != opIdx) && (OP_SQRT != opIdx) && (OP_LOG != opIdx)) || (ver >= 7)) &&
                     ((OP_RANGE_OUT       != opIdx) || (ver >= 8))  &&
                     ((OP_RANGE_IN        != opIdx) || (ver >= 14)) &&
                     ((OP_IDIV_MUL        != opIdx) || (ver >= 9))  &&
                     ((OP_SCALE_IDX_OCT   != opIdx) || (ver >= 10)) &&
                     ((OP_WHITE_TO_IDX    != opIdx) || (ver >= 11)) &&
                     ((OP_SCALE_IDX_REP   != opIdx) || (ver >= 12)) &&
                     ((OP_SCALE_NOTE_UP   != opIdx) || (ver >= 13)) &&
                     ((OP_SCALE_NOTE_DOWN != opIdx) || (ver >= 13)) &&
                     ((OP_SCALE_NOTE_DROP != opIdx) || (ver >= 13)) &&
                     ((opIdx < OP_PAN_LINEAR_L) || (ver >= 16))     &&
                     ((opIdx < OP_NEG_HARMONY)  || (ver >= 17))     &&
                     ((opIdx < OP_CURVE)        || (ver >= 19))     &&
                     ((opIdx < OP_SLEW)         || (ver >= 20))
                     )
                  {
                     Utils.ReadIntArray(ifs, opa);
                  }
                  opIdx++;
               }
               if(ifs.offset != (opStartOff + opaSz))
               {
                  trace "[---] NMM_Entry::loadState: failed to read op args (off="+ifs.offset+", expected "+(opStartOff+opaSz);
                  return false;
               }
            }
         }

         return true;
      }

      return false;
   }
}
