// ----
// ---- file   : midi.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 14Sep2006, 17Sep2006, 20Sep2006, 15Oct2007, 20Oct2007, 21Oct2007, 22Oct2007,
// ----          30Oct2007, 31Oct2007, 04Nov2007, 05Nov2007, 10Nov2007, 21Dec2007, 04Jan2008
// ----          07Jan2008, 10Jan2008, 12Jan2008, 13Jan2008, 15Jan2008, 16Jan2008, 03Aug2008
// ----          09Aug2008, 24Aug2008, 31Aug2008, 17Sep2009, 18Sep2009, 20Sep2009, 21Sep2009
// ----          22Sep2009, 23Sep2009, 26Dec2009, 02Jan2010, 03Jan2010, 09Jan2010, 10Jan2010
// ----          11Jan2010, 16Jan2010, 25Jan2010, 27Jan2010, 29Jan2010, 06Feb2010, 25Feb2010
// ----          01Mar2010, 24Apr2010, 29Apr2010, 30Apr2010, 01May2010, 02May2010, 03May2010
// ----          04May2010, 11May2010, 14May2010, 15May2010, 16May2010, 06Jun2010, 10Jun2010
// ----          13Jun2010, 15Jun2010, 24Jun2010, 26Jun2010, 28Jun2010, 30Jun2010, 01Jul2010
// ----          02Jul2010, 04Jul2010, 06Jul2010, 10Jul2010, 12Jul2010, 16Jul2010, 17Jul2010
// ----          18Jul2010, 21Jul2010, 08Sep2010, 24Sep2010, 26Sep2010, 27Sep2010, 28Sep2010
// ----          04Oct2010, 08Oct2010, 09Oct2010, 10Oct2010, 12Oct2010, 13Oct2010, 14Oct2010
// ----          15Oct2010, 16Oct2010, 17Oct2010, 19Oct2010, 20Oct2010, 25Oct2010, 26Oct2010
// ----          02Nov2010, 09Nov2010, 16Nov2010, 21Nov2010, 19Jan2011, 23Jan2011, 03Feb2011
// ----          18Feb2011, 20Feb2011, 25Feb2011, 28Feb2011, 12Mar2011, 13Mar2011, 19Mar2011
// ----          30Mar2011, 02Apr2011, 06Apr2011, 20Apr2011, 11Jun2011, 08Jan2012, 09Jan2012
// ----          16Jan2012, 17Jan2012, 19Jan2012, 20Jan2012, 24Jan2012, 06Feb2012, 08Feb2012
// ----          13Feb2012, 14Feb2012, 19Feb2012, 20Feb2012, 24Feb2012, 25Feb2012, 13May2012
// ----          26Jun2012, 28Jun2012, 09Nov2012, 13Nov2012, 21Nov2012, 21Dec2012, 03Jan2013
// ----          04Jan2013, 05Jan2013, 06Jan2013, 09Jan2013, 28Feb2013, 23Mar2013, 01Apr2013
// ----          07Apr2013, 13Apr2013, 14Apr2013, 15Apr2013, 19Apr2013, 04May2013, 08May2013
// ----          09May2013, 10May2013, 13May2013, 14May2013, 15May2013, 24May2013, 26May2013
// ----          27May2013, 29May2013, 31May2013, 01Jun2013, 04Jun2013, 05Jun2013, 02Feb2014
// ----          04Feb2014, 10Feb2014, 11Feb2014, 15Jun2014, 09Aug2014, 11Aug2014, 13Aug2014
// ----          15Aug2014, 19Aug2014, 25Aug2014, 31Aug2014, 04Sep2014, 09Sep2014, 15Sep2014
// ----          27Sep2014, 29Sep2014, 17Oct2014, 11Jan2015, 04Feb2015, 14Feb2015, 17Feb2015
// ----          19Feb2015, 21Feb2015, 23Feb2015, 02Mar2015, 14Apr2015, 18Apr2015, 20Apr2015
// ----          17May2015, 26Jul2015, 14Sep2015, 08Nov2015, 09Jan2016, 11Jan2016, 19Jan2016
// ----          25Jan2016, 26Jan2016, 05Feb2016, 07Feb2016, 22Jul2016, 18Aug2016, 13Jan2017
// ----          18Feb2017, 23Feb2017, 03Mar2017, 10Mar2017, 11Mar2017, 12Mar2017, 27May2017
// ----          14Oct2017, 04Jan2018, 17Mar2018, 08May2018, 21May2018, 28May2018, 03Jun2018
// ----          09Dec2018, 15Dec2018, 17Jan2019, 22Jan2019, 14Jul2019, 20Sep2019, 22Sep2019
// ----          02Oct2019, 03Oct2019, 05Oct2019, 20Oct2019, 03Nov2019, 08Apr2020, 26Apr2020
// ----          09May2020, 01Nov2020, 10Nov2020, 12Nov2020, 21Nov2020, 10May2021, 14Jun2021
// ----          27Dec2021, 07Jan2022, 18Mar2022, 24Nov2022, 22Jan2023, 18Feb2023, 03Apr2023
// ----          14Jun2023, 19Jul2023, 22Jul2023, 27Jul2023, 04Oct2023, 14Oct2023, 15Oct2023
// ----          20Oct2023, 07Jul2024, 02Oct2024, 05Oct2024, 16Jan2025, 15Mar2025, 17Mar2025
// ----
// ----
// ----
module MMIDI;

use namespace ui;
use namespace st2;


// <callback.png>
function onMIDITimer(MIDITimer _timer) {
   if(!replay.b_export)
   {
      if(!replay.b_thread_prio_set)
      {
         replay.b_thread_prio_set = true;
         replay.th_replay <= TKS.newThreadFromCurrent();
         Thread thReplay <= replay.th_replay;
         if(null != thReplay)
         {
            if(!STConfig.b_ignore_thread_affinity)
            {
               thReplay.setAffinityMaskByString(STConfig.replay_thread_affinity_mask);
               if(Configuration.debugLevel >= 2)
                  trace "[dbg] onMIDITimer: set replay_thread_affinity_mask=\""+STConfig.replay_thread_affinity_mask+"\"";
            }
            // thReplay.priority = THREAD_PRIORITY_TIME_CRITICAL;  // root only on Linux
            // thReplay.priority = THREAD_PRIORITY_HIGHEST;  // root only
            // thReplay.priority = THREAD_PRIORITY_HIGHEST;  // maps to max sched priority on macOS
         }
      }

      replay.tick(milliSeconds(), null/*frameExportOrNull*/);
   }
}


// <class.png>
class MIDI {

   // 0..25 => "vst_a".."vst_z"
   //   (note) see STConfig.localmidi_out_devicenames
   //   (note) see <eureka>Replay.MAX_MIDI_INPUTS
   //   (note) not including "remote_audio" (STConfig.sysex_out_devicename)
   define int MAX_LOCALMIDI_OUTPUTS = 26;

   static StringArray base_note_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

   // (@* Notes)
   //  (note) may be modified at startup when STConfig.node_tracker_octave_offset is != 0
   public static StringArray midi_notes = [
      // (note) actually, MIDI note #0 == C-2 (am.) resp. C-3 (ger.). STÂ² starts with C-0
      "C-0", "C#0", "D-0", "D#0", "E-0", "F-0", "F#0", "G-0", "G#0", "A-0", "A#0", "B-0", //   0.. 11
      "C-1", "C#1", "D-1", "D#1", "E-1", "F-1", "F#1", "G-1", "G#1", "A-1", "A#1", "B-1", //  12.. 23
      "C-2", "C#2", "D-2", "D#2", "E-2", "F-2", "F#2", "G-2", "G#2", "A-2", "A#2", "B-2", //  24.. 35
      "C-3", "C#3", "D-3", "D#3", "E-3", "F-3", "F#3", "G-3", "G#3", "A-3", "A#3", "B-3", //  36.. 47
      "C-4", "C#4", "D-4", "D#4", "E-4", "F-4", "F#4", "G-4", "G#4", "A-4", "A#4", "B-4", //  48.. 59
      "C-5", "C#5", "D-5", "D#5", "E-5", "F-5", "F#5", "G-5", "G#5", "A-5", "A#5", "B-5", //  60.. 71
      "C-6", "C#6", "D-6", "D#6", "E-6", "F-6", "F#6", "G-6", "G#6", "A-6", "A#6", "B-6", //  72.. 83
      "C-7", "C#7", "D-7", "D#7", "E-7", "F-7", "F#7", "G-7", "G#7", "A-7", "A#7", "B-7", //  84.. 95
      "C-8", "C#8", "D-8", "D#8", "E-8", "F-8", "F#8", "G-8", "G#8", "A-8", "A#8", "B-8", //  96..107
      "C-9", "C#9", "D-9", "D#9", "E-9", "F-9", "F#9", "G-9", "G#9", "A-9", "A#9", "B-9", // 108..119
      "C-A", "C#A", "D-A", "D#A", "E-A", "F-A", "F#A", "G-A"
                                           ];

   public static HashTable note_name_profiles;  // StringArray instances

   public static StringArray midi_ch_names = [
      "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"
                                              ];

   // (@* "CC Names")
   public static StringArray cc_names = [
      "CC#000 (Bank Select MSB)",
      "CC#001 (Modulation MSB)",
      "CC#002 (Breath Control MSB)",
      "CC#003 (-undefined-)",
      "CC#004 (Foot Control MSB)",
      "CC#005 (Portamento Time MSB)",
      "CC#006 (Data Entry MSB)",
      "CC#007 (Main Volume MSB)",
      "CC#008 (Balance MSB)",
      "CC#009 (-undefined-)",
      "CC#010 (Panorama MSB)",
      "CC#011 (Expression MSB)",
      "CC#012 (Effect Control 1 MSB)",
      "CC#013 (Effect Control 2 MSB)",
      "CC#014 (-undefined- MSB)",
      "CC#015 (-undefined-)",
      "CC#016 (General Purpose #1 MSB)",
      "CC#017 (General Purpose #2 MSB)",
      "CC#018 (General Purpose #3 MSB)",
      "CC#019 (General Purpose #4 MSB)",
      "CC#020 (-undefined- #020 MSB)",
      "CC#021 (-undefined- #021 MSB)",
      "CC#022 (-undefined- #022 MSB)",
      "CC#023 (-undefined- #023 MSB)",
      "CC#024 (-undefined- #024 MSB)",
      "CC#025 (-undefined- #025 MSB)",
      "CC#026 (-undefined- #026 MSB)",
      "CC#027 (-undefined- #027 MSB)",
      "CC#028 (-undefined- #028 MSB)",
      "CC#029 (-undefined- #029 MSB)",
      "CC#030 (-undefined- #030 MSB)",
      "CC#031 (-undefined- #031 MSB)",
      "CC#032 (Bank Select LSB)",
      "CC#033 (Modulation LSB)",
      "CC#034 (Breath Control LSB)",
      "CC#035 (-undefined-)",
      "CC#036 (Foot Control LSB)",
      "CC#037 (Portamento Time LSB)",
      "CC#038 (Data Entry LSB)",
      "CC#039 (Main Volume LSB)",
      "CC#040 (Balance LSB)",
      "CC#041 (-undefined-)",
      "CC#042 (Panorama LSB)",
      "CC#043 (Expression LSB)",
      "CC#044 (Effect Ctl 1 LSB)",
      "CC#045 (Effect Ctl 2 LSB)",
      "CC#046 (-undefined- #014 LSB)",
      "CC#047 (-undefined- #015 LSB)",
      "CC#048 (General Purpose #1 LSB)",
      "CC#049 (General Purpose #2 LSB)",
      "CC#050 (General Purpose #3 LSB)",
      "CC#051 (General Purpose #4 LSB)",
      "CC#052 (-undefined- #020 LSB)",
      "CC#053 (-undefined- #021 LSB)",
      "CC#054 (-undefined- #022 LSB)",
      "CC#055 (-undefined- #023 LSB)",
      "CC#056 (-undefined- #024 LSB)",
      "CC#057 (-undefined- #025 LSB)",
      "CC#058 (-undefined- #026 LSB)",
      "CC#059 (-undefined- #027 LSB)",
      "CC#060 (-undefined- #028 LSB)",
      "CC#061 (-undefined- #029 LSB)",
      "CC#062 (-undefined- #030 LSB)",
      "CC#063 (-undefined- #031 LSB)",
      "CC#064 (Hold 1 SW)",
      "CC#065 (Portamento SW)",
      "CC#066 (Sostenuto SW)",
      "CC#067 (Soft Pedal SW)",
      "CC#068 (Legato SW)",
      "CC#069 (Hold 2 SW)",
      "CC#070 (Sound Ctl 1: Variation)",
      "CC#071 (Sound Ctl 2: Harmonic Content)",
      "CC#072 (Sound Ctl 3: Release Time)",
      "CC#073 (Sound Ctl 4: Attack time)",
      "CC#074 (Sound Ctl 5: Brightness)",
      "CC#075 (Sound Ctl 6: Decay Time)",
      "CC#076 (Sound Ctl 7: Vibrato Rate)",
      "CC#077 (Sound Ctl 8: Vibrato Depth)",
      "CC#078 (Sound Ctl 9: Vibrato Delay)",
      "CC#079 (Sound Ctl10: generic)",
      "CC#080 (General Purpose #5)",
      "CC#081 (General Purpose #6)",
      "CC#082 (General Purpose #7)",
      "CC#083 (General Purpose #8)",
      "CC#084 (Portamento Control)",
      "CC#085 (-undefined- on/off)",
      "CC#086 (-undefined- on/off)",
      "CC#087 (-undefined- on/off)",
      "CC#088 (HiRes Velocity Prefix LSB)",
      "CC#089 (-undefined- on/off)",
      "CC#090 (-undefined- on/off)",
      "CC#091 (Effect 1 Depth: Reverb Send)",
      "CC#092 (Effect 2 Depth: Tremolo)",
      "CC#093 (Effect 3 Depth: Chorus Send)",
      "CC#094 (Effect 4 Depth: Celeste)",
      "CC#095 (Effect 5 Depth: Phaser)",
      "CC#096 (Data Inc. RPN/NRPN)",
      "CC#097 (Data Dec. RPN/NRPN)",
      "CC#098 (NRPN LSB)",
      "CC#099 (NRPN MSB)",
      "CC#100 (RPN LSB)",
      "CC#101 (RPN MSB)",
      "CC#102 (-undefined-)",
      "CC#103 (-undefined-)",
      "CC#104 (-undefined-)",
      "CC#105 (-undefined-)",
      "CC#106 (-undefined-)",
      "CC#107 (-undefined-)",
      "CC#108 (-undefined-)",
      "CC#109 (-undefined-)",
      "CC#110 (-undefined-)",
      "CC#111 (-undefined-)",
      "CC#112 (-undefined-)",
      "CC#113 (-undefined-)",
      "CC#114 (-undefined-)",
      "CC#115 (-undefined-)",
      "CC#116 (-undefined-)",
      "CC#117 (-undefined-)",
      "CC#118 (-undefined-)",
      "CC#119 (-undefined-)",
      "CC#120 (All Sounds Off)",
      "CC#121 (Controller Reset)",
      "CC#122 (Local Ctl On/Off)",
      "CC#123 (All Notes Off)",
      "CC#124 (Omni Off)",
      "CC#125 (Omni On)",
      "CC#126 (Mono On / Poly Off)",
      "CC#127 (Poly On / Mono Off)"
   ];

   // see MIDIMapEventType::getDefaultShortNameForCtlTagLabel()
   public static StringArray cc_ctltag_shortnames = [
      "CC0 bank",
      "CC1 mw",
      "CC2 bc",
      "CC3",
      "CC4 fc",
      "CC5 ptime",
      "CC6 data",
      "CC7 vol",
      "CC8 bal",
      "CC9",
      "CC10 pan",
      "CC11 ex",
      "CC12 fx1",
      "CC13 fx2",
      "CC14",
      "CC15",
      "CC16 gp1",
      "CC17 gp2",
      "CC18 gp3",
      "CC19 gp4",
      "CC20",
      "CC21",
      "CC22",
      "CC23",
      "CC24",
      "CC25",
      "CC26",
      "CC27",
      "CC28",
      "CC29",
      "CC30",
      "CC31",
      "CC32 bank l",
      "CC33 mw l",
      "CC34 bc l",
      "CC35",
      "CC36 fc l",
      "CC37 ptime l",
      "CC38 data l",
      "CC39 vol l",
      "CC40 bal l",
      "CC41",
      "CC42 pan l",
      "CC43 ex l",
      "CC44 fx1 l",
      "CC45 fx2 l",
      "CC46",
      "CC47",
      "CC48 gp1 l",
      "CC49 gp2 l",
      "CC50 gp3 l",
      "CC51 gp4 l",
      "CC52",
      "CC53",
      "CC54",
      "CC55",
      "CC56",
      "CC57",
      "CC58",
      "CC59",
      "CC60",
      "CC61",
      "CC62",
      "CC63",
      "CC64 sus",
      "CC65 porta",
      "CC66 sos",
      "CC67 soft",
      "CC68 lega",
      "CC69 hold 2",
      "CC70 sc1",
      "CC71 sc2",
      "CC72 sc3",
      "CC73 sc4",
      "CC74 sc5",
      "CC75 sc6",
      "CC76 sc7",
      "CC77 sc8",
      "CC78 sc9",
      "CC79 sc10",
      "CC80 gp5",
      "CC81 gp6",
      "CC82 gp7",
      "CC83 gp8",
      "CC84 porta ctl",
      "CC85",
      "CC86",
      "CC87",
      "CC88 vel l",
      "CC89",
      "CC90",
      "CC91 fx1 d",
      "CC92 fx2 d",
      "CC93 fx3 d",
      "CC94 fx4 d",
      "CC95 fx5 d",
      "CC96 data inc",
      "CC97 data dec",
      "CC98 nrpn lsb",
      "CC99 nrpn msb",
      "CC100 rpn lsb",
      "CC101 rpn msb",
      "CC102",
      "CC103",
      "CC104",
      "CC105",
      "CC106",
      "CC107",
      "CC108",
      "CC109",
      "CC110",
      "CC111",
      "CC112",
      "CC113",
      "CC114",
      "CC115",
      "CC116",
      "CC117",
      "CC118",
      "CC119",
      "CC120 all soff",
      "CC121 ctl rst",
      "CC122 local ctl",
      "CC123 all noff",
      "CC124 omni off",
      "CC125 omni on",
      "CC126 mono",
      "CC127 poly"
   ];

   static STX_MIDIOutDevice *[] out_devices; // STX_MIDIOutDevice instances
   static STX_MIDIInDevice  *[] in_devices;  // STX_MIDIInDevice instances

   static STX_MIDIInDevice *[] joystick_in_devices;  // STX_MIDIInDevice refs

   static STX_MIDIInDevice push_device;

   static StringArray out_device_names;
   static IntArray    out_device_bgcolors; // bg tint, e.g. for ComboBoxes

   static StringArray in_device_names;
   static IntArray    in_device_bgcolors;  // bg tint, e.g. for ComboBoxes

   static STX_MIDIOutDevice *[] out_devices_sorted;  // refs to out_devices[] elements
   static IntArray     out_device_indices_sorted;
   static IntArray     out_device_bgcolors_sorted; // bg tint, e.g. for ComboBoxes
   static StringArray  out_device_names_sorted;

   static STX_MIDIInDevice *[] in_devices_sorted;  // refs to in_devices[] elements
   static IntArray     in_device_indices_sorted;
   static StringArray  in_device_names_sorted;
   static IntArray     in_device_bgcolors_sorted;  // bg tint, e.g. for ComboBoxes

   static StringArray enum_out_device_names;
   static StringArray enum_in_device_names;



   ////static MIDIIn midiin_radias; // TODO: should be placed somewhere better
   // static KorgRadias korg_radias; // TODO: should be placed somewhere better
//    static YamahaAxK yamaha_axk; // TODO: should be placed somewhere better

   static MIDITimer midi_timer;

   static float tick_duration; // length of replay tick in millisec (depends on bpm/ppq)

   static int midi_in_master_idx;

   static MIDIMapEventListener *[] midimapevent_listeners;   // MIDIMapEventListener references
   static MIDISynthProfile     *[] midi_synth_profiles;      // MIDISynthProfile instances
   static MIDISynthProfileData *[] midi_synth_profile_data;  // MIDISynthProfileData instances, indexed by profileId

   static boolean b_update_out_device_names_locked;
   static boolean b_update_out_device_names_queued;

   static boolean b_skip_rebuild_all_ctl_names;

   static boolean b_ctltag;  // true=allow ctltag name substitution (temporarily disabled in CtlTagTM)


   static Init() {
      b_ctltag = true;
   }

   // // static RunRadiasTests() {
   // //    Buffer testBuf;

   // //    //if(true)
   // //    if(false)
   // //    {
   // //       korg_radias.currentProgramDataDumpRequest(testBuf);
   // //       trace "xxx testBuf.offset="+testBuf.offset;
   // //       korg_radias.saveProgramFile("init1.radias_prg", testBuf);
   // //    }

   // //    //if(true)
   // //    if(false)
   // //    {
   // //       korg_radias.currentDrumKitDataDumpRequest(testBuf);
   // //       trace "xxx testBuf.offset="+testBuf.offset;
   // //       korg_radias.saveDrumKitFile("init1.radias_kit", testBuf);
   // //    }
   // // }

   // <debug.png>
   static InitSomePrivateTestCode() {
      // TODO: do not hard code device#0
      // if(STConfig.b_enable_korg_radias)
      // {
      //    if(!korg_radias.init(out_devices[0], in_devices[0],
      //                         //false/*do NOT send init program+drumkit*/
      //                         true/*send init program+drumkit*/
      //                         ))
      //    {
      //       die "[---] failed to initialize Korg Radias.";
      //    }
      // }
      // //RunRadiasTests();
      // //return false;


//       if(b_enable_yamaha_axk)
//       {
//          if(!yamaha_axk.init(out_devices[0+b_enable_korg_radias], in_devices[0+b_enable_korg_radias]))
//          {
//             die "[---] failed to initialize Yamaha AxK.";
//          }
//       }
   }

   // <open.png>
   static OpenMIDITimer() : boolean {
      return midi_timer.open(null/*default*/);
   }

   // <close.png>
   static CloseMIDITimer() {
      Global.Debug2("MIDI::CloseMIDITimer: ENTER");

      midi_timer.close();

      Global.Debug2("MIDI::CloseMIDITimer: LEAVE");
   }

   // <method_enum.png>
   static EnumerateMIDIDevices() {

      if(STConfig.b_enable_midi)
      {
         if(STConfig.b_debug_lofreq)
         {
            // In
            trace "[...] EnumerateMIDIInDevices: found "+MIDIIn.GetNumDevices()+" MIDI devices.";

            Integer io;
            int i = 0;

            enum_in_device_names.free();

            loop(MIDIIn.GetNumDevices())
            {
               io.value = i;
               print "\tMIDI["+io.printf("%2i")+"]: \""+MIDIIn.GetDeviceNameByIdx(i)+"\" ";
               enum_in_device_names.add(MIDIIn.GetDeviceNameByIdx(i));
               i++;
            }


            // Out
            trace "[...] EnumerateMIDIInDevices: found "+MIDIOut.GetNumDevices()+" MIDI devices.";

            enum_out_device_names.free();

            i = 0;
            loop(MIDIOut.GetNumDevices())
            {
               io.value = i;
               print "\tMIDI["+io.printf("%2i")+"]: \""+MIDIOut.GetDeviceNameByIdx(i)+"\" ("+TKS.constantToString(MIDIOut.GetDeviceTypeByIdx(i), "MOD_")+")";
               enum_out_device_names.add(MIDIOut.GetDeviceNameByIdx(i));
               i++;
            }
         }
      }
   }

   // <method_get.png>
   static GetGlobalOutDeviceAlias(local String _name) : String {
      local HashTable ht <= STConfig.midi_out_device_aliases;

      if(ht.exists(_name))
      {
         return ht.get(_name);
      }
      else
      {
         return null;
      }
   }

   // <method_get.png>
   static GetOutDeviceNameByGlobalAlias(String _globalAlias) : String {
      String devName <= null;

      HashTable ht <= STConfig.midi_out_device_aliases;
      String *key;

      foreach key in ht
      {
         if(ht[key] == _globalAlias)
         {
            // Found alias
            return key;
         }
      }

      return null;
   }

   // <method_get.png>
   static GetGlobalInDeviceAlias(local String _name) : String {
      local HashTable ht <= STConfig.midi_in_device_aliases;

      if(ht.exists(_name))
      {
         return ht.get(_name);
      }
      else
      {
         return null;
      }
   }

   // <method_get.png>
   static GetFullMIDIInDeviceName(String _name) : String {
      HashTable ht <= STConfig.midi_in_device_aliases;

      if(ht.exists(_name))
      {
         return ht.get(_name) + "(" + _name +")";
      }
      else
      {
         return deref _name;
      }
   }

   // <method_get.png>
   static GetFullMIDIOutDeviceName(String _name) : String {
      HashTable ht <= STConfig.midi_out_device_aliases;

      if(ht.exists(_name))
      {
         return ht.get(_name) + "(" + _name +")";
      }
      else
      {
         return deref _name;
      }
   }

   // <method_update.png>
   static UpdateMIDIInDeviceAlias(String _devname, String _alias) {
      HashTable ht <= STConfig.midi_in_device_aliases;
      ht.realloc(200);

      if(_alias.isBlank() || (_alias == "-"))
      {
         ht.delete(_devname);
         Global.Debug2("MIDI input device \""+_devname+"\" alias deleted.");
      }
      else
      {
         ht[_devname] = Object(_alias);
         Global.Debug2("MIDI input device \""+_devname+"\" alias changed to \""+_alias+"\".");
      }

      UpdateInDeviceNames();
   }

   // <method_update.png>
   static UpdateMIDIOutDeviceAlias(String _devname, String _alias) {
      HashTable ht <= STConfig.midi_out_device_aliases;
      ht.realloc(200);

      if(_alias.isBlank() || (_alias == "-"))
      {
         ht.delete(_devname);
         Global.Debug2("MIDI output device \""+_devname+"\" alias deleted.");
      }
      else
      {
         ht[_devname] = Object(_alias);
         Global.Debug2("MIDI output device \""+_devname+"\" alias changed to \""+_alias+"\".");
      }

      UpdateOutDeviceNames();
   }

   // <method_get.png>
   static IsMIDIClockEnabled(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_clocks;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      else
      {
         return false;
      }
   }

   // <method_set.png>
   static SetMIDIClockEnabled(String _name, boolean _bEnabled) {
      HashTable ht <= STConfig.midi_device_clocks;
      ht.realloc(200);
      ht[_name] = String(_bEnabled);

      STX_MIDIOutDevice outDev <= GetMIDIOutDeviceByAliasOrName(_name);
      if(null != outDev)
      {
         Global.Debug("MIDI::SetMIDIClockEnabled: name=\""+_name+"\" bEnabled="+_bEnabled);
         outDev.b_clk = _bEnabled;
      }
   }

   // <method_get.png>
   static IsMIDISPPEnabled(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_spp;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      else
      {
         return false;
      }
   }

   // <method_set.png>
   static SetMIDISPPEnabled(String _name, boolean _bEnabled) {
      HashTable ht <= STConfig.midi_device_spp;
      ht.realloc(200);
      ht[_name] = String(_bEnabled);

      STX_MIDIOutDevice outDev <= GetMIDIOutDeviceByAliasOrName(_name);
      if(null != outDev)
      {
         outDev.b_spp = _bEnabled;
      }
   }

   // <method_get.png>
   static IsMIDIEchoEnabled(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_echos;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      else
      {
         return false;
      }
   }

   // <method_set.png>
   static SetMIDIEchoEnabled(String _name, boolean _bEnabled) {
      HashTable ht <= STConfig.midi_device_echos;
      ht.realloc(200);
      ht[_name] = String(_bEnabled);

      ////STX_MIDIInDevice inDev <= GetMIDIInDeviceByDeviceName(_name, false/*bQuiet*/);
      STX_MIDIInDevice inDev <= GetMIDIInDeviceByAliasOrName(_name);
      // trace "xxx SetMIDIEchoEnabled: dev="+#(inDev)+" name=\""+_name+"\" b_echo="+_bEnabled;
      if(null != inDev)
      {
         inDev.b_echo = _bEnabled;
      }
   }

   // <method_get.png>
   static IsMIDIGlobalEnabled(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_globals;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      else
      {
         return false;
      }
   }

   // <method_set.png>
   static SetMIDIGlobalEnabled(String _name, boolean _bEnabled) {
      HashTable ht <= STConfig.midi_device_globals;
      ht.realloc(200);
      ht[_name] = String(_bEnabled);

      // (note) pipeDev is updated in STX_MIDIOutDevice::setEnableGlobal()
   }

   // <method_get.png>
   static IsMIDIMMCRecEnabled(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_mmcrec;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      else
      {
         return false;
      }
   }

   // <method_set.png>
   static SetMIDIMMCRecEnabled(String _name, boolean _bEnabled) {
      Global.Debug("MIDI::SetMIDIMMCRecEnabled: name=\""+_name+"\" bEnabled="+_bEnabled);
      HashTable ht <= STConfig.midi_device_mmcrec;
      ht.realloc(200);
      ht[_name] = String(_bEnabled);

      STX_MIDIOutDevice outDev <= GetMIDIOutDeviceByAliasOrName(_name);
      if(null != outDev)
      {
         Global.Debug("SetMIDIMMCRecEnabled: name=\""+_name+"\" bEnabled="+_bEnabled);
         outDev.b_mmcrec = _bEnabled;
      }
   }

   // <method_get.png>
   static IsMIDIMMCPlayEnabled(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_mmcplay;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      else
      {
         return false;
      }
   }

   // <method_set.png>
   static SetMIDIMMCPlayEnabled(String _name, boolean _bEnabled) {
      Global.Debug("MIDI::SetMIDIMMCPlayEnabled: name=\""+_name+"\" bEnabled="+_bEnabled);
      HashTable ht <= STConfig.midi_device_mmcplay;
      ht.realloc(200);
      ht[_name] = String(_bEnabled);

      STX_MIDIOutDevice outDev <= GetMIDIOutDeviceByAliasOrName(_name);
      if(null != outDev)
      {
         Global.Debug("MIDI::SetMIDIMMCPlayEnabled: name=\""+_name+"\" bEnabled="+_bEnabled);
         outDev.b_mmcplay = _bEnabled;
      }
   }

   // <method_get.png>
   static IsMIDIMTCEnabled(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_mtc;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      else
      {
         return false;
      }
   }

   // <method_set.png>
   static SetMIDIMTCEnabled(String _name, boolean _bEnabled) {
      Global.Debug("MIDI::SetMIDIMTCEnabled: name=\""+_name+"\" bEnabled="+_bEnabled);
      HashTable ht <= STConfig.midi_device_mtc;
      ht.realloc(200);
      ht[_name] = String(_bEnabled);

      STX_MIDIOutDevice outDev <= GetMIDIOutDeviceByAliasOrName(_name);
      if(null != outDev)
      {
         Global.Debug("SetMIDIMTCEnabled: name=\""+_name+"\" bEnabled="+_bEnabled);
         outDev.b_mtc = _bEnabled;
      }
   }

   // <method_get.png>
   static GetNoteOffMode(String _name) : int {
      // also see STX_MIDIOutDevice.NOTE_OFF_MODE_xxx
      HashTable ht <= STConfig.midi_device_noteoffmodes;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      return -1;
   }

   // <method_set.png>
   static SetNoteOffMode(String _name, int _mode) {
      HashTable ht <= STConfig.midi_device_noteoffmodes;
      ht.realloc(200);
      ht[_name] = String(_mode);
   }

   // <method_get.png>
   static GetEnableMIDICache(String _name) : boolean {
      HashTable ht <= STConfig.midi_device_midicache;
      if(ht.exists(_name))
      {
         return int(ht.get(_name));
      }
      return true;
   }

   // <method_set.png>
   static SetEnableMIDICache(String _name, boolean _bEnable) {
      HashTable ht <= STConfig.midi_device_midicache;
      ht.realloc(200);
      ht[_name] = String(_bEnable ? 1 : 0);

      // (note) pipeDev is updated in STX_MIDIOutDevice::setEnableMIDICache()
   }

   // <method_set.png>
   static SetMIDIDeviceProfileId(String _name, byte _midiCh, String _profileId) {
      HashTable ht <= STConfig.midi_device_profile_ids;
      ht.realloc(200);
      StringArray *pids;

      if(!ht.exists(_name))
      {
         pids <= new StringArray;
         pids.alloc(16);
         pids.numElements = 16;
         ht[_name] = deref pids;
      }
      else
      {
         pids <= ht[_name];
      }

      pids[_midiCh] = Object(_profileId);
   }

   // <method_get.png>
   static GetMIDIDeviceProfileId(local String _name, local byte _midiCh) : String {
      local HashTable ht <= STConfig.midi_device_profile_ids;
      local StringArray *pids;

      if(ht.exists(_name))
      {
         pids <= ht[_name];

         String r <= pids.get(_midiCh);

         if(null != r)
         {
            if(r.isBlank())
            {
               return "default";
            }
            else
            {
               return r;
            }
         }
      }

      return null;
   }

   // <method.png>
   protected static RestoreMIDIInFilter(MIDIIn midiin, HashTable cfg, String key) {
      if(cfg.exists(key))
      {
         TKS.evalMethodByName( midiin, key.replace("flt", "setFlt"), { int(cfg.get(key)) }, null );
      }
      else
      {
         trace "[~~~] RestoreMIDIInFilter: dev=\""+midiin.deviceName+"\" cfg is missing key \""+key+"\".";
      }
   }

   // <method.png>
   static FuzzyReplaceInDeviceName(String _devName) : String {
      String *fuzzy;

      foreach fuzzy in STConfig.midi_in_fuzzy_name_match
      {
         if(_devName.startsWith(fuzzy))
         {
            String *fuzzyName;
            foreach fuzzyName in enum_in_device_names
            {
               if(fuzzyName.startsWith(fuzzy))
               {
                  return String(fuzzyName);
               }
            }
         }
      }

      // Not found
      return null;
   }

   // <method.png>
   static FuzzyCompareInDeviceName(String _nameA, String _nameB) : boolean {
      String *fuzzy;

      if(_nameA == _nameB)
      {
         return true;
      }
      else
      {
         foreach fuzzy in STConfig.midi_in_fuzzy_name_match
         {
            if(_nameA.startsWith(fuzzy))
            {
               if(_nameB.startsWith(fuzzy))
               {
                  return true;
               }
            }
         }
      }

      // No match
      return false;
   }

   // <method.png>
   static HandleInDeviceNameReplaced(String _oldName, String _newName) {

      STConfig.midi_in_device_aliases.replaceKey(_oldName, _newName);

      if(STConfig.midi_in_master_name == _oldName)
         STConfig.midi_in_master_name = _newName;

      STConfig.midi_in_filter.replaceKey(_oldName, _newName);
      STConfig.midi_in_out_device_mapping.replaceKey(_oldName, _newName);
      STConfig.midi_device_echos.replaceKey(_oldName, _newName);
   }

   // <method_init.png>
   static InitMIDIInDevice(STX_MIDIInDevice inDev, String deviceName, int deviceIdx) : boolean {
      // Return true if device was openend or false if it is unavailable
      String origDeviceName = deviceName;
      MIDIIn midiin <= new MIDIIn;
      boolean bOpen = midiin.openByName(deviceName);

      if(!bOpen)
      {
         String fuzzyName <= FuzzyReplaceInDeviceName(deviceName);
         if(null != fuzzyName)
         {
            bOpen = midiin.openByName(fuzzyName);

            if(bOpen)
            {
               deviceName = fuzzyName;

               // Update device alias, master name, in_out mapping, input filter, and echo settings
               HandleInDeviceNameReplaced(origDeviceName, deviceName);
            }
         }
      }

      if(!bOpen)
      {
         if(STConfig.b_debug_mididev_unavail)
            trace "[~~~] failed to open MIDI input device #"+deviceIdx+" \""+origDeviceName+"\".";

         inDev.initUnavail(origDeviceName, GetGlobalInDeviceAlias(origDeviceName));
      }
      else
      {
         inDev.init(deref midiin);
         inDev.findOutDeviceAndCache();

         if(FuzzyCompareInDeviceName(deviceName, STConfig.midi_in_master_name))
         {
            STConfig.midi_in_master_name = deviceName;
            midi_in_master_idx = deviceIdx;
            Global.Debug("master MIDI in device set to \""+deviceName+"\" idx="+midi_in_master_idx);
         }

         // Restore filter settings from config file
         if(STConfig.midi_in_filter.exists(deviceName))
         {
            HashTable cfg <= STConfig.midi_in_filter.get(deviceName);
            RestoreMIDIInFilter(midiin, cfg, "fltNoteOff");
            RestoreMIDIInFilter(midiin, cfg, "fltNoteOn");
            RestoreMIDIInFilter(midiin, cfg, "fltPolyPressure");
            RestoreMIDIInFilter(midiin, cfg, "fltCC");
            RestoreMIDIInFilter(midiin, cfg, "fltProgramChange");
            RestoreMIDIInFilter(midiin, cfg, "fltChannelPressure");
            RestoreMIDIInFilter(midiin, cfg, "fltPitchbend");
            RestoreMIDIInFilter(midiin, cfg, "fltSysEx");
            RestoreMIDIInFilter(midiin, cfg, "fltSysComTimeCode");
            RestoreMIDIInFilter(midiin, cfg, "fltSysComSongPosition");
            RestoreMIDIInFilter(midiin, cfg, "fltSysComSongSelect");
            RestoreMIDIInFilter(midiin, cfg, "fltSysComTuneRequest");
            RestoreMIDIInFilter(midiin, cfg, "fltSysRTTimingClock");
            RestoreMIDIInFilter(midiin, cfg, "fltSysRTStart");
            RestoreMIDIInFilter(midiin, cfg, "fltSysRTContinue");
            RestoreMIDIInFilter(midiin, cfg, "fltSysRTStop");
            RestoreMIDIInFilter(midiin, cfg, "fltSysRTActiveSensing");
            RestoreMIDIInFilter(midiin, cfg, "fltSysRTSystemReset");
            RestoreMIDIInFilter(midiin, cfg, "fltRpnSelect");
            RestoreMIDIInFilter(midiin, cfg, "fltNrpnSelect");
            RestoreMIDIInFilter(midiin, cfg, "fltRpn");
            RestoreMIDIInFilter(midiin, cfg, "fltNrpn");
         }
      }

      inDev.b_echo = MIDI.IsMIDIEchoEnabled(inDev.getAliasOrDeviceName());
      inDev.dev_idx = deviceIdx;

      return bOpen;
   }

   // <method_init.png>
   static InitMIDIInDevices() : boolean {

      midi_in_master_idx = -1;

      StringArray deviceNames <= STConfig.midi_in_devicenames;

      // Initialize devices array
      in_devices.alloc(deviceNames.numElements);
      String deviceName;
      int deviceIdx = 0;

      foreach deviceName in deviceNames
      {
         if(!deviceName.isBlank())
         {
            STX_MIDIInDevice inDev <= new STX_MIDIInDevice;
            InitMIDIInDevice(inDev, deviceName, deviceIdx);

            Global.Debug2("InitMIDIInDevice: deviceName=\""+deviceName+"\" deviceIdx="+deviceIdx);

            in_devices[deviceIdx++] = deref inDev;

         } // !blank
      } // foreach

      // <Audio2RPN> device
      STX_VirtualMIDIInDevice inDevVirt <= new STX_VirtualMIDIInDevice;
      inDevVirt.initVirtual(STX_VirtualMIDIInDevice.AUDIO2RPN_NAME, deviceIdx);
      in_devices.add(#(deref inDevVirt));
      SysEx.audio2rpn_in_dev <= inDevVirt;
      inDevVirt.findOutDeviceAndCache();
      deviceIdx++;
      SetMIDIEchoEnabled(STX_VirtualMIDIInDevice.AUDIO2RPN_NAME, true);

      in_devices.numElements = deviceIdx;

      trace "[...] initialized "+deviceIdx+" MIDI input devices.";

      InitJoystickMIDIInDevices();

      return true;
   }

   // <method_init.png>
   static InitJoystickMIDIInDevices() {
      if(STConfig.b_midi_in_joysticks)
      {
         Global.Debug("InitJoystickMIDIInDevices: found "+SDL.numJoysticks+" joystick(s)");

         int deviceIdx = in_devices.numElements;
         int joyIdx = 0;
         loop(SDL.numJoysticks)
         {
            STX_JoystickMIDIInDevice inDev <= new STX_JoystickMIDIInDevice;
            Joystick js <= SDL.getJoystick(joyIdx);
            Global.Debug2("InitMIDIInDevice<Joystick>: deviceName=\""+js.name+"\" axes="+js.numAxes+" balls="+js.numBalls+" buttons="+js.numButtons+" hats="+js.numHats);
            inDev.initJoystick(js.name, deviceIdx, joyIdx, js);
            in_devices.add(#(deref inDev));
            joystick_in_devices.add(inDev);
            deviceIdx++;
            joyIdx++;
         }
      }

   }

   // <method_update.png>
   static UpdateMIDIInEnableParam() {
      // Configure (N)RPN parser for each input device and channel

      STX_MIDIInDevice *inDev;

      foreach inDev in in_devices
      {
         if(null != inDev.midiin)
         {
            MIDIIn midiin <= inDev.midiin;
            byte midiCh = 0;
            loop(16)
            {
               MIDISynthProfile msp <= inDev.getMIDISynthProfile(midiCh);

               if(null != msp)
               {
                  // // trace "xxx msp="+msp.midi_profile_id+" b_enable_param="+msp.b_enable_param;
                  midiin.setEnableParam(midiCh, msp.b_enable_param);
               }
               else
               {
                  // Always enable parser when no profile has been assigned
                  midiin.setEnableParam(midiCh, true);
               }

               // Next MIDI channel
               midiCh++;
            }
         }

         // Next input device
      }
   }


   // <method_update.png>
   static UpdateMIDIParamMode() {
      // Configure (N)RPN parser for each input device and channel
      byte midiCh;
      MIDISynthProfile *msp;

      STX_MIDIInDevice *inDev;

      foreach inDev in in_devices
      {
         if(null != inDev.midiin)
         {
            MIDIIn midiin <= inDev.midiin;

            midiCh = 0;
            loop(16)
            {
               msp <= inDev.getMIDISynthProfile(midiCh);

               if(null != msp)
               {
                  // // trace "xxx msp="+msp.midi_profile_id+" b_enable_param="+msp.b_enable_param;
                  midiin.setDataEntryMode(midiCh, msp.param_mode);
               }
               else
               {
                  // Always enable parser when no profile has been assigned
                  midiin.setDataEntryMode(midiCh, 0/*DATAENTRYMODE_MSBLSB*/);
               }

               // Next MIDI channel
               midiCh++;
            }
         }

         // Next input device
      }


      STX_MIDIOutDevice *outDev;

      foreach outDev in out_devices
      {
         midiCh = 0;

         boolean bFilterNoteOffChannelPressure = false;

         loop(16)
         {
            msp <= outDev.getMIDISynthProfile(midiCh);

            if(null != msp)
            {
               // // trace "xxx msp="+msp.midi_profile_id+" b_enable_param="+msp.b_enable_param;
               outDev.setParamMode(midiCh, msp.param_mode);
               bFilterNoteOffChannelPressure |= msp.b_filter_note_off_channel_pressure;
               outDev.setEnableRunningStatus(midiCh, msp.b_running_status);
            }
            else
            {
               // Always enable parser when no profile has been assigned
               outDev.setParamMode(midiCh, 0/*DATAENTRYMODE_MSBLSB*/);
            }

            // Next MIDI channel
            midiCh++;
         }

         outDev.setEnableChannelPressureAndNoteOff(!bFilterNoteOffChannelPressure);

         // Next output device
      }
   }

   // <method_update.png>
   static UpdateMIDIOverflowBuffers() {
      byte midiCh = 0;
      MIDISynthProfile *msp;
      STX_MIDIOutDevice *outDev;

      foreach outDev in out_devices
      {
         midiCh = 0;

         loop(16)
         {
            msp <= outDev.getMIDISynthProfile(midiCh);

            if(null != msp)
            {
               // // trace "xxx msp="+msp.midi_profile_id+" b_use_overflow_buffers="+msp.b_use_overflow_buffers;
               outDev.setEnableUseOverflowBuffers(msp.b_use_overflow_buffers);
               break;
            }

            // Next MIDI channel
            midiCh++;
         }

         // Next output device
      }
   }

   // <method_update.png>
   static UpdateMIDICCPerfLSB() {
      // Configure 14bit performance controller CCs for each input device and channel
      byte midiCh;
      MIDISynthProfile *msp;
      STX_MIDIOutDevice *outDev;
      foreach outDev in out_devices
      {
         midiCh = 0;

         loop(16)
         {
            msp <= outDev.getMIDISynthProfile(midiCh);

            if(null != msp)
            {
               // // trace "xxx msp="+msp.midi_profile_id+" b_enable_param="+msp.b_enable_param;
               outDev.setEnableCCPerfLSB(midiCh, msp.b_cc_perf_lsb);
            }
            else
            {
               // Always disable 14bit CC when no profile has been assigned
               outDev.setEnableCCPerfLSB(midiCh, false);
            }

            // Next MIDI channel
            midiCh++;
         }

         // Next output device
      }
   }

   // <method_get.png>
   static GetMIDIInDeviceByIndex(int _idx) : STX_MIDIInDevice {
      return in_devices.get(_idx);
   }

   // <method_get.png>
   static GetMIDIInMasterDevice() : STX_MIDIInDevice {
      // (todo) remove, never called [25Jan2016]
      return in_devices.get(midi_in_master_idx);
   }

   // <method_get.png>
   static GetMIDIInDeviceByDeviceName(String _name, boolean _bQuiet) : STX_MIDIInDevice {
      if(in_devices.numElements > 0)
      {
         STX_MIDIInDevice *ret;
         // MIDIIn *midiin;

         foreach ret in in_devices
         {
            // [25Jan2016]: allow unavail
            if(ret.getDeviceName() == _name)  // checks midiin.deviceName and unavail_name
               return ret;
         }

      }

      if(!_bQuiet && STConfig.b_debug_mididev_unavail)
      {
         SongFile.TraceOnce("[~~~] MIDI::GetMIDIInDeviceByDeviceName: device \""+_name+"\" not found.");
      }
      return null;
   }

   // <method_get.png>
   static GetMIDIInDeviceByAliasOrName(String _name) : STX_MIDIInDevice {

      String devName = _name;

      HashTable ht <= STConfig.midi_in_device_aliases;
      String *key;
      foreach key in ht
      {
         if(ht[key] == _name)
         {
            // Found alias
            devName = key;
            break;
         }
      }

      return GetMIDIInDeviceByDeviceName(devName, false/*bQuiet*/);
   }

   // <method_start.png>
   static StartMIDIInDevices() {
      STX_MIDIInDevice *inDev;
      int deviceIdx = 0;
      foreach inDev in in_devices
      {
         if(null != inDev.midiin)
         {
            Global.Debug2("Starting MIDI in device #"+deviceIdx+" \""+inDev.getDeviceName()+"\".");
            inDev.start();
         }
         deviceIdx++;
      }
   }

   // <method_exit.png>
   static ExitMIDIInDevices() {
      if(STConfig.b_enable_midi)
      {
         Global.Debug2("MIDI::ExitMIDIInDevices: exit MIDI input devices.");
         STX_MIDIInDevice *inDev;
         int deviceIdx = 0;
         foreach inDev in in_devices
         {
            // trace "[...] Closing MIDIIn device #"+deviceIdx;
            if(null != inDev.midiin)
            {
               trace "[...] closing MIDI in device #"+deviceIdx+" \""+inDev.getDeviceName()+"\".";
               inDev.close();
            }
            deviceIdx++;
         }
         Global.Debug2("MIDI::ExitMIDIInDevices: LEAVE.");
      }
   }

   // <method.png>
   static FuzzyReplaceOutDeviceName(String _devName) : String {
      String *fuzzy;

      foreach fuzzy in STConfig.midi_out_fuzzy_name_match
      {
         if(_devName.startsWith(fuzzy))
         {
            String *fuzzyName;
            foreach fuzzyName in enum_out_device_names
            {
               if(fuzzyName.startsWith(fuzzy))
               {
                  return String(fuzzyName);
               }
            }
         }
      }

      // Not found
      return null;
   }

   // <method.png>
   static FuzzyCompareOutDeviceName(String _nameA, String _nameB) : boolean {
      String *fuzzy;

      if(_nameA == _nameB)
      {
         return true;
      }
      else
      {
         foreach fuzzy in STConfig.midi_out_fuzzy_name_match
         {
            if(_nameA.startsWith(fuzzy))
            {
               if(_nameB.startsWith(fuzzy))
               {
                  return true;
               }
            }
         }
      }

      // No match
      return false;
   }

   // <method.png>
   static HandleOutDeviceNameReplaced(String _oldName, String _newName) {

      STConfig.midi_out_device_aliases .replaceKey(_oldName, _newName);
      STConfig.midi_device_clocks      .replaceKey(_oldName, _newName);
      STConfig.midi_device_noteoffmodes.replaceKey(_oldName, _newName);
      STConfig.midi_device_profile_ids .replaceKey(_oldName, _newName);

      FindAutoDevDevices();
   }

   // <method.png>
   static RestoreOutDeviceConfig(STX_MIDIOutDevice outDev) {
      local String aliasOrDeviceName <= outDev.getAliasOrDeviceName();
      outDev.b_clk     = MIDI.IsMIDIClockEnabled(aliasOrDeviceName);
      outDev.b_mmcrec  = MIDI.IsMIDIMMCRecEnabled(aliasOrDeviceName);
      outDev.b_mmcplay = MIDI.IsMIDIMMCPlayEnabled(aliasOrDeviceName);
      outDev.b_mtc     = MIDI.IsMIDIMTCEnabled(aliasOrDeviceName);
      outDev.b_spp     = MIDI.IsMIDISPPEnabled(aliasOrDeviceName);
   }

   // <method_init.png>
   static InitMIDIOutDevice(String deviceName, int deviceIdx, Boolean bInitOK) : STX_MIDIOutDevice {
      // Return true if device was openend or false if it is unavailable
      String origDeviceName = deviceName;

      STX_MIDIOutDevice *outDev;

      MIDIOut midiout <= new MIDIOut;
      // // trace "xxx InitMIDIOutDevice: deviceName="+#(deviceName);
      boolean bOpen = midiout.openByName(deviceName);

      if(!bOpen)
      {
         String fuzzyName <= FuzzyReplaceOutDeviceName(deviceName);

         if(null != fuzzyName)
         {
            bOpen = midiout.openByName(fuzzyName);

            if(bOpen)
            {
               deviceName = fuzzyName;

               // Update device alias, clock and profile settings
               HandleOutDeviceNameReplaced(origDeviceName, deviceName);
            }
         }
      }

      if(!bOpen)
      {
         if(STConfig.b_debug_mididev_unavail)
            trace "[~~~] failed to open MIDI output device #"+deviceIdx+" \""+origDeviceName+"\".";
         // // // return false;

         outDev <= new STX_VirtualMIDIOutDevice;
         outDev.initUnavail(origDeviceName, GetGlobalOutDeviceAlias(origDeviceName));
      }
      else
      {
         trace "[...] OK, opened MIDI out device #"+deviceIdx+" \""+deviceName+"\".";
         outDev <= new STX_MIDIOutDevice;
         outDev.init(deref midiout);

         MIDISynthProfile msp <= outDev.getMIDISynthProfile(0);
         if(null != msp)
            if(msp.num_out_buffers > 0)
               outDev.resizeOutBuffers(msp.num_out_buffers);
      }

      RestoreOutDeviceConfig(outDev);
      outDev.dev_idx   = deviceIdx;

      bInitOK = bOpen;

      return deref outDev;
   }

   // <method_init.png>
   static InitMIDIOutDevices() : boolean {
      String *deviceName;
      int deviceIdx = 0;
      byte midiCh;

      StringArray deviceNames <= STConfig.midi_out_devicenames;

      if(STConfig.b_enable_localmidi)
      {
         StringArray deviceNamesLocal <= STConfig.localmidi_out_devicenames;

         // Initialize devices array
         out_devices.alloc(deviceNamesLocal.numElements + deviceNames.numElements);
         out_devices.useAll();

         foreach deviceName in deviceNamesLocal
         {
            STX_LocalMIDIOutDevice outDevLocal <= new STX_LocalMIDIOutDevice;
            outDevLocal.createLocalMIDI(deviceName);
            outDevLocal.init(new MIDIOut/*dummy instance*/);
            outDevLocal.dev_idx = deviceIdx;
            trace "[...] OK, created LocalMIDI out device #"+deviceIdx+" \""+deviceName+"\".";
            out_devices[deviceIdx++] = deref outDevLocal;
            RestoreOutDeviceConfig(outDevLocal);
         }
      }
      else
      {
         // Initialize devices array
         out_devices.alloc(deviceNames.numElements);
         out_devices.useAll();
      }


      STX_MIDIOutDevice *outDev;

      foreach deviceName in deviceNames
      {
         // trace "xxx InitMIDIOutDevices: deviceName=\""+deviceName+"\"";

         if(!deviceName.isBlank())
         {
            Boolean bInitOK;
            // (note) returns either MIDIOutDevice or VirtualMIDIOutDevice (unavail)
            outDev <= InitMIDIOutDevice(deviceName, deviceIdx, bInitOK);

            out_devices[deviceIdx++] = deref outDev;
         }
      }

      STX_VirtualMIDIOutDevice *outDevVirt;

      // Add scratch device (e.g. for NodeModMatrix)
      outDevVirt <= new STX_VirtualMIDIOutDevice;
      outDevVirt.initVirtualByName(STX_VirtualMIDIOutDevice.SCRATCH_NAME);
      outDevVirt.dev_idx = deviceIdx;
      out_devices[deviceIdx++] = deref outDevVirt;
      midiCh = 0;
      loop(16)
         outDevVirt.setProfileId(midiCh++, "internal");

      // Add "<Pipe>" device (for pipe-local automation)
      outDevVirt <= new STX_VirtualMIDIOutDevice;
      outDevVirt.initVirtualByName(STConfig.pipe_local_auto_devicename);
      outDevVirt.dev_idx = deviceIdx;
      out_devices[deviceIdx++] = deref outDevVirt;
      midiCh = 0;
      loop(16)
         outDevVirt.setProfileId(midiCh++, "internal");

      // Add "<autodev_a>" device
      outDevVirt <= new STX_VirtualMIDIOutDevice;
      outDevVirt.initVirtualByName(STConfig.autodev_a_devicename);
      outDevVirt.dev_idx = deviceIdx;
      out_devices[deviceIdx++] = deref outDevVirt;
      midiCh = 0;
      loop(16)
         outDevVirt.setProfileId(midiCh++, "internal");

      // Add "<autodev_b>" device
      outDevVirt <= new STX_VirtualMIDIOutDevice;
      outDevVirt.initVirtualByName(STConfig.autodev_b_devicename);
      outDevVirt.dev_idx = deviceIdx;
      out_devices[deviceIdx++] = deref outDevVirt;
      midiCh = 0;
      loop(16)
         outDevVirt.setProfileId(midiCh++, "internal");

      // Add "<swing>" device
      outDevVirt <= new STX_VirtualMIDIOutDevice;
      outDevVirt.initVirtualByName(STConfig.autodev_swing_devicename);
      outDevVirt.dev_idx = deviceIdx;
      out_devices[deviceIdx++] = deref outDevVirt;
      midiCh = 0;
      loop(16)
         outDevVirt.setProfileId(midiCh++, "internal");

      // Add "<editfocus>" device
      outDevVirt <= new STX_VirtualMIDIOutDevice;
      outDevVirt.initVirtualByName(STConfig.editfocus_devicename);
      outDevVirt.dev_idx = deviceIdx;
      out_devices[deviceIdx++] = deref outDevVirt;
      midiCh = 0;
      loop(16)
         outDevVirt.setProfileId(midiCh++, "internal");

      // Add internal MIDI buses
      int virtIdx = 1;
      loop(STConfig.midi_num_virtual_out_devices)
      {
         outDevVirt <= new STX_VirtualMIDIOutDevice;
         outDevVirt.initVirtual(virtIdx++);
         outDevVirt.dev_idx = deviceIdx;
         out_devices[deviceIdx++] = deref outDevVirt;
      }

      // Add virtual ModAudio2RPN (from Eureka) device
      outDevVirt <= new STX_VirtualMIDIOutDevice;
      outDevVirt.initVirtualAudio2RPN();
      outDevVirt.dev_idx = deviceIdx;
      midiCh = 0;
      loop(16)
         outDevVirt.setProfileId(midiCh++, "internal");
      out_devices[deviceIdx++] = deref outDevVirt;
      SysEx.audio2rpn_out_dev <= outDevVirt;

      out_devices.numElements = deviceIdx;

      trace "[...] initialized "+deviceIdx+" MIDI output devices.";

      // // FindAutoDevDevices();  // not yet, aliases are not set until project is loaded

      return true;
   }

   // <method.png>
   static AddSysExOutDevice(STX_MIDIOutDevice _outDev) {
      _outDev.dev_idx = out_devices.numElements;

      byte midiCh = 0;
      loop(16)
         _outDev.setProfileId(midiCh++, "remote");

      out_devices.add(_outDev);
   }

   // <method.png>
   static =replay= FindAutoDevDevices() {
      nodeeditor_autodev_a <= GetMIDIOutDeviceByAliasOrName(STConfig.autodev_a_devicename);
      nodeeditor_autodev_b <= GetMIDIOutDeviceByAliasOrName(STConfig.autodev_b_devicename);
      // Global.Debug("nodeeditor_autodev_a="+#(nodeeditor_autodev_a));
      // Global.Debug("nodeeditor_autodev_b="+#(nodeeditor_autodev_b));

      nodeeditor_editfocus_dev <= GetMIDIOutDeviceByAliasOrName(STConfig.editfocus_devicename);

      pagesysex_autodev <= GetMIDIOutDeviceByAliasOrName(STConfig.pagesysex_auto_devicename);
   }

   // <method_add.png>
   static =replay= AddUnavailOutDevice(String _aliasOrDevName) : STX_MIDIOutDevice {

      if(!_aliasOrDevName.isBlank() && !_aliasOrDevName.startsWith("!!empty"))
      {
         if(STConfig.b_debug_mididev_unavail)
            Global.Debug("MIDI.AddUnavailOutDevice("+_aliasOrDevName+")");

         STX_VirtualMIDIOutDevice outDevVirt <= new STX_VirtualMIDIOutDevice;
         outDevVirt.initUnavail(_aliasOrDevName, null/*aliasOrNull*/);
         outDevVirt.dev_idx = out_devices.numElements;
         out_devices.add(#(deref outDevVirt));

         return outDevVirt;
      }
      else
      {
         return null;
      }
   }

   // <method_reset.png>
   static ResetDevs() {
      // Called when song is initialized (e.g. before loading)

      STX_MIDIDevice *dev;

      foreach dev in in_devices
      {
         dev.reset();
      }

      foreach dev in out_devices
      {
         dev.reset();
      }
   }

   // <method.png>
   static SetDefaultVirtualDeviceAliases() {
      STX_VirtualMIDIOutDevice *outDevVirt;

      // <internal_1>..<internal_8> => <play_a>..<play_h>
      int devNr = 1;
      local String *devName;
      loop(8)
      {
         devName <= "<internal_"+devNr+">";

         outDevVirt <= GetMIDIOutDeviceByDeviceName(devName);
         if(null != outDevVirt )
         {
            local String devAlias <= "play_"+tcchar('a'+devNr-1);
            outDevVirt.updateDeviceAlias(devAlias);
            UpdateMIDIOutDeviceAlias(devName, devAlias);
         }
         devNr++;
      }

      // <internal_9> => <swing>
      devName <= "<internal_9>";
      outDevVirt <= GetMIDIOutDeviceByDeviceName(devName);
      if(null != outDevVirt )
      {
         outDevVirt.updateDeviceAlias("swing");
         UpdateMIDIOutDeviceAlias(devName, "swing");
      }

      // <internal_10> => <global>
      devName <= "<internal_10>";
      outDevVirt <= GetMIDIOutDeviceByDeviceName(devName);
      if(null != outDevVirt )
      {
         outDevVirt.updateDeviceAlias("global");
         UpdateMIDIOutDeviceAlias(devName, "global");
         outDevVirt.setEnableGlobal(true);
      }

      // <editfocus> (context sensitive node editor device mapping)
      devName <= "<internal_15>";
      outDevVirt <= GetMIDIOutDeviceByDeviceName(devName);
      if(null != outDevVirt )
      {
         outDevVirt.updateDeviceAlias("editfocus");
         UpdateMIDIOutDeviceAlias(devName, "editfocus");
      }

      // <autodev_a> (context sensitive node editor device mapping)
      devName <= "<internal_15>";
      outDevVirt <= GetMIDIOutDeviceByDeviceName(devName);
      if(null != outDevVirt )
      {
         outDevVirt.updateDeviceAlias("autodev_a");
         UpdateMIDIOutDeviceAlias(devName, "autodev_a");
      }

      // <autodev_b> (context sensitive node editor device mapping)
      devName <= "<internal_16>";
      outDevVirt <= GetMIDIOutDeviceByDeviceName(devName);
      if(null != outDevVirt )
      {
         outDevVirt.updateDeviceAlias("autodev_b");
         UpdateMIDIOutDeviceAlias(devName, "autodev_b");
      }

   }

   // <method_get.png>
   static GetMIDIOutDeviceByDeviceName(String _name) : STX_MIDIOutDevice {
      if(out_devices.numElements > 0)
      {
         STX_MIDIOutDevice *ret;

         foreach ret in out_devices
         {
            if(ret.getDeviceName() == _name)
            {
               return ret;
            }
         }
      }
      if(STConfig.b_debug_mididev_unavail)
         SongFile.TraceOnce("[~~~] MIDI::GetMIDIOutDeviceByDeviceName: device \""+_name+"\" not found.");

      return null;
   }

   // <method.png>
   public static GetMIDIOutAliasOrDeviceNameAndChStringByIndex(int _devIdx, byte _midiCh) : String {
      // used by NodeTracker Monitor import (lazyCreateInstrumentsAndParamsByFrame())
      local String r;

      STX_MIDIOutDevice outDev <= GetMIDIOutDeviceByIndex(_devIdx);
      if(null != outDev)
      {
         r = outDev.getAliasOrDeviceName();
         r.append(":"+(_midiCh+1));
      }
      return deref r;
   }

   // <method_get.png>
   static SortedToUnsortedDevIdx(int _sortedIdx) {
      if(_sortedIdx >= 0)
         return out_device_indices_sorted.get(_sortedIdx);
      return -1; // "*" / all
   }

   // <method_get.png>
   static UnsortedToSortedDevIdx(int _unsortedIdx) {
      if(_unsortedIdx >= 0)
         return out_device_indices_sorted.indexOf(_unsortedIdx, 0);
      return -1; // "*" / all
   }

   // <method_get.png>
   static SortedToUnsortedInDevIdx(int _sortedIdx) {
      if(_sortedIdx >= 0)
         return in_device_indices_sorted.get(_sortedIdx);
      return -1; // "*" / all
   }

   // <method_get.png>
   static UnsortedToSortedInDevIdx(int _unsortedIdx) {
      if(_unsortedIdx >= 0)
         return in_device_indices_sorted.indexOf(_unsortedIdx, 0);
      return -1; // "*" / all
   }

   // <method_get.png>
   static GetMIDIOutDeviceByIndex(int _idx) {
      return out_devices.get(_idx);
   }

   // <method_get.png>
   static GetMIDIOutDeviceByIndexSorted(int _idx) {
      return out_devices_sorted.get(_idx);
   }

   // <method_get.png>
   static GetMIDIOutAliasOrDeviceNameByIndex(int _idx) : String {
      STX_MIDIOutDevice dev <= out_devices.get(_idx);

      if(null != dev)
         return dev.getAliasOrDeviceName();

      return null;
   }

   // <method_get.png>
   static GetMIDIOutAliasOrDeviceNameByIndexSorted(int _idx) : String {
      STX_MIDIOutDevice dev <= out_devices_sorted.get(_idx);

      if(null != dev)
         return dev.getAliasOrDeviceName();

      return null;
   }

   // <method_get.png>
   static GetMIDIOutDeviceByAliasOrName(String _name) : STX_MIDIOutDevice {
      if((null == _name) || _name.isBlank())
         return null;

      STX_MIDIOutDevice *ret;
      foreach ret in out_devices
      {
         if(ret.getAlias() == _name)
            return ret;
      }

      return GetMIDIOutDeviceByDeviceName(_name);
   }

   // <method_get.png>
   static GetMIDIOutDeviceByAliasOrNamePattern(String _pattern) : STX_MIDIOutDevice {

      STX_MIDIOutDevice *ret;
      foreach ret in out_devices
      {
         String alias <= ret.getAlias();
         if(null != alias)
         {
            if(alias.toLower().patternMatch(_pattern))
               return ret;
         }

         String devName <= ret.getDeviceName();
         // trace "xxx GetMIDIOutDeviceByAliasOrNamePattern: pattern=\""+_pattern+"\" devName=\""+devName+"\"";
         if(null != devName)
         {
            if(devName.toLower().patternMatch(_pattern))
               return ret;
         }
      }

      return null;
   }

   // <method_get.png>
   static GetVirtualMIDIOutDeviceByDeviceName(String _name) : STX_VirtualMIDIOutDevice {
      if(out_devices.numElements > 0)
      {
         STX_VirtualMIDIOutDevice *ret;

         foreach ret in out_devices
         {
            if(ret instanceof STX_VirtualMIDIOutDevice)
            {
               if(ret.isOpen()) // filter unvail
               {
                  if(ret.getDeviceName() == _name)
                     return ret;
               }
            }
         }
      }
      SongFile.TraceOnce("[~~~] MIDI::GetVirtualMIDIOutDeviceByDeviceName: device \""+_name+"\" not found.");
      return null;
   }

   // <method_get.png>
   static GetFirstMIDIOutDeviceByProfileId(String _name) : STX_MIDIOutDevice {

      STX_MIDIOutDevice *ret;
      foreach ret in out_devices
      {
         if(null != ret)
         {
            int midiCh = 0;
            loop(16)
            {
               if(ret.getProfileId(midiCh++) == _name)
                  return ret;
            }
         }
      }

      return null;
   }

   // <method_exit.png>
   static ExitMIDIOutDevices() {
      if(STConfig.b_enable_midi)
      {
         STX_MIDIOutDevice outDev;
         int deviceIdx = 0;

         foreach outDev in out_devices
         {
            if(null != outDev.midiout)
            {
               trace "[...] closing MIDI out device #"+deviceIdx+" \""+(outDev.getDeviceName())+"\".";
               outDev.exit();
               outDev.midiout.close();
            }

            deviceIdx++;
         }
         out_devices.free();
         Global.Debug2("MIDI::ExitMIDIOutDevices: LEAVE.");
      }
   }

   // <method_update.png>
   public static UpdateInDeviceNames() {

      in_device_names.empty();
      in_device_bgcolors.empty();

      STX_MIDIDevice *dev;
      local STX_MIDIDevice *[] inDevsAvail;
      local STX_MIDIDevice *[] inDevsUnavail;
      local IntArray inDevIndicesAvail;
      local IntArray inDevIndicesUnavail;
      local StringArray inDevNamesAvail;
      local StringArray inDevNamesUnavail;
      local IntArray inDevColorsAvail;
      local IntArray inDevColorsUnavail;

      int bg32Open     = app_lnf.getColor(AppLookAndFeel.COLOR_DEV_OPEN);
      int bg32Unavail  = app_lnf.getColor(AppLookAndFeel.COLOR_DEV_UNAVAIL);
      int bg32Internal = app_lnf.getColor(AppLookAndFeel.COLOR_DEV_INTERNAL);

      foreach dev in in_devices
      {
         String devName <= dev.getAliasOrDeviceName();
         in_device_names.add(devName);

         int bg32;

         if(dev.isOpen())
         {
            bg32 = bg32Open;
            inDevsAvail.add(dev);
            inDevIndicesAvail.add(dev.dev_idx);
            inDevNamesAvail.add(devName);
            inDevColorsAvail.add(bg32);
         }
         else
         {
            bg32 = bg32Unavail;
            inDevsUnavail.add(dev);
            inDevIndicesUnavail.add(dev.dev_idx);
            inDevNamesUnavail.add(devName);
            inDevColorsUnavail.add(bg32);
         }
         in_device_bgcolors.add(bg32);
      }

      // Sort each category (avail/unavail) separately
      local IntArray ia;

      inDevNamesAvail.sortByValue(ia, false/*bCaseSensitive*/);
      inDevsAvail      .rearrange(ia);
      inDevIndicesAvail.rearrange(ia);
      inDevNamesAvail  .rearrange(ia);
      inDevColorsAvail .rearrange(ia);

      inDevNamesUnavail.sortByValue(ia, false/*bCaseSensitive*/);
      inDevsUnavail      .rearrange(ia);
      inDevIndicesUnavail.rearrange(ia);
      inDevNamesUnavail  .rearrange(ia);
      inDevColorsUnavail .rearrange(ia);

      // Create joint index/name/color arrays
      in_devices_sorted = inDevsAvail;
      in_devices_sorted.joinRR(in_devices_sorted, inDevsUnavail);

      in_device_indices_sorted = inDevIndicesAvail;
      in_device_indices_sorted.join(in_device_indices_sorted, inDevIndicesUnavail);

      in_device_names_sorted = inDevNamesAvail;
      in_device_names_sorted.join(in_device_names_sorted, inDevNamesUnavail);

      in_device_bgcolors_sorted = inDevColorsAvail;
      in_device_bgcolors_sorted.join(in_device_bgcolors_sorted, inDevColorsUnavail);
   }

   // <method.png>
   public static LockUpdateOutDeviceNames() {
      b_update_out_device_names_locked = true;
   }

   // <method.png>
   public static UnlockUpdateOutDeviceNames() {
      b_update_out_device_names_locked = false;
      if(b_update_out_device_names_queued)
      {
         b_update_out_device_names_queued = false;
         UpdateOutDeviceNames();
      }
   }

   // <method.png>
   public static UnlockUpdateOutDeviceNamesAndDiscardQueue() {
      b_update_out_device_names_locked = false;
      b_update_out_device_names_queued = false;
   }

   // <method_update.png>
   public static UpdateOutDeviceNames() {

      if(!b_update_out_device_names_locked)
      {
         if(0)
            Global.Debug("UpdateOutDeviceNames");

         out_device_names.empty();
         out_device_bgcolors.empty();

         STX_MIDIDevice *dev;
         local STX_MIDIDevice *[] outDevsVirt;
         local STX_MIDIDevice *[] outDevsAvail;
         local STX_MIDIDevice *[] outDevsUnavail;
         local IntArray outDevIndicesVirt;
         local IntArray outDevIndicesAvail;
         local IntArray outDevIndicesUnavail;
         local StringArray outDevNamesVirt;
         local StringArray outDevNamesAvail;
         local StringArray outDevNamesUnavail;
         local IntArray outDevColorsVirt;
         local IntArray outDevColorsAvail;
         local IntArray outDevColorsUnavail;

         int bg32Open     = app_lnf.getColor(AppLookAndFeel.COLOR_DEV_OPEN);
         int bg32Unavail  = app_lnf.getColor(AppLookAndFeel.COLOR_DEV_UNAVAIL);
         int bg32Internal = app_lnf.getColor(AppLookAndFeel.COLOR_DEV_INTERNAL);

         foreach dev in out_devices
         {
            String aliasOrDevName <= dev.getAliasOrDeviceName();

            // trace "xxx dev="+#(dev)+" dev.getAliasOrDeviceName()=\""+aliasOrDevName+"\" isOpen="+dev.isOpen();
            out_device_names.add(aliasOrDevName);
            // trace "[trc] MIDI::UpdateOutDeviceNames: out_device_names="+#(out_device_names);
            int bg32 = 0;

            if(dev.isOpen())
            {
               if(dev.isInternal())
               {
                  bg32 = bg32Internal;
                  outDevsVirt.add(dev);
                  outDevIndicesVirt.add(dev.dev_idx);
                  outDevNamesVirt.add(aliasOrDevName);
                  outDevColorsVirt.add(bg32);
               }
               else
               {
                  outDevsAvail.add(dev);
                  outDevIndicesAvail.add(dev.dev_idx);
                  outDevNamesAvail.add(aliasOrDevName);
                  outDevColorsAvail.add(bg32Open);
               }
            }
            else
            {
               bg32 = bg32Unavail;
               outDevsUnavail.add(dev);
               outDevNamesUnavail.add(aliasOrDevName);
               outDevIndicesUnavail.add(dev.dev_idx);
               outDevColorsUnavail.add(bg32);
            }

            // trace "xxx out name="+aliasOrDevName+" bg32="+bg32;

            out_device_bgcolors.add(bg32);
         }

         // Sort each category (virt/avail/unavail) separately
         local IntArray ia;

         outDevNamesVirt.sortByValue(ia, false/*bCaseSensitive*/);
         outDevsVirt      .rearrange(ia);
         outDevIndicesVirt.rearrange(ia);
         outDevNamesVirt  .rearrange(ia);
         outDevColorsVirt .rearrange(ia);

         outDevNamesAvail.sortByValue(ia, false/*bCaseSensitive*/);
         outDevsAvail      .rearrange(ia);
         outDevIndicesAvail.rearrange(ia);
         outDevNamesAvail  .rearrange(ia);
         outDevColorsAvail .rearrange(ia);

         outDevNamesUnavail.sortByValue(ia, false/*bCaseSensitive*/);
         outDevsUnavail.rearrange(ia);
         outDevIndicesUnavail.rearrange(ia);
         outDevNamesUnavail.rearrange(ia);
         outDevColorsUnavail.rearrange(ia);

         // Create joint index/name/color arrays
         out_devices_sorted = outDevsVirt;
         out_devices_sorted.joinRR(out_devices_sorted, outDevsAvail);
         out_devices_sorted.joinRR(out_devices_sorted, outDevsUnavail);

         out_device_indices_sorted = outDevIndicesVirt;
         out_device_indices_sorted.join(out_device_indices_sorted, outDevIndicesAvail);
         out_device_indices_sorted.join(out_device_indices_sorted, outDevIndicesUnavail);

         out_device_names_sorted = outDevNamesVirt;
         out_device_names_sorted.join(out_device_names_sorted, outDevNamesAvail);
         out_device_names_sorted.join(out_device_names_sorted, outDevNamesUnavail);

         out_device_bgcolors_sorted = outDevColorsVirt;
         out_device_bgcolors_sorted.join(out_device_bgcolors_sorted, outDevColorsAvail);
         out_device_bgcolors_sorted.join(out_device_bgcolors_sorted, outDevColorsUnavail);

         // trace "[trc] MIDI::UpdateOutDeviceNames: out_device_names="+#(out_device_names);
      }
      else
      {
         b_update_out_device_names_queued = true;
      }
   }

   // <method_get.png>
   public static HaveOutDeviceMapping(String _inName) : boolean {
      HashTable ht <= STConfig.midi_in_out_device_mapping;
      return ht.exists(_inName);
   }

   // <method_find.png>
   public static FindOutDeviceIdxForInDevice(String _inName) : int {

      HashTable ht <= STConfig.midi_in_out_device_mapping;

      if(ht.exists(_inName))
      {
         String outName <= ht[_inName];
         return out_device_names.indexOfObject(outName, 0);
      }
      else
      {
         // Not mapped to an out device
         return -1;
      }
   }

   // <method_find.png>
   public static FindOutDeviceForInDevice(String _inName) : STX_MIDIOutDevice {

      STX_MIDIOutDevice *outDev;

      foreach outDev in out_devices
      {
         if(null != outDev)
         {
            if(outDev.getAliasOrDeviceName() == _inName)
               return outDev;
         }
      }

      return null;
   }

   // <method_find.png>
   public static FindInDeviceIdxForOutDeviceName(local String _outName) : int {

      local HashTable ht <= STConfig.midi_in_out_device_mapping;

      local String *inName;
      foreach inName in ht
      {
         if(ht[inName] == _outName)
         {
            return in_device_names.indexOfObject(inName, 0);
         }
      }

      local int inDevIdx = 0;
      local STX_MIDIInDevice *inDev;
      foreach inDev in in_devices
      {
         if(null != inDev)
         {
            // trace "xxx FindInDeviceIdxForOutDevice: inDev.getAliasOrDeviceName()=\""+inDev.getAliasOrDeviceName()+"\"  findOutName=\""+_outName+"\"";
            if(inDev.getAliasOrDeviceName() == _outName)
               return inDevIdx;
         }
         inDevIdx++;
      }

      // Not mapped to an in device
      return -1;
   }

   // <method_find.png>
   public static FindInDeviceForOutDeviceName(String _inName) : STX_MIDIInDevice {
      int idx = FindInDeviceIdxForOutDeviceName(_inName);
      if(-1 != idx)
         return in_devices.get(idx);
      return null;
   }

   // <method_find.png>
   public static FindInDeviceIdxForOutDevice(local String _outName) : int {
      // **deprecated**
      return FindInDeviceIdxForOutDeviceName(deref _outName);
   }

   // <method_find.png>
   public static FindInDeviceForOutDevice(String _inName) : STX_MIDIInDevice {
      // **deprecated**
      return FindInDeviceForOutDeviceName(deref _inName);
   }

   // <midi_mml.png>
   static HandleMIDIMapEventUI(MIDIMapEvent _ev) : boolean {

      // Called from UI thread
      MIDIMapEventListener *listener;
      foreach listener in midimapevent_listeners
      {
         boolean bTryHandle = !b_mmc_force_global || listener.mmlOverrideForceGlobal();

         if(bTryHandle)
         {
            if(listener.mmlHandleEventUI(_ev))
               return true;
         }
      }

      return false;
   }

   // <midi_mml.png>
   static =replay= AddMIDIMapEventListener(MIDIMapEventListener _listener) {
      if(!midimapevent_listeners.containsPointer(_listener))
         midimapevent_listeners.add(_listener);
   }

   // <midi_mml.png>
   static =replay= RemoveMIDIMapEventListener(MIDIMapEventListener _listener) {
      midimapevent_listeners.remove(_listener);
   }

   // <method_parse.png>
   static protected ParseMIDISynthProfile(String _fileName) : boolean {
      String s;

      if(Configuration.debugLevel >= 2)
         Global.Debug2("ParseMIDISynthProfile: fileName=\""+_fileName+"\".");

      if(s.loadLocal(Utils.ToNativePathName(_fileName), true/*stripCR*/))
      {
         local TreeNode root <= s.parseXML();
         if("MIDISynthProfile" == root.name)
         {
            HashTable attr <= root.objectValue;

            if(attr.exists("id"))
            {
               MIDISynthProfile *msp;
               msp <= GetMIDISynthProfileById(attr.get("id"));

               if(null == msp)
               {
                  msp <= new MIDISynthProfile;
                  msp.midi_profile_id = attr.get("id");

                  if(msp.parseProfile(root))
                  {
                     // Add profile
                     midi_synth_profiles.add(#(deref msp));

                     if(STConfig.b_debug_msp_add)
                        Global.Info("added MIDI synth profile id=\""+msp.midi_profile_id+"\" #aliases="+(msp.all_aliases.numElements)+".");

                     // Succeeded
                     return true;
                  }
                  else
                  {
                     trace "[---] failed to parse MIDI synth profile id=\""+msp.midi_profile_id+"\" (file=\""+_fileName+"\")";
                  }
               }
               else
               {
                  trace "[---] MIDI synth profile id=\""+attr.get("id")+"\" already exists (file=\""+_fileName+"\")";
               }
            }
            else
            {
               trace "[---] tag \"MIDISynthProfile\" is missing attribute \"id\" (file=\""+_fileName+"\")";
            }
         }
         else
         {
            trace "[---] missing \"MIDISynthProfileTag\" in file \""+_fileName+"\".";
         }
      }
      else
      {
         trace "[---] failed to read MIDI synth profile from \""+_fileName+"\".";
      }

      // Failed
      return false;
   }

   // <method_init.png>
   static InitMIDISynthProfiles() {
      MIDISynthProfile *msp;

      int tStart = milliSeconds();

      // Default / Generic
      msp <= new MIDISynthProfile;
      msp.initDefault();
      midi_synth_profiles.add(#(deref msp));

      // Scan all profiles in "midi_synth_profiles/" directory
      StringArray mspFilenames <= Utils.ReadDirectory(STConfig.midi_profiles_path);

      local StringArray mspNames;  // for sorting
      if(null != mspFilenames)
      {
         String *mspFilename;
         foreach mspFilename in mspFilenames
         {
            StringArray attr <= mspFilename.splitSpace(true);
            String fileName <= attr.get(1);
            if(fileName.endsWith(".msp"))
            {
               if(ParseMIDISynthProfile(STConfig.midi_profiles_path+"/"+fileName))
               {
                  msp <= midi_synth_profiles.last;
                  mspNames.add(msp.profile_caption);
               }
               else
               {
                  trace "[~~~] InitMIDISynthProfile: ParseMIDISynthProfile(fileName=\""+fileName+"\") failed.";
               }
            }
         }
      }

      // Sort by name
      local IntArray ia;
      mspNames.sortByValue(ia, false/*cs*/);
      midi_synth_profiles.rearrange(ia);

      Global.Profile("InitMIDISynthProfiles() took "+(milliSeconds() - tStart)+"ms");
   }

   // <method_init.png>
   public static LazyInitSynthEditorProjectProfileDataByProfileId(String _profileId) {
      MIDISynthProfileData data <= MIDI.GetMIDISynthProfileData(_profileId);
      if(null != data)
      {
         MIDISynthProfile msp <= MIDI.GetMIDISynthProfileById(_profileId);
         if(null != msp.edit_form)
         {
            if(!msp.b_edit_form_init_done && data.projectMIDIProfileDataRequiresSynthEditorInit())  // e.g. Prophet12
            {
               msp.lazyInitSynthEditorEditForm();
               data.reload(false/*bFromUI*/);
            }
         }
      }
   }

   // <method_init.png>
   public static LazyAccessSynthEditor(String _profileId) : boolean {
      // called when synth editor is actually accessed
      //   - NodeProxy.findCachedSynthForm
      //   - PageSysEx
      Global.Debug("MIDI::LazyAccessSynthEditor: profileId=\""+_profileId+"\"");
      MIDISynthProfile msp <= MIDI.GetMIDISynthProfileById(_profileId);
      if(null != msp)
      {
         // Lazy-load TSL + create profile_data_template / edit_form instance
         if(!msp.lazyPrepareSynthEditor())
         {
            trace "[---] MIDI::LazyAccessSynthEditor: msp.lazyPrepareSynthEditor() failed (profile=\""+_profileId+"\")";
            return false;
         }

         msp.lazyInitSynthEditorEditForm();

         MIDISynthProfileData data <= MIDI.GetMIDISynthProfileData(_profileId);
         if(null == data)
         {
            // Create profile_data instance and reload global patch data
            if(null != msp.profile_data_template)
            {
               data <= msp.lazyInitProfileData();
               if(null == data)
               {
                  trace "[---] MIDI::LazyAccessSynthEditor: msp.lazyInitProfileData() failed (profile=\""+_profileId+"\")";
                  return false;
               }

               midi_synth_profile_data.add(#(deref data));
            }
         }

         if(null != data)
         {
            // Load stashed project-data
            if(!data.tryLoadStashedProjectMIDIProfileData())
            {
               trace "[~~~] MIDI::LazyAccessSynthEditor: data.tryLoadStashedProjectMIDIProfileData() failed (profile=\""+_profileId+"\")";
               return false;
            }
         }

         return true;
      }

      return false;
   }

   // <method_get.png>
   static GetDefaultSynthProfile() : MIDISynthProfile {
      return midi_synth_profiles.get(0); // "default"
   }

   // <method_get.png>
   static GetMIDISynthProfileById(local String _id) : MIDISynthProfile {
      local MIDISynthProfile *msp;

      if(null != _id)
      {
         if(_id.isBlank())
            return GetDefaultSynthProfile();
      }
      else
      {
         return GetDefaultSynthProfile();
      }

      foreach msp in midi_synth_profiles
      {
         if(msp.midi_profile_id == _id)
            return msp;
      }

      return null;
   }

   // <method_get.png>
   static GetMIDISynthProfileCaptionOptionsByInDevIdx(int _devIdx, String _firstOptionOrNull) : StringArray {
      STX_MIDIInDevice *inDev <= in_devices.get(_devIdx);
      if(null != inDev)
      {
         return inDev.getMIDISynthProfileCaptionOptions(_firstOptionOrNull);
      }
      else
      {
         local StringArray ret = midi_ch_names;
         if(null != _firstOptionOrNull)
            ret.insert(0, _firstOptionOrNull);
         return deref ret;
      }
   }

   // <method_get.png>
   static GetMIDISynthProfileCaptionOptionsByOutDevIdx(int _devIdx, String _firstOptionOrNull) : StringArray {
      STX_MIDIOutDevice *outDev <= out_devices.get(_devIdx);
      if(null != outDev)
      {
         return outDev.getMIDISynthProfileCaptionOptions(_firstOptionOrNull);
      }
      else
      {
         local StringArray ret = midi_ch_names;
         if(null != _firstOptionOrNull)
            ret.insert(0, _firstOptionOrNull);
         return deref ret;
      }
   }

   // <method_parse.png>
   static ParseMIDINoteNames(String _pathName) : boolean {
      String buf;
      if(buf.loadLocal(Utils.ToNativePathName(_pathName), true/*bRemoveCR*/))
      {
         StringArray lines <= buf.splitChar('\n');
         String *line;
         String id = "";

         StringArray noteNames <= new StringArray;
         noteNames = note_name_profiles["default"];

         foreach line in lines
         {
            line.trim();
            if(!line.isBlank())
            {
               if(!line.startsWith("#"))
               {
                  if(id.isBlank())
                  {
                     id = line;
                  }
                  else
                  {
                     int idxS = line.indexOfChar('=', 0);
                     if(-1 != idxS)
                     {
                        Integer noteIdx = line.substring(0, idxS);
                        if(0 <= noteIdx <= 127)
                        {
                           noteNames[noteIdx] = noteIdx.printf("%3d:")+line.substring(idxS+1, line.length - idxS - 1);
                        }
                     }
                  }
               }
            }
         }

         if(!id.isBlank())
         {
            if("default" != id)
            {
               note_name_profiles[id] = deref noteNames;
               return true;
            }
            else
            {
               trace "[~~~] midi note name profile id must not be \"default\" (pathName=\""+_pathName+"\")";
            }
         }

      }
      return false;
   }

   // <method_init.png>
   static InitMIDINoteNames() {

      note_name_profiles.alloc(211);

      StringArray noteNames <= new StringArray;
      Integer noteIdx = 0;
      loop(128)
      {
         noteNames.add(noteIdx.printf("%3d")+":"+midi_notes.get(noteIdx));
         noteIdx++;
      }
      note_name_profiles["default"] = deref noteNames;

      // Scan all note name profiles in "midi_note_names/" directory
      StringArray mnnFilenames <= Utils.ReadDirectory(STConfig.midi_note_names_path);
      if(null != mnnFilenames)
      {
         String *mnnFilename;
         foreach mnnFilename in mnnFilenames
         {
            StringArray attr <= mnnFilename.splitSpace(true);
            String fileName <= attr.get(1);
            if(fileName.endsWith(".mnn"))
            {
               if(!ParseMIDINoteNames(STConfig.midi_note_names_path+"/"+fileName))
               {
                  die "[---] InitMIDINoteNames: ParseMIDINoteNames(fileName=\""+fileName+"\") failed.";
               }
            }
         }
      }
   }

   // <method_get.png>
   static GetMIDINoteNamesByProfileId(String _profileId) : StringArray {
      return note_name_profiles.get(_profileId);
   }

   // <method_get.png>
   static GetMIDISynthProfileData(String _profileId) : MIDISynthProfileData {
      MIDISynthProfileData *data;
      foreach data in midi_synth_profile_data
      {
         // // trace "xxx GetMIDISynthProfileData: data.midi_profile.midi_profile_id="+data.midi_profile.midi_profile_id;
         if((data.midi_profile.midi_profile_id) == _profileId)
            return data;
      }
      return null;
   }

   // <method_stop.png>
   static StopMIDITimer() {
      if(STConfig.b_enable_midi)
      {
         midi_timer.stop();
         Global.Debug("Global.StopMIDITimer: stopped");
      }
   }

   // <method_start.png>
   static =replay= StartMIDITimer() {
      float ival = Utils.BPMPPQToMS(current_song.bpm, current_song.ppq); // millisec

      tick_duration = ival;

      Global.Debug("MIDI::StartMIDITimer: ival="+ival+" ms");

      if(STConfig.b_enable_midi)
      {
         if(!midi_timer.setMutexOverrideByName("replay"))
         {
            die "[---] failed to override MIDI timer mutex.";
         }
      }

      if(!Global.b_initializing)
      {
         if(STConfig.b_enable_midi)
         {
            Global.Debug("MIDI::StartMIDITimer: call midi_timer.start()");
            midi_timer.start(1, ival, onMIDITimer);
         }
      }
   }

   // <method_update.png>
   static UpdateMIDITimer() : boolean {
      // Called by replay to dynamically update replay speed (CTL_BPM)
      float ival = Utils.BPMPPQToMS(current_song.bpm * current_song.bpm_mul, current_song.ppq); // millisec
      tick_duration = ival;
      // // Global.Debug3("MIDI::UpdateMIDITimer: ival="+ival+" ms");
      if(STConfig.b_enable_midi)
      {
         if(!Global.b_initializing)
         {
            midi_timer.update(ival);
         }
      }
   }

   // <method_start.png>
   static RestartMIDITimer() : boolean {
      StopMIDITimer();
      StartMIDITimer();
   }

   // <method_update.png>
   static UpdateMIDIPipeRoot(MIDIPipeRoot _pipeRoot) {
      _pipeRoot.freeDevices();
      _pipeRoot.allocDeviceSlots(out_devices.numElements);

      // Create pipe devs and assign/link output buffers
      STX_MIDIOutDevice *outDev;
      int devIdx = 0;
      foreach outDev in out_devices
      {
         if(null != outDev)
         {
            if(outDev.isOpen())
            {
               MIDIPipeDevice pipeDev <= _pipeRoot.allocDevice(devIdx);

               pipeDev.setBuffers(outDev.cmd_buffer, outDev.note_buffer);
            }
         }

         devIdx++;
      }

      UpdateMIDIPipeDevFlags(_pipeRoot);
   }

   // <method_update.png>
   static UpdateMIDIPipeDevFlags(MIDIPipeRoot _pipeRoot) {
      // Create pipe devs and assign/link output buffers
      STX_MIDIOutDevice *outDev;
      int devIdx = 0;
      foreach outDev in out_devices
      {
         if(null != outDev)
         {
            if(outDev.isOpen())
            {
               MIDIPipeDevice pipeDev <= _pipeRoot.getDeviceByIdx(devIdx);

               pipeDev.setEnableMIDICache(outDev.getEnableMIDICache());
               pipeDev.setEnableGlobal(outDev.getEnableGlobal());
               pipeDev.setEnableVirtual(outDev instanceof STX_VirtualMIDIOutDevice);

               byte midiCh = 0;
               loop(16)
               {
                  pipeDev.setParamMode(midiCh, outDev.getParamMode(midiCh));
                  midiCh++;
               }
               // trace "xxx setEnableGlobal(dev="+outDev.getAliasOrDeviceName()+" enable="+outDev.getEnableGlobal();
            }
         }

         devIdx++;
      }
   }

   // <method_get.png>
   static MIDIPipeEvent_GetArg1String(MIDIPipeEvent ev, STX_MIDIDevice dev) : String {
      Integer io;

      switch(ev.type)
      {
         case MIDIPIPE_EVENT_TYPE_NONE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PRGCHG:
            return dev.getPrgShortNameByNr(ev.midiCh, ev.prgChg);

         case MIDIPIPE_EVENT_TYPE_CHPRESSURE:
            return ev.chPressure;

         case MIDIPIPE_EVENT_TYPE_PITCHBEND:
            io = ev.pitchbend;
            return io.printf("$%04x");

         case MIDIPIPE_EVENT_TYPE_CC:
            return dev.getCCShortNameByCtl(ev.midiCh, ev.ccId);

         case MIDIPIPE_EVENT_TYPE_RPN:
            return dev.getRPNShortNameByNr(ev.midiCh, ev.rpn);

         case MIDIPIPE_EVENT_TYPE_NRPN:
            return dev.getNRPNShortNameByNr(ev.midiCh, ev.nrpn);

         case MIDIPIPE_EVENT_TYPE_NOTE_OFF:
            return midi_notes.get(ev.note);

         case MIDIPIPE_EVENT_TYPE_NOTE_ON:
            return midi_notes.get(ev.note);
      }
   }

   // <method_get.png>
   static MIDIPipeEvent_GetArg2String(MIDIPipeEvent ev, STX_MIDIDevice dev) : String {
      switch(ev.type)
      {
         case MIDIPIPE_EVENT_TYPE_NONE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PRGCHG:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CHPRESSURE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PITCHBEND:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CC:
            return ev.ccValue;

         case MIDIPIPE_EVENT_TYPE_RPN:
            return ev.rpnValue;

         case MIDIPIPE_EVENT_TYPE_NRPN:
            return ev.nrpnValue;

         case MIDIPIPE_EVENT_TYPE_NOTE_OFF:
            return ev.velocity;

         case MIDIPIPE_EVENT_TYPE_NOTE_ON:
            return ev.velocity;
      }
   }

   // <method_get.png>
   static MIDIPipeEvent_GetArg3String(MIDIPipeEvent ev, STX_MIDIDevice dev) : String {
      switch(ev.type)
      {
         case MIDIPIPE_EVENT_TYPE_NONE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PRGCHG:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CHPRESSURE:
            return "-";

         case MIDIPIPE_EVENT_TYPE_PITCHBEND:
            return "-";

         case MIDIPIPE_EVENT_TYPE_CC:
            return "-";

         case MIDIPIPE_EVENT_TYPE_RPN:
            return "-";

         case MIDIPIPE_EVENT_TYPE_NRPN:
            return "-";

         case MIDIPIPE_EVENT_TYPE_NOTE_OFF:
            return ev.duration;

         case MIDIPIPE_EVENT_TYPE_NOTE_ON:
            return ev.duration;
      }
   }

   // <method_build.png>
   static SongFileReader_BuildOutDevIdxMap(StringArray _devNames, IntArray _outDevIdxMap) {
      // (note) devNames as seen when song was saved

      // trace "[trc] SongFileReader_BuildOutDevIdxMap: _devNames="+#(_devNames);
      SongFile.TraceOnceBegin();

      _outDevIdxMap.alloc(_devNames.numElements);

      String *devName;
      foreach devName in _devNames
      {
         STX_MIDIOutDevice outDev <= GetMIDIOutDeviceByAliasOrName(devName);
         int newDevIdx;

         if(null != outDev)
         {
            newDevIdx = outDev.dev_idx;

            _outDevIdxMap.add(newDevIdx);

            SongFile.Debug3Once("ok, songfile device \""+devName+"\" mapped to new dev_idx="+newDevIdx);
         }
         else
         {
            // (note) error messages are now printed after loading all pipes/nodes, i.e. when
            //         the use counts of the devices are known

            if(SongFileReader.EMPTY_DEV_NAME != devName)
            {
               outDev <= AddUnavailOutDevice(devName);

               if(null != outDev)
               {
                  newDevIdx = outDev.dev_idx;
               }
               else
               {
                  newDevIdx = -1; // Discard [26Jan2016] (empty device name or "!!empty")
               }

               _outDevIdxMap.add(newDevIdx);

               if(STConfig.b_debug_mididev_unavail)
                  trace "[~~~] unavail songfile device \""+devName+"\" mapped to virtual dev_idx="+newDevIdx;
            }
            else
            {
               trace "[~~~] unused songfile device \""+devName+"\" mapped to virtual dev_idx=-1";
               _outDevIdxMap.add(-1);
            }
         }
      } // foreach devName

      UpdateOutDeviceNames(); // show unavail devices

      SongFile.TraceOnceEnd();
   }

   // <ui_update.png>
   public static UpdateCtlTagEntryDOs() {
      // Update display object fields for ctl tag entries
      CtlTagEntry *entry;
      b_ctltag = false;
      foreach entry in current_song.ctltag_entries
      {
         MIDIMapEvent ev <= entry.mm_event;
         entry.do_dev  = ev.getAliasOrDeviceNameForDO();
         entry.do_ch   = ev.dev_ch + 1;
         entry.do_type = ev.getFullTypeName();
      }
      b_ctltag = true;
   }

   // <method_get.png>
   public static HaveCtlTagForDevChType(STX_MIDIOutDevice _dev, byte _fltCh, int _fltType) : boolean {
      CtlTagEntry *entry;
      foreach entry in current_song.ctltag_entries
      {
         MIDIMapEvent ev <= entry.mm_event;

         if(-1 == _fltType || _fltType == ev.type)
         {
            if(-1 == _fltCh || ev.dev_ch == _fltCh)
            {
               if(@(ev.dev) == @(_dev))
               {
                  return true;
               }
            }
         }
      }
      return false;
   }

   // <method_get.png>
   public static GetCtlTagByType(STX_MIDIOutDevice _dev, byte _midiCh, int _nr, int _type, boolean _bNameOnly) : String {
      CtlTagEntry *entry;
      foreach entry in current_song.ctltag_entries
      {
         MIDIMapEvent ev <= entry.mm_event;

         if(_type == ev.type)
         {
            if(ev.dev_ch == _midiCh)
            {
               if(@(ev.dev) == @(_dev))
               {
                  if(ev.ext_type == _nr)
                  {
                     switch(_type)
                     {
                        case MIDIMapEventType.TYPE_CC:
                           if(_bNameOnly)
                              return entry.tag_name;
                           else
                              return "CC#"+_nr+" ("+entry.tag_name+")";

                        case MIDIMapEventType.TYPE_RPN:
                           if(_bNameOnly)
                              return entry.tag_name;
                           else
                              return "RPN#"+_nr+" ("+entry.tag_name+")";

                        case MIDIMapEventType.TYPE_NRPN:
                           if(_bNameOnly)
                              return entry.tag_name;
                           else
                              return "NRPN#"+_nr+" ("+entry.tag_name+")";
                     }
                     break; // should not be reachable. illegal type?!
                  }
               }
            }
         }
      }

      return null;
   }

   // <method_get.png>
   public static GetCtlTagCC(STX_MIDIOutDevice _dev, byte _midiCh, int _nr, boolean _bNameOnly) : String {
      return GetCtlTagByType(_dev, _midiCh, _nr, MIDIMapEventType.TYPE_CC, _bNameOnly);
   }

   // <method_get.png>
   public static GetCtlTagRPN(STX_MIDIOutDevice _dev, byte _midiCh, int _nr, boolean _bNameOnly) : String {
      return GetCtlTagByType(_dev, _midiCh, _nr, MIDIMapEventType.TYPE_RPN, _bNameOnly);
   }

   // <method_get.png>
   public static GetCtlTagNRPN(STX_MIDIOutDevice _dev, byte _midiCh, int _nr, boolean _bNameOnly) : String {
      return GetCtlTagByType(_dev, _midiCh, _nr, MIDIMapEventType.TYPE_NRPN, _bNameOnly);
   }

   // <method_get.png>
   public static GetCtlTagByTypeAndNamePattern(STX_MIDIOutDevice _dev, byte _midiCh, int _type, String _pattern) : int {
      // Try exact name match
      CtlTagEntry *entry;
      MIDIMapEvent *ev;
      foreach entry in current_song.ctltag_entries
      {
         ev <= entry.mm_event;

         if(_type == ev.type)
         {
            if(ev.dev_ch == _midiCh)
            {
               if(@(ev.dev) == @(_dev))
               {
                  switch(_type)
                  {
                     case MIDIMapEventType.TYPE_CC:
                        if(("CC#"+ev.ext_type+" ("+entry.tag_name+")").toLower().patternMatch(_pattern))
                        {
                           return ev.ext_type;
                        }
                        return;

                     case MIDIMapEventType.TYPE_RPN:
                        if(("RPN#"+ev.ext_type+" ("+entry.tag_name+")").toLower().patternMatch(_pattern))
                        {
                           return ev.ext_type;
                        }
                        return;

                     case MIDIMapEventType.TYPE_NRPN:
                        if(("NRPN#"+ev.ext_type+" ("+entry.tag_name+")").toLower().patternMatch(_pattern))
                        {
                           return ev.ext_type;
                        }
                        return;
                  }
               }
            }
         }
      }

      return -1;
   }

   // <method_get.png>
   public static RebuildInputCtlNames() {

      int t = milliSeconds();
      Global.Profile("MIDI.RebuildInputCtlNames: begin");

      STX_MIDIDevice *dev;
      foreach dev in in_devices
      {
         if(null != dev)
            dev.buildCtlNames();
      }

      Global.Profile("MIDI.RebuildInputCtlNames: end, dt="+(milliSeconds()-t));
   }

   // <method_get.png>
   public static RebuildOutputCtlNames() {

      int t = milliSeconds();
      Global.Profile("MIDI.RebuildOutputCtlNames: begin");

      STX_MIDIDevice *dev;
      foreach dev in out_devices
      {
         if(null != dev)
            dev.buildCtlNames();
      }

      Global.Profile("MIDI.RebuildOutputCtlNames: end, dt="+(milliSeconds()-t));
   }

   // <method_get.png>
   public static RebuildAllCtlNames() {
      if(!b_skip_rebuild_all_ctl_names)
      {
         RebuildInputCtlNames();
         RebuildOutputCtlNames();
      }
   }

   // <method.png>
   public static AppendCtlTagSubMenu(PopupMenu _pm, String _submenuCaption) {
      PopupMenuButton *pmb;
      PopupMenu *spm;

      _pm.addSeparator();
      spm <= PopupMenu.New(_pm);
      pmb <= _pm.addMenu(_submenuCaption, deref spm);

      CtlTagEntry *en;
      int enIdx = 0;
      foreach en in current_song.ctltag_entries
      {
         MIDIMapEvent ev <= en.mm_event;
         STX_MIDIOutDevice dev <= ev.dev;
         if(dev instanceof STX_MIDIOutDevice) // should not be false
         {
            pmb <= spm.addDefaultButton(en.tag_name,
                                        "ctltagentry_"+enIdx
                                        );
            pmb.setAccelerators(null, dev.getAliasOrDeviceName()+":"+(ev.dev_ch+1));
         }
         enIdx++;
      }
   }

   // <method.png>
   public static AppendOutDevSubMenu(PopupMenu _pmParent, boolean _bSeparator, String _submenuCaption, String _captionPrefix, String _actionPrefix) {
      PopupMenu *pm;
      PopupMenu *spm;
      PopupMenuButton *pmb;

      String sIcon_adds <= UI.PreferMonoIcons() ? "adds_mono" : "adds";

      if(_bSeparator)
         _pmParent.addSeparator();

      if(null != _submenuCaption)
      {
         pm <= PopupMenu.New(_pmParent);
         pmb <= _pmParent.addIconMenu(_submenuCaption, sIcon_adds, deref pm);
      }
      else
      {
         pm <= _pmParent;
      }

      STX_MIDIOutDevice *outDev;
      foreach outDev in MIDI.out_devices_sorted
      {
         if!(outDev instanceof STX_VirtualMIDIOutDevice)
         {
            MIDISynthProfile *msp;
            boolean bAllowDefault = true;
            boolean bIsDefault;
            byte midiCh = 0;
            int numPorts = 0;
            loop(16)
            {
               msp <= outDev.getMIDISynthProfile(midiCh);
               bIsDefault = @(msp) == @(MIDI.GetDefaultSynthProfile());
               if(null != msp && (bAllowDefault || !bIsDefault))
               {
                  if(!bIsDefault)
                     bAllowDefault = false;
                  numPorts++;
               }
               midiCh++;
            }

            if(numPorts > 0)
            {
               if(numPorts > 1)
               {
                  spm <= PopupMenu.New(pm);
                  pmb <= pm.addMenu(_captionPrefix/*"New: "*/+outDev.getAliasOrDeviceName()+"..", deref spm);
               }
               else
                  spm <= pm;

               bAllowDefault = true;
               midiCh = 0;
               loop(16)
               {
                  msp <= outDev.getMIDISynthProfile(midiCh);
                  if(null != msp)// && @(msp) != @(MIDI.GetDefaultSynthProfile()))
                  {
                     bIsDefault = @(msp) == @(MIDI.GetDefaultSynthProfile());
                     if(null != msp && (bAllowDefault || !bIsDefault))
                     {
                        if(!bIsDefault)
                           bAllowDefault = false;
                        pmb <= spm.addDefaultButton(_captionPrefix/*"New: "*/+outDev.getAliasOrDeviceName()+":"+(midiCh+1),
                                                    _actionPrefix/*"new_"*/+outDev.dev_idx+"_"+midiCh
                                                    );
                        pmb.setAccelerators(null, msp.profile_caption);
                     }
                  }
                  midiCh++;
               }
            }
         }
      }
   }

   // <method.png>
   public static AppendCtlClipboardMenuItems(PopupMenu _pm, boolean _bActiveCopy, boolean _bActivePaste) {
      PopupMenuButton *pmb;

      pmb <= _pm.addDefaultButton("Copy to Ctl.Clipboard A", "copyctl_a");
      pmb.setToolTipCaption("Copy port+type to Ctl.Clipboard A");
      pmb.setActive(_bActiveCopy);

      pmb <= _pm.addDefaultButton("Copy to Ctl.Clipboard B", "copyctl_b");
      pmb.setToolTipCaption("Copy port+type to Ctl.Clipboard B");
      pmb.setActive(_bActiveCopy);

      _pm.addSeparator();

      local String info <= mmarg_clipboard_a.getStringForClipboardMenu();
      info <= info.isBlank()?"":(" ("+info+")");
      pmb <= _pm.addDefaultButton("Paste from Ctl.Clipboard A"+info, "pastectl_a");
      pmb.setToolTipCaption("Paste port+type from Ctl.Clipboard A");
      pmb.setActive(_bActivePaste && mmarg_clipboard_a.isValidClipboardArg());

      info <= mmarg_clipboard_b.getStringForClipboardMenu();
      info <= info.isBlank()?"":(" ("+info+")");
      pmb <= _pm.addDefaultButton("Paste from Ctl.Clipboard B"+info, "pastectl_b");
      pmb.setToolTipCaption("Paste port+type from Ctl.Clipboard B");
      pmb.setActive(_bActivePaste && mmarg_clipboard_b.isValidClipboardArg());
   }

   // <method.png>
   public static AppendNodeRemoteCtlMenuItems(PopupMenu _pm, String _actionPrefix) {
      int pipeIdx = 0;
      PopupMenu *spmNode;
      PopupMenuButton *pmb;
      STX_MIDIOutDevice *autoDev;
      loop(current_song.pipe_root.numPipes)
      {
         MIDIPipe pipe <= current_song.pipe_root.getPipeByUsedIdx(pipeIdx);

         int nodeIdx = 0;
         loop(pipe.numNodes)
         {
            MIDIPipeNodeScriptProxy n <= pipe.getNodeByIdx(nodeIdx);

            if(n instanceof MIDIPipeNodeScriptProxy)
            {
               Node sn <= n.sci;

               Integer ioPipe = ((n.parent.pipeIdx) + 1);
               Integer ioNode = (n.nodeIdx + 1);

               if(sn.b_auto_filter_a)
               {
                  if(sn.auto_dev_filter_a >= 0)
                  {
                     if(sn.auto_ch_filter_a >= 0)
                     {
                        autoDev <= MIDI.GetMIDIOutDeviceByIndex(sn.auto_dev_filter_a);
                        if(null != autoDev)
                        {
                           spmNode <= PopupMenu.New(_pm);
                           pmb <= _pm.addMenu(ioPipe.printf("%02d")+":"+ioNode.printf("%02d")+": "+autoDev.getAliasOrDeviceName()+":"+(sn.auto_ch_filter_a+1)+": "+sn.nodeGetName(), deref spmNode);
                           sn.nodeAddSupportedRPNsToPopupMenu(spmNode, _actionPrefix+"rpn_"+sn.auto_dev_filter_a+"_"+sn.auto_ch_filter_a+"_", sn.nodeGetSupportedRPNSubMenus());
                        }
                     }
                  }
               }

               if(sn.b_auto_filter_b)
               {
                  if(sn.auto_dev_filter_b >= 0)
                  {
                     if(sn.auto_ch_filter_b >= 0)
                     {
                        autoDev <= MIDI.GetMIDIOutDeviceByIndex(sn.auto_dev_filter_b);
                        if(null != autoDev)
                        {
                           spmNode <= PopupMenu.New(_pm);
                           pmb <= _pm.addMenu(ioPipe.printf("%02d")+":"+ioNode.printf("%02d")+": "+autoDev.getAliasOrDeviceName()+":"+(sn.auto_ch_filter_b+1)+": "+sn.nodeGetName(), deref spmNode);
                           sn.nodeAddSupportedRPNsToPopupMenu(spmNode, _actionPrefix+"rpn_"+sn.auto_dev_filter_b+"_"+sn.auto_ch_filter_b+"_", sn.nodeGetSupportedRPNSubMenus());
                        }
                     }
                  }
               }
            }

            // Next pipe node
            nodeIdx++;
         }

         // Next pipe
         pipeIdx++;
      }
   }

   // <method_find.png>
   static FindNoteIdxByString(String _s) : int {
      String *noteName;
      int noteIdx = 0;
      foreach noteName in midi_notes
      {
         if(noteName.toLower() == _s)
            return noteIdx;
         noteIdx++;
      }
      return -1;
   }

   // <method_get.png>
   static GetVSTOutDeviceNameByIdx(local int _vstIdx) : String {
      return STConfig.localmidi_out_devicenames.get(_vstIdx);
   }

   // <method_get.png>
   static GetVSTOutDeviceIdxByName(local String _devName) : int {
      return STConfig.localmidi_out_devicenames.indexOfObject(_devName, 0);
   }

   // <method_get.png>
   static GetVSTOutDeviceByIdx(local int _vstIdx) : STX_MIDIOutDevice {
      return GetMIDIOutDeviceByAliasOrName(GetVSTOutDeviceNameByIdx(_vstIdx));
   }

   // <method_find.png>
   static FindVSTDeviceIndices() : IntArray {
      IntArray vstDevs;
      vstDevs.free();
      vstDevs.alloc(MAX_LOCALMIDI_OUTPUTS);
      vstDevs.fill(-1);
      int vstDevIdx = 0;
      loop(MAX_LOCALMIDI_OUTPUTS)
      {
         /// "vst_[a..z]";
         STX_MIDIOutDevice vstDev <= MIDI.GetMIDIOutDeviceByAliasOrName(GetVSTOutDeviceNameByIdx(vstDevIdx));
         if(null != vstDev)
         {
            vstDevs[vstDevIdx] = vstDev.dev_idx;
         }
         vstDevIdx++;
      }
      return vstDevs;
   }

   // <method_find.png>
   static FindVSTDevices() : PointerArray {
      STX_MIDIOutDevice *[] vstDevs;
      vstDevs.free();
      vstDevs.alloc(MAX_LOCALMIDI_OUTPUTS);
      int vstDevIdx = 0;
      loop(MAX_LOCALMIDI_OUTPUTS)
      {
         STX_MIDIOutDevice vstDev <= MIDI.GetMIDIOutDeviceByAliasOrName(GetVSTOutDeviceNameByIdx(vstDevIdx));
         if(null != vstDev)
         {
            vstDevs[vstDevIdx] = vstDev;
         }
         vstDevIdx++;
      }
      return vstDevs;
   }

   // <method_get.png>
   public static GetDeviceChString(local int _devIdx, local byte _midiCh, local boolean _bEnable) : String {
      // Used by NodeMonitorPatchViewTM
      local String ret;
      if(_bEnable && (-1 != _devIdx))
      {
         local STX_MIDIOutDevice dev <= MIDI.GetMIDIOutDeviceByIndex(_devIdx);
         if(null != dev)
         {
            ret = dev.getAliasOrDeviceName();
            ret.append(":");
            if(-1 == _midiCh)
               ret.append("*");
            else
               ret.append(_midiCh + 1);
         }
         else
         {
            ret = "- (failed to resolve dev)";
         }
      }
      else
      {
         ret = "-";
      }
      return deref ret;
   }

   // <method.png>
   static UpdateMIDINoteOctaves() {
      byte oct = mathClampi(STConfig.midi_note_octave_offset, -2, 0);
      int noteIdx = 0;
      loop(128)
      {
         String sNote <= midi_notes[noteIdx++];
         if(oct < 0)
         {
            sNote.replace("-", "~");
            sNote.replace("#", "=");
         }
         if(oct > 9)
            sNote[2] = 'A'+(oct-10);
         else
            sNote[2] = '0'+abs(oct);
         if(0 == (noteIdx % 12))
            oct++;
      }

      MNT_PatternView.UpdateMIDINoteOctaves();
   }

}
