// ----
// ---- file   : NodeTracker.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 2006.. (stÂ²)
// ----          10Jan2015, 11Jan2015, 12Jan2015, 17Jan2015, 19Jan2015, 23Jan2015, 24Jan2015
// ----          26Jan2015, 27Jan2015, 28Jan2015, 30Jan2015, 04Feb2015, 05Feb2015, 06Feb2015
// ----          08Feb2015, 11Feb2015, 14Feb2015, 16Feb2015, 22Feb2015, 25Feb2015, 27Feb2015
// ----          28Feb2015, 01Mar2015, 02Mar2015, 04Mar2015, 06Mar2015, 08Mar2015, 14Mar2015
// ----          09Apr2015, 17Apr2015, 19Apr2015, 20Apr2015, 21Apr2015, 26Apr2015, 28Apr2015
// ----          29Apr2015, 03May2015, 11May2015, 12May2015, 13May2015, 30Jun2015, 06Jul2015
// ----          26Jul2015, 27Sep2015, 02Oct2015, 03Oct2015, 04Oct2015, 06Oct2015, 07Oct2015
// ----          09Oct2015, 11Oct2015, 12Oct2015, 23Oct2015, 24Oct2015, 25Oct2015, 26Oct2015
// ----          11Nov2015, 05Dec2015, 17Dec2015, 21Dec2015, 30Dec2015, 08Jan2016, 10Jan2016
// ----          17Jan2016, 20Jan2016, 22Jan2016, 29Jan2016, 30Jan2016, 13Mar2016, 28Mar2016
// ----          31Mar2016, 09Apr2016, 03Jul2016, 08Jul2016, 09Jul2016, 25Jul2016, 19Aug2016
// ----          30Sep2016, 02Oct2016, 11Oct2016, 25Nov2016, 15Jan2017, 21Jan2017, 28Jan2017
// ----          29Jan2017, 02Feb2017, 04Feb2017, 05Feb2017, 09Feb2017, 26Feb2017, 03Mar2017
// ----          05Mar2017, 20Mar2017, 29Mar2017, 04Apr2017, 23May2017, 26May2017, 05Jun2017
// ----          06Jun2017, 01Jul2017, 02Jul2017, 14Jul2017, 13Aug2017, 03Sep2017, 04Oct2017
// ----          12Oct2017, 29Oct2017, 30Oct2017, 04Jan2018, 27Feb2018, 03Mar2018, 07Mar2018
// ----          15Apr2018, 08May2018, 21May2018, 24May2018, 27May2018, 28May2018, 01Jun2018
// ----          10Jun2018, 17Jun2018, 22Jun2018, 24Jun2018, 08Dec2018, 10Jan2019, 12Jan2019
// ----          18Jan2019, 01Mar2019, 07Apr2019, 01Aug2019, 02Aug2019, 03Aug2019, 22Sep2019
// ----          03Oct2019, 09Oct2019, 10Oct2019, 19Oct2019, 20Oct2019, 31Oct2019, 02Nov2019
// ----          07Nov2019, 20Feb2020, 04Mar2020, 06Mar2020, 22Mar2020, 28Apr2020, 03Sep2020
// ----          23Oct2020, 24Oct2020, 25Oct2020, 27Oct2020, 30Oct2020, 10Nov2020, 12Nov2020
// ----          14Nov2020, 15Nov2020, 27Jan2021, 31Jan2021, 08May2021, 23May2021, 20Jun2021
// ----          21Jun2021, 20Jul2021, 21Jul2021, 28Jul2021, 01Jan2022, 02Jan2022, 04Jan2022
// ----          11Feb2022, 12Feb2022, 20Feb2022, 18Mar2022, 19Mar2022, 08May2022, 03Nov2022
// ----          03Apr2023, 29Jul2023, 20Sep2023, 04Oct2023, 14Oct2023, 15Oct2023, 07Jul2024
// ----          01Oct2024, 05Oct2024, 06Oct2024, 16Jan2025, 28Feb2025, 07Jun2025, 13Jun2025
// ----
// ----
// ----

module MNodeTracker;

use namespace ui;
use namespace st2;

boolean b_debug_prgchg = 0;


// <class.png>
class KeyJazzQueueEntry {
   byte track_nr;
   byte instr_nr;
   int  note;       // negative=note off
   byte velocity;
   int  dur_ticks;  // usually 0 (manual note off)
}


// <class.png>
class NT_BlockClipboard {
   IntArray     block_entry_flags; // for each envelope
   PointerArray block_envelopes;
   int          block_length = -1; // # ticks (clipboard size)
}


// <class.png>
class NodeTracker : Node {

   // (note) auto_* fields inherited from Node

   define int RPN_TRACKER_DELAY        = RPN_TRACKER_BASE + 0;  // unused now
   define int RPN_TRACKER_RETRIG       = RPN_TRACKER_BASE + 1;  // unused now
   define int RPN_TRACKER_RESERVD2     = RPN_TRACKER_BASE + 2;
   define int RPN_TRACKER_EXTRST       = RPN_TRACKER_BASE + 3;  // reset external notes (arp)
   define int RPN_TRACKER_SLIDENOTEOFF = RPN_TRACKER_BASE + 4;
   define int RPN_TRACKER_INJECT_CTL0  = RPN_TRACKER_BASE + 100;  // 48 ctls
   define int RPN_TRACKER_INJECT_CTL1  = RPN_TRACKER_BASE + 101;
   define int RPN_TRACKER_INJECT_CTL2  = RPN_TRACKER_BASE + 102;
   define int RPN_TRACKER_INJECT_CTL3  = RPN_TRACKER_BASE + 103;
   define int RPN_TRACKER_INJECT_CTL4  = RPN_TRACKER_BASE + 104;
   define int RPN_TRACKER_INJECT_CTL5  = RPN_TRACKER_BASE + 105;
   define int RPN_TRACKER_INJECT_CTL6  = RPN_TRACKER_BASE + 106;
   define int RPN_TRACKER_INJECT_CTL7  = RPN_TRACKER_BASE + 107;
   define int RPN_TRACKER_INJECT_CTL8  = RPN_TRACKER_BASE + 108;
   define int RPN_TRACKER_INJECT_CTL9  = RPN_TRACKER_BASE + 109;
   define int RPN_TRACKER_INJECT_CTL10 = RPN_TRACKER_BASE + 110;
   define int RPN_TRACKER_INJECT_CTL11 = RPN_TRACKER_BASE + 111;
   define int RPN_TRACKER_INJECT_CTL12 = RPN_TRACKER_BASE + 112;
   define int RPN_TRACKER_INJECT_CTL13 = RPN_TRACKER_BASE + 113;
   define int RPN_TRACKER_INJECT_CTL14 = RPN_TRACKER_BASE + 114;
   define int RPN_TRACKER_INJECT_CTL15 = RPN_TRACKER_BASE + 115;
   define int RPN_TRACKER_INJECT_CTL16 = RPN_TRACKER_BASE + 116;
   define int RPN_TRACKER_INJECT_CTL17 = RPN_TRACKER_BASE + 117;
   define int RPN_TRACKER_INJECT_CTL18 = RPN_TRACKER_BASE + 118;
   define int RPN_TRACKER_INJECT_CTL19 = RPN_TRACKER_BASE + 119;
   define int RPN_TRACKER_INJECT_CTL20 = RPN_TRACKER_BASE + 120;
   define int RPN_TRACKER_INJECT_CTL21 = RPN_TRACKER_BASE + 121;
   define int RPN_TRACKER_INJECT_CTL22 = RPN_TRACKER_BASE + 122;
   define int RPN_TRACKER_INJECT_CTL23 = RPN_TRACKER_BASE + 123;
   define int RPN_TRACKER_INJECT_CTL24 = RPN_TRACKER_BASE + 124;
   define int RPN_TRACKER_INJECT_CTL25 = RPN_TRACKER_BASE + 125;
   define int RPN_TRACKER_INJECT_CTL26 = RPN_TRACKER_BASE + 126;
   define int RPN_TRACKER_INJECT_CTL27 = RPN_TRACKER_BASE + 127;
   define int RPN_TRACKER_INJECT_CTL28 = RPN_TRACKER_BASE + 128;
   define int RPN_TRACKER_INJECT_CTL29 = RPN_TRACKER_BASE + 129;
   define int RPN_TRACKER_INJECT_CTL30 = RPN_TRACKER_BASE + 130;
   define int RPN_TRACKER_INJECT_CTL31 = RPN_TRACKER_BASE + 131;
   define int RPN_TRACKER_INJECT_CTL32 = RPN_TRACKER_BASE + 132;
   define int RPN_TRACKER_INJECT_CTL33 = RPN_TRACKER_BASE + 133;
   define int RPN_TRACKER_INJECT_CTL34 = RPN_TRACKER_BASE + 134;
   define int RPN_TRACKER_INJECT_CTL35 = RPN_TRACKER_BASE + 135;
   define int RPN_TRACKER_INJECT_CTL36 = RPN_TRACKER_BASE + 136;
   define int RPN_TRACKER_INJECT_CTL37 = RPN_TRACKER_BASE + 137;
   define int RPN_TRACKER_INJECT_CTL38 = RPN_TRACKER_BASE + 138;
   define int RPN_TRACKER_INJECT_CTL39 = RPN_TRACKER_BASE + 139;
   define int RPN_TRACKER_INJECT_CTL40 = RPN_TRACKER_BASE + 140;
   define int RPN_TRACKER_INJECT_CTL41 = RPN_TRACKER_BASE + 141;
   define int RPN_TRACKER_INJECT_CTL42 = RPN_TRACKER_BASE + 142;
   define int RPN_TRACKER_INJECT_CTL43 = RPN_TRACKER_BASE + 143;
   define int RPN_TRACKER_INJECT_CTL44 = RPN_TRACKER_BASE + 144;
   define int RPN_TRACKER_INJECT_CTL45 = RPN_TRACKER_BASE + 145;
   define int RPN_TRACKER_INJECT_CTL46 = RPN_TRACKER_BASE + 146;
   define int RPN_TRACKER_INJECT_CTL47 = RPN_TRACKER_BASE + 147;

   public NT_PatternView *pattern_view;  // ref to parent pattern view (while node is being edited)

   public NT_Track tracks[];    // NT_Track instances

   public NT_MetaPattern *[] meta_patterns; // NT_MetaPattern instances

   public NT_Instrument *[] instruments; // NT_Instrument instances

   define int PLAY_MODE_ONESHOT          = 0;
   define int PLAY_MODE_LOOP             = 1;
   int play_mode;

   boolean b_extclk_resetval; // true=advance only when external clock (PLAY_CC_EXTCLK) is received
   boolean b_extclk; // true=advance only when external clock (PLAY_CC_EXTCLK) is received
   int extclk_gatetime;           // extclk is good for <gatetime> ticks
                                  //  == max(1, (gatetime_base * gatetime_mul) / gatetime_div)
   int extclk_gatetime_base;      //
   int extclk_gatetime_mul;       // resetval=1
   int extclk_gatetime_div;       // resetval=1
   int extclk_gatetime_resetval;  // gatetime_base reset val
   int extclk_gate_countdown;     // number of ticks to play when extclk is recv'd
   int extclk_gate_next_ticknr;   // when receiving clock before gate countdown reached 0 (fast forward)

   int extclk_last_event_ticks;     // jam_current_ticks when last clock was received
   int extclk_last_event_gatetime;  // extclk_gatetime when last clock was received

   boolean b_change_reset; // true=start from the beginning when pattern changes (=> b_jam_restart)

   int offlen_ticks_resetval;  // RPN offset/length scaling factor (=> jam_scale_ticks reset value)

   float dur_ticks;           // current CTL_DUR scaling
   float dur_ticks_resetval;  // CTL_DUR scaling (reset value)

   static NodeTrackerEditor *editor;

   protected boolean b_ui_discard_notes;

   public boolean b_noteon_to_prgchg;
   public int noteon_to_prgchg_base_note;
   public int noteoff_to_prgchg_note_offset;


   // used by NodeTrackerEditor class to save/restore cursor position when switching channels:
   public int pv_track_shift;  // Left-most track  (outside this class, this is being written to by the undostack)
   public int pv_cursor_track;
   public int pv_cursor_x; // mirror of track.cursor_x
   public int pv_step_resolution;
   public int pv_zoom_preset_1;
   public int pv_zoom_preset_2;
   public int pv_zoom_preset_idx;

   // edit offset (also see getEditOffset())
   public int pv_pat_offset;  // aka ui_pat_offset (pre 24Oct2015)

   // used in non-autoscroll mode to track the current song offset (sync'd to the UI)
   public int pv_replay_pat_offset; // aka replay_ui_pat_offset (pre 24Oct2015)
   public int ui_polystep_grace_timeout;  // to avoid jumping replay offset when polysteps are played

   // Block selection and clipboard:
   int pv_block_start_pat_offset;
   int pv_block_start_cursor_track;
   int pv_block_start_cursor_x;

   int pv_block_end_pat_offset;
   int pv_block_end_cursor_track;
   int pv_block_end_cursor_x;

   // block c'n'p clipboard
   define int BLOCK_MSB_FLAG = 0x8000;
   define int BLOCK_LSB_FLAG = 0x4000;

   // indices for selectClipboard()
   define int CB_DEFAULT   = 0;
   define int CB_PRIMARY   = 0;
   define int CB_SECONDARY = 1;

   protected static NT_BlockClipboard *ccb; // current clipboard, usually points to cb_1
   protected static NT_BlockClipboard cb_1; // primary clipboard
   protected static NT_BlockClipboard cb_2; // secondary clipboard, used for some more exotic ops (exchange, rotate, ..)

   boolean b_block_no_undo;

   public int last_copied_pattern_nr;  // used for determining initial source pattern selection for TapModeDialog

   public int solo_track_nr;

   public int tick_nr; // total ticks relative to pattern start offset (no wraparound)  (affected by speed/tempo scaling)
   public float tick_frac;  // for rpn_com_speed_scl
   public int synced_tick_nr;  // ideal tick_nr (not affected by speed/tempo scaling)
   protected int last_synced_pat_len;  // fallback used after switching to non-existing pattern (continue sync)

   public boolean b_jam_run;             // 1=replay active (default), 0=pause replay
   public boolean b_jam_done;            // 1=end of oneshot pattern reached, 0=regular replay. reset in nodeRestart()
   public boolean b_jam_gate;            // 1=play sequence (if b_extclk)
   public boolean b_jam_adv;             // 1=advance sequence (if b_extclk)
   public boolean b_jam_retrig;          // 1=currently playing retrig (if b_extclk)
   public boolean b_jam_restart;         // true=restart pattern when patternnr. is changed, false=continue playing at current offset
   public int     jam_queued_pattern_nr; // next pattern nr. -1=none queued, -2=turn off current pattern
   public int     jam_queued_offset_ticks;  // CTL_SEEK (when to break), or -1. node_queued_com_seek_off contains target
   public int     jam_scale_ticks;       //
   public int     jam_scale_mul;         //
   public int     jam_scale_div;         //
   public int     jam_tick_multiplier;   // #ticks = max(1, jam_scale_ticks * jam_scale_mul / jam_scale_div)
   public int     jam_offset;            // ticks=jam_offset*jam_tick_multiplier
   public int     jam_length;            // ticks=jam_length*jam_tick_multiplier
   public int     jam_current_ticks;     // (jam_offset..jam_length)*jam_tick_multiplier.
                                         // -1=start new pattern/recalc tick offset
                                         // -2=continue pattern with new length
   public int     jam_current_start_ticks; // for ui
   public int     jam_current_end_ticks; // calc'd when pattern is (re-)started
   public int     jam_offset_queued;     // same as jam_offset but delayed until seq loops. -1=nothing queued
   public int     jam_length_queued;     // same as jam_length but delayed until seq loops. -1=nothing queued

   public NT_UndoStack *ui_undo_stack;
   public NT_UndoEntry *ui_undo_entry; // undo entry of currently active transaction
   boolean b_skip_rec_undo;  // true while creating/exporting to temporary tracker node (see NSQ_Arranger::beginTrackerEdit)

   public float def_velocity;  // used if no CTL_VELn resp. CTL_DURn data is available
   public float def_duration;

   public ClassArray keyjazz_queue;  // KeyJazzQueueEntry instances

   public boolean b_per_pattern_kj_instr;  // 1=save/restore kj instr per pattern (+track). 0=save/restore per track (default)

   public IntArray   tick_ext_note_ons;     // temporary array: ext note ons received
   public FloatArray tick_ext_note_on_vels;
   public IntArray   tick_ext_note_offs;    // temporary array: ext note offs received
   public FloatArray tick_ext_note_off_vels;

   public boolean b_tick_ext_first_note; // temporary, true=first ext note recv'd on this tick

   public IntArray ext_active_notes;
   public IntArray arp_active_notes;  // ==ext_active_notes, except in arp latch mode
   public int arp_latch_next_idx;
   public boolean b_arp_dynalen_update_queued; // true if b_arp_dynalen and #active_notes has changed (=> update sync'd to steps!)

   boolean         b_arp;           // true=map triggered note to arp_note_table to get idx which
                                    //  is then mapped to arp_active_notes
   public IntArray arp_note_table;  //
   public int      arp_base_octave;
   public boolean  b_arp_reset;     // true=reset sequence when first note-on is received
   public boolean  b_arp_wrap;      // true=wrap around arpIdx if #active_notes < #arp_notes
   public int      arp_latch_num_notes;  // >0 = ignore note-offs and wrap-around add to arp_active_notes
   public boolean  b_arp_latch_reset; // true = reset active notes when first note is played
   public boolean  b_arp_play_arp_notes;     // true=play notes even if they are not currently mapped to an ext note
   public boolean  b_arp_play_non_arp_notes; // true=play notes that cannot be mapped to ext notes
   public boolean  b_arp_dynalen;            // true=adjust pattern length to #active_notes * jam_scale_ticks

   // KeyJazz recording settings (formerly located in global config)
   //  (note) each track (if there is any) has its own KeyJazz setup!
   public boolean b_write_instrnr;          // true=write instrument nr
   public boolean b_write_noteon_velocity;  // true=write note-on velocity
   public float   write_noteon_velocity;    // note-on velocity (0..127)
   public boolean b_write_noteoff_velocity; // true=write note-off velocity
   public float   write_noteoff_velocity;   // note-off velocity (0..127)
   public boolean b_write_duration;         // true=write note duration (CTL_DUR1..5)
   public float   write_duration;           // default note duration

   // Misc UI settings:
   public int   ui_step_alignment;  // align wheelup/down and pageup/down movement to the given number of steps
   public float ui_highlight_tick_modulo; // >0: highlight every 'nth' tick, 0=disable, <0=use PPQ * -tick_modulo

   public int tick_ext_delay;  // temporary, external delay value via RPN_TRACKER_DELAY
   public int tick_ext_retrig; // temporary, external retrig value via RPN_TRACKER_RETRIG

   public byte ui_last_view;

   public boolean b_rec_quantize_last_step;
   public boolean b_match_instr;  // true=filter events by instrument dev/ch (resp. instr.param dev/ch), false=record all events. maybe=filter events by midi channel only
   public boolean b_rec_prev;     // true=record previous node output (play frames)
   public boolean b_rec_all;      // true=record to all tracks
   public boolean b_rec_spread;   // true=spread notes over multiple tracks (e.g. wide chords with more than 5 notes)
   public boolean b_rec_bg;       // true=background recording (when node is not being edited)

   define int REC_MODE_OVERDUB = 0;
   define int REC_MODE_RASTER  = 1;
   public int rec_mode;

   define int REC_SEL_NONE            = 0;
   define int REC_SEL_NOTES           = 1;
   define int REC_SEL_NOTES_AND_CTLS  = 2;
   define int REC_SEL_CTLS            = 3;
   define int REC_SEL_CURRENT_CTL     = 4;
   public int rec_sel;

   public int last_rec_soff; // tick offset of last recorded note (to prevent clear in RASTER rec_mode)
   public int last_rec_eoff;
   public int num_rec_notes; // number of recorded notes since replay start (for RASTER rec_mode)
   public int rec_clear_start; // for RASTER rec_mode
   public boolean b_rec_clear_start_wrap; // "carry" flag. if set, wait one loop before clearing starts (quant placed event at end of pat at first step)
   public int rec_clear_last_step;

   public boolean b_ta_recordmidiend_scheduled;

   // (UI) Edit modes
   define int PV_EDIT_NONE      = 0;
   define int PV_EDIT_STEP      = 1;
   define int NUM_PV_EDIT_MODES = 2;
   public int pv_edit_mode;

   public boolean b_rt_record; // true=replay was started via rshift OR while edit and autoscroll were enabled

   public int learn_mode; // see NT_InstrumentView. If != 0, do not record midi events.

   public int queued_undo_record_restart_ticks = -1;
   boolean b_rec_any_note_on;  // temp flag during recordFrame()

   public int current_microshift_idx;  // see config: STConfig.node_tracker_microshift_ticks

   public    boolean b_tap_mode;
   public    boolean b_tap_mode_keepenabled;
   // // // public    boolean b_tap_mode_before_restart;  // used by undo-and-restart
   public    byte    tap_mode_source_pat_nr;
   public    int     tap_mode_step_resolution;
   public    byte    tap_mode_scratch_pat_nr;
   public    boolean b_tap_mode_advance;     // true=auto-advance to next source step
   public    boolean b_tap_mode_select;      // true=selecting a step plays/records it
   public    boolean b_tap_mode_alltracks;   // true=play/record all tracks, false=current track only
   public    boolean b_tap_mode_beatsync;    // true=keep copied/played events synced to the beat
   public    boolean b_tap_mode_resetsourcestep; // true=rewind to first step when replay is stopped (node is reset)
   protected int     tap_mode_current_source_step;
   protected int     tap_mode_queued_play_step;
   protected int     tap_mode_last_play_overlap;  // to prevent cutoff of kj step when recording is disabled

   // true=clear all note cels of current step when recording first note
   protected boolean b_chord_clear_step;

   public boolean b_envelope_view_visible;
   public float   envelope_view_split;
   public int     envelope_view_edit_mode;
   public int     envelope_view_zoom_mode;
   public boolean b_envelope_view_replace;
   public int     envelope_view_edit_grid_size;  // in ticks
   public int     envelope_view_tick_offset;
   public int     envelope_view_block_grid_mode; // NT_EnvelopeView.BLOCK_GRID_xxx
   public int     envelope_view_custom_vis_ticks;

   public boolean b_slide_note_off;  // valid for current tick, see RPN_TRACKER_SLIDENOTEOFF

   public boolean b_ui_queued_status_info_chord;

   public boolean b_ui_timing_view;
   public boolean b_ui_timing_view_move_lock;

   public float initial_sample_offset_ms;
   public int   current_audiotrack_note;  // 12*5=C-5 while audio track is playing

   public boolean  b_ui_piano;  // true=PianoWidget is visible
   public IntArray ui_last_note_state;
   public boolean  b_ui_last_note_state_changed;

   public boolean b_block_loop;  // true=SPACE loops (previously) selected block. toggled with lctrl-RETURN (no block=disable)
   public int     block_loop_start;  // ticks
   public int     block_loop_len;    // ticks
   public boolean b_freerun_loop_bak;  // state of replay.b_freerun_loop before block-loop. maybe=unknown (don't restore)

   public boolean b_seq_temp;  // true=is NodeSeq temp node

   public String smp_import_filter;  // e.g. "a_peak*". used by NT_ImportSamplesDialog.

   public byte last_vst_dev;   // -1=none, 0..25 => vst_a..vst_z
   public byte last_vst_ch;    // -1=none, 0..15 => MIDI channel 1..16

   public int midi_node_gid;
   public int audio_node_gid;
   public boolean b_audiomidi_mutex;     // true=auto-mute MIDI node when audio node is unmuted (and vice versa). maybe=mute audio node when recording starts via NT_AudioDialog. Stored in Audio node.
   public boolean b_audionode_midimute;  // true=auto-mute MIDI node after recording <MIDI pattern length> ticks (capture decaying sounds during extra ticks). maybe=also unmute audio node when recording stops (after patlen ticks). stored in Audio node.
   public int audiorec_tick_nr;          // see NT_AudioDialog. used for auto-muting MIDI node. Stored in MIDI node.
   public int audiorec_automute_tick_nr; // ^^. Also stored in MIDI node.
   protected short queued_forced_smp_uid;
   protected short queued_forced_smp_dev_idx;
   protected short queued_forced_smp_midi_ch;

   protected boolean b_ui_ghost_seek;
   public int ghost_jam_current_ticks_song_offset;  // song_offset for last seen (valid) jam_current_ticks

   public boolean b_echo_frame_rec_to_play;  // 1=merge (remaining) frameRec events to kjIns framePlay and output-capture buffer. frameRec events will be removed after merge. applied when node editor is visible. lctrl-x 9 toggles this setting.

   // in STConfig.b_node_tracker_recordusrctlnoteon mode (lctrl-x .)
   //  - queue UsrCtl events until next note-on
   //  - record all queued UsrCtl events to note-on step
   //  - clear queued events at end of recordFrame() if note-on was recorded
   MIDIPipeFrame frame_queued_usrctl_noteon;

   NSQ_TrackerState *seq_tracker_state;  // when != null, save editor state when tracker editing ends


   // <init.png>
   public virtual nodeInit(MIDIPipe _pipe, MIDIPipeNode _node) : boolean {

      Node::nodeInit(_pipe, _node);

      meta_patterns.alloc(128);
      meta_patterns.useAll();

      // Allocate patterns
      int patIdx = 0;
      loop(128)
      {
         NT_MetaPattern mpat <= new NT_MetaPattern;
         mpat.patInit(this, patIdx);
         mpat.b_empty = true;
         nodeSetPattern(patIdx, deref mpat);
         patIdx++;
      }

      instruments.alloc(128);
      instruments.useAll();

      b_extclk_resetval = false;
      extclk_gatetime_resetval = current_song.ppq / 4;  // 1/16 note

      b_change_reset = false;////true;

      play_mode = PLAY_MODE_LOOP;

      offlen_ticks_resetval = current_song.ppq / 4;  // default= 1/16 note

      dur_ticks_resetval = 1;  // v15+ projects default value is 1/64 note (see nodeUIInit)
      dur_ticks = 1;

      b_auto_filter_a = false;
      auto_dev_filter_a = -1;
      auto_ch_filter_a  = 7;

      b_auto_filter_b = false;
      auto_dev_filter_b = -1;
      auto_ch_filter_b  = 7;

      noteon_to_prgchg_base_note = STConfig.default_noteon_to_prgchg_base_note;
      noteoff_to_prgchg_note_offset = STConfig.default_noteoff_to_prgchg_note_offset;

      solo_track_nr = -1;
      // b_mute        = false;

      pv_track_shift     = 0;
      pv_cursor_track    = 0;
      pv_cursor_x        = 0;
      pv_step_resolution = current_song.ppq / 4;  // 1/16 note
      pv_zoom_preset_1   = STConfig.node_tracker_zoom_preset_1;
      pv_zoom_preset_2   = STConfig.node_tracker_zoom_preset_2;
      pv_zoom_preset_idx = 0;
      pv_pat_offset      = 0;
      pv_replay_pat_offset = 0;

      pv_block_start_pat_offset  = -1;
      pv_block_end_pat_offset    = -1;

      b_jam_run           = true;
      b_jam_done          = false;
      jam_tick_multiplier = current_song.ppq / 4;
      jam_offset          = 0;
      jam_length          = 64;
      b_jam_restart       = true;

      edit_pattern_nr = 0;

      jam_queued_pattern_nr = -1;

      ui_undo_stack <= new NT_UndoStack;
      ui_undo_stack.init(this);
      ui_undo_entry <= null;

      def_velocity = 64;
      def_duration = current_song.ppq / 4;

      keyjazz_queue.template = KeyJazzQueueEntry;
      keyjazz_queue.alloc(32);

      b_arp = false;
      arp_note_table.empty();
      arp_base_octave = 4;
      b_arp_reset = false;
      b_arp_wrap  = true;
      arp_latch_num_notes = 0;
      b_arp_latch_reset = true;
      b_arp_play_arp_notes = false;
      b_arp_play_non_arp_notes = false;
      b_arp_dynalen = false;

      b_write_noteon_velocity  = true;
      write_noteon_velocity    = 0x40;
      b_write_noteoff_velocity = false;
      write_noteoff_velocity   = 0;
      b_write_duration         = false;
      write_duration           = current_song.ppq / 4; // 1/16

      ui_step_alignment = STConfig.node_tracker_default_step_alignment;
      ui_highlight_tick_modulo = -4;

      ui_last_view = NodeTrackerEditor.VIEW_PATTERN;

      pv_edit_mode = PV_EDIT_NONE;

      b_rec_quantize_last_step = STConfig.b_node_tracker_always_quantize_last_step;
      rec_sel = REC_SEL_NOTES_AND_CTLS;

      current_microshift_idx = 1;

      b_node_queued_b_mute_temp_custom_handler = true; // flag for native code

      b_tap_mode                 = false;
      b_tap_mode_advance         = true;
      b_tap_mode_select          = true;
      b_tap_mode_alltracks       = false;
      b_tap_mode_resetsourcestep = true;
      tap_mode_source_pat_nr     = 0;
      tap_mode_scratch_pat_nr    = Node.TMP_PAT_NR;
      b_tap_mode_keepenabled     = true;

      envelope_view_split           = 0.75;
      envelope_view_edit_mode       = NT_EnvelopeViewData.EDIT_DRAW;
      envelope_view_zoom_mode       = NT_EnvelopeViewData.ZOOM_PATTERN;
      envelope_view_tick_offset     = 0;
      envelope_view_edit_grid_size  = current_song.ppq / 4;
      envelope_view_block_grid_mode = NT_EnvelopeViewData.BLOCK_GRID_4;
      envelope_view_custom_vis_ticks= 1; // updated by NT_EnvelopeView.getVisTicks()

      initial_sample_offset_ms = -1;
      current_audiotrack_note  = -1;

      ui_last_note_state.allocAndFill(128, 0);

      b_ui_piano = false;

      b_freerun_loop_bak = maybe;

      last_vst_dev = -1;
      last_vst_ch  = -1;

      midi_node_gid = -1;
      audio_node_gid = -1;
      b_audiomidi_mutex = maybe;
      b_audionode_midimute = maybe;
      queued_forced_smp_uid = -1;

      queued_undo_record_restart_ticks = -1;

      return true;
   }

   // <ui_init.png>
   public virtual nodeUIInit() {

      Node::nodeUIInit();

      newTrack("Track 1", null/*curTrack*/, false/*bCloneLayout*/);

      NT_MetaPattern mpat <= getOrCreateMetaPattern(0);
      mpat.setNumTicks(current_song.getNumTicksPer16th() * STConfig.node_tracker_initial_pattern_length_16th);

      nodeSetCurrentPlayPatternNr(0);
      nodeSetCurrentEditPatternNr(0);

      arp_note_table.alloc(12);
      arp_note_table.useAll();
      arp_note_table.identity(12);

      dur_ticks_resetval = current_song.ppq / 64;  // 1/256
      dur_ticks = dur_ticks_resetval;

      pv_cursor_x = 1; // note cel

      initial_sample_offset_ms = -1;
      current_audiotrack_note  = -1;
   }

   // <method_get.png>
   public virtual nodeGetTypeNameShort() : String {
      return "Trk";
   }

   // <method_get.png>
   public virtual nodeGetEditor() : NodeEditor {
      if(null == editor)
      {
         editor <= new NodeTrackerEditor;

         if(!editor.init())
         {
            editor <= null;
            return false;
         }
      }
      return editor;
   }

   // <method_get.png>
   public virtual nodeGetEditorIfExists() : NodeEditor {
      return editor;
   }

   // <method_handle.png>
   public method nodeStopEditing() {

      stopTapMode(false/*bForce*/);

      Node::nodeStopEditing();
   }

   // <method_get.png>
   public virtual nodeGetIcon() : Icon {
      if(LookAndFeel.IDX_MONO == STConfig.lnf_idx)
         return UI.GetIcon("node_tracker_mono");
      else
         return UI.GetIcon("node_tracker");
   }

   // <method.png>
   public virtual nodeGetPatternClassName() : String {
      return "NT_MetaPattern";
   }

   // <method.png>
   public virtual nodeNewPattern(int _patIdx) : NodePattern {
      NT_MetaPattern mpat <= new NT_MetaPattern;
      mpat.patInit(this, _patIdx);
      meta_patterns[_patIdx] = deref mpat;
      return mpat;
   }

   // <method.png>
   public virtual nodeFreePatternTrackData(int _patIdx) {
      NT_Track *track;
      foreach track in tracks
      {
         NT_TrackPattern pat <= track.getOrCreatePattern(_patIdx); // (note) pattern should already exist
         pat.init(track, _patIdx); // re-init
      }
   }

   // <method.png>
   public virtual nodeDeletePatternByIdx(int _patIdx) {
      // Special case: keep pattern object but mark as empty
      NT_MetaPattern mpat <= meta_patterns.get(_patIdx);
      mpat.patInit(this, mpat.pat_nr); // re-init
      mpat.b_empty = true;
   }

   // <method_get.png>
   public method nodeCanShiftPatterns() : boolean {
      return true;
   }

   // <method.png>
   public virtual nodeShiftInsertPatternSlotAtIdx(int _patIdx) : boolean {
      // insert (null) pattern slot at the given index and shift subsequent patterns
      NT_MetaPattern mpat <= new NT_MetaPattern;
      mpat.patInit(this, _patIdx);
      mpat.b_empty = true;
      meta_patterns.delete(NUM_PATTERNS - 1);
      meta_patterns.insert(_patIdx, #(deref mpat));
      nodeReEnumeratePatterns();

      // Shift track patterns
      NT_Track *track;
      foreach track in tracks
      {
         int i = _patIdx;
         loop(NUM_PATTERNS - i - 1)
         {
            NT_TrackPattern trackPat <= track.patterns.get(i++);
            if(null != trackPat)
               trackPat.pat_nr++;
         }
         track.patterns.delete(NUM_PATTERNS - 1);
         track.patterns.insert(_patIdx, null);
      }

      return true;
   }

   // <method.png>
   public virtual nodeShiftDeletePatternSlotAtIdx(int _patIdx) : boolean {
      // delete pattern slot at the given index and shift subsequent patterns
      meta_patterns.delete(_patIdx);
      NT_MetaPattern mpat <= new NT_MetaPattern;
      mpat.patInit(this, NUM_PATTERNS -1);
      mpat.b_empty = true;
      meta_patterns.insert(NUM_PATTERNS -1, #(deref mpat));
      nodeReEnumeratePatterns();

      // Shift track patterns
      NT_Track *track;
      foreach track in tracks
      {
         track.patterns.delete(_patIdx);
         track.patterns.insert(NUM_PATTERNS -1, null);
         int i = _patIdx;
         loop(NUM_PATTERNS - i)
         {
            NT_TrackPattern trackPat <= track.patterns.get(i++);
            if(null != trackPat)
               trackPat.pat_nr--;
         }
      }

      return true;
   }

   // <method_get.png>
   public method getNumTracks() : int {
      return tracks.numElements;
   }

   // <replay.png>
   public method startEditorLoop(int _off, int _numTicks) {
      // called by NT_PatternView.loopCurrentPattern() (=replay= is locked)
      Global.Debug2("NT::startEditorLoop: off="+_off+" numTicks="+_numTicks);
      jam_tick_multiplier = offlen_ticks_resetval; // xxx already done by nodeReset()
      jam_current_ticks = _off;
      jam_offset = 0;
      jam_length = _numTicks / jam_tick_multiplier;
      if(0 == jam_length)
         jam_length = 1;
      jam_current_end_ticks = _numTicks;
      tick_nr = _off; // [09Sep2017] fix undoandRestartRecording
      synced_tick_nr = tick_nr;
      // // current_song.song_offset = nodeGetLastPatternStartSongOffset() + _off - 1; // [09Sep2017] fix undoandRestartRecording
      // (note) subtract -1 b/c handleReplayTick() is called at the end of processFrame() but before song_offset is increased in replay.tick()
      //   ==> [13Sep2017] NO. handleReplayTick() moved up to processFrame() start (=> fix realtime note recording)
      // // current_song.song_offset = nodeGetLastPatternStartSongOffset() + _off; // [09Sep2017] fix undoandRestartRecording
      current_song.song_offset = nodeGetLastPatternStartEditorSongOffset() + _off; // [09Sep2017] fix undoandRestartRecording
   }

   // <method_get.png>
   public =replay= method uiGetLastNoteStateAndReset(IntArray _ret) : boolean {
      boolean r = b_ui_last_note_state_changed;
      if(r)
      {
         // (note) the note_state is shared between PianoWidget and node by reference
         // // _ret = ui_last_note_state;
         // // ui_last_note_state.fill(0);
         b_ui_last_note_state_changed = false;
      }
      return r;
   }

   // <ui_selection.png>
   public method selectNoneRaw() {
      pv_block_start_pat_offset = -1;
      pv_block_end_pat_offset   = -1;
   }

   // <ui_selection.png>
   public static SelectClipboard(int _idx) {
      if(0 == _idx)
      {
         ccb <= cb_1;
      }
      else if(1 == _idx)
      {
         ccb <= cb_2;
      }
      else
      {
         Global.Error("PV::selectClipboard: invalid idx="+_idx);
         ccb <= cb_1;
      }
   }

   // <ui_selection.png>
   public method haveSelection() : boolean {
      explain "Query if a selection is available.";

      ////trace "xxx block_start_pat_offset="+pv_block_start_pat_offset+" pv_block_end_pat_offset="+pv_block_end_pat_offset;
      return (-1 != pv_block_start_pat_offset) && (-1 != pv_block_end_pat_offset);
   }

   // <method.png>
   public method getSortedBlockStartOffset() : int {
      return mathMini(pv_block_start_pat_offset, pv_block_end_pat_offset);
   }

   // <method.png>
   public method getSortedBlockEndOffset() : int {
      return mathMaxi(pv_block_start_pat_offset, pv_block_end_pat_offset);
   }

   // <ui_selection.png>
   public static InvalidateBlockClipboard() {
      ccb.block_length = -1;
   }

   // <ui_selection.png>
   public static GetClipboardBlockLength() : int {
      // Number of ticks
      return ccb.block_length;
   }

   // <ui_selection.png>
   public method swapBlockStartAndEnd() {
      int t;

      // Swap song offset
      t = pv_block_start_pat_offset;
      pv_block_start_pat_offset = pv_block_end_pat_offset;
      pv_block_end_pat_offset   = t;

      // Swap track nr
      t = pv_block_start_cursor_track;
      pv_block_start_cursor_track = pv_block_end_cursor_track;
      pv_block_end_cursor_track   = t;

      // Swap track cursor position
      t = pv_block_start_cursor_x;
      pv_block_start_cursor_x = pv_block_end_cursor_x;
      pv_block_end_cursor_x   = t;
   }

   // <ui_selection.png>
   public method blockSelectPatRangeRaw(int _startOff, _startTrack, _startX,
                                        int _endOff, _endTrack, _endX
                                        ) {
      // no auto-expand

      // trace "xxx blockSelectPatRange: start off="+_startOff+" track="+_startTrack+" x="+_startX;
      // trace "xxx blockSelectPatRange:   end off="+_endOff+" track="+_endTrack+" x="+_endX;

      pv_block_start_pat_offset   = _startOff;
      pv_block_start_cursor_track = _startTrack;
      pv_block_start_cursor_x     = _startX;

      pv_block_end_pat_offset   = _endOff;
      pv_block_end_cursor_track = _endTrack;
      pv_block_end_cursor_x     = _endX;
   }

   // <ui_selection.png>
   public method setEnableBlockLoop(boolean _bEnable) {
      if(!haveSelection())
         _bEnable = false;

      NT_MetaPattern mpatCur <= getCurrentEditMetaPattern();
      if(null == mpatCur)
         _bEnable = false;

      if(!_bEnable)
      {
         // Stop block loop
         b_block_loop = false;
         block_loop_start = -1;
         block_loop_len   = 0;
         if(maybe != b_freerun_loop_bak)
         {
            replay.setEnableFreerunLoop(b_freerun_loop_bak);
            b_freerun_loop_bak = maybe;
            replay.setCycle(false/*bEnabled*/, true/*bQuiet*/);
         }
      }
      else
      {
         // Start or continue block loop
         b_block_loop = true;
         b_freerun_loop_bak = replay.b_freerun_loop;
         replay.setEnableFreerunLoop(false);

         if(pv_block_end_pat_offset < pv_block_start_pat_offset)
            swapBlockStartAndEnd();

         block_loop_start = pv_block_start_pat_offset + nodeGetLastPatternStartEditorSongOffset();
         block_loop_len   = pv_block_end_pat_offset - pv_block_start_pat_offset + pv_step_resolution;

         // trace "xxx BLKLOOP nodeGetLastPatternStartEditorSongOffset="+nodeGetLastPatternStartEditorSongOffset();
         // trace "xxx BLKLOOP pv_block_start_pat_offset="+pv_block_start_pat_offset;
         // trace "xxx BLKLOOP block_loop_start="+block_loop_start;
         // trace "xxx BLKLOOP block_loop_len="+block_loop_len;

         if((pv_block_start_pat_offset + block_loop_len) > mpatCur.num_ticks)
            block_loop_len = mpatCur.num_ticks - pv_block_start_pat_offset;  // after lctrl-a (one step too long)

         // // replay.setCycle(true/*bEnabled*/, true/*bQuiet*/);
         // // if(replay.b_playing)
         // // {
         // //    // Queue new loop
         // //    trace "xxx setEnableBlockLoop: start="+block_loop_start+" len="+block_loop_len;
         // //    current_song.queueCycleLoop(block_loop_start, block_loop_len/*numTicksOverrideOr0*/, false/*bQuiet*/, false/*bImmediate*/);
         // // }

      }
   }

   // <ui_selection.png>
   public method blockCopyRaw(int _extraBlockEndTicks) : int {
      int uiTotalNumEvents = 0; // Return value, number of copied events

      // trace "xxx blockCopyRaw: pv_block_start_pat_offset="+pv_block_start_pat_offset+" pv_block_end_pat_offset="+pv_block_end_pat_offset;

      // Swap start/end if necessary
      if(haveSelection())
      {
         PointerArray blockEnvs <= ccb.block_envelopes; // Array of Envelope objects
         blockEnvs.free();

         // (todo) the entryFlags do not seem to be read anywhere. remove ?
         IntArray entryFlags <= ccb.block_entry_flags; // for each envelope, 0x8000 for 2digit hex MSB, 0x4000 for 2digit hex LSB, 0 for "single column" float entry
         entryFlags.empty();

         int trackNr = pv_block_start_cursor_track;
         int cursorX = pv_block_start_cursor_x;
         while(trackNr <= pv_block_end_cursor_track)
         {
            NT_Track track <= getTrack(trackNr);
            NT_TEL   tel   <= track.getTrackLayout();
            int              numCursorX = tel.num_cursor_positions;

            if(trackNr == pv_block_end_cursor_track)
            {
               numCursorX = pv_block_end_cursor_x + 1;
            }

            // trace "xxx copy track="+trackNr+" cursorX="+cursorX+" numCursorX="+numCursorX;

            while(cursorX < numCursorX)
            {
               int ctlMapId = tel.cursor_to_ctl_map[cursorX];
               NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
               int ctlId = cel.ctl_id;

               ////trace "xxx trackNr="+trackNr+" cursorX="+cursorX+" cel mapId="+ctlMapId+" ctlId="+ctlId;

               Envelope *env <= new Envelope;
               blockEnvs.add(#(deref env));

               int patOff = pv_block_start_pat_offset;
               int blockEndOff = pv_block_end_pat_offset + _extraBlockEndTicks;
               int envOff = 0;
               var e;

               // (todo) support 3 digit cels
               if(cel.style == NT_CEL.STYLE_HEX)
               {
                  // "two-digit" envelope
                  if(ctlMapId & NT_TEL.MSB_FLAG)
                  {
                     if(cursorX < (numCursorX-1))
                     {
                        // LSB is also selected, skip next cursorX
                        entryFlags.add(BLOCK_MSB_FLAG | BLOCK_LSB_FLAG);

                        cursorX++;
                     }
                     else
                     {
                        // Only select MSB
                        entryFlags.add(BLOCK_MSB_FLAG);
                     }
                  }
                  else
                  {
                     // Only select LSB
                     entryFlags.add(BLOCK_LSB_FLAG);
                  }
               }
               else
               {
                  // Regular "single-digit" envelope
                  entryFlags.add(0);
               }

               while(patOff < blockEndOff)
               {
                  e = getEventAt(track, ctlId, patOff, 1);
                  // if(0 == patOff)
                  //    trace "xxx trackNr="+trackNr+" patNr="+edit_pattern_nr+" patOff="+patOff+" cursorX="+cursorX+" ctlId="+ctlId+" e="+#(e);
                  env.shiftEvents(envOff, 1);
                  if(typeid(e) == YAC_TYPE_FLOAT)
                  {
                     ////env.insertReplaceEvent(envOff, e, _stepResolution/*not 1??*/);
                     env.insertReplaceEvent(envOff, e, 1);
                     uiTotalNumEvents++;
                  }
                  patOff ++;
                  envOff ++;
               }
               /////trace "xxx env="+#(env);

               cursorX++;
            }

            cursorX = 0;
            trackNr++;
         }

         ccb.block_length = pv_block_end_pat_offset + _extraBlockEndTicks - pv_block_start_pat_offset;
      }

      return uiTotalNumEvents;
   }

   // <ui_selection.png>
   public method blockPasteRaw__SLOW(int trackNr, int cursorX, boolean _bShift) : int {

      int uiTotalNumEvents = 0; // Return value, number of pasted events

      // Paste (pattern) clipboard at current cursor position, shift all following events
      if(-1 != ccb.block_length)
      {
         int numTracks = tracks.numElements;

         ////trace "xxx NodeTracker::blockPaste() numTracks="+numTracks+" block_length="+ccb.block_length+" bShift="+_bShift;
         if(0 != numTracks)
         {

            int entryId = 0;
            int numEnv = ccb.block_envelopes.numElements;
            // IntArray entryFlags <= ccb.block_entry_flags;
            PointerArray blockEnvs <= ccb.block_envelopes; // Array of Envelope objects

            ////trace "xxx paste trackNr="+trackNr+" numTracks="+numTracks;

            while(trackNr < numTracks)
            {
               ////trace "xxx paste trackNr="+trackNr+"/"+numTracks;

               NT_Track track <= getTrack(trackNr);
               NT_TEL   tel   <= track.getTrackLayout();
               int              numCursorX = tel.num_cursor_positions;

               ////trace "xxx cursorX="+cursorX+" numCursorX="+numCursorX+" entryId="+entryId+" numEnv="+numEnv;

               int editOffset = getEditOffset();

               int lastCtlId = -1;

               while( (cursorX < numCursorX) && (entryId < numEnv) )
               {
                  int ctlMapId = tel.cursor_to_ctl_map[cursorX];
                  NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                  int ctlId = cel.ctl_id;

                  ////trace "xxx trackNr="+trackNr+" cursorX="+cursorX+" cel mapId="+ctlMapId+" ctlId="+ctlId;

                  if(ctlId != lastCtlId)
                  {
                     Envelope *env <= blockEnvs[entryId];
                     // int entryFlag = entryFlags[entryId];

                     int patOff = editOffset;
                     int envOff = 0;
                     var e;

                     if(cel.style == NT_CEL.STYLE_HEX)
                     {
                        // "two-digit" column
                        if(ctlMapId & NT_TEL.MSB_FLAG)
                        {
                           // MSB + LSB
                           cursorX++;
                        }
                     }

                     ////trace "xxx paste single-digit env="+#(env);

                     // Regular "single-digit" envelope
                     while(envOff < ccb.block_length)
                     {
                        if(_bShift)
                        {
                           shiftEventsAt(track, ctlId, patOff, 1);
                        }

                        e = env.valueAtTimeRaster(envOff, 1);

                        if(typeid(e) == YAC_TYPE_FLOAT)
                        {
                           insertReplaceEventAtRes(track, ctlId, e, patOff, 1);
                           uiTotalNumEvents++;
                        }
                        else
                        {
                           removeEventAt(track, ctlId, patOff, 1);
                           shiftEventsAt(track, ctlId, patOff, 1);
                        }
                        envOff++;
                        patOff++;
                     }

                     lastCtlId = ctlId;

                  } // if ctlId != lastCtlId

                  entryId++;
                  cursorX++;
               }

               cursorX = 0;
               trackNr++;
            }

         } // if numTracks
      } // if -1 != block_length

      return uiTotalNumEvents;
   }

   // <ui_selection.png>
   public method blockPasteRaw(int trackNr, int cursorX, boolean _bShift) : int {

      int uiTotalNumEvents = 0; // Return value, number of pasted events

      // Paste (pattern) clipboard at current cursor position, shift all following events
      if(-1 != ccb.block_length)
      {
         int numTracks = tracks.numElements;

         ////trace "xxx NodeTracker::blockPaste() numTracks="+numTracks+" block_length="+ccb.block_length+" bShift="+_bShift;
         if(0 != numTracks)
         {

            int entryId = 0;
            int numEnv = ccb.block_envelopes.numElements;
            // IntArray entryFlags <= ccb.block_entry_flags;
            PointerArray blockEnvs <= ccb.block_envelopes; // Array of Envelope objects

            ////trace "xxx paste trackNr="+trackNr+" numTracks="+numTracks;

            while(trackNr < numTracks)
            {
               ////trace "xxx paste trackNr="+trackNr+"/"+numTracks;

               NT_Track track <= getTrack(trackNr);
               NT_TEL   tel   <= track.getTrackLayout();
               int              numCursorX = tel.num_cursor_positions;

               ////trace "xxx cursorX="+cursorX+" numCursorX="+numCursorX+" entryId="+entryId+" numEnv="+numEnv;

               int editOffset = getEditOffset();

               int lastCtlId = -1;

               while( (cursorX < numCursorX) && (entryId < numEnv) )
               {
                  int ctlMapId = tel.cursor_to_ctl_map[cursorX];
                  NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                  int ctlId = cel.ctl_id;

                  ////trace "xxx trackNr="+trackNr+" cursorX="+cursorX+" cel mapId="+ctlMapId+" ctlId="+ctlId;

                  if(ctlId != lastCtlId)
                  {
                     Envelope *env <= blockEnvs[entryId];
                     // int entryFlag = entryFlags[entryId];

                     int patOff = editOffset;
                     int envOff = 0;
                     var e;

                     if(cel.style == NT_CEL.STYLE_HEX)
                     {
                        // "two-digit" column
                        if(ctlMapId & NT_TEL.MSB_FLAG)
                        {
                           // MSB + LSB
                           cursorX++;
                        }
                     }

                     ////trace "xxx paste single-digit env="+#(env);

                     if(_bShift)
                     {
                        // Insert: Make room for pasted block
                        shiftEventsAt(track, ctlId, patOff, ccb.block_length);
                     }
                     else
                     {
                        // Replace: Clear destination region and shift following events (i.e. keep absolute time)
                        deleteTrackEnvRegionAndShift(track, ctlId, patOff, ccb.block_length);
                     }

                     // Iterate deltatime / value pairs and copy from clipboard
                     int envIdx = 0;
                     loop(env.numElements / 2)
                     {
                        int   dt  = env[envIdx + 0];
                        float val = env[envIdx + 1];

                        envOff += dt;
                        patOff += dt;

                        if(envOff < ccb.block_length)  // paranoia, should always be true
                        {
                           insertReplaceEventAtRes(track, ctlId, val, patOff, 1);
                           uiTotalNumEvents++;
                        }
                        else break;

                        envIdx += 2;
                     }

                     // (todo) use ctlId mask array (optimization)
                     lastCtlId = ctlId;

                  } // if ctlId != lastCtlId

                  entryId++;
                  cursorX++;
               }

               cursorX = 0;
               trackNr++;
            }

         } // if numTracks
      } // if -1 != block_length

      return uiTotalNumEvents;
   }

   // <method.png>
   protected method clearScratchPattern() {

      NT_Track *track;
      foreach track in tracks
      {
         NT_TrackPattern pat <= track.getOrCreatePattern(tap_mode_scratch_pat_nr);
         if(null != pat)
         {
            pat.clearAllEnvelopes();
         }
      }

   }

   // <method.png>
   public =replay= method startTapMode() {

      if(!b_tap_mode)
      {
         Global.Debug("NT::startTapMode: source_pat_nr="+tap_mode_source_pat_nr+" step_res="+tap_mode_step_resolution+" keep_enabled="+b_tap_mode_keepenabled);

         // Set scratch pattern length to current pattern length
         NT_MetaPattern mpatCur <= getCurrentEditMetaPattern();

         if(null != mpatCur)
         {
            NT_MetaPattern mpatTmp <= getOrCreateMetaPattern(tap_mode_scratch_pat_nr);
            mpatTmp.num_ticks = mpatCur.num_ticks;
            // mapTmp.pat_name = "tmp";

            clearScratchPattern();
         }

         b_tap_mode = true;

         tap_mode_current_source_step = -1;
         tap_mode_queued_play_step = -1;

         // ////undoBeginNested("tap mode");
         // // undoBeginNested("record MIDI");

         // // undoTouchAllControllers(b_tap_mode_alltracks);
      }
   }

   // <method.png>
   public =replay= method stopTapMode(boolean _bForce) {

      if(b_tap_mode && (_bForce || !b_tap_mode_keepenabled))
      {
         Global.Debug("NT::stopTapMode");

         b_tap_mode = false;

         // // undoEndNested("tap mode");
         // undoEndNested("record MIDI");
      }
   }

   // <method.png>
   protected method copyStep(byte _patNrDst, int _patOffDst,
                             byte _patNrSrc, int _patOffSrc,
                             int _numTicks,
                             boolean _bAllTracks
                             ) {

      if(_numTicks > 0)
      {
         // Backup edit pattern/offset/clipboard
         SelectClipboard(CB_SECONDARY);
         int origEditPatternNr = edit_pattern_nr;
         int origEditOffset = pv_pat_offset;

         // Copy source step
         edit_pattern_nr = _patNrSrc;

         NT_Track track <= getTrack(_bAllTracks ? (tracks.numElements - 1) : pv_cursor_track);
         NT_TEL   tel   <= track.getTrackLayout();
         int              numCursorX = tel.num_cursor_positions;

         // trace "xxx numCursorX="+numCursorX+" patNrSrc="+_patNrSrc+" patOffSrc="+_patOffSrc+" numTicks="+_numTicks;

         blockSelectPatRangeRaw(_patOffSrc,
                                _bAllTracks ? 0 : pv_cursor_track, // startTrack
                                0 /*startX*/,
                                _patOffSrc + _numTicks, // endOff
                                _bAllTracks ? (tracks.numElements-1) : pv_cursor_track, // endTrack
                                numCursorX-1 // endX
                                );

         blockCopyRaw(0/*extraBlockEndTicks*/);

         // Paste destination step
         edit_pattern_nr = _patNrDst;
         pv_pat_offset = _patOffDst;

         blockPasteRaw(_bAllTracks ? 0 : pv_cursor_track, // trackNr
                       0 /*cursorX*/,
                       false/*bShift*/
                       );

         selectNoneRaw();

         // Restore edit pattern/offset/clipboard
         edit_pattern_nr = origEditPatternNr;
         pv_pat_offset = origEditOffset;
         SelectClipboard(CB_PRIMARY);
      }
   }

   // <method_set.png>
   public =replay= method setNoteOnToPrgChgBaseNote(byte _baseNote) {
      noteon_to_prgchg_base_note = _baseNote;
   }

   // <method_set.png>
   public =replay= method setEnableNoteOnToPrgChg(boolean _bEnabled) {
      b_noteon_to_prgchg = _bEnabled;
   }

   // <method_set.png>
   public =replay= method setNoteOffToPrgChgNoteOffset(int _offset) {
      noteoff_to_prgchg_note_offset = _offset;
   }

   // <method_set.png>
   public =replay= method uiSetEnableDiscardNotes(boolean _bEnabled) {
      b_ui_discard_notes = _bEnabled;
   }

   // <method_set.png>
   public =replay= method setEnableEchoFrameRecToPlay(boolean _bEnabled) {
      b_echo_frame_rec_to_play = _bEnabled;
   }

   // <method_set.png>
   public =replay= method setEnableExtClk(boolean _bEnabled) {
      b_extclk_resetval = _bEnabled;
      b_extclk = _bEnabled;
      b_jam_run = !b_extclk;
   }

   // <method_get.png>
   public method getEnableExtClk() : boolean {
      return b_extclk_resetval;
   }

   // <method_set.png>
   public =replay= method setExtClkGateTime(int _t) {
      if(_t < 1)
         _t = 1;
      extclk_gatetime_resetval = _t;
      extclk_gatetime_base = _t;
      extclk_gatetime = (extclk_gatetime_base * extclk_gatetime_mul) / extclk_gatetime_div;
   }

   // <method_get.png>
   public method getExtClkGateTime() : int {
      return extclk_gatetime_resetval;
   }

   // <method_set.png>
   public =replay= method setPlayMode(int _mode) {
      play_mode = _mode;
   }

   // <method_get.png>
   public method getPlayMode() : int {
      return play_mode;
   }

   // <method_set.png>
   public =replay= method setEnableChangeReset(boolean _bChangeReset) {
      b_change_reset = _bChangeReset;
      b_jam_restart = (false != b_change_reset);
   }

   // <method_get.png>
   public method getEnableChangeReset() : boolean {
      return b_change_reset;
   }

   // <method_set.png>
   public =replay= method setOffLenTicks(int _ticks) {
      if(_ticks < 1)
         _ticks = 1;
      offlen_ticks_resetval = _ticks;
   }

   // <method_get.png>
   public method getOffLenTicks() : int {
      return offlen_ticks_resetval;
   }

   // <method_set.png>
   public =replay= method setDurTicks(float _ticks) {
      if(_ticks < 1)
         _ticks = 1;
      dur_ticks_resetval = _ticks;
      dur_ticks = dur_ticks_resetval;
   }

   // <method_get.png>
   public method getDurTicks() : float {
      return dur_ticks_resetval;
   }

   // <method_set.png>
   public =replay= method setEnableMatchInstr(boolean _bEnable) {
      b_match_instr = _bEnable;
   }

   // <method_get.png>
   public method getEnableMatchInstr() : boolean {
      return b_match_instr;
   }

   // <method_set.png>
   public =replay= method setEnableRecPrev(boolean _bEnable) {
      b_rec_prev = _bEnable;
   }

   // <method_get.png>
   public method getEnableRecPrev() : boolean {
      return b_rec_prev;
   }

   // <method_set.png>
   public =replay= method setEnableRecAll(boolean _bEnable) {
      b_rec_all = _bEnable;
   }

   // <method_get.png>
   public method getEnableRecAll() : boolean {
      return b_rec_all;
   }

   // <method_set.png>
   public =replay= method setEnableRecSpread(boolean _bEnable) {
      b_rec_spread = _bEnable;
   }

   // <method_get.png>
   public method getEnableRecSpread() : boolean {
      return b_rec_spread;
   }

   // <method_set.png>
   public =replay= method setEnableRecBg(boolean _bEnable) {
      b_rec_bg = _bEnable;
   }

   // <method_get.png>
   public method getEnableRecBg() : boolean {
      return b_rec_bg;
   }

   // <method_set.png>
   public =replay= method setRecMode(int _mode) {
      rec_mode = _mode;
   }

   // <method_get.png>
   public method getRecMode() : int {
      return rec_mode;
   }

   // <method_set.png>
   public =replay= method setRecSel(int _sel) {
      rec_sel = _sel;
   }

   // <method_get.png>
   public method getRecSel() : int {
      return rec_sel;
   }

   // <method_set.png>
   public =replay= method setEnableRecQuantizeLastStep(boolean _bEnable) {
      b_rec_quantize_last_step = _bEnable;
   }

   // <method_get.png>
   public method getEnableRecQuantizeLastStep() : boolean {
      return b_rec_quantize_last_step;
   }

   // <method_set.png>
   public method setEnableChordClearStep(boolean _bEnabled) {
      b_chord_clear_step = _bEnabled;
   }

   // <method_get.png>
   public method getEnableChordClearStep() : boolean {
      return b_chord_clear_step;
   }

   // <method_get.png>
   public method doRecordNotes() : boolean {
      return (REC_SEL_NOTES == rec_sel) || (REC_SEL_NOTES_AND_CTLS == rec_sel);
   }

   // <method_get.png>
   public method doRecordCtls() : boolean {
      return (REC_SEL_NOTES_AND_CTLS == rec_sel) || (REC_SEL_CTLS == rec_sel) || (REC_SEL_CURRENT_CTL == rec_sel);
   }

   // <method_set.png>
   public =replay= method setArpBaseOctave(int _oct) {
      arp_base_octave = _oct;
   }

   // <method_get.png>
   public method getArpBaseOctave() : int {
      return arp_base_octave;
   }

   // <method_set.png>
   public =replay= method setEnableArp(boolean _bEnabled) {
      b_arp = _bEnabled;
   }

   // <method_get.png>
   public method getEnableArp() : boolean {
      return b_arp;
   }

   // <method_set.png>
   public =replay= method setEnableArpReset(boolean _bEnabled) {
      b_arp_reset = _bEnabled;
   }

   // <method_get.png>
   public method getEnableArpReset() : boolean {
      return b_arp_reset;
   }

   // <method_set.png>
   public =replay= method setEnableArpWrap(boolean _bEnabled) {
      b_arp_wrap = _bEnabled;
   }

   // <method_get.png>
   public method getEnableArpWrap() : boolean {
      return b_arp_wrap;
   }

   // <method_set.png>
   public =replay= method setArpLatchNumNotes(int _num) {
      arp_latch_num_notes = _num;

      if(0 == _num)
      {
         arp_active_notes = ext_active_notes;
         arp_latch_next_idx = 0;
         b_arp_dynalen_update_queued = true;
      }
   }

   // <method_get.png>
   public method getArpLatchNumNotes() : int {
      return arp_latch_num_notes;
   }

   // <method_set.png>
   public =replay= method setEnableArpLatchReset(boolean _bEnabled) {
      b_arp_latch_reset = _bEnabled;
   }

   // <method_get.png>
   public method getEnableArpLatchReset() : boolean {
      return b_arp_latch_reset;
   }

   // <method_set.png>
   public =replay= method setEnablePlayArpNotes(boolean _bEnabled) {
      b_arp_play_arp_notes = _bEnabled;
   }

   // <method_get.png>
   public method getEnablePlayArpNotes() : boolean {
      return b_arp_play_arp_notes;
   }

   // <method_set.png>
   public =replay= method setEnablePlayNonArpNotes(boolean _bEnabled) {
      b_arp_play_non_arp_notes = _bEnabled;
   }

   // <method_get.png>
   public method getEnablePlayNonArpNotes() : boolean {
      return b_arp_play_non_arp_notes;
   }

   // <method_set.png>
   public =replay= method setEnableArpDynaLen(boolean _bEnabled) {
      b_arp_dynalen = _bEnabled;

      if(!b_arp_dynalen)
      {
         jam_length = getMetaPatternLength(play_pattern_nr) / offlen_ticks_resetval;
      }
   }

   // <method_get.png>
   public method getEnableArpDynaLen() : boolean {
      return b_arp_dynalen;
   }

   // <method.png>
   public =replay= method incArpNote(int _idx) {
      if(_idx <= arp_note_table.numElements)
      {
         int note = arp_note_table[_idx];
         note++;
         if(note >= 12)
            note = 0;
         arp_note_table[_idx] = note;
      }
   }

   // <method.png>
   public =replay= method decArpNote(int _idx) {
      if(_idx <= arp_note_table.numElements)
      {
         int note = arp_note_table[_idx];
         note--;
         if(note < 0)
            note = 11;
         arp_note_table[_idx] = note;
      }
   }

   // <method.png>
   public =replay= method copyArpNotes(IntArray _newNotes) {
      arp_note_table = _newNotes;
   }

   // <method_set.png>
   public method setMicroShiftIdx(int _idx) {
      current_microshift_idx = _idx;
   }

   // <method_get.png>
   public method getMicroShiftIdx() : int {
      return current_microshift_idx;
   }

   // <method_get.png>
   public method getMicroShiftTicks() : int {
      int ret = STConfig.node_tracker_microshift_ticks.get(current_microshift_idx);
      if(ret < 1)
         ret = 1;
      return ret;
   }

    // <ui_render.png>
   public method queueStatusInfoChord() {
      b_ui_queued_status_info_chord = true;
   }

   // <replay.png>
   public virtual nodeQueuePattern(int _patNr, int _seekOff, boolean _bMuteTemp) {
      jam_queued_pattern_nr = _patNr;

      // trace "xxx NT::nodeQueuePattern: patNr="+_patNr+" seekOff="+_seekOff+" bMuteTemp="+_bMuteTemp+" jam_current_ticks="+jam_current_ticks;

      node_queued_com_seek_off = _seekOff;  // (note) -1 = dont seek

      node_queued_b_mute_temp = _bMuteTemp;

      ui_b_node_pattern_changed = true;

      Events.SendPlayPat();
   }

   // <replay.png>
   protected method queuePatternPC(int _patNr, int _seekOff, boolean _bMuteTemp) {
      if(b_debug_prgchg)
         trace "[trc] nt::queuePatternPC: song_offset="+current_song.song_offset+" patNr="+_patNr;

      nodeQueuePattern(_patNr, _seekOff, _bMuteTemp);

      if(STConfig.b_node_tracker_edit_pattern_follows_replay_pattern && replay.b_playing)
      // // if(STConfig.b_node_tracker_edit_pattern_follows_replay_pattern)
      {
         if(nodeIsEditorVisible() || b_rec_bg)
         {
            nodeSetCurrentEditPatternNr(_patNr);

            // // int patLen = getMetaPatternLength(_patNr);
            // // int patEditOff = pv_pat_offset;
            // // patEditOff = (patEditOff % patLen);
            int patEditOff = 0;
            int newOff;
            // trace "xxx nt::queuePatternPC: seekOff="+_seekOff;

            if(-1 != _seekOff)
            {
               // trace "xxx nt::queuePatternPC: seekOff="+_seekOff;
               if(b_debug_prgchg)
                  trace "[trc] nt::queuePatternPC<off>: song_offset="+current_song.song_offset+" patEditOff="+patEditOff+" seekOff="+_seekOff+" patNr="+_patNr;
               newOff = mathMaxi(0, current_song.song_offset - _seekOff - patEditOff);
               if(b_debug_prgchg)
                  trace "[trc] nt::queuePatternPC<off>: new patternStartEditorSongOffset="+newOff;
               edit_clip_start_ticks = -1;
               nodeSetLastPatternStartEditorSongOffset(newOff);
            }
            else
            {
               // e.g. manual pattern change
               int patLen = getMetaPatternLength(_patNr);
               int modTickNr = tick_nr % patLen;
               patEditOff = modTickNr;

               if(b_debug_prgchg)
                  trace "[trc] nt::queuePatternPC: song_offset="+current_song.song_offset+" patEditOff="+patEditOff+" patNr="+_patNr;
               newOff = mathMaxi(0, current_song.song_offset - patEditOff);
               if(b_debug_prgchg)
                  trace "[trc] nt::queuePatternPC: new patternStartEditorSongOffset="+newOff;
               edit_clip_start_ticks = -1;
               nodeSetLastPatternStartEditorSongOffset(newOff);
            }
         }
      }
   }

   // <method_handle.png>
   protected method handlePrgChg(MIDIPipeFrame _frame, boolean _bAllowSeekPrgChgAndMute) {
      int numPC = _frame.getNumEventsPrgChg();

      if(numPC > 0)
      {
         int pcIdx = 0;

         // // if(!replay.isPatternNode(this)) // don't recv program changes if node is in pattern replay mode
         if(_bAllowSeekPrgChgAndMute)
         {
            loop(numPC)
            {
               MIDIPipeEvent ev;
               _frame.getEventByIdx(pcIdx, ev, MIDIPIPE_EVENT_TYPE_PRGCHG);

               if(b_auto_filter_a && b_auto_recv_prgchg_a)
               {
                  if( (-1 == auto_dev_filter_a) || (auto_dev_filter_a == ev.devIdx) )
                  {
                     if( (-1 == auto_ch_filter_a) || (auto_ch_filter_a == ev.midiCh) )
                     {
                        queuePatternPC(ev.arg1, -1/*seekOff*/, false/*bMuteTemp*/);

                        Global.Debug3("nt: GID="+getNodeGID()+" queued pattern "+jam_queued_pattern_nr+" via PrgChg A");
                        // trace "\t\t this="+#(this);
                     }
                  }
               }

               if(b_auto_filter_b && b_auto_recv_prgchg_b)
               {
                  if( (-1 == auto_dev_filter_b) || (auto_dev_filter_b == ev.devIdx) )
                  {
                     if( (-1 == auto_ch_filter_b) || (auto_ch_filter_b == ev.midiCh) )
                     {
                        queuePatternPC(ev.arg1, -1/*seekOff*/, false/*bMuteTemp*/);

                        Global.Debug3("nt: GID="+getNodeGID()+" queued pattern "+jam_queued_pattern_nr+" via PrgChg B");
                        // trace "\t\t this="+#(this);
                     }
                  }
               }

               pcIdx++;
            }

         }
      }

      // Handle timeline recordable program change
      short t = getFrameRPN(_frame, RPN_COMMON_UI_PRGCHG);
      // if(_frame.numEventsNRPN > 0)
      //    trace "xxx nt: frame.numEventsNRPN="+_frame.numEventsNRPN+" t="+t;
      if(t >= 0)
      {
         // trace "xxx nt: RPN_COMMON_UI_PRGCHG t="+t;
         queuePatternPC(t, -1/*seekOff*/, false/*bMuteTemp*/);
         replay.addUIPrgChgEntry(getNodeGID(), t);
      }
   }

   // <method.png>
   public =replay= method queueForcedSmpUID(short _smpUID, int _devIdx, byte _midiCh) {
      queued_forced_smp_uid     = _smpUID;
      queued_forced_smp_dev_idx = _devIdx;
      queued_forced_smp_midi_ch = _midiCh;
   }

   // <method_get.png>
   public method getFirstTrackRPNSmpPeakEnvelope(byte _patNr) : Envelope {
      if(tracks.numElements > 0)
      {
         NT_Track track <= getTrack(0);
         NT_Instrument ins <= getInstrument(track.current_instrument_nr);
         if(null != ins)
         {
            NT_MIDIParam param <= ins.findParamForTypeAndMSBCCOrNRPN(NT_MIDIParam.TYPE_RPN, 87/*smp_peak*/);
            if(null != param)
            {
               // (todo) check if param is actually visible ?
               NT_TrackPattern trackPat <= track.getPattern(_patNr);
               if(null != trackPat)
               {
                  Envelope env <= trackPat.getEnvelope(NT_TrackPattern.CTL_USR + param.id);
                  return env;
               }
            }
         }
      }
      return null;
   }

   // <method.png>
   public method trySelectSampleInEureka(short _smpUID, int _vstDevIdx, byte _midiCh) {
      if(-1 != _vstDevIdx)
      {
         // Select sample in Eureka
         Global.Debug2("NodeTracker::trySelectSampleInEureka: smpUID="+_smpUID+" vstDevIdx="+_vstDevIdx+" midiCh="+_midiCh);
         queueForcedSmpUID(_smpUID, _vstDevIdx, _midiCh);

         // Wait up to 500ms until sample has been selected (replay thread)
         loop(10)
         {
            TKS.sleep(50);
            if(-1 == queued_forced_smp_uid)
               break;
         }
      }
   }

   // <method.png>
   public method trySelectSampleInEurekaOnCurrentTrack(short _smpUID) {
      // called by NT_AudioDialog (after creating new sample)
      NT_Instrument instr <= getCurrentTrackInstrument();
      if(null != instr)
      {
         trySelectSampleInEureka(_smpUID,
                                 instr.getOutDeviceIdx(),
                                 instr.midi_channel
                                 );
      }
   }

   // <method.png>
   public method tryEditSampleInEureka(short   _smpUID,
                                       int     _vstDevIdx,
                                       byte    _midiCh,
                                       boolean _bShowEurekaWindow,
                                       float   _selStartMS,
                                       float   _selLenMS
                                       ) {
      // Select sample
      Global.Debug2("NodeTracker::tryEditSampleInEureka: smpUID="+_smpUID+" vstDevIdx="+_vstDevIdx+" midiCh="+_midiCh+" bShowEurekaWindow="+_bShowEurekaWindow);

      trySelectSampleInEureka(_smpUID, _vstDevIdx, _midiCh);

      // Show Eureka sampleeditor (PageSample) for first ModSample that plays the given sample
      SysEx.QueueSendSmpEdit(_smpUID, -1/*instanceIdHint*/, _selStartMS/*selStartMS*/, _selLenMS/*-1==keep*/, -1/*noteIdxHint*/);

      Global.Print("Edit smpUID="+_smpUID+" startMS="+_selStartMS+" lenMS="+_selLenMS+" dev="+_vstDevIdx+" ch="+(_midiCh+1));

      if(_bShowEurekaWindow)
         root_form.showEurekaWindow(true/*bFocus*/);
   }

   // <method.png>
   public method tryEditCurrentTrackSampleInEureka(short _smpUID, boolean _bShowEurekaWindow) {
      // called by NT_AudioDialog
      NT_Instrument instr <= getCurrentTrackInstrument();
      if(null != instr)
      {
         tryEditSampleInEureka(_smpUID,
                               instr.getOutDeviceIdx(),
                               instr.midi_channel,
                               _bShowEurekaWindow,
                               0/*selStartMS*/,
                               -1/*selLenMS=keep*/
                               );
      }
   }

   // <ui_handle.png>
   public method tryEditAudioPatternSampleInEureka(byte _patNr, int _ticks, boolean _bShowEurekaWindow) : boolean {
      // Called by NA_TimelineData::editFirstSelectedClip() (lshift-RETURN)
      if(tracks.numElements > 0)
      {
         NT_Track track <= getTrack(0);
         NT_Instrument instr <= getInstrument(track.current_instrument_nr);
         if(null != instr && null != instr.out_device)
         {
            if(maybe == instr.b_audio)  // select smp_uid instead of program change ?
            {
               NT_TrackPattern trackPat <= track.getPattern(_patNr);
               if(null != trackPat)
               {
                  NT_MetaPattern mpat <= meta_patterns.get(_patNr);
                  _ticks = _ticks % mpat.num_ticks;

                  Envelope env <= trackPat.getEnvelope(NT_TrackPattern.CTL_PC);
                  if(null != env)
                  {
                     var lastPCBeforeSmpStart = env.valueAtTimeSH(_ticks);
                     if(lastPCBeforeSmpStart > 0)
                     {
                        // trace "xxx instr.out_device="+#(instr.out_device)+" outDeviceIdx="+instr.getOutDeviceIdx();
                        tryEditSampleInEureka(lastPCBeforeSmpStart/*smp_uid*/,
                                              instr.getOutDeviceIdx(),
                                              instr.midi_channel,
                                              _bShowEurekaWindow,
                                              0/*selStartMS*/,
                                              -1/*selLenMS=keep*/
                                              );
                        return true;
                     }
                  }
               }
            }
         }
      }
      return false;
   }

   // <method_handle.png>
   protected method handleExtNotes(MIDIPipeFrame _frame) {

      if(b_auto_filter_a || b_auto_filter_b)
      {
         boolean bProcess;
         MIDIPipeEvent ev;
         int noteIdx;

         // Process all-notes-off events
         int numAllNotesOff = _frame.getNumEventsAllNotesOff();

         noteIdx = 0;

         loop(numAllNotesOff)
         {
            _frame.getEventByIdx(noteIdx, ev, MIDIPIPE_EVENT_TYPE_ALL_NOTES_OFF);

            bProcess = false;

            if(b_auto_filter_a)
            {
               if( (-1 == auto_dev_filter_a) || (auto_dev_filter_a == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_a) || (auto_ch_filter_a == ev.midiCh) )
                  {
                     bProcess = true;
                  }
               }
            }

            if(b_auto_filter_b)
            {
               if( (-1 == auto_dev_filter_b) || (auto_dev_filter_b == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_b) || (auto_ch_filter_b == ev.midiCh) )
                  {
                     bProcess = true;
                  }
               }
            }

            // trace "xxx ext all notes off 1 bProcess="+bProcess+" ev.devIdx="+ev.devIdx+" ev.midiCh="+ev.midiCh+" dev_filter_a="+auto_dev_filter_a;

            if(bProcess)
            {
               // trace "xxx ext all notes off";
               int enote;
               foreach enote in ext_active_notes
               {
                  tick_ext_note_offs.add(enote);
                  tick_ext_note_off_vels.add(0);
               }
            }

            noteIdx++;
         }


         // Process note-on events
         int numNoteOn = _frame.getNumEventsNoteOn();
         noteIdx = 0;

         loop(numNoteOn)
         {
            _frame.getEventByIdx(noteIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_ON);

            bProcess = false;

            if(b_auto_filter_a)
            {
               if( (-1 == auto_dev_filter_a) || (auto_dev_filter_a == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_a) || (auto_ch_filter_a == ev.midiCh) )
                  {
                     bProcess = true;
                  }
               }
            }

            if(b_auto_filter_b)
            {
               if( (-1 == auto_dev_filter_b) || (auto_dev_filter_b == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_b) || (auto_ch_filter_b == ev.midiCh) )
                  {
                     bProcess = true;
                  }
               }
            }

            if(bProcess)
            {
               tick_ext_note_ons.add(ev.arg1);
               tick_ext_note_on_vels.add(ev.arg2);
            }

            noteIdx++;
         }

         // Process note-off events
         int numNoteOff = _frame.getNumEventsNoteOff();

         noteIdx = 0;

         loop(numNoteOff)
         {
            _frame.getEventByIdx(noteIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_OFF);

            bProcess = false;

            if(b_auto_filter_a)
            {
               if( (-1 == auto_dev_filter_a) || (auto_dev_filter_a == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_a) || (auto_ch_filter_a == ev.midiCh) )
                  {
                     bProcess = true;
                  }
               }
            }

            if(b_auto_filter_b)
            {
               if( (-1 == auto_dev_filter_b) || (auto_dev_filter_b == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_b) || (auto_ch_filter_b == ev.midiCh) )
                  {
                     bProcess = true;
                  }
               }
            }

            if(bProcess)
            {
               tick_ext_note_offs.add(ev.arg1);
               tick_ext_note_off_vels.add(ev.arg2);
            }

            noteIdx++;
         }


      }
   }

   // <method_handle.png>
   protected method handleExtActiveNotes() {

      int noteNr;

      // if(tick_ext_note_offs.numElements > 0)
      // {
      //    trace "xxx nt::handleExtActiveNotes: tick_ext_note_offs="+#(tick_ext_note_offs);
      // }

      foreach noteNr in tick_ext_note_offs
      {
         int activeNoteIdx = ext_active_notes.indexOf(noteNr, 0);
         if(-1 != activeNoteIdx)
         {
            ext_active_notes.delete(activeNoteIdx);

            if(0 == arp_latch_num_notes)
            {
               arp_active_notes.delete(arp_active_notes.indexOf(noteNr, 0));

               if(b_arp_dynalen)
               {
                  b_arp_dynalen_update_queued = true;
               }
            }

            // trace "xxx nt: delete: ext_active_notes="+#(ext_active_notes);
            // trace "xxx nt: delete: arp_active_notes="+#(arp_active_notes);
         }
      }

      // // if(tick_ext_note_ons.numElements > 0)
      // // {
      // //    trace "xxx nt::handleExtActiveNotes: tick_ext_note_ons="+#(tick_ext_note_ons);
      // // }

      foreach noteNr in tick_ext_note_ons
      {
         if(-1 == ext_active_notes.indexOf(noteNr, 0))
         {
            b_tick_ext_first_note |= (0 == ext_active_notes.numElements);
            ext_active_notes.add(noteNr);

            if(arp_latch_num_notes > 0)
            {
               if((1 == ext_active_notes.numElements) && b_arp_latch_reset)
               {
                  arp_latch_next_idx = 0;
                  arp_active_notes.empty();
               }

               if(arp_latch_next_idx < arp_active_notes.numElements)
               {
                  arp_active_notes[arp_latch_next_idx] = noteNr;
               }
               else
               {
                  arp_active_notes.add(noteNr);
               }

               arp_latch_next_idx = (arp_latch_next_idx + 1) % arp_latch_num_notes;
            }
            else
            {
               arp_active_notes.add(noteNr);
            }

            // trace "xxx nt: add: ext_active_notes="+#(ext_active_notes);
            // trace "xxx nt: add: arp_active_notes="+#(arp_active_notes);

            if(b_arp_dynalen)
            {
               b_arp_dynalen_update_queued = true;
            }
         }
      }

   }

   // <method_set.png>
   public =replay= virtual nodeSetPattern(int _idx, NT_MetaPattern _pat) {
      meta_patterns[_idx & 127] = deref _pat;
   }

   // <method.png>
   public =replay= virtual nodeSwapPatterns(int _idxA, int _idxB) {
      NT_MetaPattern a <= meta_patterns.get(_idxA);
      NT_MetaPattern b <= meta_patterns.get(_idxB);

      meta_patterns.swap(_idxA, _idxB);

      if(null != a)
      {
         a.pat_nr = _idxB;
      }
      if(null != b)
      {
         b.pat_nr = _idxA;
      }

      NT_Track *track;

      foreach track in tracks
      {
         PointerArray trackPatterns <= track.patterns;

         NT_TrackPattern trackPatA <= trackPatterns.get(_idxA);
         NT_TrackPattern trackPatB <= trackPatterns.get(_idxB);

         trackPatterns.swap(_idxA, _idxB);

         if(null != trackPatA)
         {
            trackPatA.pat_nr = _idxB;
            trackPatA.meta_pattern <= b;
         }

         if(null != trackPatB)
         {
            trackPatB.pat_nr = _idxA;
            trackPatB.meta_pattern <= a;
         }
      }

   }

   // <method_set.png>
   public =replay= virtual nodeSetCurrentPlayPatternNr(int _patNr) {
      // trace "xxx NT:nodeSetCurrentPlayPatternNr("+_patNr+")";
      Node::nodeSetCurrentPlayPatternNr(_patNr);

      int seekTicks = tick_nr + nodeGetLastPatternStartSongOffset();
      nodeSeek(seekTicks);
   }

   // <method_get.png>
   public virtual nodeIsPatternEmpty(int _patNr) : boolean {
      NT_MetaPattern mpat <= meta_patterns.get(_patNr);
      if(null != mpat)
         return mpat.b_empty;
      else
         return true;
   }

   // <method_get.png>
   public method isPatternEmptyCheck(int _patNr) : boolean {
      NT_MetaPattern mpat <= meta_patterns.get(_patNr);
      if(null != mpat)
      {
         if(mpat.num_ticks > 0)
            return false;

         NT_Track *track;
         foreach track in tracks
         {
            if(!track.areAllPatternsEmpty())
               return false;
         }
      }
      return true;
   }

   // <method.png>
   public virtual nodeFindPatternByEvents(NodePattern _o) : int {

      NT_MetaPattern om <= _o;

      local Buffer bufO;
      bufO.size = MAX_FIND_PAT_STATE_SIZE;
      bufO.offset = 0;
      om.saveEventData(bufO);

      local Buffer bufCur;
      bufCur.size = MAX_FIND_PAT_STATE_SIZE;

      int patIdx = 0;

      loop(NUM_PATTERNS)
      {
         NT_MetaPattern pat <= nodeGetPatternByIdx(patIdx);
         if(null != pat)
         {
            if(!pat.patIsEmpty())
            {
               bufCur.offset = 0;
               pat.saveEventData(bufCur);

               // trace "xxx compare patIdx="+patIdx+" bufCur.offset="+bufCur.offset+" bufO.offset="+bufO.offset;
               // local File f;
               // if(f.openLocal("xxx_bufcur.bin", IOS_OUT))
               // {
               //    f.writeBuffer(bufCur, 0, bufCur.offset);
               //    f.close();
               // }
               // if(f.openLocal("xxx_bufo.bin", IOS_OUT))
               // {
               //    f.writeBuffer(bufO, 0, bufO.offset);
               //    f.close();
               // }

               if(bufCur.compareBuffer(bufO))
               {
                  trace "[>>>] NodeTracker::nodeFindPatternByEvents: found patIdx="+patIdx;
                  return patIdx;
               }
            }
         }

         patIdx++;
      }

      return -1;
   }

   // <method_get.png>
   public =replay= virtual nodeGetPatternByIdx(int _idx) : NT_MetaPattern {
      return meta_patterns.get(_idx);
   }

   // <method_get.png>
   public =replay= virtual nodeGetCurrentPlayPattern() : NT_MetaPattern {
      return meta_patterns.get(play_pattern_nr);
   }

   // <method_get.png>
   public virtual nodeGetCurrentPlayPatternNumTicks() : int {
      NT_MetaPattern mpat <= nodeGetCurrentPlayPattern();
      if(null != mpat)
         return mpat.num_ticks; // (note) do _not_ scale by speed
      return 0;
   }

   // <method_get.png>
   public virtual nodeGetPatternNumTicks(local byte _patIdx) : int {
      NT_MetaPattern mpat <= nodeGetPatternByIdx(_patIdx);
      if(null != mpat)
         return mpat.num_ticks; // (note) do _not_ scale by speed
      return 0;
   }

   // <method.png>
   public virtual nodeGetCurrentPlayPatternTickOffset() : int {
      return tick_nr;
   }

   // <method_get.png>
   public =replay= method getInstrument(local int _idx) : NT_Instrument {
      return instruments.get(_idx);
   }

   // <method_set.png>
   public =replay= method setInstrument(int _idx, NT_Instrument _ins) {
      instruments[_idx & 127] = deref _ins;
   }

   // <method.png>
   public method findFirstUnusedInstrumentSlot() : int {
      int insNr = instruments.indexOfPointer(null, 1/*0 is reserved for empty instr*/);
      return insNr;
   }

   // <method.png>
   public =replay= method freeAllInstruments() {
      int instrIdx = 0;
      loop(instruments.numElements)
      {
         instruments[instrIdx] = null;
         instrIdx++;
      }
   }

   // <method_find.png>
   public method findInstrumentByPartialName(String _substring) : NT_Instrument {
      NT_Instrument *ins;
      foreach ins in instruments
      {
         if(null != ins)
         {
            if(ins.name & _substring)
               return ins;
         }
      }
      return null;
   }

   // <method_find.png>
   public method findInstrumentByUniqueId(int _smpUID) : NT_Instrument {
      NT_Instrument *ins;
      foreach ins in instruments
      {
         if(null != ins)
         {
            if(ins.smp_uid == _smpUID)
               return ins;
         }
      }
      return null;
   }

   // <method.png>
   public method lazyCreateInstrumentByDevCh(int _devIdx, byte _midiCh, String _newInsNameHint, boolean _bNeedFreeParam) : NT_Instrument {
      Global.Debug3("nt::lazyCreateInstrumentByDevCh: devIdx="+_devIdx+" midiCh="+_midiCh+" insName="+_newInsNameHint);

      NT_Instrument *ins;
      foreach ins in instruments
      {
         if(null != ins)
         {
            if(ins.usesDevCh(_devIdx, _midiCh))
            {
               if(_bNeedFreeParam)
               {
                  if(ins.getNumFreeParams() >= 1)
                     return ins;
               }
               else
               {
                  return ins;
               }
            }
         }
      }

      int newInstrNr = findFirstUnusedInstrumentSlot();
      Global.Debug2("nt::lazyCreateInstrumentByDevCh: newInstrNr="+newInstrNr+" this="+#(this));
      if(-1 != newInstrNr)
      {
         ins <= new NT_Instrument;
         ins.init(this, newInstrNr/*instrument_nr placeholder*/);
         ins.setOutDevice(MIDI.GetMIDIOutDeviceByIndex(_devIdx));
         ins.setMidiChannel(_midiCh);
         ins.name = _newInsNameHint;
         ins.b_name_edited = false;
         setInstrument(newInstrNr, deref ins);
         return ins;
      }

      return null;
   }

   // <method.png>
   public method lazyCreateInstrumentByDevChAndName(int _devIdx, byte _midiCh, String _name) : NT_Instrument {
      NT_Instrument *ins;
      foreach ins in instruments
      {
         if(null != ins)
         {
            if(ins.usesDevCh(_devIdx, _midiCh))
            {
               if(ins.name == _name)
                  return ins;
            }
         }
      }

      int newInstrNr = findFirstUnusedInstrumentSlot();
      if(-1 != newInstrNr)
      {
         ins <= new NT_Instrument;
         ins.init(this, newInstrNr/*instrument_nr placeholder*/);
         ins.setOutDevice(MIDI.GetMIDIOutDeviceByIndex(_devIdx));
         ins.setMidiChannel(_midiCh);
         ins.name = _name;
         ins.b_name_edited = !_name.isBlank();
         setInstrument(newInstrNr, deref ins);
         return ins;
      }

      return null;
   }

   // <method.png>
   public method initInstrumentAt(int _instrNr, int _devIdx, byte _midiCh, byte _prgId, String _newInsNameHint) : NT_Instrument {
      Global.Debug("initInstrumentAt: instrNr="+_instrNr+" devIdx="+_devIdx+" midiCh="+_midiCh+" prgId="+_prgId+" insName="+_newInsNameHint);

      NT_Instrument ins <= instruments.get(_instrNr);
      if(null == ins)
      {
         ins <= new NT_Instrument;
         ins.init(this, _instrNr/*instrument_nr placeholder*/);
         setInstrument(_instrNr, deref ins);
      }

      ins.setOutDevice(MIDI.GetMIDIOutDeviceByIndex(_devIdx));
      ins.setMidiChannel(_midiCh);
      ins.name = _newInsNameHint;
      ins.b_name_edited = true;
      ins.b_program = (-1 != _prgId);
      ins.program = _prgId;
      return ins;
   }

   // <method.png>
   public method isAutoDevCh(int _devIdx, byte _midiCh) : boolean {
      if( (-1 != auto_dev_filter_a) && (_devIdx == auto_dev_filter_a) )
      {
         if( (-1 != auto_ch_filter_a) && (_midiCh == auto_ch_filter_a) )
         {
            return true;
         }
      }

      if( (-1 != auto_dev_filter_b) && (_devIdx == auto_dev_filter_b) )
      {
         if( (-1 != auto_ch_filter_b) && (_midiCh == auto_ch_filter_b) )
         {
            return true;
         }
      }

      return false;
   }

   // <method.png>
   public method lazyCreateInstrumentsAndParamsByFrame(MIDIPipeFrame _frame,
                                                       String        _insNamePrefix,
                                                       String        _insNameSuffix,
                                                       boolean       _bPreferCTL_PC,
                                                       boolean       _bConvRPNPC
                                                       ) : boolean {
      NT_Instrument *ins;
      NT_MIDIParam *param;
      MIDIPipeEvent ev;
      boolean ret = true;
      boolean bParamDone;
      STX_MIDIOutDevice *outDev;

      int numNoteOn = _frame.getNumEventsNoteOn();
      int evIdx = 0;

      local String *insName;

      // Note on
      loop(numNoteOn)
      {
         _frame.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_ON);

         if(!isAutoDevCh(ev.devIdx, ev.midiCh))
         {
            insName <= _insNamePrefix+MIDI.GetMIDIOutAliasOrDeviceNameAndChStringByIndex(ev.devIdx, ev.midiCh)+_insNameSuffix;
            lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, false/*bNeedFreeParam*/);
         }

         evIdx++;
      }

      // Note off
      int numNoteOff = _frame.getNumEventsNoteOff();
      evIdx = 0;

      loop(numNoteOff)
      {
         _frame.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_OFF);

         if(!isAutoDevCh(ev.devIdx, ev.midiCh))
         {
            insName <= _insNamePrefix+MIDI.GetMIDIOutAliasOrDeviceNameAndChStringByIndex(ev.devIdx, ev.midiCh)+_insNameSuffix;
            lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, false/*bNeedFreeParam*/);
         }

         evIdx++;
      }

      // PrgChg
      int numPrgChg = _frame.getNumEventsPrgChg();
      evIdx = 0;

      loop(numPrgChg)
      {
         _frame.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_PRGCHG);

         if(!isAutoDevCh(ev.devIdx, ev.midiCh))
         {
            insName <= _insNamePrefix+MIDI.GetMIDIOutAliasOrDeviceNameAndChStringByIndex(ev.devIdx, ev.midiCh)+_insNameSuffix;
            ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, false/*bNeedFreeParam*/);

            bParamDone = false;

            if(null != ins)
            {
               if(_bPreferCTL_PC)
               {
                  // Use regular CTL_PC instead of usrctl param
                  bParamDone = true;
               }
               else
               {
                  if(null != ins.findParamForTypeAndMSBCCOrNRPN(NT_MIDIParam.TYPE_PRGCHG, -1))
                  {
                     bParamDone = true;
                  }
                  else
                  {
                     ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, true/*bNeedFreeParam*/);
                  }
               }
            }

            if(!bParamDone)
            {
               if(null != ins)
               {
                  param <= ins.createNewParam(-1);
                  param.type = NT_MIDIParam.TYPE_PRGCHG;
                  param.name = "PrgChg";
               }
               else
               {
                  trace "[---] NT::lazyCreateInstrumentsAndParamsByFrame: failed to create PrgChg ins/param";
                  ret = false;
               }
            }
         }

         evIdx++;
      }

      // CC
      int numCC = _frame.getNumEventsCC();
      evIdx = 0;

      loop(numCC)
      {
         _frame.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_CC);

         if(!isAutoDevCh(ev.devIdx, ev.midiCh))
         {
            insName <= _insNamePrefix+MIDI.GetMIDIOutAliasOrDeviceNameAndChStringByIndex(ev.devIdx, ev.midiCh)+_insNameSuffix;
            ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, false/*bNeedFreeParam*/);

            bParamDone = false;

            if(null != ins)
            {
               if(null != ins.findParamForTypeAndMSBCCOrNRPN(NT_MIDIParam.TYPE_CC, ev.ccId))
               {
                  bParamDone = true;
               }
               else
               {
                  ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, true/*bNeedFreeParam*/);
               }
            }

            if(!bParamDone)
            {
               if(null != ins)
               {
                  param <= ins.createNewParam(-1);
                  param.type = NT_MIDIParam.TYPE_CC;
                  param.cc_msb_id = ev.ccId;
                  outDev <= MIDI.GetMIDIOutDeviceByIndex(ev.devIdx);
                  if(null != outDev)
                  {
                     param.name = outDev.getCCLongNameByCtl(ev.midiCh, ev.ccId);
                  }
                  else
                  {
                     param.name = "CC#"+ev.ccId;
                  }
               }
               else
               {
                  trace "[---] NT::lazyCreateInstrumentsAndParamsByFrame: failed to create CC ins/param";
                  ret = false;
               }
            }
         }

         evIdx++;
      }

      // RPN
      int numRPN = _frame.getNumEventsRPN();
      evIdx = 0;

      loop(numRPN)
      {
         _frame.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN);

         if(!isAutoDevCh(ev.devIdx, ev.midiCh))
         {
            insName <= _insNamePrefix+MIDI.GetMIDIOutAliasOrDeviceNameAndChStringByIndex(ev.devIdx, ev.midiCh)+_insNameSuffix;
            ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, false/*bNeedFreeParam*/);

            if(Node.RPN_IMPORT_DUMMY != ev.rpn)
            {
               bParamDone = false;

               if(null != ins)
               {
                  if(_bConvRPNPC && (Node.RPN_COMMON_UI_PRGCHG == ev.rpn))
                  {
                     // Skip userctl param, will be converted to CTL_PC during import
                     bParamDone = true;
                  }
                  else
                     if(null != ins.findParamForTypeAndMSBCCOrNRPN(NT_MIDIParam.TYPE_RPN, ev.rpn))
                     {
                        bParamDone = true;
                     }
                     else
                     {
                        ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, true/*bNeedFreeParam*/);
                     }
               }

               if(!bParamDone)
               {
                  if(null != ins)
                  {
                     param <= ins.createNewParam(-1);
                     param.type = NT_MIDIParam.TYPE_RPN;
                     param.rpn_id = ev.rpn;
                     param.b_scale14bit = false;

                     outDev <= MIDI.GetMIDIOutDeviceByIndex(ev.devIdx);
                     if(null != outDev)
                     {
                        param.name = outDev.getRPNLongNameByNr(ev.midiCh, ev.rpn);
                        int rpnMax = outDev.getRPNMax(ev.midiCh, ev.rpn);
                        if(16383 == rpnMax)
                        {
                           // e.g. internal/Eureka Ctl 1..32 (0..16383)
                           param.b_scale14bit = true;
                           param.ui_range = NT_CEL.RANGE_0_255;
                           param.ui_style = NT_CEL.STYLE_BAR4;
                        }
                        else if(rpnMax > 127)
                        {
                           param.ui_range = NT_CEL.RANGE_0_255;
                        }
                        // else: keep default value range 0..127
                     }
                     else
                     {
                        param.name = "RPN#"+ev.rpn;
                     }
                  }
                  else
                  {
                     trace "[---] NT::lazyCreateInstrumentsAndParamsByFrame: failed to create RPN ins/param";
                     ret = false;
                  }
               }
            } // if !RPN_IMPORT_DUMMY
         }

         evIdx++;
      }

      // NRPN
      int numNRPN = _frame.getNumEventsNRPN();
      evIdx = 0;

      loop(numNRPN)
      {
         _frame.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_NRPN);

         if(!isAutoDevCh(ev.devIdx, ev.midiCh))
         {
            insName <= _insNamePrefix+MIDI.GetMIDIOutAliasOrDeviceNameAndChStringByIndex(ev.devIdx, ev.midiCh)+_insNameSuffix;
            ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, false/*bNeedFreeParam*/);

            bParamDone = false;

            if(null != ins)
            {
               if(null != ins.findParamForTypeAndMSBCCOrNRPN(NT_MIDIParam.TYPE_NRPN, ev.nrpn))
               {
                  bParamDone = true;
               }
               else
               {
                  ins <= lazyCreateInstrumentByDevCh(ev.devIdx, ev.midiCh, insName, true/*bNeedFreeParam*/);
               }
            }

            if(!bParamDone)
            {
               if(null != ins)
               {
                  param <= ins.createNewParam(-1);
                  param.type = NT_MIDIParam.TYPE_NRPN;
                  param.nrpn_id = ev.nrpn;
                  param.b_scale14bit = false;

                  outDev <= MIDI.GetMIDIOutDeviceByIndex(ev.devIdx);
                  if(null != outDev)
                  {
                     param.name = outDev.getNRPNLongNameByNr(ev.midiCh, ev.nrpn);
                     int nrpnMax = outDev.getNRPNMax(ev.midiCh, ev.nrpn);
                     if(16383 == nrpnMax)
                     {
                        // display as 0..255 (and scale back to original 0..16383 range during replay)
                        param.b_scale14bit = true;
                        param.ui_range = NT_CEL.RANGE_0_255;
                        param.ui_style = NT_CEL.STYLE_BAR4;
                     }
                     else if(nrpnMax > 127)
                     {
                        param.ui_range = NT_CEL.RANGE_0_255;
                     }
                     // else: keep default value range 0..127
                  }
                  else
                  {
                     param.name = "NRPN#"+ev.nrpn;
                  }
               }
               else
               {
                  trace "[---] NT::lazyCreateInstrumentsAndParamsByFrame: failed to create NRPN ins/param";
                  ret = false;
               }
            }
         }

         evIdx++;
      }

      return ret;
   }

   // <method_get.png>
   static GetControllerName(NT_Instrument _insHint, int _ctlId) : String {
      if(_ctlId >= NT_TrackPattern.CTL_USR)
      {
         int usrCtlId = _ctlId - NT_TrackPattern.CTL_USR;
         if(null != _insHint)
         {
            return "CTL_USR"+(usrCtlId+1)+" ("+_insHint.getUsrCtlParamName(usrCtlId)+" )";
         }
         else
         {
            return "CTL_USR"+(usrCtlId+1)+" (???)";
         }
      }
      else
      {
         return MNT_PatternView.ctl_names[_ctlId];
      }
   }

   // <method_set.png>
   public method setSoloTrackNr(int _trackNr) {
      solo_track_nr = _trackNr;

      // Immediately stop voices
      if(-1 != solo_track_nr)
      {
         int trackNr = 0;
         NT_Track *track;

         foreach track in tracks
         {
            if(trackNr != solo_track_nr)
            {
               track.stopCurrentVoices();
            }
            trackNr++;
         }
      }
   }

   // <method_get.png>
   public method getTrack(local int _i) : NT_Track {
      explain "Return reference to track (0..n).";
      if(0 <= _i < tracks.numElements)
         return tracks[_i];
      return null;
   }

   // <method_get.png>
   public method getCurrentTrackNr() : int {
      return pv_cursor_track;
   }

   // <method_get.png>
   public virtual nodeGetCursorTrack() : int {
      return pv_cursor_track;
   }

   // <method_get.png>
   public method getCurrentTrack() : NT_Track {
      return getTrack(pv_cursor_track);
   }

   // <method_get.png>
   public method findFirstUnusedPattern(int _startOff) : int {
      int patIdx = _startOff;
      while(patIdx < 128)
      {
         NT_MetaPattern mpat <= meta_patterns.get(patIdx);
         if(null != mpat)
         {
            if(mpat.b_empty)
            {
               return patIdx;
            }
         }
         else
         {
            return patIdx;
         }

         patIdx++;
      }

      return -1;
   }

   // <method_get.png>
   public method findFirstUnusedPatternGroup(int _startOff) : int {
      _startOff = (_startOff & ~3);

      int patIdx = _startOff;
      while(patIdx < 128)
      {
         NT_MetaPattern mpat <= meta_patterns.get(patIdx);
         if(null != mpat)
         {
            if(mpat.b_empty)
               return patIdx;
         }
         else
         {
            return patIdx;
         }

         patIdx += 4;
      }

      return -1;
   }

   // <method_get.png>
   public method findFirstUnusedPatternSub(int _startOff) : int {
      _startOff = (_startOff & ~3);

      int patIdx = _startOff;
      while(patIdx < (_startOff + 4))
      {
         NT_MetaPattern mpat <= meta_patterns.get(patIdx);
         if(null != mpat)
         {
            if(mpat.b_empty)
               return patIdx;
         }
         else
         {
            return patIdx;
         }

         patIdx ++;
      }

      return -1;
   }

   // <method_get.png>
   public method getOrCreateMetaPattern(int _patNr) : NT_MetaPattern {
      NT_MetaPattern mpat <= meta_patterns.get(_patNr);
      if(null == mpat)
      {
         if(_patNr >= 0)
         {
            mpat <= new NT_MetaPattern;
            mpat.patInit(this, _patNr);
            mpat.b_empty = false;
            meta_patterns[_patNr] = deref mpat;
         }
      }
      return mpat;
   }

   // <method_get.png>
   public method getMetaPattern(int _patNr) : NT_MetaPattern {
      return meta_patterns.get(_patNr);
   }

   // <method_get.png>
   public method getCurrentEditMetaPattern() : NT_MetaPattern {
      return meta_patterns.get(edit_pattern_nr);
   }

   // <method_get.png>
   public method getMetaPatternLength(int _patNr) : int {
      NT_MetaPattern mp <= meta_patterns.get(_patNr);
      if(null != mp)
         return mp.num_ticks;
      return 0;
   }

   // <method_get.png>
   public method getCurrentEditMetaPatternLength() : int {
      return getMetaPatternLength(edit_pattern_nr);
   }

   // <method_get.png>
   public virtual nodeGetTotalNumPatternEvents(int _patNr) : int {
      int r = 0;
      NT_Track *track;
      foreach track in tracks
      {
         NT_TrackPattern pat <= track.getPattern(_patNr);
         if(null != pat)
         {
            Envelope *env;
            foreach env in pat.controllers
            {
               if(null != env)
                  r += env.numElements / 2;  // time,value pairs
            }
         }
      }
      return r;
   }

   // <method_get.png>
   public method getTrackPattern(int _tracknr, int _patNr) : NT_TrackPattern {
      NT_Track track <= getTrack(_tracknr);
      if(null != track)
      {
         NT_TrackPattern pat <= track.getPattern(_patNr);
         return pat;
      }
      return null;
   }

   // <method_get.png>
   public method getOrCreateTrackPattern(int _tracknr, int _patNr) : NT_TrackPattern {
      NT_Track track <= getTrack(_tracknr);
      if(null != track)
      {
         NT_TrackPattern pat <= track.getOrCreatePattern(_patNr);
         return pat;
      }
      return null;
   }

   // <method_get.png>
   public method getEventAt(local NT_Track _track, local int _ctl, local int _patOffset, local int _raster) {
      local NT_TrackPattern pat <= _track.getCurrentEditPattern();
      if(null != pat)
      {
         local Envelope env <= pat.getEnvelope(_ctl);
         if(null != env)
         {
            return env.valueAtTimeRaster(_patOffset, _raster);
         }
      }
      return void;
   }

   // <method_get.png>
   public method getTrackEventAt(local int _ctl, local int _patOffset) {
      local NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         return getEventAt(track, _ctl, _patOffset, pv_step_resolution);
      }
   }

   // <method_get.png>
   public method getVelocityAt(local NT_Track _track, local int _noteIdx, local int _patOffset, local int _raster) : float {
      local var velVal = getEventAt(_track, _noteIdx + NT_TrackPattern.CTL_VEL1, _patOffset, _raster);
      while((typeid(velVal) == YAC_TYPE_VOID) && (_noteIdx >= 0))
      {
         _noteIdx--;
         velVal = getEventAt(_track, _noteIdx + NT_TrackPattern.CTL_VEL1, _patOffset, _raster);
      }
      if(typeid(velVal) == YAC_TYPE_FLOAT)
      {
         return velVal;
      }
      else
      {
         // No velocity ctl set, return default velocity
         if(null != _track)
            return _track.keyjazz_on_velocity;
      }
      return 64;
   }

   // <method_get.png>
   public method getTrackVelocityAt(local int _noteIdx, int _patOffset) : float {
      return getVelocityAt(getCurrentTrack(), _noteIdx, _patOffset, pv_step_resolution);
   }

   // <method_get.png>
   public method getDurationAt(local NT_Track _track, local int _noteIdx, local int _patOffset, local int _raster) : int {
      local var durVal = getEventAt(_track, _noteIdx + NT_TrackPattern.CTL_DUR1, _patOffset, _raster);
      while((typeid(durVal) == YAC_TYPE_VOID) && (_noteIdx >= 0))
      {
         _noteIdx--;
         durVal = getEventAt(_track, _noteIdx + NT_TrackPattern.CTL_DUR1, _patOffset, _raster);
      }
      if(typeid(durVal) == YAC_TYPE_FLOAT)
      {
         return durVal;
      }
      else
      {
         // No duration ctl set, return default duration
         if(null != _track)
            return _track.keyjazz_duration;
         else
            return def_duration;
      }
      return 1;
   }

   // <method_get.png>
   public method getTrackDurationTicksAt(local int _noteIdx, local int _patOffset) : int {
      return getDurationAt(getCurrentTrack(), _noteIdx, _patOffset, pv_step_resolution) * dur_ticks;
   }

   // <method_get.png>
   public method isTrackStepEmpty(local int _patOffset) : boolean {

      int ctlIdx = 0;

      loop(NT_TrackPattern.CTL_NUM)
      {
         var ev = getTrackEventAt(ctlIdx, _patOffset);

         if(YAC_TYPE_VOID != typeid(ev))
         {
            return false;
         }

         ctlIdx++;
      }

      return true;
   }

   // <method.png>
   public method insertReplaceEventAtRes(NT_Track _track, int _ctl, float _value, int _patOffset, int _res) {
      ////trace "xxx insertReplaceEventAt track="+#(track)+" patOffset="+_patOffset;
      int patNr = nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      // trace "xxx insertReplaceEventAtRes(track="+#(_track)+" ctl="+_ctl+" value="+_value+" patOffset="+_patOffset+" patNr="+patNr+" pat="+#(pat);
      if(null != pat)
      {
         if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctl);

            if(!b_block_no_undo)
               undoTouchController(_track.track_nr, patNr, _ctl, env);

            // trace "\nxxx patOffset="+_patOffset;
            // trace "xxx env.time="+env.time;
            env.insertReplaceEvent(_patOffset, _value, _res);
            // trace "xxx env.time 2="+env.time;
         }
      } // if pat
   }

   // <method.png>
   public method insertReplaceExistingEventAtRes(NT_Track _track, int _ctl, float _value, int _patOffset, int _res) {
      ////trace "xxx insertReplaceEventAt track="+#(track)+" patOffset="+_patOffset;
      int patNr = nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      // trace "xxx insertReplaceEventAtRes(track="+#(_track)+" ctl="+_ctl+" value="+_value+" patOffset="+_patOffset+" patNr="+patNr+" pat="+#(pat);
      if(null != pat)
      {
         if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getEnvelope(_ctl);

            if(null != env)
            {
               boolean bInsert;

               if(b_envelope_view_replace)
               {
                  bInsert = (YAC_TYPE_FLOAT == typeid(env.valueAtTimeRaster(_patOffset, _res)));
               }
               else
               {
                  bInsert = true;
               }

               if(bInsert)
               {
                  if(!b_block_no_undo)
                  {
                     undoTouchController(_track.track_nr, patNr, _ctl, env);
                  }

                  env.insertReplaceEvent(_patOffset, _value, _res);
               }
            }
         }
      } // if pat
   }

   // <method.png>
   public method insertReplaceEventAt(NT_Track _track, int _ctl, float _value, int _patOffset) {
      insertReplaceEventAtRes(_track, _ctl, _value, _patOffset, pv_step_resolution);
   }

   // <method.png>
   =replay= public method insertReplaceTrackEventAt(int _ctl, float _value, int _patOffset) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         insertReplaceEventAt(track, _ctl, _value, _patOffset);
      } // if track
   }

   // <method.png>
   =replay= public method insertReplaceTrackEventAtRes(int _ctl, float _value, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         insertReplaceEventAtRes(track, _ctl, _value, _patOffset, _res);
      } // if track
   }

   // <method.png>
   =replay= public method insertReplaceExistingTrackEventAtRes(int _ctl, float _value, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         insertReplaceExistingEventAtRes(track, _ctl, _value, _patOffset, _res);
      } // if track
   }

   // <method.png>
   =replay= public method alignOffsetToFirstTrackEventAtWindow(NT_Track _track, int _patOffset, Integer _raster) : int {
      // Called before writing a controller value in step-edit (i.e. non-realtime) mode
      //   'raster' is adjusted to actual offset (e.g. subtract 2 ticks when offset is increased by 2)
      int ret = _patOffset;

      if(1 != _raster)
      {
         int patNr = nodeGetCurrentEditPatternNr();
         NT_TrackPattern pat <= _track.getPattern(patNr);

         if(null != pat)
         {
            int ctl;
            for(ctl = 0; ctl < NT_TrackPattern.CTL_NUM; ctl++)
            {
               Envelope env <= pat.getEnvelope(ctl);

               if(null != env)
               {
                  var val = env.valueAtTimeRaster(_patOffset, 1);

                  if(YAC_TYPE_VOID == typeid(val))
                  {
                     val = env.valueAtTimeRaster(_patOffset, _raster);

                     if(YAC_TYPE_VOID != typeid(val))
                     {
                        // There's an event in the given window/raster, determine exact offset
                        ret = env.getNextEventTimeAfter(_patOffset);

                        _raster = _raster - (ret - ((_patOffset / _raster) * _raster));
                        return ret;
                     }
                     else
                     {
                        // No existing event
                     }
                  }
                  else
                  {
                     // There's an event exactly at 'patOffset'
                     return ret;
                  }
               } // if env
               else
               {
                  // No existing event
               }
            } // loop ctls
         }
      }

      return ret;
   }

   // <method.png>
   =replay= public method fixOffsetToExistingTrackEventAtWindow(NT_Track _track,
                                                                int              _ctl,
                                                                int              _patOffset,
                                                                Integer          _raster
                                                                ) : int {
      // Called before writing a controller value in step-edit (i.e. non-realtime) mode
      int ret = _patOffset;

      if(1 != _raster)
      {
         int patNr = nodeGetCurrentEditPatternNr();
         NT_TrackPattern pat <= _track.getPattern(patNr);

         if(null != pat)
         {
            Envelope env <= pat.getEnvelope(_ctl);

            if(null != env)
            {
               var val = env.valueAtTimeRaster(_patOffset, 1);

               if(YAC_TYPE_VOID == typeid(val))
               {
                  val = env.valueAtTimeRaster(_patOffset, _raster);

                  if(YAC_TYPE_VOID != typeid(val))
                  {
                     // There's an event in the given window/raster, determine exact offset
                     ret = env.getNextEventTimeAfter(_patOffset);
                  }
                  else
                  {
                     // No existing event, align event to any event / any ctl
                     ret = alignOffsetToFirstTrackEventAtWindow(_track, _patOffset, _raster);
                  }

                  _raster = _raster - (ret - ((_patOffset / _raster) * _raster));
               }
               else
               {
                  // There's an event exactly at 'patOffset'
               }
            } // if env
            else
            {
               // No existing event, align event to any event / any ctl
               ret = alignOffsetToFirstTrackEventAtWindow(_track, _patOffset, _raster);

               _raster = _raster - (ret - ((_patOffset / _raster) * _raster));
            }
         }
      }

      return ret;
   }

   // <method.png>
   =replay= public method fixOffsetToExistingEventAtWindow(int _ctl, int _patOffset, Integer _raster) : int {
      // Called before writing a controller value in step-edit (i.e. non-realtime) mode
      int ret = _patOffset;

      if(1 != _raster)
      {
         NT_Track track <= getCurrentTrack();
         if(null != track)
            return fixOffsetToExistingTrackEventAtWindow(track, _ctl, _patOffset, _raster);
      }

      return ret;
   }

   // <method.png>
   public method removeEventAt(local NT_Track _track, local int _ctl, local int _patOffset, local int _raster) {
      // _ctl=-1 ==> remove all controller events
      local int patNr = nodeGetCurrentEditPatternNr();
      local NT_TrackPattern pat <= _track.getPattern(patNr);
      if(null != pat)
      {
         Envelope *env;
         if(-1 == _ctl)
         {
            // Remove step in all controllers
            local int ctlId = 0;
            foreach env in pat.controllers
            {
               if(null != env)
               {
                  if(!b_block_no_undo)
                     undoTouchController(_track.track_nr, patNr, ctlId, env);

                  env.removeRange(_patOffset, _raster);
               }
               ctlId++;
            }
         }
         else if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            env <= pat.getEnvelope(_ctl);
            if(null != env)
            {
               if(!b_block_no_undo)
                  undoTouchController(_track.track_nr, patNr, _ctl, env);

               env.removeRange(_patOffset, _raster);
            }
         }
      } // if pat
   }

   // <method.png>
   =replay= public method removeTrackEventAt(local int _ctl, local int _patOffset) {
      local NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         removeEventAt(track, _ctl, _patOffset, pv_step_resolution);
      } // if track
   }

   // <method.png>
   =replay= public method removeTrackEventAtRes(local int _ctl, local int _patOffset, local int _res) {
      local NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         removeEventAt(track, _ctl, _patOffset, _res);
      } // if track
   }

   // <method.png>
   =replay= public method removeAllTrackEventsAtRes(local int _patOffset, local int _res) {
      local NT_Track *track;
      foreach track in tracks
      {
         removeEventAt(track, -1/*allCtls*/, _patOffset, _res);
      } // if track
   }

   // <method.png>
   public method deleteTrackEnvRegionAndShift(NT_Track _track, int _ctlId, int _patOff, int _numTicks) {
      // keep absolute time of events after deleted region (shift back)
      int patNr = nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      if(null != pat)
      {
         if(_ctlId < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctlId);

            if(!b_block_no_undo)
               undoTouchController(_track.track_nr, patNr, _ctlId, env);

            int envOff = 0;
            int envIdx = 0;
            int shiftNext = 0;
            int lastEvOff = 0;
            int endOff = _patOff + _numTicks;

            // trace "xxx deleteTrackEnvRegionAndShift: ctlId="+_ctlId+" patOff="+_patOff+" numTicks="+_numTicks;

            while(envIdx < env.numElements)
            {
               int dt = env[envIdx];
               envOff += dt;
               env[envIdx] = env[envIdx] + shiftNext;  // adjust deltatime

               // trace "xxx envIdx="+(envIdx/2)+" envOff="+envOff+" patOff="+_patOff+" lastEvOff="+lastEvOff+" shiftNext="+shiftNext;

               if(envOff >= endOff)
                  break;

               if(envOff >= _patOff)
               {
                  shiftNext = (envOff - lastEvOff);

                  env.delete(envIdx);  // delta-time
                  env.delete(envIdx);  // value
               }
               else
               {
                  // Find first event >= patOff
                  envIdx += 2;
                  lastEvOff = envOff;
               }

               // Next event
            }
         }
      }
   }

   // <method.png>
   public method deleteTrackEnvRegion(NT_Track _track, int _ctlId, int _patOff, int _numTicks) {
      // Delete and move events after deleted region up
      int patNr = nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      if(null != pat)
      {
         if(_ctlId < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctlId);

            if(!b_block_no_undo)
               undoTouchController(_track.track_nr, patNr, _ctlId, env);

            int envOff = 0;
            int envIdx = 0;
            boolean bFirstShifted = false;
            int shiftNext = 0;
            int lastEvOff = 0;
            int endOff = _patOff + _numTicks;

            // trace "xxx deleteTrackEnvRegion: ctlId="+_ctlId+" patOff="+_patOff+" numTicks="+_numTicks;

            while(envIdx < env.numElements)
            {
               int dt = env[envIdx];
               envOff += dt;

               // trace "xxx envIdx="+(envIdx/2)+" envOff="+envOff+" patOff="+_patOff+" lastEvOff="+lastEvOff+" shiftNext="+shiftNext;

               if(envOff >= endOff)
               {
                  if(!bFirstShifted)  // no events within selected block ?
                     shiftNext = env[envIdx] -_numTicks;
                  else
                     shiftNext += (envOff - endOff);
                  // trace "xxx shift first ev after block by "+shiftNext+" ticks";
                  env[envIdx] = shiftNext;  // adjust deltatime
                  break;
               }

               if(envOff >= _patOff)
               {
                  if(!bFirstShifted)
                  {
                     shiftNext = (_patOff - lastEvOff);  // shift first event (adjust to block start)
                     bFirstShifted = true;
                  }

                  env.delete(envIdx);  // delta-time
                  env.delete(envIdx);  // value
               }
               else
               {
                  // Find first event >= patOff
                  envIdx += 2;
                  lastEvOff = envOff;
               }

               // Next event
            }
         }
      }
   }

   // <method.png>
   =replay= public method getNextTrackEventOffsetAt(local int _ctl, local int _patOffset) {
      int ret = 0;
      local NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         local int patNr = nodeGetCurrentEditPatternNr();
         local NT_TrackPattern pat <= track.getPattern(patNr);
         if(null != pat)
         {
            Envelope *env;
            int envIdx;
            int envT;
            int minEvTime = 9999999;

            if(-1 == _ctl)
            {
               // Query all ctls
               local int ctlId = 0;
               foreach env in pat.controllers
               {
                  if(null != env)
                  {
                     envT = env.getNextEventTimeAfter(_patOffset);
                     if(-1 != envT)
                     {
                        if(envT < minEvTime)
                        {
                           minEvTime = envT;
                           ret = minEvTime;
                        }
                     }
                  }
                  ctlId++;
               }
            }
            else if(_ctl < NT_TrackPattern.CTL_NUM)
            {
               env <= pat.getEnvelope(_ctl);
               if(null != env)
               {
                  envT = env.getNextEventTimeAfter(_patOffset);
                  if(-1 != envT)
                  {
                     ret = envT;
                  }
               }
            }
         }
      }
      return ret;
   }

   // <method.png>
   public method shiftEventsAt(local NT_Track _track, local int _ctl, local int _patOffset, local int _raster) {
      // ctl=-1 ==> shift all controllers
      local int patNr = nodeGetCurrentEditPatternNr();
      local NT_TrackPattern pat <= _track.getPattern(patNr);
      if(null != pat)
      {
         local Envelope *env;
         if(-1 == _ctl)
         {
            // Shift events of all controllers
            local int ctlId = 0;
            foreach env in pat.controllers
            {
               if(null != env)
               {
                  if(!b_block_no_undo)
                     undoTouchController(_track.track_nr, patNr, ctlId, env);

                  env.shiftEvents(_patOffset, _raster);
               }
               ctlId++;
            }
         }
         else if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            env <= pat.getEnvelope(_ctl);
            if(null != env)
            {
               if(!b_block_no_undo)
                  undoTouchController(_track.track_nr, patNr, _ctl, env);

               env.shiftEvents(_patOffset, _raster);
            }
         }
      } // if pat
   }

   // <method.png>
   =replay= public method shiftTrackEventsAt(int _ctl, int _patOffset) {
      local NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         shiftEventsAt(track, _ctl, _patOffset, pv_step_resolution);
      } // if track
   }

   // <method.png>
   =replay= public method shiftTrackEventsAtRes(int _ctl, int _patOffset, int _res) {
      local NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         shiftEventsAt(track, _ctl, _patOffset, _res);
      } // if track
   }

   // <method.png>
   =replay= public method shiftAllTrackEventsAtRes(local int _patOffset, local int _res) {
      local NT_Track *track;
      foreach track in tracks
      {
         shiftEventsAt(track, -1/*allCtls*/, _patOffset, _res);
      } // if track
   }

   // <method.png>
   protected method clearRaster(NT_Track _track, int _patOffset) {
      if(b_rec_all)
      {
         // Clear all tracks
         NT_Track *track;
         foreach track in tracks
         {
            removeEventAt(track, -1/*all ctls*/, _patOffset, pv_step_resolution);
            shiftEventsAt(track, -1/*all ctls*/, _patOffset, pv_step_resolution);
         }
      }
      else
      {
         // Clear current track
         removeEventAt(_track, -1/*all ctls*/, _patOffset, pv_step_resolution);
         shiftEventsAt(_track, -1/*all ctls*/, _patOffset, pv_step_resolution);
      }
      rec_clear_last_step = _patOffset;
   }

   // <method_get.png>
   public method doAutoScroll() : boolean {
      return STConfig.b_node_tracker_autoscroll && !b_extclk;
   }

   // <method.png>
   public static method DoRecordNoteOff() : boolean {
      if(STConfig.b_node_tracker_recordnoteoff)
      {
         if(!replay.b_playing)
            return !STConfig.b_node_tracker_recordnoteoff_replay;
         else
            return true;
      }
      return false;
   }

   // <method_set.png>
   public =replay= method setReplayUIPatOffset(int _off) {
      pv_replay_pat_offset = _off;
   }

   // <method_get.png>
   public method getReplayUIPatOffset() : int {
      return pv_replay_pat_offset;
   }

   // <method_set.png>
   public =replay= method setEditOffset(int _offset) {
      // trace "xxx setEditOffset(offset="+_offset+" / step#="+(_offset/step_resolution)+")";
      // trace "xxx setEditOffset: this="+#(this)+" offset="+_offset;
      // Utils.Backtrace();
      pv_pat_offset = _offset;

      if(!replay.b_playing)
         pv_replay_pat_offset = _offset;
   }

   // <method_get.png>
   public =replay= method getEditOffset() : int {
      return pv_pat_offset;
   }

   // <method_set.png>
   public =replay= method nodeSetRelativeEditOffset(int _off) {
      // // pv_pat_offset = nodeGetLastPatternStartEditorSongOffset() + _off;
      pv_pat_offset = _off;
   }

   // <method_get.png>
   public method getSongEditOffset() : int {
      // for e.g. song.seek() calls
      return nodeGetLastPatternStartEditorSongOffset() + pv_pat_offset;
   }

   // <method_get.png>
   public /*=replay=*/ method getAlignedPatOffset(int _patOff) : int {
      _patOff = (_patOff / pv_step_resolution) * pv_step_resolution;
      return _patOff;
   }

   // <method_get.png>
   public method getClippedPatOffset(local int _offset) : int {

      // Clip to pattern length
      local int jamLen = getCurrentEditMetaPatternLength();
      // trace "xxx getClippedPatOffset: offset="+_offset+" jamLen="+jamLen;
      if(_offset >= jamLen)
      {
         _offset = jamLen - pv_step_resolution;
         if(_offset < 0)
            _offset = 0;
      }
      return _offset;
   }

   // <method.png>
   public =replay= method getPlayPatOffset() : int {
      // Used to get pattern offset in realtime recording mode
      // return current_song.song_offset - nodeGetLastPatternStartEditorSongOffset();
      return tick_nr;  // [14Mar2019] fix recording pos when recording to song loop
   }

   // <method.png>
   public =replay= method getRecordPatOffsetMidiRec(local boolean _bMayQuantize,
                                                    local boolean _bForceReplayPos,
                                                    local boolean _bFramePlay
                                                    ) : int {
      local int patOffset;

      ////if(!replay.b_playing)
      if(!b_rt_record && !_bForceReplayPos)
      {
         // Use quantized edit cursor offset
         patOffset = getEditOffset();
      }
      else
      {
         // Use current replay tick (to be played in current ST_Song::tick())
         /////patOffset = current_song.song_offset - parent_node.last_pattern_start_editor_song_offset;
         patOffset = getPlayPatOffset();
         // trace "xxx getRecordPatOffsetMidiRec: patOffset="+patOffset;

         local int patLen = getCurrentEditMetaPatternLength();

         patOffset = patOffset % patLen;  // [05Jun2017] REC_MODE_RASTER fix

         if(!_bFramePlay)
         {
            if(STConfig.b_node_tracker_rec_latency)
            {
               patOffset -= int((STConfig.node_tracker_rec_latency / MIDI.tick_duration)+0.5);
            }
            patOffset -= current_pipe_root.pipeDelay;
            // trace "xxx rec patOffset="+patOffset+" pipeDelay="+current_pipe_root.pipeDelay;
            if(patOffset < 0)
               patOffset += patLen;
         }

         local boolean bQuantize = STConfig.b_node_tracker_recordquantize && _bMayQuantize;

         if(b_rec_quantize_last_step)
         {
            if(patOffset >= (patLen - pv_step_resolution/2))
            {
               bQuantize = true;
            }
         }

         if(bQuantize)
         {
            patOffset = int( (patOffset + pv_step_resolution/2) / pv_step_resolution) * pv_step_resolution;
            patOffset = patOffset % patLen;  // [02Jul2017] qlast fix
         }

         // // if(patOffset >= patLen)
         // //    patOffset -= patLen;
         // // // patOffset = patOffset % patLen;  // [05Jun2017] REC_MODE_RASTER fix
      }

      return patOffset;
   }

   // <replay.png>
   public virtual nodeReset(boolean _bSoft) {

      // trace "xxx nt: nodeReset";
      Node::nodeReset(_bSoft);

      last_rec_soff = 999999;
      last_rec_eoff = 999999;
      num_rec_notes = 0; // for RASTER rec_mode (start clearing not until first note event is recorded)
      rec_clear_start = -1; // for RASTER rec_mode
      b_rec_clear_start_wrap = false;
      rec_clear_last_step = -1;

      if(maybe == _bSoft)
      {
         // Reached when playing single step
         b_jam_retrig = false;
         extclk_last_event_ticks = -1;
         extclk_last_event_gatetime = extclk_gatetime_resetval;
         return;
      }

      audiorec_tick_nr = 0;
      audiorec_automute_tick_nr = -1;

      tick_frac = 0.0;

      // trace "xxx NT: nodeReset all b_extclk="+b_extclk;

      b_extclk      = b_extclk_resetval;
      b_jam_run     = !b_extclk;
      b_jam_done    = (maybe == b_change_reset);
      b_jam_restart = (false != b_change_reset);
      b_jam_gate    = !b_extclk;
      b_jam_adv     = !b_extclk;
      b_jam_retrig  = false;

      extclk_gatetime_base  = extclk_gatetime_resetval;
      extclk_gatetime_mul   = 1;
      extclk_gatetime_div   = 1;
      extclk_gatetime       = extclk_gatetime_resetval;
      extclk_gate_countdown = 0;

      extclk_last_event_ticks = -1;
      extclk_last_event_gatetime = extclk_gatetime_resetval;

      ext_active_notes.empty();
      arp_active_notes.empty();
      arp_latch_next_idx = 0;
      b_arp_dynalen_update_queued = false;

      jam_queued_pattern_nr = -1;

      jam_scale_ticks = offlen_ticks_resetval;
      jam_scale_mul   = 1;
      jam_scale_div   = 1;
      jam_tick_multiplier = offlen_ticks_resetval;

      jam_offset = 0;
      jam_length = getMetaPatternLength(play_pattern_nr) / jam_tick_multiplier;

      jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;  // 30Nov2017 (fix seek pos when adding node while replay is running)

      jam_offset_queued = -1;
      jam_length_queued = -1;

      dur_ticks = dur_ticks_resetval;

      jam_queued_offset_ticks = -1;

      // trace "xxx NT::nodeReset";

      NT_Track *track;
      foreach track in tracks
      {
         track.reset();
      }

      if(b_tap_mode)
      {
         clearScratchPattern();

         if(b_tap_mode_resetsourcestep)
         {
            tap_mode_current_source_step = -1;
         }
      }

   }

   // <replay.png>
   public virtual nodeRestart() {
      nodeSetLastPatternStartSongOffset(current_song.song_offset);

      tick_nr = 0;  // [04Feb2017]
      synced_tick_nr = tick_nr;

      b_jam_done = false;

      nodeSeek(nodeGetLastPatternStartSongOffset() + 0);
   }

   // <method_set.png>
   public method resetEQ() {
      NT_Track *track;
      foreach track in tracks
      {
         track.eq_anim = 0.0f;
      }
   }

   // <method.png>
   public virtual nodeCalcRelativeTicks(int _ticks) : int {
      int scaledTicks = (_ticks - nodeGetLastPatternStartSongOffset()); // (note) do _not_ scale by rpn_com_speed_scl;
      int relTicks;
      // (note) this is actually not quite correct in case the start offset is != 0 (jam_offset)
      int patLenTicks = jam_current_end_ticks; // do _not_ scale by rpn_com_speed_scl

      if(patLenTicks > 0)
      {
         if(scaledTicks < 0)
         {
            relTicks = patLenTicks - (-scaledTicks % patLenTicks);
            relTicks = relTicks % patLenTicks;
         }
         else
         {
            relTicks = scaledTicks % patLenTicks;
         }
      }
      else
      {
         relTicks = scaledTicks;
      }

      if(relTicks < 0)
         relTicks = 0;

      return relTicks;
   }

   // <replay.png>
   public method queueAudioClip() {
      // may only be called from within nodeProcess() or nodeSeek()
      // if("a_keys" == parent_pipenode.name)
      //    trace "xxx nt::queueAudioClip: jam_current_ticks="+jam_current_ticks;
      initial_sample_offset_ms = current_song.ticksToMilliSeconds(jam_current_ticks);
   }

   // <method.png>
   public =replay= method nodeHandleUnmute() {
      queueAudioClip();

      if(midi_node_gid >= 0)
      {
         if(b_audiomidi_mutex)
         {
            // Try to auto-mute MIDI node
            NodeTracker midiNode <= current_song.findNodeByGID(midi_node_gid);
            if(midiNode instanceof NodeTracker)
            {
               Node.SetNodeMuteState(midiNode.parent_pipenode, true/*bMute*/);
            }
         }
      }
      else if(audio_node_gid >= 0)
      {
         // Try to auto-mute Audio node
         NodeTracker audioNode <= current_song.findNodeByGID(audio_node_gid);
         if(audioNode instanceof NodeTracker)
         {
            if(audioNode.b_audiomidi_mutex)
            {
               Node.SetNodeMuteState(audioNode.parent_pipenode, true/*bMute*/);
            }
         }
      }
   }

   // <method.png>
   public =replay= method nodeHandleMute() {

      if(midi_node_gid >= 0)
      {
         if(b_audiomidi_mutex)
         {
            // Try to auto-unmute MIDI node
            NodeTracker midiNode <= current_song.findNodeByGID(midi_node_gid);
            if(midiNode instanceof NodeTracker)
            {
               Node.SetNodeMuteState(midiNode.parent_pipenode, false/*bMute*/);
            }
         }
      }
      else if(audio_node_gid >= 0)
      {
         // Try to auto-unmute Audio node
         NodeTracker audioNode <= current_song.findNodeByGID(audio_node_gid);
         if(audioNode instanceof NodeTracker)
         {
            if(audioNode.b_audiomidi_mutex)
            {
               Node.SetNodeMuteState(audioNode.parent_pipenode, false/*bMute*/);
            }
         }
      }
   }

   // <replay.png>
   public =replay= virtual nodeSeek(int _ticks) {

      // if(parent_pipenode.name == "chip arp notes")
      // {
       // trace "xxxxxx nodeSeek(ticks="+_ticks+")";
      // }

      if(replay.b_playing && b_arp && b_arp_reset)
      {
         // Pattern reset is controlled by arp note-on
         return;
      }

      // trace "xxx NT: nodeSeek: jam_current_ticks 1="+jam_current_ticks;

      jam_current_ticks = nodeCalcRelativeTicks(_ticks); // modulo by jam_end_ticks, result is never <0

      // trace "xxx NT: nodeSeek: jam_current_ticks 2="+jam_current_ticks;

      if(!replay.b_playing)
      {
         // e.g. when replay is about to start (b_playing is still false during song.seek())
         tick_nr = jam_current_ticks;
         synced_tick_nr = tick_nr;
      }

      // Used by audio-track like instruments (auto-send note on/off when pattern starts/stops)
      queueAudioClip();

      last_rec_soff = 99999999;

      // Global.Debug3("NodeTracker::seek: time="+jam_current_ticks+" reqTime="+_ticks+" end_ticks="+jam_current_end_ticks);

      NT_Track *track;
      foreach track in tracks
      {
         track.seek(jam_current_ticks);
      }

      byte origPlayPatNr = play_pattern_nr;
      if(b_tap_mode)
      {
         play_pattern_nr = tap_mode_scratch_pat_nr;

         foreach track in tracks
         {
            track.seek(jam_current_ticks);
         }

         play_pattern_nr = origPlayPatNr;
      }

   }

   // <replay.png>
   public virtual nodeGetCurrentTickOffset() : int {
      int ret = jam_current_ticks;
      if(ret < 0)
         ret = 0; // pattern restart queued
      return ret;
   }

   // <replay.png>
   public virtual nodeGetCurrentCommonOffset() : int {
      // to be scaled by RPN_COMMON_OFFLEN_SCALE
      if(-1 != jam_current_ticks)
      {
         return jam_current_ticks / jam_tick_multiplier;
      }
      return 0;
   }

   // <method.png>
   public method newTrack(String _name, NT_Track _curTrack, boolean _bCloneLayout) : NT_Track {
      //
      // Allocate new track and clone event layout from _curTrack (if != null)
      //
      int oldNumTracks = tracks.numElements;

      // Create new track
      tracks.realloc(tracks.numElements + 1);
      NT_Track track <= tracks.nextFree;
      track.init(this, tracks.numElements - 1);
      track.name = _name;

      // Copy ui settings from current track, if available
      if(null != _curTrack)
      {
         track.is_muted             = _curTrack.is_muted;
         track.keyjazz_instr_nr     = _curTrack.keyjazz_instr_nr;
         track.keyjazz_octave       = _curTrack.keyjazz_octave;
         track.keyjazz_on_velocity  = _curTrack.keyjazz_on_velocity;
         track.keyjazz_off_velocity = _curTrack.keyjazz_off_velocity;
         track.keyjazz_duration     = _curTrack.keyjazz_duration;
         track.keyjazz_last_note    = _curTrack.keyjazz_last_note;
      }

      // Clone event layout from current track, if available
      if((null != _curTrack) && _bCloneLayout)
      {
         track.tel.cloneFrom(_curTrack.tel);
      }

      return track;
   }

   // <method.png>
   public method lazyCreateTrackByName(String _name) : NT_Track {
      NT_Track *track;
      foreach track in tracks
      {
         if(track.name == _name)
            return track;
      }

      return newTrack(_name, null/*curTrack*/, false/*bCloneLayout*/);
   }

   // <method.png>
   public method enumerateTracks() {
      int trackNr = 0;
      NT_Track *track;
      foreach track in tracks
      {
         track.track_nr = trackNr++;
      }
   }

   // <method.png>
   public method deleteTrack(int _trackNr) {

      tracks.delete(_trackNr);

      enumerateTracks();
   }

   // <method.png>
   public method unlinkTrack(int _trackNr) : NT_Track {
      // used by undo
      return tracks.getDeref(_trackNr);
   }

   // <method.png>
   public method insertTrack(int _trackNr, NT_Track _track) {
      // used by undo
      tracks.insert(_trackNr, #(deref _track));

      enumerateTracks();
   }

   // <method.png>
   public method swapTracks(int _trackNrA, int _trackNrB) {

      if(solo_track_nr == _trackNrA)
      {
         solo_track_nr = _trackNrB;
      }
      else if(solo_track_nr == _trackNrB)
      {
         solo_track_nr = _trackNrA;
      }

      NT_Track ta <= tracks.get(_trackNrA);
      if(null != ta)
      {
         ta.track_nr = _trackNrB;
      }

      NT_Track tb <= tracks.get(_trackNrB);
      if(null != tb)
      {
         tb.track_nr = _trackNrA;
      }

      tracks.swap(_trackNrA, _trackNrB);
   }

   // <method_get.png>
   public method findTrackByPartialName(String _substring) {
      NT_Track *track;
      foreach track in tracks
      {
         if(null != track)
         {
            if(track.name & _substring)
               return track;
         }
      }
      return null;
   }

   // <method_get.png>
   public method findTrackByName(String _name) {
      NT_Track *track;
      foreach track in tracks
      {
         if(null != track)
         {
            if(track.name == _name)
               return track;
         }
      }
      return null;
   }

   // <method_get.png>
   public method getCurrentTrackInstrument() : NT_Instrument {
      // called by UI
      NT_Track track <= getTrack(pv_cursor_track);
      if(null != track)
         return getInstrument(track.current_instrument_nr);
      return null;
   }

   // <method_get.png>
   public method keyJazzGetInstrument() : NT_Instrument {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         return getInstrument(track.keyjazz_instr_nr);
      }
      return null;
   }

   // <method_get.png>
   public method keyJazzGetInstrumentNr() : int {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         return track.keyjazz_instr_nr;
      }
      return 0;
   }

   // <method_get.png>
   public method keyJazzGetCtlNames() : StringArray {
      // Return controller names according to current track and instrument
      // Called by NT_EditTrackLayoutDialog
      StringArray r;
      int i;

      r.empty();

      NT_Instrument ins <= keyJazzGetInstrument();

      if(null != ins)
      {
         // Ok, have instrument context, now add instrument-specific controller names
         i = 0;
         loop(NT_TrackPattern.CTL_NUM)
         {
            r.add(GetControllerName(ins, i));
            i++;
         }

         return r;
      }

      // No track / instrument context available, add default controller names
      r = MNT_PatternView.ctl_names;
      i = 1;
      loop(NT_TrackPattern.CTL_NUMUSR)
      {
         r.add("CTL_USR" + i);
         i++;
      }

      return r;
   }

   // <replay.png>
   public =replay= method keyJazzQueueAdd(int _trackNr, int _instrNr, int _note, int _velocity, int _durTicks) {
      // trace "xxx keyJazzQueueAdd: note="+_note+" vel="+_velocity;
      KeyJazzQueueEntry e <= keyjazz_queue.nextFree;
      if(null != e)
      {
         // trace "xxx keyJazzQueueAdd: GID="+getNodeGID()+" trackNr="+_trackNr+" instrNr="+_instrNr+" note="+_note+" vel="+_velocity+" dur="+_durTicks;
         e.track_nr  = _trackNr;
         e.instr_nr  = _instrNr;
         e.note      = _note;
         e.velocity  = _velocity;
         e.dur_ticks = _durTicks;
      }
      else
      {
         trace "[---] NodeTracker::keyJazzQueue: failed to queue ins="+_instrNr+" note="+_note+" vel="+_velocity;
      }
   }

   // <method_get.png>
   public method keyJazzGetNoteOnVelocity() : float {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         return track.keyjazz_on_velocity;
      return 127.0f;
   }

   // <method_get.png>
   public method keyJazzGetNoteOffVelocity() : float {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         return track.keyjazz_off_velocity;
      else
         return 0.0f;
   }

   // <method_get.png>
   public method keyJazzGetDuration() : int {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         return track.keyjazz_duration;
      return 0;
   }

   // <replay.png>
   public =replay= method keyJazzNoteOnTicks(int _note, byte _velOrMinusOne, int _durTicks) {
      if(-1 != current_song.locked_keyjazz_node_gid)
      {
         // Redirect keyjazz to other node (or track)
         NodeTracker kjNode <= current_song.findNodeByGID(current_song.locked_keyjazz_node_gid);

         if(kjNode instanceof NodeTracker)
         {
            NT_Track kjTrack <= kjNode.getTrack(current_song.locked_keyjazz_track);

            if(null != kjTrack)
            {
               kjNode.keyJazzQueueAdd(current_song.locked_keyjazz_track,
                                      kjTrack.keyjazz_instr_nr,
                                      _note,
                                      (_velOrMinusOne > 0) ? _velOrMinusOne : kjTrack.keyjazz_on_velocity,
                                      _durTicks
                                      );
            }
         }
         return;
      }

      keyJazzQueueAdd(getCurrentTrackNr(),
                      keyJazzGetInstrumentNr(),
                      _note,
                      (_velOrMinusOne > 0) ? _velOrMinusOne : keyJazzGetNoteOnVelocity(),
                      _durTicks
                      );
   }

   // <replay.png>
   public =replay= method keyJazzNoteOn(int _note, byte _velOrMinusOne) {
      // trace "xxx KeyJazzNoteOn: note="+_note+" vel="+keyJazzGetNoteOnVelocity();
      keyJazzNoteOnTicks(_note, _velOrMinusOne, 0/*durTicks*/);
   }

   // <replay.png>
   public =replay= method keyJazzNoteOff(int _note) {
      // trace "xxx KeyJazzNoteOff: note="+_note;

      if(-1 != current_song.locked_keyjazz_node_gid)
      {
         // Redirect keyjazz to other node (or track)
         NodeTracker kjNode <= current_song.findNodeByGID(current_song.locked_keyjazz_node_gid);

         if(kjNode instanceof NodeTracker)
         {
            NT_Track kjTrack <= kjNode.getTrack(current_song.locked_keyjazz_track);
            if(null != kjTrack)
            {
               kjNode.keyJazzQueueAdd(current_song.locked_keyjazz_track,
                                      kjTrack.keyjazz_instr_nr,
                                      -_note,
                                      kjTrack.keyjazz_off_velocity,
                                      0/*durTicks*/
                                      );
            }
         }
         return;
      }

      keyJazzQueueAdd(getCurrentTrackNr(),
                      keyJazzGetInstrumentNr(),
                      -_note,
                      keyJazzGetNoteOffVelocity(),
                      0/*durTicks*/
                      );
   }

   // <method_get.png>
   public method isWriteInstrumentNrEnabled() : boolean {
      return b_write_instrnr;
   }

   // <method_get.png>
   public method isWriteVelocityEnabled() : boolean {
      return b_write_noteon_velocity;
   }

   // <method_get.png>
   public method isWriteOffVelocityEnabled() : boolean {
      return b_write_noteoff_velocity;
   }

   // <method_get.png>
   public method isWriteDurationEnabled() : boolean {
      // must only be used for step-edit mode or as a last-resort fallback when note-off/CTL_DUR recording is disabled
      return b_write_duration;
   }

   // <replay.png>
   public method mapArpNote(int _note) : int {

      if(!replay.b_playing)
         return _note;

      boolean bSign;
      int origNote = _note;

      if(_note < 0)
      {
         if(_note < -127)
            return _note; // MAGIC_xxx
         _note = -_note;
         bSign = true;
      }
      else
      {
         bSign = false;
      }

      int arpIdx = arp_note_table.indexOf(_note % 12, 0);

      // trace "xxx mapArpNote(note="+_note+") arpIdx="+arpIdx;

      if(-1 != arpIdx)
      {
         if(arp_active_notes.numElements > 0)
         {
            if(arpIdx >= arp_active_notes.numElements)
            {
               if(b_arp_wrap)
               {
                  // trace "xxx wrap arpIdx="+arpIdx+", #arp_active_notes="+arp_active_notes.numElements;
                  arpIdx = arpIdx % arp_active_notes.numElements;
               }
               else
               {
                  if(b_arp_play_arp_notes)
                  {
                     // Note is currently not mapped to an ext note
                     return origNote;
                  }
                  return NT_TrackPattern.INVALID_VALUE;
               }
            }

            byte oct = (_note / 12) - arp_base_octave;  // octave-delta of pattern sequence note

            _note = arp_active_notes.get(arpIdx) + (12 * oct);
            // trace "xxx oct="+oct+" newNote="+_note;

            if(bSign)
               _note = - _note;

            return _note;
         }
         else
         {
            if(b_arp_play_arp_notes)
            {
               // Note is currently not mapped to an ext note
               return origNote;
            }
         }
      }
      else
      {
         // Note cannot be mapped to an ext note
         if(b_arp_play_non_arp_notes)
         {
            return origNote;
         }
      }

      return NT_TrackPattern.INVALID_VALUE;
   }

   // <ui_undo.png>
   public method undoDisable() {
      b_block_no_undo = true;
   }

   // <ui_undo.png>
   public method undoEnable() {
      b_block_no_undo = false;
   }

   // <ui_undo.png>
   public =replay= method undoBegin(String _name) {
      if(b_skip_rec_undo)
         return;

      if(_name.startsWith("TODO")) // dev/debug helper
      {
         trace "[---] NodeTracker::undoBegin: transaction \""+(_name.replace("TODO",""))+"\" does not support undo, yet.";
         undoEmpty();
      }
      else
      {
         if(null != ui_undo_entry)
         {
            trace "[---] NodeTracker::undoBegin: internal error: transaction \""+(ui_undo_entry.name)+"\" still in progress !!! (clearing stack)";
            // // ui_undo_stack.endEntry(ui_undo_entry);
            ui_undo_stack.empty(); // fail-safe
         }
         ui_undo_entry <= ui_undo_stack.allocEntry();
         ui_undo_entry.begin(_name);
      }
   }

   // <ui_undo.png>
   public haveUndo() : boolean {
      return !ui_undo_stack.isEmpty();
   }

   // <ui_undo.png>
   public =replay= method undoBeginCond(String _name) {
      if(b_skip_rec_undo)
         return;

      // superceded by undoBeginNested() ???!
      if(null != ui_undo_entry)
      {
         if(ui_undo_entry.name == _name)
         {
            // OK, transaction already started
            return;
         }
         else
         {
            trace "[---] NodeTracker::undoBeginCond(\""+_name+"\"): transaction \""+(ui_undo_entry.name)+"\" still in progress !!! (clearing stack)";
            ui_undo_stack.empty(); // fail-safe
            return;
         }
      }
      else
      {
         ui_undo_entry <= ui_undo_stack.allocEntry();
         ui_undo_entry.begin(_name);
      }
   }

   // <ui_undo.png>
   public =replay= undoBeginCondPat(String _name) {
      if(b_skip_rec_undo)
         return;

      // superceded by undoBeginNested() ???!
      if(STConfig.b_node_tracker_undo_record_single_transaction)
      {
         if(replay.b_playing)
         {
            if(b_rt_record)
            {
               // Undo transaction already started
               return;
            }
         }
      }
      // Start single-step edit undo transaction
      undoBeginCond(_name);
   }

   // <ui_undo.png>
   public =replay= method undoBeginNested(String _name) {
      if(b_skip_rec_undo)
         return;

      if(null != ui_undo_entry)
      {
         // OK, transaction already started
         // // Global.Debug2("NT::undoBeginNested: name=\""+_name+"\", current=\""+ui_undo_entry.name+"\".");
         return;
      }
      if(STConfig.b_node_tracker_undo_debug)
         Global.Debug2("NT::undoBeginNested: name=\""+_name+"\"");
      ui_undo_entry <= ui_undo_stack.allocEntry();
      ui_undo_entry.begin(_name);
   }

   // <ui_undo.png>
   public method getUndoEntryName() : String {
      if(null != ui_undo_entry)
      {
         return ui_undo_entry.name;
      }
      return null;
   }

   // <ui_undo.png>
   public method undo(boolean _bRestoreCursor) : boolean {
      if(null != ui_undo_entry)
      {
         trace "[---] NodeTracker::undo: error: transaction \""+(ui_undo_entry.name)+"\" still in progress !!! (aborting undo)";
         return false;
      }
      else
      {
         ui_undo_stack.undo(_bRestoreCursor);
         return true;
      }
   }

   // <ui_undo.png>
   public method redo() : boolean {
      if(null != ui_undo_entry)
      {
         trace "[---] NodeTracker::redo: error: transaction \""+(ui_undo_entry.name)+"\" still in progress !!! (aborting redo)";
         return false;
      }
      else
      {
         ui_undo_stack.redo();
         return true;
      }
   }

   // <ui_undo.png>
   public undoTouchPattern(int _pattern) {
      if(b_skip_rec_undo)
         return;

      // Called by c'n'p while =replay= is locked
      if(null != ui_undo_entry)
      {
         ui_undo_entry.touchPattern(_pattern);
      }
      else
      {
         trace "[---] NodeTracker::undoTouchPattern("+_pattern+"): internal error: no transaction in progress !!! (ignoring)";
      }
   }

   // <ui_undo.png>
   public =replay= undoTouchController(int _track, int _pattern, int _ctl, Envelope _env) {
      if(b_skip_rec_undo)
         return;

      if(null != ui_undo_entry)
      {
         ui_undo_entry.touchController(_track, _pattern, _ctl, _env);
      }
      else
      {
         trace "[---] NodeTracker::undoTouchController("+_track+", "+_pattern+", "+_ctl+"): internal error: no transaction in progress !!! (ignoring)";
      }
   }

   // <ui_undo.png>
   protected method undoTouchAllControllers(boolean _bAllTracks) {
      if(b_skip_rec_undo)
         return;

      // Used by tap_mode
      int trackNr = 0;

      loop(tracks.numElements)
      {
         if(_bAllTracks || (trackNr == pv_cursor_track))
         {
            undoTouchAllTrackControllers(trackNr);
         }

         // Next track
         trackNr++;
      }
   }

   // <ui_undo.png>
   protected method undoTouchAllTrackControllers(int _trackNr) {
      if(b_skip_rec_undo)
         return;

      // Used by tap_mode
      NT_Track track <= tracks.get(_trackNr);

      Envelope *env;
      int ctlNr = 0;
      NT_TrackPattern pat <= track.getPattern(edit_pattern_nr);
      if(null != pat)
      {
         foreach env in pat.controllers
         {
            undoTouchController(_trackNr, edit_pattern_nr, ctlNr, env);
            ctlNr++;
         }
      }
   }

   // <ui_undo.png>
   public =replay= undoTouchTrackLayout(int _trackNr, NT_TEL _tel) {
      if(b_skip_rec_undo)
         return;

      if(null != ui_undo_entry)
      {
         ui_undo_entry.touchTrackLayout(_trackNr, _tel);
      }
      else
      {
         trace "[---] undoTouchTrackLayout: internal error: no transaction in progress !!! (ignoring)";
      }
   }

   // <ui_undo.png>
   public =replay= undoTouchNodeState() {
      if(b_skip_rec_undo)
         return;

      if(null != ui_undo_entry)
      {
         ui_undo_entry.touchNodeState(this);
      }
      else
      {
         trace "[---] undoTouchTrackLayout: internal error: no transaction in progress !!! (ignoring)";
      }
   }

   // <ui_undo.png>
   public method undoEnd() : boolean {
      if(b_skip_rec_undo)
         return;

      // Returns true if undo entry was actually created (empty ones are discarded)
      boolean ret = false;
      if(null == ui_undo_entry)
      {
         // trace "[---] NodeTracker::undoEnd: internal error: no transaction in progress !!!";
      }
      else
      {
         ret = ui_undo_stack.endEntry(ui_undo_entry);
         ui_undo_entry <= null;

         if(nodeIsEditorVisible())
         {
            editor.queueUpdateBidirectionalControls();
         }
      }
      return ret;
   }

   // <ui_undo.png>
   public =replay= method undoEndCond(String _name) {
      if(b_skip_rec_undo)
         return;

      if(null != ui_undo_entry)
      {
         if(ui_undo_entry.name == _name)
         {
            ui_undo_stack.endEntry(ui_undo_entry);
            ui_undo_entry <= null;

            if(nodeIsEditorVisible())
            {
               editor.queueUpdateBidirectionalControls();
            }
         }
      }
   }

   // <ui_undo.png>
   public =replay= method undoEndNested(String _name) {
      if(b_skip_rec_undo)
         return;

      undoEndCond(_name);
   }

   // <ui_undo.png>
   public =replay= undoEndCondPat() {
      if(b_skip_rec_undo)
         return;

      if(STConfig.b_node_tracker_undo_record_single_transaction)
      {
         if(replay.b_playing)
         {
            if(b_rt_record)
            {
               // Undo transaction ends when replay is stopped or edit mode is deactivated
               return;
            }
         }
      }
      // Finish single-step edit undo transaction
      undoEnd();
   }

   // <ui_undo.png>
   public method undoEmpty() {
      if(null != ui_undo_entry)
      {
         trace "[---] NodeTracker::undoEmpty: internal error: transaction \""+(ui_undo_entry.name)+"\" still in progress !!! (discarding entry)";
         // // ui_undo_stack.endEntry(ui_undo_entry);
         ui_undo_entry <= null;
      }
      ui_undo_stack.empty();

      Global.Print("undo history cleared.");
   }

   // <save.png>
   public virtual nodeSaveState(Stream ofs) {
      ofs.i16 = 42; // Version

      Node::nodeSaveState(ofs);

      ofs.i8 = edit_pattern_nr;

      ofs.i8 = b_extclk_resetval; // v5+
      ofs.i16 = extclk_gatetime_resetval; // v5+
      ofs.i8 = play_mode;
      ofs.i8 = b_change_reset; // v6+
      ofs.i8 = 0;  // unused in v19+, previously: change_mode
      ofs.i16 = 0; // unused in v19+; previously: change_quant_ticks
      ofs.i16 = offlen_ticks_resetval; // v8+
      ofs.f32 = dur_ticks_resetval; // v15+
      ofs.i8  = b_per_pattern_kj_instr; // v42+

      // // pre v20:
      // // ofs.i8 = b_auto_filter_a; // v7+
      // // ofs.i8 = auto_dev_filter_a;
      // // ofs.i8 = auto_ch_filter_a;
      // // ofs.i8 = b_auto_filter_b; // v7+
      // // ofs.i8 = auto_dev_filter_b;
      // // ofs.i8 = auto_ch_filter_b;

      ofs.i8 = b_noteon_to_prgchg;
      ofs.i8 = noteon_to_prgchg_base_note;
      ofs.i8 = noteoff_to_prgchg_note_offset;

      ofs.i8 = pv_track_shift; // v2+
      ofs.i8 = pv_cursor_track; // v2+
      ofs.i8 = pv_cursor_x; // v2+
      ofs.i16 = pv_step_resolution; // v2+
      ofs.i16 = pv_zoom_preset_1;    // v32+
      ofs.i16 = pv_zoom_preset_2;    // v32+
      ofs.i8  = pv_zoom_preset_idx;  // v32+
      ofs.i32 = pv_pat_offset; // v2+

      ofs.i8 = solo_track_nr; // v2+

      ofs.f32 = def_velocity; // v2+
      ofs.f32 = def_duration; // v2+

      ///// ofs.i32 = last_pattern_start_song_offset; // v2+ , pre v16

      // Write arp settings (v9+)
      ofs.i8 = b_arp;
      ofs.i8 = b_arp_reset;
      ofs.i8 = arp_base_octave;
      ofs.i8 = b_arp_wrap; // v10+
      ofs.i8 = arp_latch_num_notes; // v11+
      ofs.i8 = b_arp_latch_reset;   // v11+
      ofs.i8 = b_arp_play_arp_notes; // v12+
      ofs.i8 = b_arp_play_non_arp_notes; // v12+
      ofs.i8 = b_arp_dynalen; // v14+
      Utils.WriteIntArray(ofs, arp_note_table); // v9+

      // Write KeyJazz recording default settings (v13+)
      ofs.i8 = b_write_instrnr;
      ofs.i8 = b_write_noteon_velocity;
      ofs.i8 = write_noteon_velocity;
      ofs.i8 = b_write_noteoff_velocity;
      ofs.i8 = write_noteoff_velocity;
      ofs.i8 = b_write_duration;
      ofs.i8 = write_duration;

      ofs.i8 = b_match_instr; // v21+
      ofs.i8 = b_rec_prev; // v23+
      ofs.i8 = b_rec_all;  // v23+
      ofs.i8 = b_rec_spread;  // v33+
      ofs.i8 = b_rec_bg;   // v23+
      ofs.i8 = rec_mode; // v22+
      ofs.i8 = rec_sel; // v24+
      ofs.i8 = b_rec_quantize_last_step; // v24+
      ofs.i8 = b_echo_frame_rec_to_play; // v41+

      // Write misc UI settings (v13+)
      ofs.i16 = ui_step_alignment;
      ofs.f32 = ui_highlight_tick_modulo;
      ofs.i8 = current_microshift_idx; // v25+

      // Write meta patterns
      NT_MetaPattern *mpat;
      int patIdx = 0;
      loop(128)
      {
         mpat <= meta_patterns.get(patIdx);

         if(null != mpat)
         {
            if(!mpat.b_empty)
            {
               mpat.patSaveState(ofs);
            }
            else
            {
               // Unused
               ofs.i16 = 0; // (version)
            }
         }
         else
         {
            // Unused
            ofs.i16 = 0; // (version)
         }

         // Next meta pattern
         patIdx++;
      }

      // Write tracks (v2)
      ofs.i8 = tracks.numElements;
      int trackNr = 0;
      loop(tracks.numElements)
      {
         NT_Track track <= tracks.get(trackNr);

         // Write name
         Utils.WriteString(ofs, track.name);

         // Write muted flag
         ofs.i8 = track.is_muted;

         ofs.i8 = track.current_instrument_nr;

         ofs.i8 = track.cursor_x;

         ofs.i8 = track.keyjazz_instr_nr;
         ofs.i8 = track.keyjazz_octave;
         ofs.i8 = track.keyjazz_on_velocity;
         ofs.i8 = track.keyjazz_off_velocity;
         ofs.i8 = track.keyjazz_duration;
         ofs.i8 = track.keyjazz_last_note; // v18+

         // Write track patterns
         int allPatStartOff = ofs.offset;
         ofs.i32 = 0;

         patIdx = 0;
         loop(128)
         {
            mpat <= meta_patterns.get(patIdx);

            if(null != mpat)
            {
               if(!mpat.b_empty)
               {
                  NT_TrackPattern pat <= track.getOrCreatePattern(patIdx); // (note) pattern should already exist
                  int patStartOff = ofs.offset;
                  ofs.i32 = 0;
                  pat.saveState(ofs, -1/*forcePatNr*/);
                  Utils.FixChunkSize(ofs, patStartOff);
               }
            }

            // Next pattern
            patIdx++;
         }

         Utils.FixChunkSize(ofs, allPatStartOff);

         // Write track layout (v3+)
         NT_TEL tel <= track.tel;
         ofs.i8 = tel.ctl_layouts.numElements;
         NT_CEL *cel;
         foreach cel in tel.ctl_layouts
         {
            ofs.i8 = cel.b_visible;
            ofs.i8 = cel.ctl_id;
            ofs.i8 = cel.style;
            ofs.i8 = cel.alt_style; // v34+
            ofs.i8 = cel.range;
            ofs.i32 = cel.bg_tint;
         }

         // Write tracklayout cel filter (v26+)
         tel.ui_filter.saveStream(ofs);

         // Next track
         trackNr++;
      }

      // Write instruments (v4+)
      int allInsStartOff = ofs.offset;
      ofs.i32 = 0;

      NT_Instrument *ins;
      foreach ins in instruments
      {
         if(null != ins)
         {
            int insStartOff = ofs.offset;
            ofs.i32 = 0;

            ins.saveState(ofs);

            Utils.FixChunkSize(ofs, insStartOff);
         }
      }

      Utils.FixChunkSize(ofs, allInsStartOff);

      // Last used view/tab
      ofs.i8 = ui_last_view; // v17+

      // Envelope view visibility
      ofs.i8 = b_envelope_view_visible; // v27+

      // Envelope view split y
      ofs.f32 = envelope_view_split; // v28+

      ofs.i8  = envelope_view_edit_mode;        // v29+
      ofs.i8  = envelope_view_zoom_mode;        // v29+
      ofs.i8  = b_envelope_view_replace;        // v31+
      ofs.i16 = envelope_view_edit_grid_size;   // v29+
      ofs.i32 = envelope_view_tick_offset;      // v29+
      ofs.i8  = envelope_view_block_grid_mode;  // v29+
      ofs.i32 = envelope_view_custom_vis_ticks; // v30+

      // PianoWidget (v35+)
      ofs.i8 = b_ui_piano;

      // Sample import filter (v36+)
      Utils.WriteString(ofs, smp_import_filter);

      // Last VST dev/ch (v37+)
      ofs.i8 = last_vst_dev;
      ofs.i8 = last_vst_ch;

      // Audio/MIDI linked node GIDs (v38+)
      ofs.i32 = midi_node_gid;         // v38+
      ofs.i32 = audio_node_gid;        // v38+
      ofs.i8  = b_audiomidi_mutex;     // v39+
      ofs.i8  = b_audionode_midimute;  // v40+
   }

   // <load.png>
   public virtual nodeLoadState(Stream ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      short ver = ifs.i16;

      if(ver >= 1)
      {
         if(!Node::nodeLoadState(ifs, _outDevIdxMap, _outDevUseCount))
         {
            return false;
         }

         edit_pattern_nr = ifs.i8;
         play_pattern_nr = edit_pattern_nr;
         jam_queued_pattern_nr = -1;

         if(ver >= 5)
         {
            b_extclk_resetval = ifs.i8;
            extclk_gatetime_resetval = ifs.i16;
         }

         play_mode          = ifs.i8;
         if(ver >= 6)
         {
            b_change_reset = ifs.s8; // signed for 'maybe' state (-1)
         }
         ifs.getI8();  // unused in v19+; previously: change_mode
         ifs.getU16(); // unused in v19+; previously: change_quant_ticks
         if(ver >= 8)
         {
            offlen_ticks_resetval = ifs.u16;

            if(ver >= 15)
            {
               dur_ticks_resetval = ifs.f32;
            }
         }

         if(ver >= 42)
         {
            b_per_pattern_kj_instr = ifs.b8; // v42+
         }

         if(ver < 20) // (note) handle by base class in newer versions
         {
            if(ver >= 7)
            {
               b_auto_filter_a = ifs.i8;
            }
            auto_dev_filter_a = ifs.s8;
            auto_ch_filter_a  = ifs.s8;

            // trace "xxx read auto_dev_filter="+auto_dev_filter;
            // trace "xxx _outDevIdxMap="+#(_outDevIdxMap);

            if(-1 != auto_dev_filter_a)
            {
               _outDevUseCount.inc(auto_dev_filter_a);

               auto_dev_filter_a = _outDevIdxMap.get(auto_dev_filter_a);
            }

            if(ver >= 7)
            {
               b_auto_filter_b = ifs.i8;
            }
            auto_dev_filter_b = ifs.s8;
            auto_ch_filter_b  = ifs.s8;

            // trace "xxx read auto_dev_filter="+auto_dev_filter;
            // trace "xxx _outDevIdxMap="+#(_outDevIdxMap);

            if(-1 != auto_dev_filter_b)
            {
               _outDevUseCount.inc(auto_dev_filter_b);

               auto_dev_filter_b = _outDevIdxMap.get(auto_dev_filter_b);
            }
         }


         b_noteon_to_prgchg = ifs.b8;
         noteon_to_prgchg_base_note = ifs.i8;
         noteoff_to_prgchg_note_offset = ifs.s8;

         if(ver >= 2)
         {
            pv_track_shift     = ifs.i8; // v2+
            pv_cursor_track    = ifs.i8; // v2+
            pv_cursor_x        = ifs.i8; // v2+
            pv_step_resolution = ifs.i16; // v2+
            if(ver >= 32)
            {
               pv_zoom_preset_1   = ifs.u16; // v32+
               pv_zoom_preset_2   = ifs.u16; // v32+
               pv_zoom_preset_idx = ifs.u8;  // v32+
            }
            pv_pat_offset      = ifs.i32; // v2+

            solo_track_nr = ifs.s8; // v2+

            def_velocity = ifs.f32; // v2+
            def_duration = ifs.f32; // v2+

            if(ver < 16)
            {
               last_pattern_start_song_offset = ifs.i32; // v2+, pre v16
            }
         }

         if(ver >= 9)
         {
            // Read arp settings (v9+)
            b_arp           = ifs.b8;
            b_arp_reset     = ifs.b8;
            arp_base_octave = ifs.i8;
            if(ver >= 10)
            {
               b_arp_wrap = ifs.i8;

               if(ver >= 11)
               {
                  arp_latch_num_notes = ifs.i8;
                  b_arp_latch_reset   = ifs.b8;

                  if(ver >= 12)
                  {
                     b_arp_play_arp_notes     = ifs.b8; // v12+
                     b_arp_play_non_arp_notes = ifs.b8; // v12+

                     if(ver >= 14)
                     {
                        b_arp_dynalen = ifs.i8; // v14+
                     }
                  }
               }
            }
            Utils.ReadIntArray(ifs, arp_note_table);

            if(ver >= 13)
            {
               // Read KeyJazz recording settings
               b_write_instrnr           = ifs.b8;
               b_write_noteon_velocity   = ifs.b8;
               write_noteon_velocity     = ifs.i8;
               b_write_noteoff_velocity  = ifs.b8;
               write_noteoff_velocity    = ifs.i8;
               b_write_duration          = ifs.b8;
               write_duration            = ifs.i8;

               if(ver >= 21)
               {
                  b_match_instr = ifs.s8; // v21+
               }

               if(ver >= 23)
               {
                  b_rec_prev = ifs.b8;  // v23+
                  b_rec_all  = ifs.b8;  // v23+
                  if(ver >= 33)
                  {
                     b_rec_spread = ifs.b8; // v33+
                  }
                  b_rec_bg   = ifs.b8;  // v23+
               }

               if(ver >= 22)
               {
                  rec_mode = ifs.u8; // v22+
               }

               if(ver >= 24)
               {
                  rec_sel = ifs.u8;  // v24+
                  b_rec_quantize_last_step = ifs.b8; // v24+
               }

               if(ver >= 41)
               {
                  b_echo_frame_rec_to_play = ifs.b8; // v41+
               }

               // Read misc UI settings (v13+)
               ui_step_alignment = ifs.i16;
               ui_highlight_tick_modulo = ifs.f32;

               if(ver >= 25)
               {
                  current_microshift_idx = ifs.u8;
               }
            }
         }

         // Read meta patterns
         int patIdx = 0;
         loop(128)
         {
            short patVer = ifs.i16;

            // trace "xxx try read patIdx="+patIdx+" patVer="+patVer;

            if(patVer > 0)
            {
               NT_MetaPattern mpat <= new NT_MetaPattern;

               mpat.patInit(this, patIdx);
               mpat.b_empty = false;

               meta_patterns[patIdx] = deref mpat;

               if(!mpat.patLoadState(ifs, patVer, _outDevIdxMap, _outDevUseCount))
               {
                  return false;
               }
            }
            else
            {
               // unused
               mpat <= meta_patterns.get(patIdx);
               if(null != mpat)
               {
                  mpat.patInit(this, patIdx);
               }
            }

            patIdx++;
         }

         // Read tracks (v2)
         if(ver >= 2)
         {
            int numTracks = ifs.i8;
            tracks.free();
            int trackNr = 0;
            loop(numTracks)
            {
               NT_Track track <= new NT_Track;
               track.init(this, trackNr);

               // Read name
               Utils.ReadString(ifs, track.name);

               track.is_muted = ifs.i8;

               track.current_instrument_nr = ifs.i8;

               track.cursor_x = ifs.i8;

               track.keyjazz_instr_nr     = ifs.u8;
               track.keyjazz_octave       = ifs.u8;
               track.keyjazz_on_velocity  = ifs.u8;
               track.keyjazz_off_velocity = ifs.u8;
               track.keyjazz_duration     = ifs.u8;
               if(ver >= 18)
               {
                  track.keyjazz_last_note = ifs.u8;
               }

               // Read track patterns
               int allTrackPatStartOff = ifs.offset;
               int allTrackPatBytes = ifs.i32;
               int allTrackPatBytesLeft = allTrackPatBytes - 4;

               while(allTrackPatBytesLeft > 0)
               {
                  int trackPatStartOff = ifs.offset;
                  int trackPatBytes = ifs.i32;
                  NT_TrackPattern pat <= new NT_TrackPattern;
                  pat.init(track, 0/*placeholder patnr*/);
                  if(!pat.loadState(ifs))
                  {
                     return false;
                  }

                  if( (ifs.offset - trackPatStartOff) != trackPatBytes)
                  {
                     trace "[---] NodeTracker::loadState: wrong track pattern read size. expected "+trackPatBytes+", have "+(ifs.offset - trackPatStartOff);
                     return false;
                  }

                  track.setPattern(pat.pat_nr, deref pat);
                  pat.meta_pattern <= getOrCreateMetaPattern(pat.pat_nr); // [04Feb2017] update placeholder

                  allTrackPatBytesLeft -= trackPatBytes;


                  // import old randomparams from metapattern
                  //  (moved to track pattern in newer versions)
                  if(0 == trackNr)
                  {
                     mpat <= meta_patterns.get(pat.pat_nr);
                     if(null != mpat.randomParamsDummy)
                     {
                        NT_RandomParams randomParamsOldImport <= pat.getOrCreateRandomParams();
                        randomParamsOldImport.copyFrom(mpat.randomParamsDummy);
                     }
                  }

               }

               if(0 != allTrackPatBytesLeft)
               {
                  trace "[---] NodeTracker::loadState: wrong alltrackpat siz. expected "+allTrackPatBytes+", have "+(ifs.offset - allTrackPatStartOff);
                  return false;
               }

               tracks[trackNr] = deref track;

               // Read track layout (v3+)
               NT_TEL tel <= track.tel;

               if(ver >= 3)
               {
                  // Read #cels (should be NT_TEL.NUM_CELS)
                  int numCels = ifs.i8;
                  int celNr = 0;
                  NT_CEL *cel;
                  loop(numCels)
                  {
                     cel <= tel.ctl_layouts.get(celNr);
                     if(null != cel)
                     {
                        cel.alt_style = -1;
                        cel.b_visible = ifs.b8;
                        cel.ctl_id    = ifs.i8;
                        cel.style     = ifs.i8;
                        if(ver >= 34)
                        {
                           cel.alt_style = ifs.s8; // v34+
                        }
                        cel.range     = ifs.i8;
                        cel.bg_tint   = ifs.i32;
                     }
                     else
                     {
                        trace "[~~~] NodeTracker::loadState: cel "+celNr+" does not exist. skipping..";
                        ifs.seek(8, SEEK_CUR);
                     }
                     celNr++;
                  }
                  tel.calcCursorExtents();
               }

               // Read tracklayout cel filter (v26+)
               if(ver >= 26)
               {
                  if(!tel.ui_filter.loadStream(ifs))
                  {
                     return false;
                  }
               }

               // Next track
               trackNr++;

            } // loop numTracks

            // Read instruments
            if(ver >= 4)
            {
               int allInsStartOff = ifs.offset;
               int allInsBytes = ifs.i32;
               int allInsBytesLeft = allInsBytes - 4;

               while(allInsBytesLeft > 0)
               {
                  int insStartOff = ifs.offset;
                  int insBytes = ifs.i32;

                  NT_Instrument ins <= new NT_Instrument;
                  ins.init(this, 0/*instrument_nr placeholder*/);

                  if(!ins.loadState(ifs, _outDevIdxMap, _outDevUseCount))
                  {
                     trace "[---] NodeTracker::loadState: failed to load instrument.";
                     // // ifs.seek(insStartOff + insBytes, SEEK_SET);
                     break;
                  }

                  setInstrument(ins.instrument_nr, deref ins);

                  allInsBytesLeft -= insBytes;
               }

               if(0 != allInsBytesLeft)
               {
                  trace "[---] NodeTracker::loadState: expected all instr chunk size="+allInsBytes+", read "+(ifs.offset - allInsStartOff);
                  return false;
               }

            } // if ver >= 4

         } // if ver >= 2

         // Last used view/tab
         if(ver >= 17)
         {
            ui_last_view = ifs.u8;
         }

         if(ver >= 27)
         {
            b_envelope_view_visible = ifs.b8;

            if(ver >= 28)
            {
               envelope_view_split = ifs.f32;
            }

            if(ver >= 29)
            {
               envelope_view_edit_mode       = ifs.u8;   // v29+
               envelope_view_zoom_mode       = ifs.u8;   // v29+

               if(ver >= 31)
               {
                  b_envelope_view_replace = ifs.b8;  // v31+
               }

               envelope_view_edit_grid_size  = ifs.u16;  // v29+
               envelope_view_tick_offset     = ifs.i32;  // v29+
               envelope_view_block_grid_mode = ifs.u8;   // v29+

               if(ver >= 30)
               {
                  envelope_view_custom_vis_ticks = ifs.i32;  // v30+
               }
            }
         }

         if(ver >= 35)
         {
            // PianoWidget (v35+)
            b_ui_piano = ifs.b8;
         }

         if(ver >= 36)
         {
            // Sample import filter (v36+)
            Utils.ReadString(ifs, smp_import_filter);
         }

         if(ver >= 37)
         {
            // Last VST dev/ch (v37+)
            last_vst_dev = ifs.s8;
            last_vst_ch  = ifs.s8;
         }

         // Audio/MIDI linked node GIDs (v38+)
         if(ver >= 38)
         {
            midi_node_gid = ifs.i32; // v38+
            audio_node_gid = ifs.i32; // v38+

            if(ver >= 39)
            {
               b_audiomidi_mutex = ifs.s8;  // v39+
            }

            if(ver >= 40)
            {
               b_audionode_midimute = ifs.s8;  // v40+
            }
         }

         return true;
      }

      return false;
   }

   // <method_update.png>
   public virtual nodeUpdateClonedGIDs(IntArray _newGIDMap) {
      Node::nodeUpdateClonedGIDs(_newGIDMap);

      int idx;

      if(-1 != midi_node_gid)
      {
         idx = _newGIDMap.indexOf(midi_node_gid, 0);
         if(-1 != idx)
         {
            if(0 == (idx & 1))  // is "old" GID ?
            {
               midi_node_gid = _newGIDMap.get(idx + 1);  // replace by new GID
            }
            else
            {
               // should not be reachable
               trace "[!!!] NodeTracker::nodeUpdateClonedGIDs: midi_node_gid="+midi_node_gid+" already is a new GID";
            }
         }
         else
         {
            // can be reachable when loading node/pipe preset and "external" arranger node is referenced
            trace "[~~~] NodeTracker::nodeUpdateClonedGIDs: midi_node_gid="+midi_node_gid+" => node not found in newGIDMap="+_newGIDMap+" (was external?";
         }
      }

      if(-1 != audio_node_gid)
      {
         idx = _newGIDMap.indexOf(audio_node_gid, 0);
         if(-1 != idx)
         {
            if(0 == (idx & 1))  // is "old" GID ?
            {
               audio_node_gid = _newGIDMap.get(idx + 1);  // replace by new GID
            }
            else
            {
               // should not be reachable
               trace "[!!!] NodeTracker::nodeUpdateClonedGIDs: audio_node_gid="+audio_node_gid+" already is a new GID";
            }
         }
         else
         {
            // can be reachable when loading node/pipe preset and "external" arranger node is referenced
            trace "[~~~] NodeTracker::nodeUpdateClonedGIDs: audio_node_gid="+audio_node_gid+" => node not found in newGIDMap="+_newGIDMap+" (was external?";
         }
      }
   }

   // <ui_midi.png>
   protected method recordMIDINote(NT_Track track, byte _note, byte _vel, int _dur, boolean _bFramePlay) : boolean {
      // returns true if recorded note will be replayed by future tick

      int noteCelIdx;
      int cNote;
      boolean bCelFound;
      NT_TEL *tel;
      NT_CEL *cel;
      NT_CEL *celBak;
      NT_CEL *noteCel;
      var e;
      IntArray *currentNotes;
      IntArray *recNoteOnPatOff;
      IntArray *recNoteOnSongTicks;
      IntArray *recNoteOnPatNrs;
      IntArray *recNoteOnDurCtlIds;
      IntArray *recNoteOnDurLeft;
      int velCtlId;
      boolean bFutureEv = false;
      int ctlId;

      // trace "xxx recordMIDINote: note="+_note+" vel="+_vel+" dur="+_dur+" bFramePlay="+_bFramePlay;

      Integer recRes = STConfig.b_node_tracker_recordquantize ? pv_step_resolution : 1;

      // Current cursor pos in step-editor mode or replay position
      int patOffsetRecRaw = getRecordPatOffsetMidiRec(false/*bMayQuantize*/, false/*bForceReplayPos*/, _bFramePlay);
      // trace "xxx patOffsetRecRaw="+patOffsetRecRaw;

      int patLen = getCurrentEditMetaPatternLength();

      int patOffsetRecStep = (patOffsetRecRaw / pv_step_resolution) * pv_step_resolution;  // for raster clear
      int patOffsetPlay = getPlayPatOffset();
      int patOffsetPlayStep = ((patOffsetPlay % patLen) / pv_step_resolution) * pv_step_resolution;

      boolean bRTRecord = b_rt_record;
      int recRaster = bRTRecord ? recRes : pv_step_resolution;

      boolean bRecorded = false;

      tel <= track.getTrackLayout();

      if(null != tel)
      {
         int durCtlId;

         NT_Instrument kjIns <= getInstrument(track.keyjazz_instr_nr);

         currentNotes <= track.rec_current_notes;
         // trace "xxx recordMIDINote: tracknr="+track.track_nr+" currentNotes="+#(currentNotes);
         recNoteOnPatOff    <= track.rec_noteon_patoff;
         recNoteOnSongTicks <= track.rec_noteon_song_ticks;
         recNoteOnPatNrs    <= track.rec_noteon_patnrs;
         recNoteOnDurCtlIds <= track.rec_noteon_dur_ctl_ids;
         recNoteOnDurLeft   <= track.rec_noteon_dur_left;  // #ticks, required for NodeSeq=>tracker export (polypressure)

         int ctlMapId = tel.cursor_to_ctl_map[track.cursor_x];
         cel <= tel.ctl_layouts[ctlMapId&31]; // mask out MSB_FLAG

         if(_bFramePlay)
         {
            // Previous node output, ignore cursor position and start with first visible note cel
            cel <= tel.findVisibleNoteCelByIdx(0);
         }

         if(null == cel)
            return false;

         if(NT_CEL.STYLE_NOTE != cel.style)
         {
            if(bRTRecord)
            {
               // Realtime recording. Ignore cursor position and start with first visible note cel
               cel <= tel.findVisibleNoteCelByIdx(0);

               if(null == cel)
                  return false;
            }
         }

         if(NT_CEL.STYLE_NOTE == cel.style)
         {
            // Track last played note
            if(_note >= 0)
            {
               track.keyjazz_last_note = _note;
            }

            int patOffsetRec;

            // Find unused note cel
            bCelFound = false;

            int prefNoteCelStartIdx = 0;

            int numVisibleNoteCels = tel.getNumVisibleNoteCels();

            undoBeginNested("record MIDI");

            if(_note < 0)
            {
               // Note off

               patOffsetRec = getRecordPatOffsetMidiRec(
                  !STConfig.b_node_tracker_recordnoteoff_dur/*bMayQuantize*/,
                  false/*bForceReplayPos*/,
                  _bFramePlay
                                                        );

               // trace "xxx recordMIDINote<off>: offPlay="+patOffsetPlay+" offRec="+patOffsetRec;

               if(!bRTRecord)
               {
                  patOffsetRec = fixOffsetToExistingTrackEventAtWindow(track, cel.ctl_id, patOffsetRec, recRaster);
               }

               // Try to place note-off in cel that currently belongs to an active note-on
               noteCelIdx = 0;
               ctlId = -1;
               loop(NT_TrackPattern.NUM_NOTESLOTS)
               {
                  if(currentNotes[noteCelIdx] == -_note)
                  {
                     ctlId = noteCelIdx;
                     break;
                  }
                  noteCelIdx++;
               }

               if(-1 == ctlId)
                  noteCelIdx = 0;

               // (note) ctlId is overwritten by cel.ctl_id before it's used


               // Chord note off: find cel that triggered the currently played note
               // trace "xxx find noteCelIdx for noteOff="+(-_note);
               loop(NT_TrackPattern.NUM_NOTESLOTS)
               {
                  cNote = currentNotes[noteCelIdx];
                  // trace "xxx noteoff: track.ui_rec_current_notes["+noteCelIdx+"] note="+cNote;
                  if(cNote == -_note)
                  {
                     // found it
                     noteCel <= tel.findVisibleNoteCelByIdx(noteCelIdx);
                     if(null != noteCel)
                     {
                        // Check if an event already exists
                        e = getEventAt(track, noteCel.ctl_id, patOffsetRec, recRes);
                        if(typeid(e) != YAC_TYPE_FLOAT)
                        {
                           // No event, yet
                           // trace "xxx found cel for note-off";
                           bCelFound = true;
                        }
                        cel <= noteCel; // use cel as startpoint for fallback search
                     }
                     break;
                  }

                  noteCelIdx = (noteCelIdx + 1) % NT_TrackPattern.NUM_NOTESLOTS;
               }
            }
            else
            {
               // Note on
               // trace "xxx nt:noteon: track.rec_num_active_notes="+track.rec_num_active_notes;

               patOffsetRec = getRecordPatOffsetMidiRec(true/*bMayQuantize*/,
                                                        false/*bForceReplayPos*/,
                                                        _bFramePlay
                                                        );

               if(!bRTRecord)
               {
                  patOffsetRec = fixOffsetToExistingTrackEventAtWindow(track, cel.ctl_id, patOffsetRec, recRaster);
               }

               // trace "xxx recordMIDINote<on>: offPlay="+patOffsetPlay+" offRec="+patOffsetRec;

               // Chord note-on: find (possibly) unused cel
               // trace "xxx find noteCelIdx for noteOn="+(_note);
               if(1 == track.rec_num_active_notes)
               {
                  // always assign cursor cel to first note (keep current cel)
                  bCelFound = true;

                  if(!b_rt_record && b_chord_clear_step)
                  {
                     for(noteCelIdx = 0; noteCelIdx < NT_TrackPattern.NUM_NOTESLOTS; noteCelIdx++)
                     {
                        removeEventAt(track, NT_TrackPattern.CTL_NOTE1 + noteCelIdx, patOffsetRec, recRaster);
                        shiftEventsAt(track, NT_TrackPattern.CTL_NOTE1 + noteCelIdx, patOffsetRec, recRaster);
                     }
                  }

               }
               else
               {
                  // Chords: prefer cel next to cursor note cel (e.g. reserve first cel for ###)
                  noteCelIdx = 0;
                  if(bRTRecord)
                  {
                     int cursorCtlMapId = tel.cursor_to_ctl_map[track.cursor_x];
                     NT_CEL cursorCel <= tel.ctl_layouts[cursorCtlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                     if(null != cursorCel)
                     {
                        if(cursorCel.isNoteCtl())
                        {
                           noteCelIdx = tel.findIdxByVisibleNoteCel(cursorCel);
                           prefNoteCelStartIdx = noteCelIdx;
                           // trace "xxx currentNotes="+#(currentNotes);
                           boolean bFoundUnusedChordCel = false;
                           loop(numVisibleNoteCels)
                           {
                              if(currentNotes[noteCelIdx] < 0)
                              {
                                 bFoundUnusedChordCel = true;
                                 break;
                              }
                              noteCelIdx = (noteCelIdx + 1) % numVisibleNoteCels;//NT_TrackPattern.NUM_NOTESLOTS;
                           }
                           if(!bFoundUnusedChordCel)
                           {
                              noteCelIdx = prefNoteCelStartIdx + (track.rec_num_active_notes - 1);
                              noteCelIdx = (noteCelIdx % numVisibleNoteCels);
                              // trace "xxx chordNoteCelIdx="+noteCelIdx;
                           }
                        }
                     }
                     // trace "xxx NodeTracker::recordMIDINote: chord note on: start with noteCelIdx="+noteCelIdx;
                  }

                  loop(numVisibleNoteCels)
                  {
                     cNote = currentNotes[noteCelIdx];
                     // trace "xxx nt:noteon: track.rec_current_notes["+noteCelIdx+"] note="+cNote;
                     if(-1 == cNote)
                     {
                        noteCel <= tel.findVisibleNoteCelByIdx(noteCelIdx); // get visible cel
                        if(null != noteCel)
                        {
                           // Check if an event already exists
                           e = getEventAt(track, noteCel.ctl_id, patOffsetRec, recRes);
                           if(typeid(e) != YAC_TYPE_FLOAT)
                           {
                              // No event, yet
                              // trace "xxx found cel for note-on";
                              bCelFound = true;
                           }
                           cel <= noteCel; // use cel as startpoint for fallback search
                        }
                        break;
                     }
                     noteCelIdx = (noteCelIdx + 1) % numVisibleNoteCels;
                  }
               }
            }

            if(!bCelFound)
            {
               noteCelIdx = (prefNoteCelStartIdx + (track.rec_num_active_notes - 1)) % numVisibleNoteCels;
               noteCel <= tel.findVisibleNoteCelByIdx(noteCelIdx);
               if(null != noteCel)
                  cel <= noteCel;

               // Chords: find unused note ctl
               loop(numVisibleNoteCels) // max. 5 note ctls per pattern (CTL_NOTE1..CTL_NOTE5)
               {
                  e = getEventAt(track, cel.ctl_id, patOffsetRec, recRes);
                  if(typeid(e) == YAC_TYPE_FLOAT)
                  {
                     // Note event already exists, try next notectl
                     cel <= tel.findNextVisibleNoteCel(cel);
                  }
                  else
                  {
                     // OK, found unused note ctl
                     bCelFound = true;
                     break;
                  }
                  noteCelIdx = (noteCelIdx + 1) % numVisibleNoteCels;
               }

               if(!bCelFound)
               {
                  // Note cel == active note idx
                  celBak <= cel;
                  cel <= tel.findVisibleNoteCelByIdx((prefNoteCelStartIdx + (track.rec_num_active_notes - 1)) % numVisibleNoteCels);
                  if(null == cel)
                     cel <= celBak;
               }
            }

            ctlId = cel.ctl_id;

            noteCelIdx = tel.findIdxByVisibleNoteCel(cel);

            if(_note < 0)
            {
               // *** Note-off ***

               if(DoRecordNoteOff() && !STConfig.b_node_tracker_recordnoteoff_dur)
               {
                  /////if(replay.b_playing)
                  if(b_rt_record)
                  {
                     if(REC_MODE_RASTER == rec_mode)
                     {
                        if( (0 == num_rec_notes) ||
                            (patOffsetRecStep != patOffsetPlayStep)
                            )
                        {
                           if(rec_clear_last_step != patOffsetRecStep*pv_step_resolution)
                           {
                              // Clear raster
                              clearRaster(track, patOffsetRecStep*pv_step_resolution);
                           }
                        }
                     }
                  }

                  insertReplaceEventAtRes(track, ctlId, _note, patOffsetRec, recRes);
                  last_rec_soff = patOffsetRec;
                  last_rec_eoff = patOffsetRec + recRes;
                  num_rec_notes++;

                  if(-1 == rec_clear_start)
                  {
                     rec_clear_start = patOffsetRecStep;
                     b_rec_clear_start_wrap = (patOffsetRecStep < patOffsetPlayStep);
                  }

                  velCtlId = ctlId + NT_TrackPattern.NUM_NOTESLOTS;

                  if(null == tel.findVisibleCelForCtlById(velCtlId)) // VEL1..5 follow directly after NOTE1..5 ctls
                  {
                     velCtlId = NT_TrackPattern.CTL_VEL1;
                  }

                  if((ctlId==(velCtlId - NT_TrackPattern.NUM_NOTESLOTS)) && (null != kjIns)) // first note ctl?
                  {
                     if(isWriteOffVelocityEnabled())
                     {
                        insertReplaceEventAtRes(track, velCtlId, _vel, patOffsetRec, recRes);
                     }

                     if(isWriteInstrumentNrEnabled())
                     {
                        insertReplaceEventAtRes(track, NT_TrackPattern.CTL_INSTR, track.keyjazz_instr_nr, patOffsetRec, recRes);
                     }
                  }

                  bRecorded = true;
               }

               if(replay.b_playing && STConfig.b_node_tracker_recordnoteoff_dur)
               {
                  int noteOnPatOff    = recNoteOnPatOff   [-_note];
                  int noteOnSongTicks = recNoteOnSongTicks[-_note];
                  int noteOnPatNr     = recNoteOnPatNrs   [-_note];

                  // trace "xxx nt: note-off: noteOnPatOff="+noteOnPatOff+" noteOnPatNr="+noteOnPatNr;

                  if((-1 != noteOnPatOff) && (noteOnPatNr >= 0))
                  {
                     int noteDur = current_song.tick_nr - noteOnSongTicks;
                     // trace "xxx ==> noteDur="+noteDur;

                     durCtlId = recNoteOnDurCtlIds[-_note];

                     if(null == tel.findVisibleCelForCtlById(durCtlId))
                     {
                        durCtlId = NT_TrackPattern.CTL_DUR1;

                        if(null == tel.findVisibleCelForCtlById(durCtlId))
                        {
                           durCtlId = -1;
                        }
                     }

                     if(-1 != durCtlId)
                     {
                        noteDur = (noteDur / dur_ticks);

                        if(noteDur < 1)
                           noteDur = 1;

                        if(-1 != noteOnPatNr)
                        {
                           // (note) note on pattern might differ from note off pattern during multi-pattern recording
                           int savePatNr = edit_pattern_nr;
                           edit_pattern_nr = noteOnPatNr;
                           insertReplaceEventAtRes(track, durCtlId, noteDur, noteOnPatOff, recRes);
                           edit_pattern_nr = savePatNr;
                        }
                        else
                        {
                           // Should not be reachable
                           trace "[!!!] NodeTracker::recordMIDINote: noteOnPatNr was -1";
                           insertReplaceEventAtRes(track, durCtlId, noteDur, noteOnPatOff, recRes);
                        }

                        Events.SendRedrawPattern();
                     }

                  }
               }

               currentNotes[noteCelIdx] = -1;

               recNoteOnPatOff[-_note] = -1;
            }
            else
            {
               // *** Note-on ***
               recNoteOnPatOff   [_note] = patOffsetRec;
               recNoteOnSongTicks[_note] = current_song.tick_nr;  // for CTL_DURn
               recNoteOnPatNrs   [_note] = edit_pattern_nr;  // for CTL_DURn (multi-pattern recording)

               /////if(replay.b_playing)
               if(b_rt_record)
               {
                  if(REC_MODE_RASTER == rec_mode)
                  {
                     // trace "xxx patOffsetRecStep="+patOffsetRecStep+" patOffsetPlayStep="+patOffsetPlayStep+" numRec="+parent_node.num_rec_notes+" rec_clear_last_step="+parent_node.rec_clear_last_step;
                     if( (0 == num_rec_notes) ||
                         /////(patOffsetRecStep != patOffsetPlayStep) && (0 == (parent_node.tick_nr % step_resolution))
                         (patOffsetRecStep != patOffsetPlayStep)
                         )
                     {
                        if(rec_clear_last_step != patOffsetRecStep*pv_step_resolution)
                        {
                           // Clear raster
                           clearRaster(track, patOffsetRecStep*pv_step_resolution);
                        }
                     }
                  }
               }

               insertReplaceEventAtRes(track, ctlId, _note, patOffsetRec, recRes);
               last_rec_soff = patOffsetRec;
               last_rec_eoff = patOffsetRec + recRes;
               num_rec_notes++;
               b_rec_any_note_on = true;

               if(-1 == rec_clear_start)
               {
                  rec_clear_start = patOffsetRecStep;
                  b_rec_clear_start_wrap = (patOffsetRecStep < patOffsetPlayStep);
                  // trace "xxx nt: NOTE ON (patOffsetRecStep="+patOffsetRecStep+" < patOffsetPlayStep="+patOffsetPlayStep+") = b_rec_clear_start_wrap="+b_rec_clear_start_wrap;
               }

               velCtlId = ctlId + NT_TrackPattern.CTL_VEL1;

               if(null == tel.findVisibleCelForCtlById(velCtlId))
               {
                  velCtlId = NT_TrackPattern.CTL_VEL1;
               }

               durCtlId = ctlId + NT_TrackPattern.CTL_DUR1;

               if(null == tel.findVisibleCelForCtlById(durCtlId))
               {
                  durCtlId = NT_TrackPattern.CTL_DUR1;
               }

               // trace "xxx velCtlId="+velCtlId+" durCtlId="+durCtlId+" dur="+_dur;

               if(0 != _dur)
               {
                  int writeDur = (_dur / dur_ticks);
                  if(writeDur < 1)
                     writeDur = 1;

                  if((replay.b_playing && STConfig.b_node_tracker_recordnoteoff_dur) || _bFramePlay)
                  {
                     insertReplaceEventAtRes(track, durCtlId, writeDur, patOffsetRec, recRes);
                  }
               }
               else
               {
                  if((replay.b_playing && STConfig.b_node_tracker_recordnoteoff_dur) || _bFramePlay)
                  {
                     // Placeholder, will be fixed when note off is received
                     insertReplaceEventAtRes(track, durCtlId, 0/*dur*/, patOffsetRec, recRes);
                  }
                  else if(DoRecordNoteOff())
                  {
                     insertReplaceEventAtRes(track, durCtlId, 0, patOffsetRec, recRes);
                  }
                  else if(isWriteDurationEnabled())
                  {
                     insertReplaceEventAtRes(track, durCtlId, track.keyjazz_duration, patOffsetRec, recRes);
                  }
               }

               if(isWriteInstrumentNrEnabled())
               {
                  insertReplaceEventAtRes(track, NT_TrackPattern.CTL_INSTR, track.keyjazz_instr_nr, patOffsetRec, recRes);
               }

               if(isWriteVelocityEnabled() || (b_rt_record && !_bFramePlay) )
               {
                  insertReplaceEventAtRes(track, velCtlId, _vel, patOffsetRec, recRes);
               }

               if(0 == _dur)
               {
                  if(replay.b_playing)
                  {
                     if(STConfig.b_node_tracker_recordnoteoff_dur)
                     {
                        // Insert place-holder duration (infinite)
                        //  (note) CTL_DUR envs are s&h
                        durCtlId = NT_TrackPattern.CTL_DUR1 + ctlId;

                        if(null == tel.findVisibleCelForCtlById(durCtlId))
                        {
                           durCtlId = NT_TrackPattern.CTL_DUR1;

                           if(null == tel.findVisibleCelForCtlById(durCtlId))
                           {
                              durCtlId = -1;
                           }
                        }

                        if(-1 != durCtlId)
                        {
                           // Placeholder
                           insertReplaceEventAtRes(track, durCtlId, 0/*dur*/, patOffsetRec, recRes);
                        }

                        recNoteOnDurCtlIds[_note] = durCtlId;
                     }
                  }
               }

               // trace "xxx nt::recordMIDINote: note="+_note+" noteCelIdx="+noteCelIdx+" dur="+_dur;
               currentNotes[noteCelIdx] = _note;
               recNoteOnPatNrs[_note] = edit_pattern_nr;
               recNoteOnDurLeft[noteCelIdx] = _dur;  // must track this for polyphonic pressure events (NodeSeq tracker export)

               bRecorded = true;
            }

            // // trace #(currentNotes);

            if(!b_rt_record)
            {
               undoEndNested("record MIDI");
            }

            if(bRecorded || ( (_note < 0) && !b_rt_record ) )
            {
               // Send redraw or redraw+scroll event to UI thread

               if(!b_rt_record)
               {
                  if(STConfig.b_node_tracker_advance_allnotesreleased)
                  {
                     if(0 == track.rec_num_active_notes)
                     {
                        Events.SendScrollDownPattern();
                     }
                     else
                     {
                        Events.SendRedrawPattern();
                     }
                  }
                  else
                  {
                     if(bRecorded)
                     {
                        // Scroll down on every MIDI keypress
                        Events.SendScrollDownPattern();
                     }
                     else
                     {
                        Events.SendRedrawPattern();
                     }
                  }
               }
               else
               {
                  Events.SendRedrawPattern();
               }

               if(bRecorded)
               {
                  if(b_rt_record && (patOffsetRec >= patOffsetPlay))
                  {
                     // Note will be triggered by replay
                     // trace "xxx nt: patOffsetRec="+patOffsetRec+" patOffsetPlay="+patOffsetPlay;
                     bFutureEv = replay.b_playing;
                  }
                  else
                  {
                     // Before play offset, play keyjazz
                  }
               }

            } // if bRecorded

         } // if STYLE_NOTE

      } // if tel

      return bFutureEv;
   }

   // <ui_midi.png>
   protected method recordMIDICtl(NT_Track track,
                                  int              _ctlId,
                                  float            _val,
                                  boolean          _bFramePlay,
                                  boolean          _bAllowRec
                                  ) : boolean {
      // Returns true if recorded event will be played by future tick

      NT_TEL *tel;
      NT_CEL *cel;
      var e;
      boolean bFutureEv = false;

      int recRes = STConfig.b_node_tracker_recordquantize ? pv_step_resolution : 1;

      // Current cursor pos in step-editor mode or replay position
      int patOffsetRecRaw = getRecordPatOffsetMidiRec(false/*bMayQuantize*/, false/*bForceReplayPos*/, _bFramePlay);

      int patOffsetRec = getRecordPatOffsetMidiRec(true/*bMayQuantize*/, false/*bForceReplayPos*/, _bFramePlay);

      int patOffsetRecStep = (patOffsetRecRaw / pv_step_resolution) * pv_step_resolution;
      int patOffsetPlay = getPlayPatOffset();
      int patOffsetPlayStep = (patOffsetPlay / pv_step_resolution) * pv_step_resolution;  // REC_MODE_RASTER

      boolean bRTRecord = b_rt_record;
      Integer recRaster = bRTRecord ? recRes : pv_step_resolution;

      boolean bRecorded = false;

      // trace "xxx recordMIDICtl: ctlId="+_ctlId+" val="+_val;

      tel <= track.getTrackLayout();

      if(null != tel)
      {
         cel <= tel.findVisibleCelForCtlById(_ctlId);

         if(null != cel)
         {
            // trace "xxx recordMIDICtl: offPlay="+patOffsetPlay+" offRec="+patOffsetRec+" track="+#(track)+" tel="+#(tel);

            boolean bRecCtl = true;

            if(REC_SEL_CURRENT_CTL == rec_sel)
            {
               int ctlMapId = tel.cursor_to_ctl_map[track.cursor_x];
               NT_CEL csrCel <= tel.ctl_layouts[ctlMapId&31]; // mask out MSB_FLAG

               bRecCtl = (csrCel.ctl_id == cel.ctl_id);
            }

            if(bRecCtl)
            {
               if(nodeIsEditorVisible())
               {
                  parent_editor.evHandleRecordMidiEndSchedule();

                  // // if(!b_ta_recordmidiend_scheduled)
                  // // {
                  // //    b_ta_recordmidiend_scheduled = true;
                  // //    Events.Send_PV_TARecordMidiEnd_Schedule();
                  // // }

                  undoBeginNested("record MIDI");
               }
               else
               {
                  undoBeginNested("record MIDI");
               }

               if(!bRTRecord)
               {
                  patOffsetRec = fixOffsetToExistingTrackEventAtWindow(track, _ctlId, patOffsetRec, recRaster);
               }

               if(_bAllowRec)
                  insertReplaceEventAtRes(track, _ctlId, _val, patOffsetRec, recRaster);

               last_rec_soff = patOffsetRec;
               last_rec_eoff = patOffsetRec + recRes;

               if(-1 == rec_clear_start)
               {
                  rec_clear_start = patOffsetRecStep;
                  b_rec_clear_start_wrap = (patOffsetRecStep < patOffsetPlayStep);
               }

               bRecorded = true;

            } // if bRecCtl

         } // if cel
         // else
         //    trace "xxx cel not found";

         // // if(!replay.b_playing)
         // // {
         // //    undoEndCondPat();
         // // }

         if(bRecorded)
         {
            // Send redraw event to UI thread

            if(_bAllowRec)
               Events.SendRedrawPattern();

            if(bRecorded)
            {
               if(patOffsetRec >= patOffsetPlay)
               {
                  // Event will be triggered by replay
                  bFutureEv = b_rt_record;
               }
               else
               {
                  // Before play offset, play keyjazz
               }
            }

         } // if bRecorded

      } // if tel

      return bFutureEv;
   }

   // <method.png>
   public =replay= method recordUsrCtlParamValue(NT_Track _track, NT_MIDIParam _param, float _paramValue) {
      // Called from UI thread
      int patOff = getRecordPatOffsetMidiRec(true/*bMayQuantize*/, false/*bForceReplayPos*/, false/*bFramePlay*/);
      undoBeginNested("record MIDI");
      insertReplaceEventAtRes(_track,
                              NT_TrackPattern.CTL_USR + _param.id,
                              _paramValue,
                              patOff,
                              1
                              );
   }

   // <ui_midi.png>
   public method recordFrameTapMode(MIDIPipeFrame _frameRec) {
      // Note-On
      int evIdx = 0;
      int numEvents = _frameRec.numEventsNoteOn;

      int fltNoteDevIdx = -1;  // (todo)
      int fltNoteDevCh = -1;

      while(evIdx < numEvents)
      {
         MIDIPipeEvent ev;

         if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_ON))
         {
            if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
            {
               if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
               {
                  byte note = ev.note;

                  // trace "xxx recordFrameTapMode: note="+note;

                  int srcLen = getMetaPatternLength(tap_mode_source_pat_nr);

                  if(note < STConfig.node_tracker_tap_mode_low_note)
                  {
                     // Advance
                     tap_mode_current_source_step++;

                     // Wrap-around
                     if( (tap_mode_current_source_step * tap_mode_step_resolution) >= srcLen )
                     {
                        tap_mode_current_source_step = 0;
                     }

                     if(b_tap_mode_advance)
                     {
                        tap_mode_queued_play_step = tap_mode_current_source_step;
                     }

                  }
                  else
                  {
                     // Select
                     tap_mode_current_source_step = (note - STConfig.node_tracker_tap_mode_low_note);

                     // Wrap-around
                     if( (tap_mode_current_source_step * tap_mode_step_resolution) >= srcLen )
                     {
                        tap_mode_current_source_step = (tap_mode_current_source_step % (srcLen / tap_mode_step_resolution));
                     }

                     // trace "xxx recordFrameTapMode: select step "+tap_mode_current_source_step;

                     if(b_tap_mode_select)
                     {
                        tap_mode_queued_play_step = tap_mode_current_source_step;
                     }
                     else
                     {
                        tap_mode_current_source_step = -1; // will be incremented before being played
                     }
                  }

                  _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_NOTE_ON);
                  evIdx--;
                  numEvents = _frameRec.numEventsNoteOn;
               } // fltCh
            } // fltDev
         } // if getEvent

         evIdx++;
      } // while events
   }

   // <method.png>
   protected method haveTrackForDevCh(local int _fltDevIdx, local int _fltMidiCh, local int _trackIdx) : boolean {
      while(_trackIdx < tracks.numElements)
      {
         local NT_Track track <= tracks.get(_trackIdx);
         local NT_Instrument kjIns <= getInstrument(track.keyjazz_instr_nr);
         if( (-1 == _fltDevIdx) || (kjIns.getOutDeviceIdx() == _fltDevIdx) )
            if( (-1 == _fltMidiCh) || (kjIns.midi_channel == _fltMidiCh) )
               return true;

         _trackIdx++;
      }
      return false;
   }

   // <method.png>
   public method importResetActiveNotes() {
      // trace "xxx nt::importResetActiveNotes()";
      NT_Track *track;
      foreach track in tracks
      {
         track.importResetActiveNotes();
      }
   }

   // <method.png>
   public method importTrackDurLeft(int _tickDelta) {
      // called by NodeTrackerEditor.cmd_pattern_import_monitor_handle_ok()
      NT_Track *track;
      foreach track in tracks
      {
         track.importTrackDurLeft(_tickDelta);
      }
   }

   // <ui_midi.png>
   public method recordFrame(MIDIPipeFrame _frameRec,
                             boolean       _bFramePlay,
                             boolean       _bMuted,
                             boolean       _bForceEditable,  // true during import
                             MIDIPipeFrame _frameOut
                             ) {
      // called by nodeProcessFrame() and NT_PatternView.importSMF()

      if(NT_InstrumentView.LEARN_NONE != learn_mode)
         return;

      if(REC_SEL_NONE == rec_sel)
         return;

      int evIdx;
      int numEvents;
      MIDIPipeEvent ev;
      boolean bEditable = (PV_EDIT_NONE != pv_edit_mode);

      boolean bEditFocus = nodeIsEditorVisible();
      if(!bEditFocus)
      {
         if(node_gid == current_song.locked_keyjazz_node_gid)
         {
            bEditFocus = true;

            // don't allow step-edit from any MIDI input when node is armed for recording but replay is not running
            //  (note) "arm-for-recording" enables both pv_edit_mode and b_rec_bg
            bEditable = b_rt_record && b_rec_bg;
         }
      }
      if(-1 != current_song.locked_keyjazz_node_gid &&
         node_gid != current_song.locked_keyjazz_node_gid
         )
      {
         // Editor is visible but keyjazz is locked to other node
         bEditFocus = false;
         bEditable  = false;
      }

      if(_bFramePlay)
      {
         // don't allow MIDI KeyJazz from previous node output (on any MIDI port)
         bEditFocus = false;
      }

      if(!bEditFocus && !b_rec_bg && !_bForceEditable)
         return;

      bEditable |= _bForceEditable;

      boolean bDelegatePerfCtl = STConfig.b_node_tracker_delegate_perf_events && bEditFocus && !_bMuted;
      NT_Instrument *kjInstr;
      boolean bFutureEv;

      // if(_frameRec.numEventsPrgChg > 0)
      //    trace "xxx recordFrame this name="+parent_pipenode.name+" numEv="+_frameRec.numEvents+" bFramePlay="+_bFramePlay;

      // if(_frameRec.numEventsNoteOn > 0)
      //    trace "xxx recordFrame";

      // don't uncomment, this breaks the raster recording mode
      // // if(0 == _frameRec.numEvents)
      // // {
      // //    return;
      // // }

      NT_Track curTrack <=
         (current_song.locked_keyjazz_node_gid == node_gid)
         ? getTrack(current_song.locked_keyjazz_track)
         : getCurrentTrack()
         ;

      boolean bRecAll = b_rec_all || b_rec_spread;

      b_rec_any_note_on = false;  // STConfig.b_node_tracker_recordusrctlnoteon mode

      if(bEditFocus && !b_rt_record)
      {
         // Always record to current track in step-recording mode
         bRecAll = false;
      }

      int curTrackIdx = 0;
      NT_Track *track;

      foreach track in tracks
      {
         int trackNumVisibleNoteCels = track.tel.getNumVisibleNoteCels();

         if(bRecAll || (@(track) == @(curTrack)))
         {
            if(b_rt_record && replay.b_playing && bEditable)
            {
               if(REC_MODE_RASTER == rec_mode)
               {
                  if(0 == (tick_nr % pv_step_resolution))
                  {
                     // trace "xxx nt: clear raster num_rec_notes="+num_rec_notes;

                     if(num_rec_notes > 0)  // (todo) per track ??
                     {
                        int patOffsetRecRaw = getRecordPatOffsetMidiRec(false/*bMayQuantize*/,
                                                                        false/*bForceReplayPos*/,
                                                                        _bFramePlay
                                                                        );
                        // trace "xxx nt: clear raster patOffsetRecRaw="+patOffsetRecRaw+" num_rec_notes="+num_rec_notes;
                        // trace "xxx nt: clear raster last_rec_soff="+last_rec_soff+" last_rec_eoff="+last_rec_eoff;

                        // // quantization may have placed a note in the future, dont clear that note
                        if!(last_rec_soff <= patOffsetRecRaw < last_rec_eoff)
                        {
                           // trace "xxx nt: clear raster: patOffsetRecRaw="+patOffsetRecRaw;
                           // Clear raster
                           if(rec_clear_start != patOffsetRecRaw)
                           {
                              clearRaster(track, patOffsetRecRaw);
                              Events.SendRedrawPattern();
                           }
                        }

                        if(patOffsetRecRaw > last_rec_soff)
                           last_rec_soff = 99999999;
                     }
                  }
               }
            }

            if(replay.b_playing)
            {
            }
            else
            {
               if(0 == track.rec_num_active_notes)
               {
                  track.rec_current_notes.fill(-1);
               }
            }

            int fltNoteDevIdx = -1;
            int fltNoteDevCh  = -1;
            NT_Instrument *kjIns;
            int kjDevIdx = -1;
            int kjCh = -1;

            kjIns <= getInstrument(track.keyjazz_instr_nr);
            if(null != kjIns)
            {
               if(null != kjIns.out_device)
               {
                  kjDevIdx = kjIns.out_device.dev_idx;
                  kjCh     = kjIns.midi_channel;
               }
            }

            if(!bEditFocus || b_rt_record)
            {
               if(false != b_match_instr)
               {
                  if(maybe != b_match_instr)  // filter only by channel ?
                  {
                     fltNoteDevIdx = kjDevIdx;
                  }
                  fltNoteDevCh  = kjCh;
               }
            }


            // trace "xxx pv: fltNoteDevIdx="+fltNoteDevIdx+" fltNoteDevCh="+fltNoteDevCh;

            if(doRecordNotes())
            {
               boolean bRecCurTrack;

               // Note-Off
               evIdx = 0;
               numEvents = _frameRec.numEventsNoteOff;
               while(evIdx < numEvents)
               {
                  if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_OFF))
                  {
                     // trace "xxx recordFrame: note off note="+ev.note;

                     if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
                     {
                        if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
                        {
                           // trace "xxx note off: current_notes="+#(track.rec_current_notes)+" ev.note="+ev.note;
                           bRecCurTrack = !(b_rec_spread && bRecAll) || (track.rec_current_notes.contains(ev.note));
                           if(!bRecCurTrack)
                           {
                              // Are there any tracks left that match the events dev+ch ?
                              if(!haveTrackForDevCh(fltNoteDevIdx, fltNoteDevCh, curTrackIdx+1))
                                 bRecCurTrack = true; // no more tracks left, force-record to current track
                           }

                           // trace "xxx NodeTracker::recordFrame<off>: curTrackIdx="+curTrackIdx+" bRecCurTrack="+bRecCurTrack;

                           if(bRecCurTrack)
                           {
                              if(bEditable)
                              {
                                 track.rec_num_active_notes--;
                                 if(track.rec_num_active_notes < 0)
                                    track.rec_num_active_notes = 0;
                                 bFutureEv = recordMIDINote(track, -ev.note, ev.velocity, 0/*dur*/, _bFramePlay);
                              }
                              else
                              {
                                 bFutureEv = false;
                              }

                              if(!_bMuted)
                              {
                                 _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_NOTE_OFF);
                                 evIdx--;
                                 numEvents = _frameRec.numEventsNoteOff;
                              }

                              queueStatusInfoChord();

                              if(!bFutureEv)
                              {
                                 if(!_bFramePlay && bEditFocus && !_bMuted)
                                 {
                                    // trace "xxx keyjazzNoteOff";
                                    keyJazzQueueAdd(curTrackIdx,
                                                    track.keyjazz_instr_nr,
                                                    -ev.note,
                                                    ev.velocity,
                                                    0/*durTicks*/
                                                    );
                                 }
                              } // if bFutureEv
                           } // if bRecCurTrack
                        } // if flt ch
                     } // if flt dev
                  }
                  evIdx++;
               }

               // Note-On
               evIdx = 0;
               numEvents = _frameRec.numEventsNoteOn;

               // // if(numEvents > 0)
               // //    trace "xxx pv: fltNoteDevIdx="+fltNoteDevIdx+" fltNoteDevCh="+fltNoteDevCh;

               while(evIdx < numEvents)
               {
                  if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_ON))
                  {
                     // trace "xxx recordFrame: note on note="+ev.note;

                     if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
                     {
                        if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
                        {
                           // trace "xxx pv: note fltNoteDevIdx="+fltNoteDevIdx+" fltNoteDevCh="+fltNoteDevCh;
                           // trace "xxx pv: note ev.devIdx="+ev.devIdx+" ev.midiCh="+ev.midiCh;

                           bRecCurTrack = !(b_rec_spread && bRecAll) || (track.rec_num_active_notes < trackNumVisibleNoteCels);
                           if(!bRecCurTrack)
                           {
                              // Are there any tracks left that match the events dev+ch ?
                              if(!haveTrackForDevCh(fltNoteDevIdx, fltNoteDevCh, curTrackIdx+1))
                                 bRecCurTrack = true; // no more tracks left, force-record to current track
                           }

                           // trace "xxx NodeTracker::recordFrame<on>: curTrackIdx="+curTrackIdx+" bRecCurTrack="+bRecCurTrack+" bEditable="+bEditable+" bMuted="+_bMuted;

                           if(bRecCurTrack)
                           {
                              if(bEditable)
                              {
                                 track.rec_num_active_notes++;
                                 // trace "xxx track.rec_num_active_notes="+track.rec_num_active_notes;
                                 bFutureEv = recordMIDINote(track, ev.note, ev.velocity, ev.duration, _bFramePlay);
                                 // trace "xxx nt: bRemoveEv="+bRemoveEv+" tick_nr="+tick_nr+" song_offset="+current_song.song_offset;
                              }
                              else
                              {
                                 bFutureEv = false;
                              }

                              if(!_bMuted)
                              {
                                 _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_NOTE_ON);
                                 evIdx--;
                                 numEvents = _frameRec.numEventsNoteOn;
                              }

                              queueStatusInfoChord();

                              if(!bFutureEv)
                              {
                                 if(!_bFramePlay && bEditFocus && !_bMuted)
                                 {
                                    keyJazzQueueAdd(curTrackIdx,
                                                    track.keyjazz_instr_nr,
                                                    ev.note,
                                                    ev.velocity,
                                                    0/*durTicks*/
                                                    );
                                 }
                              }
                           } // rec spread
                           // else: record to next track
                        } // if ch flt
                     } // if dev flt
                  }
                  evIdx++;
               }

            } // if doRecordNotes()

            if(doRecordCtls())
            {
               // Record program change events
               evIdx = 0;
               numEvents = _frameRec.numEventsPrgChg;
               // trace "xxx numEventsPrgChg="+numEvents;
               while(evIdx < numEvents)
               {
                  if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_PRGCHG))
                  {
                     // trace "xxx recordFrame: PC="+ev.prgChg;

                     if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
                     {
                        if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
                        {
                           if(bEditable)
                           {
                              bFutureEv = recordMIDICtl(track,
                                                        NT_TrackPattern.CTL_PC,
                                                        ev.prgChg,
                                                        _bFramePlay,
                                                        true/*bAllowRec*/
                                                        );
                              // trace "xxx rec PC="+ev.prgChg+" bRemoveEv="+bRemoveEv;
                           }
                           else
                           {
                              bFutureEv = false;
                           }

                           if(!_bMuted)
                           {
                              _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_PRGCHG);
                              evIdx--;
                              numEvents = _frameRec.numEventsPrgChg;
                           }

                           if(!bFutureEv)
                           {
                              if(!_bFramePlay && bEditFocus && !_bMuted)
                              {
                                 track.injectCtl(NT_TrackPattern.CTL_PC, ev.prgChg);
                              }
                           }
                        }
                     }
                  }
                  evIdx++;
               }

               // Record channel pressure (aftertouch) events
               evIdx = 0;
               numEvents = _frameRec.numEventsChPressure;
               while(evIdx < numEvents)
               {
                  if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_CHPRESSURE))
                  {
                     // trace "xxx recordFrame: note on note="+ev.note;

                     if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
                     {
                        if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
                        {
                           if(bEditable)
                           {
                              bFutureEv = recordMIDICtl(track,
                                                        NT_TrackPattern.CTL_AT,
                                                        ev.chPressure,
                                                        _bFramePlay,
                                                        true/*bAllowRec*/
                                                        );
                           }
                           else
                           {
                              bFutureEv = false;
                           }

                           _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_CHPRESSURE);
                           evIdx--;
                           numEvents = _frameRec.numEventsChPressure;

                           if(!bFutureEv)
                           {
                              if(!_bFramePlay && bEditFocus && !_bMuted)
                              {
                                 track.injectCtl(NT_TrackPattern.CTL_AT, ev.chPressure);
                              }
                           }

                           // Delegate channel pressure to keyjazz instrument
                           if(bDelegatePerfCtl && !bFutureEv)
                           {
                              if((null != _frameOut) && (-1 != kjDevIdx))
                              {
                                 // (note) injectCtl() already takes care of this ?!!
                                 _frameOut.chPressure(true/*bSet*/, kjDevIdx, kjCh, ev.chPressure);
                              }
                           }

                        }
                     }
                  }
                  evIdx++;
               }

               // Record polyphonic aftertouch events
               if(doRecordNotes())
               {
                  IntArray currentNotes <= track.rec_current_notes;

                  // if(_bForceEditable)
                  //    trace "xxx nt::recordFrame: frameRec.numEventsPolyPressure="+_frameRec.numEventsPolyPressure+" currentNotes="+#(currentNotes);

                  evIdx = 0;
                  numEvents = _frameRec.numEventsPolyPressure;
                  while(evIdx < numEvents)
                  {
                     if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_POLYPRESSURE))
                     {
                        // trace "xxx recordFrame: note on note="+ev.note;

                        if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
                        {
                           if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
                           {
                              bFutureEv = false;
                              int polyAtNoteSlot = currentNotes.indexOf(ev.polyPressureNote, 0);
                              if(bEditable)
                              {
                                 if(-1 != polyAtNoteSlot)
                                 {
                                    NT_TEL tel <= track.getTrackLayout();
                                    NT_CEL polyNoteCel <= tel.findVisibleNoteCelByIdx(polyAtNoteSlot);
                                    if(null != polyNoteCel)
                                    {
                                       polyAtNoteSlot = polyNoteCel.ctl_id; // starts with 0

                                       bFutureEv = recordMIDICtl(track,
                                                                 NT_TrackPattern.CTL_POLYAT1 + polyAtNoteSlot,
                                                                 ev.polyPressureValue,
                                                                 _bFramePlay,
                                                                 true/*bAllowRec*/
                                                                 );
                                    }
                                 }
                                 // else:
                                 //   can happen when importing Monitor pattern (e.g. from NodeSeq) which contains
                                 //    pressure events but no noteons
                                 //     ==> must check in NodeSeqEditor and prevent export in this case
                              }

                              _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_POLYPRESSURE);
                              evIdx--;
                              numEvents = _frameRec.numEventsPolyPressure;

                              // if(!bFutureEv)
                              // {
                              //    if(!_bFramePlay && bEditFocus && !_bMuted)
                              //    {
                              //       // (todo) inject ctl
                              //    }
                              // }

                              // Delegate poly pressure to keyjazz instrument
                              if(bDelegatePerfCtl && !bFutureEv)
                              {
                                 if((null != _frameOut) && (-1 != kjDevIdx))
                                 {
                                    _frameOut.polyPressure(true/*bSet*/, kjDevIdx, kjCh, ev.polyPressureNote, ev.polyPressureValue);
                                 }
                              }

                           }
                        }
                     }
                     evIdx++;
                  }
               }

               // Record pitchbend events
               evIdx = 0;
               numEvents = _frameRec.numEventsPitchbend;
               while(evIdx < numEvents)
               {
                  if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_PITCHBEND))
                  {
                     // trace "xxx recordFrame: note on note="+ev.note;

                     if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
                     {
                        if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
                        {
                           if(bEditable)
                           {
                              bFutureEv = recordMIDICtl(track,
                                                        NT_TrackPattern.CTL_PB,
                                                        ev.pitchbend / 128.0,
                                                        _bFramePlay,
                                                        true/*bAllowRec*/
                                                        );
                           }
                           else
                           {
                              bFutureEv = false;
                           }

                           _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_PITCHBEND);
                           evIdx--;
                           numEvents = _frameRec.numEventsPitchbend;

                           if(!bFutureEv)
                           {
                              if(!_bFramePlay && bEditFocus && !_bMuted)
                              {
                                 // trace "xxx inject pb track.track_nr="+track.track_nr;
                                 track.injectCtl(NT_TrackPattern.CTL_PB, ev.pitchbend / 128.0);
                              }
                           }

                           if(bDelegatePerfCtl && !bFutureEv)
                           {
                              // (todo) already handled by injectCtl ?!!
                              if((null != _frameOut) && (-1 != kjDevIdx))
                              {
                                 // trace "xxx delegate pb kjDevIdx="+kjDevIdx+" kjCh="+kjCh+" pb="+ev.pitchbend;
                                 _frameOut.pitchbend(true/*bSet*/, kjDevIdx, kjCh, ev.pitchbend);
                              }
                           }

                        }
                     }
                  }
                  evIdx++;
               }

               if(null != kjIns)
               {
                  // Continuous or note-on synced UsrCtl recording mode
                  if(STConfig.b_node_tracker_recordusrctlnoteon)
                  {
                     if(b_rec_any_note_on)
                     {
                        // Record queued events (and remove them from frame_queued_usrctl_noteon)
                        recordUsrCtl(track,
                                     frame_queued_usrctl_noteon,
                                     _bFramePlay,
                                     _bMuted,
                                     _frameOut,
                                     true/*bAllowRec*/,
                                     true/*bAllowRemove*/,
                                     true/*bAllowInject*/,
                                     bDelegatePerfCtl,
                                     kjIns,
                                     kjDevIdx,
                                     kjCh,
                                     fltNoteDevIdx,
                                     fltNoteDevCh,
                                     bEditable,
                                     bEditFocus
                                     );

                        // Record current tick events (and remove them from frameRec)
                        recordUsrCtl(track,
                                     _frameRec,
                                     _bFramePlay,
                                     _bMuted,
                                     _frameOut,
                                     true/*bAllowRec*/,
                                     true/*bAllowDeleteEv*/,
                                     true/*bAllowInject*/,
                                     bDelegatePerfCtl,
                                     kjIns,
                                     kjDevIdx,
                                     kjCh,
                                     fltNoteDevIdx,
                                     fltNoteDevCh,
                                     bEditable,
                                     bEditFocus
                                     );
                     }
                     else
                     {
                        // Queue events until next recorded note-on
                        frame_queued_usrctl_noteon.mergeFrame(_frameRec);

                        // Remove events from 'frameRec' that would have been recorded
                        recordUsrCtl(track,
                                     _frameRec,
                                     _bFramePlay,
                                     _bMuted,
                                     _frameOut,
                                     false/*bAllowRec*/,
                                     true/*bAllowRemove*/,
                                     !b_rt_record/*bAllowInject*/,
                                     !b_rt_record && !_bMuted/*bDelegatePerfCtl*/,
                                     kjIns,
                                     kjDevIdx,
                                     kjCh,
                                     fltNoteDevIdx,
                                     fltNoteDevCh,
                                     bEditable,
                                     bEditFocus
                                     );
                     }
                  }
                  else
                  {
                     // (regular) Continuous UsrCtl recording
                     recordUsrCtl(track,
                                  _frameRec,
                                  _bFramePlay,
                                  _bMuted,
                                  _frameOut,
                                  true/*bAllowRec*/,
                                  true/*bAllowRemove*/,
                                  true/*bAllowInject*/,
                                  bDelegatePerfCtl,
                                  kjIns,
                                  kjDevIdx,
                                  kjCh,
                                  fltNoteDevIdx,
                                  fltNoteDevCh,
                                  bEditable,
                                  bEditFocus
                                  );
                  }

               } // if kjIns
            } // if doRecordCtls()
         } // if bRecAll || track==curTrack

         curTrackIdx++;
      } // foreach track

      if(b_rec_any_note_on)
         frame_queued_usrctl_noteon.empty();
   }

   // <method.png>
   protected method recordUsrCtl(NT_Track      *track,
                                 MIDIPipeFrame  _frameRec,
                                 boolean        _bFramePlay,
                                 boolean        _bMuted,
                                 MIDIPipeFrame  _frameOut,
                                 boolean        _bAllowRec,
                                 boolean        _bAllowRemove,  // (todo) always true ?!
                                 boolean        _bAllowInject,
                                 boolean        bDelegatePerfCtl,
                                 NT_Instrument *kjIns,
                                 int            kjDevIdx,
                                 int            kjCh,
                                 int            fltNoteDevIdx,
                                 int            fltNoteDevCh,
                                 boolean        bEditable,
                                 boolean        bEditFocus
                                 ) {

      int evIdx;
      int numEvents;
      MIDIPipeEvent ev;
      NT_MIDIParam *param;
      Float retCtlVal;
      boolean bFutureEv;

      // Record CTL_USR:CC events
      evIdx = 0;
      numEvents = _frameRec.numEventsCC;
      while(evIdx < numEvents)
      {
         if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_CC))
         {
            // // trace "xxx recordFrame: CC id="+ev.ccId+" val="+ev.ccValue;

            param <= kjIns.findParamForPipeEvent(ev, b_match_instr, retCtlVal);

            if(null != param)
            {
               // // trace "xxx recordFrame: ==> param="+#(param)+" retCtlVal="+retCtlVal+" track_nr="+track.track_nr;

               if(bEditable)
               {
                  bFutureEv = recordMIDICtl(track,
                                            NT_TrackPattern.CTL_USR + param.id,
                                            retCtlVal,
                                            _bFramePlay,
                                            _bAllowRec
                                            );
               }
               else
               {
                  bFutureEv = false;
               }

               if(_bAllowRemove)  // (todo) always true ?!
               {
                  _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_CC);
                  evIdx--;
                  numEvents = _frameRec.numEventsCC;
               }

               if(!bFutureEv)
               {
                  if(!_bFramePlay && bEditFocus && !_bMuted)
                  {
                     if(_bAllowInject)
                        track.injectCtl(NT_TrackPattern.CTL_USR + param.id, retCtlVal);
                  }
               }

            } // if param

            // Delegate sustain, softpedal, modwheel, breathcontrol, expression events (msb+lsb) to keyjazz instrument
            if(bDelegatePerfCtl && !bFutureEv)
            {
               if(null != _frameOut && -1 != kjDevIdx)
               {
                  if([1,2,4,11,33,34,36,43,64,65,66,67,68,69].contains(ev.ccId))
                  {
                     if( (-1 == fltNoteDevIdx) || (fltNoteDevIdx == ev.devIdx) )
                     {
                        if( (-1 == fltNoteDevCh) || (fltNoteDevCh == ev.midiCh) )
                        {
                           _frameOut.cc(true/*bSet*/, kjDevIdx, kjCh, ev.ccId, ev.ccValue);

                           if(null == param && _bAllowRemove)
                           {
                              _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_CC);
                              evIdx--;
                              numEvents = _frameRec.numEventsCC;
                           }
                        }
                     }
                  }
               }
            }
         }
         evIdx++;
      }

      // Record CTL_USR:RPN events
      evIdx = 0;
      numEvents = _frameRec.numEventsRPN;
      while(evIdx < numEvents)
      {
         if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN))
         {
            // // trace "xxx recordFrame: RPN id="+ev.rpn+" val="+ev.rpnValue;

            param <= kjIns.findParamForPipeEvent(ev, b_match_instr, retCtlVal);

            // // trace "xxx recordFrame<RPN="+ev.rpn+">: ==> param="+#(param)+" retCtlVal="+retCtlVal;

            if(null != param)
            {
               if(bEditable)
               {
                  bFutureEv = recordMIDICtl(track,
                                            NT_TrackPattern.CTL_USR + param.id,
                                            retCtlVal,
                                            _bFramePlay,
                                            _bAllowRec
                                            );
               }
               else
               {
                  bFutureEv = false;
               }

               if(_bAllowRemove) // (todo) always true ?!
               {
                  _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_RPN);
                  evIdx--;
                  numEvents = _frameRec.numEventsRPN;
               }

               if(!bFutureEv)
               {
                  if(!_bFramePlay && bEditFocus && !_bMuted && _bAllowInject)
                  {
                     track.injectCtl(NT_TrackPattern.CTL_USR + param.id, retCtlVal);
                  }
               }
            }
         }
         evIdx++;
      }

      // Record CTL_USR:NRPN events
      evIdx = 0;
      numEvents = _frameRec.numEventsNRPN;
      while(evIdx < numEvents)
      {
         if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_NRPN))
         {
            // // trace "xxx recordFrame: RPN id="+ev.rpnId+" val="+ev.rpnValue;

            param <= kjIns.findParamForPipeEvent(ev, b_match_instr, retCtlVal);

            // // trace "xxx recordFrame: ==> param="+#(param)+" retCtlVal="+retCtlVal;

            if(null != param)
            {
               if(bEditable)
               {
                  bFutureEv = recordMIDICtl(track,
                                            NT_TrackPattern.CTL_USR + param.id,
                                            retCtlVal,
                                            _bFramePlay,
                                            _bAllowRec
                                            );
               }
               else
               {
                  bFutureEv = false;
               }

               if(_bAllowRemove) // (todo) always true ?!
               {
                  _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_NRPN);
                  evIdx--;
                  numEvents = _frameRec.numEventsNRPN;
               }

               if(!bFutureEv)
               {
                  if(!_bFramePlay && bEditFocus && !_bMuted && _bAllowInject)
                  {
                     track.injectCtl(NT_TrackPattern.CTL_USR + param.id, retCtlVal);
                  }
               }
            }
         }
         evIdx++;
      }

      // Record CTL_USR:PRGCHG events
      evIdx = 0;
      numEvents = _frameRec.numEventsPrgChg;
      while(evIdx < numEvents)
      {
         if(_frameRec.getEventByIdx(evIdx, ev, MIDIPIPE_EVENT_TYPE_PRGCHG))
         {
            // // trace "xxx recordFrame: PrgChg id="+ev.ccId+" val="+ev.ccValue+" b_match_instr="+b_match_instr;

            param <= kjIns.findParamForPipeEvent(ev, b_match_instr, retCtlVal);

            // // trace "xxx recordFrame: ==> PrgChg param="+#(param)+" retCtlVal="+retCtlVal;

            if(null != param)
            {
               if(bEditable)
               {
                  bFutureEv = recordMIDICtl(track,
                                            NT_TrackPattern.CTL_USR + param.id,
                                            retCtlVal,
                                            _bFramePlay,
                                            _bAllowRec
                                            );
               }
               else
               {
                  bFutureEv = false;
               }

               if(_bAllowRemove) // (todo) always true ?!
               {
                  _frameRec.deleteEventByIdx(evIdx, MIDIPIPE_EVENT_TYPE_PRGCHG);
                  evIdx--;
                  numEvents = _frameRec.numEventsPrgChg;
               }

               if(!bFutureEv)
               {
                  if(!_bFramePlay && bEditFocus && !_bMuted && _bAllowInject)
                  {
                     track.injectCtl(NT_TrackPattern.CTL_USR + param.id, retCtlVal);
                  }
               }
            }
         }
         evIdx++;
      }
   }

   // <method.png>
   protected method handleCtlInjectRPN(MIDIPipeFrame _frame) {

      MIDIPipeEvent ev;
      int evIdx = 0;
      NT_Track *track;
      int ctlId;

      // Filter A
      if(b_auto_filter_a)
      {
         loop(_frame.getNumEventsRPNByFlt(auto_dev_filter_a, auto_ch_filter_a))
         {
            if(_frame.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN, auto_dev_filter_a, auto_ch_filter_a))
            {
               if(RPN_TRACKER_INJECT_CTL0 <= ev.rpn <= RPN_TRACKER_INJECT_CTL47)
               {
                  ctlId = ev.rpn - RPN_TRACKER_INJECT_CTL0;

                  foreach track in tracks
                  {
                     track.injectCtl(ctlId, ev.rpnValue);
                  }
               }
            }

            evIdx++;
         }
      }

      // Filter B
      if(b_auto_filter_b)
      {
         evIdx = 0;

         loop(_frame.getNumEventsRPNByFlt(auto_dev_filter_b, auto_ch_filter_b))
         {
            if(_frame.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN, auto_dev_filter_b, auto_ch_filter_b))
            {
               if(RPN_TRACKER_INJECT_CTL0 <= ev.rpn <= RPN_TRACKER_INJECT_CTL47)
               {
                  ctlId = ev.rpn - RPN_TRACKER_INJECT_CTL0;

                  foreach track in tracks
                  {
                     track.injectCtl(ctlId, ev.rpnValue);
                  }
               }
            }

            evIdx++;
         }
      }
   }

   // <method.png>
   protected method handleRecordUsrCtlRPN(MIDIPipeFrame _frame) {

      boolean bEditable = (PV_EDIT_NONE != pv_edit_mode);

      MIDIPipeEvent ev;
      int evIdx = 0;
      int usrCtlIdx;
      NT_Track *track;
      float paramValue;
      NT_MIDIParam *param;
      NT_Instrument *instr;

      if(nodeIsEditorVisible() && (null != pattern_view))
      {
         loop(_frame.numEventsRPN)
         {
            if(_frame.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN, -1/*fltDev*/, -1/*fltCh*/))
            {
               if(RPN_CTL_0 <= ev.rpn <= RPN_CTL_15) // prev: TRACKER_RECORD_USRCTLx
               {
                  usrCtlIdx = ev.rpn - RPN_CTL_0;

                  track <= pattern_view.getCurrentTrack();
                  if(null != track)
                  {
                     instr <= getInstrument(track.keyjazz_instr_nr);
                     if(null != instr)
                     {
                        param <= instr.getUsrCtlParam(usrCtlIdx);
                        if(null != param)
                        {
                           // // trace "xxx handleRecordUsrCtlRPN: rpnValue="+ev.rpnValue;
                           paramValue = param.unmapRecordUsrCtlRPNParamValue(ev.rpnValue);
                           if(bEditable)
                           {
                              undoBeginNested("record MIDI");
                              recordUsrCtlParamValue(track, param, paramValue);
                              Events.SendRedrawPattern();
                           }
                           // // trace "xxx handleRecordUsrCtlRPN: paramValue="+paramValue;
                           track.injectCtl(NT_TrackPattern.CTL_USR + usrCtlIdx, paramValue);
                        }
                     }
                  }
               }
            }
            evIdx++;
         }
      }
      else
      {
         // Filter A
         if(b_auto_filter_a)
         {
            loop(_frame.getNumEventsRPNByFlt(auto_dev_filter_a, auto_ch_filter_a))
            {
               if(_frame.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN, auto_dev_filter_a, auto_ch_filter_a))
               {
                  if(RPN_CTL_0 <= ev.rpn <= RPN_CTL_15)
                  {
                     usrCtlIdx = ev.rpn - RPN_CTL_0;  // prev: TRACKER_RECORD_USRCTL0

                     foreach track in tracks
                     {
                        instr <= getInstrument(track.keyjazz_instr_nr);
                        if(null != instr)
                        {
                           param <= instr.getUsrCtlParam(usrCtlIdx);

                           if(null != param)
                           {
                              paramValue = param.unmapRecordUsrCtlRPNParamValue(ev.rpnValue);

                              // // trace "xxx RECORD_USRCTL: rpnValue="+ev.rpnValue+" => paramValue="+paramValue;

                              track.injectCtl(NT_TrackPattern.CTL_USR + usrCtlIdx, paramValue);
                           }
                        }
                     }
                  }
               }

               evIdx++;
            }
         }

         // Filter B
         if(b_auto_filter_b)
         {
            evIdx = 0;

            loop(_frame.getNumEventsRPNByFlt(auto_dev_filter_b, auto_ch_filter_b))
            {
               if(_frame.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN, auto_dev_filter_b, auto_ch_filter_b))
               {
                  if(RPN_CTL_0 <= ev.rpn <= RPN_CTL_15)
                  {
                     usrCtlIdx = ev.rpn - RPN_CTL_0; // prev: TRACKER_RECORD_USRCTL0

                     foreach track in tracks
                     {
                        instr <= getInstrument(track.keyjazz_instr_nr);
                        if(null != instr)
                        {
                           param <= instr.getUsrCtlParam(usrCtlIdx);
                           if(null != param)
                           {
                              paramValue = param.unmapRecordUsrCtlRPNParamValue(ev.rpnValue);

                              // // trace "xxx RECORD_USRCTL: rpnValue="+ev.rpnValue+" => paramValue="+paramValue;

                              track.injectCtl(NT_TrackPattern.CTL_USR + usrCtlIdx, paramValue);
                           }
                        }
                     }
                  }
               }

               evIdx++;
            }
         }
      }
   }

   // <method_parse.png>
   protected method parseRPN_editfocus(MIDIPipeFrame _frame) {
      // parse <editfocus> events (RPN 100..131)

      if(null != nodeeditor_editfocus_dev)
      {
         int fltDev = nodeeditor_editfocus_dev.dev_idx;
         int fltCh = -1;

         int numEv = _frame.getNumEventsRPNByFlt(fltDev, fltCh);
         int evIdx = 0;

         // // trace "xxx parseRPN_editFocus: numEv="+numEv;

         boolean bEditorVisible = nodeIsEditorVisible();
         if(bEditorVisible)
         {
            if(null != last_editfocus)
            {
               loop(numEv)
               {
                  MIDIPipeEvent ev;

                  if(_frame.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_RPN, fltDev, fltCh))
                  {
                     if(Node.RPN_CTL_BASE <= ev.rpn < (Node.RPN_CTL_BASE + Node.RPN_CTL_NUM))  // Ctl 1..100
                     {
                        // Queue param update
                        int stepIdx = ev.rpn - Node.RPN_CTL_BASE/*100*/;
                        editor.queueNormalizedParamUpdate(stepIdx, ev.rpnValue);
                     }
                  }

                  evIdx++;
               } // loop ev

            } // if last_editfocus

            _frame.deleteEventsByFlt(fltDev, fltCh);

         } // if bEditorVisible

      }  // if nodeeditor_editfocus_dev
   }

   // <method_find.png>
   public virtual nodeFindSampleUIDs(IntArray _retSmpUIDs) {
      NT_Instrument *ins;
      boolean bHaveAudioIns = false;
      local Integer io;
      foreach ins in instruments
      {
         if(null != ins)
         {
            if(maybe == ins.b_audio) // RPN/smp_uid mode ?
            {
               bHaveAudioIns = true;
               if(ins.smp_uid >= 0)
               {
                  _retSmpUIDs.add(ins.smp_uid);
                  io = ins.smp_uid;
                  trace "[trc] NodeTracker::nodeFindSampleUIDs: add ref to ins.smp_uid="+ins.smp_uid+"/$"+io.printf("%04x");
               }
            }
         }
      }
      if(bHaveAudioIns)
      {
         NT_Track *track;
         foreach track in tracks
         {
            byte patNr = 0;
            loop(Node.NUM_PATTERNS)
            {
               NT_TrackPattern pat <= track.getPattern(patNr);
               if(null != pat)
               {
                  Envelope env <= pat.getEnvelope(NT_Defs.CTL_PC);
                  int numEnv = env.numElements / 2;
                  int evOff = 1;
                  loop(numEnv)
                  {
                     int envSmpUID = env[evOff];
                     _retSmpUIDs.add(envSmpUID);
                     io = envSmpUID;
                     trace "[trc] NodeTracker::nodeFindSampleUIDs: add ref to envSmpUID="+envSmpUID+"/$"+io.printf("%04x");
                     evOff += 2;
                  }
               }
               patNr++;
            }
         }
      }
   }

   // <method.png>
   protected method echoKJInsFrameRecToPlay(MIDIPipeFrame _frOutReplay, MIDIPipeFrame _frameRec) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_Instrument kjIns <= getInstrument(track.keyjazz_instr_nr);
         if(null != kjIns)
         {
            STX_MIDIOutDevice outDev <= kjIns.out_device;
            if(null != outDev)
            {
               _frOutReplay.mergeFrameFltDst(_frameRec,
                                             -1/*fltDev*/, -1/*fltCh*/,
                                             outDev.dev_idx/*dstDev*/, kjIns.midi_channel/*dstCh*/,
                                             true/*bMergeNotes*/,
                                             true/*bMergeRPN*/
                                             );
            }
         }
      }
   }

   // <method_get.png>
   public virtual nodeIsArmedForRecording() : boolean {
      return (PV_EDIT_NONE != pv_edit_mode) && (b_rec_bg || nodeIsEditorVisible());
   }

   // <method_set.png>
   public =replay= virtual nodeArmForRecording(boolean _bEnable) : boolean {
      if(PV_EDIT_NONE == pv_edit_mode)
         pv_edit_mode = PV_EDIT_STEP;
      else
         pv_edit_mode = PV_EDIT_NONE;

      b_rec_bg = (PV_EDIT_NONE != pv_edit_mode);
      Global.Debug("nt::nodeArmForRecording: lazy-"+(b_rec_bg?"enable":"disable")+" background recording mode");
   }

   // <method_get.png>
   public virtual nodeIsRTRecordActive() : boolean {
      // // trace "xxx NodeTracker::isRTRecordActive: b_rt_record="+b_rt_record;
      return b_rt_record;
   }

   // <method_handle.png>
   public virtual nodeHandleStartRecording() {
      if(STConfig.b_node_tracker_undo_record_single_transaction)
      {
         if(nodeIsArmedForRecording())
         {
            // Replay was started while edit mode is active => start transaction
            b_rt_record = true;

            frame_queued_usrctl_noteon.empty();

            undoBeginNested("record start");

            Global.Debug2("pv: start recording (node)");
         }
      }
   }

   // <method_handle.png>
   public virtual nodeHandleStopRecording() {

      stopTapMode(false/*bForce*/);

      queued_undo_record_restart_ticks = -1;

      b_ta_recordmidiend_scheduled = false;

      frame_queued_usrctl_noteon.empty();

      if(STConfig.b_node_tracker_undo_record_single_transaction)
      {
         if(NodeTracker.PV_EDIT_NONE != pv_edit_mode)
         {
            if(b_rt_record)
            {
               // Replay was stopped while edit mode is active => finish transaction
               // trace "xxx nodeHandleStopRecording: undoEnd()";
               undoEnd();
            }
         }
      }

      b_rt_record = false;
   }

   // <method_handle.png>
   public virtual nodeHandleStopPlaying() {
      // Called from UI thread while =replay= is locked
      nodeStopOutputCapture();

      audiorec_automute_tick_nr = -1;
   }

   // <method_get.png>
   public =replay= method checkResetUIGhostSeek() : boolean {
      boolean r = b_ui_ghost_seek;
      b_ui_ghost_seek = false;
      return r;
   }

   static int xxx_debug = 0;

   // <method_get.png>
   public virtual nodeGetSupportedRPNs() : IntArray {
      return [
         RPN_CTL_0,  RPN_CTL_1, RPN_CTL_2,  RPN_CTL_3,  RPN_CTL_4,  RPN_CTL_5,  RPN_CTL_6,  RPN_CTL_7,
         RPN_CTL_8,  RPN_CTL_9, RPN_CTL_10, RPN_CTL_11, RPN_CTL_12, RPN_CTL_13, RPN_CTL_14, RPN_CTL_15,

         RPN_COMMON_UI_PRGCHG,
         RPN_COMMON_MUTE_TEMP, // nodeParseRPN_Mute
         RPN_COMMON_MUTE_TEMP_TOGGLE,
         RPN_COMMON_MUTE_TEMP_1_8,
         RPN_COMMON_MUTE_TEMP_9_16,
         RPN_COMMON_SOLO_TEMP_1_8,
         RPN_COMMON_SOLO_TEMP_9_16,
         RPN_COMMON_UI_NODE_MUTE,
         RPN_COMMON_UI_NODE_SOLO,
         RPN_COMMON_UI_PIPE_MUTE,
         RPN_COMMON_UI_PIPE_SOLO,

         RPN_COMMON_TRANSPOSE,  // nodeParseRPN_Transpose

         RPN_COMMON_VELOCITY_OFF,  // nodeParseRPN_Vel_Dur_Speed
         RPN_COMMON_VELOCITY_SCL,

         RPN_COMMON_VEL_SCL_TRACK_1,
         RPN_COMMON_VEL_SCL_TRACK_2,
         RPN_COMMON_VEL_SCL_TRACK_3,
         RPN_COMMON_VEL_SCL_TRACK_4,
         RPN_COMMON_VEL_SCL_TRACK_5,
         RPN_COMMON_VEL_SCL_TRACK_6,
         RPN_COMMON_VEL_SCL_TRACK_7,
         RPN_COMMON_VEL_SCL_TRACK_8,
         RPN_COMMON_VEL_SCL_TRACK_9,
         RPN_COMMON_VEL_SCL_TRACK_10,
         RPN_COMMON_VEL_SCL_TRACK_11,
         RPN_COMMON_VEL_SCL_TRACK_12,
         RPN_COMMON_VEL_SCL_TRACK_13,
         RPN_COMMON_VEL_SCL_TRACK_14,
         RPN_COMMON_VEL_SCL_TRACK_15,
         RPN_COMMON_VEL_SCL_TRACK_16,

         RPN_COMMON_DURATION_OFF,
         RPN_COMMON_DURATION_SCL,
         RPN_COMMON_SPEED,
         RPN_COMMON_POSITION,
         RPN_COMMON_SPEEDSYNCRATE,

         RPN_COMMON_PROB_ALL_REL,  // nodeParseRPN_Probability
         RPN_COMMON_PROB_TRACK_1,
         RPN_COMMON_PROB_TRACK_2,
         RPN_COMMON_PROB_TRACK_3,
         RPN_COMMON_PROB_TRACK_4,
         RPN_COMMON_PROB_TRACK_5,
         RPN_COMMON_PROB_TRACK_6,
         RPN_COMMON_PROB_TRACK_7,
         RPN_COMMON_PROB_TRACK_8,
         RPN_COMMON_PROB_TRACK_9,
         RPN_COMMON_PROB_TRACK_10,
         RPN_COMMON_PROB_TRACK_11,
         RPN_COMMON_PROB_TRACK_12,
         RPN_COMMON_PROB_TRACK_13,
         RPN_COMMON_PROB_TRACK_14,
         RPN_COMMON_PROB_TRACK_15,
         RPN_COMMON_PROB_TRACK_16,

         RPN_COMMON_RESET,
         RPN_COMMON_RUN,
         RPN_COMMON_LENGTH,
         RPN_COMMON_LENGTH_QUEUED,
         RPN_COMMON_OFFSET,
         RPN_COMMON_RESTART,
         RPN_COMMON_EXTCLK,
         RPN_COMMON_OFFLEN_MUL,
         RPN_COMMON_OFFLEN_DIV,
         RPN_COMMON_OFFLEN_SCALE,
         RPN_COMMON_OFFSET_ADD,
         RPN_COMMON_OFFSET_QUEUED,
         RPN_COMMON_SEEK_OFFSET,
         RPN_COMMON_SEEK_REL_PRE,
         RPN_COMMON_GATE,
         RPN_COMMON_GATETIME_MUL,
         RPN_COMMON_GATETIME_DIV,
         RPN_COMMON_GATETIME,
         RPN_COMMON_SEEK_REL_POST,
         RPN_COMMON_RETRIG,
         RPN_COMMON_CLOCKGATE,
         RPN_COMMON_CLOCK,

         RPN_TRACKER_DELAY,
         RPN_TRACKER_RETRIG,
         RPN_TRACKER_SLIDENOTEOFF,
         RPN_TRACKER_EXTRST,

         RPN_TRACKER_INJECT_CTL0,
         RPN_TRACKER_INJECT_CTL1,
         RPN_TRACKER_INJECT_CTL2,
         RPN_TRACKER_INJECT_CTL3,
         RPN_TRACKER_INJECT_CTL4,
         RPN_TRACKER_INJECT_CTL5,
         RPN_TRACKER_INJECT_CTL6,
         RPN_TRACKER_INJECT_CTL7,
         RPN_TRACKER_INJECT_CTL8,
         RPN_TRACKER_INJECT_CTL9,
         RPN_TRACKER_INJECT_CTL10,
         RPN_TRACKER_INJECT_CTL11,
         RPN_TRACKER_INJECT_CTL12,
         RPN_TRACKER_INJECT_CTL13,
         RPN_TRACKER_INJECT_CTL14,
         RPN_TRACKER_INJECT_CTL15,
         RPN_TRACKER_INJECT_CTL16,
         RPN_TRACKER_INJECT_CTL17,
         RPN_TRACKER_INJECT_CTL18,
         RPN_TRACKER_INJECT_CTL19,
         RPN_TRACKER_INJECT_CTL20,
         RPN_TRACKER_INJECT_CTL21,
         RPN_TRACKER_INJECT_CTL22,
         RPN_TRACKER_INJECT_CTL23,
         RPN_TRACKER_INJECT_CTL24,
         RPN_TRACKER_INJECT_CTL25,
         RPN_TRACKER_INJECT_CTL26,
         RPN_TRACKER_INJECT_CTL27,
         RPN_TRACKER_INJECT_CTL28,
         RPN_TRACKER_INJECT_CTL29,
         RPN_TRACKER_INJECT_CTL30,
         RPN_TRACKER_INJECT_CTL31,
         RPN_TRACKER_INJECT_CTL32,
         RPN_TRACKER_INJECT_CTL33,
         RPN_TRACKER_INJECT_CTL34,
         RPN_TRACKER_INJECT_CTL35,
         RPN_TRACKER_INJECT_CTL36,
         RPN_TRACKER_INJECT_CTL37,
         RPN_TRACKER_INJECT_CTL38,
         RPN_TRACKER_INJECT_CTL39,
         RPN_TRACKER_INJECT_CTL40,
         RPN_TRACKER_INJECT_CTL41,
         RPN_TRACKER_INJECT_CTL42,
         RPN_TRACKER_INJECT_CTL43,
         RPN_TRACKER_INJECT_CTL44,
         RPN_TRACKER_INJECT_CTL45,
         RPN_TRACKER_INJECT_CTL46,
         RPN_TRACKER_INJECT_CTL47,

         RPN_COMMON_POLY_STEP_1,
         RPN_COMMON_POLY_STEP_2,
         RPN_COMMON_POLY_STEP_3,
         RPN_COMMON_POLY_STEP_4,
         RPN_COMMON_POLY_STEP_5,
         RPN_COMMON_POLY_STEP_6,
         RPN_COMMON_POLY_STEP_7,
         RPN_COMMON_POLY_STEP_8,
         RPN_COMMON_POLY_STEP_9,
         RPN_COMMON_POLY_STEP_10,
         RPN_COMMON_POLY_STEP_11,
         RPN_COMMON_POLY_STEP_12,
         RPN_COMMON_POLY_STEP_13,
         RPN_COMMON_POLY_STEP_14,
         RPN_COMMON_POLY_STEP_15,
         RPN_COMMON_POLY_STEP_16,
         RPN_COMMON_POLY_PAT_1,
         RPN_COMMON_POLY_PAT_2,
         RPN_COMMON_POLY_PAT_3,
         RPN_COMMON_POLY_PAT_4,
         RPN_COMMON_POLY_PAT_5,
         RPN_COMMON_POLY_PAT_6,
         RPN_COMMON_POLY_PAT_7,
         RPN_COMMON_POLY_PAT_8,
         RPN_COMMON_POLY_PAT_9,
         RPN_COMMON_POLY_PAT_10,
         RPN_COMMON_POLY_PAT_11,
         RPN_COMMON_POLY_PAT_12,
         RPN_COMMON_POLY_PAT_13,
         RPN_COMMON_POLY_PAT_14,
         RPN_COMMON_POLY_PAT_15,
         RPN_COMMON_POLY_PAT_16,
         RPN_COMMON_POLY_TRACK_1,
         RPN_COMMON_POLY_TRACK_2,
         RPN_COMMON_POLY_TRACK_3,
         RPN_COMMON_POLY_TRACK_4,
         RPN_COMMON_POLY_TRACK_5,
         RPN_COMMON_POLY_TRACK_6,
         RPN_COMMON_POLY_TRACK_7,
         RPN_COMMON_POLY_TRACK_8,
         RPN_COMMON_POLY_TRACK_9,
         RPN_COMMON_POLY_TRACK_10,
         RPN_COMMON_POLY_TRACK_11,
         RPN_COMMON_POLY_TRACK_12,
         RPN_COMMON_POLY_TRACK_13,
         RPN_COMMON_POLY_TRACK_14,
         RPN_COMMON_POLY_TRACK_15,
         RPN_COMMON_POLY_TRACK_16,
              ];
   }

   // <method_get.png>
   public virtual nodeGetSupportedRPNSubMenus() : StringArray {
      return ["600..615: PolyStep Step",
              "616..631: PolyStep Pat",
              "632..647: PolyStep Track",
              "700..716: Probability",
              "800..815: Track Velocity Scale",
              "2100..2147: Inject Ctl",
              ];
   }

   // <replay.png>
   public virtual nodeProcessFrame(MIDIPipeFrame _framePlay,
                                   MIDIPipeFrame _frameRec,
                                   boolean       _bMuted,
                                   boolean       _bPlaySeq
                                   ) {
      boolean bEditFocus;
      if(-1 == current_song.locked_keyjazz_node_gid)
         bEditFocus = nodeIsEditorVisible();
      else
         bEditFocus = (current_song.locked_keyjazz_node_gid == node_gid);

      if(bEditFocus)
         nodeHandleContextSensitiveAutoDevEvents(_frameRec, _framePlay);

      // trace "xxx nt tick";
      // if("tracker#5" == nodeGetName())
      //    trace "tick_nr="+tick_nr;

      // // if(_frameRec.hasEvents())
      // //    trace "xxx frameRec.numEvents="+_frameRec.numEvents;
      // // if(replay.b_playing)
      // //    trace "xxx tick_nr="+tick_nr+" song_offset="+current_song.song_offset;

      if(-1 != queued_forced_smp_uid)
      {
         // used for syncing audio pattern changes with Eureka sample selection even when node is muted
         _framePlay.rpn(true/*bSet*/,
                        queued_forced_smp_dev_idx, queued_forced_smp_midi_ch,
                        90/*ModSample.RPN_SMP_UID*/,
                        queued_forced_smp_uid/*smp_uid*/
                        );
         queued_forced_smp_uid = -1;
      }


      int origPlayPatNr = play_pattern_nr;

      // Ignore arranger prgchg+mute+seek if replay was started from pattern editor
      boolean bAllowSeekPrgChgAndMute = true;
      if(STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay)
         bAllowSeekPrgChgAndMute = !replay.isPatternNode(this);
      bAllowSeekPrgChgAndMute = bAllowSeekPrgChgAndMute && !b_node_ignore_seek_prgchg_mute;

      boolean bHaveRPN = (_framePlay.numEventsRPN > 0) || (_frameRec.numEventsRPN > 0);

      if(_bPlaySeq)
      {
         audiorec_tick_nr++;
         if(-1 != audiorec_automute_tick_nr)
         {
            // // trace "xxx nt: audiorec_automute_tick_nr="+audiorec_automute_tick_nr+" audiorec_tick_nr="+audiorec_tick_nr;
            if(audiorec_tick_nr >= audiorec_automute_tick_nr)
            {
               _bMuted = true;

               NodeTracker audioNode <= current_song.findNodeByGID(audio_node_gid);
               if(audioNode instanceof NodeTracker)
               {
                  if(maybe == audioNode.b_audiomidi_mutex)
                  {
                     // auto-mute MIDI node, auto-unmute Audio node
                     nodeSetEnableMute(true);
                     audioNode.nodeSetEnableMute(false);
                     _bMuted = true;
                     audiorec_automute_tick_nr = -1;
                     Events.SendHandleUpdateTextFieldNodeState();
                  }
               }
            }
         }
      }

      if(bHaveRPN)
      {
         parseRPN_editfocus(_framePlay); // [30Dec2021]
         parseRPN_editfocus(_frameRec);
      }

      if(b_tap_mode)
      {
         if(b_rec_bg || bEditFocus)
         {
            play_pattern_nr = tap_mode_scratch_pat_nr;

            recordFrameTapMode(_frameRec);

            if(b_rec_prev)
            {
               recordFrameTapMode(_framePlay);
            }
         }
      }
      else
      {
         // // trace "xxx nt:nodeProcessFrame: _frameRec.numEvents="+_frameRec.numEvents;

         // // if(_framePlay.numEventsPrgChg > 0)
         // //    trace "xxx nt: HAVE PRGCHG b_rec_bg="+b_rec_bg;

         if(b_rec_bg || bEditFocus)
         {
            if(b_rt_record && replay.b_playing)
            {
               if(REC_MODE_RASTER == rec_mode)
               {
                  // Reset clear-enable flag when tick offset where clearing started is reached
                  int recTicks = jam_current_ticks;
                  // (note) -1 when pattern jump/loop is pending
                  if(-1 == recTicks)
                     recTicks = 0;  // (todo) use actual start offset (usually 0 but still..)
                  // // trace "xxx nt: clear ticks="+recTicks+" rec_clear_start="+rec_clear_start+" num_rec_notes="+num_rec_notes;
                  if(num_rec_notes > 0)
                  {
                     if(recTicks == rec_clear_start)
                     {
                        // // trace "\n\n\nxxx b_rec_clear_start_wrap="+b_rec_clear_start_wrap;
                        trace "xxx nt: clear ticks="+recTicks+" rec_clear_start="+rec_clear_start+" b_rec_clear_start_wrap="+b_rec_clear_start_wrap+" num_rec_notes="+num_rec_notes;
                        if(!b_rec_clear_start_wrap)
                        {
                           rec_clear_start = -1;
                           rec_clear_last_step = -1;
                           num_rec_notes = 0;
                           // // trace "xxx nt: stop clear at tick="+recTicks;
                        }
                        else
                        {
                           b_rec_clear_start_wrap = false;
                        }
                     }
                  }
               }
            }

            MIDIPipeFrame frOut;
            frOut.empty();

            recordFrame(_frameRec, false/*bFramePlay*/, _bMuted, false/*bForceEditable*/, frOut);

            if(b_rec_prev)
            {
               recordFrame(_framePlay, true/*bFramePlay*/, _bMuted, false/*bForceEditable*/, frOut);
            }

            _framePlay.mergeFrame(frOut);
         }
      }


      int t;
      int val;

      int forceJamTicks = -1;
      int forceJamLen = -1;
      boolean bForceJamOffset = false;
      boolean bSeekPattern = false;
      NT_MetaPattern *pat;

      tick_ext_delay = -1; // RPN_TRACKER_DELAY
      tick_ext_retrig = -1; // RPN_TRACKER_RETRIG

      if(bHaveRPN)
      {
         t = getRPN(_framePlay, _frameRec, RPN_COMMON_RESET);
         if(t > 0)
         {
            nodeReset(false/*bSoft*/);
         }

         handleCtlInjectRPN(_framePlay);
         handleCtlInjectRPN(_frameRec);

         handleRecordUsrCtlRPN(_framePlay);  // [19Dec2021]
         handleRecordUsrCtlRPN(_frameRec);

      }

      handlePrgChg(_framePlay, bAllowSeekPrgChgAndMute);
      handlePrgChg(_frameRec,  bAllowSeekPrgChgAndMute);

      nodeSendQueuedPrgChgOut(_framePlay);


      // 18Apr2017: activate queued pattern before handling RPN and reset jam_offset/jam_length
      if(-1 != jam_queued_pattern_nr)
      {
         // trace "xxx handle jam_queued_pattern_nr="+jam_queued_pattern_nr;
         play_pattern_nr = jam_queued_pattern_nr;
         // // // jam_queued_pattern_nr = -1;

         Node::nodeSetCurrentPlayPatternNr(play_pattern_nr);

         pat <= meta_patterns.get(play_pattern_nr);

         jam_offset = 0;

         if(null != pat)
         {
            jam_length = pat.num_ticks / jam_tick_multiplier;
            jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;
         }

         queueAudioClip();
      }



      if(b_ui_discard_notes)
      {
         _frameRec.deleteNoteOnsByFlt(-1/*fltDevIdx*/, -1/*fltMidiCh*/);
         _frameRec.deleteNoteOffsByFlt(-1/*fltDevIdx*/, -1/*fltMidiCh*/);
      }

      if(bHaveRPN || (-1 != node_queued_com_seek_off))
      {
         // trace "xxx nt: bHaveRPN=true bPlaySeq="+_bPlaySeq;
         // Handle RPN_COMMON_VELOCITY_OFF, RPN_COMMON_VELOCITY_SCL, RPN_COMMON_DURATION_OFF, RPN_COMMON_DURATION_SCL, RPN_COMMON_SPEED
         nodeParseRPN_Vel_Dur_Speed(_framePlay, _frameRec);
         nodeParseRPN_Vel_Track(_framePlay, _frameRec);
         nodeParseRPN_Dur_Track(_framePlay, _frameRec);

         nodeParseRPN_Transpose(_framePlay, _frameRec);

         tick_ext_delay  = getRPN(_framePlay, _frameRec, RPN_TRACKER_DELAY);
         tick_ext_retrig = getRPN(_framePlay, _frameRec, RPN_TRACKER_RETRIG);
         // // if(-1 != tick_ext_retrig)
         // // {
         // //    Integer io = tick_ext_retrig;
         // //    trace "xxx tick_ext_retrig="+io.printf("%02x");
         // // }

         nodeParseRPN_Probability(_framePlay, _frameRec);

         if(_bPlaySeq)
         {
            // (note) [04Feb2017] moved from bottom to top so that OFFSET etc still work when restart happens on same tick
            t = getRPN(_framePlay, _frameRec, RPN_COMMON_RESTART);
            if(t > 0)
            {
               if(-1 == jam_current_ticks)
               {
                  forceJamTicks = 0;
               }
               else
               {
                  nodeRestart();
                  forceJamTicks = 0;
               }
            }


            t = getRPN(_framePlay, _frameRec, RPN_COMMON_EXTCLK);
            if(t >= 0)
            {
               b_extclk = (0 != t);
               b_jam_run  = !b_extclk;
               b_jam_gate = !b_extclk;
               b_jam_adv  = !b_extclk;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_RUN);
            if(-1 != t)
            {
               b_jam_run = (t > 0);
            }

            // Handle MUTE_TEMP_*, MUTE_TEMP_TOGGLE, MUTE_SOLO_*
            nodeParseRPN_Mute(_framePlay, _frameRec);

            if(-1 != queued_node_mute_temp_track_mask_1_8)
            {
               node_mute_temp_track_mask = (node_mute_temp_track_mask &~255) | queued_node_mute_temp_track_mask_1_8;
               queued_node_mute_temp_track_mask_1_8 = -1;
            }

            if(-1 != queued_node_mute_temp_track_mask_9_16)
            {
               node_mute_temp_track_mask = (node_mute_temp_track_mask &255) | (queued_node_mute_temp_track_mask_9_16 << 8);
               queued_node_mute_temp_track_mask_9_16 = -1;
            }


            t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFLEN_MUL);
            if(-1 != t)
            {
               if(t < 1)
                  t = 1;
               jam_scale_mul = t;
               jam_tick_multiplier = (jam_scale_ticks * jam_scale_mul) / jam_scale_div;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFLEN_DIV);
            if(-1 != t)
            {
               if(t < 1)
                  t = 1;
               jam_scale_div = t;
               jam_tick_multiplier = (jam_scale_ticks * jam_scale_mul) / jam_scale_div;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFLEN_SCALE);
            if(-1 != t)
            {
               if(t < 1)
                  t = 1;
               jam_scale_ticks = t;
               jam_tick_multiplier = (jam_scale_ticks * jam_scale_mul) / jam_scale_div;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFSET);
            if(-1 != t)
            {
               jam_offset = t;
               tick_nr = jam_offset * jam_tick_multiplier;
               synced_tick_nr = tick_nr;
               forceJamTicks = tick_nr;
               jam_current_ticks = -1; // force seek
               bForceJamOffset = true;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_SEEK_REL_PRE);
            if(-1 != t)
            {
               tick_nr += (t * jam_tick_multiplier);
               if(tick_nr >= ((jam_offset + jam_length) * jam_tick_multiplier)) {
                  tick_nr -= ((jam_offset + jam_length) * jam_tick_multiplier);
               }
               forceJamTicks = tick_nr;
               synced_tick_nr = tick_nr;
               jam_current_ticks = -1; // force seek
               bForceJamOffset = true;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_LENGTH);
            if(-1 != t)
            {
               if(t < 1)
                  t = 1;

               // Update length and wrap-around if necessary
               jam_length = t;
               forceJamLen = t;

               // trace "xxx RPN_COMMON_LENGTH:    tick_nr="+tick_nr;
               forceJamTicks = (tick_nr - jam_offset * jam_scale_ticks) % (jam_length * jam_scale_ticks);// (todo) *jam_tick_multiplier??
               // trace "xxx RPN_COMMON_LENGTH:    1 forceJamTicks="+forceJamTicks;
               forceJamTicks += (jam_offset * jam_tick_multiplier);
               // trace "xxx RPN_COMMON_LENGTH:    2 forceJamTicks="+forceJamTicks;
               jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;

               if(forceJamTicks >= jam_current_end_ticks)
               {
                  forceJamTicks -= jam_length * jam_tick_multiplier;
               }

               bSeekPattern = true;

               ////nodeSetCurrentPlayPatternNr(play_pattern_nr); // force seek
                // trace "xxx RPN_COMMON_LENGTH:    4 forceJamTicks="+forceJamTicks;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFSET_QUEUED);
            if(-1 != t)
            {
               jam_offset_queued = t;
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_LENGTH_QUEUED);
            if(-1 != t)
            {
               if(t < 1)
                  t = 1;

               jam_length_queued = t;
            }

            if(bAllowSeekPrgChgAndMute)
            {
               t = getRPN(_framePlay, _frameRec, RPN_COMMON_SEEK_OFFSET);
               if(-1 == t)
               {
                  // // if(0 == jam_queued_offset_ticks)
                  // // {
                  // //    trace "xxx jam_current_ticks="+jam_current_ticks;
                  // // }
                  if((-1 == jam_queued_offset_ticks) || (jam_current_ticks == jam_queued_offset_ticks) ||
                     ((-1 == jam_current_ticks) && (0 == jam_queued_offset_ticks))/*patRestart hack*/
                     )
                  {
                     jam_queued_offset_ticks = -1;
                     t = node_queued_com_seek_off;
                     node_queued_com_seek_off = -1;
                     // // if(-1 != t)
                     // // {
                     //    // trace "xxx CTL_SEEK: jumping to off="+t+" (ticks="+(t * jam_scale_ticks)+")";
                     // // }
                  }
               }
               if(-1 == jam_queued_offset_ticks)
               {
                  node_queued_com_seek_off = -1;
               }
               if(-1 != t)
               {
                  if(b_debug_prgchg)
                     trace "[trc] nt: this="+#(this)+" SEEK_OFFSET t="+t;

                  forceJamTicks = t * jam_tick_multiplier;
                  tick_nr = forceJamTicks;
                  synced_tick_nr = tick_nr;

                  // trace "xxx forceJamTicks="+forceJamTicks+" jam_current_end_ticks="+jam_current_end_ticks;
                  forceJamTicks = forceJamTicks % (jam_length * jam_tick_multiplier);

                  if(jam_current_end_ticks > 0)
                  {
                     forceJamTicks += jam_offset * jam_tick_multiplier;
                     if(forceJamTicks >= jam_current_end_ticks)
                     {
                        // // forceJamTicks -= jam_length * jam_scale_ticks;// (todo) *jam_tick_multiplier??
                        forceJamTicks -= jam_length * jam_tick_multiplier;
                     }
                  }

                  jam_current_ticks = -1;////forceJamTicks;
                  bSeekPattern = true;

                  // if(b_node_class_show)
                  //    trace "xxx nt: this="+#(this)+" SEEK_OFFSET to "+forceJamTicks;

                  if(b_debug_prgchg)
                     trace "[trc] nt: set SEEK_OFFSET="+forceJamTicks;

                  edit_clip_start_ticks = -1;
                  nodeSetLastPatternStartEditorSongOffset(mathMaxi(0, current_song.song_offset - forceJamTicks)); // ????

                  if(b_debug_prgchg)
                     trace "[trc] nt: SEEK_OFFSET editor_song_offset="+nodeGetLastPatternStartEditorSongOffset();
               }
            }

            t = getRPN(_framePlay, _frameRec, RPN_TRACKER_SLIDENOTEOFF);
            if(t >= 0)
            {
               b_slide_note_off = t;
            }

            t = getRPN(_framePlay, _frameRec, RPN_TRACKER_EXTRST);
            if(t > 0)
            {
               ext_active_notes.empty();
               arp_active_notes.empty();
            }

            if(b_extclk || !b_jam_run)
            {
               t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATETIME_MUL);
               if(-1 != t)
               {
                  if(t < 1)
                     t = 1;
                  extclk_gatetime_mul = t;
                  extclk_gatetime = (extclk_gatetime_base * extclk_gatetime_mul) / extclk_gatetime_div;
               }

               t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATETIME_DIV);
               if(-1 != t)
               {
                  if(t < 1)
                     t = 1;
                  extclk_gatetime_div = t;
                  extclk_gatetime = (extclk_gatetime_base * extclk_gatetime_mul) / extclk_gatetime_div;
               }

               t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATETIME);
               if(-1 != t)
               {
                  if(t < 1)
                     t = 1;
                  extclk_gatetime_base = t;
                  extclk_gatetime = (extclk_gatetime_base * extclk_gatetime_mul) / extclk_gatetime_div;
               }

               t = getRPN(_framePlay, _frameRec, RPN_COMMON_RETRIG);
               if(t > 0)
               {
                  // trace "xxx RPN_COMMON_RETRIG: last_event_ticks="+extclk_last_event_ticks;
                  if(-1 != extclk_last_event_ticks)
                  {
                     b_jam_retrig = true;

                     // trace "xxx RETRIG: last_event_ticks="+extclk_last_event_ticks+" gatetime="+extclk_last_event_gatetime;
                     nodeSeek(extclk_last_event_ticks);
                     /////extclk_gate_countdown = extclk_last_event_gatetime;
                     extclk_gate_countdown = extclk_gatetime;

                     b_jam_adv = true;
                     b_jam_gate = true;
                  }
               }

               t = getRPN(_framePlay, _frameRec, RPN_COMMON_CLOCKGATE);
               if(t > 0)
               {
                  if(extclk_gate_countdown > 0)
                  {
                     // Clock is received before all gate ticks were played => fast forward
                     nodeSeek(nodeGetLastPatternStartSongOffset() + extclk_gate_next_ticknr);
                  }

                  extclk_gate_countdown = extclk_gatetime;
                  extclk_gate_next_ticknr = jam_current_ticks + extclk_gatetime;

                  if(b_jam_retrig)
                  {
                     nodeSeek(extclk_last_event_ticks + extclk_last_event_gatetime);
                     b_jam_retrig = false;
                  }

                  extclk_last_event_gatetime = extclk_gatetime;
                  if(-1 == jam_current_ticks)
                  {
                     // Pattern start / offset jump queued
                     extclk_last_event_ticks = jam_offset * jam_tick_multiplier;
                  }
                  else
                  {
                     extclk_last_event_ticks = jam_current_ticks;
                  }

                  b_jam_gate = true;
                  b_jam_adv  = true;
               }

               t = getRPN(_framePlay, _frameRec, RPN_COMMON_CLOCK);
               if(t > 0)
               {
                  if(extclk_gate_countdown > 0)
                  {
                     // Clock is received before all gate ticks were played => fast forward
                     nodeSeek(nodeGetLastPatternStartSongOffset() + extclk_gate_next_ticknr);
                  }

                  extclk_gate_countdown = extclk_gatetime;
                  extclk_gate_next_ticknr = jam_current_ticks + extclk_gatetime;

                  if(b_jam_retrig)
                  {
                     // trace "xxx COMMON_CLOCK seekRetrig:";
                     nodeSeek(extclk_last_event_ticks + extclk_last_event_gatetime);
                     b_jam_retrig = false;
                  }

                  extclk_last_event_gatetime = extclk_gatetime;
                  if(-1 == jam_current_ticks)
                  {
                     // Pattern start / offset jump queued
                     extclk_last_event_ticks = jam_offset * jam_tick_multiplier;
                  }
                  else
                  {
                     extclk_last_event_ticks = jam_current_ticks;
                  }

                  b_jam_adv  = true;
                  // trace "xxx nt: COMMON_CLOCK step="+(jam_current_ticks/24);
               }

               t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATE);
               if(t > 0)
               {
                  if(0 == extclk_gate_countdown)
                     extclk_gate_countdown = 1;
                  b_jam_gate = true;

                  // trace "xxx nt: COMMON_GATE step="+(jam_current_ticks/24);
               }

            } // if b_extclk || !b_jam_run
         } // if _bPlaySeq
      } // if num RPN

      if(b_extclk || !b_jam_run)
      {
         b_jam_gate = b_jam_gate && (extclk_gate_countdown > 0);
         b_jam_adv  = b_jam_adv  && (extclk_gate_countdown > 0);
      }
      else
      {
         b_jam_gate = false;
         b_jam_adv = false;
      }

      // if(!b_jam_run)
      //    trace "xxx pause: this="+#(this)+" b_jam_adv="+b_jam_adv;

      if(!bAllowSeekPrgChgAndMute)
         node_queued_b_mute_temp = -1;

      _bMuted |= nodeHandleQueuedMuteTemp();

      boolean bMutedOrig = _bMuted; // save for polystep
      _bMuted = _bMuted || ((b_extclk || !b_jam_run) && !b_jam_gate && replay.b_playing) || b_jam_done;
      boolean bAdvSeq = _bPlaySeq && (b_jam_run || b_jam_adv ||!replay.b_playing) && !b_jam_done;

      nodeDecodePolystepRPN(_frameRec, _framePlay);

      // // _bMuted=false;//xxxxx
      // if(b_extclk)
      //    trace "xxx bMuted="+_bMuted+" bAdvSeq="+bAdvSeq+" b_jam_adv="+b_jam_adv+" b_jam_gate="+b_jam_gate+" b_jam_done="+b_jam_done;

      // // if(_bPlaySeq && !_bMuted && (replay.b_playing || replay.ticks_to_play))
      // // {
      // //    if(b_extclk)
      // //    {
      // //       trace "xxx ext_ticks="+jam_current_ticks+" b_jam_gate="+b_jam_gate+" b_jam_adv="+b_jam_adv+" playSeq="+_bPlaySeq+" advSeq="+bAdvSeq+" lastEvTicks="+extclk_last_event_ticks;
      // //    }
      // //    else
      // //    {
      // //       trace "xxx ticks="+jam_current_ticks;
      // //    }
      // // }


      // Handle external notes / arpeggiator
      tick_ext_note_ons.empty();
      tick_ext_note_on_vels.empty();

      tick_ext_note_offs.empty();
      tick_ext_note_off_vels.empty();

      handleExtNotes(_framePlay); // fill tick_ext* arrays
      handleExtNotes(_frameRec);

      b_tick_ext_first_note = false;
      handleExtActiveNotes();

      MIDIPipeFrame frOutCapture;
      MIDIPipeFrame *frOutReplay;
      boolean bCapture = b_capture && replay.b_playing;
      if(bCapture)
      {
         frOutCapture.empty();
         frOutReplay <= frOutCapture;
      }
      else
      {
         frOutReplay <= _framePlay;
      }

      if(b_arp)
      {
         if(b_tick_ext_first_note)
         {
            if(b_arp_reset)
            {
               jam_current_ticks = -1; // force seek to jam_start
               forceJamTicks = -1;  // cancel CTL_SEEK, ..
               // trace "xxx nt: ----------------- ARP FIRST NOTE";
            }

            // // if(b_arp_latch_reset && arp_latch_num_notes>0)
            // // {
            // //    arp_active_notes = ext_active_notes;
            // //    arp_latch_next_idx = 1;
            // // }
         }

         // // if(0 == arp_latch_num_notes)
         // // {
         // //    arp_active_notes = ext_active_notes;
         // // }
      }

      NT_Track *track;

      // Play delayed polysteps (CTL_DELAY)
      int polystepRestorePatNr = -1;
      int polystepRestoreTicks = -1;

      if(b_extclk && ! bMutedOrig)
      {
         foreach track in tracks
         {
            if(track.delay_countdown > 0)
            {
               // trace "xxx play delayed polystep step: track.delay_countdown="+track.delay_countdown+" last_polystep_tickoff="+track.last_polystep_tickoff+" last_polystep_patnr="+track.last_polystep_patnr;

               if(-1 != track.last_polystep_tickoff)
               {
                  polystepRestorePatNr = play_pattern_nr;
                  polystepRestoreTicks = jam_current_ticks;

                  if(-1 != track.last_polystep_patnr)
                  {
                     play_pattern_nr = track.last_polystep_patnr & 127;
                  }

                  jam_current_ticks = track.last_polystep_tickoff;
                  pv_replay_pat_offset = jam_current_ticks;

                  // // trace "xxx play delayed polystep step: pre track.delay_countdown="+track.delay_countdown;
                  track.tick(frOutReplay, _frameRec, true/*bSeekPattern*/, false/*bMuted*/, true/*bPlaySeq*/, false/*bAdvSeq*/, false/*bAllowDelayBegin*/);
                  // // trace "xxx play delayed polystep step: post track.delay_countdown="+track.delay_countdown;

                  if(1 == track.delay_countdown)
                  {
                     track.delay_countdown = -1;
                     track.delay_ticks     = 0;
                     // // trace "xxx play delayed polystep step: play actual step *******";

                     // (note) in extclk/polystep mode, delay is increased by one tick
                     track.tick(frOutReplay, _frameRec, true/*bSeekPattern*/, false/*bMuted*/, true/*bPlaySeq*/, false/*bAdvSeq*/, false/*bAllowDelayBegin*/);
                  }
               }
            }
         }

         if(-1 != polystepRestorePatNr)
         {
            // Restore pattern nr
            play_pattern_nr = polystepRestorePatNr;

            // Restore pattern offset and force seek
            jam_current_ticks = polystepRestoreTicks;
            bSeekPattern = true;
         }
      }

      // Play polysteps
      if(polystep_max > 0)
      {
         // // trace "xxx polystep_max="+polystep_max+" bMuted="+bMutedOrig;

         if(!bMutedOrig)
         {
            polystepRestorePatNr = play_pattern_nr;
            polystepRestoreTicks = jam_current_ticks;
            int polystepIdx = 0;

            loop(polystep_max)
            {
               int polystepNr = polystep_stepnr.get(polystepIdx);

               // // trace "xxx polystepNr ="+polystepNr;

               if(polystepNr >= 0)
               {
                  int polystepTickOff = jam_tick_multiplier * polystepNr;
                  // // trace "xxx polystepTickOff="+polystepTickOff;
                  int polystepPatNr = polystep_patnr.get(polystepIdx);
                  int polystepTrackNr = polystep_tracknr.get(polystepIdx);
                  boolean bTrackDelay;

                  if(-1 != polystepPatNr)
                  {
                     play_pattern_nr = polystepPatNr & 127;
                  }

                  jam_current_ticks = polystepTickOff;
                  pv_replay_pat_offset = jam_current_ticks;
                  ui_polystep_grace_timeout = 20;

                  if(-1 != polystepTrackNr)
                  {
                     // // Play single track
                     if(0 <= polystepTrackNr < tracks.numElements)
                     {
                        track <= tracks.get(polystepTrackNr);

                        if(null != track)
                        {
                           // // track.hltrackname_countdown = 1.0;
                           track.hlpolystep_offset = polystepTickOff;
                           track.hlpolystep_countdown = 1.0;

                           track.last_polystep_tickoff = polystepTickOff;
                           track.last_polystep_patnr   = polystepPatNr;

                           bTrackDelay = (-1 != track.delay_countdown);
                           // trace "xxx nt: polystep: trackNr="+polystepTrackNr+" PRE track.delay_countdown="+track.delay_countdown;

                           track.tick(frOutReplay, _frameRec, true/*bSeekPattern*/, false/*bMuted*/, true/*bPlaySeq*/, false/*bAdvSeq*/, true/*bAllowDelayBegin*/);
                           // trace "xxx nt: polystep: trackNr="+polystepTrackNr+" POST track.delay_countdown="+track.delay_countdown;

                           if(!bTrackDelay && (track.delay_countdown > 0))
                           {
                              // trace "xxx nt: start polystep track delay: track.delay_countdown="+track.delay_countdown;
                              track.delay_countdown++;
                           }
                        }
                     }
                  }
                  else
                  {
                     // Play all tracks
                     foreach track in tracks
                     {
                        track.last_polystep_tickoff = polystepTickOff;
                        track.last_polystep_patnr   = polystepPatNr;

                        // // track.hltrackname_countdown = 1.0;
                        track.hlpolystep_offset = polystepTickOff;
                        track.hlpolystep_countdown = 1.0;

                        bTrackDelay = (-1 != track.delay_countdown);

                        track.tick(frOutReplay, _frameRec, true/*bSeekPattern*/, false/*bMuted*/, true/*bPlaySeq*/, false/*bAdvSeq*/, true/*bAllowDelayBegin*/);
                        if(!bTrackDelay && (track.delay_countdown > 0))
                           track.delay_countdown++;

                     }
                  }
               } // if stepnr>=0

               // Next polystep index
               polystepIdx++;

            } // loop polystep indices

            // Restore pattern nr
            play_pattern_nr = polystepRestorePatNr;

            // Restore pattern offset and force seek
            jam_current_ticks = polystepRestoreTicks;
            bSeekPattern = true;

         } // if!_bMuted
      }


      // if(-1 != jam_queued_pattern_nr)
      //    trace "xxx song_offset="+current_song.song_offset+" jam_queued_pattern_nr="+jam_queued_pattern_nr+" tick_frac="+tick_frac;

      // [08May2021] move pattern chg handling outside of tick loop to fix arp (speed=0.25) pattern reset glitch
      if(-1 != jam_queued_pattern_nr)
      {
         // if(b_node_class_show)
         //    trace "xxx nt: hihats change pattern";
         // Global.Debug("NodeTracker::tick: jam_queued_pattern_nr="+jam_queued_pattern_nr+" b_jam_restart="+b_jam_restart+" forceJamTicks="+forceJamTicks+" bForceJamOffset="+bForceJamOffset+" ticksBefore="+jam_current_ticks+" name="+parent_pipenode.name);
         play_pattern_nr = jam_queued_pattern_nr;

         Node::nodeSetCurrentPlayPatternNr(play_pattern_nr);

         // // tick_nr = 0;

         pat <= meta_patterns.get(play_pattern_nr);

         if(!bForceJamOffset)
         {
            jam_offset = 0;
         }

         /////if(-1 == forceJamTicks) // (todo) should be forceJamLen
         if(-1 == forceJamLen) // (todo) should be forceJamLen
         {
            if(null != pat)
            {
               jam_length = pat.num_ticks / jam_tick_multiplier;
               // // if(!b_node_class_show)
               // //    trace "xxx set jam_length to "+jam_length;
            }
         }

         if(bForceJamOffset)
         {
            // 09Oct2015: pattern play offset set via RPN, calc new pattern start offset
            // // nodeSetLastPatternStartEditorSongOffset(current_song.song_offset - tick_nr);  // xxxxxxxxxxxxxx
         }

         jam_queued_pattern_nr = -1;

         if(b_jam_restart)
         {
            jam_current_ticks = -1;
            if(b_debug_prgchg)
               trace "xxx restart pattern at song_offset="+current_song.song_offset;
            tick_frac = 0.0;  // [08May2021] attempt to fix arp pattern glitch (not enough)
         }
         else
         {
            // trace "xxx nt: change pat and continue, jam_current_ticks="+jam_current_ticks;

            if(-1 == forceJamTicks)
            {
               // Switching from empty pattern to continously running pattern, recalc current_ticks
               //  OR looping pattern
               jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;

               if(b_extclk)
               {
                  if(jam_current_ticks < 0)
                     jam_current_ticks = 0;
                  // (note) keep current_ticks (modulo'ing with pattern length would cause sudden jump)
                  // trace "xxx  ..> EXTCLK patchg jam_current_ticks="+jam_current_ticks+" end_ticks="+jam_current_end_ticks;
               }
               else
               {
                  // // jam_current_ticks = (current_song.song_offset - last_pattern_start_song_offset) * rpn_com_speed_scl;
                  // trace "xxx  --> 0 tick_nr="+tick_nr;
                  jam_current_ticks = nodeCalcRelativeTicks(tick_nr + nodeGetLastPatternStartSongOffset());
                  // trace "xxx  ..> 1 songoffset.jam_current_ticks="+jam_current_ticks+" end_ticks="+jam_current_end_ticks+" song_offset="+current_song.song_offset+" last_pattern_start_song_offset="+last_pattern_start_song_offset;
                  // trace "xxx  ..> 2 songoffset.jam_current_ticks="+jam_current_ticks+" end_ticks="+jam_current_end_ticks;
                  // // jam_current_ticks = jam_current_ticks % jam_current_end_ticks;
               }

               // trace "xxx  ==> jam_current_ticks="+jam_current_ticks+" jam_current_end_ticks="+jam_current_end_ticks+" play_pattern_nr="+play_pattern_nr+" last_start_off="+last_pattern_start_song_offset;
            }

            if((jam_current_ticks >= 0) || (-1 != forceJamTicks))
            {
               // trace "xxx nt: seek tracks, forceJamTicks="+forceJamTicks+" jam_current_ticks="+jam_current_ticks;
               foreach track in tracks
               {
                  // // track.seekJam(jam_current_ticks);
                  track.seek((-1 != forceJamTicks) ? forceJamTicks : jam_current_ticks);
               }
            }
         }

         queueAudioClip();
      } // if -1 != jam_queued_pattern_nr

      // Play regular tick(s)
      while(tick_frac >= 0.0)
      {
         pat <= meta_patterns.get(play_pattern_nr);

         // if(Global.b_playing)
         // {
         //    Global.Debug2("NodeTracker::tick: jam_current_ticks="+jam_current_ticks);
         // }


         // Update pattern play length depending on #active_arp_notes, synchronized to 'step' grid
         if(b_arp_dynalen)
         {
            if(b_arp_dynalen_update_queued)
            {
               if((-1 == jam_current_ticks) || (0 == (jam_current_ticks % jam_tick_multiplier))) // sync to step
               {
                  jam_length = arp_active_notes.numElements;

                  // trace "xxx arp_dynlen: update jam_length to "+jam_length+" ticks="+jam_current_ticks;
                  b_arp_dynalen_update_queued = false;

                  if(-1 != jam_current_ticks)
                  {
                     jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;
                     if(jam_current_ticks >= jam_current_end_ticks)
                     {
                        jam_current_ticks = -1;
                        bSeekPattern = true;
                     }
                  }
               }
            }
         }

         jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;

         // if(!_bMuted && b_node_class_show)
         //    trace "xxx jam_current_ticks="+jam_current_ticks+" end="+jam_current_end_ticks+" len="+jam_length;

         if(-1 == jam_current_ticks) // Restart pattern/seek ?
         {
            // if(!_bMuted && b_node_class_show)
            //    trace "xxx jam_current_ticks=-1 forceJamTicks="+forceJamTicks+" jam_offset="+jam_offset;

            if(-1 == forceJamTicks)
            {
               jam_current_ticks = jam_offset * jam_tick_multiplier;
               // // jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;
               queueAudioClip();
            }
            else
            {
               // if(b_node_class_show)
               //    trace "xxx hihats:----------------------";
               // trace "xxx nt: apply forceJamTicks="+forceJamTicks;
               jam_current_ticks = forceJamTicks;

               // // // nodeSetLastPatternStartSongOffset(current_song.song_offset - jam_current_ticks); // xxxxx
            }

            jam_current_start_ticks = jam_current_ticks;

            bSeekPattern = true;

            b_jam_done = false; // reset oneshot-done flag

            // if(!_bMuted && b_node_class_show)
            //    trace "xxx    2 jam_current_ticks="+jam_current_ticks+" bSeekPattern=true";

            // // extclk_last_event_ticks = -1;
            // // b_jam_retrig = false;

            // // last_pattern_start_song_offset = current_song.song_offset - jam_current_ticks;
            // // if(last_pattern_start_song_offset < 0)
            // //    last_pattern_start_song_offset = 0;

            // Global.Debug2("NodeTracker::tick: bStartPattern, jam_current_ticks="+jam_current_ticks+" jam_current_end_ticks="+jam_current_end_ticks);
         }
         else
         {
            // // if(-2 == jam_current_ticks)
            // // {
            // //    // Length changed
            // //    jam_current_end_ticks = (jam_offset + jam_length) * jam_tick_multiplier;
            // //    Global.Debug2("NodeTracker::tick: length changed, jam_current_end_ticks="+jam_current_end_ticks);
            // // }

            //////bStartPattern = ((jam_current_ticks + 1) >= jam_current_end_ticks); // ??? restart on last tick
         }

         if(-1 != forceJamTicks)
         {
            jam_current_ticks = forceJamTicks;

            queueAudioClip();
         }

         if(b_tap_mode)
         {
            if(0 != getMetaPatternLength(edit_pattern_nr))
            {
               if(_bPlaySeq && bAdvSeq)
               {
                  if(0 == (jam_current_ticks % tap_mode_step_resolution))
                  {
                     // Copy tap mode replay step from edit to scratch pattern
                     // trace "xxx tapmode: copy replay step editpat="+edit_pattern_nr+" ticks="+jam_current_ticks;
                     b_block_no_undo = true;
                     copyStep(tap_mode_scratch_pat_nr, jam_current_ticks + tap_mode_last_play_overlap,  // dst
                              edit_pattern_nr, jam_current_ticks,      // src
                              tap_mode_step_resolution - tap_mode_last_play_overlap,                    // numTicks
                              true/*allTracks*/
                              );
                     b_block_no_undo = false;
                     tap_mode_last_play_overlap = 0;
                  }
               }
            }

            if(-1 != tap_mode_queued_play_step)
            {
               // Copy source mini-block to scratch pattern
               // trace "xxx tapmode: copy play step sourcepat="+tap_mode_source_pat_nr+" ticks="+jam_current_ticks;
               b_block_no_undo = true;

               int tapModeTicksAlign;
               int tapModeTicksQ;
               int tapModeTicksQWrapped;
               int tapModeOverlap;
               int tapModeCopyLen;

               if(replay.b_playing && b_tap_mode_beatsync)
               {
                  // trace "xxx tapModeOverlap="+tapModeOverlap+" curTicks="+jam_current_ticks;
                  tapModeTicksAlign = (int(jam_current_ticks / pv_step_resolution) * pv_step_resolution);
                  tapModeTicksQ = (int((jam_current_ticks + pv_step_resolution-1) / pv_step_resolution) * pv_step_resolution);
                  tapModeTicksQWrapped = tapModeTicksQ;
                  if(tapModeTicksQWrapped >= getMetaPatternLength(tap_mode_scratch_pat_nr))
                     tapModeTicksQWrapped -= getMetaPatternLength(tap_mode_scratch_pat_nr);
                  // // int tapModeSyncOverlap = (tapModeTicksQ - tapModeTicksAlign);

                  tapModeCopyLen = tap_mode_step_resolution - ( tapModeTicksQ - (int(tapModeTicksQ/tap_mode_step_resolution)*tap_mode_step_resolution) );
                  // trace "xxx tapModeCopyLen="+tapModeCopyLen+" ticksQ="+tapModeTicksQWrapped;
                  tapModeOverlap = (jam_current_ticks - tapModeTicksAlign);

                  copyStep(tap_mode_scratch_pat_nr, tapModeTicksQWrapped,  // dst
                           tap_mode_source_pat_nr, (tap_mode_queued_play_step * tap_mode_step_resolution),  // src
                           tapModeCopyLen,                   // numTicks
                           b_tap_mode_alltracks
                           );

                  ////tap_mode_last_play_overlap = tapModeSyncOverlap;
                  if(tapModeCopyLen == tap_mode_step_resolution)
                  {
                     tap_mode_last_play_overlap = (tapModeTicksQ == jam_current_ticks) ? 0 : tap_mode_step_resolution;
                  }
                  else
                  {
                     tap_mode_last_play_overlap = 0;
                  }
               }
               else
               {
                  tapModeTicksAlign = (int(jam_current_ticks / tap_mode_step_resolution) * tap_mode_step_resolution);
                  tapModeOverlap = (jam_current_ticks - tapModeTicksAlign);

                  copyStep(tap_mode_scratch_pat_nr, jam_current_ticks,  // dst
                           tap_mode_source_pat_nr, (tap_mode_queued_play_step * tap_mode_step_resolution),  // src
                           tap_mode_step_resolution,                    // numTicks
                           b_tap_mode_alltracks
                           );

                  if(_bPlaySeq && bAdvSeq)
                  {
                     tap_mode_last_play_overlap = tapModeOverlap;
                  }
               }

               b_block_no_undo = false;


               if(PV_EDIT_NONE != pv_edit_mode) // isEditable() ?
               {
                  int tapModeRecOffset = getRecordPatOffsetMidiRec(true/*bMayQuantize*/, false/*bForceReplayPos*/, false/*bFramePlay*/);

                  int tapModePatLen = getCurrentEditMetaPatternLength();
                  int tapModeRecLen = tap_mode_step_resolution;
                  int tapModeRecSrcOff = (tap_mode_queued_play_step * tap_mode_step_resolution);

                  if(replay.b_playing && doAutoScroll() && b_tap_mode_beatsync)
                  {
                     tapModeRecOffset = tapModeTicksQWrapped;
                     tapModeRecLen = tapModeCopyLen;
                  }
                  else
                  {
                     if(replay.b_playing && STConfig.b_node_tracker_recordquantize)
                     {
                        tapModeRecOffset = int( (tapModeRecOffset + pv_step_resolution/2) / pv_step_resolution) * pv_step_resolution;

                        if(tapModeRecOffset >= tapModePatLen)
                           tapModeRecOffset -= tapModePatLen;
                     }
                  }


                  if(0 != getMetaPatternLength(edit_pattern_nr))
                  {
                     undoBeginNested("record tap step");
                     copyStep(edit_pattern_nr, tapModeRecOffset,
                              tap_mode_source_pat_nr, tapModeRecSrcOff,
                              tapModeRecLen,
                              b_tap_mode_alltracks
                              );
                     undoEndNested("record tap step");

                     if(!doAutoScroll() || !replay.b_playing)
                     {
                        pv_pat_offset += tap_mode_step_resolution;
                     }

                     Events.SendRedrawPattern();
                  }

               }

               if(!replay.b_playing)
               {
                  // Play mini-block
                  replay.ticks_to_play = tap_mode_step_resolution;
                  _bPlaySeq = true;
                  bAdvSeq = true;
                  jam_current_ticks = tapModeRecOffset;
                  bSeekPattern = true;

                  clearScratchPattern();

                  b_block_no_undo = true;
                  copyStep(tap_mode_scratch_pat_nr, jam_current_ticks,
                           tap_mode_source_pat_nr, (tap_mode_queued_play_step * tap_mode_step_resolution),
                           tap_mode_step_resolution,
                           b_tap_mode_alltracks
                           );
                  b_block_no_undo = false;
               }

               tap_mode_queued_play_step = -1;

            } // if queued_play_step
         } // if b_tap_mode

         // Process tracks
         // if(bSeekPattern)
         //    trace "xxx nt: bSeekPattern=true, tick_nr="+tick_nr;
         boolean bPatZeroLen = (0 == nodeGetCurrentPlayPatternNumTicks());

         if(bPatZeroLen)
            initial_sample_offset_ms = -1;

         foreach track in tracks
         {
            // trace "xxx bStartPattern="+bStartPattern;
            // (note) seek to jam_current_ticks when bSeekPattern is true
            if(-1 == track.last_polystep_tickoff || !replay.b_playing)
               track.tick(frOutReplay, _frameRec, bSeekPattern, _bMuted | bPatZeroLen, _bPlaySeq, bAdvSeq, true/*bAllowDelayBegin*/);
         }

         keyjazz_queue.empty();

         if(_bPlaySeq && bAdvSeq)
         {
            // Jam play mode
            // if(!_bMuted)
            // {
            //    trace "xxx tick_nr="+tick_nr+" jam_current_ticks="+jam_current_ticks;
            // }

            tick_nr++;
            jam_current_ticks++;

            if(jam_current_ticks >= jam_current_end_ticks)
            {
               // // extclk_last_event_ticks = -1;
               // // b_jam_retrig = false;

               if(jam_current_end_ticks > 0)
               {
                  if(! (b_arp && b_arp_dynalen)) // filter arp spam
                  {
                     // Global.Debug3("NodeTracker::tick: jam loop pattern GID="+node_gid);
                  }
                  if(0 != last_rec_soff) // dont reset when quantization placed event on tick 0 (recorded at end of pattern)
                     last_rec_soff = 99999999;
               }

               if(PLAY_MODE_ONESHOT == play_mode)
               {
                  b_jam_done = true;
               }
               else
               {
                  // Loop
                  jam_current_ticks = -1; // restart pattern during next tick()

                  // Apply queued offset/length
                  if(-1 != jam_offset_queued)
                  {
                     jam_offset = jam_offset_queued;
                     jam_offset_queued = -1;
                  }

                  if(-1 != jam_length_queued)
                  {
                     jam_length = jam_length_queued;
                     jam_length_queued = -1;
                  }
               }
            }
         }

         if(b_extclk || !b_jam_run)
         {
            if(extclk_gate_countdown > 0)
            {
               extclk_gate_countdown--;

               if(b_jam_retrig)
               {
                  if(0 == extclk_gate_countdown)
                  {
                     // Retrig finish
                     b_jam_retrig = false;
                     nodeSeek(extclk_last_event_ticks + extclk_last_event_gatetime);
                  }
               }
            }
         }

         tick_frac -= 1.0;

      } // while tick_frac >= 1.0

      t = getRPN(_framePlay, _frameRec, RPN_COMMON_SEEK_REL_POST);
      if(-1 != t)
      {
         tick_nr += (t * jam_tick_multiplier);
         if(tick_nr >= ((jam_offset + jam_length) * jam_tick_multiplier))
         {
            // Loop
            tick_nr -= ((jam_offset + jam_length) * jam_tick_multiplier);

            // Apply queued offset/length
            if(-1 != jam_offset_queued)
            {
               jam_offset = jam_offset_queued;
               jam_offset_queued = -1;
            }

            if(-1 != jam_length_queued)
            {
               jam_length = jam_length_queued;
               jam_length_queued = -1;
            }

            tick_nr += (jam_offset * jam_tick_multiplier);

         }
         nodeSeek(nodeGetLastPatternStartSongOffset() + tick_nr);
         synced_tick_nr = tick_nr;
      }


      float syncSpeedFactor = 1.0;

      // bool bSyncDebug = ((0 == (++xxx_debug & 31)) && replay.b_playing && ("dd 1" == nodeGetName()));
      // bool bSyncDebug = ((0 == (++xxx_debug & 31)) && replay.b_playing && ("cycles" == nodeGetName()));
      bool bSyncDebug = false;
      if(bSyncDebug)
         trace "xxx tick_frac="+tick_frac+" rpn_com_speed_scl="+rpn_com_speed_scl+" tick_nr="+tick_nr+" synced="+synced_tick_nr;

      if(!_bMuted)
      {
         if(b_echo_frame_rec_to_play && bEditFocus && _frameRec.numEvents > 0)
         {
            // [07Jun2025] echo *all* frameRec events to keyjazz instrument (e.g. synth ctl changes)
            echoKJInsFrameRecToPlay(frOutReplay, _frameRec);
            _frameRec.empty();
         }
      }

      if(_bPlaySeq && bAdvSeq)  // [25Oct2020] don#t handle speed sync during precount
      {
         if(rpn_com_speed_sync_rate > 0.0f)
         {
            float unsyncedPatOff = tick_nr;
            float syncedPatOff = synced_tick_nr + 1;
            float syncedPatLen = jam_length * jam_tick_multiplier;
            if(0 == syncedPatLen)
            {
               // non-existing pattern selected, continue with last seen pattern length
               //  (at least better than skipping sync entirely)
               syncedPatLen = last_synced_pat_len;
            }
            else
               last_synced_pat_len = syncedPatLen;
            unsyncedPatOff = unsyncedPatOff % syncedPatLen;
            syncedPatOff = syncedPatOff % syncedPatLen;
            if( ((synced_tick_nr+1) > tick_nr) && (unsyncedPatOff > syncedPatOff) )
            {
               syncedPatOff += syncedPatLen;
            }

            if(bSyncDebug)
               trace "xxx len="+syncedPatLen+" off unsynced="+unsyncedPatOff+" synced="+syncedPatOff+" delta="+(syncedPatOff - unsyncedPatOff);

            if(syncedPatOff > unsyncedPatOff)
            {
               // Speed up
               syncSpeedFactor = 1.0 + rpn_com_speed_sync_rate;
            }
            else if(syncedPatOff < unsyncedPatOff)
            {
               // Slow down
               syncSpeedFactor = (1.0 / (1.0 + rpn_com_speed_sync_rate));
            }

            if(bSyncDebug)
               trace "xxx syncSpeedFactor="+syncSpeedFactor;
         }

         if(bCapture)
         {
            // if(frOutReplay.numEvents)
            //    trace "xxx NodeTracker: captureAdd: frOutReplay.numEvents="+frOutReplay.numEvents;
            mon_capture.captureAdd(frOutReplay, true/*bAdvance*/);
            _framePlay.mergeFrame(frOutReplay);
         }

         tick_frac += rpn_com_speed_scl * syncSpeedFactor;
         synced_tick_nr++;
      }
      else
      {
         // idle, increase tick_frac so keyjazz_queue gets processed in NT_TrackPattern.tick()
         tick_frac += 1.0f;//////rpn_com_speed_scl * syncSpeedFactor;
      }

      if(b_tap_mode)
      {
         play_pattern_nr = origPlayPatNr;
      }

      b_slide_note_off = false;

      if(-1 != jam_current_ticks)
         ghost_jam_current_ticks_song_offset = current_song.song_offset;

      if(bSeekPattern)
         b_ui_ghost_seek = true;

      // at end of pattern (last tick)
      // if(-1 == jam_current_ticks)
      //    trace "!!! jam_current_ticks == -1 at end of tick  node_queued_com_seek_off="+node_queued_com_seek_off+" song_offset="+current_song.song_offset;

      // trace "xxx tick_nr="+tick_nr;
   }

}
