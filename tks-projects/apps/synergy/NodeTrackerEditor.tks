// ----
// ---- file   : NodeTrackerEditor.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 14Sep2006
// ---- changed: .., .., ..,
// ----          29Jan2010, 25Feb2010, 01Mar2010, 24Apr2010, 29Apr2010, 01May2010, 02May2010
// ----          03May2010, 14May2010, 16May2010, 04Jul2010, 06Jul2010, 21Jul2010, 19Oct2010
// ----          17Feb2011, 20Feb2011, 25Feb2011, 14Mar2011, 15Mar2011, 17Mar2011, 19Mar2011
// ----          02Apr2011, 11Jun2011, 04Jan2012, 09Jan2012, 16Jan2012, 17Jan2012, 19Jan2012
// ----          02Feb2012, 08Feb2012, 14Feb2012, 13May2012, 26Jun2012, 04Jan2013, 06Jan2013
// ----          28Feb2013, 09May2013, 10May2013, 15May2013, 25May2013, 29May2013, 31May2013
// ----          01Jun2013, 04Jun2013, 05Jun2013, 27Aug2013, 02Feb2014, 17Jan2015, 19Jan2015,
// ----          23Jan2015, 24Jan2015, 26Jan2015, 27Jan2015, 28Jan2015, 30Jan2015, 01Feb2015,
// ----          03Feb2015, 05Feb2015, 06Feb2015, 07Feb2015, 08Feb2015, 09Feb2015, 11Feb2015,
// ----          13Feb2015, 16Feb2015, 18Feb2015, 22Feb2015, 24Feb2015, 26Feb2015, 27Feb2015
// ----          28Feb2015, 01Mar2015, 02Mar2015, 04Mar2015, 05Mar2015, 06Mar2015, 08Mar2015
// ----          14Mar2015, 09Apr2015, 19Apr2015, 20Apr2015, 28Apr2015, 29Apr2015, 03May2015,
// ----          13May2015, 14May2015, 06Jul2015, 26Jul2015, 28Jul2015, 11Sep2015, 25Sep2015
// ----          26Sep2015, 27Sep2015, 28Sep2015, 29Sep2015, 02Oct2015, 03Oct2015, 08Oct2015
// ----          09Oct2015, 10Oct2015, 23Oct2015, 24Oct2015, 26Oct2015, 29Oct2015, 05Nov2015
// ----          11Nov2015, 12Nov2015, 15Nov2015, 17Nov2015, 17Dec2015, 30Dec2015, 08Jan2016
// ----          19Jan2016, 30Jan2016, 13Mar2016, 28Mar2016, 31Mar2016, 09Apr2016, 08Jul2016
// ----          12Jul2016, 25Jul2016, 19Sep2016, 30Sep2016, 02Oct2016, 15Oct2016, 25Nov2016
// ----          19Jan2017, 28Jan2017, 04Feb2017, 09Feb2017, 10Feb2017, 12Feb2017, 13Feb2017
// ----          26Feb2017, 04Mar2017, 05Mar2017, 18Mar2017, 20Mar2017, 07Apr2017, 18Apr2017
// ----          23May2017, 05Jun2017, 16Jun2017, 01Jul2017, 14Jul2017, 18Aug2017, 01Sep2017
// ----          04Oct2017, 12Oct2017, 13Oct2017, 29Oct2017, 09Nov2017, 04Jan2018, 03Mar2018
// ----          06Mar2018, 15Apr2018, 24May2018, 28May2018, 01Jun2018, 17Jun2018, 27Nov2018
// ----          02Dec2018, 10Jan2019, 12Jan2019, 13Jan2019, 01Mar2019, 19May2019, 08Jun2019
// ----          02Aug2019, 03Aug2019, 27Aug2019, 29Aug2019, 10Sep2019, 20Sep2019, 22Sep2019
// ----          03Oct2019, 07Oct2019, 19Oct2019, 20Oct2019, 22Oct2019, 23Oct2019, 24Oct2019
// ----          30Oct2019, 31Oct2019, 01Nov2019, 08Nov2019, 17Nov2019, 20Feb2020, 06Mar2020
// ----          25Apr2020, 26Apr2020, 28Apr2020, 04Sep2020, 24Sep2020, 24Oct2020, 26Oct2020
// ----          27Oct2020, 08Nov2020, 10Nov2020, 15Nov2020, 26Jan2021, 31Jan2021, 13May2021
// ----          02Jun2021, 17Jul2021, 21Jul2021, 01Oct2021, 11Dec2021, 30Dec2021, 01Jan2022
// ----          04Jan2022, 04Feb2022, 11Feb2022, 16Apr2022, 19Apr2022, 20Apr2022, 06May2022
// ----          23Jun2022, 25Nov2022, 11Feb2023, 19Feb2023, 23Jun2023, 16Aug2023, 21Sep2023
// ----          03Oct2023, 05Oct2023, 06Oct2023, 14Oct2023, 05Nov2023, 10Nov2023, 14Nov2023
// ----          16Nov2023, 19Nov2023, 27Nov2023, 02Dec2023, 07Dec2023, 22Mar2024, 06May2024
// ----          07Jul2024, 01Oct2024, 02Oct2024, 06Oct2024, 04Jan2025, 28Feb2025, 07Jun2025
// ----          12Jun2025, 13Jun2025
// ----
// ----
// ----

module MNodeTrackerEditor;

use namespace ui;
use namespace st2;


// <class.png>
class NT_ModeButton : Button {
   boolean b_last_state;

   public virtual setDefaultInnerPadding() {
      setInnerPadding4f(-2, 2, 0, 2);
      setPadding4fUnscaled(1.0f, 4.0f, 0.0f, 0.0f);
      setRequiredSizeYScaled(12.0);
   }

   public virtual onDraw() {
      Label::onDraw();
   }

   public virtual beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {
      boolean r = Button::beginXFMTag(_form, _attributes);
      b_last_state = -99;
      setEnableKbdFocusOnMouse(false);
      return r;
   }
}

// <class.png>
class NodeTrackerEditor extends NodeEditor, MIDIMapEventListener, KeyboardFocusListener, ActionProvider, MIDIMapDefs, RemoteEventListener {

   define String TA_NOTELABEL;
   define String TA_MODEWIDGETS;

   define int VIEW_PATTERN    = 0;
   define int VIEW_INSTRUMENT = 1;
   define int VIEW_PLAY       = 2;
   define int VIEW_ARP        = 3;

   // define String MMT_TAB_PATTERN;
   // define String MMT_TAB_INSTRUMENTS;
   // define String MMT_TAB_PLAY;
   // define String MMT_TAB_ARP;

   define String MMT_PATTERN_LEN;
   define String MMT_PATTERN_LEN_INV;
   define String MMT_PATTERN_LEN_DELTA;
   define String MMT_PATTERN_LEN_INC;
   define String MMT_PATTERN_LEN_DEC;

   define String MMT_PATTERN_NR;
   define String MMT_PATTERN_NR_INV;
   define String MMT_PATTERN_NR_DELTA;
   define String MMT_PATTERN_NR_INC;
   define String MMT_PATTERN_NR_DEC;

   define String MMT_PATTERN_NR_GROUP;
   define String MMT_PATTERN_NR_GROUP_INV;
   define String MMT_PATTERN_NR_GROUP_DELTA;
   define String MMT_PATTERN_NR_GROUP_INC;
   define String MMT_PATTERN_NR_GROUP_DEC;

   define String MMT_PATTERN_NR_SUB;
   define String MMT_PATTERN_NR_SUB_INV;
   define String MMT_PATTERN_NR_SUB_DELTA;
   define String MMT_PATTERN_NR_SUB_INC;
   define String MMT_PATTERN_NR_SUB_DEC;

   define String MMT_PATTERN_NR_1;  // 01x
   define String MMT_PATTERN_NR_2;
   define String MMT_PATTERN_NR_3;
   define String MMT_PATTERN_NR_4;
   define String MMT_PATTERN_NR_5;
   define String MMT_PATTERN_NR_6;
   define String MMT_PATTERN_NR_7;
   define String MMT_PATTERN_NR_8;
   define String MMT_PATTERN_NR_9;
   define String MMT_PATTERN_NR_10;
   define String MMT_PATTERN_NR_11;
   define String MMT_PATTERN_NR_12;
   define String MMT_PATTERN_NR_13;
   define String MMT_PATTERN_NR_14;
   define String MMT_PATTERN_NR_15;
   define String MMT_PATTERN_NR_16; // 16x

   define String MMT_EDIT_UNDO;
   define String MMT_EDIT_REDO;

   define String MMT_PAT_COPY;
   define String MMT_PAT_PASTE;
   define String MMT_PAT_CLEAR;
   define String MMT_PAT_NEW;
   define String MMT_PAT_NEW_SUB;
   define String MMT_PAT_DELETE;
   define String MMT_PAT_CLONE;
   define String MMT_PAT_CLONE_SUB;
   define String MMT_PAT_DOUBLE;
   define String MMT_PAT_DOUBLE_COPY;
   define String MMT_PAT_REVERSE;
   define String MMT_PAT_ROTATE_UP;
   define String MMT_PAT_ROTATE_DOWN;

   define String MMT_PAT_EDIT;
   define String MMT_PAT_RECORD;
   define String MMT_PAT_RECORD_CONTINUE;
   define String MMT_PAT_PLAY;
   define String MMT_PAT_TAP_TOGGLE;
   define String MMT_PAT_COLLAPSE_AND_TAP;

   define String MMT_CURSOR_PAGEUP;
   define String MMT_CURSOR_PAGEDOWN;
   define String MMT_CURSOR_TRACK_PREV;
   define String MMT_CURSOR_TRACK_NEXT;
   define String MMT_CURSOR_TRACK_CTL_PREV;
   define String MMT_CURSOR_TRACK_CTL_NEXT;
   define String MMT_CURSOR_TRACK_CTL_DELTA;

   // // define String MMT_SOLO_PIPE;
   // // define String MMT_SOLO_NODE;

   // // define String MMT_REC_NOTEOFF;
   // // define String MMT_REC_DUR;
   // // define String MMT_REC_QUANTIZE;

   define String MMT_ZOOM_1_32T;
   define String MMT_ZOOM_1_32;
   define String MMT_ZOOM_1_16T;
   define String MMT_ZOOM_1_16;
   define String MMT_ZOOM_1_8T;
   define String MMT_ZOOM_1_8;
   define String MMT_ZOOM_1_4T;
   define String MMT_ZOOM_1_4;
   define String MMT_ZOOM_INC;
   define String MMT_ZOOM_DEC;

   public NodeTracker *tracker_node; // node that's currently being edited

   public NT_PatternView    *pattern_view;
   public NT_InstrumentView *instrument_view;
   public NT_EnvelopeView   *envelope_view;

   protected Panel     *pn_pattern_view;
   protected SplitPane *sp_envelope_view;

   public PianoWidget    *piano;
   protected LayerSwitch *ls_piano;

   protected LayerSwitch *ls_view;
   protected Button      *bt_view_pattern;
   protected Button      *bt_view_instruments;
   protected Button      *bt_view_play;
   protected Button      *bt_view_arp;

   protected Label       *lb_playpat;

   protected TextField    *tf_pat_name;
   protected Button       *bt_keyjazz;  // toggle button
   protected Button       *bt_follow;   // toggle button
   protected PopupMenuBar *menubar;

   // PatternView scrollbar
   protected Scroller    *sr_tracks;
   protected LayerSwitch *ls_tracks;

   protected LayerSwitch *ls_envelope;  // show/hide envelope view

   protected TimerAction *ta_notelabel;
   protected boolean noteicon_mode; // 0=icon, 1=text, 2=icon
   protected String notelabel_caption;

   protected ComboBox   *cm_patnr;
   protected ComboBox   *cm_mmc_patnr_group;
   protected ComboBox   *cm_mmc_patnr_sub;
   protected FloatParam *fp_patlen;
   protected TextField  *tf_kj_instrument; // xxx make this an editable ComboBox later..
   protected CheckBox   *cb_write_instrnr;
             FloatParam *fp_kj_octave;
   protected FloatParam *fp_kj_velocity;
   protected CheckBox   *cb_write_velocity;
   protected CheckBox   *cb_addnotecel_vel;
             FloatParam *fp_kj_duration;
   protected CheckBox   *cb_write_duration;
   protected CheckBox   *cb_addnotecel_dur;
   protected FloatParam *fp_kj_offvelocity;
   protected CheckBox   *cb_write_offvelocity;
             FloatParam *fp_stepresolution;
   protected Label      *lb_zoomicon;

   protected Panel *pn_mode;

   protected NT_ModeButton *bt_mode_edit;
   protected NT_ModeButton *bt_mode_rtrecord;
   protected NT_ModeButton *bt_mode_relshift;
   protected NT_ModeButton *bt_mode_autoscroll;
   protected NT_ModeButton *bt_mode_wraparound;
   protected NT_ModeButton *bt_mode_bookmark;
   protected NT_ModeButton *bt_mode_playstepreset;
   protected NT_ModeButton *bt_mode_swaplshift;
   protected NT_ModeButton *bt_mode_kjlock;
   protected NT_ModeButton *bt_mode_precount;

   protected NT_ModeButton *bt_mode_freerun;
   protected NT_ModeButton *bt_mode_ignorearr;
   protected NT_ModeButton *bt_mode_selectplay;
   protected NT_ModeButton *bt_mode_followarr;
   protected NT_ModeButton *bt_mode_chordadv;
   protected NT_ModeButton *bt_mode_chordclear;
   protected NT_ModeButton *bt_mode_tapmode;
   protected NT_ModeButton *bt_mode_reclatency;
   protected NT_ModeButton *bt_mode_kjnoteoff;
   protected NT_ModeButton *bt_mode_recusrctlnoteon;

   protected NT_ModeButton *bt_mode_timing;
   protected NT_ModeButton *bt_mode_timinglock;
   protected NT_ModeButton *bt_mode_recnoteoff;
   protected NT_ModeButton *bt_mode_recnoteoff_replay;
   protected NT_ModeButton *bt_mode_recquant;
   protected NT_ModeButton *bt_mode_recdur;
   protected NT_ModeButton *bt_mode_envelope;
   protected NT_ModeButton *bt_mode_piano;
   protected NT_ModeButton *bt_mode_kj;
   protected NT_ModeButton *bt_mode_metronome;

   protected TimerAction *ta_modewidgets;

   // Pulldown menu
   PopupMenuCheckButton *pmcb_edit_patternedit;
   PopupMenuCheckButton *pmcb_edit_shiftall;
   PopupMenuCheckButton *pmcb_edit_undomode;
   PopupMenuCheckButton *pmcb_edit_undodebug;
   PopupMenuCheckButton *pmcb_edit_advanceallnotesreleased;
   PopupMenuCheckButton *pmcb_edit_chordclearstep;
   PopupMenuCheckButton *pmcb_edit_timingviewmovelock;
   PopupMenuCheckButton *pmcb_edit_swaplshift;
   PopupMenuCheckButton *pmcb_edit_showctlinfo;
   PopupMenuCheckButton *pmcb_edit_frrectokjinsplay;
   PopupMenuCheckButton *pmcb_cursor_autoscroll;
   PopupMenuCheckButton *pmcb_cursor_wraparound;
   PopupMenuCheckButton *pmcb_cursor_doublecenter;
   PopupMenuCheckButton *pmcb_cursor_doublewidth;
   PopupMenuCheckButton *pmcb_cursor_doubleheight;
   PopupMenuCheckButton *pmcb_cursor_timing_autodoublewidth;
   PopupMenuCheckButton *pmcb_cursor_timing_autodoubleheight;
   PopupMenuCheckButton *pmcb_cursor_decimalpatoff;
   PopupMenuCheckButton *pmcb_cursor_shiftpatoff;
   PopupMenuCheckButton *pmcb_replay_selectandplay;
   PopupMenuCheckButton *pmcb_replay_playstepreset;
   PopupMenuCheckButton *pmcb_replay_invertspace;
   PopupMenuCheckButton *pmcb_replay_freerun;
   PopupMenuCheckButton *pmcb_replay_ignorearr;
   PopupMenuCheckButton *pmcb_replay_followarr;
   // // PopupMenuCheckButton *pmcb_replay_mmcrec_autoreset;
   PopupMenuCheckButton *pmcb_track_shownames;
   PopupMenuCheckButton *pmcb_track_showeq;
   PopupMenuCheckButton *pmcb_track_addnotecel_vel;
   PopupMenuCheckButton *pmcb_track_addnotecel_dur;
   PopupMenuCheckButton *pmcb_track_addnotecel_autogroup;
   // // PopupMenuCheckButton *pmcb_track_eqrms;
   PopupMenuCheckButton *pmcb_track_showctlstatus;
   PopupMenuCheckButton *pmcb_pattern_recordpre;
   PopupMenuCheckButton *pmcb_pattern_recordnoteoff;
   PopupMenuCheckButton *pmcb_pattern_recordnoteoff_replay;
   PopupMenuCheckButton *pmcb_pattern_recordnoteoff_dur;
   PopupMenuCheckButton *pmcb_pattern_recordquantize;
   PopupMenuCheckButton *pmcb_pattern_recusrctlnoteon;
   PopupMenuCheckButton *pmcb_pattern_reclatency;
   PopupMenuCheckButton *pmcb_pattern_capture_ticks;
   PopupMenuButton      *pmb_block_mode;
   PopupMenuButton      *pmb_block_transpose_up;
   PopupMenuButton      *pmb_block_transpose_down;
   // // PopupMenuCheckButton *pmcb_event_pulse;
   PopupMenuCheckButton *pmcb_instrument_keyjazzmanualnoteoff;
   PopupMenuCheckButton *pmcb_track_lockkeyjazz;
   PopupMenuButton      *pmb_events_collapse;

   PointerArray pa_pmrb_edit_stepadv;
   PointerArray pa_pmrb_edit_microshift;

   // Play view:
   protected ComboBox   *cm_node_class;
   protected CheckBox   *cb_node_class_show;
   // (note) cm_node_class_show_in is declared in NodeEditor base class
   protected ComboBox   *cm_play_mode;
   protected CheckBox   *cb_play_change_reset;
   protected CheckBox   *cb_play_extclk;
   protected FloatParam *fp_play_extclk_gatetime;
   protected FloatParam *fp_speed_scl_reset;
   protected FloatParam *fp_play_offlen_steps;
   protected FloatParam *fp_play_dur_steps;

   protected ComboBox *cm_play_rec_mode;
   protected CheckBox *cb_play_match_instr;  // "Filter"
   protected CheckBox *cb_play_rec_qlast;
   protected CheckBox *cb_play_rec_prev;
   protected CheckBox *cb_play_rec_all;
   protected CheckBox *cb_play_rec_spread;
   protected CheckBox *cb_play_rec_bg;
   protected ComboBox *cm_play_rec_sel;

   protected ComboBox *cm_play_midi_node;
   protected ComboBox *cm_play_audio_node;

   protected CheckBox *cb_play_per_pattern_kj_instr;


   // Arp view:
   protected CheckBox     *cb_arp;
   protected TableView    *tv_arp_notes;
   protected NT_ArpNotesTM *tm_arp_notes;
   protected Button    *bt_arp_add;
   protected Button    *bt_arp_remove;
   protected Button    *bt_arp_moveup;
   protected Button    *bt_arp_movedown;
   protected ComboBox  *cm_arp_baseoct;
   protected CheckBox  *cb_arp_reset;
   protected CheckBox  *cb_arp_wrap;
   protected ComboBox  *cm_arp_latch;
   protected CheckBox  *cb_arp_latch_reset;
   protected CheckBox  *cb_arp_play_arp_notes;
   protected CheckBox  *cb_arp_play_non_arp_notes;
   protected CheckBox  *cb_arp_dynalen;

   // Dialogs:

   static NT_ManageColumnsDialog         *dlg_manage_columns;
   static NT_EditTrackLayoutDialog       *dlg_edit_track_layout;

   static NT_NewTrackDialog               dlg_newtrack;
   static NT_DeleteTrackDialog            dlg_deletetrack;
   static NT_SetPatternLengthDialog       dlg_setpatternlength;
   static NT_DebugUndoDialog              dlg_debugsubsongundo;
   static NT_PatternTimeMulConstDialog   *dlg_patterntimemulconst;
   static NT_ImportARDialog              *dlg_import_ar;
   static NT_ImportTrigSeqDialog         *dlg_import_trigseq;
   static NT_ImportMonitorDialog         *dlg_import_monitor;
   static NT_TapModeDialog               *dlg_tap_mode;

   static StringArray instr_nr_names = [
      "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
      "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
      "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"
                                        ];

   define int MAX_QUEUED_NORMALIZED_PARAM_UPDATES = 16;
   FloatArray normalized_param_update_queue;  // paramidx(0..31 => RPN Ctl 1..32),value tuples
   Mutex mtx_normalized_param_update;

   static String import_smf_open_suggested_file = "";
   static StringArray import_smf_file_filter_names = [ "Standard MIDI File (*.mid)" ];
   static StringArray import_smf_file_filter_strings = [ "*.mid" ];


   // <ui_init.png>
   public virtual init() : boolean {

      local String sPatternPreviousNext <= STConfig.b_key_swap_pattern_home_end
         // home=dec, end=inc
?'               <PopupMenuButton caption="Edit previous pattern (-4)" acceleratorKey="lctrl-home" actionName="pattern_prev4"/>
                <PopupMenuButton caption="Edit previous pattern (-1)" acceleratorKey="home" actionName="pattern_prev"/>
                <PopupMenuButton caption="Edit previous used pattern" acceleratorKey="lctrl-lshift-home" actionName="pattern_used_prev"/>
                <PopupMenuButton caption="Edit next pattern (+1)" acceleratorKey="end" actionName="pattern_next"/>
                <PopupMenuButton caption="Edit next pattern (+4)" acceleratorKey="lctrl-end" actionName="pattern_next4"/>
                <PopupMenuButton caption="Edit next used pattern" acceleratorKey="lctrl-lshift-end" actionName="pattern_used_next"/>
   '

         // home=inc, end=dec
:'               <PopupMenuButton caption="Edit previous pattern (-4)" acceleratorKey="lctrl-end" actionName="pattern_prev4"/>
                <PopupMenuButton caption="Edit previous pattern (-1)" acceleratorKey="end" actionName="pattern_prev"/>
                <PopupMenuButton caption="Edit previous used pattern" acceleratorKey="lctrl-lshift-end" actionName="pattern_used_prev"/>
                <PopupMenuButton caption="Edit next pattern (+1)" acceleratorKey="home" actionName="pattern_next"/>
                <PopupMenuButton caption="Edit next pattern (+4)" acceleratorKey="lctrl-home" actionName="pattern_next4"/>
                <PopupMenuButton caption="Edit next used pattern" acceleratorKey="lctrl-lshift-home" actionName="pattern_used_next"/>
'
         ;

      local String sBlockCopyPaste <= UI.b_key_cmd_copy_paste
?'              <PopupMenuButton caption="Copy block" acceleratorKey="lctrl-c" altAcceleratorKey="lalt-c" actionName="block_copyblock"
		                         toolTipCaption="Copy selected block to clipboard\n\n (note) When no block is selected, the entire pattern is copied to the clipboard"
		                         />
              <!-- Note: lctrl-x used for triadic accelerators <PopupMenuButton caption="Cut block" acceleratorKey="lctrl-x" actionName="block_cut"/> -->
              <PopupMenuButton caption="Paste block (replace)" acceleratorKey="lctrl-v" altAcceleratorKey="lalt-v" actionName="block_paste"
		                         toolTipCaption="Paste clipboard at cursor position. Replace/overwrite existing events."
		                         />
              <PopupMenuButton caption="Paste block (insert)" acceleratorKey="lctrl-lshift-v" altAcceleratorKey="lalt-lshift-v" actionName="block_pasteshift"
		                         toolTipCaption="Paste clipboard at cursor position. Shift existing events."
		                         />
'
:'              <PopupMenuButton caption="Copy block" acceleratorKey="lctrl-c" actionName="block_copyblock"
		                         toolTipCaption="Copy selected block to clipboard\n\n (note) When no block is selected, the entire pattern is copied to the clipboard"
		                         />
              <!-- Note: lctrl-x used for triadic accelerators <PopupMenuButton caption="Cut block" acceleratorKey="lctrl-x" actionName="block_cut"/> -->
              <PopupMenuButton caption="Paste block (replace)" acceleratorKey="lctrl-v" actionName="block_paste"
		                         toolTipCaption="Paste clipboard at cursor position. Replace/overwrite existing events."
		                         />
              <PopupMenuButton caption="Paste block (insert)" acceleratorKey="lctrl-lshift-v" actionName="block_pasteshift"
		                         toolTipCaption="Paste clipboard at cursor position. Shift existing events."
		                         />
';

      local String sXFM; sXFM.load("NodeTrackerEditor.xfm", true/*bRemoveCR*/);
      sXFM.replace("$(PATTERN_PREVIOUS_NEXT)", sPatternPreviousNext);
      sXFM.replace("$(BLOCK_COPY_PASTE)", sBlockCopyPaste);

      if(parseXMLForm(sXFM))
      {
         initTimers();

         initWidgets();
         f_autodev.initAutoDeviceForm();

         initPatternView();
         initInstrumentView();
         initEnvelopeView();

         sp_envelope_view <= findLayerById("sp_envelope_view");

         // pattern_view
         pn_pattern_view <= findLayerById("pn_pattern_view");
         pattern_view <= pn_pattern_view.unlinkChildLayer(pattern_view);
         pn_pattern_view.removeChildLayer(pattern_view);
         Panel pn <= findLayerById("pn_envelope_view");
         envelope_view <= pn.unlinkChildLayer(envelope_view);

         initPulldownMenuWidgets();

         tm_arp_notes <= new NT_ArpNotesTM;
         tm_arp_notes.parent_editor <= this;
         tm_arp_notes.initTableModel();
         tv_arp_notes.setTableModel(tm_arp_notes);

         fp_speed_scl_reset.setPresetOptions([0.25,      0.5,    0.75,  1.0,         1.5,   2.0],
                                             ["Quarter", "Half", "3/4", "<default>", "6/4", "Double"]
                                             );

         if(initDialogs())
         {
            sr_tracks.addActionConsumer(pattern_view);

            initMMC();

            showView(VIEW_PATTERN, false/*bEnterLeave*/);

            return true;
         }
         else
         {
            Global.Error("NodeTrackerEditor::init: initDialogs() failed.");
         }
      }

      Global.Error("NodeTrackerEditor::init() failed.");
      return false;
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_notelabel   <= TimerAction.New(TA_NOTELABEL,   this, 100);
      ta_modewidgets <= TimerAction.New(TA_MODEWIDGETS, this, 128);
   }

   // <ui_init.png>
   protected method initDialogs() {

      if(!initEditTrackLayoutDialog())
         return false;

      if(!initManageColumnsDialog())
         return false;

      if(!initPatternTimeMulConstDialog())
         return false;

      if(!initImportARDialog())
         return false;

      if(!initImportTrigSeqDialog())
         return false;

      if(!initImportMonitorDialog())
         return false;

      if(!initTapModeDialog())
         return false;

      return true;
   }

   // <ui_init.png>
   protected method initEditTrackLayoutDialog() : boolean {
      dlg_edit_track_layout <= new NT_EditTrackLayoutDialog();
      if(!dlg_edit_track_layout.init(this))
      {
         Global.Error("NT_EditTrackLayoutDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initManageColumnsDialog() : boolean {
      dlg_manage_columns <= new NT_ManageColumnsDialog();
      if(!dlg_manage_columns.init())
      {
         Global.Error("NT_ManageColumnsDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initPatternTimeMulConstDialog() : boolean {
      dlg_patterntimemulconst <= new NT_PatternTimeMulConstDialog;
      if(!dlg_patterntimemulconst.init())
      {
         Global.Error("NT_PatternTimeMulConstDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initImportARDialog() {
      dlg_import_ar <= new NT_ImportARDialog;
      if(!dlg_import_ar.init())
      {
         Global.Error("NT_ImportARDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initImportTrigSeqDialog() {
      dlg_import_trigseq <= new NT_ImportTrigSeqDialog;
      if(!dlg_import_trigseq.init())
      {
         Global.Error("NT_ImportTrigSeqDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initImportMonitorDialog() {
      dlg_import_monitor <= new NT_ImportMonitorDialog;
      if(!dlg_import_monitor.init())
      {
         Global.Error("NT_ImportMonitorDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initTapModeDialog() {
      dlg_tap_mode <= new NT_TapModeDialog;
      if(!dlg_tap_mode.init())
      {
         Global.Error("NT_TapModeDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   public method initWidgets() {

      autoResolveIds(this);

      cm_patnr.setOptions(Node.patnr_options);
      cm_mmc_patnr_group.setOptions(Node.patnr_group_options);
      cm_mmc_patnr_sub.setOptions(Node.patnr_sub_options);

      cb_addnotecel_vel.setSelected(STConfig.b_node_tracker_addnotecel_vel);
      cb_addnotecel_dur.setSelected(STConfig.b_node_tracker_addnotecel_dur);
   }

   // <ui_init.png>
   protected method initPulldownMenuWidgets() {
      int i;

      pmcb_edit_patternedit                <= findLayerById("pmcb_edit_patternedit");
      pmcb_edit_shiftall                   <= findLayerById("pmcb_edit_shiftall");
      pmcb_edit_undomode                   <= findLayerById("pmcb_edit_undomode");
      pmcb_edit_undodebug                  <= findLayerById("pmcb_edit_undodebug");
      pmcb_edit_advanceallnotesreleased    <= findLayerById("pmcb_edit_advanceallnotesreleased");
      pmcb_edit_chordclearstep             <= findLayerById("pmcb_edit_chordclearstep");
      pmcb_edit_timingviewmovelock         <= findLayerById("pmcb_edit_timingviewmovelock");
      pmcb_edit_swaplshift                 <= findLayerById("pmcb_edit_swaplshift");
      pmcb_edit_showctlinfo                <= findLayerById("pmcb_edit_showctlinfo");
      pmcb_edit_frrectokjinsplay           <= findLayerById("pmcb_edit_frrectokjinsplay");
      pmcb_cursor_doublecenter             <= findLayerById("pmcb_cursor_doublecenter");
      pmcb_cursor_doublewidth              <= findLayerById("pmcb_cursor_doublewidth");
      pmcb_cursor_doubleheight             <= findLayerById("pmcb_cursor_doubleheight");
      pmcb_cursor_timing_autodoublewidth   <= findLayerById("pmcb_cursor_timing_autodoublewidth");
      pmcb_cursor_timing_autodoubleheight  <= findLayerById("pmcb_cursor_timing_autodoubleheight");
      pmcb_cursor_decimalpatoff            <= findLayerById("pmcb_cursor_decimalpatoff");
      pmcb_cursor_shiftpatoff              <= findLayerById("pmcb_cursor_shiftpatoff");
      pmcb_replay_selectandplay            <= findLayerById("pmcb_replay_selectandplay");
      pmcb_replay_playstepreset            <= findLayerById("pmcb_replay_playstepreset");
      pmcb_replay_invertspace              <= findLayerById("pmcb_replay_invertspace");
      pmcb_replay_freerun                  <= findLayerById("pmcb_replay_freerun");
      pmcb_replay_ignorearr                <= findLayerById("pmcb_replay_ignorearr");
      pmcb_replay_followarr                <= findLayerById("pmcb_replay_followarr");
      // // pmcb_replay_mmcrec_autoreset         <= findLayerById("pmcb_replay_mmcrec_autoreset");
      pmcb_track_shownames                 <= findLayerById("pmcb_track_shownames");
      pmcb_track_showeq                    <= findLayerById("pmcb_track_showeq");
      pmcb_track_addnotecel_vel            <= findLayerById("pmcb_track_addnotecel_vel");
      pmcb_track_addnotecel_dur            <= findLayerById("pmcb_track_addnotecel_dur");
      pmcb_track_addnotecel_autogroup      <= findLayerById("pmcb_track_addnotecel_autogroup");
      // // pmcb_track_eqrms                     <= findLayerById("pmcb_track_eqrms");
      pmcb_track_lockkeyjazz               <= findLayerById("pmcb_track_lockkeyjazz");
      // // pmcb_track_showctlstatus             <= findLayerById("pmcb_track_showctlstatus");
      pmcb_cursor_autoscroll               <= findLayerById("pmcb_cursor_autoscroll");
      pmcb_cursor_wraparound               <= findLayerById("pmcb_cursor_wraparound");
      pmcb_pattern_recordpre               <= findLayerById("pmcb_pattern_recordpre");
      pmcb_pattern_recordnoteoff           <= findLayerById("pmcb_pattern_recordnoteoff");
      pmcb_pattern_recordnoteoff_replay    <= findLayerById("pmcb_pattern_recordnoteoff_replay");
      pmcb_pattern_recordnoteoff_dur       <= findLayerById("pmcb_pattern_recordnoteoff_dur");
      pmcb_pattern_recordquantize          <= findLayerById("pmcb_pattern_recordquantize");
      pmcb_pattern_recusrctlnoteon         <= findLayerById("pmcb_pattern_recusrctlnoteon");
      pmcb_pattern_reclatency              <= findLayerById("pmcb_pattern_reclatency");
      pmcb_pattern_capture_ticks           <= findLayerById("pmcb_pattern_capture_ticks");
      // // pmcb_event_pulse                     <= findLayerById("pmcb_event_pulse");
      pmb_block_mode                       <= findLayerById("pmb_block_mode");
      pmb_block_transpose_up               <= findLayerById("pmb_block_transpose_up");
      pmb_block_transpose_down             <= findLayerById("pmb_block_transpose_down");
      // // pmcb_macro_keyjazzlatch              <= findLayerById("pmcb_macro_keyjazzlatch");
      pmcb_instrument_keyjazzmanualnoteoff <= findLayerById("pmcb_instrument_keyjazzmanualnoteoff");
      pmb_events_collapse                  <= findLayerById("pmb_events_collapse");

      // Step advance buttons in pulldown menu
      i=0;
      loop(10)
      {
         pa_pmrb_edit_stepadv.add(findLayerById("pmrb_edit_stepadv_"+i));
         i++;
      }
      updateStepAdvanceRadioButtons();

      // Microshift buttons in pulldown menu
      i=0;
      loop(10)
      {
         PopupMenuRadioButton pmrb <= findLayerById("pmrb_edit_microshift_"+i);
         pmrb.setCaption((STConfig.node_tracker_microshift_ticks.get(i))+" ticks");
         pa_pmrb_edit_microshift.add(pmrb);
         i++;
      }

      // // pmcb_macro_keyjazzlatch.setSelected(STConfig.b_keyjazz_macro_latch);

      pmcb_instrument_keyjazzmanualnoteoff.setSelected(STConfig.b_node_tracker_keyjazz_manual_noteoff);

      pmcb_edit_undomode .setSelected (STConfig.b_node_tracker_undo_record_single_transaction);
      pmcb_edit_undodebug.setSelected (STConfig.b_node_tracker_undo_debug);
      pmcb_edit_advanceallnotesreleased.setSelected(STConfig.b_node_tracker_advance_allnotesreleased);

      pmcb_cursor_autoscroll      .setSelected(STConfig.b_node_tracker_autoscroll);
      pmcb_cursor_wraparound      .setSelected(STConfig.b_node_tracker_wraparound);
      pmcb_cursor_doublecenter    .setSelected(UI.IsHiDPI()
                                               ? STConfig.b_node_tracker_doublecenter_hidpi
                                               : STConfig.b_node_tracker_doublecenter_lodpi
                                               );
      pmcb_cursor_doublewidth     .setSelected(UI.IsHiDPI()
                                               ? STConfig.b_node_tracker_doublewidth_hidpi
                                               : STConfig.b_node_tracker_doublewidth_lodpi
                                               );
      pmcb_cursor_doubleheight    .setSelected(UI.IsHiDPI()
                                               ? STConfig.b_node_tracker_doubleheight_hidpi
                                               : STConfig.b_node_tracker_doubleheight_lodpi
                                               );
      pmcb_cursor_timing_autodoublewidth .setSelected(STConfig.b_node_tracker_timing_view_autodouble_width);
      pmcb_cursor_timing_autodoubleheight.setSelected(STConfig.b_node_tracker_timing_view_autodouble_height);
      pmcb_cursor_decimalpatoff   .setSelected(STConfig.b_node_tracker_decimal_patternoffset);
      pmcb_cursor_shiftpatoff     .setSelected(STConfig.b_node_tracker_shift_patternoffset);

      pmcb_track_showeq         .setSelected(STConfig.b_node_tracker_draweq);
      // // pmcb_track_eqrms        .setSelected(STConfig.patternview_eqrms);
      // // pmcb_track_showctlstatus.setSelected(STConfig.b_ctlstatus_view);
      pmcb_track_addnotecel_vel .setSelected(STConfig.b_node_tracker_addnotecel_vel);
      pmcb_track_addnotecel_dur .setSelected(STConfig.b_node_tracker_addnotecel_dur);
      pmcb_track_addnotecel_autogroup .setSelected(STConfig.b_node_tracker_addnotecel_autogroup);

      pmcb_pattern_recordpre             .setSelected(STConfig.b_node_tracker_precount);
      pmcb_pattern_recordnoteoff         .setSelected(STConfig.b_node_tracker_recordnoteoff);
      pmcb_pattern_recordnoteoff_replay  .setSelected(STConfig.b_node_tracker_recordnoteoff_replay);
      pmcb_pattern_recordnoteoff_dur     .setSelected(STConfig.b_node_tracker_recordnoteoff_dur);
      pmcb_pattern_recordquantize        .setSelected(STConfig.b_node_tracker_recordquantize);
      pmcb_pattern_recusrctlnoteon       .setSelected(STConfig.b_node_tracker_recordusrctlnoteon);
      pmcb_pattern_reclatency            .setSelected(STConfig.b_node_tracker_rec_latency);
      pmcb_pattern_capture_ticks         .setSelected(STConfig.b_node_monitor_capture_tick_timebase);

      pmcb_replay_selectandplay   .setSelected(STConfig.b_node_tracker_selectandplay);
      pmcb_replay_invertspace     .setSelected(!STConfig.b_node_tracker_swapstopbookmark);
      pmcb_replay_freerun         .setSelected(replay.b_freerun_loop);
      updateIgnorePrgChgAndFollowArr();
      // // pmcb_replay_mmcrec_autoreset.setSelected(STConfig.b_node_tracker_midi_mmcrec_autoreset);


      updateBlockModeName();
   }

   // <ui_update.png>
   public method updateIgnorePrgChgAndFollowArr() {
      pmcb_replay_ignorearr.setSelected(STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay);
      pmcb_replay_followarr.setSelected(STConfig.b_node_tracker_edit_pattern_follows_replay_pattern);

      bt_follow.setSelected(STConfig.b_node_tracker_edit_pattern_follows_replay_pattern && !STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay);
   }

   // <ui_init.png>
   public method initPatternView() {

      pattern_view <= findLayerById("pattern_view");

      pattern_view.init(this);

      setStepResolution(current_song.ppq / 4);

      // // pattern_view.renderPatPosition(0, -1);

      sr_tracks <= findLayerById("sr_tracks");
      sr_tracks.addActionConsumer(pattern_view);
      ls_tracks <= findLayerById("ls_tracks");
   }

   // <ui_init.png>
   public method initInstrumentView() : boolean {
      instrument_view <= findLayerById("instrument_view");
      return instrument_view.init(this);
   }

   // <ui_init.png>
   public method initEnvelopeView() : boolean {
      envelope_view <= findLayerById("envelope_view");
      return envelope_view.init(this);
   }

   // <midi_mmc.png>
   protected method initMMC() {

      // Init normal context
      mmcInit("NodeTrackerEditor");

      // From PageNode: (so these show up in the map editor)
      root_form.pg_node.addBaseMMCTargets(this);

      addMMCTargets(this);
   }

   // <midi_mmc.png>
   protected method addMMCTargets(MIDIMapContext _mmc) {

      _mmc.mmcAddTargetExO(MMT_PATTERN_NR,            CLASS_VALUE,  SYN_NONE,
                           "PatNr", "Pattern", DPY_DEFAULT, cm_patnr
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_INV,        CLASS_VALUE,  SYN_NONE,
                           "PatNr", "Pattern", DPY_DEFAULT, cm_patnr
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_DELTA,      CLASS_DELTA,  1,
                           "PatNr", "Pattern", DPY_DEFAULT, cm_patnr
                           );
      _mmc.mmcAddTarget(MMT_PATTERN_NR_INC,          CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_DEC,          CLASS_BUTTON, SYN_BUTTON_REPEAT);


      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_GROUP,      CLASS_VALUE,  SYN_NONE,
                           "PatGrp", "Pattern Group", DPY_DEFAULT, cm_mmc_patnr_group
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_GROUP_INV,  CLASS_VALUE,  SYN_NONE,
                           "PatGrp", "Pattern Group", DPY_DEFAULT, cm_mmc_patnr_group
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_GROUP_DELTA, CLASS_DELTA,  8,
                           "PatGrp", "Pattern Group",  DPY_DEFAULT, cm_mmc_patnr_group
                           );
      _mmc.mmcAddTarget(MMT_PATTERN_NR_GROUP_INC,      CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_GROUP_DEC,      CLASS_BUTTON, SYN_BUTTON_REPEAT);


      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_SUB,      CLASS_VALUE,  SYN_NONE,
                           "PatSub", "Pattern Sub", DPY_DEFAULT, cm_mmc_patnr_sub
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_SUB_INV,  CLASS_VALUE,  SYN_NONE,
                           "PatSub", "Pattern Sub", DPY_DEFAULT, cm_mmc_patnr_sub
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_NR_SUB_DELTA, CLASS_DELTA,  12,
                           "PatSub", "Pattern Sub",  DPY_DEFAULT, cm_mmc_patnr_sub
                           );
      _mmc.mmcAddTarget(MMT_PATTERN_NR_SUB_INC,      CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_SUB_DEC,      CLASS_BUTTON, SYN_BUTTON_REPEAT);


      _mmc.mmcAddTargetExO(MMT_PATTERN_LEN,            CLASS_VALUE,  SYN_NONE,
                           "PatLen", "Pattern length", DPY_DEFAULT, fp_patlen
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_LEN_INV,        CLASS_VALUE,  SYN_NONE,
                           "PatLen", "Pattern length", DPY_DEFAULT, fp_patlen
                           );
      _mmc.mmcAddTargetExO(MMT_PATTERN_LEN_DELTA,      CLASS_DELTA,  1,
                           "PatLen", "Pattern length", DPY_DEFAULT, fp_patlen
                           );
      _mmc.mmcAddTarget(MMT_PATTERN_LEN_INC,          CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_PATTERN_LEN_DEC,          CLASS_BUTTON, SYN_BUTTON_REPEAT);


      _mmc.mmcAddTarget(MMT_PATTERN_NR_1,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_2,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_3,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_4,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_5,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_6,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_7,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_8,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_9,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_10,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_11,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_12,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_13,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_14,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_15,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PATTERN_NR_16,             CLASS_BUTTON, SYN_BUTTON_SELECT);

      _mmc.mmcAddTarget(MMT_EDIT_UNDO,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_EDIT_REDO,             CLASS_BUTTON, SYN_BUTTON_CLICK);

      _mmc.mmcAddTarget(MMT_PAT_COPY,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_PASTE,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_CLEAR,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_NEW,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_NEW_SUB,          CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_DELETE,           CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_CLONE,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_CLONE_SUB,        CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_DOUBLE,           CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_DOUBLE_COPY,      CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_REVERSE,          CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_PAT_ROTATE_UP,        CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_PAT_ROTATE_DOWN,      CLASS_BUTTON, SYN_BUTTON_REPEAT);

      _mmc.mmcAddTarget(MMT_PAT_EDIT,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PAT_RECORD,           CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PAT_RECORD_CONTINUE,  CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PAT_PLAY,             CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PAT_TAP_TOGGLE,       CLASS_BUTTON, SYN_BUTTON_SELECT);
      _mmc.mmcAddTarget(MMT_PAT_COLLAPSE_AND_TAP, CLASS_BUTTON, SYN_BUTTON_SELECT);

      _mmc.mmcAddTarget(MMT_CURSOR_PAGEUP,          CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_CURSOR_PAGEDOWN,        CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_CURSOR_TRACK_PREV,      CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_CURSOR_TRACK_NEXT,      CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_CURSOR_TRACK_CTL_PREV,  CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_CURSOR_TRACK_CTL_NEXT,  CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_CURSOR_TRACK_CTL_DELTA, CLASS_DELTA,  0);

      _mmc.mmcAddTarget(MMT_ZOOM_1_32T,  CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_1_32,   CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_1_16T,  CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_1_16,   CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_1_8T,   CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_1_8,    CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_1_4T,   CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_1_4,    CLASS_BUTTON, SYN_BUTTON_CLICK);
      _mmc.mmcAddTarget(MMT_ZOOM_INC,    CLASS_BUTTON, SYN_BUTTON_REPEAT);
      _mmc.mmcAddTarget(MMT_ZOOM_DEC,    CLASS_BUTTON, SYN_BUTTON_REPEAT);

      // // _mmc.mmcAddTarget(MMT_SEQEDIT_SELECT_STEP,     CLASS_BUTTON, SYN_BUTTON_SELECT);
      // // _mmc.mmcAddTarget(MMT_SEQEDIT_TOGGLE_NOTE,     CLASS_BUTTON, SYN_BUTTON_SELECT);
      // // _mmc.mmcAddTarget(MMT_SEQEDIT_CYCLE_VELOCITY,  CLASS_BUTTON, SYN_BUTTON_SELECT);
      // // _mmc.mmcAddTarget(MMT_SEQEDIT_MOVE_STEP,       CLASS_BUTTON, SYN_BUTTON_SELECT);
      // // _mmc.mmcAddTarget(MMT_SEQEDIT_SWAP_STEP,       CLASS_BUTTON, SYN_BUTTON_SELECT);

      // // _mmc.mmcAddTarget(MMT_SEQEDIT_PUSH_ENCODER_MODE,  CLASS_BUTTON, SYN_BUTTON_CLICK);
   }

   // <midi_mmc.png>
   public virtual mmcProxyGet() : MIDIMapContext {
      return null;
   }

   // <midi_mmc.png>
   public virtual mmcHandleEvent(MIDIMapEvent _ev) : boolean {

      // trace "xxx NT: mmcHandleEvent";

      if(mmcIsBindableEvent(_ev))
      {
         MIDIMapContext mmc <= this;

         MIDIMapEvent boundEv <= mmc.mmcGetBindingByEvent(_ev);

         if(null != boundEv)
         {
            String tgtName <= boundEv.bound_target.target_name;
            // trace "xxx tgtName="+tgtName;
            switch(tgtName)
            {
               default:
                  break;

               case MMT_PATTERN_NR:
               case MMT_PATTERN_NR_DELTA:
                  MMTListener.MMTHandleLayerEvent(cm_patnr, _ev, false/*bInv*/);
                  return true;

               case MMT_PATTERN_NR_INV:
                  MMTListener.MMTHandleLayerEvent(cm_patnr, _ev, true/*bInv*/);
                  return true;

               case MMT_PATTERN_NR_INC:
                  MMTListener.MMTHandleLayerInc(cm_patnr);
                  return true;

               case MMT_PATTERN_NR_DEC:
                  MMTListener.MMTHandleLayerDec(cm_patnr);
                  return true;


               case MMT_PATTERN_NR_GROUP:
               case MMT_PATTERN_NR_GROUP_DELTA:
                  MMTListener.MMTHandleLayerEvent(cm_mmc_patnr_group, _ev, false/*bInv*/);
                  return true;

               case MMT_PATTERN_NR_GROUP_INV:
                  MMTListener.MMTHandleLayerEvent(cm_mmc_patnr_group, _ev, true/*bInv*/);
                  return true;

               case MMT_PATTERN_NR_GROUP_INC:
                  MMTListener.MMTHandleLayerInc(cm_mmc_patnr_group);
                  return true;

               case MMT_PATTERN_NR_GROUP_DEC:
                  MMTListener.MMTHandleLayerDec(cm_mmc_patnr_group);
                  return true;


               case MMT_PATTERN_NR_SUB:
               case MMT_PATTERN_NR_SUB_DELTA:
                  MMTListener.MMTHandleLayerEvent(cm_mmc_patnr_sub, _ev, false/*bInv*/);
                  return true;

               case MMT_PATTERN_NR_SUB_INV:
                  MMTListener.MMTHandleLayerEvent(cm_mmc_patnr_sub, _ev, true/*bInv*/);
                  return true;

               case MMT_PATTERN_NR_SUB_INC:
                  MMTListener.MMTHandleLayerInc(cm_mmc_patnr_sub);
                  return true;

               case MMT_PATTERN_NR_SUB_DEC:
                  MMTListener.MMTHandleLayerDec(cm_mmc_patnr_sub);
                  return true;


               case MMT_PATTERN_LEN:
               case MMT_PATTERN_LEN_DELTA:
                  MMTListener.MMTHandleLayerEvent(fp_patlen, _ev, false/*bInv*/);
                  return true;

               case MMT_PATTERN_LEN_INV:
                  MMTListener.MMTHandleLayerEvent(fp_patlen, _ev, true/*bInv*/);
                  return true;

               case MMT_PATTERN_LEN_INC:
                  MMTListener.MMTHandleLayerInc(fp_patlen);
                  return true;

               case MMT_PATTERN_LEN_DEC:
                  MMTListener.MMTHandleLayerDec(fp_patlen);
                  return true;

               case MMT_PATTERN_NR_1:
                  selectPatternGroup(0);
                  return true;

               case MMT_PATTERN_NR_2:
                  selectPatternGroup(1);
                  return true;

               case MMT_PATTERN_NR_3:
                  selectPatternGroup(2);
                  return true;

               case MMT_PATTERN_NR_4:
                  selectPatternGroup(3);
                  return true;

               case MMT_PATTERN_NR_5:
                  selectPatternGroup(4);
                  return true;

               case MMT_PATTERN_NR_6:
                  selectPatternGroup(5);
                  return true;

               case MMT_PATTERN_NR_7:
                  selectPatternGroup(6);
                  return true;

               case MMT_PATTERN_NR_8:
                  selectPatternGroup(7);
                  return true;

               case MMT_PATTERN_NR_9:
                  selectPatternGroup(8);
                  return true;

               case MMT_PATTERN_NR_10:
                  selectPatternGroup(9);
                  return true;

               case MMT_PATTERN_NR_11:
                  selectPatternGroup(10);
                  return true;

               case MMT_PATTERN_NR_12:
                  selectPatternGroup(11);
                  return true;

               case MMT_PATTERN_NR_13:
                  selectPatternGroup(12);
                  return true;

               case MMT_PATTERN_NR_14:
                  selectPatternGroup(13);
                  return true;

               case MMT_PATTERN_NR_15:
                  selectPatternGroup(14);
                  return true;

               case MMT_PATTERN_NR_16:
                  selectPatternGroup(15);
                  return true;

               case MMT_EDIT_UNDO:
                  cmd_edit_undo();
                  return true;

               case MMT_EDIT_REDO:
                  cmd_edit_redo();
                  return true;

               case MMT_PAT_COPY:
                  cmd_pattern_copy(true/*bInvBlock*/);
                  return true;

               case MMT_PAT_PASTE:
                  cmd_pattern_paste();
                  return true;

               case MMT_PAT_CLEAR:
                  cmd_pattern_free(false/*bFreeMeta*/, true/*bUndoBegin*/);
                  return true;

               case MMT_PAT_NEW:
                  cmd_pattern_alloc(false/*bSub*/);
                  return true;

               case MMT_PAT_NEW_SUB:
                  cmd_pattern_alloc(true/*bSub*/);
                  return true;

               case MMT_PAT_DELETE:
                  cmd_pattern_free(true/*bFreeMeta*/, true/*bUndoBegin*/);
                  return true;

               case MMT_PAT_CLONE:
                  cmd_pattern_clone(false/*bSub*/);
                  return true;

               case MMT_PAT_CLONE_SUB:
                  cmd_pattern_clone(true/*bSub*/);
                  return true;

               case MMT_PAT_DOUBLE:
                  cmd_pattern_double(false/*bCopy*/);
                  return true;

               case MMT_PAT_DOUBLE_COPY:
                  cmd_pattern_double(true/*bCopy*/);
                  return true;

               case MMT_PAT_REVERSE:
                  cmd_pattern_reverse();
                  return true;

               case MMT_PAT_ROTATE_UP:
                  cmd_pattern_rotate_up();
                  return true;

               case MMT_PAT_ROTATE_DOWN:
                  cmd_pattern_rotate_down();
                  return true;


               case MMT_PAT_EDIT:
                  pattern_view.nextEditMode();
                  return true;

               case MMT_PAT_RECORD:
                  pattern_view.handleKeyRShift(false/*bCtrl*/);
                  return true;

               case MMT_PAT_RECORD_CONTINUE:
                  pattern_view.setEditMode(NodeTracker.PV_EDIT_STEP);
                  pattern_view.handleKeySpace(false/*bShift*/, true/*bCtrl*/);
                  return true;

               case MMT_PAT_PLAY:
                  pattern_view.handleKeySpace(false/*bShift*/, false/*bCtrl*/);
                  pattern_view.setEditMode(NodeTracker.PV_EDIT_NONE);
                  return true;

               case MMT_PAT_TAP_TOGGLE:
                  cmd_edit_tapmode_toggle();
                  return true;

               case MMT_PAT_COLLAPSE_AND_TAP:
                  cmd_edit_collapse_and_tap();
                  return true;

               case MMT_CURSOR_PAGEUP:
                  pattern_view.pageUpFast();
                  return true;

               case MMT_CURSOR_PAGEDOWN:
                  pattern_view.pageDownFast();
                  return true;

               case MMT_CURSOR_TRACK_PREV:
                  pattern_view.moveCursorToPreviousTrackX(false/*bAlignRight*/);
                  return true;

               case MMT_CURSOR_TRACK_NEXT:
                  pattern_view.moveCursorToNextTrackX();
                  return true;

               case MMT_CURSOR_TRACK_CTL_PREV:
                  pattern_view.moveCursorToPreviousColumnGroup();
                  return true;

               case MMT_CURSOR_TRACK_CTL_NEXT:
                  pattern_view.moveCursorToNextColumnGroup();
                  return true;

               case MMT_CURSOR_TRACK_CTL_DELTA:
                  pattern_view.moveCursorToColumnGroupDelta(_ev.getDeltaValue());
                  return true;

               case MMT_ZOOM_1_32T:
                  cmd_edit_zoom_1_32t();
                  return true;

               case MMT_ZOOM_1_32:
                  cmd_edit_zoom_1_32();
                  return true;

               case MMT_ZOOM_1_16T:
                  cmd_edit_zoom_1_16t();
                  return true;

               case MMT_ZOOM_1_16:
                  cmd_edit_zoom_1_16();
                  return true;

               case MMT_ZOOM_1_8T:
                  cmd_edit_zoom_1_8t();
                  return true;

               case MMT_ZOOM_1_8:
                  cmd_edit_zoom_1_8();
                  return true;

               case MMT_ZOOM_1_4T:
                  cmd_edit_zoom_1_4t();
                  return true;

               case MMT_ZOOM_1_4:
                  cmd_edit_zoom_1_4();
                  return true;

               case MMT_ZOOM_INC:
                  MMTListener.MMTHandleLayerInc(fp_stepresolution);
                  return true;

               case MMT_ZOOM_DEC:
                  MMTListener.MMTHandleLayerDec(fp_stepresolution);
                  return true;

                  // // case MMT_SEQEDIT_SELECT_STEP:
                  // //    // (todo) remove
                  // //    return true;

                  // // case MMT_SEQEDIT_TOGGLE_NOTE:
                  // //    // (todo) remove
                  // //    return true;

                  // // case MMT_SEQEDIT_CYCLE_VELOCITY:
                  // //    // (todo) remove
                  // //    return true;

                  // // case MMT_SEQEDIT_MOVE_STEP:
                  // //    // (todo) remove
                  // //    return true;

                  // // case MMT_SEQEDIT_SWAP_STEP:
                  // //    // (todo) remove
                  // //    return true;

                  // // case MMT_SEQEDIT_PUSH_ENCODER_MODE:
                  // //    // (todo) remove
                  // //    return true;

            } // switch tgtName
         } // if boundEv

         // Fallback to page or global MMC
         boundEv <= mmcGetBindingByEvent(_ev);
         if(null != boundEv)
         {
            return root_form.pg_node.mmcHandleNodeTarget(boundEv.bound_target.target_name);
         }

      } // mmcIsBindableEvent()

      return false;
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray layers) {

      layers.add(bt_view_pattern);
      layers.add(bt_view_instruments);
      layers.add(bt_view_play);
      layers.add(bt_view_arp);
      layers.add(tf_pat_name);

      layers.add(bt_keyjazz);
      layers.add(bt_follow);
      // // layers.add(cb_mmcrec);

      layers.add(cm_patnr);
      layers.add(fp_patlen);
      layers.add(tf_kj_instrument);
      layers.add(cb_write_instrnr);
      layers.add(fp_kj_octave);
      layers.add(fp_kj_velocity);
      layers.add(cb_write_velocity);
      layers.add(cb_addnotecel_vel);
      layers.add(fp_kj_duration);
      layers.add(cb_write_duration);
      layers.add(cb_addnotecel_dur);
      layers.add(fp_kj_offvelocity);
      layers.add(cb_write_offvelocity);
      layers.add(fp_stepresolution);

      switch(ls_view.getCurrentChildNr())
      {
         case VIEW_PATTERN:
            layers.add(pattern_view);

            if(1 == ls_envelope.getCurrentChildNr())
            {
               // envelope_view.addTabCycleOverrides(layers);
               envelope_view.addMMTFocusLayers(layers);
            }
            break;

         case VIEW_INSTRUMENT:
            instrument_view.addMMTFocusLayers(layers);
            break;

         case VIEW_PLAY:
            layers.add(cm_node_class);
            layers.add(cb_node_class_show);
            layers.add(cm_node_class_show_in);
            layers.add(cm_play_mode);
            layers.add(cb_play_change_reset);
            layers.add(fp_play_extclk_gatetime);
            layers.add(cb_play_extclk);
            layers.add(fp_speed_scl_reset);

            layers.add(cm_play_rec_mode);
            layers.add(cb_play_rec_qlast);
            layers.add(cb_play_rec_prev);
            layers.add(cb_play_match_instr);
            layers.add(cb_play_rec_all);
            layers.add(cb_play_rec_spread);
            layers.add(cb_play_rec_bg);

            layers.add(cm_play_rec_sel);
            layers.add(fp_play_offlen_steps);
            layers.add(fp_play_dur_steps);

            layers.add(cm_play_midi_node);
            layers.add(cm_play_audio_node);

            layers.add(cb_play_per_pattern_kj_instr);

            f_autodev.addTabCycleOverrides(layers);
            break;

         case VIEW_ARP:
            layers.add(cb_arp);
            layers.add(tv_arp_notes);
            layers.add(bt_arp_add);
            layers.add(bt_arp_remove);
            layers.add(bt_arp_moveup);
            layers.add(bt_arp_movedown);
            layers.add(cm_arp_baseoct);
            layers.add(cb_arp_reset);
            layers.add(cb_arp_wrap);
            layers.add(cm_arp_latch);
            layers.add(cb_arp_latch_reset);
            layers.add(cb_arp_play_arp_notes);
            layers.add(cb_arp_play_non_arp_notes);
            layers.add(cb_arp_dynalen);
            break;
      }
   }

   // <method.png>
   public method refocusDefault() {

      // trace "xxx NodeTrackerEditor::refocusDefault: b_lock_kbdfocus="+b_lock_kbdfocus;

      if(!NodeEditor.b_lock_kbdfocus)
      {
         switch(ls_view.getCurrentChildNr())
         {
            case VIEW_PATTERN:
               // trace "xxx refocusDefault: PV";
               UI.SetKeyboardFocus(pattern_view);
               break;

            case VIEW_INSTRUMENT:
                // trace "xxx refocusDefault: IV";
               UI.SetKeyboardFocus(instrument_view.tv_instruments);
               break;

            case VIEW_PLAY:
                // trace "xxx refocusDefault: PV";
               UI.SetKeyboardFocus(cm_node_class);
               break;

            case VIEW_ARP:
                // trace "xxx refocusDefault: PV";
               UI.SetKeyboardFocus(tv_arp_notes);
               break;
         }
      }
   }

   public virtual recursiveOnLookAndFeelChanged() {
      Layer::recursiveOnLookAndFeelChanged();

      pattern_view   .recursiveOnLookAndFeelChanged();
      instrument_view.recursiveOnLookAndFeelChanged();
      envelope_view  .recursiveOnLookAndFeelChanged();
   }

   // <method.png>
   protected method showView(int _view, boolean _bEnterLeave) {

      String *msg;

      if(_bEnterLeave)
      {
         handleViewLeave();
      }

      switch(_view)
      {
         default:
         case VIEW_PATTERN:
            ls_view.switchToLayerNr(VIEW_PATTERN);
            bt_view_pattern    .setBackgroundTint(#20c3ff82);  // (todo) move color AppLookAndFeel
            bt_view_instruments.setBackgroundTint(#10000000);
            bt_view_play       .setBackgroundTint(#10000000);
            bt_view_arp        .setBackgroundTint(#10000000);
            SysEx.SetRemoteEventListener(this);
            msg <= "Show Pattern view";
            break;

         case VIEW_INSTRUMENT:
            ls_view.switchToLayerNr(VIEW_INSTRUMENT);
            bt_view_pattern    .setBackgroundTint(#10000000);
            bt_view_instruments.setBackgroundTint(#20c3ff82);
            bt_view_play       .setBackgroundTint(#10000000);
            bt_view_arp        .setBackgroundTint(#10000000);
            SysEx.SetRemoteEventListener(instrument_view);
            msg <= "Show Instrument view";
            break;

         case VIEW_PLAY:
            ls_view.switchToLayerNr(VIEW_PLAY);
            bt_view_pattern    .setBackgroundTint(#10000000);
            bt_view_instruments.setBackgroundTint(#10000000);
            bt_view_play       .setBackgroundTint(#20c3ff82);
            bt_view_arp        .setBackgroundTint(#10000000);
            SysEx.SetRemoteEventListener(null);
            msg <= "Show Play view";
            break;

         case VIEW_ARP:
            ls_view.switchToLayerNr(VIEW_ARP);
            bt_view_pattern    .setBackgroundTint(#10000000);
            bt_view_instruments.setBackgroundTint(#10000000);
            bt_view_play       .setBackgroundTint(#10000000);
            bt_view_arp        .setBackgroundTint(#20c3ff82);
            SysEx.SetRemoteEventListener(null);
            msg <= "Show Arp view";
            break;
      }

      if(_bEnterLeave)
      {
         handleViewEnter();
         redraw();

         Global.Print(msg);
      }
   }

   // <method_get.png>
   public method isPatternViewActive() : boolean {
      return (VIEW_PATTERN == ls_view.getCurrentChildNr());
   }

   // <method.png>
   public method toggleViews() {
      // trace "[dbg] NT:toggleViews";

      if(VIEW_PATTERN != ls_view.getCurrentChildNr())
      {
         showView(VIEW_PATTERN, true/*bEnterLeave*/);
      }
      else
      {
         showView(VIEW_INSTRUMENT, true/*bEnterLeave*/);
      }
   }

   // <method.png>
   public method togglePlayView() {

      if(VIEW_PLAY == ls_view.getCurrentChildNr())
      {
         showView(VIEW_ARP, true/*bEnterLeave*/);
      }
      else if(VIEW_PATTERN == ls_view.getCurrentChildNr())
      {
         showView(VIEW_PLAY, true/*bEnterLeave*/);
      }
      else
      {
         showView(VIEW_PATTERN, true/*bEnterLeave*/);
      }
   }

   // <method.png>
   public method toggleEnvelopeView(boolean _bForce) : boolean {

      boolean bEnable = (maybe == _bForce) ? (ls_envelope.getCurrentChildNr() ^ 1) : _bForce;

      if(bEnable)
      {
         // Show
         pn_pattern_view.removeChildLayer(pattern_view);
         ls_envelope.switchToLayerNr(1);
         tracker_node.b_envelope_view_visible = true;
         sp_envelope_view.setLeft(pattern_view);
         sp_envelope_view.setRight(envelope_view);
         ls_envelope.switchToLayerNr(tracker_node.b_envelope_view_visible ? 1 : 0);
         // trace "xxx toggleEnvelopeView: add envelope view overlay";
         root_form.addOverlay(envelope_view.data);
         UI.SetKeyboardFocus(envelope_view.data);
      }
      else
      {
         // Hide
         sp_envelope_view.setLeft(null);
         sp_envelope_view.setRight(null);
         pn_pattern_view.addLayer(pattern_view, Layout.CENTER);
         ls_envelope.switchToLayerNr(0);
         tracker_node.b_envelope_view_visible = false;
         // trace "xxx toggleEnvelopeView: remove envelope view overlay";
         root_form.removeOverlay(envelope_view.data);
         UI.SetKeyboardFocus(pattern_view);
      }

      if((1 == ls_envelope.getCurrentChildNr()) && (1 == ls_piano.getCurrentChildNr()))
         togglePianoWidget();

      relayout();
      pattern_view.renderAndRedrawAll();

      return bEnable;
   }

   // <method_handle.png>
   protected method handleViewEnter() {

      keyJazzReselectInstrument(); // update instr.name

      int cView = ls_view.getCurrentChildNr();

      switch(cView)
      {
         case VIEW_PATTERN:
            if(UI.b_fbo)
            {
               root_form.addOverlay(pattern_view); // for equalizers, mute X, track names, highlighting

               if(1 == ls_envelope.getCurrentChildNr())
               {
                  // trace "xxx handleViewEnter: add envelope view overlay";
                  root_form.addOverlay(envelope_view.data);
               }
            }
            break;

         case VIEW_INSTRUMENT:
            // // instrument_view.handleViewEnter();
            instrument_view.editSelectedInstrument();
            // // instrument_view.editSelectedParameter();  // [04Feb2022] already handled via selectKeyJazzInstr() => trySelectParamForCurrentCel()
            break;

         case VIEW_ARP:
            if(-1 == tm_arp_notes.getCursorIndex())
            {
               tv_arp_notes.moveCursorToFirstRow();
            }
            break;
      }

      refocusDefault();
   }

   // <method_handle.png>
   protected method handleViewLeave() {

      SysEx.SetRemoteEventListener(null);

      if(VIEW_PATTERN == ls_view.getCurrentChildNr())
      {
         if(UI.b_fbo)
         {
            root_form.removeOverlay(pattern_view);
            // trace "xxx handleViewLeave: remove envelope view overlay";
            root_form.removeOverlay(envelope_view.data);
         }
      }
      else if(VIEW_INSTRUMENT == ls_view.getCurrentChildNr())
      {
         instrument_view.handleViewLeave();
      }
   }

   // <method.png>
   public method togglePianoWidget() {

      if(0 == ls_piano.getCurrentChildNr())
      {
         // Show
         tracker_node.b_ui_piano = true;
         ls_piano.switchToLayerNr(1);
         Global.Print("Show piano widget");
         pattern_view.ta_piano_widget.reschedule();
      }
      else
      {
         // Hide
         tracker_node.b_ui_piano = false;
         ls_piano.switchToLayerNr(0);
         Global.Print("Hide piano widget");
         pattern_view.ta_piano_widget.cancel();
      }

      if((1 == ls_envelope.getCurrentChildNr()) && (1 == ls_piano.getCurrentChildNr()))
         toggleEnvelopeView(false/*force hide*/);
      else
         ls_envelope.switchToLayerNr(0);  // already selected but fixes layout issue

      relayout();
      redraw();

      UI.SetKeyboardFocus(pattern_view);
   }

   // <ui_update.png>
   public method updatePianoWidgetEnable(boolean _bRelayout) {
      if(tracker_node.b_ui_piano ^ ls_piano.getCurrentChildNr())
      {
         ls_piano.switchToLayerNr(tracker_node.b_ui_piano);
         if(_bRelayout)
         {
            relayout();
            redraw();
         }
      }
   }

   // <ui_update.png>
   public method updatePianoWidgetPressedNotes(IntArray _activeNotes) {
      piano.setPressedNotesFromActiveNoteList(_activeNotes);
   }

   // // // <method_get.png>
   // // public method isMMCRecEnabled() : boolean {
   // //    return cb_mmcrec.isSelected();
   // // }

   // // // <method_set.png>
   // // public method setEnableMMCRec(boolean _bEnable) {
   // //    cb_mmcrec.setSelected(_bEnable);
   // //    cb_mmcrec.redraw();
   // // }


   // <ui_update.png>
   protected method updateModeButton(NT_ModeButton _bt, boolean _bEnable) {
      if(_bEnable ^ _bt.b_last_state)
      {
         _bt.b_last_state = _bEnable;

         int bg;
         int fg;

         if(_bEnable)
         {
            bg = app_lnf.getColor(AppLookAndFeel.COLOR_NT_MODE_ENABLE_BG);
            fg = app_lnf.getColor(AppLookAndFeel.COLOR_NT_MODE_ENABLE_FG);
         }
         else
         {
            bg = app_lnf.getColor(AppLookAndFeel.COLOR_NT_MODE_DISABLE_BG);
            fg = app_lnf.getColor(AppLookAndFeel.COLOR_NT_MODE_DISABLE_FG);
         }

         bg = lnf.getTintedColor(LookAndFeel.COLOR_WINDOW_BG, bg);
         fg = lnf.getTintedColor(LookAndFeel.COLOR_WINDOW_BG, fg);

         _bt.setBackgroundColor(bg);
         _bt.setForegroundColor(fg);

         _bt.redraw();
      }
   }

   // <ui_update.png>
   public method updateModeWidgets() {

      updateModeButton(bt_mode_edit,          (tracker_node.pv_edit_mode != NodeTracker.PV_EDIT_NONE));
      updateModeButton(bt_mode_rtrecord,      tracker_node.b_rt_record);
      updateModeButton(bt_mode_relshift,      !pattern_view.b_insdel_shiftall_mode);
      updateModeButton(bt_mode_autoscroll,    STConfig.b_node_tracker_autoscroll);
      updateModeButton(bt_mode_wraparound,    STConfig.b_node_tracker_wraparound);
      updateModeButton(bt_mode_bookmark,      !STConfig.b_node_tracker_swapstopbookmark);
      updateModeButton(bt_mode_playstepreset, replay.b_playstep_reset);
      updateModeButton(bt_mode_swaplshift,    STConfig.b_node_tracker_swap_lshift);
      updateModeButton(bt_mode_kjlock,        pmcb_track_lockkeyjazz.isSelected());
      updateModeButton(bt_mode_precount,      STConfig.b_node_tracker_precount);

      updateModeButton(bt_mode_freerun,         replay.b_freerun_loop);
      updateModeButton(bt_mode_ignorearr,       /*STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay || */tracker_node.b_node_ignore_seek_prgchg_mute);
      updateModeButton(bt_mode_selectplay,      STConfig.b_node_tracker_selectandplay);
      updateModeButton(bt_mode_followarr,       STConfig.b_node_tracker_edit_pattern_follows_replay_pattern);
      updateModeButton(bt_mode_chordadv,        STConfig.b_node_tracker_advance_allnotesreleased);
      updateModeButton(bt_mode_chordclear,      tracker_node.getEnableChordClearStep());
      updateModeButton(bt_mode_tapmode,         tracker_node.b_tap_mode);
      updateModeButton(bt_mode_reclatency,      STConfig.b_node_tracker_rec_latency);
      updateModeButton(bt_mode_kjnoteoff,       STConfig.b_node_tracker_keyjazz_manual_noteoff);
      updateModeButton(bt_mode_recusrctlnoteon, STConfig.b_node_tracker_recordusrctlnoteon);

      updateModeButton(bt_mode_timing,            tracker_node.b_ui_timing_view);
      updateModeButton(bt_mode_timinglock,        tracker_node.b_ui_timing_view_move_lock);
      updateModeButton(bt_mode_recnoteoff,        STConfig.b_node_tracker_recordnoteoff);
      updateModeButton(bt_mode_recnoteoff_replay, STConfig.b_node_tracker_recordnoteoff_replay);
      updateModeButton(bt_mode_recquant,          STConfig.b_node_tracker_recordquantize);
      updateModeButton(bt_mode_recdur,            STConfig.b_node_tracker_recordnoteoff_dur);
      updateModeButton(bt_mode_envelope,          tracker_node.b_envelope_view_visible);
      updateModeButton(bt_mode_piano,             tracker_node.b_ui_piano);
      updateModeButton(bt_mode_kj,                bt_keyjazz.isSelected());
      updateModeButton(bt_mode_metronome,         STConfig.b_midi_metronome);
   }

   // <method_get.png>
   public method keyJazzIsEnabled() : boolean {
      return bt_keyjazz.isSelected();
   }

   // <method.png>
   public method keyJazzOctaveDown() {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         if(track.keyjazz_octave > 0)
         {
            track.keyjazz_octave -= 12;

            fp_kj_octave.setValue(track.keyjazz_octave / 12);
         }

         Global.Print("Set keyjazz note transpose to "+track.keyjazz_octave+" ("+MNT_PatternView.midi_notes.get(track.keyjazz_octave)+" .. "+MNT_PatternView.midi_notes.get(track.keyjazz_octave+31)+")");
      }
      else
      {
         Global.Error("keyJazzOctaveDown: no track");
      }
   }

   // <method.png>
   public method keyJazzOctaveUp() {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         if(track.keyjazz_octave < 96)
         {
            track.keyjazz_octave += 12;

            fp_kj_octave.setValue(track.keyjazz_octave / 12);
         }

         Global.Print("Set keyjazz note transpose to "+track.keyjazz_octave+" ("+MNT_PatternView.midi_notes.get(track.keyjazz_octave)+" .. "+MNT_PatternView.midi_notes.get(track.keyjazz_octave+31)+")");
      }
      else
      {
         Global.Error("keyJazzOctaveUp: no track");
      }
   }

   // <method_set.png>
   public method keyJazzSetOctave(int _oct, boolean _bQuiet) {
      // (note) _oct in note transpose steps, e.g. oct=12 => 1 octave up
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         track.keyjazz_octave = _oct;

         if(!_bQuiet)
            Global.Print("Set keyjazz note transpose to "+track.keyjazz_octave+" ("+MNT_PatternView.midi_notes.get(track.keyjazz_octave)+" .. "+MNT_PatternView.midi_notes.get(track.keyjazz_octave+31)+")");
      }
      else
      {
         Global.Error("keyJazzSetOctave: no track");
      }
   }

   // <method_get.png>
   public method keyJazzGetOctave() : int {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         return track.keyjazz_octave;
      }
      return 0;
   }

   // <method_set.png>
   public method keyJazzSetNoteOnVelocity(float _vel, boolean _bQuiet) {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         track.keyjazz_on_velocity = _vel;
         if(!_bQuiet)
            Global.Print("Set keyjazz velocity to "+track.keyjazz_on_velocity+".");
      }
      else
      {
         tracker_node.write_noteon_velocity = _vel;
      }
   }

   // <method_set.png>
   public method keyJazzSetNoteOffVelocity(float _vel, boolean _bQuiet) {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         track.keyjazz_off_velocity = _vel;
         if(!_bQuiet)
            Global.Print("Set keyjazz noteoff velocity to "+track.keyjazz_off_velocity+".");
      }
      else
      {
         tracker_node.write_noteoff_velocity = _vel;
      }
   }

   // <method_set.png>
   public method keyJazzSetDuration(int _dur, boolean _bQuiet) {
      // (todo) is this really used ?
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         track.keyjazz_duration = _dur;
         if(!_bQuiet)
            Global.Print("keyJazzSetDuration: Set keyjazz note duration to "+_dur+".");
      }
      else
      {
         tracker_node.write_duration = _dur;
      }
   }

   // <method.png>
   public method keyJazzSelectInstrument(int _nr, boolean _bMakeVisible, boolean _bQuiet) {
      trace "[trc] keyJazzSelectInstrument("+_nr+")";

      // (note) if bMakeVisible, scroll instrument list/table. This should be false if the instr. is selected by clicking a table row

      NT_Track track <= pattern_view.getCurrentTrack();

      if(null != track)
      {
         if(_nr != track.keyjazz_instr_nr)
         {
            if(!replay.b_playing)
            {
               keyJazzAllInstrumentVoicesOff();
            }
         }

         if(_nr < 0) _nr = 0;
         else if(_nr >= 62) _nr=61;

         NT_Instrument instr <= tracker_node.getInstrument(_nr);
         track.keyjazzSetInstrumentNr(_nr);

         if(tracker_node.b_per_pattern_kj_instr)
         {
            NT_TrackPattern trackPat <= track.getPattern(tracker_node.nodeGetCurrentEditPatternNr());
            if(null != trackPat)
            {
               trace "xxx keyJazzSelectInstrument: update trackPat from "+trackPat.keyjazz_instr_nr+" to "+_nr;
               trackPat.keyjazz_instr_nr = _nr;
            }
         }

         String name = Utils.MapLetterNr(_nr) + " (";
         if(null != instr)
         {
            name.append(instr.name);
            // // keyjazz_instr.handleKeyJazzSelection();
         }
         else
         {
            name.append("-none-");
         }
         name.append(")");

         updateKJInstrumentName(name, _bQuiet);

         if(!_bQuiet)
            Global.Print("Selected keyjazz instrument "+Utils.MapLetterNr(track.keyjazz_instr_nr)+".");
      }
      else
      {
         Global.Error("keyJazzSelectInstrument: no track");
      }

      instrument_view.queueSelectKeyJazzInstr(_bMakeVisible);
   }

   // <method.png>
   public method keyJazzReselectInstrument() {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         // updates UI in case the name has changed
         keyJazzSelectInstrument(track.keyjazz_instr_nr, false/*bMakeVisible*/, true/*bQuiet*/);
      }
   }

   // <method.png>
   public method keyJazzSelectPreviousInstrument() {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         int ins = track.keyjazz_instr_nr;
         if(ins > 0)
         {
            ins--;
         }
         else
         {
            // Wrap-around
            ins = 61; // 'z'
         }
         keyJazzSelectInstrument(ins, true/*bMakeVisible*/, false/*bQuiet*/);
      }
      else
      {
         Global.Error("keyJazzSelectPreviousInstrument: no track");
      }
   }

   // <method.png>
   public method keyJazzSelectNextInstrument() {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         int ins = track.keyjazz_instr_nr;
         if(ins < 61)
         {
            ins++;
         }
         else
         {
            // Wrap-around
            ins = 0; // '0'
         }
         keyJazzSelectInstrument(ins, true/*bMakeVisible*/, false/*bQuiet*/);
      }
      else
      {
         Global.Error("keyJazzSelectPreviousInstrument: no track");
      }
   }

   // <replay.png>
   public =replay= method keyJazzAllInstrumentVoicesOff() {
      NT_Instrument instr <= tracker_node.keyJazzGetInstrument();
      if(null != instr)
      {
         // called when switching instruments during keyjazz to prevent hanging notes

         // (todo) implement me

         ////KeyJazz.AllNotesOff();
      }
   }

   // <method.png>
   public method isPatternEditable(String _op) : boolean {
      explain "Check whether the patternview/orderlist is editable and print an error message if it's not";

      if(pattern_view.isEditable())
      {
         return true;
      }
      else
      {
         Global.Error(_op+" requires pattern to be editable");
      }
   }

   // <method.png>
   public method notPlayingAndPatternEditable(String _op) : boolean {
      if(Global.NotPlaying(_op))
      {
         return isPatternEditable(_op);
      }
      return true;
   }

   // <ui_update.png>
   public method updateSongWidgets() {
      fp_stepresolution .setValue(pattern_view.step_resolution);
   }

   // <ui_update.png>
   public method updateUndoModeSingleTransaction() {
      pmcb_edit_undomode.setSelected(STConfig.b_node_tracker_undo_record_single_transaction);
   }

   // <ui_update.png>
   public method updateUndoDebug() {
      pmcb_edit_undodebug.setSelected(STConfig.b_node_tracker_undo_debug);
   }

   // <ui_update.png>
   public method updatePatternEditMode() {
      pmcb_edit_patternedit.setSelected(NodeTracker.PV_EDIT_NONE != tracker_node.pv_edit_mode);
   }

   // <ui_update.png>
   public method updateShiftMode() {
      pmcb_edit_shiftall.setSelected(! pattern_view.b_insdel_shiftall_mode);
   }

   // <ui_update.png>
   public method updateAutoScroll() {
      pmcb_cursor_autoscroll.setSelected(STConfig.b_node_tracker_autoscroll);
   }

   // <ui_update.png>
   public method updateAdvanceAllNotesReleased() {
      pmcb_edit_advanceallnotesreleased.setSelected(STConfig.b_node_tracker_advance_allnotesreleased);
   }

   // <ui_update.png>
   public method updateChordClearStep() {
      pmcb_edit_chordclearstep.setSelected(tracker_node.getEnableChordClearStep());
   }

   // <ui_update.png>
   public method updateTimingViewMoveLock() {
      pmcb_edit_timingviewmovelock.setSelected(tracker_node.b_ui_timing_view_move_lock);
   }

   // <ui_update.png>
   public method updateSwapLShift() {
      pmcb_edit_swaplshift.setSelected(STConfig.b_node_tracker_swap_lshift);
   }

   // <ui_update.png>
   public method updateShowCtlInfo() {
      pmcb_edit_showctlinfo.setSelected(STConfig.b_show_ctl_info);
   }

   // <ui_update.png>
   public method updateFrRecToKJInsPlay() {
      pmcb_edit_frrectokjinsplay.setSelected(tracker_node.b_echo_frame_rec_to_play);
   }

   // <ui_update.png>
   public method updateWrapAround() {
      pmcb_cursor_wraparound.setSelected(STConfig.b_node_tracker_wraparound);
   }

   // <ui_update.png>
   public method updateSwapStopBookmark() {
      pmcb_replay_invertspace.setSelected(!STConfig.b_node_tracker_swapstopbookmark);
   }

   // <ui_update.png>
   public method updatePlayStepReset() {
      pmcb_replay_playstepreset.setSelected(replay.b_playstep_reset);
   }

   // <ui_update.png>
   public method updateFreerunLoop() {
      pmcb_replay_freerun.setSelected(replay.b_freerun_loop);
   }

   // // // <ui_update.png>
   // // public method updateMMCRecAutoReset() {
   // //    pmcb_replay_mmcrec_autoreset.setSelected(STConfig.b_node_tracker_midi_mmcrec_autoreset);
   // // }

   // <ui_update.png>
   public method updateShowTrackNames() {
      pmcb_track_shownames.setSelected(STConfig.b_node_tracker_show_track_names);
   }

   // <ui_update.png>
   public method updateShowTrackEQ() {
      pmcb_track_showeq.setSelected(STConfig.b_node_tracker_draweq);
   }

   // <ui_update.png>
   public method updatePatternDoubleCenter() {
      pmcb_cursor_doublecenter.setSelected(UI.IsHiDPI()
                                           ? STConfig.b_node_tracker_doublecenter_hidpi
                                           : STConfig.b_node_tracker_doublecenter_lodpi
                                           );
   }

   // <ui_update.png>
   public method updatePatternDoubleWidth() {
      pmcb_cursor_doublewidth.setSelected(UI.IsHiDPI()
                                          ? STConfig.b_node_tracker_doublewidth_hidpi
                                          : STConfig.b_node_tracker_doublewidth_lodpi
                                          );
   }

   // <ui_update.png>
   public method updatePatternDoubleHeight() {
      pmcb_cursor_doubleheight.setSelected(UI.IsHiDPI()
                                           ? STConfig.b_node_tracker_doubleheight_hidpi
                                           : STConfig.b_node_tracker_doubleheight_lodpi
                                           );
   }

   // <ui_update.png>
   public method updatePatternTimingAutoDoubleWidth() {
      pmcb_cursor_timing_autodoublewidth.setSelected(STConfig.b_node_tracker_timing_view_autodouble_width);
   }

   // <ui_update.png>
   public method updatePatternTimingAutoDoubleHeight() {
      pmcb_cursor_timing_autodoubleheight.setSelected(STConfig.b_node_tracker_timing_view_autodouble_height);
   }

   // <ui_update.png>
   public method updatePatternDecimalOffset() {
      pmcb_cursor_decimalpatoff.setSelected(STConfig.b_node_tracker_decimal_patternoffset);
   }

   // <ui_update.png>
   public method updatePatternShiftOffset() {
      pmcb_cursor_shiftpatoff.setSelected(STConfig.b_node_tracker_shift_patternoffset);
   }

   // <ui_update.png>
   public method updateLockKeyJazz() {
      boolean bEnable = false;
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         bEnable = track.isKeyJazzLocked();
      }
      pmcb_track_lockkeyjazz.setSelected(bEnable);
   }

   // <ui_update.png>
   public method updateRecordPre() {
      pmcb_pattern_recordpre.setSelected(STConfig.b_node_tracker_precount);
   }

   // <ui_update.png>
   public method updateRecordNoteOff() {
      pmcb_pattern_recordnoteoff.setSelected(STConfig.b_node_tracker_recordnoteoff);
   }

   // <ui_update.png>
   public method updateRecordNoteOffReplay() {
      pmcb_pattern_recordnoteoff_replay.setSelected(STConfig.b_node_tracker_recordnoteoff_replay);
   }

   // <ui_update.png>
   public method updateRecordNoteOffDur() {
      pmcb_pattern_recordnoteoff_dur.setSelected(STConfig.b_node_tracker_recordnoteoff_dur);
   }

   // <ui_update.png>
   public method updateRecordQuantize() {
      pmcb_pattern_recordquantize.setSelected(STConfig.b_node_tracker_recordquantize);
   }

   // <ui_update.png>
   public method updateRecordUsrCtlNoteOn() {
      pmcb_pattern_recusrctlnoteon.setSelected(STConfig.b_node_tracker_recordusrctlnoteon);
   }

   // <ui_update.png>
   public method updateRecLatency() {
      pmcb_pattern_reclatency.setSelected(STConfig.b_node_tracker_rec_latency);
   }

   // <ui_update.png>
   public method updateKeyJazzManualNoteOff() {
      pmcb_instrument_keyjazzmanualnoteoff.setSelected(STConfig.b_node_tracker_keyjazz_manual_noteoff);
   }

   // <ui_update.png>
   public method updateKJInstrumentName(String _name, boolean _bQuiet) {
      if(null != _name)
      {
         tf_kj_instrument.setText(_name);
      }
      else
      {
         int instrNr = tracker_node.keyJazzGetInstrumentNr();
         keyJazzSelectInstrument(instrNr, true/*bMakeVisible*/, _bQuiet);
      }
   }

   // <ui_update.png>
   public method updateKeyJazzWidgets() {
      cb_write_instrnr    .setSelected(tracker_node.b_write_instrnr);
      cb_write_velocity   .setSelected(tracker_node.b_write_noteon_velocity);
      cb_write_offvelocity.setSelected(tracker_node.b_write_noteoff_velocity);
      cb_write_duration   .setSelected(tracker_node.b_write_duration);

      NT_Track track <= pattern_view.getCurrentTrack();

      if(null != track)
      {
         fp_kj_velocity    .setValue(track.keyjazz_on_velocity);
         fp_kj_offvelocity .setValue(track.keyjazz_off_velocity);
         fp_kj_duration    .setValue(track.keyjazz_duration);
         fp_kj_octave      .setValue(track.keyjazz_octave / 12);
      }
      else
      {
         fp_kj_velocity    .setValue(tracker_node.write_noteon_velocity);
         fp_kj_offvelocity .setValue(tracker_node.write_noteoff_velocity);
         fp_kj_duration    .setValue(tracker_node.write_duration);
      }
   }

   // <ui_update.png>
   public method updateBlockModeName() {
      pmb_block_mode.setCaption("Current blockmode: "+pattern_view.getBlockModeName());
   }

   // <ui_update.png>
   public method updateStepResolution(int _res) {

      fp_stepresolution.setMaxValueLimit(current_song.ppq*4*8);

      fp_stepresolution.setValue(_res);

      fp_stepresolution.setNominalValues(0, current_song.ppq / 4);

      updateNoteIcon(true/*bRestartAnim*/);
   }

   // <method.png>
   protected method updateNoteIcon(boolean bRestartAnim) {
      // Select note icon
      float sr = fp_stepresolution.getValue();
      float nl = sr / (4 * current_song.ppq);

      float trip8Len = current_song.ppq / 3.0;

      if(bRestartAnim)
      {
         noteicon_mode = STConfig.b_node_tracker_zoomicon_prefer_text ? 1 : 0;
      }

      PNGIcon *ico;
      boolean bExact;
      boolean bDot;
      boolean bTrip;
      String *cap;

      if(sr >= (64*trip8Len))
      {
         ico <= UI.GetIcon("nt_note_8");
         bExact = (8 == nl);
         bDot = (8*1.5 == nl);
         bTrip = ((64*trip8Len) == sr);
         cap <= ("8");
      }
      else if(sr >= (32*trip8Len))
      {
         ico <= UI.GetIcon("nt_note_4");
         bExact = (4 == nl);
         bDot = (4*1.5 == nl);
         bTrip = ((32*trip8Len) == sr);
         cap <= ("4");
      }
      else if(sr >= (16*trip8Len))
      {
         ico <= UI.GetIcon("nt_note_2");
         bExact = (2 == nl);
         bDot = (2*1.5 == nl);
         bTrip = ((16*trip8Len) == sr);
         cap <= ("2");
      }
      else if(sr >= (8*trip8Len))
      {
         ico <= UI.GetIcon("nt_note_1");
         bExact = (1 == nl);
         bDot = (1*1.5 == nl);
         bTrip = ((8*trip8Len) == sr);
         cap <= ("1");
      }
      else if(sr >= (4*trip8Len)) //((1.0/2) - (0.5 * (1.0/2 - 1.0/4))) )
      {
         ico <= UI.GetIcon("nt_note_1_2");
         bExact = (1.0/2 == nl);
         bDot = (((1.0/2)*1.5) == nl);
         bTrip = ((4*trip8Len) == sr);
         cap <= ("1/2");
      }
      else if(sr >= (2*trip8Len)) // ((1.0/4) - (0.5 * (1.0/4 - 1.0/8))) )
      {
         ico <= UI.GetIcon("nt_note_1_4");
         bExact = (1.0/4 == nl);
         bDot = (((1.0/4)*1.5) == nl);
         bTrip = ((2*trip8Len) == sr);
         cap <= ("1/4");
      }
      else if(sr >= (1*trip8Len)) // ((1.0/8) - (0.5 * (1.0/8 - 1.0/16))) )
      {
         ico <= UI.GetIcon("nt_note_1_8");
         bExact = (1.0/8 == nl);
         bDot = (((1.0/8)*1.5) == nl);
         bTrip = ((1*trip8Len) == sr);
         cap <= ("1/8");
      }
      else if(sr >= (0.5*trip8Len)) // ((1.0/16) - (0.5 * (1.0/16 - 1.0/32))) )
      {
         ico <= UI.GetIcon("nt_note_1_16");
         bExact = (1.0/16 == nl);
         bDot = (((1.0/16)*1.5) == nl);
         bTrip = ((0.5*trip8Len) == sr);
         cap <= ("1/16");
      }
      else if(sr >= (0.25*trip8Len)) // ((1.0/32) - (0.5 * (1.0/32 - 1.0/64))) )
      {
         ico <= UI.GetIcon("nt_note_1_32");
         bExact = (1.0/32 == nl);
         bDot = (((1.0/32)*1.5) == nl);
         bTrip = ((0.25*trip8Len) == sr);
         cap <= ("1/32");
      }
      else if(sr >= (0.125*trip8Len)) // ((1.0/64) - (0.5 * (1.0/64 - 1.0/128))) )
      {
         ico <= UI.GetIcon("nt_note_1_64");
         bExact = (1.0/64 == nl);
         bDot = (((1.0/64)*1.5) == nl);
         bTrip = ((0.125*trip8Len) == sr);
         cap <= ("1/64");
      }
      else if(sr >= (0.0625*trip8Len)) // ((1.0/128) - (0.5 * (1.0/128 - 1.0/256))) )
      {
         ico <= UI.GetIcon("nt_note_1_128");
         bExact = (1.0/128 == nl);
         bDot = (((1.0/128)*1.5) == nl);
         bTrip = ((0.0625*trip8Len) == sr);
         cap <= ("1/128");
      }
      else if(sr > (0.031250*trip8Len))
      {
         ico <= UI.GetIcon("nt_note_1_256");
         bExact = (1.0/256 == nl);
         bDot = (((1.0/256)*1.5) == nl);
         bTrip = ((0.03125*trip8Len) == sr);
         cap <= ("1/256");
      }
      else if(2 == sr)
      {
         ico <= UI.GetIcon("nt_note_1_256");
         bExact = false;
         bDot = false;
         bTrip = false;
         cap <= ("1/"+(current_song.ppq*2));
      }
      else if(sr > (0.02343750000000000000*trip8Len))
      {
         ico <= UI.GetIcon("nt_note_1_256");
         bExact = (1.0/256 == nl);
         bDot = (((1.0/256)*1.5) == nl);
         bTrip = ((0.03125*trip8Len) == sr);
         cap <= ("1/384");
      }
      else // if(1 == sr)
      {
         ico <= UI.GetIcon("nt_note_1_256");
         bExact = (1 == sr);
         bDot = false;
         bTrip = false;
         cap <= ("1/"+(current_song.ppq*4));
      }

      // make getIconWidth()/getIconHeight() return actual image size
      ico.setView(0,0,0,0);

      ico.setView(20, 0, 60, ico.getIconHeight());

      notelabel_caption = cap;

      if(bExact)
      {
         lb_zoomicon.setBackgroundColor(lnfGetTintedColor(LookAndFeel.COLOR_WINDOW_BG, #0400ff00));
      }
      else if(bDot)
      {
         lb_zoomicon.setBackgroundColor(lnfGetTintedColor(LookAndFeel.COLOR_WINDOW_BG, #10ffff00));
         if(nl > ((1.0/64) - (0.5 * (1.0/64 - 1.0/128))) )
         {
            notelabel_caption.append("d");
         }
      }
      else if(bTrip)
      {
         lb_zoomicon.setBackgroundColor(lnfGetTintedColor(LookAndFeel.COLOR_WINDOW_BG, #10ff6f00));
         notelabel_caption.append("t");
      }
      else
      {
         lb_zoomicon.setBackgroundColor(lnfGetTintedColor(LookAndFeel.COLOR_WINDOW_BG, #10ff0000));
         if(nl > ((1.0/64) - (0.5 * (1.0/64 - 1.0/128))) )
         {
            notelabel_caption = "~" + notelabel_caption;
         }
      }

      lb_zoomicon.setToolTipCaption(notelabel_caption);

      if((1 != noteicon_mode) || !STConfig.b_node_tracker_zoomicon_anim)
      {
         lb_zoomicon.setIcon(ico);
         float icoSclY = 50.0 / ico.getIconHeight();
         if(UI.font_scaling > 1.0)
            icoSclY *= 1.0 + (UI.font_scaling - 1.0)*0.5;
         lb_zoomicon.setIconScaleY(icoSclY);
         lb_zoomicon.setCaption(null);
      }
      else
      {
         lb_zoomicon.setIcon(null);
         lb_zoomicon.setCaption(notelabel_caption);
      }

      lb_zoomicon.redraw();

      Global.Print("Zoom: "+cap+" note"+((nl > 1)?"s":"")+" per step "+(bExact ? "" : bTrip ? "(triplet)" : bDot ? "(dotted)" : "(approximately)"));

      if(STConfig.b_node_tracker_zoomicon_anim)
      {
         if(2 != noteicon_mode)
         {
            noteicon_mode++;
            ta_notelabel.cancel();
            ta_notelabel.scheduleTicks((1 == noteicon_mode) ? 1500 : 750);
         }
      }
   }

   // <ui_update.png>
   protected method updatePatNr() {

      local StringArray patNrOptions;
      local IntArray patNrColors;
      Node.CalcPatNrOptions(tracker_node, null/*retOptionsShort*/, patNrOptions, patNrColors);
      cm_patnr.setOptionsLong(patNrOptions);
      cm_patnr.setOptionBGColors(patNrColors);

      int cPatNr = tracker_node.nodeGetCurrentEditPatternNr();
      cm_patnr.setSelectedOption(cPatNr);
      cm_patnr.redraw();

      // Update invisible widgets (for Push)
      cm_mmc_patnr_group.setSelectedOption(cPatNr>>2);
      cm_mmc_patnr_sub.setSelectedOption(cPatNr&3);
   }

   // <ui_update.png>
   public method updatePatLen() {
      int v = tracker_node.getCurrentEditMetaPatternLength() / pattern_view.step_resolution;
      // // trace "xxx updatePatLen: tracker_node.getCurrentEditMetaPatternLength()="+tracker_node.getCurrentEditMetaPatternLength();

      fp_patlen.setNominalValues(0, 128 * ((current_song.ppq/4.0) / pattern_view.step_resolution));

      fp_patlen.setValue(v);
      fp_patlen.redraw();
   }

   // <ui_update.png>
   public method updatePatName() {
      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      if(null != mpat)
      {
         tf_pat_name.setText(mpat.pat_name);
         tf_pat_name.setEditable(true);
      }
      else
      {
         tf_pat_name.setText("");
         tf_pat_name.setEditable(false);
      }
   }


   // <ui_update.png>
   protected method updateExtClkGateTimeSteps() {
      fp_play_extclk_gatetime.setValue(tracker_node.getExtClkGateTime() / float(pattern_view.step_resolution));
      fp_play_extclk_gatetime.redraw();
   }

   // <ui_update.png>
   protected method updatePlayOffLenSteps() {
      fp_play_offlen_steps.setValue(tracker_node.getOffLenTicks() / float(pattern_view.step_resolution));
      fp_play_offlen_steps.redraw();
   }

   // <ui_update.png>
   protected method updatePlayDurSteps() {
      fp_play_dur_steps.setValue(tracker_node.getDurTicks() / float(pattern_view.step_resolution));
      fp_play_dur_steps.redraw();
   }

   // <ui_update.png>
   protected method updatePlayRec() {
      cb_play_match_instr.setSelected(tracker_node.getEnableMatchInstr());
      cb_play_match_instr.redraw();

      cb_play_rec_qlast.setSelected(tracker_node.getEnableRecQuantizeLastStep());
      cb_play_rec_qlast.redraw();

      cb_play_rec_prev.setSelected(tracker_node.getEnableRecPrev());
      cb_play_rec_prev.redraw();

      cb_play_rec_all.setSelected(tracker_node.getEnableRecAll());
      cb_play_rec_all.redraw();

      cb_play_rec_spread.setSelected(tracker_node.getEnableRecSpread());
      cb_play_rec_spread.redraw();

      cb_play_rec_bg.setSelected(tracker_node.getEnableRecBg());
      cb_play_rec_bg.redraw();

      cm_play_rec_mode.setSelectedOption(tracker_node.getRecMode());
      cm_play_rec_mode.redraw();

      cm_play_rec_sel.setSelectedOption(tracker_node.getRecSel());
      cm_play_rec_sel.redraw();
   }

   // <ui_update.png>
   public method updateNodeClass() {
      cm_node_class.setSelectedOption(tracker_node.getNodeClassId());
      cb_node_class_show.setSelected(tracker_node.getEnableNodeClassShow());
   }

   // <ui_update.png>
   protected method updateChangeOptions() {
      cm_play_mode.setSelectedOption(tracker_node.getPlayMode());
      cb_play_change_reset.setSelected(tracker_node.getEnableChangeReset());
      updatePlayOffLenSteps();
   }

   // <ui_update.png>
   protected method updateAudioMIDINodeOptions() {
      local StringArray optNodes;
      local IntArray optColors;

      optNodes.add("-");
      optColors.add(0);
      int midiOptIdx = 0;
      int audioOptIdx = 0;

      int pipeIdx = 0;
      loop(current_pipe_root.numPipes)
      {
         MIDIPipe pipe <= current_pipe_root.getPipeByUsedIdx(pipeIdx);

         int nodeIdx = 0;
         loop(pipe.numNodes)
         {
            MIDIPipeNodeScriptProxy nsp <= pipe.getNodeByIdx(nodeIdx);
            if(nsp instanceof MIDIPipeNodeScriptProxy)
            {
               NodeTracker nt <= nsp.sci;
               if(nt instanceof NodeTracker)
               {
                  int nodeGID = nt.getNodeGID();
                  if(nodeGID == tracker_node.midi_node_gid)
                     midiOptIdx = optNodes.numElements;
                  if(nodeGID == tracker_node.audio_node_gid)
                     audioOptIdx = optNodes.numElements;
                  optNodes.add(nodeGID+": "+nt.nodeGetName());

                  if(@(nt) == @(tracker_node))
                     optColors.add(#40a00000);
                  else
                     optColors.add(0);
               }
            }
            nodeIdx++;
         }

         pipeIdx++;
      }

      cm_play_midi_node.setOptions(optNodes);
      cm_play_midi_node.setOptionBGColors(optColors);
      cm_play_midi_node.setSelectedOption(midiOptIdx);

      cm_play_audio_node.setOptions(optNodes);
      cm_play_audio_node.setOptionBGColors(optColors);
      cm_play_audio_node.setSelectedOption(audioOptIdx);
   }

   // <ui_handle.png>
   public method handleMIDINodeGIDChanged() {
      if(cm_play_midi_node.getSelectedOption() > 0)
      {
         String s <= cm_play_midi_node.getSelectedOptionName();
         tracker_node.midi_node_gid = s.substring(0, s.indexOfChar(':', 0));
         Global.Print("MIDI node GID is "+tracker_node.midi_node_gid+" ("+s+")");
      }
      else
      {
         // "-"
         tracker_node.midi_node_gid = -1;
      }
   }

   // <ui_handle.png>
   public method handleAudioNodeGIDChanged() {
      if(cm_play_audio_node.getSelectedOption() > 0)
      {
         String s <= cm_play_audio_node.getSelectedOptionName();
         tracker_node.audio_node_gid = s.substring(0, s.indexOfChar(':', 0));
         Global.Print("Audio node GID is "+tracker_node.audio_node_gid+" ("+s+")");
      }
      else
      {
         // "-"
         tracker_node.audio_node_gid = -1;
      }
   }

   // <ui_handle.png>
   protected method handlePerPatternKJInstrChanged() {
      tracker_node.b_per_pattern_kj_instr = cb_play_per_pattern_kj_instr.isSelected();
      Global.Print("Per-pattern-KJ-instrument is "+Utils.GetEnableString(tracker_node.b_per_pattern_kj_instr));
   }

   // <ui_handle.png>
   public method handleWriteInstrumentNrEnableChanged() {
      tracker_node.b_write_instrnr = cb_write_instrnr.isSelected();

      Global.Print("Rec instr-nr is "+Utils.GetEnableString(tracker_node.b_write_instrnr));
   }

   // <ui_handle.png>
   public method handleWriteVelocityEnableChanged() {
      tracker_node.b_write_noteon_velocity = cb_write_velocity.isSelected();

      Global.Print("Rec note-on velocity is "+Utils.GetEnableString(tracker_node.b_write_noteon_velocity));
   }

   // <ui_handle.png>
   public method handleWriteVelocityChanged() {
      tracker_node.write_noteon_velocity = fp_kj_velocity.getFloatValue();
   }

   // <ui_handle.png>
   public method handleWriteOffVelocityEnableChanged() {
      tracker_node.b_write_noteoff_velocity = cb_write_offvelocity.isSelected();

      Global.Print("Rec note-off velocity is "+Utils.GetEnableString(tracker_node.b_write_noteoff_velocity));
   }

   // <ui_handle.png>
   public method handleWriteOffVelocityChanged() {
      tracker_node.write_noteoff_velocity = fp_kj_offvelocity.getFloatValue();
   }

   // <ui_handle.png>
   public method handleWriteDurationEnableChanged() {
      tracker_node.b_write_duration = cb_write_duration.isSelected();

      Global.Print("Rec duration is "+Utils.GetEnableString(tracker_node.b_write_duration));
   }

   // <ui_handle.png>
   public method handleWriteDurationChanged() {
      tracker_node.write_duration = fp_kj_duration.getFloatValue();
   }

   // <ui_update.png>
   public method updateStepAdvanceRadioButtons() {
      PopupMenuRadioButton *rb;
      foreach rb in pa_pmrb_edit_stepadv
      {
         rb.setSelected(false);
      }
      switch(pattern_view.step_advance)
      {
         default:
            rb <= pa_pmrb_edit_stepadv.get(0);
            break;

         case 1:
            rb <= pa_pmrb_edit_stepadv.get(1);
            break;

         case 2:
            rb <= pa_pmrb_edit_stepadv.get(2);
            break;

         case 3:
            rb <= pa_pmrb_edit_stepadv.get(3);
            break;

         case 4:
            rb <= pa_pmrb_edit_stepadv.get(4);
            break;

         case 5:
            rb <= pa_pmrb_edit_stepadv.get(5);
            break;

         case 6:
            rb <= pa_pmrb_edit_stepadv.get(6);
            break;

         case 7:
            rb <= pa_pmrb_edit_stepadv.get(7);
            break;

         case 8:
            rb <= pa_pmrb_edit_stepadv.get(8);
            break;

         case -1:
            rb <= pa_pmrb_edit_stepadv.get(9);
            break;
      }

      rb.setSelected(true);
   }

   // <ui_update.png>
   public method updateMicroShiftRadioButtons() {
      PopupMenuRadioButton *rb;
      foreach rb in pa_pmrb_edit_microshift
      {
         rb.setSelected(false);
      }
      switch(tracker_node.getMicroShiftIdx())
      {
         default:
            rb <= pa_pmrb_edit_microshift.get(0);
            break;

         case 1:
            rb <= pa_pmrb_edit_microshift.get(1);
            break;

         case 2:
            rb <= pa_pmrb_edit_microshift.get(2);
            break;

         case 3:
            rb <= pa_pmrb_edit_microshift.get(3);
            break;

         case 4:
            rb <= pa_pmrb_edit_microshift.get(4);
            break;

         case 5:
            rb <= pa_pmrb_edit_microshift.get(5);
            break;

         case 6:
            rb <= pa_pmrb_edit_microshift.get(6);
            break;

         case 7:
            rb <= pa_pmrb_edit_microshift.get(7);
            break;

         case 8:
            rb <= pa_pmrb_edit_microshift.get(8);
            break;

         case 16:
            rb <= pa_pmrb_edit_microshift.get(9);
            break;
      }

      rb.setSelected(true);
   }

   // <ui.png>
   public method autoEnableAndConfigureTracksScroller() {
      int numTracks = pattern_view.getNumTracks();
      int numVisTracks = pattern_view.getNumVisibleTracks();

      // trace "xxx NT::autoEnableAndConfigureTracksScroller: numTracks="+numTracks+" numVisTracks="+numVisTracks;

      if((numTracks > numVisTracks) && (numVisTracks > 0))
      {
         // Enable scroller
         if(0 != ls_tracks.getCurrentChildNr())
         {
            ls_tracks.switchToLayerNr(0);

            // Force re-layout, even if layout cache is enabled
            b_layout_done = false;
            layoutHierarchy(true, false);
         }

         sr_tracks.setRange(0, numTracks-1);
         sr_tracks.setRelativeKnobSize(numTracks / float(numVisTracks));
         sr_tracks.setValue(pattern_view.getCurrentTrackNr());
         sr_tracks.redraw();
      }
      else
      {
         if(1 != ls_tracks.getCurrentChildNr())
         {
            ls_tracks.switchToLayerNr(1);

            // Force re-layout, even if layout cache is enabled
            b_layout_done = false;
            layoutHierarchy(true, false);
         }
      }
   }

   // <method_set.png>
   public method setStepResolution(int _res) {
      // Called after step resolution has been entered in a dialog or the zoom keys have been used

      // (note) also updates node.pv_step_resolution
      pattern_view.setStepResolution(_res);

      if(null != fp_stepresolution)
      {
         updateStepResolution(_res);
      }
   }

   // <method.png>
   public method focusStepResolution() {
      fp_stepresolution.onTabFocus();
   }

   // <method.png>
   public method focusKJVelocity() {
      fp_kj_velocity.onTabFocus();
   }

   // <method.png>
   public method focusKJDuration() {
      fp_kj_duration.onTabFocus();
   }

   // <method.png>
   public method focusKJInstrument() {
      tf_kj_instrument.onTabFocus();
   }

   // <ui_handle.png>
   public method handleKJInstrumentChanged(boolean _bRefocusPattern) {
      // trace "xxx handleKJInstrumentChanged bRefocusPattern="+_bRefocusPattern;

      //  ui_kj_instrument_changed
      int ins = Utils.UnmapLetterNr(tf_kj_instrument.getText());

      keyJazzSelectInstrument(ins, true/*bMakeVisible*/, false/*bQuiet*/);

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   public virtual nodeHandleEditPatternChanged() {
      handlePatNrChanged2(tracker_node.nodeGetCurrentEditPatternNr(),
                          false/*bRefocusPattern*/
                          );
   }

   // <method.png>
   public method restoreKJInstrFromPat() {
      if(tracker_node.b_per_pattern_kj_instr)
      {
         NT_Track track <= pattern_view.getCurrentTrack();
         if(null != track)
         {
            NT_TrackPattern trackPat <= track.getPattern(tracker_node.nodeGetCurrentEditPatternNr());
            if(null != trackPat)
            {
               trace "xxx handlePatNrChanged3: restore trackPat.keyjazz_instr_nr="+trackPat.keyjazz_instr_nr;
               keyJazzSelectInstrument(trackPat.keyjazz_instr_nr, true/*bMakeVisible*/, true/*bQuiet*/);
            }
         }
      }
   }

   // <ui_handle.png>
   protected method handlePatNrChanged3() {

      updatePatNr();
      updatePatLen();
      updatePatName();
      
      restoreKJInstrFromPat();

      pattern_view.queueRedrawAll();
   }

   // <ui_handle.png>
   protected method handlePatNrChanged2(int     _patNr,
                                        boolean _bRefocusPattern
                                        ) {
      selectPatternByIdx(_patNr);

      handlePatNrChanged3();

      Global.Print("Select pattern "+cm_patnr.getCaption());

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <method.png>
   protected /*=replay=*/ method trySelectAudioSample() {

      Integer instrDevIdx;
      Byte instrMidiCh;
      short smpUID = pattern_view.findSmpUID(instrDevIdx, instrMidiCh);
      Global.Debug2("NodeTrackerEditor::trySelectAudioSample: smpUID="+smpUID+" instrDevIdx="+instrDevIdx+" instrMidiCh="+instrMidiCh);
      if(smpUID >= 0)
      {
         if(instrDevIdx >= 0)
         {
            // (note) calls queueForcedSmpUID()
            tracker_node.tryEditSampleInEureka(smpUID,
                                               instrDevIdx, instrMidiCh,
                                               false/*bShowEurekaWindow*/,
                                               0/*selStartMS*/,
                                               -1/*selLenMS=keep*/
                                               );
         }
      }

      if(RootForm.IsAudioLiveRecFormVisible())
         f_audio_liverec.handleAudioPatNrChanged();
   }

   // <ui_handle.png>
   public method selectPatternGroup(int _groupIdx) {
      int cPatNr = cm_patnr.getSelectedOption();

      handlePatNrChanged2((_groupIdx << 2) | (cPatNr & 3),
                          true/*bRefocusPattern*/
                          );
   }

   // <ui_handle.png>
   public method handlePatNrChanged(boolean _bRefocusPattern) {

      handlePatNrChanged2(cm_patnr.getSelectedOption(),
                          _bRefocusPattern
                          );
   }

   // <ui_handle.png>
   public method handlePatNrGroupChanged(boolean _bRefocusPattern) {

      int cPatNr = cm_patnr.getSelectedOption();

      cPatNr = (cPatNr & 3) | (cm_mmc_patnr_group.getSelectedOption() << 2);

      handlePatNrChanged2(cPatNr,
                          _bRefocusPattern
                          );
   }

   // <ui_handle.png>
   public method handlePatNrSubChanged(boolean _bRefocusPattern) {

      int cPatNr = cm_patnr.getSelectedOption();

      cPatNr = (cPatNr & ~3) | (cm_mmc_patnr_sub.getSelectedOption());

      handlePatNrChanged2(cPatNr,
                          _bRefocusPattern
                          );
   }

   // <ui_handle.png>
   public method handlePatLenChanged(boolean _bRefocusPattern) {

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      if(null != mpat)
      {
         mpat.setNumTicks( fp_stepresolution.getValue() * fp_patlen.getValue() );

         pattern_view.queueRedrawAll();

         envelope_view.showNode(tracker_node);
         if(1 == ls_envelope.getCurrentChildNr())
         {
            envelope_view.redraw();
         }
      }

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   public method handlePatNameChanged(boolean _bRefocusPattern) {

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      if(null != mpat)
      {
         mpat.patSetName(tf_pat_name.getText());

         Global.Print("Pattern name is \""+mpat.pat_name+"\"");
      }

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   public method handleStepResolutionChanged(boolean _bRefocusPattern) {
      // ui_stepResolution_changed
      int sr = fp_stepresolution.getValue();

      setStepResolution(sr);

      updatePatLen();
      updateExtClkGateTimeSteps();
      updatePlayOffLenSteps();
      updatePlayDurSteps();

      // Global.Print("Step resolution set to "+sr);

      pattern_view.redrawAll();

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   public method handleKJOctaveChanged(boolean _bRefocusPattern) {
      // ui_kj_octave_changed
      int oct = fp_kj_octave.getValue();
      oct *= 12;

      keyJazzSetOctave(oct, false/*bQuiet*/);

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   public method handleKJVelocityChanged(boolean _bRefocusPattern) {
      // ui_kj_velocity_changed
      float vel = fp_kj_velocity.getValue();

      keyJazzSetNoteOnVelocity(vel, false/*bQuiet*/);

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   public method handleKJOffVelocityChanged(boolean _bRefocusPattern) {
      //  ui_kj_offvelocity_changed
      float vel = fp_kj_offvelocity.getValue();

      keyJazzSetNoteOffVelocity(vel, false/*bQuiet*/);

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   public method handleKJDurationChanged(boolean _bRefocusPattern) {
      //  ui_kj_duration_changed
      int dur = fp_kj_duration.getValue();

      keyJazzSetDuration(dur, false/*bQuiet*/);

      if(_bRefocusPattern)
         refocusDefault();
   }

   // <ui_handle.png>
   protected method handlePlayExtClkChanged() {
      tracker_node.setEnableExtClk(cb_play_extclk.isSelected());

      Global.Print("ExtClk is "+Utils.GetEnableString(tracker_node.getEnableExtClk()));
   }

   // <ui_handle.png>
   protected method handleSpeedSclResetValChanged() {
      tracker_node.setSpeedSclResetVal(fp_speed_scl_reset.getFloatValue());
      if(tracker_node.rpn_com_speed_scl_reset_val > 0)
      {
         local Float fo = tracker_node.rpn_com_speed_scl_reset_val;
         Global.Print("Speed reset value is "+fo.printf("%3.3f"));
      }
      else
      {
         Global.Print("Speed reset value is <not set>");
      }
   }

   // <ui_handle.png>
   protected method handleExtClkGateTimeChanged() {
      tracker_node.setExtClkGateTime(fp_play_extclk_gatetime.getFloatValue() * pattern_view.step_resolution);

      Global.Print("ExtClk Gate Time is "+tracker_node.getExtClkGateTime()+" ticks");
   }

   // <ui_handle.png>
   protected method handleNodeClassChanged() {
      tracker_node.setNodeClassId(cm_node_class.getSelectedOption());

      f_autodev.handleNodeClassChanged();

      Global.Print("Node class is \""+tracker_node.getNodeClassString()+"\"");
   }

   // <ui_handle.png>
   protected method handleNodeClassShowChanged() {
      tracker_node.setEnableNodeClassShow(cb_node_class_show.isSelected());

      f_autodev.handleNodeClassShowChanged();

      Global.Print("Node class show is "+Utils.GetEnableString(tracker_node.getEnableNodeClassShow()));
   }

   // <ui_handle.png>
   protected method handlePlayModeChanged() {
      tracker_node.setPlayMode(cm_play_mode.getSelectedOption());

      Global.Print("Play mode is "+cm_play_mode.getSelectedOptionName()+".");
   }

   // <ui_handle.png>
   protected method handlePlayChangeResetChanged() {
      tracker_node.setEnableChangeReset(cb_play_change_reset.isSelected());

      Global.Print("Play change/reset is "+Utils.GetEnableString(tracker_node.getEnableChangeReset())+".");
   }

   // <ui_handle.png>
   protected method handlePlayOffLenStepsChanged() {
      int ticks = fp_play_offlen_steps.getFloatValue() * pattern_view.step_resolution;
      tracker_node.setOffLenTicks(ticks);

      Global.Print("Off/len scale is "+ticks+" ticks");
   }

   // <ui_handle.png>
   protected method handlePlayDurStepsChanged() {
      float ticks = fp_play_dur_steps.getFloatValue() * pattern_view.step_resolution;
      tracker_node.setDurTicks(ticks);

      Global.Print("Duration scale is "+ticks+" ticks");
   }

   // <ui_handle.png>
   protected method handlePlayMatchInstrChanged() {
      tracker_node.setEnableMatchInstr(cb_play_match_instr.isSelected());

      String msg;
      switch(cb_play_match_instr.isSelected())
      {
         default:
         case false:
            msg = "Don't filter events";
            break;

         case true:
            msg = "Filter events by instrument device+channel";
            break;

         case maybe:
            msg = "Filter events by instrument channel";
            break;
      }

      Global.Print(msg);
   }

   // <ui_handle.png>
   protected method handlePlayRecQLastChanged() {
      tracker_node.setEnableRecQuantizeLastStep(cb_play_rec_qlast.isSelected());

      Global.Print("Rec qlast is "+Utils.GetEnableString(tracker_node.getEnableRecQuantizeLastStep()));
   }

   // <ui_handle.png>
   protected method handlePlayRecPrevChanged() {
      tracker_node.setEnableRecPrev(cb_play_rec_prev.isSelected());

      Global.Print("Rec prev is "+Utils.GetEnableString(tracker_node.getEnableRecPrev()));
   }

   // <ui_handle.png>
   protected method handlePlayRecAllChanged() {
      tracker_node.setEnableRecAll(cb_play_rec_all.isSelected());

      Global.Print("Rec all is "+Utils.GetEnableString(tracker_node.getEnableRecAll()));
   }

   // <ui_handle.png>
   protected method handlePlayRecSpreadChanged() {
      tracker_node.setEnableRecSpread(cb_play_rec_spread.isSelected());

      Global.Print("Rec spread is "+Utils.GetEnableString(tracker_node.getEnableRecSpread()));
   }

   // <ui_handle.png>
   protected method handlePlayRecBgChanged() {
      tracker_node.setEnableRecBg(cb_play_rec_bg.isSelected());

      Global.Print("Rec bg is "+Utils.GetEnableString(tracker_node.getEnableRecBg()));
   }

   // <ui_handle.png>
   protected method handlePlayRecModeChanged() {
      tracker_node.setRecMode(cm_play_rec_mode.getSelectedOption());

      Global.Print("Record mode is "+cm_play_rec_mode.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePlayRecSelChanged() {
      tracker_node.setRecSel(cm_play_rec_sel.getSelectedOption());

      Global.Print("Record selection is "+cm_play_rec_sel.getSelectedOptionName());
   }

   // <ui_undo.png>
   public =replay= undoTouchCurrentTrackLayout(NT_TEL _tel) {
      tracker_node.undoTouchTrackLayout(pattern_view.getCurrentTrackNr(), _tel);
   }

   // <ui_undo.png>
   public =replay= undoTouchTrackLayoutIfCurrent(NT_TEL _tel) {
      // (todo) the ManageTrackLayoutDialog can edit dialog, so actually this method would have to to determine channel/track
      //         by layout. for now, simply skip the undo entry if it's not the current layout
      NT_TEL telCur <= pattern_view.getCurrentTrackLayout();
      if(@(telCur) == @(_tel))
      {
         undoTouchCurrentTrackLayout(_tel);
      }
   }

   // <ui_update.png>
   protected method updateArpWidgets() {
      cb_arp.setSelected(tracker_node.getEnableArp());

      tm_arp_notes.parent_node <= tracker_node;
      tv_arp_notes.tableModelChanged();

      int numArpNotes = (tracker_node.arp_note_table.numElements);

      bt_arp_add.setEditable(numArpNotes < 12);
      bt_arp_remove.setEditable(-1 != tm_arp_notes.getCursorIndex());
      bt_arp_moveup.setEditable(-1 != tm_arp_notes.getCursorIndex());
      bt_arp_movedown.setEditable(-1 != tm_arp_notes.getCursorIndex());

      cm_arp_baseoct.setSelectedOption(tracker_node.getArpBaseOctave());
      cb_arp_reset.setSelected(tracker_node.getEnableArpReset());
      cb_arp_wrap.setSelected(tracker_node.getEnableArpWrap());
      cm_arp_latch.setSelectedOption(tracker_node.getArpLatchNumNotes());
      cb_arp_latch_reset.setSelected(tracker_node.getEnableArpLatchReset());
      cb_arp_play_arp_notes.setSelected(tracker_node.getEnablePlayArpNotes());
      cb_arp_play_non_arp_notes.setSelected(tracker_node.getEnablePlayNonArpNotes());
      cb_arp_dynalen.setSelected(tracker_node.getEnableArpDynaLen());
   }

   // <ui_handle.png>
   public method handleArpEnableChanged() {
      tracker_node.setEnableArp(cb_arp.isSelected());
   }

   // <method.png>
   public method incSelectedArpNote() {
      // Called from table view

      int noteIdx = tm_arp_notes.getCursorIndex();

      if(-1 != noteIdx)
      {
         tracker_node.incArpNote(noteIdx);

         tv_arp_notes.tableModelChanged();
      }

   }

   // <method.png>
   public method decSelectedArpNote() {
      // Called from table view

      int noteIdx = tm_arp_notes.getCursorIndex();

      if(-1 != noteIdx)
      {
         tracker_node.decArpNote(noteIdx);

         tv_arp_notes.tableModelChanged();
      }
   }

   // <ui_handle.png>
   protected method handleAddArpNote() {

      if(tm_arp_notes.getNumRows() < 12)
      {
         int row = tm_arp_notes.getCursorIndex();

         IntArray notes = tracker_node.arp_note_table;

         int newNote = 0;
         loop(12)
         {
            if(-1 == notes.indexOf(newNote, 0))
               break;
            newNote++;
         }

         newNote = newNote % 12;

         if(-1 == row)
         {
            notes.add(newNote);
            row = notes.numElements - 1;
         }
         else
         {
            row++;
            notes.insert(row, newNote);
         }

         tracker_node.copyArpNotes(notes);

         tv_arp_notes.tableModelChanged();

         tv_arp_notes.moveCursorToRow(row);

         bt_arp_add.setEditable(12 != notes.numElements);
      }
   }

   // <ui_handle.png>
   protected method handleRemoveArpNote() {

      if(tm_arp_notes.getNumRows() > 0)
      {
         int row = tm_arp_notes.getCursorIndex();

         if(-1 != row)
         {
            IntArray notes = tracker_node.arp_note_table;

            notes.delete(row);

            tracker_node.copyArpNotes(notes);

            tv_arp_notes.tableModelChanged();

            bt_arp_add.setEditable(true);
            bt_arp_remove.setEditable(0 != notes.numElements);
            bt_arp_moveup.setEditable(0 != notes.numElements);
            bt_arp_movedown.setEditable(0 != notes.numElements);
         }
      }
   }

   // <ui_handle.png>
   protected method handleMoveUpArpNote() {

      if(tm_arp_notes.getNumRows() > 1)
      {
         int row = tm_arp_notes.getCursorIndex();

         if(-1 != row)
         {
            IntArray notes = tracker_node.arp_note_table;

            if(row > 0)
            {
               notes.swap(row, row - 1);
            }

            tracker_node.copyArpNotes(notes);

            tv_arp_notes.tableModelChanged();

            tv_arp_notes.moveCursorToPreviousRow();
         }
      }
   }

   // <ui_handle.png>
   protected method handleMoveDownArpNote() {
      if(tm_arp_notes.getNumRows() > 1)
      {
         int row = tm_arp_notes.getCursorIndex();

         if(-1 != row)
         {
            IntArray notes = tracker_node.arp_note_table;

            if(row != (notes.numElements - 1))
            {
               notes.swap(row, row + 1);
            }

            tracker_node.copyArpNotes(notes);

            tv_arp_notes.tableModelChanged();

            tv_arp_notes.moveCursorToNextRow();
         }
      }
   }

   // <ui_handle.png>
   protected method handleArpBaseOctaveChanged() {
      tracker_node.setArpBaseOctave(cm_arp_baseoct.getSelectedOption());
   }

   // <ui_handle.png>
   protected method handleArpResetChanged() {
      tracker_node.setEnableArpReset(cb_arp_reset.isSelected());
   }

   // <ui_handle.png>
   protected method handleArpWrapChanged() {
      tracker_node.setEnableArpWrap(cb_arp_wrap.isSelected());
   }

   // <ui_handle.png>
   protected method handleArpLatchChanged() {
      tracker_node.setArpLatchNumNotes(cm_arp_latch.getSelectedOption());
   }

   // <ui_handle.png>
   protected method handleArpLatchResetChanged() {
      tracker_node.setEnableArpLatchReset(cb_arp_latch_reset.isSelected());
   }

   // <ui_handle.png>
   public method handleArpPlayArpNotesChanged() {
      tracker_node.setEnablePlayArpNotes(cb_arp_play_arp_notes.isSelected());
   }

   // <ui_handle.png>
   public method handleArpPlayNonArpNotesChanged() {
      tracker_node.setEnablePlayNonArpNotes(cb_arp_play_non_arp_notes.isSelected());
   }

   // <ui_handle.png>
   public method handleArpDynaLenChanged() {
      tracker_node.setEnableArpDynaLen(cb_arp_dynalen.isSelected());
   }

   // <ui_show.png>
   public virtual showNode(NodeTracker _tracker) {

      tracker_node <= _tracker;

      Global.Debug("NodeTrackerEditor::showNode: node="+#(_tracker)+" edit_clip_parent_arranger_gid="+tracker_node.edit_clip_parent_arranger_gid);

      tracker_node.pattern_view <= pattern_view;
      tracker_node.b_skip_rec_undo = false; // paranoia

      // Set edit pattern to play pattern
      //  (note) when not invoked from arranger
      if(-1 == tracker_node.edit_clip_parent_arranger_gid)
      {
         byte playPatNr = tracker_node.nodeGetCurrentPlayPatternNr();
         if(playPatNr != 126/*scratch*/)
         {
            tracker_node.nodeSetCurrentEditPatternNr(playPatNr);
         }
      }

      if(!replay.b_playing && STConfig.b_node_tracker_edit_pattern_follows_replay_pattern)
      {
         // Update last pattern start editor song offset
         //  (note) when replay is running, this has already been updated
         handleSongPosSelected();
      }

      cb_play_extclk.setSelected(tracker_node.getEnableExtClk());
      updateExtClkGateTimeSteps();

      fp_speed_scl_reset.setValue(tracker_node.rpn_com_speed_scl_reset_val);

      StringArray devAll;
      devAll.join(["*"], MIDI.out_device_names_sorted);
      IntArray bgcolorsAll;
      bgcolorsAll.join([0], MIDI.out_device_bgcolors_sorted);

      f_autodev.showNode(tracker_node, devAll, bgcolorsAll);

      pattern_view.showNode(tracker_node);
      instrument_view.showNode(tracker_node);
      envelope_view.showNode(tracker_node);

      sp_envelope_view.setSplit(tracker_node.envelope_view_split);
      toggleEnvelopeView(tracker_node.b_envelope_view_visible);

      cm_node_class.setOptions(STConfig.node_class_names);
      updateNodeClass();
      updateNodeClassShowIn(tracker_node);

      updateChangeOptions();
      updatePlayDurSteps();
      updatePlayRec();

      updateAudioMIDINodeOptions();

      cb_play_per_pattern_kj_instr.setSelected(tracker_node.b_per_pattern_kj_instr);

      piano.setLastNotesByRef(tracker_node.ui_last_note_state);
      piano.clearNotes();
      updatePianoWidgetEnable(false/*bRelayout*/);

      // Restore (vertical) cursor position
      if(tracker_node.doAutoScroll())
      {
         pattern_view.gotoPatPosition(current_song.song_offset - tracker_node.nodeGetLastPatternStartEditorSongOffset(), false);
      }
      else
      {
         pattern_view.gotoPatPosition(tracker_node.pv_pat_offset, false);
      }

      // Update song attribute widgets
      updateSongWidgets();
      updateStepResolution(tracker_node.pv_step_resolution);

      updatePatNr();
      updatePatLen();
      updatePatName();

      updatePlayStepReset();
      updateLockKeyJazz();

      handlePlayPatChanged();

      updateArpWidgets();

      updateChordClearStep();
      updateTimingViewMoveLock();
      updateSwapLShift();
      updateShowCtlInfo();
      updateFrRecToKJInsPlay();

      // // tracker_node.rec_num_active_notes = 0;

      updateKeyJazzWidgets();

      StringArray midiNotes <= MIDI.midi_notes;
      pmb_events_collapse.setToolTipCaption("Collapse events to scratch pattern and start tap mode\n\n (note) MIDI "+midiNotes.get(4*12/*C-4*/)+"..? plays (collapsed) row, "+midiNotes.get(3*12+11/*B-3*/)+" plays next row (cycle)\n\n (note) lctrl-x t ends tap mode\n\n (note) zoom level at tap mode start determines row granularity");

      MIDI.AddMIDIMapEventListener(this);

      handleViewEnter();
   }

   // <method.png>
   public method showNodeQuiet(NodeTracker _tracker) {
      // used by NodeSeq sub-song export ("explode")
      tracker_node <= _tracker;
      tracker_node.pattern_view <= pattern_view;
      pattern_view.showNodeQuiet(tracker_node);
      instrument_view.showNodeQuiet(tracker_node);
      // // envelope_view.showNode(tracker_node);
   }


   // <ui_show.png>
   public virtual showNodePost() {
      // // trace "[dbg] NodeTrackerEditor::showNodePost";

      showView(tracker_node.ui_last_view, true/*bEnterLeave*/);

      autoEnableAndConfigureTracksScroller();

      updateMicroShiftRadioButtons();

      // postpone until size_x is != 0
      pattern_view.b_queue_verify_track_shift = true;

      ta_modewidgets.schedule();

      UI.SetKeyboardFocusListener(this);

      refocusDefault();
   }

   // <ui_hide.png>
   public virtual leaveNode() {
      // trace "xxx NT::leaveNode";

      UI.SetKeyboardFocusListener(null);

      cancelAllTimers();

      if(null != tracker_node)
      {
         if(null != tracker_node.seq_tracker_state)
         {
            // Backup tracker editor state for next invocation
            NSQ_TrackerState ts <= tracker_node.seq_tracker_state;
            ts.copyFrom(tracker_node);
            tracker_node.seq_tracker_state <= null;
         }

         if(tracker_node.b_tap_mode)
            Global.WarningLong("Tap mode is still enabled (lctrl-x t)");

         tracker_node.b_seq_temp = false;  // when Node is somehow exited by other means than ESC (should not happen)

         // // // tracker_node.nodeStopOutputCapture();  // no, keep on recording

         MIDI.RemoveMIDIMapEventListener(this);

         tracker_node.envelope_view_split = sp_envelope_view.getSplit();

         // trace "xxx pv::leaveNode: tracker_node="+#(tracker_node);
         envelope_view.leaveNode();
         instrument_view.leaveNode();
         pattern_view.leaveNode();
         f_autodev.leaveNode();

         handleViewLeave();

         if(null != tracker_node)
         {
            tracker_node.pattern_view <= null;
         }

         tracker_node.ui_last_view = ls_view.getCurrentChildNr();
      }

   }

   // <method.png>
   public method cancelAllTimers() {
      ta_notelabel.cancel();
      ta_modewidgets.cancel();

      pattern_view.cancelAllTimers();
      envelope_view.cancelAllTimers();
      instrument_view.cancelAllTimers();
   }

   // <ui_hide.png>
   public virtual unsetNode() {
      // trace "xxx NT::unsetNode";
      f_autodev.unsetNode();
      envelope_view.parent_node <= null;
      instrument_view.parent_node <= null;
      pattern_view.parent_node <= null;  // 30Nov2017  (fix crash after deleting node in pipemap)
      tracker_node <= null;
   }

   // <ui_midi.png>
   public virtual mmtHandleGlobalValue(float _val) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();

      return false;
   }

   // <ui_midi.png>
   public virtual mmtHandleGlobalValueDelta(int _delta) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();

      return false;
   }

   // <ui_midi.png>
   public virtual mmlHandleEventUI(MIDIMapEvent _ev) : boolean {

      // trace "xxx nt:mmlHandleEventUI";

      if(_ev.isReservedEvent())
         return false;

      if(STConfig.b_show_ctl_info)
      {
         MIDIMapEvent evXForm = _ev;
         MIDIMorphScene.TransformEvent(evXForm);
         if(evXForm.isValid())
         {
            evXForm.echoTransformForced();
            if(STConfig.b_show_ctl_info_hifreq || !evXForm.isHiFreqEvent())
            {
               Global.PrintFast(evXForm.getInfoStringForPipeMap());
            }
         }
      }

      NT_RandomDialog randomDlg <= pattern_view.dlg_random;
      if( (null != randomDlg) && randomDlg.isFloatingLayerVisible() )
      {
         return randomDlg.mmlHandleEventUI(_ev);
      }

      int curView = ls_view.getCurrentChildNr();

      if(VIEW_PATTERN == curView)
      {
         return pattern_view.mmlHandleEventUI(_ev);
      }
      else if(VIEW_INSTRUMENT == curView)
      {
         return instrument_view.mmlHandleEventUI(_ev);
      }
   }

   // <method_handle.png>
   public virtual handleRemoteEvent(RemoteEvent _ev) : boolean {
      // Called from UI thread
      if(pattern_view.isEditable())
      {
         NT_Track track <= pattern_view.getCurrentTrack();
         if(null != track)
         {
            NT_Instrument instr <= tracker_node.getInstrument(track.keyjazz_instr_nr);
            if(null != instr)
            {
               NT_MIDIParam param <= instr.getUsrCtlParamByRemoteEvent(_ev);
               if(null != param)
               {
                  float paramValue = param.unmapRemoteEventParamValue(_ev.param_value);
                  tracker_node.recordUsrCtlParamValue(track, param, paramValue);
                  pattern_view.queueRedrawAll();
                  evHandleRecordMidiEndSchedule();
                  return true;
               }
            }
         }
      }
      return false;
   }

   // <method_set.png>
   public virtual selectPatternByIdx(byte _patNr) {
      // (note) caller triggers redraw, updates editor widgets, ..

      // trace "xxx selectPatternByIdx("+_patNr+")";

      _patNr = _patNr & 127;

      if(!replay.b_playing || STConfig.b_node_tracker_selectandplay)
      {
         // Change edit pattern + replay pattern
         // // tracker_node.nodeSetCurrentPlayPatternNr(_patNr);
         tracker_node.nodeQueuePatternUI(_patNr, -1, false/*bMuteTemp*/);
         tracker_node.nodeSetCurrentEditPatternNr(_patNr);

         tracker_node.nodeQueuePrgChgOut(_patNr);
         // // replay.handleNodeStateChangedUI(tracker_node, -1/*active*/, _patNr/*pat*/);
      }
      else
      {
         // Only change edit pattern
         tracker_node.nodeSetCurrentEditPatternNr(_patNr);
      }

      pattern_view.selectNone();

      handlePlayPatChanged();

      root_form.pg_node.handleEditPatternChanged();

      // From SetPatternNumberDialog handling:
      updatePatNr();
      pattern_view.redrawAll();

      queueUpdateBidirectionalControls();

      trySelectAudioSample();
   }

   // <method.png>
   public virtual selectPatternByUsedIdx(int _idx) {
      if(_idx >= 0)
      {
         int patNr = tracker_node.nodeGetPatternNrByUsedIdx(_idx);

         if(-1 != patNr)
         {
            handlePatNrChanged2(patNr,
                                false/*bRefocusPattern*/
                                );
            // // replay.handleNodeStateChangedUI(tracker_node, -1/*active*/, patNr/*pat*/);
         }
      }
      else
      {
         handlePatNrChanged2(Node.EMPTY_PAT_NR,
                             false/*bRefocusPattern*/
                             ); // --/
         // // replay.handleNodeStateChangedUI(tracker_node, -1/*active*/, Node.EMPTY_PAT_NR/*pat*/);
      }

      pattern_view.selectNone();
   }

   // <method_get.png>
   public method uiGetNextTrackName() : String {
      int maxTrackNr = 0;
      NT_Track *track;
      foreach track in tracker_node.tracks
      {
         String n = track.name;
         if(n.startsWith("Track "))
         {
            n.replace("Track ", "");
            int trackNr = n;
            if(trackNr > maxTrackNr)
            {
               maxTrackNr = trackNr;
            }
         }
      }
      return "Track " + (maxTrackNr+1);
   }

   // <ui_cmd.png>

   // --------------------------------------------------------------------------
   // - cmd_edit_xxx
   // --------------------------------------------------------------------------
   public method cmd_edit_undo() {

      if(pattern_view.undoAndRestartRecording())
      {
         return;
      }

      // if(Global.NotPlaying("cmd_edit_undo"))
      {
         // (note) NT_UndoStack.undo() checks if pattern view has to be editable for undo operation
         if(tracker_node.undo(!replay.b_playing || !tracker_node.doAutoScroll()/*bRestoreCursor*/))
         {
            pattern_view.cursor_x = tracker_node.pv_cursor_x;

            selectPatternByIdx(tracker_node.nodeGetCurrentEditPatternNr());

            updatePatNr();
            updatePatLen();
            updateKJInstrumentName(null, true/*bQuiet*/);

            pattern_view.queueRedrawAll();
         }
         else
         {
            Global.Warning("Undo: transaction \""+tracker_node.getUndoEntryName()+"\" still in progress.");
         }
      }
   }

   public method cmd_edit_redo() {
      // if(Global.NotPlaying("cmd_edit_redo"))
      {
         // (note) NT_UndoStack.redo() checks if pattern view has to be editable for undo operation
         if(tracker_node.redo())
         {
            pattern_view.cursor_x = tracker_node.pv_cursor_x;

            selectPatternByIdx(tracker_node.nodeGetCurrentEditPatternNr());

            updatePatNr();
            updatePatLen();
            updateKJInstrumentName(null, true/*bQuiet*/);

            pattern_view.queueRedrawAll();
         }
         else
         {
            Global.Warning("Redo: transaction \""+tracker_node.getUndoEntryName()+"\" still in progress.");
         }
      }
   }

   public method cmd_edit_undoempty() {
      tracker_node.undoEmpty();
   }

   public method cmd_edit_undotogglemode() {
      STConfig.b_node_tracker_undo_record_single_transaction = !STConfig.b_node_tracker_undo_record_single_transaction;

      updateUndoModeSingleTransaction();

      Global.Print("single-undo-transaction pattern recording mode is now " +
                   Utils.GetEnableString(STConfig.b_node_tracker_undo_record_single_transaction)
                   );
   }

   public method cmd_edit_undotoggledebug() {
      STConfig.b_node_tracker_undo_debug = !STConfig.b_node_tracker_undo_debug;

      updateUndoDebug();

      Global.Print("undo debug mode is now " +
                   Utils.GetEnableString(STConfig.b_node_tracker_undo_debug)
                   );
   }

   public method cmd_edit_togglemode() {
      pattern_view.nextEditMode();

      updatePatternEditMode();
   }

   public method cmd_edit_toggleshiftmode() {
      pattern_view.toggleRelativeShiftMode();

      updateShiftMode();
   }

   public method cmd_edit_autoscroll() {
      pattern_view.toggleAutoScroll();

      updateAutoScroll();
   }

   public method cmd_edit_zoomin() {
      fp_stepresolution.decFine();

      int res = fp_stepresolution.getValue();

      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();

      // // Global.Print("cmd_edit_zoomin: Set step resolution to "+res);
   }

   // // public method cmd_edit_zoomin_double() {
   // //    int res = fp_stepresolution.getValue();
   // //    res = res/2;
   // //    if(res < 1)
   // //       res = 1;

   // //    updateStepResolution(res);

   // //    setStepResolution(res);

   // //    pattern_view.printCursorStatusInfo();  // chord detect + piano notes
   // //    pattern_view.redrawAll();

   // //    // // Global.Print("cmd_edit_zoomin_double: Set step resolution to "+res);
   // // }

   public method cmd_edit_zoomout() {
      fp_stepresolution.incFine();
      int res = fp_stepresolution.getValue();

      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();

      // // Global.Print("cmd_edit_zoomout: Set step resolution to "+res);
   }

   // // public method cmd_edit_zoomout_half() {
   // //    int res = fp_stepresolution.getValue();
   // //    res = res*2;
   // //    if(res > (current_song.ppq*4*8))
   // //       res = (current_song.ppq*4*8);

   // //    updateStepResolution(res);

   // //    setStepResolution(res);

   // //    pattern_view.printCursorStatusInfo();  // chord detect + piano notes
   // //    pattern_view.redrawAll();

   // //    // // Global.Print("cmd_edit_zoomout_half: Set step resolution to "+res);
   // // }

   public method cmd_edit_togglezoompreset() {
      int res = fp_stepresolution.getValue();

      if(0 == tracker_node.pv_zoom_preset_idx)
      {
         tracker_node.pv_zoom_preset_1 = res;
         res = tracker_node.pv_zoom_preset_2;
         tracker_node.pv_zoom_preset_idx = 1;
      }
      else
      {
         tracker_node.pv_zoom_preset_2 = res;
         res = tracker_node.pv_zoom_preset_1;
         tracker_node.pv_zoom_preset_idx = 0;
      }

      updateStepResolution(res);

      setStepResolution(res);

      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();

      // Global.Print("cmd_edit_togglezoompreset: presets=("+tracker_node.pv_zoom_preset_1+", "+tracker_node.pv_zoom_preset_2+") idx="+tracker_node.pv_zoom_preset_idx);
   }

   public method cmd_edit_enterstepresolution() {
      focusStepResolution();
   }

   public method cmd_edit_zoom_1_32t() {
      pattern_view.setStepResolution( (current_song.ppq / 12.0) );
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_zoom_1_32() {
      pattern_view.setStepResolution( (current_song.ppq / 8.0) );
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_zoom_1_16t() {
      pattern_view.setStepResolution( (current_song.ppq / 6.0) );
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_zoom_1_16() {
      pattern_view.setStepResolution( (current_song.ppq / 4.0) );
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_zoom_1_8t() {
      pattern_view.setStepResolution( (current_song.ppq / 3.0) );
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_zoom_1_8() {
      pattern_view.setStepResolution( (current_song.ppq / 2.0) );
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_zoom_1_4t() {
      pattern_view.setStepResolution( (current_song.ppq / 3.0) * 2.0);
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_zoom_1_4() {
      pattern_view.setStepResolution( (current_song.ppq / 1.0) );
      updateStepResolution(pattern_view.step_resolution);
      pattern_view.printCursorStatusInfo();  // chord detect + piano notes
      pattern_view.redrawAll();
   }

   public method cmd_edit_enternotevelocity() {
      focusKJVelocity();
   }

   public method cmd_edit_enternoteduration() {
      focusKJDuration();
   }

   public method setMicroShiftIdx(int _idx) {
      tracker_node.setMicroShiftIdx(_idx);
      updateMicroShiftRadioButtons();

      Global.Print("Set microshift to "+tracker_node.getMicroShiftTicks()+" ticks");
   }

   public method cmd_edit_detail() {
      pattern_view.showDetailEditAtCurrentPosition();
   }

   public method cmd_edit_toggleadvanceallnotesreleased() {
      STConfig.b_node_tracker_advance_allnotesreleased = !STConfig.b_node_tracker_advance_allnotesreleased;

      updateAdvanceAllNotesReleased();

      Global.Print("cmd_edit_toggleadvanceallnotesreleased: enabled="+STConfig.b_node_tracker_advance_allnotesreleased);
   }

   public =replay= method cmd_edit_tapmode() {
      if(tracker_node.b_tap_mode)
      {
         tracker_node.stopTapMode(true/*force*/);
         Global.Print("Stop tap mode");
      }
      else
      {
         dlg_tap_mode.run(this);
      }
   }

   public =replay= method cmd_edit_tapmode_toggle() {
      if(tracker_node.b_tap_mode)
      {
         tracker_node.stopTapMode(true/*force*/);
         Global.Print("Stop tap mode");
      }
      else
      {
         tracker_node.startTapMode();////b_tap_mode = true;
         Global.Print("Start tap mode");
      }
   }

   public method cmd_edit_tapmode_start() {
      // When dlg_tap_mode returns (is not canceled)
      tracker_node.tap_mode_source_pat_nr     = dlg_tap_mode.getSourcePatNr();
      tracker_node.tap_mode_step_resolution   = dlg_tap_mode.getStepResolution();
      tracker_node.b_tap_mode_advance         = dlg_tap_mode.getEnableAdvance();
      tracker_node.b_tap_mode_select          = dlg_tap_mode.getEnableSelect();
      tracker_node.b_tap_mode_alltracks       = dlg_tap_mode.getEnableAllTracks();
      tracker_node.b_tap_mode_beatsync        = dlg_tap_mode.getEnableBeatSync();
      tracker_node.b_tap_mode_resetsourcestep = dlg_tap_mode.getEnableResetSourceStep();
      tracker_node.b_tap_mode_keepenabled     = dlg_tap_mode.getKeepEnabled();

      tracker_node.startTapMode();

      Global.Print("Start tap mode"+(tracker_node.b_tap_mode_keepenabled ? " (active)" : " (active until replay stops)"));
   }

   public method cmd_edit_collapse_and_tap() {

      NT_MetaPattern *mpat;

      // Copy current pattern to clipboard
      NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
      int origEditPatNr = tracker_node.nodeGetCurrentEditPatternNr();
      mpat <= tracker_node.getCurrentEditMetaPattern();
      mpat.patCopyToClipboard();

      // Copy clipboard to scratch pattern (125)
      selectPatternByIdx(Node.SCRATCH_PAT_NR);
      mpat <= tracker_node.getCurrentEditMetaPattern();
      mpat.patCopyFromClipboard();

      // Collapse scratch pattern
      pattern_view.collapse(false/*bUndo*/);  // side effect: overwrites TMP pattern and changes clipboard mode back to PRIMARY

      // Select original pattern and clear it
      selectPatternByIdx(origEditPatNr);
      tracker_node.undoBeginNested("collapse_and_tap");
      cmd_pattern_free(false/*bFreeMeta*/, false/*bUndoBegin*/);
      tracker_node.undoEndNested("collapse_and_tap");

      // Set scratch pattern as tap source pattern and start tap mode
      tracker_node.last_copied_pattern_nr = Node.SCRATCH_PAT_NR;
      dlg_tap_mode.updateWidgetsFromNode(this);
      tracker_node.b_tap_mode = false;
      cmd_edit_tapmode_start();

      Global.Print("Collapse + start tap mode");

   }

   public method cmd_edit_toggle_chordclearstep() {
      tracker_node.setEnableChordClearStep(!tracker_node.getEnableChordClearStep());

      updateChordClearStep();

      Global.Print("Chord-clear-step mode is "+Utils.GetEnableString(tracker_node.getEnableChordClearStep()));
   }

   public method cmd_edit_toggleenvelopeview() {
      boolean bShow = toggleEnvelopeView(maybe);

      Global.Print((bShow?"Show":"Hide")+" envelope view");
   }

   public method cmd_edit_togglepianowidget() {
      togglePianoWidget();
   }

   public method cmd_edit_toggletimingview() {
      pattern_view.toggleTimingView();
   }

   public method cmd_edit_toggletimingview_movelock() {
      pattern_view.toggleTimingViewMoveLock();
      updateTimingViewMoveLock();
   }

   public method cmd_edit_showaudiodialog() {
      pattern_view.showAudioDialog();
   }

   public method cmd_edit_swaplshift() {
      STConfig.b_node_tracker_swap_lshift = !STConfig.b_node_tracker_swap_lshift;
      Global.Print("Swap lshift INSERT/DELETE behaviour is "+Utils.GetEnableString(STConfig.b_node_tracker_swap_lshift));
      updateSwapLShift();
   }

   public method cmd_edit_showctlinfo() {
      STConfig.b_show_ctl_info = !STConfig.b_show_ctl_info;
      Global.Print("Show incoming ctl info is "+Utils.GetEnableString(STConfig.b_show_ctl_info));
      updateShowCtlInfo();
   }

   public method cmd_edit_frrectokjinsplay() {
      pattern_view.toggleKJInsFrameRecToPlay();
      updateFrRecToKJInsPlay();
   }

   // <ui_cmd.png>
   // --------------------------------------------------------------------------
   // - cmd_cursor_xxx
   // --------------------------------------------------------------------------
   public method cmd_cursor_autoscroll() {
      pattern_view.toggleAutoScroll();

      updateAutoScroll();
   }

   public method cmd_cursor_wraparound() {
      pattern_view.togglePatternWrapAroundMode();

      updateWrapAround();
   }

   public method cmd_cursor_doublecenter() {
      pattern_view.toggleMeshZoomMode();

      updatePatternDoubleCenter();
   }

   public method cmd_cursor_doublewidth() {
      pattern_view.toggleDoubleCharWidth();

      updatePatternDoubleWidth();
   }

   public method cmd_cursor_doubleheight() {
      pattern_view.toggleDoubleCharHeight();

      updatePatternDoubleHeight();
   }

   public method cmd_cursor_timing_autodoublewidth() {
      STConfig.b_node_tracker_timing_view_autodouble_width = !STConfig.b_node_tracker_timing_view_autodouble_width;
      updatePatternTimingAutoDoubleWidth();
      pattern_view.handleCharSizeChanged();
      pattern_view.verifyTrackShift(true/*bAlignRight*/);
      pattern_view.renderAndRedrawAll();
      Global.Print("TimingView: Auto-double width is "+Utils.GetEnableString(STConfig.b_node_tracker_timing_view_autodouble_width));
   }

   public method cmd_cursor_timing_autodoubleheight() {
      STConfig.b_node_tracker_timing_view_autodouble_height = !STConfig.b_node_tracker_timing_view_autodouble_height;
      updatePatternTimingAutoDoubleHeight();
      pattern_view.handleCharSizeChanged();
      pattern_view.verifyTrackShift(true/*bAlignRight*/);
      pattern_view.renderAndRedrawAll();
      Global.Print("TimingView: Auto-double height is "+Utils.GetEnableString(STConfig.b_node_tracker_timing_view_autodouble_height));
   }

   public method cmd_cursor_decimalpatoff() {
      STConfig.b_node_tracker_decimal_patternoffset = !STConfig.b_node_tracker_decimal_patternoffset;

      pattern_view.queueRedrawAll();

      updatePatternDecimalOffset();
   }

   public method cmd_cursor_shiftpatoff() {
      STConfig.b_node_tracker_shift_patternoffset = !STConfig.b_node_tracker_shift_patternoffset;

      pattern_view.queueRedrawAll();

      updatePatternShiftOffset();
   }

   public method cmd_cursor_jumptocolumn() {
      dlg_manage_columns.showSelector(this);
      pattern_view.redrawAll();
   }


   // --------------------------------------------------------------------------
   // - cmd_replay_xxx
   // --------------------------------------------------------------------------
   public method cmd_replay_selectandplay() {
      STConfig.b_node_tracker_selectandplay = !STConfig.b_node_tracker_selectandplay;

      pmcb_replay_selectandplay.setSelected(STConfig.b_node_tracker_selectandplay);

      Global.Print("Select+Play is "+Utils.GetEnableString(STConfig.b_node_tracker_selectandplay));
   }

   public method cmd_replay_pat() {
      boolean bChanged = tracker_node.nodeGetCurrentPlayPatternNr() != tracker_node.nodeGetCurrentEditPatternNr();

      // ///tracker_node.nodeSetCurrentPlayPatternNr(tracker_node.nodeGetCurrentEditPatternNr());
      tracker_node.nodeQueuePatternUI(tracker_node.nodeGetCurrentEditPatternNr(), -1, false/*bMuteTemp*/);

      if(bChanged)
      {
         handlePlayPatChanged();
         Global.Print("Replay current edit pattern");
      }
   }

   public method cmd_replay_rec() {
      pattern_view.handleKeyRShift(false/*bCtrl*/);
   }

   public method cmd_replay_rec_cont() {
      pattern_view.handleKeyRShift(true/*bCtrl*/);
   }

   public method cmd_replay_invertspace() {
      pattern_view.toggleSwapStopBookmark();

      updateSwapStopBookmark();

      if(STConfig.b_node_tracker_swapstopbookmark)
      {
         Global.Print("Stay at cursor position when replay stops");
      }
      else
      {
         Global.Print("Goto bookmark when replay stops");
      }
   }

   public method cmd_replay_playstepreset() {
      replay.b_playstep_reset = ! replay.b_playstep_reset;

      updatePlayStepReset();

      Global.Print("Reset replay after step play is now "+Utils.GetEnableString(replay.b_playstep_reset));
   }

   public method cmd_replay_togglepipesolo() {
      PagePipeRoot pgRoot <= root_form.pg_piperoot;
      pgRoot.toggleSelectedPipeSoloState();
   }

   public method cmd_replay_togglepipemute() {
      PagePipeRoot pgRoot <= root_form.pg_piperoot;
      pgRoot.toggleSelectedPipeMuteState();
   }

   public method cmd_replay_togglenodesolo() {
      // // PagePipe     pgPipe <= root_form.pg_pipe;
      // // pgPipe.toggleSelectedNodeSoloState();

      // // PageNode pgNode <= root_form.pg_node;
      // // pgNode.updateTextFieldNodeState();
      root_form.toggleNodeSolo();
   }

   public method cmd_replay_togglenodemute() {
      // PagePipe     pgPipe <= root_form.pg_pipe;
      // pgPipe.toggleSelectedNodeMuteState();

      // PageNode pgNode <= root_form.pg_node;
      // pgNode.updateTextFieldNodeState();

      root_form.toggleNodeMute();
   }

   public method cmd_replay_togglefreerun() {
      replay.setEnableFreerunLoop(!replay.b_freerun_loop);

      updateFreerunLoop();

      Global.Print("Free-run loop mode is now "+Utils.GetEnableString(replay.b_freerun_loop));
   }

   public method cmd_replay_toggleignorearr() {
      STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay = !STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay;
      updateIgnorePrgChgAndFollowArr();
      Global.Print("Ignore PrgChg/Seek/Mute (def) mode is now "+Utils.GetEnableString(STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay));
   }

   public method cmd_replay_toggleignorearr_node() {
      tracker_node.nodeToggleIgnoreSeekPrgChgMute();
      updateIgnorePrgChgAndFollowArr();
      Global.Print("Ignore PrgChg/Seek/Mute (node) mode is now "+Utils.GetEnableString(tracker_node.b_node_ignore_seek_prgchg_mute));
   }

   public method cmd_replay_togglefollowarr() {
      STConfig.b_node_tracker_edit_pattern_follows_replay_pattern = !STConfig.b_node_tracker_edit_pattern_follows_replay_pattern;
      updateIgnorePrgChgAndFollowArr();
      if(STConfig.b_node_tracker_edit_pattern_follows_replay_pattern)
         Global.Print("Edit pattern follows replay pattern (\"follow arranger\")");
      else
         Global.Print("Edit pattern is independent of replay pattern");
   }

   public method cmd_replay_toggleignoreandfollow(boolean _bForce) {
      if(maybe == _bForce)
         _bForce = !STConfig.b_node_tracker_edit_pattern_follows_replay_pattern;

      // Called by pattern view lctrl-lshift-SPACE key handler
      if(_bForce)
      {
         STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay = false;
         STConfig.b_node_tracker_edit_pattern_follows_replay_pattern           = true;
      }
      else
      {
         STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay = true;
         STConfig.b_node_tracker_edit_pattern_follows_replay_pattern           = false;
      }
      updateIgnorePrgChgAndFollowArr();  // update menu entries
      Global.Print("Follow arranger is "+Utils.GetEnableString(STConfig.b_node_tracker_edit_pattern_follows_replay_pattern));
   }

   public =replay= method cmd_replay_clearmidicache() {
      current_pipe_root.clearMIDICache();

      Global.Print("Clear MIDI cache");
   }

   // // public method cmd_replay_mmcrec_autoreset() {
   // //    STConfig.b_node_tracker_midi_mmcrec_autoreset = !STConfig.b_node_tracker_midi_mmcrec_autoreset;

   // //    updateMMCRecAutoReset();

   // //    Global.Print("MMC Rec auto-reset is now "+Utils.GetEnableString(STConfig.b_node_tracker_midi_mmcrec_autoreset));
   // // }

   // <ui_cmd.png>
   // --------------------------------------------------------------------------
   // - cmd_track_xxx
   // --------------------------------------------------------------------------
   public method cmd_track_new_dlg() {
      dlg_newtrack.run(this);
   }

   public =replay= method cmd_track_new(String _trackName, boolean _bCloneLayout) {

      // // tracker_node.undoEmpty();
      tracker_node.undoBeginNested("cmd_track_new");
      tracker_node.undoTouchNodeState();

      NT_Track track <= tracker_node.newTrack(_trackName, pattern_view.getCurrentTrack(), _bCloneLayout);

      if( (tracker_node.tracks.numElements) >1)
      {
         // Not very efficient but WTH :)
         // Just move the new track up until it is placed directly after the current track
         int trackNr = pattern_view.getCurrentTrackNr();
         int newTrackNr = tracker_node.tracks.numElements -1;
         int numBubbles = (newTrackNr - trackNr);
         if(numBubbles > 1)
         {
            loop(numBubbles-1)
            {
               NT_Track l <= tracker_node.tracks[newTrackNr];
               NT_Track r <= tracker_node.tracks[newTrackNr - 1];
               int tmpTrackNr = l.track_nr;
               l.track_nr = r.track_nr;
               r.track_nr = tmpTrackNr;
               tracker_node.tracks.swap(newTrackNr, newTrackNr -1);
               newTrackNr--;
            }
         }
         pattern_view.moveCursorToStartOfNextTrack();
         pattern_view.moveCursorRight(); // select note cel
      }

      pattern_view.redrawAll();

      NT_TEL tel <= track.getTrackLayout();
      tel.handleCelAdded();

      tracker_node.undoEndNested("cmd_track_new");

      Global.Debug("CMD track_new("+_trackName+") OK. num tracks is now "+(tracker_node.tracks.numElements));

      Global.Success("cmd_track_new: Track added.");

      refocusDefault();
   }

   public method cmd_track_delete_dlg() {
      if( (tracker_node.tracks.numElements) > 0)
      {
         dlg_deletetrack.run(this);
      }
      else
      {
         Global.Debug("cmd_track_delete_dlg: nothing to delete.");
      }
   }

   public =replay= method cmd_track_delete(boolean _bUndoBeginEnd) {

      if(_bUndoBeginEnd)
         tracker_node.undoBeginNested("cmd_track_delete");

      tracker_node.undoTouchNodeState();

      int trackNr = pattern_view.getCurrentTrackNr();

      tracker_node.deleteTrack(trackNr);

      int newNumTracks = pattern_view.getNumTracks();
      if(trackNr >= newNumTracks)
         trackNr = newNumTracks - 1;
      if(trackNr >= 0)
         pattern_view.moveCursorToTrack(trackNr);

      // Adjust cursor if necessary
      pattern_view.selectNone();

      pattern_view.verifyTrackShift(true);

      pattern_view.cursorTrackChanged();
      pattern_view.queueRedrawAll();

      if(_bUndoBeginEnd)
         tracker_node.undoEndNested("cmd_track_delete");

      Global.Debug("cmd_track_delete: num tracks is now "+(tracker_node.tracks.numElements));

      Global.Success("cmd_track_delete: Track deleted.");

      refocusDefault();
   }

   public method cmd_track_moveleft() {
      if(Global.NotPlaying("track_moveleft"))
      {
         // // tracker_node.undoEmpty();

         int trackNr = pattern_view.getCurrentTrackNr();
         if(trackNr > 0)
         {
            tracker_node.undoBeginNested("track_moveleft");
            tracker_node.undoTouchNodeState();

            tracker_node.swapTracks(trackNr, trackNr-1);

            pattern_view.moveCursorToPreviousTrackX(false/*bAlignRight*/);////moveCursorToFirstColumnOrPreviousTrack();
            pattern_view.queueRedrawAll();
            pattern_view.selectNone();

            tracker_node.undoEndNested("track_moveleft");

            Global.Success("cmd_track_moveleft: Track moved left.");
         }
      }
   }

   public method cmd_track_moveright() {
      if(Global.NotPlaying("track_moveright"))
      {
         int trackNr = pattern_view.getCurrentTrackNr();

         if( trackNr < (tracker_node.tracks.numElements-1) )
         {
            tracker_node.undoBeginNested("track_moveright");
            tracker_node.undoTouchNodeState();

            tracker_node.swapTracks(trackNr, trackNr +1);

            pattern_view.moveCursorToNextTrackX();////moveCursorToStartOfNextTrack();
            pattern_view.queueRedrawAll();
            pattern_view.selectNone();

            tracker_node.undoEndNested("track_moveright");

            Global.Success("cmd_track_moveright: Track moved right.");
         }
      }
   }

   public method cmd_track_editlayout() {
      NT_TEL tel <= pattern_view.getCurrentTrackLayout();
      if(null != tel)
      {
         tracker_node.undoBeginNested("cmd_track_editlayout");  // ended when Dialog.ACTION_HIDE is recvd
         dlg_edit_track_layout.showTrackLayout(this, tel, pattern_view.getCurrentTrackNr());
      }
   }

   public method cmd_track_shownames() {
      NT_Track track <= pattern_view.getCurrentTrack();

      if(null != track)
      {
         STConfig.b_node_tracker_show_track_names ^= 1;

         updateShowTrackNames();

         pattern_view.redraw();

         Global.Print("cmd_track_shownames: Track names "+Utils.GetEnableString(STConfig.b_node_tracker_show_track_names)+".");
      }
   }

   public method cmd_track_rename() {
      pattern_view.editCurrentTrackName();
   }

   public method cmd_track_showeq() {
      NT_Track track <= pattern_view.getCurrentTrack();

      if(null != track)
      {
         STConfig.b_node_tracker_draweq = STConfig.b_node_tracker_draweq ^ 1;

         updateShowTrackEQ();

         pattern_view.redraw();

         Global.Print("cmd_track_showeq: Equalizers are now "+Utils.GetEnableString(STConfig.b_node_tracker_draweq)+".");
      }
   }

   public method cmd_track_togglemute() {
      if(tracker_node.solo_track_nr != -1)
      {
         // trace "xxx convert solo to mute ch.solo_track_nr="+ch.solo_track_nr;
         // Convert solo to mute
         int trackNr = 0;
         NT_Track *track;
         foreach track in tracker_node.tracks
         {
            if(trackNr != tracker_node.solo_track_nr)
               track.setMuted(true);
            trackNr++;
         }
         tracker_node.solo_track_nr = -1;
      }

      pattern_view.toggleMuteTrack();
   }

   public method cmd_track_togglesolo() {
      if(tracker_node.solo_track_nr == -1)
         tracker_node.setSoloTrackNr(pattern_view.getCurrentTrackNr());
      else
         tracker_node.setSoloTrackNr(-1);

      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
         track.setMuted(false);

      pattern_view.redraw();

      Global.Print("cmd_track_togglesolo: solo_track_nr set to "+tracker_node.solo_track_nr);
   }

   public method cmd_track_muteall(boolean _bMuted) {
      NT_Track *track;
      foreach track in tracker_node.tracks
         track.setMuted(_bMuted);

      if(!_bMuted)
         tracker_node.setSoloTrackNr(-1);

      pattern_view.renderAndRedrawAll();
   }

   public method cmd_track_randomdialog() {
      pattern_view.showRandomDialog();
   }

   public method cmd_track_lockkeyjazz() {
      NT_Track track <= pattern_view.getCurrentTrack();
      if(null != track)
      {
         boolean bLocked = track.toggleKeyJazzLock();

         updateLockKeyJazz();

         if(bLocked)
            Global.Print("KeyJazz is now locked to node #"+tracker_node.getNodeGID()+", track "+(track.track_nr+1));
         else
            Global.Print("KeyJazz lock is now released");
      }
   }

   public method cmd_track_editsound() {
      pattern_view.tryEditSound();
   }

   public method cmd_track_addcel_dlg() {
      dlg_manage_columns.showAdd(this);
   }

   public method cmd_track_addnotecel() {
      NT_TEL tel <= pattern_view.getCurrentTrackLayout();
      if(null != tel) // paranoia
      {
         if(tel.canAddNoteCel())
         {
            NT_CEL *cel;

            tracker_node.undoBeginNested("cmd_track_addnotecel");

            undoTouchCurrentTrackLayout(tel);

            int noteCelIdx = tel.addNoteCel();
            int noteNr     = tel.getCtlIdByCelIdx(noteCelIdx);

            if(STConfig.b_node_tracker_addnotecel_vel)
            {
               // Add velocity cel
               int lastVelCelIdx = tel.findLastNoteCtlCelIdx(NT_TrackPattern.CTL_VEL1, noteNr);

               if(-1 != lastVelCelIdx)
               {
                  tel.insertCEL(lastVelCelIdx);

                  cel <= tel.ctl_layouts[lastVelCelIdx+1];
                  cel.b_visible = true;
                  cel.ctl_id    = NT_TrackPattern.CTL_VEL1 + noteNr;
                  cel.bg_tint   = 0;
                  cel.style     = NT_CEL.STYLE_HEX;
                  cel.range     = NT_CEL.RANGE_0_127;
               }
            }

            if(STConfig.b_node_tracker_addnotecel_dur)
            {
               // Add duration cel
               int lastDurCelIdx = tel.findLastNoteCtlCelIdx(NT_TrackPattern.CTL_DUR1, noteNr);

               if(-1 != lastDurCelIdx)
               {
                  tel.insertCEL(lastDurCelIdx);

                  cel <= tel.ctl_layouts[lastDurCelIdx+1];
                  cel.b_visible = true;
                  cel.ctl_id    = NT_TrackPattern.CTL_DUR1 + noteNr;
                  cel.bg_tint   = 0;
                  cel.style     = NT_CEL.STYLE_HEX;
                  cel.range     = NT_CEL.RANGE_0_127;
               }
            }

            // Update noteCelIdx (might have changed after adding vel/dur cels)

            if(STConfig.b_node_tracker_addnotecel_autogroup)
            {
               tel.groupNoteVelDur();
               tel.toggleVelDurStyles(maybe, maybe);
               tel.toggleVelDurStyles(maybe, maybe);
            }

            cel <= tel.findVisibleCelForCtlById(noteNr);
            noteCelIdx = tel.getIdxByCel(cel);

            tel.calcCursorExtents();

            pattern_view.setCursorX(tel.calcCursorXByCelIdx(noteCelIdx));
            pattern_view.validateCursorX();

            pattern_view.cursorTrackChanged();
            pattern_view.verifyTrackShift(true);
            pattern_view.redrawAll();

            tracker_node.undoEndNested("cmd_track_addnotecel");

            Global.Success("cmd_track_addnotecel: Added note cel");
         }
      }
   }

   public method cmd_track_addnotecel_vel() {
      STConfig.b_node_tracker_addnotecel_vel = !STConfig.b_node_tracker_addnotecel_vel;

      pmcb_track_addnotecel_vel.setSelected(STConfig.b_node_tracker_addnotecel_vel);
      cb_addnotecel_vel.setSelected(STConfig.b_node_tracker_addnotecel_vel);

      Global.Print("Add note cel + vel is "+Utils.GetEnableString(STConfig.b_node_tracker_addnotecel_vel));
   }

   public method cmd_track_addnotecel_dur() {
      STConfig.b_node_tracker_addnotecel_dur = !STConfig.b_node_tracker_addnotecel_dur;

      pmcb_track_addnotecel_dur.setSelected(STConfig.b_node_tracker_addnotecel_dur);
      cb_addnotecel_dur.setSelected(STConfig.b_node_tracker_addnotecel_dur);

      Global.Print("Add note cel + dur is "+Utils.GetEnableString(STConfig.b_node_tracker_addnotecel_dur));
   }

   public method cmd_track_addnotecel_autogroup() {
      STConfig.b_node_tracker_addnotecel_autogroup = !STConfig.b_node_tracker_addnotecel_autogroup;

      pmcb_track_addnotecel_autogroup.setSelected(STConfig.b_node_tracker_addnotecel_autogroup);

      Global.Print("Auto-Group note cel vel + dur is "+Utils.GetEnableString(STConfig.b_node_tracker_addnotecel_autogroup));
   }

   public method cmd_track_autocolorizecels() {

      dlg_edit_track_layout.setEditor(this);

      dlg_edit_track_layout.tel <= pattern_view.getCurrentTrackLayout();

      if(null != dlg_edit_track_layout.tel)
      {
         tracker_node.undoBeginNested("cmd_track_autocolorizecels");
         // dlg_edit_track_layout.cmdCelColsGen();
         dlg_edit_track_layout.cmdCelColsGenToggle();
         tracker_node.undoEndNested("cmd_track_autocolorizecels");

         Global.Print("Toggle auto-colorize cels");
      }
   }

   public method cmd_track_removecel_dlg() {
      dlg_manage_columns.showRemove(this);
   }

   public method cmd_track_toggleveldurstyles() {
      tracker_node.undoBeginNested("toggleveldurstyles");
      NT_Track *track;
      boolean bBar = maybe;
      int cursorCelId = pattern_view.getCurrentCelId();
      foreach track in tracker_node.tracks
      {
         NT_TEL tel <= track.getTrackLayout();
         undoTouchCurrentTrackLayout(tel);
         bBar = tel.toggleVelDurStyles(bBar, bBar/*bNibble*/);
         STConfig.b_node_seq_tracker_vel_bars = bBar;
      }
      tracker_node.undoEndNested("toggleveldurstyles");
      pattern_view.validateCursorX();
      pattern_view.cursorTrackChanged();
      pattern_view.verifyTrackShift(true/*bAlignRight*/);
      pattern_view.moveCursorToCel(cursorCelId);
      pattern_view.queueRedrawAll();
      Global.Print("Toggle velocity+duration cel style(s)");
   }

   public method toggleveldurstyles_noundo(boolean _bBar, boolean _bNibble) {
      NT_Track *track;
      int cursorCelId = pattern_view.getCurrentCelId();
      foreach track in tracker_node.tracks
      {
         NT_TEL tel <= track.getTrackLayout();
         tel.toggleVelDurStyles(_bBar, _bNibble);
      }
      pattern_view.validateCursorX();
      pattern_view.cursorTrackChanged();
      pattern_view.verifyTrackShift(true/*bAlignRight*/);
      pattern_view.moveCursorToCel(cursorCelId);
      pattern_view.queueRedrawAll();
   }

   public method cmd_track_togglealtstyles() {
      tracker_node.undoBeginNested("togglealtstyles");
      NT_Track *track;
      int cursorCelId = pattern_view.getCurrentCelId();
      foreach track in tracker_node.tracks
      {
         NT_TEL tel <= track.getTrackLayout();
         undoTouchCurrentTrackLayout(tel);
         tel.toggleAltStyles();
      }
      tracker_node.undoEndNested("togglealtstyles");
      pattern_view.validateCursorX();
      pattern_view.cursorTrackChanged();
      pattern_view.verifyTrackShift(true/*bAlignRight*/);
      // trace "xxx movecursortocelid celId="+cursorCelId;
      pattern_view.moveCursorToCel(cursorCelId);
      pattern_view.queueRedrawAll();
      Global.Print("Toggle alternative cel style(s)");
   }

   public method cmd_track_managecolumns() {
      dlg_manage_columns.showManager(this);

      Global.Print("Show cel/ctl/param wizard");
   }

   public =replay= method cmd_track_reverse() {
      if(pattern_view.isEditable())
      {
         pattern_view.patternReverse(false/*bPattern*/);
         Global.Print("Reverse track");
      }
      else
      {
         Global.Warning("Reverse track failed: please change edit mode");
      }
   }

   public =replay= method cmd_track_rotate_up() {
      pattern_view.patternRotateUp(false/*bPattern*/);
   }

   public =replay= method cmd_track_rotate_down() {
      pattern_view.patternRotateDown(false/*bPattern*/);
   }



   // <ui_cmd.png>
   // --------------------------------------------------------------------------
   // - cmd_pattern_xxx
   // --------------------------------------------------------------------------
   public =replay= method cmd_pattern_alloc(boolean _bSub) {
      int patIdx;

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      boolean bPatEmpty = true;
      if(null != mpat)
      {
         bPatEmpty = mpat.patIsEmpty();
      }

      if(!bPatEmpty)
      {
         patIdx = -1;

         if(true == _bSub)
         {
            // Find unused A..D sub pattern
            patIdx = tracker_node.findFirstUnusedPatternSub(tracker_node.nodeGetCurrentEditPatternNr());
         }
         else if(false == _bSub)
         {
            // Find unused 1..32 pattern group
            patIdx = tracker_node.findFirstUnusedPatternGroup(tracker_node.nodeGetCurrentEditPatternNr());
         }

         if(-1 == patIdx)
         {
            // Find any unused pattern
            patIdx = tracker_node.findFirstUnusedPattern(tracker_node.nodeGetCurrentEditPatternNr());
         }

         if(-1 == patIdx)
         {
            // Find any unused pattern
            patIdx = tracker_node.findFirstUnusedPattern(0);
         }
      }
      else
      {
         patIdx = tracker_node.nodeGetCurrentEditPatternNr();
      }

      if(-1 != patIdx)
      {
         tracker_node.undoBeginNested("cmd_pattern_alloc");

         tracker_node.undoTouchPattern(patIdx);

         selectPatternByIdx(patIdx);

         mpat <= tracker_node.getOrCreateMetaPattern(patIdx);

         int patLen = fp_patlen.getFloatValue() * fp_stepresolution.getFloatValue();
         if(0 == patLen)
         {
            patLen = current_song.ppq * 4;
         }

         mpat.setNumTicks(patLen);

         // seq.setPattern(patIdx, deref p);

         // seq.nodeSetCurrentPatternNr(patIdx);
         /////cm_patnr.setSelectedOption(patIdx);
         updatePatNr();
         // // cm_patnr.redraw();

         updatePatLen();
         updatePatName();

         pattern_view.redrawAll();

         tracker_node.undoEndNested("cmd_pattern_alloc");

         Global.Success("Allocated pattern "+cm_patnr.getSelectedOptionName()+" ("+patIdx+").");
         return true;
      }
      else
      {
         Global.Error("All patterns in use.");
         return false;
      }
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_clone(boolean _bSub) {

      tracker_node.undoBeginNested("cmd_pattern_clone");

      cmd_pattern_copy(false/*bInvBlock*/);

      if(cmd_pattern_alloc(_bSub))
      {
         cmd_pattern_paste();

         Global.Print("Pattern cloned");
      }

      tracker_node.undoEndNested("cmd_pattern_clone");
   }

   protected =replay= method cmd_pattern_free_ex(boolean _bFreeMeta, boolean _bUndoBegin, boolean _bUndo) {

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      if(!mpat.b_empty)
      {
         if(_bUndoBegin)
            tracker_node.undoBeginNested("cmd_pattern_free");

         if(_bUndo)
            tracker_node.undoTouchPattern(mpat.pat_nr);

         if(_bFreeMeta)
         {
            mpat.patInit(tracker_node, mpat.pat_nr); // re-init
         }

         tracker_node.nodeFreePatternTrackData(mpat.pat_nr);

         handlePatNrChanged(true/*bRefocusPattern*/);

         if(_bFreeMeta)
         {
            pattern_view.gotoPatPosition(0, false/*bClip*/);
         }

         if(_bUndoBegin)
            tracker_node.undoEndNested("cmd_pattern_free");

         if(_bFreeMeta)
         {
            Global.Print("Pattern deleted");
         }
         else
         {
            Global.Print("Pattern cleared");
         }
      }

   }

   public method cmd_pattern_free(boolean _bFreeMeta, boolean _bUndoBegin) {
      Global.Debug("NT: cmd_pattern_free");
      cmd_pattern_free_ex(_bFreeMeta, _bUndoBegin, true/*bUndo*/);
   }

   public method cmd_pattern_free_no_undo(boolean _bFreeMeta) {
      Global.Debug("NT: cmd_pattern_free_no_undo");
      cmd_pattern_free_ex(_bFreeMeta, false/*bUndoBegin*/, false/*bUndo*/);
   }

   public =replay= method cmd_pattern_copy(boolean _bInvBlock) {
      Global.Debug("NT: cmd_pattern_copy");

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();
      // trace "xxx cmd_pattern_copy: mpat="+#(mpat);
      mpat.patCopyToClipboard();

      if(_bInvBlock)
      {
         // When lctrl-c fallback is used
         NodeTracker.InvalidateBlockClipboard();
      }

      tracker_node.last_copied_pattern_nr = tracker_node.nodeGetCurrentEditPatternNr();

      Global.Print("Pattern copied to clipboard");
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_paste() {
      Global.Debug2("NT: cmd_pattern_paste");

      tracker_node.undoBeginNested("cmd_pattern_paste");

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      tracker_node.undoTouchPattern(mpat.pat_nr);

      mpat.patCopyFromClipboard();

      handlePatNrChanged(true/*bRefocusPattern*/);

      tracker_node.undoEndNested("cmd_pattern_paste");

      Global.Print("Pattern copied from clipboard");
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_capture_begin() {
      // (note) capture stops when replay is stopped
      mon_capture.captureBegin();
      tracker_node.b_capture = true;
      Global.Print("Start output capture");
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_capture_paste() {

      Global.Debug("---------------------------------------- cmd_pattern_capture_paste");

      // Lazy-stop replay
      if(replay.b_playing)
         root_form.handleToggleReplay(false/*bSendMMC*/);

      NM_Pattern patMon <= mon_capture.nodeGetCurrentEditPattern();
      // trace "xxx 1 cmd_pattern_capture_paste: patMon.numFrames="+patMon.getNumFrames();
      patMon.noteOffsToDuration();
      // trace "xxx 2 cmd_pattern_capture_paste: patMon.numFrames="+patMon.getNumFrames();

      // Set pattern length to (beat-aligned) monitor pattern duration
      int numTicksPerBeat = current_song.beatsOrBarsToTicks(-1/*1 beat*/);
      // int recNumTicks = (int(mon_capture.tick_nr) + numTicksPerBeat-1);  // align to beat end
      int recNumTicks = (int(mon_capture.tick_nr));  // align to beat start
      recNumTicks = int(recNumTicks / numTicksPerBeat) * numTicksPerBeat;
      if(0 == recNumTicks)
      {
         Global.Error("Capture buffer too short (<1 beat)");
         return;
      }

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();
      if(null == mpat)
      {
         cmd_pattern_alloc(false/*bSub*/);
         mpat <= tracker_node.getCurrentEditMetaPattern();
      }

      if(null != mpat)
      {
         if(mpat.patIsEmpty())
            cmd_pattern_alloc(false/*bSub*/);
         else
            pattern_view.patternClear();
         pattern_view.moveCursorToStart();

         cmd_pattern_import_monitor_handle_ok(patMon,
                                              false/*bForceReInit*/,
                                              true/*bForceMulti*/,  // match track instr + record all tracks
                                              true/*bCreateInstrumentsAndParams*/,
                                              false/*bConvRPNPC*/,
                                              false/*bPreferCTLPC*/,
                                              false/*bCopyPatName*/,
                                              true/*bResetRec*/,    // assume note-on duration (no explicit note-offs)
                                              true/*bAlignBars*/,
                                              false/*bExplode*/,
                                              true/*bUndo*/
                                              );
         // // mpat.num_ticks = recNumTicks;  // already set by cmd_pattern_import_monitor_handle_ok()

         pattern_view.redrawAll();
         updatePatLen();
      }
      else
         Global.Error("Failed to paste capture buffer (no pattern)");
   }

   // <ui_cmd.png>
   protected =replay= method cmd_pattern_capture_upload_to_eureka_sync(NT_Instrument _ins) : boolean {
      Global.Debug("---------------------------------------- cmd_pattern_capture_upload_to_eureka");
      // Lazy-stop replay
      if(replay.b_playing)
         root_form.handleToggleReplay(false/*bSendMMC*/);
      
      NM_Pattern patMon <= mon_capture.nodeGetCurrentEditPattern();
      patMon.noteOffsToDuration();
      
      int numFrames = patMon.getNumFrames();
      if(numFrames > 0)
      {
         Global.Debug2("upload: patMon.b_tick_timebase="+patMon.b_tick_timebase+" numFrames="+numFrames);
         local File f;
         local String nativePathname = Utils.ToNativePathName(STConfig.temp_proc_track_seq_file);
         if(f.openLocal(nativePathname, IOS_OUT))
         {
            int frIdx = 0;
            f.i32 = _ins.smp_uid;
            f.i32 = numFrames;
            int totalNumEv = 0;
            int tickOff = 0;

            loop(numFrames)
            {
               MIDIPipeFrame frMonIns <= patMon.getReplayFrameByIdx(frIdx);

               // (note) event device indices are ignored (will be redirected to Sample source track)
               f.i32 = frIdx;
               frMonIns.saveState(f);
               int numEv = frMonIns.numEvents;
               tickOff += frMonIns.timeStamp;
               trace "xxx upload: frame["+frIdx+"] timeStamp="+frMonIns.timeStamp+" numEv="+numEv+" tickOff="+tickOff;
               totalNumEv += numEv;

               frIdx++;
            }

            f.close();

            if(SysEx.IsAudioConnected())
            {
               SysEx.QueueSendSmpUploadSeq(_ins.smp_uid);
                     
               local String msg <= "Upload "+numFrames+" proc.track sample seq frame"+Utils.GetPluralString(numFrames)+" ("+totalNumEv+" event"+Utils.GetPluralString(totalNumEv)+") (smpUID="+_ins.smp_uid+")";
               Global.Print(msg);
               trace "[dbg] "+msg;

               // Succeeded
               return true;
            }
            else
            {
               Global.Error("Upload seq: audio host is not connected");
            }
         }
         else
         {
            Global.Error("Failed to open \""+nativePathname+"\" for writing");
         }
      }
      else
      {
         Global.Warning("Upload seq: capture buffer is empty");
      }
   }

   public method cmd_pattern_capture_upload_to_eureka() : boolean {
      NT_Instrument ins <= instrument_view.getSelectedInstrument();
      if(null != ins)
      {
         if(ins.smp_uid >= 0)
         {
            if(cmd_pattern_capture_upload_to_eureka_sync(ins))
            {
               return SysEx.WaitForSmpUploadSeqAck(ins.smp_uid);
            }
         }
         else
         {
            Global.Warning("Upload seq: invalid smpUID="+ins.smp_uid+" in selected instrument");
         }
      }
      else
      {
         Global.Warning("Upload seq: no instrument selected in instrument view");
      }
      return false;
   }

   // <ui_cmd.png>
   protected =replay= method cmd_pattern_capture_download_from_eureka_sync(NT_Instrument _ins) : boolean {
      Global.Debug("---------------------------------------- cmd_pattern_capture_download_from_eureka");

      Global.Debug("cmd_pattern_capture_download_from_eureka: smpUID="+_ins.smp_uid);
      local File f;
      local String nativePathname = Utils.ToNativePathName(STConfig.temp_proc_track_seq_file);
      if(f.openLocal(nativePathname, IOS_IN))
      {
         int smpUID = f.i32;
         if(smpUID == _ins.smp_uid)
         {
            int numFrames = f.i32;
            int totalNumEv = 0;
            if(numFrames < 16384)
            {
               IntArray vstDeviceIndices <= MIDI.FindVSTDeviceIndices();

               cmd_pattern_capture_begin();

               local MIDIPipeFrame fr;
               int frIdx = 0;
               loop(numFrames)
               {
                  int frIdxFile = f.i32;

                  if(frIdxFile == frIdx)
                  {
                     fr.empty();

                     if(!fr.loadState(f))
                     {
                        trace "[---] cmd_pattern_capture_download_from_eureka: loadState() failed (frame "+(frIdx+1)+"/"+numFrames+")";
                        f.close();
                        return false;
                     }

                     int vstDevIdx = 0;
                     loop(MIDI.MAX_LOCALMIDI_OUTPUTS)
                     {
                        fr.replaceDevIdxAndMidiCh(vstDevIdx, -1/*fltCh*/,
                                                  vstDeviceIndices.get(vstDevIdx), -1/*ch=keep*/
                                                  );
                        vstDevIdx++;
                     }

                     mon_capture.tick_nr = fr.timeStamp;
                     mon_capture.captureAdd(fr, true/*bAdvance*/);

                     int numEv = fr.numEvents;
                     totalNumEv += numEv;
                     trace "[trc] cmd_pattern_capture_download_from_eureka: read frame "+(frIdx+1)+"/"+numFrames+" timeStamp="+fr.timeStamp+" numEv="+numEv;
                  }
                  else
                  {
                     Global.Error("cmd_pattern_capture_download_from_eureka: frame idx mismatch. expect="+frIdx+" frIdxFile="+frIdxFile);
                     f.close();
                     return false;
                  }

                  // Next frame
                  frIdx++;
               }

               // Succeeded
               local String msg <= "download "+numFrames+" frame"+Utils.GetPluralString(numFrames)+", totalNumEv="+totalNumEv+" to capture buffer";
               Global.Debug("cmd_pattern_capture_download_from_eureka: "+msg);
               f.close();

               Global.Success(msg);

               return true;
            }
            else
            {
               Global.Error("cmd_pattern_capture_download_from_eureka: insane numFrames="+numFrames);
            }
         }
         else
         {
            Global.Error("cmd_pattern_capture_download_from_eureka: smpUID mismatch. ins.smp_uid="+_ins.smp_uid+" tmpFile="+smpUID);
         }
         f.close();
      }
      else
      {
         Global.Error("cmd_pattern_capture_download_from_eureka: failed to open \""+nativePathname+"\" for reading");
      }
      return false;
   }

   protected method cmd_pattern_capture_download_from_eureka() : boolean {
      NT_Instrument ins <= instrument_view.getSelectedInstrument();
      if(null != ins)
      {
         if(ins.smp_uid >= 0)
         {
            SysEx.QueueSendSmpDownloadSeq(ins.smp_uid);
            if(SysEx.WaitForSmpDownloadSeqReply(ins.smp_uid))
            {
               if(cmd_pattern_capture_download_from_eureka_sync(ins))
               {
                  return true;
               }
            }
         }
         else
         {
            Global.Warning("Download seq: invalid smpUID="+ins.smp_uid+" in selected instrument");
         }
      }
      else
      {
         Global.Warning("Download seq: no instrument selected in instrument view");
      }
      return false;
   }

   // <ui_cmd.png>
   public method cmd_pattern_capture_ticks() {
      STConfig.b_node_monitor_capture_tick_timebase = !STConfig.b_node_monitor_capture_tick_timebase;
      pmcb_pattern_capture_ticks.setSelected(STConfig.b_node_monitor_capture_tick_timebase);
      Global.Print("Output-Capture time base is "+(STConfig.b_node_monitor_capture_tick_timebase?"ticks":"milliseconds"));
   }

   // <ui_cmd.png>
   public method cmd_pattern_split(boolean _bPasteNewPattern) {
      pattern_view.splitPatternToClipboard(_bPasteNewPattern);
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_import_ar() {
      dlg_import_ar.setRecipient(this);
      dlg_import_ar.show();
   }

   public =replay= method cmd_pattern_import_ar_handle_ok() {
      Global.Debug("NodeTrackerEditor: import AR pattern");

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      if(null == mpat)
      {
         Global.Error("ImportAR: please create a pattern, first.");
         return;
      }

      tracker_node.undoBeginNested("import_ar");

      AR_Pattern arPat <= dlg_import_ar.ar_import_pattern;
      if(arPat.version < 5)
      {
         Global.Error("ImportAR: need version 5, have "+arPat.version);
         return;
      }

      NT_Instrument *ins;
      STX_MIDIOutDevice *dev;
      NT_Track *track;
      String *s;
      NT_TrackPattern *trackPat;
      Envelope *envNote;
      Envelope *envVel;
      int stepIdx;
      float tickOff;
      float tickStepDelta;
      String insName;
      String trkName;
      int trackIdx;

      boolean bDoSingleCh    = dlg_import_ar.doSingleCh();
      boolean bDoConditional = dlg_import_ar.doConditional();

      if(dlg_import_ar.doClearPattern())
      {
         cmd_pattern_free(false/*bFreeMeta*/, false/*bUndoBegin*/);

         while((tracker_node.tracks.numElements) > 0)
         {
            cmd_track_delete(false/*bUndoBeginEnd*/);
         }
      }

      if(dlg_import_ar.doClearInstruments())
      {
         int instrNr = 0;
         foreach ins in tracker_node.instruments
         {
            tracker_node.setInstrument(instrNr, null);
            instrNr++;
         }
      }

      if(dlg_import_ar.doCreateInstruments())
      {
         trackIdx = 0;

         dev <= MIDI.GetFirstMIDIOutDeviceByProfileId("analogrytm_track"); // magic name, must match synth profile id

         // Regular tracks
         loop(bDoSingleCh ? 1 : 12)
         {
            if(bDoSingleCh)
               insName = "Analog Rytm";
            else
               insName = ((NAR_Defs.track_names_short.get(trackIdx)).toLower())+" "+(trackIdx+1);
            ins <= tracker_node.findInstrumentByPartialName(insName);

            if(null == ins)
            {
               Global.Debug2("NodeTrackerEditor::ImportAR: creating instrument \""+insName+"\"");
               ins <= instrument_view.createNewInstrument(-1);
               if(null != ins)
               {
                  ins.name         = insName;
                  ins.out_device  <= dev;
                  ins.midi_channel = trackIdx;
               }
               else
               {
                  Global.Error("ImportAR: All instruments in use!");
                  tracker_node.undoEndNested("import_ar");
                  return;
               }
            }
            else
            {
               Global.Debug2("NodeTrackerEditor::ImportAR: instrument \""+insName+"\" already exists, skipping");
            }

            trackIdx++;
         }

         // FX track
         if(!bDoSingleCh)
         {
            insName = "fx 13";
            ins <= tracker_node.findInstrumentByPartialName(insName);

            if(null == ins)
            {
               Global.Debug2("NodeTrackerEditor::ImportAR: creating instrument \""+insName+"\"");
               dev <= MIDI.GetFirstMIDIOutDeviceByProfileId("analogrytm_fx"); // magic name, must match synth profile id
               ins <= instrument_view.createNewInstrument(-1);

               if(null != ins)
               {
                  ins.name = insName;
                  ins.out_device <= dev;
                  ins.midi_channel = 12;
               }
               else
               {
                  Global.Error("ImportAR: All instruments in use!");
                  tracker_node.undoEndNested("import_ar");
                  return;
               }
            }
            else
            {
               Global.Debug2("NodeTrackerEditor::ImportAR: instrument \""+insName+"\" already exists, skipping");
            }
         }
      }

      if(dlg_import_ar.doTracks())
      {
         trackIdx = 0;
         loop(bDoSingleCh ? 12 : 13/*with fx*/)
         {
            trkName = NAR_Defs.track_names_short.get(trackIdx).toLower();
            track <= tracker_node.findTrackByPartialName(trkName);
            if(null == track)
            {
               Global.Debug2("NodeTrackerEditor::ImportAR: creating track \""+trkName+"\"");
               track <= tracker_node.newTrack(trkName, null/*curTrack*/, false/*bCloneLayout*/);

               if(null == track)
               {
                  Global.Error("ImportAR: failed to create track!");
                  tracker_node.undoEndNested("import_ar");
                  return;
               }
            }
            else
            {
               Global.Debug2("NodeTrackerEditor::ImportAR: track \""+trkName+"\" already exists, skipping");
            }
            trackIdx++;
         }
      }

      // (note) all instruments and tracks exist now

      //int arLen = raw.peekI8(0x337d); // does not work in recent OS (used to work in older OS)
      int arLen = arPat.masterLength;
      if(1/*inf*/ == arLen)
      {
         // Find max track len
         trackIdx = 0;
         loop(13)
            arLen = mathMaxi(arLen, arPat.getNumSteps(trackIdx++));
      }

      // // int arSpd = raw.peekI8((3 == patVer) ? 0x3390 : 0x3383);
      int arSpd = arPat.masterSpeed & 7;

      Global.Debug2("NodeTrackerEditor::ImportAR: pattern length is "+arLen);
      Global.Debug2("NodeTrackerEditor::ImportAR: pattern speed is "+arSpd);

      if(dlg_import_ar.doLength())
      {
         float metaTicks = (current_song.ppq / 4.0) * arLen;
         switch(arSpd)
         {
            case 0: // 2x
               metaTicks /= 2;
               break;

            case 1: // 3/2x
               metaTicks /= (3.0 / 2.0f);
               break;

            case 2: // 1x
            case 7: // 1x
               break;

            case 3: // 3/4x
               metaTicks /= (3.0 / 4.0f);
               break;

            case 4: // 1/2x
               metaTicks *= 2;
               break;

            case 5: // 1/4x
               metaTicks *= 4;
               break;

            case 6: // 1/8x
               metaTicks *= 8;
               break;
         }
         mpat.setNumTicks(int(metaTicks));
         updatePatLen();
      }

      int patLenTicks = mpat.getNumTicks();

      // Utils.HexDump(raw, 0, raw.size);

      if(dlg_import_ar.doNotes())
      {
         boolean bDoVel    = dlg_import_ar.doVelocities();
         boolean bDoAccent = dlg_import_ar.doAccents();
         boolean bDoDur    = dlg_import_ar.doDurations();
         boolean bDoMicro  = dlg_import_ar.doMicroTimings();

         // // trackOff = 0x4; // offset to first track in pattern data

         // (note) also see libanalogrytm/pattern.h
         trackIdx = 0;
         loop(bDoSingleCh ? 12 : 13/*with fx*/)
         {
            // // tickStepDelta = float(patLenTicks) / arLen;
            tickStepDelta = (current_song.ppq / 4.0);
            switch(arPat.getFlagsAndSpeed(trackIdx) & 7)
            {
               case 0: // 2x
                  tickStepDelta /= 2;
                  break;

               case 1: // 3/2x
                  tickStepDelta /= (3.0 / 2.0f);
                  break;

               case 2: // 1x
               case 7:
                  break;

               case 3: // 3/4x
                  tickStepDelta /= (3.0 / 4.0f);
                  break;

               case 4: // 1/2x
                  tickStepDelta *= 2;
                  break;

               case 5: // 1/4x
                  tickStepDelta *= 4;
                  break;

               case 6: // 1/8x
                  tickStepDelta *= 8;
                  break;
            }

            // // byte arDefNote = raw.peekI8(trackOff + 0x240);
            // // byte arDefVel  = raw.peekI8(trackOff + 0x241);
            // // byte arDefDur  = raw.peekI8(trackOff + 0x242);

            byte arDefNote = arPat.getDefaultNote(trackIdx);
            byte arDefVel  = arPat.getDefaultVelocity(trackIdx);
            byte arDefDur  = arPat.getDefaultNoteLength(trackIdx);

            trkName = NAR_Defs.track_names_short.get(trackIdx).toLower();
            track <= tracker_node.findTrackByPartialName(trkName); // must exist (see above)

            trackPat <= track.getOrCreatePattern(mpat.pat_nr);

            // // envNote <= trackPat.getCreateEnvelope(NT_TrackPattern.CTL_NOTE1);

            if(bDoSingleCh)
               insName = "Analog Rytm";
            else
               insName = (NAR_Defs.track_names_short.get(trackIdx).toLower())+" "+(trackIdx+1);

            ins <= tracker_node.findInstrumentByPartialName(insName); // must exist (see above)

            pattern_view.moveCursorToTrack(trackIdx);
            keyJazzSelectInstrument(ins.instrument_nr, false/*bMakeVisible*/, true/*bQuiet*/);

            int stepIdxMaster = 0;
            tickOff = 0.0;

            loop(arLen)
            {
               stepIdx = stepIdxMaster % arPat.getNumSteps(trackIdx);

               short arTrigFlags = arPat.getTrig(trackIdx, stepIdx);
               byte  arNoteEvRaw = arPat.getStepNote(trackIdx, stepIdx);
               byte  arNoteEv    = arNoteEvRaw & 127;
               byte  tickShift   = arPat.getStepMicroTiming(trackIdx, stepIdx);  // -23..23  (1/384 ticks)
               // if(0 == trackIdx)
               //    trace "xxx tickShift="+tickShift+" noteRaw="+arNoteEvRaw+" note="+arNoteEv;
               byte  arVelEv     = arPat.getStepVelocity(trackIdx, stepIdx);
               byte  arDurEv     = arPat.getStepNoteLength(trackIdx, stepIdx);

               tickShift &=    0b00111111;
               if(tickShift &  0b00100000)
                  tickShift |= 0b11000000 | (0xFFFFFF << 8);  // extend sign

               if(0 == trackIdx)
               {
                  Integer io = arTrigFlags;
                  trace " trk1 step["+stepIdx+"] trigFlags="+io.printf("%04x")+" arNoteEv&127="+arNoteEv+" arNoteEv="+arNoteEvRaw+" arVelEv="+arVelEv+" arDurEv="+arDurEv+" utimeShift="+tickShift;
               }

               // trace "xxx arNoteEv["+stepIdx+"] = "+arNoteEv;

               if(arPat.getTrigEnable(trackIdx, stepIdx) && !arPat.getTrigless(trackIdx, stepIdx))
               {
                  int evTick;

                  if(bDoMicro)
                  {
                     tickShift = tickShift * (current_song.ppq / 96.0)/*hardcoded in AR, smallest delay is 1/384 note*/;
                     evTick = int(tickOff + tickShift);
                     if(evTick < 0)
                        evTick += patLenTicks;
                  }
                  else
                     evTick = tickOff;

                  byte evNote;

                  // if( (128 == (arNoteEvRaw&128)) || bDoConditional )
                  // {
                  if(bDoSingleCh)
                  {
                     evNote = trackIdx;  // C0..B0
                  }
                  else if(255 == arNoteEvRaw) // default note (mask out trig cond flag) ?
                  {
                     evNote = (12*3) + arDefNote - 0x3c/*60*/;
                  }
                  else
                  {
                     evNote = (12*3) + arNoteEv - 0x3C/*60*/;
                  }

                  tracker_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_NOTE1,
                                                            evNote,
                                                            evTick,
                                                            1/*raster*/
                                                            );

                  if(bDoVel)
                  {
                     byte evVel = (255 == arVelEv) ? arDefVel : arVelEv;
                     if(evVel < 1)
                        evVel = 1;

                     if(bDoAccent)
                     {
                        if(arPat.getTrigAccent(trackIdx, stepIdx))
                        {
                           evVel += 32;
                           if(evVel > 127)
                              evVel = 127;
                        }
                     }

                     tracker_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_VEL1,
                                                               evVel,
                                                               evTick,
                                                               1/*raster*/
                                                               );
                  }

                  if(bDoDur)
                  {
                     float evDur = (255 == arDurEv) ? arDefDur : arDurEv;
                     evDur = (float(current_song.ppq/4.0) * (NAR_Defs.note_dur_tbl.get(evDur))) / tracker_node.dur_ticks;
                     tracker_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_DUR1,
                                                               evDur,
                                                               evTick,
                                                               1/*raster*/
                                                               );
                  }
               }

               stepIdxMaster++;
               tickOff += tickStepDelta;
            }

            // Next track
            trackIdx++;
         }
      }

      pattern_view.moveCursorToTrack(0);

      tracker_node.undoEndNested("import_ar");

      pattern_view.redrawAll();
   }

   // <ui_cmd.png>
   public method cmd_pattern_import_trigseq() {
      dlg_import_trigseq.setRecipient(this);
      dlg_import_trigseq.show();
   }

   public =replay= method cmd_pattern_import_trigseq_handle_ok() {
      Global.Debug("NodeTrackerEditor: import TrigSeq pattern");

      if(Global.NotPlaying("import_trigseq"))
      {
         NTS_Pattern patNTSCB <= NodePattern.PatGetClipboardForClass("NTS_Pattern");

         if(null != patNTSCB)
         {
            Global.Debug2("import_trigseq: parent_gid="+patNTSCB.parent_gid);
            NodeTrigSeq nts <= current_song.findNodeByGID(patNTSCB.parent_gid);
            Global.Debug2("import_trigseq: ==> nts="+#(nts));

            NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

            if(null == mpat)
            {
               Global.Error("ImportTrigSeq: please create a pattern, first.");
               return;
            }

            NTS_Pattern patNTS <= nts.nodeGetCurrentPlayPattern();

            if(null != patNTS)
            {
               // // int patNTSTicks = patNTS.getMaxTicks();
               int patNTSTicks = nts.nodeGetPatternNumTicks(patNTS.pat_nr);

               trace "xxx import_trigseq: patNTSTicks="+patNTSTicks;

               boolean bFail = false;

               // Clear current pattern
               if(dlg_import_trigseq.doClear())
               {
                  // // cmd_pattern_free(false/*bFreeMeta*/, false/*bUndoBegin*/);

                  // Free tracks
                  //   (note) currently needs its own undo entry (todo) include in import transaction
                  while((tracker_node.tracks.numElements) > 0)
                  {
                     cmd_track_delete(true/*bUndoBeginEnd*/);
                  }
               }

               tracker_node.undoBeginNested("cmd_pattern_import_trigseq");

               // Set pattern length
               if(dlg_import_trigseq.doLength())
               {
                  mpat.num_ticks = patNTSTicks * dlg_import_trigseq.getNumLoops();
                  updatePatLen();
               }

               // Lazy create tracks and instruments
               NTS_Track *trackNTS;
               NT_Track *track;
               NT_Instrument *ins;

               local int totalNumNO;
               local int totalNumPAT;
               local int totalNumCAT;
               local int totalNumCC;
               local int totalNumPC;
               local int totalNumPB;
               local int totalNumRPN;
               local int totalNumNRPN;

               foreach trackNTS in patNTS.tracks
               {
                  if( (trackNTS.getNumTrigs() > 0) || dlg_import_trigseq.doEmpty() )
                  {
                     track <= tracker_node.lazyCreateTrackByName((trackNTS.track_nr+1)+"_"+trackNTS.name);

                     Global.Debug2("import_trigseq: lazyCreateTrackByName: track="+#(track));

                     if(null != track)
                     {
                        //ins <= tracker_node.lazyCreateInstrumentByDevCh(nts.out_dev_idx, trackNTS.getOutCh(nts, patNTS), "trigseq");
                        ins <= tracker_node.lazyCreateInstrumentByDevChAndName(trackNTS.getOutDevIdx(nts), trackNTS.getOutCh(nts, patNTS), (trackNTS.track_nr+1)+"_"+trackNTS.name);
                        Global.Debug2("import_trigseq: lazyCreateInstrumentByDevChAndName(dev="+trackNTS.getOutDevIdx(nts)+" ch="+trackNTS.getOutCh(nts, patNTS)+"): ins="+#(ins));

                        if(null != ins)
                        {
                           // // if(ins.name == "trigseq")
                           // // {
                           // //    ins.name = trackNTS.name;
                           // // }

                           track.current_instrument_nr = ins.instrument_nr;
                           track.keyjazz_instr_nr = ins.instrument_nr;
                        }
                        else
                           bFail = true;
                     }
                     else
                        bFail = true;
                  }
               }

               local MIDIPipeFrame frEmpty;
               local MIDIPipeFrame fr;
               local MIDIPipeEvent pipeEv;
               local Float retCtlVal;
               NT_MIDIParam *param;

               foreach trackNTS in patNTS.tracks
               {
                  local IntArray noteState;
                  noteState.allocAndFill(NT_Defs.NUM_NOTESLOTS, -1);

                  if(trackNTS.getNumTrigs() > 0)
                  {
                     track <= tracker_node.findTrackByName((trackNTS.track_nr+1)+"_"+trackNTS.name);

                     if(null != track)
                     {
                        NT_TEL tel <= track.getTrackLayout();
                        NT_CEL *cel;
                        pattern_view.moveCursorToTrack(track.track_nr);

                        nts.nodeSeek(0);
                        int tickNr = 0;

                        // (note) use previously created instrument (see above)
                        ins <= tracker_node.getInstrument(track.keyjazz_instr_nr);

                        if(null != ins)
                        {
                           instrument_view.selectKeyJazzInstr(true/*bCenter*/);

                           loop(patNTSTicks * dlg_import_trigseq.getNumLoops())
                           {
                              fr.empty();
                              trackNTS.tick(fr,
                                            false/*bMuted*/,
                                            true/*bPlaySeq*/,
                                            nts,
                                            patNTS
                                            );
                              // // nts.nodeProcessFrame(fr/*framePlay*/,
                              // //                      frEmpty/*frameRec*/,
                              // //                      false/*bMuted*/,
                              // //                      true/*bPlaySeq*/
                              // //                      );

                              int evIdx;
                              int noteIdx;

                              if(fr.hasEvents())
                              {
                                 // Global.Debug2("import_trigseq: trk"+trackNTS.track_nr+"["+tickNr+"]: fr.numEvents="+fr.numEvents);

                                 // Note
                                 if(fr.numEventsNoteOn > 0)
                                 {
                                    noteIdx = 0;
                                    loop(NT_Defs.NUM_NOTESLOTS)
                                    {
                                       if(fr.getEventByIdx(noteIdx/*evIdx*/, pipeEv, MIDIPIPE_EVENT_TYPE_NOTE_ON))
                                       {
                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_INSTR,
                                                                               ins.instrument_nr,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );

                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_NOTE1 + noteIdx,
                                                                               pipeEv.note,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          noteState[noteIdx] = pipeEv.note;

                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_VEL1 + noteIdx,
                                                                               pipeEv.velocity,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );

                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_DUR1 + noteIdx,
                                                                               pipeEv.duration / tracker_node.dur_ticks,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          totalNumNO++;

                                          noteIdx++;
                                       }
                                       else
                                          break;
                                    }

                                    // trace "xxx import_trigseq: trk"+trackNTS.track_nr+"["+tickNr+"]:    fr.numEventsNoteOn="+fr.numEventsNoteOn;
                                 }

                                 // Poly Pressure
                                 //  (todo) support alternate dev/ch (create new instrument ?)
                                 if(fr.numEventsPolyPressure > 0)
                                 {
                                    evIdx = 0;
                                    loop(NT_Defs.NUM_NOTESLOTS)
                                    {
                                       if(fr.getEventByIdx(evIdx, pipeEv, MIDIPIPE_EVENT_TYPE_POLYPRESSURE))
                                       {
                                          if( (ins.getOutDeviceIdx() == pipeEv.devIdx) && (ins.midi_channel == pipeEv.midiCh) )
                                          {
                                             // Find note slot
                                             noteIdx = noteState.indexOf(pipeEv.polyPressureNote, 0);
                                             if(-1 != noteIdx)
                                             {
                                                tracker_node.insertReplaceEventAtRes(track,
                                                                                     NT_TrackPattern.CTL_POLYAT1 + noteIdx,
                                                                                     pipeEv.polyPressureValue,
                                                                                     tickNr,
                                                                                     1/*res*/
                                                                                     );
                                                totalNumPAT++;
                                             }
                                          }
                                          else
                                          {
                                             // Cannot import (note is unknown)
                                             trace "[~~~] import_trigseq: polypressure dev or ch differs from track/ins output dev or ch (skipping..)";
                                          }
                                       }
                                       else
                                          break;
                                       evIdx++;
                                    }
                                 }

                                 // Channel pressure
                                 if(fr.numEventsChPressure > 0)
                                 {
                                    if(fr.getEventByIdx(0/*evIdx*/, pipeEv, MIDIPIPE_EVENT_TYPE_CHPRESSURE))
                                    {
                                       if( (ins.getOutDeviceIdx() == pipeEv.devIdx) && (ins.midi_channel == pipeEv.midiCh) )
                                       {
                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_AT,
                                                                               pipeEv.chPressure,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          totalNumCAT++;
                                       }
                                       else
                                       {
                                          //  (todo) support alternate dev/ch (create new instrument or param ?)
                                          trace "[~~~] import_trigseq: chpressure dev or ch differs from track/ins output dev or ch (skipping..)";
                                       }
                                    }
                                 }

                                 // Pitchbend
                                 if(fr.numEventsPitchbend > 0)
                                 {
                                    if(fr.getEventByIdx(0/*evIdx*/, pipeEv, MIDIPIPE_EVENT_TYPE_PITCHBEND))
                                    {
                                       if( (ins.getOutDeviceIdx() == pipeEv.devIdx) && (ins.midi_channel == pipeEv.midiCh) )
                                       {
                                          float pb = pipeEv.pitchbend - 8192;
                                          if(pb >= 0)
                                             pb = pb / 8191.0;
                                          else
                                             pb = pb / 8192.0;
                                          pb *= 64.0;
                                          pb += 64.0;
                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_PB,
                                                                               pb,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          totalNumPB++;
                                       }
                                       else
                                       {
                                          //  (todo) support alternate dev/ch (create new instrument or param ?)
                                          trace "[~~~] import_trigseq: pitchbend dev or ch differs from track/ins output dev or ch (skipping..)";
                                       }
                                    }
                                 }

                                 // Program change
                                 if(fr.numEventsPrgChg > 0)
                                 {
                                    if(fr.getEventByIdx(0/*evIdx*/, pipeEv, MIDIPIPE_EVENT_TYPE_PRGCHG))
                                    {
                                       if( (ins.getOutDeviceIdx() == pipeEv.devIdx) && (ins.midi_channel == pipeEv.midiCh) )
                                       {
                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_PC,
                                                                               pipeEv.prgChg,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          totalNumPC++;
                                       }
                                       else
                                       {
                                          param <= ins.findParamForPipeEvent(pipeEv, true/*bMatchInstr*/, retCtlVal);

                                          // trace "xxx import_trigseq:  evIdx<pc>="+evIdx+" retCtlVal="+retCtlVal+" param="+#(param);

                                          if(null == param)
                                          {
                                             param <= ins.createNewParam(-1/*idx*/);
                                             Global.Debug2("import_trigseq: lazycreate param for PrgChg => param="+#(param));

                                             if(null != param)
                                             {
                                                // trace "xxx import_trigseq: created PC param id="+param.id;
                                                param.initPrgChgFromPipeEvent(ins, pipeEv, "prgchg");
                                                instrument_view.updateParamVisibility(true/*bUpdateLayout*/);
                                             }
                                             else
                                                bFail = true;
                                          }

                                          if(null != param)
                                          {
                                             tracker_node.insertReplaceEventAtRes(track,
                                                                                  NT_TrackPattern.CTL_USR + param.id,
                                                                                  retCtlVal,
                                                                                  tickNr,
                                                                                  1/*res*/
                                                                                  );
                                             totalNumPC++;
                                          }
                                       }
                                    }
                                 }

                                 // CC
                                 if(fr.numEventsCC > 0)
                                 {
                                    evIdx = 0;

                                    loop(fr.numEventsCC)
                                    {
                                       fr.getEventByIdx(evIdx, pipeEv, MIDIPIPE_EVENT_TYPE_CC);

                                       param <= ins.findParamForPipeEvent(pipeEv, true/*bMatchInstr*/, retCtlVal);

                                       // trace "xxx import_trigseq:  evIdx<cc>="+evIdx+" cc="+pipeEv.ccId+" val="+pipeEv.ccValue+" retCtlVal="+retCtlVal+" param="+#(param);

                                       if(null == param)
                                       {
                                          param <= ins.createNewParam(-1/*idx*/);
                                          Global.Debug2("import_trigseq: lazycreate param for cc="+pipeEv.ccId+" param="+#(param));

                                          if(null != param)
                                          {
                                             // trace "xxx import_trigseq: created CC param id="+param.id;
                                             param.initCCFromPipeEvent(ins, pipeEv, "trigseq cc ");
                                             instrument_view.updateParamVisibility(true/*bUpdateLayout*/);
                                             param <= ins.findParamForPipeEvent(pipeEv, true/*bMatchInstr*/, retCtlVal);
                                          }
                                          else
                                             bFail = true;
                                       }

                                       if(null != param)
                                       {
                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_USR + param.id,
                                                                               retCtlVal,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          totalNumCC++;
                                       }

                                       evIdx++;
                                    } // loop CC events

                                    // trace "xxx import_trigseq: trk"+trackNTS.track_nr+"["+tickNr+"]:    fr.numEventsCC="+fr.numEventsCC;
                                 } // if numEventsCC > 0

                                 // RPN
                                 if(fr.numEventsRPN > 0)
                                 {
                                    evIdx = 0;

                                    loop(fr.numEventsRPN)
                                    {
                                       fr.getEventByIdx(evIdx, pipeEv, MIDIPIPE_EVENT_TYPE_RPN);

                                       param <= ins.findParamForPipeEvent(pipeEv, true/*bMatchInstr*/, retCtlVal);

                                       // trace "xxx import_trigseq:  evIdx<rpn>="+evIdx+" rpn="+pipeEv.rpn+" val="+pipeEv.rpnValue+" retCtlVal="+retCtlVal+" param="+#(param);

                                       if(null == param)
                                       {
                                          param <= ins.createNewParam(-1/*idx*/);
                                          Global.Debug2("import_trigseq: lazycreate RPN param for rpn="+pipeEv.rpn+" param="+#(param));

                                          if(null != param)
                                          {
                                             // trace "xxx import_trigseq: created param id="+param.id;
                                             param.initRPNFromPipeEvent(ins, pipeEv, "trigseq rpn ");
                                             instrument_view.updateParamVisibility(true/*bUpdateLayout*/);
                                             param <= ins.findParamForPipeEvent(pipeEv, true/*bMatchInstr*/, retCtlVal);
                                          }
                                          else
                                             bFail = true;
                                       }

                                       if(null != param)
                                       {
                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_USR + param.id,
                                                                               retCtlVal,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          totalNumRPN++;
                                       }

                                       evIdx++;
                                    } // loop RPN events

                                    // trace "xxx import_trigseq: trk"+trackNTS.track_nr+"["+tickNr+"]:    fr.numEventsRPN="+fr.numEventsRPN;
                                 } // if numEventsRpn > 0

                                 // NRPN
                                 if(fr.numEventsNRPN > 0)
                                 {
                                    evIdx = 0;

                                    loop(fr.numEventsNRPN)
                                    {
                                       fr.getEventByIdx(evIdx, pipeEv, MIDIPIPE_EVENT_TYPE_NRPN);

                                       param <= ins.findParamForPipeEvent(pipeEv, true/*bMatchInstr*/, retCtlVal);

                                       // trace "xxx import_trigseq:  evIdx<nrpn>="+evIdx+" nrpn="+pipeEv.nrpn+" val="+pipeEv.nrpnValue+" retCtlVal="+retCtlVal+" param="+#(param);

                                       if(null == param)
                                       {
                                          param <= ins.createNewParam(-1/*idx*/);
                                          Global.Debug2("import_trigseq: lazycreate param for nrpn="+pipeEv.nrpn+" param="+#(param));

                                          if(null != param)
                                          {
                                             // trace "xxx import_trigseq: created NRPN param id="+param.id;
                                             param.initNRPNFromPipeEvent(ins, pipeEv, "trigseq nrpn ");
                                             instrument_view.updateParamVisibility(true/*bUpdateLayout*/);
                                             param <= ins.findParamForPipeEvent(pipeEv, true/*bMatchInstr*/, retCtlVal);
                                          }
                                          else
                                             bFail = true;
                                       }

                                       if(null != param)
                                       {
                                          tracker_node.insertReplaceEventAtRes(track,
                                                                               NT_TrackPattern.CTL_USR + param.id,
                                                                               retCtlVal,
                                                                               tickNr,
                                                                               1/*res*/
                                                                               );
                                          totalNumNRPN++;
                                       }

                                       evIdx++;
                                    } // loop NRPN events

                                    // trace "xxx import_trigseq: trk"+trackNTS.track_nr+"["+tickNr+"]:    fr.numEventsNRPN="+fr.numEventsNRPN;
                                 }

                              }

                              // Next tick
                              tickNr++;
                              nts.tick_nr++;
                           }
                        }
                        else
                           bFail = true;
                     } // if track
                  } // if numTrigs
               } // loop trackNTS

               // Make hidden ctl cels visible when they have events
               lazyMakeCtlCelsVisible();

               pattern_view.cursorTrackChanged();
               pattern_view.queueRedrawAll();
               // // updateKeyJazzWidgets();

               tracker_node.undoEndNested("cmd_pattern_import_trigseq");

               if(bFail)
                  Global.Error("Import TrigSeq: error");
               else
                  Global.Success("Import TrigSeq: OK ("
                                 +totalNumNO+" note"+Utils.GetPluralString(totalNumNO)
                                 +", "+totalNumPB+" pb"+Utils.GetPluralString(totalNumPB)
                                 +", "+totalNumPAT+" pat"+Utils.GetPluralString(totalNumPAT)
                                 +", "+totalNumCAT+" pat"+Utils.GetPluralString(totalNumCAT)
                                 +", "+totalNumPC+" pc"+Utils.GetPluralString(totalNumPC)
                                 +", "+totalNumCC+" cc"+Utils.GetPluralString(totalNumCC)
                                 +", "+totalNumRPN+" rpn"+Utils.GetPluralString(totalNumRPN)
                                 +", "+totalNumNRPN+" rpn"+Utils.GetPluralString(totalNumNRPN)
                                 +")");

            } // if patNTS
            else
            {
               Global.Warning("Import TrigSeq: Play pattern is null");
            }
         }
         else
         {
            Global.Warning("Import TrigSeq: Clipboard is empty");
         }
      }
   }

   protected method lazyMakeCtlCelsVisible() {
      int trackIdx = 0;
      loop(tracker_node.tracks.numElements)
      {
         NT_Track track <= tracker_node.getTrack(trackIdx);
         NT_TEL   tel   <= track.getTrackLayout();
         dlg_edit_track_layout.showHidden(this, tel, trackIdx);
         dlg_edit_track_layout.cmdAutoLayout();
         trackIdx++;
      }
   }

   protected method findInstrByFirstEventInFrame(MIDIPipeFrame _frame) : NT_Instrument {
      if(_frame.hasEvents())
      {
         MIDIPipeEvent pev;
         if(_frame.getEventByIdx(0, pev, -1))
         {
            NT_Instrument *ins;
            foreach ins in tracker_node.instruments
            {
               if(null != ins.out_device)
               {
                  if((ins.out_device.dev_idx) == pev.devIdx)
                  {
                     if(ins.midi_channel == pev.midiCh)
                     {
                        return ins;
                     }
                  }
               }
            }
         }
      }
      return null;
   }

   public method cmd_pattern_import_monitor() {
      if(Global.NotPlaying("import_monitor"))
      {
         dlg_import_monitor.setRecipient(this);
         dlg_import_monitor.show();
      }
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_import_monitor_handle_ok(NM_Pattern patMon,
                                                               boolean _bForceReInit,
                                                               boolean _bForceMulti,
                                                               boolean _bCreateInstrumentsAndParams,
                                                               boolean _bConvRPNPC,
                                                               boolean _bPreferCTLPC,
                                                               boolean _bCopyPatName,
                                                               boolean _bResetRec,
                                                               boolean _bAlignBars,
                                                               boolean _bExplode,
                                                               boolean _bUndo
                                                               ) {
      Global.Debug("NodeTrackerEditor: ..................................... import Monitor pattern. bResetRec="+_bResetRec);

      NT_Track ctrack <= pattern_view.getCurrentTrack();

      if(null != ctrack)
      {
         if(null != patMon)
         {
            NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

            if((null == mpat) || mpat.patIsEmpty())
            {
               Global.Error("Import Monitor: please create a pattern, first.");
               return;
            }

            int origSongOffset = current_song.song_offset;
            boolean bWasPlaying = replay.b_playing;
            if(bWasPlaying)
               root_form.handleToggleReplay(false/*bSendMMC*/);

            boolean bQuantizeOrig = STConfig.b_node_tracker_recordquantize;
            STConfig.b_node_tracker_recordquantize = false;

            boolean bOrigRecLatency = STConfig.b_node_tracker_rec_latency;
            STConfig.b_node_tracker_rec_latency = false;

            boolean bOrigRecUsrCtlNoteOn = STConfig.b_node_tracker_recordusrctlnoteon;
            STConfig.b_node_tracker_recordusrctlnoteon = false;

            int origLockedKeyjazzNodeGID = current_song.locked_keyjazz_node_gid;
            current_song.locked_keyjazz_node_gid = -1;

            boolean bFail = false;
            NT_Instrument *trackIns;
            boolean bCreateTracks = (1 == tracker_node.nodeGetNumUsedPatterns()) | _bForceReInit;
            boolean bMulti = bCreateTracks || _bForceMulti;

            if(!_bExplode && _bUndo)
            {
               tracker_node.undoBeginNested("cmd_pattern_import_monitor");
               tracker_node.undoTouchNodeState();
            }

            int recSelOrig = tracker_node.rec_sel;
            tracker_node.setRecSel(NodeTracker.REC_SEL_NOTES_AND_CTLS);

            tracker_node.importResetActiveNotes();

            if(bCreateTracks)
            {
               // Re-init node
               while((tracker_node.tracks.numElements) > 1)
               {
                  tracker_node.deleteTrack((tracker_node.tracks.numElements) - 1);
               }
               tracker_node.freeAllInstruments();
               selectPatternByIdx(0);
               cmd_pattern_free_ex(false/*bFreeMeta*/, false/*bUndoBegin*/, _bUndo);  // patternClear()

               // (note) don't re-init track layout (e.g. keep preconfigured note,vel,dur grouping)
               // // NT_TEL firstTEL <= tracker_node.tracks.get(0).getTrackLayout();
               // // firstTEL.init();
            }

            int ctrackIdx;
            int origTrackNr;

            boolean bOrigFilter    = tracker_node.b_match_instr;
            boolean bOrigRecAll    = tracker_node.b_rec_all;
            boolean bOrigRecSpread = tracker_node.b_rec_spread;

            //
            // Create CTL_NOTEn, DURn, VELn, POLYATn, PB, PC, AT cels
            //
            ctrackIdx = 0;
            foreach ctrack in tracker_node.tracks
            {
               // // tracker_node.undoTouchTrackLayout(ctrackIdx, ctrack.tel);
               ctrack.import_orig_cursor_x = ctrack.cursor_x;
               ctrack.importLazyCreateCels();
               ctrackIdx++;
            }

            int origNumTracks = ctrackIdx;

            int frIdx = 0;
            int numFrames = patMon.getNumFrames();

            //
            // Iterate import frames and create instruments + params
            //
            if(_bCreateInstrumentsAndParams)
            {
               loop(numFrames)
               {
                  MIDIPipeFrame frMonIns <= patMon.getReplayFrameByIdx(frIdx);
                  tracker_node.lazyCreateInstrumentsAndParamsByFrame(frMonIns,
                                                                     ""/*insNamePrefix*/,
                                                                     " (ImportMon)"/*insNameSuffix*/,
                                                                     _bPreferCTLPC,
                                                                     _bConvRPNPC
                                                                     );
                  frIdx++;
               }
            }

            // Copy pattern name
            if(_bCopyPatName)
            {
               mpat.patSetName(patMon.pat_name);
            }

            if(bCreateTracks)
            {
               // Count max number of simultaneous notes per instrument
               local IntArray numInstrNotes;
               foreach trackIns in tracker_node.instruments
               {
                  if(null != trackIns)
                  {
                     int maxNumNotes = patMon.findMaxSimultaneousNotes(trackIns.getOutDeviceIdx(),
                                                                       trackIns.midi_channel
                                                                       );
                     // trace "xxx trackIns maxNumNotes="+maxNumNotes;
                     Global.Debug("importmon: devIdx="+trackIns.getOutDeviceIdx()+" ch="+trackIns.midi_channel+" maxNumNotes="+maxNumNotes);
                     numInstrNotes.add(maxNumNotes);
                  }
                  else
                  {
                     numInstrNotes.add(0);
                  }
               }

               // // origTrackNr = tracker_node.pv_cursor_track;

               Global.Debug("Import Monitor: creating tracks / assigning instruments");
               int trackInsIdx = 0;
               int trackCreateIdx = 0;
               foreach trackIns in tracker_node.instruments
               {
                  if(trackInsIdx > 0)
                  {
                     if(null != trackIns)
                     {
                        // (note) lazy-create multiple tracks if number of max. active notes is >5
                        int numCreateTracks = numInstrNotes.get(trackInsIdx);
                        // trace "xxx trackInsIdx="+trackInsIdx+" numCreateTracks="+numCreateTracks+" numInstrNotes="+numInstrNotes;
                        numCreateTracks = (numCreateTracks + NT_Defs.NUM_NOTESLOTS-1) / NT_Defs.NUM_NOTESLOTS;

                        // Create at least one track for each instrument (e.g. for controller/prgchg recording)
                        if(0 == numCreateTracks)
                           numCreateTracks = 1;

                        loop(numCreateTracks)
                        {
                           NT_Track track <= tracker_node.getTrack(trackCreateIdx++);
                           if(null == track)
                           {
                              // // tracker_node.undoTouchNodeState();
                              track <= tracker_node.newTrack("x", null/*curTrack*/, false/*bCloneLayout*/);
                           }
                           // trace "xxx monimport: update track idx="+(trackInsIdx-1);
                           track.name = "trk"+trackInsIdx;
                           track.keyjazz_instr_nr = trackInsIdx;
                           track.current_instrument_nr = trackInsIdx;
                        }
                     }
                  }
                  trackInsIdx++;
               }

               // Init new tracks
               ctrackIdx = 0;
               foreach ctrack in tracker_node.tracks
               {
                  if(ctrackIdx >= origNumTracks)
                  {
                     // // tracker_node.undoTouchTrackLayout(ctrackIdx, ctrack.tel);
                     ctrack.import_orig_cursor_x = ctrack.cursor_x;
                     ctrack.importLazyCreateCels();
                  }
                  ctrackIdx++;
               }
            }
            else
            {
               Global.Debug("Import Monitor: using manual track/instrument assignments (#pat > 1)");
            }

            if(bMulti)
            {
               tracker_node.b_match_instr = true;
               tracker_node.b_rec_all     = true;
               tracker_node.b_rec_spread  = true;
            }

            //
            // Iterate tracks and make all params visible for current kj instr
            //
            ctrackIdx = 0;
            origTrackNr = tracker_node.pv_cursor_track;
            foreach ctrack in tracker_node.tracks
            {
               trackIns <= tracker_node.getInstrument(ctrack.keyjazz_instr_nr);
               if(null != trackIns)
               {
                  tracker_node.pv_cursor_track = ctrackIdx;  // moveCursorToTrack()
                  instrument_view.updateParamVisibilityForIns(trackIns,
                                                              false/*bUpdateLayout*/,
                                                              false/*bCalcExtents*/
                                                              );
               }
               ctrack.tel.calcCursorExtents();
               ctrackIdx++;
            }
            tracker_node.pv_cursor_track = origTrackNr;

            //
            // Import monitor pattern frames
            //
            tracker_node.b_rt_record = true;
            replay.b_playing = true;
            int origEditOffset = tracker_node.getEditOffset();
            // // int origSongOffset = current_song.song_offset;
            int origTickNr     = tracker_node.tick_nr;
            // // boolean bOrigWriteInstrNr = tracker_node.b_write_instrnr;
            // // tracker_node.b_write_instrnr = true;
            handleStartPlaying();

            mpat.num_ticks = 65536*4; // fixed later on (~320 bars at 120bpm/192ppq)
            frIdx = 0;
            int tickStart = -1;
            int evOff = 0;  // ticks
            int evOffAbs = 0;
            int evOffAbsPrev = 0;
            int tickDelta = 0;

            // // boolean bSetInstr = true;
            // // NT_Instrument lastSetInstr <= null;

            loop(numFrames)
            {
               // Get a copy of the current frame
               MIDIPipeFrame frMon = patMon.getReplayFrameByIdx(frIdx);
               // trace "xxx importMon: frIdx="+frIdx+" frMon.timestamp="+frMon.timeStamp+" #ev="+frMon.numEvents+" #noteon="+frMon.numEventsNoteOn;
               evOffAbsPrev = evOffAbs;

               if(patMon.b_tick_timebase)  // used (only) by output capture mode
                  evOff = frMon.timeStamp/*ticks*/;
               else // to ticks
                  evOff = int( ( (frMon.timeStamp/*milliseconds*/ + patMon.replay_shift_ms) * current_song.bpm * current_song.ppq) / (1000.0 * 60) +0.5);

               evOffAbs = evOff;

               if(-1 == tickStart)
               {
                  tickStart = evOff;
                  evOff = 0;
                  tickDelta = 0;
               }
               else
               {
                  evOff -= tickStart;
                  tickDelta = (evOffAbs - evOffAbsPrev);
                  // trace "xxx evOffAbsPrev="+evOffAbsPrev+" evOffAbs="+evOffAbs+" => tickDelta="+tickDelta;
               }

               Global.Debug3("NT::cmd_pattern_import_monitor: import frame "+(frIdx+1)+"/"+numFrames+" ticks="+evOff+" numEv="+frMon.numEvents);

               tracker_node.setEditOffset(evOff);
               tracker_node.tick_nr = evOff;  // for recordMIDICtl()
               current_song.song_offset = evOff + tracker_node.nodeGetLastPatternStartEditorSongOffset();

               // // if(bSetInstr)
               // // {
               // //    NT_Instrument firstIns <= findInstrByFirstEventInFrame(frMon);
               // //    if(null != firstIns)
               // //    {
               // //       if(@(firstIns) != @(lastSetInstr))
               // //       {
               // //          lastSetInstr <= firstIns;
               // //          insertReplaceEventAt(..);
               // //       }
               // //    }
               // // }

               if(_bConvRPNPC)
               {
                  frMon.convertRPNUIPrgChgToPrgChg(-1/*fltDev*/, -1/*fltCh*/);
               }

               if(!_bResetRec)
               {
                  tracker_node.importTrackDurLeft(tickDelta);
               }

               // trace "xxx nt::importmon: evOff="+evOff+" frMon.numEventsNoteOn="+frMon.numEventsNoteOn;
               // (note) bMuted (also) controls whether recorded events are deleted from input frame
               //         (=> bMuted=true avoids recording duplicate notes when there is more than one track for an instrument)
               // tracker_node.recordFrame(frMon, true/*bFramePlay*/, true/*bMuted*/, true/*bForceEditable*/, null/*frOut*/);
               tracker_node.recordFrame(frMon, true/*bFramePlay*/, false/*bMuted*/, true/*bForceEditable*/, null/*frOut*/);

               if(_bResetRec)
               {
                  // (note) assumes that Monitor frames do not contain note-offs but note-on durations
                  //         => minimize number of note-cels by resetting the active notes after each recorded tick
                  tracker_node.importResetActiveNotes();
               }

               // Next frame
               frIdx++;
            }

            // Align to even "offlen" (usually 16ths)
            //  (note) num_ticks_hint is 0 when pattern was copied from Monitor node
            //          and > 0 when pattern was exported from NodeSeq (Freeform) selection
            Global.Debug2("cmd_pattern_import_monitor_handle_ok: patMon.num_ticks_hint="+patMon.num_ticks_hint);
            if(0 != patMon.num_ticks_hint)
               mpat.num_ticks = patMon.num_ticks_hint;
            else
               mpat.num_ticks = ((((evOff + 1) / tracker_node.offlen_ticks_resetval)+1)&~1) * tracker_node.offlen_ticks_resetval;

            int ticksPerBar = current_song.getNumTicksPerBar();
            Global.Debug2("cmd_pattern_import_monitor_handle_ok: bAlignBars="+_bAlignBars+" ticksPerBar="+ticksPerBar);
            if(_bAlignBars)
            {
               mpat.num_ticks = ((mpat.num_ticks + ticksPerBar - 1) / ticksPerBar) * ticksPerBar;
            }
            Global.Debug2("cmd_pattern_import_monitor_handle_ok: mpat.num_ticks="+mpat.num_ticks);

            // // trace "xxx 1 tracker_node.getCurrentEditMetaPatternLength()="+tracker_node.getCurrentEditMetaPatternLength();


            //
            // Iterate tracks and hide unused cels
            //
            foreach ctrack in tracker_node.tracks
            {
               ctrack.importLazyHideUnusedCels();
               ctrack.cursor_x = ctrack.import_orig_cursor_x;
            }


            //
            // Import finished
            //
            // // autoEnableAndConfigureTracksScroller();

            tracker_node.b_match_instr = bOrigFilter;
            tracker_node.b_rec_all     = bOrigRecAll;
            tracker_node.b_rec_spread  = bOrigRecSpread;

            handleStopPlaying(false/*bAllowBookmark*/);
            tracker_node.b_rt_record = false;
            replay.b_playing = false;
            tracker_node.setEditOffset(origEditOffset);
            current_song.song_offset = origSongOffset;
            tracker_node.tick_nr     = origTickNr;
            // // tracker_node.b_write_instrnr = bOrigWriteInstrNr;
            STConfig.b_node_tracker_recordquantize = bQuantizeOrig;
            STConfig.b_node_tracker_rec_latency = bOrigRecLatency;
            STConfig.b_node_tracker_recordusrctlnoteon = bOrigRecUsrCtlNoteOn;
            current_song.locked_keyjazz_node_gid = origLockedKeyjazzNodeGID;

            if(!_bExplode)
            {
               pattern_view.queueRedrawAll();
               // // updateKeyJazzWidgets();
               pattern_view.cursorTrackChanged();
               updatePatLen();
            }
            else
            {
               pattern_view.cancelAllTimers();
            }

            if(_bCopyPatName)
               updatePatName();

            tracker_node.setRecSel(recSelOrig);

            // Rewind to original song position
            current_song.seek(origSongOffset);

            // Restart replay
            if(bWasPlaying)
               root_form.handleToggleReplay(false/*bSendMMC*/);

            if(!_bExplode)
            {
               if(_bUndo)
                  tracker_node.undoEndNested("cmd_pattern_import_monitor");

               if(bFail)
                  Global.Error("Import Monitor: error");
               else
               {
                  float numBars = (int((100.0*mpat.num_ticks)/ticksPerBar)/100.0);
                  Global.Success("Import Monitor: OK"+(bMulti ? " (multi)" : "")+" ("+numBars+" bar"+((numBars != 0.0)?"s":"")+")");
               }
            }
         }
         else
         {
            Global.Error("Import Monitor: Clipboard pattern is null");
         }
      }
      else
      {
         Global.Error("Import Monitor: current track is null");
      }
   }

   // <ui_cmd.png>
   public method cmd_pattern_import_smf() {
      local String suggestedPath, suggestedFile;
      Utils.SplitPathname(import_smf_open_suggested_file, suggestedPath, suggestedFile);

      local String fileName <= UI.OpenFileDialog(suggestedPath,
                                                 suggestedFile,
                                                 "Import Standard MIDI File",
                                                 import_smf_file_filter_names,
                                                 import_smf_file_filter_strings,
                                                 false, false
                                                 );

      if(fileName != null)
      {
         import_smf_open_suggested_file = fileName;

         pattern_view.importSMFFromLocalFile(fileName);
      }
   }

   // <ui_cmd.png>
   public method cmd_pattern_prev(int _delta) {
      int patNr = tracker_node.nodeGetCurrentEditPatternNr();
      if(patNr > 0)
      {
         if((patNr - _delta) >= 0)
         {
            selectPatternByIdx(patNr - _delta);

            updatePatNr();
            updatePatLen();
            updatePatName();

            restoreKJInstrFromPat();

            pattern_view.queueRedrawAll();

            refocusDefault();

            Global.Print("Select pattern "+cm_patnr.getCaption());
         }
      }
   }

   // <ui_cmd.png>
   public method cmd_pattern_next(int _delta) {
      int patNr = tracker_node.nodeGetCurrentEditPatternNr();
      if(patNr < 127)
      {
         if((patNr + _delta) <= 127)
         {
            selectPatternByIdx(patNr + _delta);

            updatePatNr();
            updatePatLen();
            updatePatName();

            restoreKJInstrFromPat();

            pattern_view.queueRedrawAll();

            refocusDefault();

            Global.Print("Select pattern "+cm_patnr.getCaption());
         }
      }
   }

   // <ui_cmd.png>
   public method cmd_pattern_used_prev() {
      int patNr = tracker_node.nodeGetCurrentEditPatternNr();

      patNr = tracker_node.nodeFindPreviousPatternNrByUsedIdxWithOffset(patNr-1, 0);

      if(-1 != patNr)
      {
         selectPatternByIdx(patNr);

         updatePatNr();
         updatePatLen();
         updatePatName();

         restoreKJInstrFromPat();

         pattern_view.queueRedrawAll();

         refocusDefault();

         Global.Print("Select prev used pattern "+cm_patnr.getCaption());
      }
   }

   // <ui_cmd.png>
   public method cmd_pattern_used_next() {
      int patNr = tracker_node.nodeGetCurrentEditPatternNr();

      patNr = tracker_node.nodeFindNextPatternNrByUsedIdxWithOffset(patNr+1, 0);

      if(-1 != patNr)
      {
         selectPatternByIdx(patNr);

         updatePatNr();
         updatePatLen();
         updatePatName();

         restoreKJInstrFromPat();

         pattern_view.queueRedrawAll();

         refocusDefault();

         Global.Print("Select next used pattern "+cm_patnr.getCaption());
      }
   }

   // <ui_cmd.png>
   public method cmd_pattern_enternr() {
      root_form.pg_node.showPatternNumberDialog();
      // // dlg_setpatternnumber.run(this, tracker_node.nodeGetCurrentEditPatternNr());
   }

   // // public =replay= cmd_pattern_enternr2(int _patNr) {
   // //    // Called by NT_SetPatternNumberDialog

   // //    if( (_patNr >= 0) && (_patNr <= 127) )
   // //    {
   // //       selectPatternByIdx(_patNr);

   // //       updatePatNr();
   // //       pattern_view.redrawAll();

   // //       Global.Success("Pattern number set to "+_patNr+".");
   // //    }
   // // }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_enterlen() {
      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();
      if(null != mpat)
      {
         dlg_setpatternlength.run(this, mpat.num_ticks);
      }
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_enterlen2(int _ticks) {

      pattern_view.setPatternLengthWithUndo(_ticks);

      updatePatLen();

      Global.Success("Pattern length set to "+(_ticks / fp_stepresolution.getValue())+" ("+_ticks+" ticks).");
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_lentocursor() {
      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      if(null != mpat)
      {
         int editOff = tracker_node.getAlignedPatOffset(tracker_node.getEditOffset());

         if(editOff > 0)
         {
            tracker_node.undoBeginNested("lentocursor");
            int patNr = tracker_node.nodeGetCurrentEditPatternNr();
            tracker_node.undoTouchPattern(patNr);

            pattern_view.scrollUp();
            pattern_view.setPatternLength(editOff);
            // // mpat.num_ticks = editOff;
            // // pattern_view.renderAndRedrawAll();
            updatePatLen();
            tracker_node.undoEndNested("lentocursor");

            Global.Print("Set pattern length to cursor position ("+editOff+")");
         }
      }
   }

   // <ui_cmd.png>
   public method cmd_pattern_entername() {
      tf_pat_name.onTabFocus();
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_double(boolean _bCopy) {
      pattern_view.doublePattern(_bCopy);
      Global.Print("Double pattern"+(_bCopy?" (copy)":""));
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_reverse() {
      if(pattern_view.isEditable())
      {
         pattern_view.patternReverse(true/*bPattern*/);
         Global.Print("Reverse pattern");
      }
      else
      {
         Global.Warning("Reverse pattern failed: please change edit mode");
      }
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_rotate_up() {
      pattern_view.patternRotateUp(true/*bPattern*/);
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_rotate_down() {
      pattern_view.patternRotateDown(true/*bPattern*/);
   }

   // <ui_cmd.png>
   public =replay= method cmd_pattern_exportmon() {
      Global.Debug("NodeTrackerEditor::cmd_pattern_exportmon");
      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();

      // if(null != mpat)
      //    trace "xxx cmd_pattern_exportmon: mpat.patIsEmpty()="+mpat.patIsEmpty()+" mpat.num_ticks="+mpat.num_ticks;

      if(null != mpat && !mpat.patIsEmpty())
      {
         // Save current song position and lazy-stop replay
         int origSongOffset = current_song.song_offset;
         boolean bWasPlaying = replay.b_playing;
         if(bWasPlaying)
            root_form.handleToggleReplay(false/*bSendMMC*/);

         // Seek to pattern start
         pattern_view.moveCursorToStart();

         // Start output capture
         boolean bOrigTimebase = STConfig.b_node_monitor_capture_tick_timebase;
         STConfig.b_node_monitor_capture_tick_timebase = true;
         mon_capture.captureBegin();
         tracker_node.b_capture = true;
         STConfig.b_node_monitor_capture_tick_timebase = bOrigTimebase;

         // Set pattern duration hint (was reset by captureBegin())
         NM_Pattern monPat <= mon_capture.nodeGetCurrentPlayPattern();
         monPat.num_ticks_hint = mpat.num_ticks;

         // Create start frame (may remain empty, except for marker)
         local MIDIPipeFrame frEmpty;
         mon_capture.captureAdd(frEmpty, false/*bAdvance*/);
         // // mon_capture.captureSeek(0);

         // Restart replay
         root_form.handleToggleReplay(false/*bSendMMC*/);

         // Export ticks
         int patStartOff = tracker_node.nodeGetLastPatternStartSongOffset();
         local MIDIPipeFrame frPlayDummy;
         int curTicks = 0;
         boolean bHaveEv = false;
         int patNr = tracker_node.nodeGetCurrentEditPatternNr();
         NT_Track *track;
         NT_TrackPattern *pat;
         Envelope *env;
         for(;;)
         {
            int nextTicks = -1;
            foreach track in tracker_node.tracks
            {
               pat <= track.getPattern(patNr);
               if(null != pat)
               {
                  foreach env in pat.controllers
                  {
                     if(null != env)
                     {
                        int t = env.getNextEventTimeAfter(curTicks);
                        if( t >= 0 && (-1 == nextTicks || t < nextTicks) )
                           nextTicks = t;
                        // trace "xxx exportmon: nextTicks="+nextTicks;
                     }
                  }
               }
            } // foreach track

            // trace "xxx nextTicks="+nextTicks;

            if(-1 == nextTicks)
            {
               // No more events (DONE)
               break;
            }
            else
            {
               tracker_node.nodeSeek(patStartOff + nextTicks);
               frPlayDummy.empty();
               mon_capture.captureSeek(nextTicks);
               tracker_node.nodeProcessFrame(frPlayDummy,
                                             frEmpty/*frameRec*/,
                                             false/*bMuted*/,
                                             true/*bPlaySeq*/
                                             );
               // trace "xxx exportmon: frPlayDummy.numEvents="+frPlayDummy.numEvents;
               curTicks = nextTicks + 1;
            }
         }

         // Stop replay
         root_form.handleToggleReplay(false/*bSendMMC*/);

         // Rewind to original song position
         current_song.seek(origSongOffset);

         // Restart replay
         if(bWasPlaying)
            root_form.handleToggleReplay(false/*bSendMMC*/);

      } // if mpat && !empty
      else
      {
         // Clear mon_capture pattern
         mon_capture.captureBegin();
      }
      Global.Print("Export pattern to monitor / output capture clipboard");
   }

   // <ui_cmd.png>
   public cmd_pattern_trim_start_to_cursor() {
      pattern_view.trimStartToCursor();
   }

   // <ui_cmd.png>
   // --------------------------------------------------------------------------
   // - cmd_events_xxx
   // --------------------------------------------------------------------------

   public method cmd_events_recordpre() {
      STConfig.b_node_tracker_precount = !STConfig.b_node_tracker_precount;
      Global.Print("Pre-Count is "+Utils.GetEnableString(STConfig.b_node_tracker_precount)+(STConfig.b_node_tracker_precount?(" ("+STConfig.node_tracker_precount_num_bars+" bar"+Utils.GetPluralStringFloat(STConfig.node_tracker_precount_num_bars)+")"):""));

      updateRecordPre();
   }

   public method cmd_events_recordnoteoff() {
      pattern_view.toggleRecordNoteOffMode();

      updateRecordNoteOff();
   }

   public method cmd_events_recordnoteoff_replay() {
      pattern_view.toggleRecordNoteOffReplayMode();

      updateRecordNoteOffReplay();
   }

   public method cmd_events_recordnoteoff_dur() {
      pattern_view.toggleRecordNoteOffDurMode();

      updateRecordNoteOffDur();
   }

   public method cmd_events_recordquantize() {
      pattern_view.toggleRecordQuantizeMode();

      updateRecordQuantize();
   }

   public method cmd_events_recordusrctlnoteon() {
      pattern_view.toggleRecordUsrCtlNoteOn();

      updateRecordUsrCtlNoteOn();
   }

   public method cmd_events_reclatency() {
      pattern_view.toggleRecLatency();

      updateRecLatency();
   }

   public method cmd_events_timemulconst_dlg() {
      // if(Global.NotPlaying("cmd_events_timemulconst_dlg"))
      {
         dlg_patterntimemulconst.run(this);
      }
   }

   public method cmd_events_timemulconst(float _factor, boolean _bAllTracks) {
      // Called from dlg_patterntimemulconst

      refocusDefault();

      pattern_view.patternTimeMulConst(_factor, _bAllTracks);
   }

   public method cmd_events_calcdelayticks() {
      if(pattern_view.isEditable())
      {
         pattern_view.calcDelayTicks();
      }
      else
      {
         Global.Warning("CalcDelayTicks: please change edit mode");
      }
   }

   public method cmd_events_collapse() {
      if(pattern_view.isEditable())
      {
         pattern_view.collapse(true/*bUndo*/);
      }
      else
      {
         Global.Warning("Collapse: please change edit mode");
      }
   }

   public method cmd_events_collapse_tap() {
      cmd_edit_collapse_and_tap();
   }

   public method cmd_events_copystate() {
      if(pattern_view.isEditable())
      {
         pattern_view.pasteMIDIOutputState();
      }
      else
      {
         Global.Warning("Copy output state: please change edit mode");
      }
   }

   public method cmd_events_copyctl_a() {
      pattern_view.copyCurrentCtlToClipboard(false/*bClipboardB*/);
   }

   public method cmd_events_copyctl_b() {
      pattern_view.copyCurrentCtlToClipboard(true/*bClipboardB*/);
   }

   // <ui_cmd.png>
   // --------------------------------------------------------------------------
   // - cmd_instrument_xxx
   // --------------------------------------------------------------------------
   public method cmd_instrument_toggleviews() {
      toggleViews();
   }

   public method cmd_instrument_kjoctavedown() {
      keyJazzOctaveDown();
   }

   public method cmd_instrument_kjoctaveup() {
      keyJazzOctaveUp();
   }

   public method cmd_instrument_previous() {
      keyJazzSelectPreviousInstrument();
   }

   public method cmd_instrument_next() {
      keyJazzSelectNextInstrument();
   }

   public method cmd_instrument_enternumber() {
      focusKJInstrument();
   }

   public method cmd_instrument_editsample() {
      pattern_view.tryEditInstrumentAudioSample();
   }

   public method cmd_instrument_select(DynamicPopupMenuAction _ac, int _minInstr, _maxInstr) {

      int instrNr = _minInstr;
      PopupMenu pm <= _ac.getPopupMenu();
      pm.removeMenuItems();
      while(instrNr < _maxInstr)
      {
         String name = Utils.MapLetterNr(instrNr);
         NT_Instrument ins <= tracker_node.getInstrument(instrNr);
         if(null != ins)
         {
            name.append(": ");
            name.append(ins.name);
         }
         else
         {
            name.append(": -");
         }

         pm.addDefaultButton(name, "instrument_select_dyn"+instrNr);

         // Next instrument
         instrNr++;
      }
   }

   public method cmd_instrument_keyjazzmanualnoteoff() {
      STConfig.b_node_tracker_keyjazz_manual_noteoff = !STConfig.b_node_tracker_keyjazz_manual_noteoff;

      updateKeyJazzManualNoteOff();

      Global.Print("Manual note-off is now "+Utils.GetEnableString(STConfig.b_node_tracker_keyjazz_manual_noteoff));
   }

   // <ui_cmd.png>
   // --------------------------------------------------------------------------
   // - cmd_block_xxx
   // --------------------------------------------------------------------------
   public method cmd_block_mode() {
      pattern_view.nextBlockMode();
   }

   public method cmd_block_interpol() {
      // if(Global.NotPlaying("cmd_block_interpol"))
      // {
         pattern_view.showBlockInterpolationDialog();
      // }
   }

   public method cmd_block_beginblock() {
      pattern_view.blockBegin(true/*bAllowSelectNone*/);
   }

   public method cmd_block_endblock() {
      pattern_view.blockAncCancel();
      pattern_view.blockEnd(false/*bAllowCancel*/);
   }

   public method cmd_block_markpattern() {
      pattern_view.blockSelectCurrentPatternOrNone();  // lctrl-a
   }

   public method cmd_block_selectnone() {
      if(tracker_node.haveSelection())
      {
         pattern_view.selectNone();
      }
   }

   public method cmd_block_copyblock() {
      pattern_view.blockCopy();
   }

   public method cmd_block_paste() {
      pattern_view.blockPaste(false, true/*bUndoStartEnd*/, true/*bScrollDown*/);
   }

   public method cmd_block_pasteshift() {
      pattern_view.blockPaste(true, true/*bUndoStartEnd*/, true/*bScrollDown*/);
   }

   public method cmd_block_quantize_last() {
      pattern_view.blockQuantizeLastMethod();
   }

   public method cmd_block_quantize_100() {
      pattern_view.blockQuantizeMethod(1);
   }

   public method cmd_block_quantize_50() {
      pattern_view.blockQuantizeMethod(2);
   }

   public method cmd_block_quantize_25() {
      pattern_view.blockQuantizeMethod(3);
   }

   public method cmd_block_quantize_dialog() {
      pattern_view.blockQuantizeMethod(0);
   }

   public method cmd_block_transpose_up() {
      // lshift-f2
      if(SysEx.IsAudioConnected() && !pattern_view.isEditable())//// && !(UI.GetKeyMod() & VMOD_LCTRL))
      {
         root_form.showAudioLiveRecDialog(maybe/*bForce=toggle*/, null/*recipient*/);
      }
      else
      {
         pattern_view.blockTranspose(1);
      }
   }

   public method cmd_block_transpose_down() {
      // lshift-f1
      if(SysEx.IsAudioConnected() && !pattern_view.isEditable())
      {
         root_form.showAudioRecordDialog(maybe/*bForce=toggle*/, null/*recipient*/, null/*namePrefixOrNull*/);
      }
      else
      {
         pattern_view.blockTranspose(-1);
      }
   }

   public method cmd_block_shift_up() {
      pattern_view.blockShiftUp();
   }

   public method cmd_block_shift_up_tick() {
      pattern_view.blockShiftUpRes(1/*res*/, true/*bAllowScroll*/, false/*bQuiet*/);
   }

   public method cmd_block_shift_down() {
      pattern_view.blockShiftDown();
   }

   public method cmd_block_shift_down_tick() {
      pattern_view.blockShiftDownRes(1/*res*/, true/*bAllowScroll*/, false/*bQuiet*/);
   }

   // <ui_handle.png>
   protected method tryHandleMenuAction(String _acName) : boolean {
      Key synKey;

      if(_acName.startsWith("instrument_select_dyn"))
      {
         int instrNr = _acName.replace("instrument_select_dyn", ""); // 0..61
         tf_kj_instrument.setText(Utils.MapLetterNr(instrNr));
         handleKJInstrumentChanged(true/*bRefocusPattern*/);
         return true;
      }

      switch(_acName)
      {
      // ---------------------------------------------------
      // --                                               --
      // -- edit                                          --
      // --                                               --
      // ---------------------------------------------------
      case "edit_undo":
         cmd_edit_undo();
         return true;

      case "edit_redo":
         cmd_edit_redo();
         return true;

      case "edit_undoempty":
         cmd_edit_undoempty();
         return true;

      case "edit_undotogglemode":
         cmd_edit_undotogglemode();
         return true;

      case "edit_undotoggledebug":
         cmd_edit_undotoggledebug();
         return true;

      case "edit_togglemode":
         cmd_edit_togglemode();
         return true;

      case "edit_toggleshiftmode":
         cmd_edit_toggleshiftmode();
         return true;

      case "edit_zoomin":
         cmd_edit_zoomin();
         return true;

      // // case "edit_zoomin_double":
      // //    cmd_edit_zoomin_double();
      // //    return true;

      case "edit_zoomout":
         cmd_edit_zoomout();
         return true;

      // // case "edit_zoomout_half":
      // //    cmd_edit_zoomout_half();
      // //    return true;

      case "edit_togglezoompreset":
         cmd_edit_togglezoompreset();
         return true;

      case "edit_enterstepresolution":
         cmd_edit_enterstepresolution();
         return true;

      case "edit_zoom_1_32t":
         cmd_edit_zoom_1_32t();
         return true;

      case "edit_zoom_1_32":
         cmd_edit_zoom_1_32();
         return true;

      case "edit_zoom_1_16t":
         cmd_edit_zoom_1_16t();
         return true;

      case "edit_zoom_1_16":
         cmd_edit_zoom_1_16();
         return true;

      case "edit_zoom_1_8t":
         cmd_edit_zoom_1_8t();
         return true;

      case "edit_zoom_1_8":
         cmd_edit_zoom_1_8();
         return true;

      case "edit_zoom_1_4t":
         cmd_edit_zoom_1_4t();
         return true;

      case "edit_zoom_1_4":
         cmd_edit_zoom_1_4();
         return true;

      case "edit_enternotevelocity":
         cmd_edit_enternotevelocity();
         return true;

      case "edit_enternoteduration":
         cmd_edit_enternoteduration();
         return true;

      case "edit_stepadvance_0":
         pattern_view.setStepAdvance(0);
         return true;

      case "edit_stepadvance_1":
         pattern_view.setStepAdvance(1);
         return true;

      case "edit_stepadvance_2":
         pattern_view.setStepAdvance(2);
         return true;

      case "edit_stepadvance_3":
         pattern_view.setStepAdvance(3);
         return true;

      case "edit_stepadvance_4":
         pattern_view.setStepAdvance(4);
         return true;

      case "edit_stepadvance_5":
         pattern_view.setStepAdvance(5);
         return true;

      case "edit_stepadvance_6":
         pattern_view.setStepAdvance(6);
         return true;

      case "edit_stepadvance_7":
         pattern_view.setStepAdvance(7);
         return true;

      case "edit_stepadvance_8":
         pattern_view.setStepAdvance(8);
         return true;

      case "edit_stepadvance_nextevent":
         pattern_view.setStepAdvance(-1);
         return true;

      case "edit_chordclearstep":
         cmd_edit_toggle_chordclearstep();
         return true;

////////////////
      case "edit_microshift_0":
         setMicroShiftIdx(0);
         return true;

      case "edit_microshift_1":
         setMicroShiftIdx(1);
         return true;

      case "edit_microshift_2":
         setMicroShiftIdx(2);
         return true;

      case "edit_microshift_3":
         setMicroShiftIdx(3);
         return true;

      case "edit_microshift_4":
         setMicroShiftIdx(4);
         return true;

      case "edit_microshift_5":
         setMicroShiftIdx(5);
         return true;

      case "edit_microshift_6":
         setMicroShiftIdx(6);
         return true;

      case "edit_microshift_7":
         setMicroShiftIdx(7);
         return true;

      case "edit_microshift_8":
         setMicroShiftIdx(8);
         return true;

      case "edit_microshift_9":
         setMicroShiftIdx(9);
         return true;

      case "edit_toggleadvanceallnotesreleased":  // chord advance mode
         cmd_edit_toggleadvanceallnotesreleased();
         return true;

      case "edit_tapmode":
         cmd_edit_tapmode();
         return true;

      case "edit_detail":
         cmd_edit_detail();
         return true;

      case "edit_togglenoteonoffordetailedit":
         if(pattern_view.isEditable())
         {
            pattern_view.toggleNoteOffAtCursorOrShowDetailEdit();
         }
         else
         {
            Global.Warning("toggle note on/off or detail edit failed. please change edit mode.");
         }
         return true;

      case "edit_toggleslide_or_sort_notes":
         pattern_view.toggleSlideOrSortNotes();
         return true;

      case "edit_toggleenvelopeview":
         cmd_edit_toggleenvelopeview();
         return true;

      case "edit_togglepianowidget":
         cmd_edit_togglepianowidget();
         return true;

      case "edit_toggletimingview":
         cmd_edit_toggletimingview();
         return true;

      case "edit_toggletimingview_movelock":
         cmd_edit_toggletimingview_movelock();
         return true;

      case "edit_showaudiodialog":
         cmd_edit_showaudiodialog();
         return true;

      case "edit_swaplshift":
         cmd_edit_swaplshift();
         return true;

      case "edit_showctlinfo":
         cmd_edit_showctlinfo();
         return true;

      case "edit_frrectokjinsplay":
         cmd_edit_frrectokjinsplay();
         return true;



      // ---------------------------------------------------
      // --                                               --
      // -- cursor                                        --
      // --                                               --
      // ---------------------------------------------------
      case "cursor_autoscroll":
         cmd_cursor_autoscroll();
         return true;

      case "cursor_wraparound":
         cmd_cursor_wraparound();
         return true;

      case "cursor_doublecenter":
         cmd_cursor_doublecenter();
         return true;

      case "cursor_doublewidth":
         cmd_cursor_doublewidth();
         return true;

      case "cursor_doubleheight":
         cmd_cursor_doubleheight();
         return true;

      case "cursor_timing_autodoublewidth":
         cmd_cursor_timing_autodoublewidth();
         return true;

      case "cursor_timing_autodoubleheight":
         cmd_cursor_timing_autodoubleheight();
         return true;

      case "cursor_decimalpatoff":
         cmd_cursor_decimalpatoff();
         return true;

      case "cursor_shiftpatoff":
         cmd_cursor_shiftpatoff();
         return true;

      case "cursor_movetofirstorprevioustrack":
         pattern_view.moveCursorToFirstColumnOrPreviousTrack();
         return true;

      case "cursor_movetolastornexttrack":
         pattern_view.moveCursorToStartOfNextTrack();
         return true;

      case "cursor_movetoprevioustrack":
         pattern_view.moveCursorToPreviousTrackX(false/*bAlignRight*/);
         return true;

      case "cursor_movetonexttrack":
         pattern_view.moveCursorToNextTrackX();
         return true;

      case "cursor_moveuponestep":
         pattern_view.scrollUp();
         return true;

      case "cursor_movedownonestep":
         pattern_view.scrollDown();
         return true;

      case "cursor_moveupnsteps":
         pattern_view.pageUp();
         return true;

      case "cursor_movedownnsteps":
         pattern_view.pageDown();
         return true;

      case "cursor_moveuposteps":
         pattern_view.pageUpFast();
         return true;

      case "cursor_movedownosteps":
         pattern_view.pageDownFast();
         return true;

      case "cursor_movetostart":
         pattern_view.moveCursorToStart();
         return true;

      case "cursor_movetoend":
         pattern_view.moveCursorToEnd();
         return true;

      case "cursor_jumptostep":
         pattern_view.showJumpToStepDialog();
         return true;

      case "cursor_tickmodulo":
         pattern_view.showHighlightTickModuloDialog();
         return true;

      case "cursor_stepalignment":
         pattern_view.showStepAlignmentDialog();
         return true;

      case "cursor_movetofirstcolumn":
         pattern_view.moveCursorToFirstColumn();
         return true;

      case "cursor_movetopreviouscolumngroup":
         pattern_view.moveCursorToPreviousColumnGroup();
         return true;

      case "cursor_movetonextcolumngroup":
         pattern_view.moveCursorToNextColumnGroup();
         return true;

      case "cursor_movetopreviouscolumn":
         pattern_view.moveCursorLeft();
         return true;

      case "cursor_movetonextcolumn":
         pattern_view.moveCursorRight();
         return true;

      case "cursor_movetopreviousevent":
         pattern_view.gotoPreviousEvent();
         return true;

      case "cursor_movetonextevent":
         pattern_view.gotoNextEvent();
         return true;

      case "cursor_jumptocolumn":
         cmd_cursor_jumptocolumn();
         return true;

      // ---------------------------------------------------
      // --                                               --
      // -- replay                                        --
      // --                                               --
      // ---------------------------------------------------
      case "replay_selectandplay":
         cmd_replay_selectandplay();
         return true;

      case "replay_pat":
         cmd_replay_pat();
         return true;

      case "replay_rec":
         cmd_replay_rec();
         return true;

      case "replay_rec_cont":
         cmd_replay_rec_cont();
         return true;

      case "replay_continue":
         if(replay.b_playing)
         {
            replay.stopReplay(false/*bAllowBookmark*/, true/*bAllowPanic*/);
         }
         else
         {
            // // pattern_view.startReplay();
            pattern_view.loopCurrentPattern(true/*bFromCurOffset*/, true/*bStop*/);
         }
         return true;

      case "replay_stopplaystep":
         if(replay.b_playing)
         {
            replay.stopReplay(false/*bAllowBookmark*/, true/*bAllowPanic*/);
         }
         else
         {
            pattern_view.playStep();
         }
         return true;

      case "replay_stoplooppattern":
         if(replay.b_playing)
         {
            replay.stopReplay(true/*bAllowBookmark*/, true/*bAllowPanic*/);
         }
         else
         {
            pattern_view.loopCurrentPattern(false/*bFromCurOffset*/, true/*bStop*/);
         }
         return true;

      case "replay_invertspace":
         cmd_replay_invertspace();
         return true;

      case "replay_setreplayoffset":
         pattern_view.setPatternReplayOffsetToCursor();
         return true;

      case "replay_playstepreset":
         cmd_replay_playstepreset();
         return true;

      case "replay_togglepipesolo":
         cmd_replay_togglepipesolo();
         return true;

      case "replay_togglepipemute":
         cmd_replay_togglepipemute();
         return true;

      case "replay_togglenodesolo":
         cmd_replay_togglenodesolo();
         return true;

      case "replay_togglenodemute":
         cmd_replay_togglenodemute();
         return true;

      case "replay_toggleplayview":
         togglePlayView();
         return true;

      case "replay_freerun":
         cmd_replay_togglefreerun();
         return true;

      case "replay_ignorearr":
         cmd_replay_toggleignorearr();
         return true;

      case "replay_followarr":
         cmd_replay_togglefollowarr();
         return true;

      case "replay_clearmidicache":
         cmd_replay_clearmidicache();
         return true;

      // // case "replay_mmcrec_autoreset":
      // //    cmd_replay_mmcrec_autoreset();
      // //    return true;


      // ---------------------------------------------------
      // --                                               --
      // -- track                                         --
      // --                                               --
      // ---------------------------------------------------
      case "track_new":
         cmd_track_new_dlg();
         return true;

      case "track_delete":
         cmd_track_delete_dlg();
         return true;

      case "track_moveleft":
         cmd_track_moveleft();
         return true;

      case "track_moveright":
         cmd_track_moveright();
         return true;

      case "track_shownames":
         cmd_track_shownames();
         return true;

      case "track_rename":
         cmd_track_rename();
         return true;

      case "track_showeq":
         cmd_track_showeq();
         return true;

      case "track_editlayout":
         cmd_track_editlayout();
         return true;

      case "track_managecolumns":
         cmd_track_managecolumns();
         return true;

      case "track_addcel":
         cmd_track_addcel_dlg();
         return true;

      case "track_addnotecel":
         cmd_track_addnotecel();
         return true;

      case "track_addnotecel_vel":
         cmd_track_addnotecel_vel();
         return true;

      case "track_addnotecel_dur":
         cmd_track_addnotecel_dur();
         return true;

      case "track_addnotecel_autogroup":
         cmd_track_addnotecel_autogroup();
         return true;

      case "track_removecel":
         cmd_track_removecel_dlg();
         return true;

      case "track_toggleveldurstyles":
         cmd_track_toggleveldurstyles();
         return true;

      case "track_togglealtstyles":
         cmd_track_togglealtstyles();
         return true;

      case "track_togglemute":
         cmd_track_togglemute();
         return true;

      case "track_togglesolo":
         cmd_track_togglesolo();
         return true;

      case "track_muteall":
         cmd_track_muteall(true);
         return true;

      case "track_unmuteall":
         cmd_track_muteall(false);
         return true;

      case "track_reverse":
         cmd_track_reverse();
         return true;

      case "track_rotate_up":
         cmd_track_rotate_up();
         return true;

      case "track_rotate_down":
         cmd_track_rotate_down();
         return true;

      case "track_randomdialog":
         cmd_track_randomdialog();
         return true;

      case "track_lockkeyjazz":
         cmd_track_lockkeyjazz();
         return true;

      case "track_editsound":
         cmd_track_editsound();
         return true;

      // ---------------------------------------------------
      // --                                               --
      // -- pattern                                       --
      // --                                               --
      // ---------------------------------------------------
      case "pattern_alloc":
         cmd_pattern_alloc(false/*bSub*/);
         return true;

      case "pattern_alloc_sub":
         cmd_pattern_alloc(true/*bSub*/);
         return true;

      case "pattern_clone":
         cmd_pattern_clone(false/*bSub*/);
         return true;

      case "pattern_clone_sub":
         cmd_pattern_clone(true/*bSub*/);
         return true;

      case "pattern_clear":
         cmd_pattern_free(false/*bFreeMeta*/, true/*bUndoBegin*/);
         return true;

      case "pattern_free":
         cmd_pattern_free(true/*bFreeMeta*/, true/*bUndoBegin*/);
         return true;

      case "pattern_copy":
         cmd_pattern_copy(false/*bInvBlock*/);
         return true;

      case "pattern_paste":
         cmd_pattern_paste();
         return true;

      case "pattern_capture_begin":
         cmd_pattern_capture_begin();
         return true;

      case "pattern_capture_paste":
         cmd_pattern_capture_paste();
         return true;

      case "pattern_capture_export":
         cmd_pattern_exportmon();
         return true;

      case "pattern_capture_upload_to_eureka":
         cmd_pattern_capture_upload_to_eureka();
         return true;

      case "pattern_capture_download_from_eureka":
         cmd_pattern_capture_download_from_eureka();
         return true;

      case "pattern_import_ar":
         cmd_pattern_import_ar();
         return true;

      case "pattern_import_trigseq":
         cmd_pattern_import_trigseq();
         return true;

      case "pattern_import_monitor":
         cmd_pattern_import_monitor();
         return true;

      case "pattern_import_smf":
         cmd_pattern_import_smf();
         return true;

      case "pattern_prev":
         cmd_pattern_prev(1);
         return true;

      case "pattern_prev4":
         cmd_pattern_prev(4);
         return true;

      case "pattern_next":
         cmd_pattern_next(1);
         return true;

      case "pattern_next4":
         cmd_pattern_next(4);
         return true;

      case "pattern_used_prev":
         cmd_pattern_used_prev();
         return true;

      case "pattern_used_next":
         cmd_pattern_used_next();
         return true;

      case "pattern_enternr":
         cmd_pattern_enternr();
         return true;

      case "pattern_enterlen":
         cmd_pattern_enterlen();
         return true;

      case "pattern_lentocursor":
         cmd_pattern_lentocursor();
         return true;

      case "pattern_entername":
         cmd_pattern_entername();
         return true;

      case "pattern_double":
         cmd_pattern_double(false/*bCopy*/);
         return true;

      case "pattern_double_copy":
         cmd_pattern_double(true/*bCopy*/);
         return true;

      case "pattern_reverse":
         cmd_pattern_reverse();
         return true;

      case "pattern_rotate_up":
         cmd_pattern_rotate_up();
         return true;

      case "pattern_rotate_down":
         cmd_pattern_rotate_down();
         return true;

      case "pattern_capture_ticks":
         cmd_pattern_capture_ticks();
         return true;

      case "pattern_split":
         cmd_pattern_split(false/*bPasteNewPattern*/);
         return true;

      case "pattern_split_new":
         cmd_pattern_split(true/*bPasteNewPattern*/);
         return true;

      case "pattern_trim_start_to_cursor":
         cmd_pattern_trim_start_to_cursor();
         return true;



      // ---------------------------------------------------
      // --                                               --
      // -- events                                        --
      // --                                               --
      // ---------------------------------------------------
      case "events_deleteenv":
         pattern_view.deleteCurrentTrackEnvelope();
         return true;

      case "events_keydelete":
         pattern_view.handleKeyDelete(false/*bShift*/, false/*bCtrl*/);
         return true;

      case "events_keydeletetick":
         pattern_view.handleKeyDelete(false/*bShift*/, true/*bCtrl*/);
         return true;

      case "events_deleteeventall":
         // // pattern_view.removeTrackEvent(-1);
         pattern_view.handleKeyDelete(true/*bShift*/, false/*bCtrl*/);
         return true;

      case "events_deleteeventalltick":
         pattern_view.handleKeyDelete(true/*bShift*/, true/*bCtrl*/);
         return true;

      case "events_clearevent":
         synKey.pressed = 60; // '\'
         synKey.mod = 0;
         pattern_view.handleKeyJazzOrCelEditKey(synKey, null/*midiEv*/);
         return true;

      case "events_cleareventall":
         synKey.pressed = 60; // '\'
         synKey.mod = VMOD_LSHIFT;
         pattern_view.handleKeyJazzOrCelEditKey(synKey, null/*midiEv*/);
         return true;

      case "events_keyinsert":
         pattern_view.handleKeyInsert(false/*bShift*/, false/*bCtrl*/);
         return true;

      case "events_keyinserttick":
         pattern_view.handleKeyInsert(false/*bShift*/, true/*bCtrl*/);
         return true;

      case "events_inserteventall":
         pattern_view.handleKeyInsert(true/*bShift*/, false/*bCtrl*/);
         return true;

      case "events_inserteventalltick":
         pattern_view.handleKeyInsert(true/*bShift*/, true/*bCtrl*/);
         return true;

      case "events_timemulconst":
         cmd_events_timemulconst_dlg();
         return true;

      case "events_calcdelayticks":
         cmd_events_calcdelayticks();
         return true;

      case "events_collapse":
         cmd_events_collapse();
         return true;

      case "events_collapse_tap":
         cmd_events_collapse_tap();
         return true;

      case "events_copystate":
         cmd_events_copystate();
         return true;

      case "events_copyctl_a":
         cmd_events_copyctl_a();
         return true;

      case "events_copyctl_b":
         cmd_events_copyctl_b();
         return true;

      case "events_recordpre":
         cmd_events_recordpre();
         return true;

      case "events_recordnoteoff":
         cmd_events_recordnoteoff();
         return true;

      case "events_recordnoteoff_replay":
         cmd_events_recordnoteoff_replay();
         return true;

      case "events_recordnoteoff_dur":
         cmd_events_recordnoteoff_dur();
         return true;

      case "events_recordquantize":
         cmd_events_recordquantize();
         return true;

      case "events_recordusrctlnoteon":
         cmd_events_recordusrctlnoteon();
         return true;

      case "events_reclatency":
         cmd_events_reclatency();
         return true;


      // ---------------------------------------------------
      // --                                               --
      // -- block                                         --
      // --                                               --
      // ---------------------------------------------------
      case "block_mode":
         cmd_block_mode();
         return true;

      case "block_free_env":
         if(pattern_view.isEditable())
         {
            if(pattern_view.isPatternBlockMode())
            {
               cmd_pattern_free(false/*bFreeMeta*/, true/*bUndoBegin*/);
            }
            else
            {
               pattern_view.deleteAllCurrentTrackEnvelopes();
            }
         }
         return true;

      case "block_interpol":
         cmd_block_interpol();
         return true;

      case "block_beginblock":
         cmd_block_beginblock();
         return true;

      case "block_endblock":
         cmd_block_endblock();
         return true;

      case "block_markpattern":
         cmd_block_markpattern();
         return true;

      case "block_selectnone":
         cmd_block_selectnone();
         return true;

      case "block_copyblock":
         cmd_block_copyblock();
         return true;

      case "block_paste":
         cmd_block_paste();
         return true;

      case "block_pasteshift":
         cmd_block_pasteshift();
         return true;

      case "block_quantize_last":
         cmd_block_quantize_last();
         return true;

      case "block_quantize_100":
         cmd_block_quantize_100();
         return true;

      case "block_quantize_50":
         cmd_block_quantize_50();
         return true;

      case "block_quantize_25":
         cmd_block_quantize_25();
         return true;

      case "block_quantize_dialog":
         cmd_block_quantize_dialog();
         return true;

      case "block_transpose_up":
         cmd_block_transpose_up();
         return true;

      case "block_transpose_down":
         cmd_block_transpose_down();
         return true;

      case "block_shift_up":
         cmd_block_shift_up();
         return true;

      case "block_shift_up_tick":
         cmd_block_shift_up_tick();
         return true;

      case "block_shift_down":
         cmd_block_shift_down();
         return true;

      case "block_shift_down_tick":
         cmd_block_shift_down_tick();
         return true;


      // ---------------------------------------------------
      // --                                               --
      // -- instrument                                    --
      // --                                               --
      // ---------------------------------------------------
      case "instrument_toggleviews":
         cmd_instrument_toggleviews();
         return true;

      case "instrument_kjoctavedown":
         cmd_instrument_kjoctavedown();
         return true;

      case "instrument_kjoctaveup":
         cmd_instrument_kjoctaveup();
         return true;

      case "instrument_previous":
         cmd_instrument_previous();
         return true;

      case "instrument_next":
         cmd_instrument_next();
         return true;

      case "instrument_enternumber":
         cmd_instrument_enternumber();
         return true;

      case "instrument_editsample":
         cmd_instrument_editsample();
         return true;

      case "instrument_radias_init":
         // if(STConfig.b_enable_korg_radias)
         // {
         //    MIDI.korg_radias.sendInitState();
         // }
         return true;

      case "instrument_keyjazzmanualnoteoff":
         cmd_instrument_keyjazzmanualnoteoff();
         return true;
      }

      return false;
   }

   // <ui_timer.png>
   public virtual handleReplayTimer() {
      // // if(replay.b_playing)
      // // {
      // // }
      handleQueuedNormalizedParamUpdates();
      handleQueuedBidirectionalControls();
   }

   // <replay.png>
   public virtual handleReplayTick() {
      // called from replay thread
      pattern_view.handleReplayTick();
   }

   // <method_handle.png>
   public virtual handleReplayTickUI() {
      // called from UI thread when replay is running
      pattern_view.handleReplayTickUI();
   }

   // <method_handle.png>
   public virtual handleStartPlaying() {
      // // // tracker_node.nodeCopyLastPatternStartSongOffsetFromEditor();

      pattern_view.handleStartPlaying();
   }

   // <method_handle.png>
   public virtual handleStopPlaying(boolean _bAllowBookmark) {

      // // // tracker_node.nodeCopyLastPatternStartSongOffsetFromEditor();

      if(tracker_node.b_tap_mode)
      {
         Global.Debug2("NodeTrackerEditor::handleStopPlaying: set playpat=editpat ("+tracker_node.nodeGetCurrentEditPatternNr()+")");
         tracker_node.nodeSetCurrentPlayPatternNr(tracker_node.nodeGetCurrentEditPatternNr()); // deselect tmp pat after tap_mode
      }

      pattern_view.handleStopPlaying(_bAllowBookmark);
   }

   // <method_handle.png>
   public virtual handleSongPosSelected() {
      // called from UI thread while =replay= is locked
      Global.Debug2("NodeTrackerEditor::handleSongPosSelected: current_song.song_offset="+current_song.song_offset);
      tracker_node.nodeSetLastPatternStartEditorSongOffset(current_song.song_offset);

      if(tracker_node.nodeIsMaster())
      {
         tracker_node.setEditOffset(current_song.song_offset);
      }

      pattern_view.queueRedrawAll();
   }

   // <method_handle.png>
   public virtual handlePlayPatChanged() {
      // called when play pattern has changed or node is shown
      int patNr = tracker_node.nodeGetCurrentPlayPatternNr();
      int qPatNr = tracker_node.jam_queued_pattern_nr;

      String cap = (MNT_PatternView.patnr3_strings.get(patNr & 127));

      cap.append(" / ");

      if(qPatNr >= 0)
      {
         cap.append( (MNT_PatternView.patnr3_strings.get(qPatNr & 127)) );
      }
      else
      {
         cap.append("---");
      }

      lb_playpat.setCaption(cap);
      lb_playpat.redraw();

      if(STConfig.b_node_tracker_edit_pattern_follows_replay_pattern)
      {
         // if(patNr != tracker_node.nodeGetCurrentEditPatternNr())
         {
            tracker_node.nodeSetCurrentEditPatternNr(patNr);
            /////nodeHandleEditPatternChanged();

            // // if(!replay.b_playing)
            // {
            //    // tracker_node.nodeSetLastPatternStartEditorSongOffset(mathMaxi(0, current_song.song_offset - tracker_node.getEditOffset()));
            //    tracker_node.nodeSetLastPatternStartEditorSongOffset(current_song.song_offset);
            // }

            root_form.pg_node.handleEditPatternChanged();  // update label
            handlePatNrChanged3();
         }
      }
   }

   // <method_handle.png>
   public virtual evHandleRedrawPattern() {
      // called when EV_REDRAWPATTERN is received

      if(replay.b_playing)
      {
         pattern_view.flagRenderAll();
      }
      else
      {
         pattern_view.renderAndRedrawAll();
      }
   }

   // <method_handle.png>
   public virtual evHandleScrollDownPattern() {
      // called when EV_SCROLLDOWNPATTERN is received

      if(!(replay.b_playing && tracker_node.doAutoScroll()))
      {
         pattern_view.scrollDownEventEntered();
      }
   }

   // <method_handle.png>
   public virtual evHandleRecordMidiEndSchedule() {
      // trace "xxx -------- nte::evHandleRecordMidiEndSchedule";
      // Utils.Backtrace();
      // if(!(pattern_view.ta_recordmidiend.isScheduled()))
      pattern_view.ta_recordmidiend.cancel();
      pattern_view.ta_recordmidiend.schedule();
   }

   // <ui_handle.png>
   public method toggleKeyJazz() {
      bt_keyjazz.toggleSelection();
      Global.Print("KeyJazz is now "+Utils.GetEnableString(bt_keyjazz.isSelected()));
   }

   // <ui_init.png>
   public virtual onOpen() {
      pattern_view.onOpen();
   }

   // <ui_kbd.png>
   public method handleCtrlAcceleratorKey(Key _k) : boolean {
      switch(_k.pressed)
      {
         case '[': // ue on ger. keyboard
            if(_k.modShift())
            {
               // // Global.cmd_macro_previous();
            }
            else
            {
               cmd_instrument_previous();
            }
            return true;

         case ']': // + on ger. keyboard
            if(_k.modShift())
            {
               // // Global.cmd_macro_next();
            }
            else
            {
              cmd_instrument_next();
            }
            return true;

         case VKEY_TAB:
            if(_k.modShift())
            {
               cmd_edit_toggleenvelopeview();
               return true;
            }
            break;
      }
      return false;
   }

   // <ui_kbd.png>
   public virtual onBeginTriadKeyMode() : boolean {
      Global.Print("lctrl-x - ");
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {

      // (note) never shown ? see NT_PatternView::onTriadKeyTimeout()

      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
            d       :   Toggle pattern manager
            u       :   Focus node name widget
            z       :   Switch between pipenodes A/B
          TAB       :   Cycle pattern/play/arp views
          BACKSPACE :   Toggle ignore prgchg/mute mode
          INSERT    :   Toggle follow-replay edit mode
"
          // TAB       :   (todo)
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      int key = _k.pressed;
      boolean r = false;
      loop(2) // first pass for raw keycode, second pass for unicode
      {
         // US (reference) keyboard layout (raw keycodes)
         switch(key)
         {
            case 'c':
               togglePlayView();
               r = true; break;

            case 'd':
               // trace "xxx toggleviews";
               // // toggleViews();
               root_form.pg_node.togglePatternManager();
               r = true; break;

            case 'y':
               root_form.pg_node.handlePipeNodeABSwap();
               r = true; break;

            // case 'x':
            case VKEY_TAB:
               togglePlayView();
               r = true; break;

            case VKEY_BACKSPACE:
               cmd_replay_toggleignorearr_node();
               r = true; break;

            case VKEY_INSERT:
               cmd_replay_togglefollowarr();
               r = true; break;

            default:
               r = maybe; break;
         }

         if(true == r)
         {
            return true;
         }
         else if(maybe == r)
         {
            Global.Print("");
         }

         // see above
         key = _k.unicode;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {

      // trace "[>>>] NodeTrackerEditor::onKey: code="+_k.code+" pressed="+_k.pressed+" mod="+_k.mod;

      if(_k.pressed)
      {
         switch(_k.pressed)
         {
            case VKEY_LEFT:
               if(_k.modNone())
               {
                  if(UI.GetKeyboardFocus() == tv_arp_notes.getTableViewData())
                  {
                     decSelectedArpNote();
                     return true;
                  }
               }
               return false;

            case VKEY_RIGHT:
               if(_k.modNone())
               {
                  if(UI.GetKeyboardFocus() == tv_arp_notes.getTableViewData())
                  {
                     incSelectedArpNote();
                     return true;
                  }
               }
               return false;
         }

         if(_k.modCtrl())
         {
            if(!_k.modAlt()) // workaround since SDL reports ctrl flag for alt-} keypress e.g..
            {
               if(handleCtrlAcceleratorKey(_k))
               {
                  return true;
               }
            }
         }

         // trace "xxx checkAcceleratorList(k.name="+_k.name+")";
         if( !( UI.b_key_cmd_copy_paste && (VKEY_LALT==_k.code) ) )  // don't open menu on macOS for cmd-c/v to work
         {
            if(UI.b_key_cmd_copy_paste && _k.modAlt())
            {
               _k.mod = (_k.mod & ~VMOD_LALT) | VMOD_LCTRL;  // prevent submenu selection when pressing cmd-c/v
            }

            // trace "xxx call checkAcceleratorList(k.name="+_k.name+")";
            if(menubar.checkAcceleratorList(_k))
            {
               return true;
            }

            if(VIEW_INSTRUMENT == ls_view.getCurrentChildNr())
            {
               // e.g. lalt-INSERT
               if(instrument_view.onKey(_k))
                  return true;
            }
         }
      }

      switch(_k.pressed)
      {
         case 'q':
            if(_k.modNone())
            {
               if(VIEW_PATTERN != ls_view.getCurrentChildNr())
               {
                  showView(VIEW_PATTERN, true/*bEnterLeave*/);
                  return true;
               }
            }
            return false;

         case VKEY_F7:
            if(_k.modShift())
            {
               cmd_pattern_import_ar();
               return true;
            }
            break;

         case VKEY_F8:
            if(_k.modShift())
            {
               cmd_pattern_import_trigseq();
               return true;
            }
            break;

         // // case VKEY_F11:
         // //    cb_mmcrec.toggleSelection();
         // //    Global.Print("MMCRec is now "+Utils.GetEnableString(cb_mmcrec.isSelected()));
         // //    return true;

         case VKEY_F12:
            ////case 'a':
            if(_k.modCtrlOnly())
            {
               toggleKeyJazz();
               return true;
            }
            return false;

         case VKEY_TAB:
            if(VMOD_LCTRL == _k.mod)
            {
               // Called when LEAVING instrument view
               //  (note) when PatternView has kbd focus, PatternView::handleKeyTab() enters InstrumentView
               toggleViews();
               return true;
            }
            break;

         case VKEY_ESCAPE:
            if(VIEW_PATTERN != ls_view.getCurrentChildNr())
            {
               showView(VIEW_PATTERN, true/*bEnterLeave*/);
               return true;
            }
            break;
      }

      if(trySelectPatternByUsedIdx(_k))
         return true;

      if(_k.modShift())
      {
         switch(_k.pressed)
         {
            case 'x':
               if(_k.modCtrl())
               {
                  if(pattern_view.hasKeyboardFocus())
                  {
                     if(1 != ls_envelope.getCurrentChildNr())
                     {
                        toggleEnvelopeView(true/*bForce*/);
                     }
                     envelope_view.focusEditMode();
                  }
                  else
                  {
                     UI.SetKeyboardFocus(pattern_view);
                  }
                  return true;
               }
               break;
         }
      }

      return NodeEditor::onKey(_k);
   }

   // <ui_cmd.png>
   public virtual cmdGetAvailableCommands() : StringArray {
      return ["env_shreset",
              "init_audio\t<dev>:<midich> <smpnamepattern=*> <patlen16th=64> <startpat=01A> <startinstrnr=1> <patnradv=4>",
              "neg_harmony\t<key>",
              "rand_ctl_abs\t<min=0> <max=127>",
              "rand_ctl_delta\t<min=20> <max=20>",
              "rand_ctl_rel\t<min=80%> <max=120%>",
              "scale_ctl\t<factor=2>",
              "spread_unique_notes_to_tracks",
              "timescale_curtrack\t<factor=2>",
              "timescale_alltracks\t<factor=2>",
              ];
   }

   // <ui_cmd.png>
   public method cmdGetDefaultActions() : StringArray {
      return ["env_shreset",
              "rand_ctl_abs 0 127",
              "rand_ctl_delta 20 20",
              "rand_ctl_rel 80 120",
              "spread_unique_notes_to_tracks",
              "scale_ctl 0.5",
              "scale_ctl 2.0",
              "timescale_curtrack 0.5",
              "timescale_curtrack 2.0",
              "timescale_alltracks 0.5",
              "timescale_alltracks 2.0",
              ];
   }

   // <ui_cmd.png>
   public virtual cmdGetActionToolTips() : HashTable {
      return #[
         "spread_unique_notes_to_tracks"
         = "Spread (drum-trig) notes to separate tracks. Tracks must be created prior to executing this function.",
               ];
   }

   // <ui_cmd.png>
   public virtual cmdFindArgAutoCompletions(String _cmd, int _argIdx, String _prefix) : StringArray {
      return null;
   }

   // <ui_cmd.png>
   public virtual cmdGetAvailableArgs(String _cmd, int _argIdx) : StringArray {
      Global.Debug2("NodeTrackerEditor::cmdGetAvailableArgs: cmd=\""+_cmd+"\" argIdx="+_argIdx);
      switch(_cmd)
      {
         case "env_shreset":
            break;

         case "neg_harmony":
            return Scale.key_names_lc;

         case "rand_ctl_abs":
         case "rand_ctl_rel":
            break;

         case "init_audio":
            switch(_argIdx)
            {
               case 0:
                  // (note) usually 'vst_h' (idx=7)
                  String audioDevName <= MIDI.GetVSTOutDeviceNameByIdx(STConfig.preferred_audio_dev_idx);
                  if(null != audioDevName)
                  {
                     byte audioMidiCh = 1;
                     local StringArray aAudioDevs;
                     loop(16)
                     {
                        aAudioDevs.add("audioDevName:"+audioMidiCh);
                        audioMidiCh++;
                     }
                     return deref aAudioDevs;
                  }
                  return ["none"];

               case 1:
                  return ["*"];

               case 2:
                  return ["8", "16", "24", "32", "48", "64", "80", "96", "128"];

               case 3:
                  return Node.patnr_options_short;

               case 4:
                  return NodeTrackerEditor.instr_nr_names;

               case 5:
                  return ["1", "4"];
            }
            break;
      }
      return null;
   }

   // <ui_cmd.png>
   protected method handlePageCmdNegHarmony(StringArray _argv) : boolean {
      if(2 == _argv.numElements)
      {
         int key = Scale.FindKeyIdxByString(_argv.get(1));
         if(-1 != key)
         {
            pattern_view.blockNegHarmony(key);
            return true;
         }
      }
      return false;
   }

   // <ui_cmd.png>
   protected method handlePageCmdRandCtlAbs(StringArray _argv) : boolean {
      float min = 0;
      float max = 127;
      float t;

      if(_argv.numElements >= 2)
      {
         min = _argv.get(1);
         if(min < 0)
            min = 0;
      }
      if(_argv.numElements >= 3)
      {
         max = _argv.get(2);
         if(max < 0)
            max = 0;
      }
      if(min > max)
      {
         t = min;
         min = max;
         max = t;
      }

      pattern_view.blockRandCtl(min, max, 1/*abs*/);
      return true;
   }

   // <ui_cmd.png>
   protected method handlePageCmdRandCtlDelta(StringArray _argv) : boolean {
      float min = 20;  // neg
      float max = 20;  // pos
      float t;

      if(_argv.numElements >= 2)
      {
         min = _argv.get(1);
         if(min < 0)
            min = 0;
      }
      if(_argv.numElements >= 3)
      {
         max = _argv.get(2);
         if(max < 0)
            max = 0;
      }

      pattern_view.blockRandCtl(min, max, 2/*delta*/);
      return true;
   }

   // <ui_cmd.png>
   protected method handlePageCmdRandCtlRel(StringArray _argv) : boolean {
      float min = 80;
      float max = 120;
      float t;

      if(_argv.numElements >= 2)
      {
         min = _argv.get(1);
         if(min < 0)
            min = 0;
      }
      if(_argv.numElements >= 3)
      {
         max = _argv.get(2);
         if(max < 0)
            max = 0;
      }
      if(min > max)
      {
         t = min;
         min = max;
         max = t;
      }

      pattern_view.blockRandCtl(min / 100.0, max / 100.0, 3/*rel*/);
      return true;
   }

   // <ui_cmd.png>
   protected method handlePageCmdScaleCtl(StringArray _argv) : boolean {
      float factor = 2.0;
      if(_argv.numElements >= 2)
         factor = _argv[1];
      pattern_view.blockScaleCurrentCtl(factor);
      return true;
   }

   // <ui_cmd.png>
   protected method handlePageCmdScaleTime(StringArray _argv, boolean _bAllTracks) : boolean {
      float factor = 2.0;
      if(_argv.numElements >= 2)
         factor = _argv[1];
      if(0.0f < factor <= 3072)
      {
         pattern_view.patternTimeMulConst(factor, _bAllTracks);
         return true;
      }
      return false;
   }

   // <ui_cmd.png>
   protected method handlePageCmdToggleSHReset() : boolean {
      boolean bSHReset = pattern_view.toggleCurrentEnvelopeShReset();
      Global.Print("Envelope SHReset is "+Utils.GetEnableString(bSHReset));
   }

   // <ui_cmd.png>
   protected =replay= method handlePageCmdInitAudio2(STX_MIDIOutDevice outDev, byte midiCh,
                                                     int patlen16th,
                                                     int startPat,
                                                     int startInstr,
                                                     int patAdv
                                                     ) : boolean {
      // trace "xxx audio_init: recvd samples="+#(SysEx.queued_recv_samples)+" prgIds="+#(SysEx.queued_recv_sample_prg_ids);
      int smpIdx = 0;
      NT_Instrument *ins;

      tracker_node.undoBeginNested("pagecmd_init_audio");
      tracker_node.undoTouchNodeState();

      int numInsInit = 0;
      int numPatInit = 0;

      int curInstrNr = startInstr;
      int curPatNr = startPat;
      NT_MetaPattern *metaPat;
      int patLenTicks = patlen16th * current_song.ppq / 4.0;

      SysExSample *sysSmp;

      foreach sysSmp in SysEx.queued_recv_samples
      {
         if(curInstrNr < 62)
         {
            if(curPatNr < 122)
            {
               if(-1 != sysSmp.prg_id)
               {
                  // Create/Init instrument
                  String smpName <= sysSmp.name;
                  Global.Debug("nt:audio_init: ["+numInsInit+"] init instrument "+curInstrNr+" name=\""+smpName+"\"");
                  ins <= tracker_node.initInstrumentAt(curInstrNr,
                                                       outDev.dev_idx, midiCh,
                                                       sysSmp.prg_id,
                                                       smpName
                                                       );
                  ins.b_audio = true;
                  numInsInit++;

                  // Create/init pattern
                  metaPat <= tracker_node.getOrCreateMetaPattern(curPatNr);
                  metaPat.setNumTicks(patLenTicks);
                  if(smpName.length > 9)
                     metaPat.patSetName(smpName.substring(smpName.length-1-8, 8));
                  else
                     metaPat.patSetName(smpName);
                  Global.Debug("nt:audio_init: ["+numPatInit+"] init pattern "+curPatNr+" name=\""+metaPat.pat_name+"\"");

                  NT_Track *track;
                  if(0 == (tracker_node.tracks.numElements))
                  {
                     track <= tracker_node.lazyCreateTrackByName("audio");
                  }
                  else
                  {
                     track <= tracker_node.tracks.get(0);
                  }
                  // // track.current_instrument_nr = curInstrNr;
                  // // track.keyjazz_instr_nr = curInstrNr;
                  NT_TrackPattern *trackPat;
                  trackPat <= track.getOrCreatePattern(curPatNr);
                  Envelope env <= trackPat.getCreateEnvelope(NT_Defs.CTL_INSTR);
                  env.insertReplaceEvent(0/*patOffset*/, curInstrNr, 1/*res*/);

                  numPatInit++;

                  curInstrNr++;
                  curPatNr += patAdv;
               }
            }
         }

         // Next sample
         smpIdx++;
      }

      selectPatternByIdx(startPat);
      keyJazzSelectInstrument(startInstr, true/*bMakeVisible*/, true/*bQuiet*/);

      tracker_node.undoEndNested("pagecmd_init_audio");

      Global.Print("Init "+numInsInit+" instrument"+Utils.GetPluralString(numInsInit)+" and "+numPatInit+" pattern"+Utils.GetPluralString(numPatInit));

      return true;
   }

   // <ui_cmd.png>
   protected method handlePageCmdInitAudio(StringArray _argv) : boolean {
      if(_argv.numElements >= 3)
      {
         trace "xxx handlePageCmdInitAudio: dev_ch="+_argv.get(1);
         local StringArray devCh <= _argv.get(1).splitChar(':');
         if(null != devCh)
         {
            local String devName <= devCh.get(0);
            if(null != devName)
            {
               int midiCh = mathClampi(int(devCh.get(1)) - 1, 0, 15);
               STX_MIDIOutDevice outDev <= MIDI.GetMIDIOutDeviceByAliasOrName(devName);

               if(null != outDev)
               {
                  int patlen16th = 64;
                  int startPat   = 0;
                  int startInstr = 1;
                  int patAdv     = 4;

                  if(_argv.numElements > 3)
                     patlen16th = mathClampi(int(_argv.get(3)), 1, 3072*4);

                  if(_argv.numElements > 4)
                     startPat = mathClampi(Node.patnr_options_short.indexOf(_argv.get(4), 0), 0, 124);

                  if(_argv.numElements > 5)
                     startInstr = mathClampi(NodeTrackerEditor.instr_nr_names.indexOf(_argv.get(5), 0), 1, 62);

                  if(_argv.numElements > 6)
                     patAdv = mathClampi(int(_argv.get(6)), 1, 16);

                  Global.Debug("nt::handlePageCmdInitAudio: dev=\""+devName+"\" ch="+(midiCh+1)+" namePat=\""+_argv.get(2)+"\" patlen16th="+patlen16th+" startPat="+(Node.patnr_options_short.get(startPat))+" startInstr="+(NodeTrackerEditor.instr_nr_names.get(startInstr))+" patAdv="+patAdv);

                  SysEx.QueueSendQuerySamples(_argv.get(2)/*namePattern*/, STConfig.node_tracker_audioclip_note/*def=C-5*/);
                  int t = milliSeconds();
                  for(;;)
                  {
                     if(SysEx.b_queued_recv_samples)
                     {
                        return handlePageCmdInitAudio2(outDev, midiCh,
                                                       patlen16th,
                                                       startPat,
                                                       startInstr,
                                                       patAdv
                                                       );
                     }

                     int dt = milliSeconds() - t;
                     if(dt >= 2000)
                     {
                        Global.Error("audio_init: SysEx timeout (2000ms)");
                        return false;
                     }
                  }
               }
               else
               {
                  Global.Error("Invalid dev \""+devName+"\"");
               }
            }
            else
            {
               Global.Error("Invalid dev:ch \""+_argv.get(1)+"\"");
            }
         } // if devCh
      } // if #args >= 3
      return false;
   }

   // <ui_cmd.png>
   public =replay= method handlePageCmdSpreadUniqueNotesToTracks(boolean _bUndoBeginEnd) : boolean {
      // (note) added for drum maps (e.g. imported audio to midi notes)
      // (note) count unique notes and check if there are enough tracks
      // (note) move notes to tracks (e.g. C-4=bd, D-4=sd, a#4=ch, ..)

      NT_MetaPattern mpat <= tracker_node.getCurrentEditMetaPattern();
      if(null != mpat)
      {
         int numTracks = tracker_node.tracks.numElements;
         if(numTracks > 0)
         {
            NT_Track track <= pattern_view.getCurrentTrack();
            if(null != track)
            {
               NT_TrackPattern pat <= track.getCurrentEditPattern();
               if(null != pat)
               {
                  Envelope envOrig <= pat.getEnvelope(NT_TrackPattern.CTL_NOTE1);
                  if(null != envOrig)
                  {
                     local Envelope env = envOrig;

                     int evIdx = 0;
                     int note;
                     int uniqueNote;
                     local IntArray uniqueNotes;

                     loop(env.numElements / 2)
                     {
                        note = env[evIdx + 1];
                        if(note < 0)
                           note = -note;
                        if(!uniqueNotes.contains(note))
                           uniqueNotes.add(note);

                        // Next Note event
                        evIdx += 2;
                     }

                     if(uniqueNotes.numElements <= numTracks)
                     {
                        if(_bUndoBeginEnd)
                        {
                           tracker_node.undoBeginNested("spread_unique_notes_to_tracks");
                           tracker_node.undoTouchPattern(mpat.pat_nr);
                        }

                        local IntArray unSorted;
                        uniqueNotes.sortByValue(unSorted);
                        uniqueNotes.rearrange(unSorted);

                        int oldEditOff = tracker_node.getEditOffset();
                        int oldBlockMode = pattern_view.block_mode;
                        int oldCursorTrackIdx = pattern_view.getCurrentTrackNr();
                        int oldStepResolution = tracker_node.pv_step_resolution;
                        pattern_view.setStepResolution(1);
                        pattern_view.block_mode = NT_PatternView.BLOCK_MODE_TRACK;  // in case we are currently in CTL or PATTERN mode
                        NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
                        pattern_view.b_block_quiet = true;

                        int evAbsTime = 0;
                        evIdx = 0;
                        int numEv = env.numElements / 2;
                        loop(numEv)
                        {
                           evAbsTime += env[evIdx + 0];
                           note = env[evIdx + 1];
                           if(note < 0)
                              note = -note;

                           int uniqueTrackIdx = uniqueNotes.indexOf(note, 0);
                           // trace "xxx evAbsTime="+evAbsTime+" note="+note+" => uniqueTrackIdx="+uniqueTrackIdx;

                           if(oldCursorTrackIdx != uniqueTrackIdx)
                           {
                              tracker_node.setEditOffset(evAbsTime);

                              // Copy row to clipboard
                              pattern_view.moveCursorToTrack(oldCursorTrackIdx);
                              pattern_view.blockAncBegin();
                              pattern_view.blockAncUpdate();
                              pattern_view.blockCopy();

                              // Remove row
                              tracker_node.removeEventAt(track, -1/*allCtls*/, evAbsTime, 1/*res*/);
                              tracker_node.shiftEventsAt(track, -1/*allCtls*/, evAbsTime, 1/*res*/);

                              // Paste row on new track
                              pattern_view.moveCursorToTrack(uniqueTrackIdx);
                              pattern_view.blockPaste(true/*bShift*/, false/*bUndoStartEnd*/, false/*bScrollDown*/);

                              // evIdx -= 2;
                           }
                           // else: same track, keep row

                           // Next Note event
                           evIdx += 2;
                        }

                        pattern_view.setStepResolution(oldStepResolution);
                        pattern_view.block_mode = oldBlockMode;
                        pattern_view.moveCursorToTrack(oldCursorTrackIdx);
                        pattern_view.selectNone();
                        NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);
                        tracker_node.setEditOffset(oldEditOff);
                        pattern_view.b_block_quiet = false;

                        if(_bUndoBeginEnd)
                           tracker_node.undoEndNested("spread_unique_notes_to_tracks");

                        pattern_view.renderAndRedrawAll();
                        Global.Success("spread_unique_notes: "+uniqueNotes.numElements+" unique note"+Utils.GetPluralString(uniqueNotes.numElements)+", "+numEv+" CTL_NOTE1 events");

                        // Succeeded
                        return true;
                     }
                     else
                     {
                        Global.Warning("spread_unique_notes_to_tracks: have "+uniqueNotes.numElements+" note"+Utils.GetPluralString(uniqueNotes.numElements)+" but only "+numTracks+" track"+Utils.GetPluralString(numTracks));
                     }
                  }
                  else
                  {
                     Global.Warning("spread_unique_notes_to_tracks: missing CTL_NOTE1 envelope");
                  }
               }
               else
               {
                  Global.Warning("spread_unique_notes_to_tracks: missing track pattern");
               }
            }
            else
            {
               Global.Warning("spread_unique_notes_to_tracks: missing track");
            }
         }
      }

      return false;
   }

   // <ui_cmd.png>
   public virtual cmdExec(StringArray _argv) : boolean {
      Global.Debug("NodeTrackerEditor::cmdExec: argv="+#(_argv));
      switch(_argv.get(0))
      {
         case "neg_harmony":
            return handlePageCmdNegHarmony(_argv);

         case "rand_ctl_abs":
            return handlePageCmdRandCtlAbs(_argv);

         case "rand_ctl_delta":
            return handlePageCmdRandCtlDelta(_argv);

         case "rand_ctl_rel":
            return handlePageCmdRandCtlRel(_argv);

         case "scale_ctl":
            return handlePageCmdScaleCtl(_argv);

         case "spread_unique_notes_to_tracks":
            return handlePageCmdSpreadUniqueNotesToTracks(true/*bUndoBeginEnd*/);

         case "timescale_curtrack":
            return handlePageCmdScaleTime(_argv, false/*bAllTracks*/);

         case "timescale_alltracks":
            return handlePageCmdScaleTime(_argv, true/*bAllTracks*/);

         case "init_audio":
            return handlePageCmdInitAudio(_argv);

         case "env_shreset":
            return handlePageCmdToggleSHReset();
      }
      return false;
   }

   // <ui_kbd.png>
   public virtual handleKeyboardFocusChanged(Layer _newKeyboardLayer) {
      // trace "xxx NodeTrackerEditor::handleKeyboardFocusChanged: newKeyboardLayer="+#(_newKeyboardLayer);
      if(_newKeyboardLayer instanceof NT_PatternView)
         tracker_node.nodeSetLastEditFocus(_newKeyboardLayer);
      else if(null != _newKeyboardLayer)
      {
         Layer p <= _newKeyboardLayer.getParentLayerType(NT_PatternView);
         if(null != p)
            tracker_node.nodeSetLastEditFocus(p);
         else
            tracker_node.nodeSetLastEditFocus(null);
      }
      else
         tracker_node.nodeSetLastEditFocus(null);
      queueUpdateBidirectionalControls();
   }


   // <ui_update.png>
   public =replay= virtual updateBidirectionalControls() {
      // trace "xxx NodeTrackerEditor::updateBidirectionalControls";
      int rpn = Node.RPN_CTL_BASE;
      if(tracker_node.nodeGetLastEditFocus() instanceof NT_PatternView)
      {
         // Update from cursor ctl
         NT_Track track <= pattern_view.getCurrentTrack();
         if(null != track)
         {
            NT_CEL cel <= pattern_view.getCurrentControllerLayout();
            if(null != cel) // should not be null
            {
               int ctlId = cel.ctl_id;
               float minVal = cel.getMinVal();
               float maxVal = cel.getMaxVal();
               // trace "xxx NodeTrackerEditor::updateBidirectionalControls: ctlId="+ctlId+" minVal="+minVal+" maxVal="+maxVal;
               float numTicksPer16th = current_song.ppq / 4.0;
               StringArray ctlNames <= NT_Defs.ctl_short_names;

               Envelope env <= pattern_view.getCurrentEnvelope(ctlId);
               if(null != env)
               {
                  int envIdx = 0;
                  int evNr = 1;
                  int absTime = 0;
                  Float fo16;
                  loop(mathMini(16, env.numElements/2))
                  {
                     absTime += env[envIdx + 0];
                     fo16 = absTime / numTicksPer16th;
                     float rpnVal = mathClampf(16383.0 * ((env[envIdx + 1] - minVal) / (maxVal - minVal)), 0, 16383);
                     // // tracker_node.nodeQueueBidirectionalEditFocusRPNUpdate(rpn, rpnVal, "ev "+evNr+" "+ioAbsTime.printf("%d"));
                     tracker_node.nodeQueueBidirectionalEditFocusRPNUpdate(rpn, rpnVal, ctlNames.get(ctlId)+" "+evNr+" "+fo16.printf("%3.2f"));

                     // Next event
                     envIdx += 2;
                     rpn++;
                     evNr++;
                  }
               }
            }
         }
      }

      while(rpn < (Node.RPN_CTL_BASE + 16))
      {
         tracker_node.nodeQueueBidirectionalEditFocusRPNUpdate(rpn++, 8192, "-");
      }
   }

   // <method.png>
   public method queueNormalizedParamUpdate(int _paramIdx, float _value) {
      // called from replay thread
      mtx_normalized_param_update.lock();
      if( (2*MAX_QUEUED_NORMALIZED_PARAM_UPDATES) == normalized_param_update_queue.numElements)
      {
         normalized_param_update_queue.delete(0); // paramidx
         normalized_param_update_queue.delete(0); // value
      }
      normalized_param_update_queue.add(_paramIdx);
      normalized_param_update_queue.add(_value);
      mtx_normalized_param_update.unlock();
   }

   // <ui_handle.png>
   protected =replay= method handleNormalizedParamUpdate(int _paramIdx, float _value) {
      // trace "xxx NodeTrackerEditor::handleNormalizedParamUpdate: paramIdx="+_paramIdx+" value="+_value;

      if(tracker_node.nodeGetLastEditFocus() instanceof NT_PatternView)
      {
         if(pattern_view.isEditable())
         {
            // Update event
            NT_Track track <= pattern_view.getCurrentTrack();
            if(null != track)
            {
               NT_CEL cel <= pattern_view.getCurrentControllerLayout();
               if(null != cel) // should not be null
               {
                  int ctlId = cel.ctl_id;
                  float minVal = cel.getMinVal();
                  float maxVal = cel.getMaxVal();
                  // trace "xxx NodeTrackerEditor::handleNormalizedParamUpdate: ctlId="+ctlId+" minVal="+minVal+" maxVal="+maxVal;

                  Envelope env <= pattern_view.getCurrentEnvelope(ctlId);
                  if(null != env)
                  {
                     if(_paramIdx < (env.numElements/2))
                     {
                        tracker_node.undoBeginNested("fader_edit");
                        tracker_node.undoTouchController(track.track_nr, tracker_node.nodeGetCurrentEditPatternNr(), ctlId, env);
                        float val = (_value / 16383.0) * (maxVal - minVal) + minVal;
                        env[_paramIdx*2 + 1] = val;
                        tracker_node.undoEndNested("fader_edit");
                        pattern_view.queueRedrawAll();
                     }
                  }
               }
            }
         } // isEditable
      } // PatternView has focus
   }

   // <ui_handle.png>
   protected method handleQueuedNormalizedParamUpdates() {
      // called from UI thread
      mtx_normalized_param_update.lock();
      for(;;)
      {
         if(normalized_param_update_queue.numElements >= 2)
         {
            int paramIdx  = normalized_param_update_queue[0];
            float value   = normalized_param_update_queue[1];
            normalized_param_update_queue.delete(0);
            normalized_param_update_queue.delete(0);
            mtx_normalized_param_update.unlock();
            handleNormalizedParamUpdate(paramIdx, value);  // tries to lock =replay=, beware of deadlocks!!
            mtx_normalized_param_update.lock();
         }
         else
         {
            break;
         }
      }
      mtx_normalized_param_update.unlock();
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      StringAction *sac;

      // trace "[>>>] NodeTrackerEditor::consumeAction: acName="+acName+" ap="+#(ap);

      switch(@(ap))
      {
         case @(bt_mode_edit):
            cmd_edit_togglemode();
            return true;

         case @(bt_mode_rtrecord):
            if(tracker_node.b_rt_record)
               pattern_view.handleKeySpace(false/*bShift*/, false/*bCtrl*/);
            else
               pattern_view.handleKeyRShift(false/*bCtrl*/);
            return true;

         case @(bt_mode_relshift):
            cmd_edit_toggleshiftmode();
            return true;

         case @(bt_mode_autoscroll):
            cmd_edit_autoscroll();
            return true;

         case @(bt_mode_wraparound):
            cmd_cursor_wraparound();
            return true;

         case @(bt_mode_bookmark):
            cmd_replay_invertspace();
            return true;

         case @(bt_mode_playstepreset):
            cmd_replay_playstepreset();
            return true;

         case @(bt_mode_selectplay):
            cmd_replay_selectandplay();
            return true;

         case @(bt_mode_freerun):
            cmd_replay_togglefreerun();
            return true;

         case @(bt_mode_ignorearr):
            cmd_replay_toggleignorearr_node();
            return true;

         case @(bt_mode_followarr):
            cmd_replay_togglefollowarr();
            return true;

         case @(bt_mode_chordadv):
            cmd_edit_toggleadvanceallnotesreleased();
            return true;

         case @(bt_mode_chordclear):
            cmd_edit_toggle_chordclearstep();
            return true;

         case @(bt_mode_tapmode):
            cmd_edit_tapmode();
            return true;

         case @(bt_mode_timing):
            cmd_edit_toggletimingview();
            return true;

         case @(bt_mode_timinglock):
            cmd_edit_toggletimingview_movelock();
            return true;

         case @(bt_mode_recnoteoff):
            cmd_events_recordnoteoff();
            return true;

         case @(bt_mode_recnoteoff_replay):
            cmd_events_recordnoteoff_replay();
            return true;

         case @(bt_mode_recquant):
            cmd_events_recordquantize();
            return true;

         case @(bt_mode_recdur):
            cmd_events_recordnoteoff_dur();
            return true;

         case @(bt_mode_envelope):
            cmd_edit_toggleenvelopeview();
            return true;

         case @(bt_mode_metronome):
            root_form.toggleMetronome();
            return true;

         case @(bt_mode_kjlock):
            cmd_track_lockkeyjazz();
            return true;

         case @(bt_mode_precount):
            cmd_events_recordpre();
            return true;

         case @(bt_mode_kjnoteoff):
            cmd_instrument_keyjazzmanualnoteoff();
            return true;

         case @(bt_mode_recusrctlnoteon):
            cmd_events_recordusrctlnoteon();
            return true;

         case @(bt_mode_kj):
            toggleKeyJazz();
            return true;

         case @(bt_mode_swaplshift):
            cmd_edit_swaplshift();
            return true;

         case @(bt_mode_reclatency):
            cmd_events_reclatency();
            return true;

         case @(bt_mode_piano):
            cmd_edit_togglepianowidget();
            return true;

         case @(bt_view_pattern):
            if(Button.ACTION_HOLD_CLICK == acName)
            {
               root_form.pg_node.togglePatternManager();
            }
            else
            {
               if(VIEW_PATTERN != ls_view.getCurrentChildNr())
               {
                  showView(VIEW_PATTERN, true/*bEnterLeave*/);
               }
               else
               {
                  root_form.pg_node.togglePatternManager();
                  // // showView(VIEW_INSTRUMENT, true/*bEnterLeave*/);
               }
            }
            return true;

         case @(bt_view_instruments):
            if(VIEW_INSTRUMENT != ls_view.getCurrentChildNr())
            {
               showView(VIEW_INSTRUMENT, true/*bEnterLeave*/);
            }
            else
            {
               showView(VIEW_PATTERN, true/*bEnterLeave*/);
            }
            return true;

         case @(bt_view_play):
            if(VIEW_PLAY != ls_view.getCurrentChildNr())
            {
               showView(VIEW_PLAY, true/*bEnterLeave*/);
            }
            else
            {
               showView(VIEW_PATTERN, true/*bEnterLeave*/);
            }
            return true;

         case @(bt_view_arp):
            if(VIEW_ARP != ls_view.getCurrentChildNr())
            {
               showView(VIEW_ARP, true/*bEnterLeave*/);
            }
            else
            {
               showView(VIEW_PATTERN, true/*bEnterLeave*/);
            }
            return true;

         case @(this):
            switch(acName)
            {
               case TA_NOTELABEL:
                  updateNoteIcon(false/*bRestartAnim*/);
                  return true;

               case TA_MODEWIDGETS:
                  updateModeWidgets();
                  ta_modewidgets.reschedule();
                  return true;
            }
            break;

         case @(dlg_edit_track_layout):
            switch(acName)
            {
               case Dialog.ACTION_HIDE:
                  // End transaction started by cmd_track_editlayout()
                  tracker_node.undoEndNested("cmd_track_editlayout");
                  break;
            }
            return true;

         case @(tf_pat_name):
            handlePatNameChanged(TextField.ACTION_TEXTENTERED == acName);
            return true;

         case @(bt_keyjazz):
            Global.Print("KeyJazz is now "+Utils.GetEnableString(bt_keyjazz.isSelected()));
            return true;

         case @(bt_follow):
            cmd_replay_toggleignoreandfollow(bt_follow.isSelected());
            Global.Print("Follow mode is now "+Utils.GetEnableString(bt_follow.isSelected()));
            return true;

         // // case @(cb_mmcrec):
         // //    Global.Print("MMCRec is now "+Utils.GetEnableString(cb_mmcrec.isSelected()));
         // //    return true;

         case @(cm_patnr):
            handlePatNrChanged(true);
            return true;

         case @(cm_mmc_patnr_group):
            handlePatNrGroupChanged(true);
            return true;

         case @(cm_mmc_patnr_sub):
            handlePatNrSubChanged(true);
            return true;

         case @(fp_patlen):
            switch(acName)
            {
               case FloatParam.ACTION_VALUECHANGING:
                  handlePatLenChanged(false);
                  break;

               case FloatParam.ACTION_VALUECHANGED:
                  handlePatLenChanged(true);
                  break;

               case FloatParam.ACTION_VALUEUNCHANGED:
                  refocusDefault();
                  break;
            }
            return true;

         case @(tf_kj_instrument):
            // trace "xxx tf_kj_instrument: acName="+acName;
            switch(acName)
            {
               case TextFieldIncDec.ACTION_INC:
                  cmd_instrument_next();
                  break;

               case TextFieldIncDec.ACTION_DEC:
                  cmd_instrument_previous();
                  break;

               case TextFieldIncDec.ACTION_LIST:
                  // cmd_instrument_manageinstruments();
                  break;

               case TextField.ACTION_TEXTCHANGED: // tab
                  handleKJInstrumentChanged(false);
                  break;

               case TextField.ACTION_TEXTENTERED: // return
                  handleKJInstrumentChanged(true);
                  break;

            }
            return true;

         case @(fp_kj_octave):
            switch(acName)
            {
               case FloatParam.ACTION_VALUECHANGING:
                  handleKJOctaveChanged(false);
                  break;

               case FloatParam.ACTION_VALUECHANGED:
                  handleKJOctaveChanged(true);
                  break;

               case FloatParam.ACTION_VALUEUNCHANGED:
                  refocusDefault();
                  break;
            }
            return true;

         case @(fp_kj_velocity):
            handleWriteVelocityChanged();
            switch(acName)
            {
               case FloatParam.ACTION_VALUECHANGING:
                  handleKJVelocityChanged(false);
                  break;

               case FloatParam.ACTION_VALUECHANGED:
                  handleKJVelocityChanged(true);
                  break;

               case FloatParam.ACTION_VALUEUNCHANGED:
                  refocusDefault();
                  break;
            }
            return true;

         case @(fp_kj_offvelocity):
            handleWriteOffVelocityChanged();
            switch(acName)
            {
               case FloatParam.ACTION_VALUECHANGING:
                  handleKJOffVelocityChanged(false);
                  break;

               case FloatParam.ACTION_VALUECHANGED:
                  handleKJOffVelocityChanged(true);
                  break;

               case FloatParam.ACTION_VALUEUNCHANGED:
                  refocusDefault();
                  break;
            }
            return true;

         case @(fp_kj_duration):
            handleWriteDurationChanged();
            switch(acName)
            {
               case FloatParam.ACTION_VALUECHANGING:
                  handleKJDurationChanged(false);
                  break;

               case FloatParam.ACTION_VALUECHANGED:
                  handleKJDurationChanged(true);
                  break;

               case FloatParam.ACTION_VALUEUNCHANGED:
                  refocusDefault();
                  break;
            }
            return true;

         case @(cb_write_instrnr):
            handleWriteInstrumentNrEnableChanged();
            refocusDefault();
            return true;

         case @(cb_write_velocity):
            handleWriteVelocityEnableChanged();
            refocusDefault();
            return true;

         case @(cb_addnotecel_vel):
            cmd_track_addnotecel_vel();
            refocusDefault();
            return true;

         case @(cb_write_offvelocity):
            handleWriteOffVelocityEnableChanged();
            refocusDefault();
            return true;

         case @(cb_write_duration):
            handleWriteDurationEnableChanged();
            refocusDefault();
            return true;

         case @(cb_addnotecel_dur):
            cmd_track_addnotecel_dur();
            refocusDefault();
            return true;

         case @(fp_stepresolution):
            switch(acName)
            {
               case FloatParam.ACTION_VALUECHANGING:
                  handleStepResolutionChanged(false);
                  break;

               case FloatParam.ACTION_VALUECHANGED:
                  handleStepResolutionChanged(true);
                  break;

               case FloatParam.ACTION_VALUEUNCHANGED:
                  refocusDefault();
                  break;
            }
            return true;

         case @(sr_tracks):
            if( (acName == Scroller.ACTION_VALUECHANGING) ||
                (acName == Scroller.ACTION_VALUECHANGED)
                )
            {
               pattern_view.moveCursorToTrack(sr_tracks.getValue());

               if((acName == Scroller.ACTION_VALUECHANGED))
                  refocusDefault();
            }
            return true;

            // "Play" view:
         case @(cm_node_class):
            handleNodeClassChanged();
            return true;

         case @(cb_node_class_show):
            handleNodeClassShowChanged();
            return true;

         case @(cm_node_class_show_in):
            handleNodeClassShowInChanged(tracker_node);
            f_autodev.handleNodeClassShowChanged();
            return true;

         case @(cm_play_mode):
            handlePlayModeChanged();
            return true;

         case @(cb_play_extclk):
            handlePlayExtClkChanged();
            return true;

         case @(fp_speed_scl_reset):
            handleSpeedSclResetValChanged();
            return true;

         case @(fp_play_extclk_gatetime):
            handleExtClkGateTimeChanged();
            return true;

         case @(cb_play_change_reset):
            handlePlayChangeResetChanged();
            return true;

         case @(fp_play_offlen_steps):
            handlePlayOffLenStepsChanged();
            return true;

         case @(fp_play_dur_steps):
            handlePlayDurStepsChanged();
            return true;

         case @(cb_play_match_instr):
            handlePlayMatchInstrChanged();
            return true;

         case @(cb_play_rec_qlast):
            handlePlayRecQLastChanged();
            return true;

         case @(cb_play_rec_prev):
            handlePlayRecPrevChanged();
            return true;

         case @(cb_play_rec_all):
            handlePlayRecAllChanged();
            return true;

         case @(cb_play_rec_spread):
            handlePlayRecSpreadChanged();
            return true;

         case @(cb_play_rec_bg):
            handlePlayRecBgChanged();
            return true;

         case @(cm_play_rec_mode):
            handlePlayRecModeChanged();
            return true;

         case @(cm_play_rec_sel):
            handlePlayRecSelChanged();
            return true;

         case @(cm_play_midi_node):
            handleMIDINodeGIDChanged();
            return true;

         case @(cm_play_audio_node):
            handleAudioNodeGIDChanged();
            return true;

         case @(cb_play_per_pattern_kj_instr):
            handlePerPatternKJInstrChanged();
            return true;

            // "Arp" view:
         case @(cb_arp):
            handleArpEnableChanged();
            return true;

         case @(tv_arp_notes):
            if(TableView.ACTION_ROWCLICKED == acName)
            {
            }
            else if(TableView.ACTION_ROWSELECTED == acName)
            {
               bt_arp_remove.setEditable(true);
               bt_arp_moveup.setEditable(true);
               bt_arp_movedown.setEditable(true);
            }
            else if(TableView.ACTION_SHOWCONTEXTMENU == acName)
            {
            }
            return true;

         case @(bt_arp_add):
            handleAddArpNote();
            return true;

         case @(bt_arp_remove):
            handleRemoveArpNote();
            return true;

         case @(bt_arp_moveup):
            handleMoveUpArpNote();
            return true;

         case @(bt_arp_movedown):
            handleMoveDownArpNote();
            return true;

         case @(cm_arp_baseoct):
            handleArpBaseOctaveChanged();
            return true;

         case @(cb_arp_reset):
            handleArpResetChanged();
            return true;

         case @(cb_arp_wrap):
            handleArpWrapChanged();
            return true;

         case @(cm_arp_latch):
            handleArpLatchChanged();
            return true;

         case @(cb_arp_latch_reset):
            handleArpLatchResetChanged();
            return true;

         case @(cb_arp_play_arp_notes):
            handleArpPlayArpNotesChanged();
            return true;

         case @(cb_arp_play_non_arp_notes):
            handleArpPlayNonArpNotesChanged();
            return true;

         case @(cb_arp_dynalen):
            handleArpDynaLenChanged();
            return true;

         case @(dlg_import_ar):
            if(NT_ImportARDialog.ACTION_AR_IMPORT == acName)
            {
               cmd_pattern_import_ar_handle_ok();
            }
            return true;

         case @(dlg_import_trigseq):
            if(NT_ImportTrigSeqDialog.ACTION_TRIGSEQ_IMPORT == acName)
            {
               cmd_pattern_import_trigseq_handle_ok();
            }
            return true;

         case @(dlg_import_monitor):
            if(NT_ImportMonitorDialog.ACTION_MONITOR_IMPORT == acName)
            {
               cmd_pattern_import_monitor_handle_ok(NodePattern.PatGetClipboardForClass("NM_Pattern"),
                                                    dlg_import_monitor.doReInit(),
                                                    dlg_import_monitor.doMulti(),
                                                    dlg_import_monitor.doInstrumentsAndParams(),
                                                    dlg_import_monitor.doConvRPNPC(),
                                                    dlg_import_monitor.doPreferCTLPC(),
                                                    dlg_import_monitor.doCopyPatName(),
                                                    dlg_import_monitor.doResetRec(),
                                                    dlg_import_monitor.doAlignBars(),
                                                    false/*bExplode*/,
                                                    true/*bUndo*/
                                                    );
            }
            return true;
      }

      switch(acName)
      {
         case "instrument_select_08":
            cmd_instrument_select(_action, 0*9, 1*9);
            return true;

         case "instrument_select_9H":
            cmd_instrument_select(_action, 1*9, 2*9);
            return true;

         case "instrument_select_IQ":
            cmd_instrument_select(_action, 2*9, 3*9);
            return true;

         case "instrument_select_RZ":
            cmd_instrument_select(_action, 3*9, 4*9);
            return true;

         case "instrument_select_ai":
            cmd_instrument_select(_action, 4*9, 5*9);
            return true;

         case "instrument_select_jr":
            cmd_instrument_select(_action, 5*9, 6*9);
            return true;

         case "instrument_select_sz":
            cmd_instrument_select(_action, 6*9, 7*9);
            return true;
      }

      // Try to handle menu item
      if(ap instanceof PopupMenu)
      {
         // trace "xxx NodeTrackerEditor:: handle menu item";
         if(VIEW_PATTERN == ls_view.getCurrentChildNr())
         {
            if(tryHandleMenuAction(acName))
            {
               return true;
            }
            else
            {
               trace "[~~~] NodeTrackerEditor: unhandled menu item=\""+acName+"\".";
               return true;
            }
         }
         else
         {
            if("instrument_toggleviews" == acName)
            {
               cmd_instrument_toggleviews();
               return true;
            }
            return false;
         }
      }

      return XMLForm::consumeAction(_action);
   }


}
