// ----
// ---- file   : Prophet08.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2016-2018 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ----
// ---- created: 08Feb2016
// ---- changed: 23Feb2017, 09May2017, 04Jan2018, 07Mar2018
// ----
// ----
// ----
module MProphet08;

use namespace ui;
use namespace st2;


// <class.png>
class Prophet08_Defs {
   // Layer B offset: 200
   define int OFF_LAYER_B = 200;

   // (note) enum uses tetra patch dump offsets
   define int OFF_OSC1_FREQ       =   0;  // 0..120
   define int OFF_OSC1_FINE       =   1;  // 0=-50, 50=0, 100=+50
   define int OFF_OSC1_SHAPE      =   2;  // 0=off, 1=saw, 2=tri, 3=saw/tri, 4..103=pulse 0..99
   define int OFF_OSC1_GLIDE      =   3;  // 0..127
   define int OFF_OSC1_KBD        =   4;  // 0=off, 1=on
   define int OFF_OSC1_SUB_LEVEL  =   5;  // 0..127 (tetra)
   define int OFF_OSC2_FREQ       =   6;  // 0..120
   define int OFF_OSC2_FINE       =   7;  // 0=-50, 50=0, 100=+50
   define int OFF_OSC2_SHAPE      =   8;  // 0=off, 1=saw, 2=tri, 3=saw/tri, 4..103=pulse 0..99
   define int OFF_OSC2_GLIDE      =   9;  // 0..127
   define int OFF_OSC2_KBD        =  10;  // 0=off, 1=on
   define int OFF_OSC2_SUB_LEVEL  =  11;  // 0..127 (tetra)
   define int OFF_SYNC_EN         =  12;  // 0=off, 1=on
   define int OFF_GLIDE_MODE      =  13;  // 0=fixed rate, 1=fixed rate auto, 2=fixed time, 3=fixed time auto
   define int OFF_OSC_SLOP        =  14;  // 0..5
   define int OFF_PITCHBEND_RANGE =  15;  // 0..12
   define int OFF_OSC_MIX         =  16;  // 0..127
   define int OFF_NOISE_LEVEL     =  17;  // 0..127
   define int OFF_FEEDBACK_VOL    =  18;  // 0..127 (tetra)


   define int OFF_FEEDBACK_GAIN   =  21;  // 0..127 (tetra)
   define int OFF_FLT_FREQ        =  20;  // 0..164
   define int OFF_FLT_RES         =  21;  // 0..127
   define int OFF_FLT_KBD_AMT     =  22;  // 0..127
   define int OFF_FLT_AUDIO_MOD   =  23;  // 0..127
   define int OFF_FLT_POLES       =  24;  // 0=2-pole, 1=4-pole
   define int OFF_FLT_ENV_AMT     =  25;  // 0..254 (-127..+127)
   define int OFF_FLT_ENV_VEL_AMT =  26;  // 0..127
   define int OFF_FLT_ENV_DELAY   =  27;  // 0..127
   define int OFF_FLT_ENV_ATTACK  =  28;  // 0..127
   define int OFF_FLT_ENV_DECAY   =  29;  // 0..127
   define int OFF_FLT_ENV_SUSTAIN =  30;  // 0..127
   define int OFF_FLT_ENV_RELEASE =  31;  // 0..127
   define int OFF_VCA_LEVEL       =  32;  // 0..127
   define int OFF_VCA_ENV_AMT     =  33;  // 0..127
   define int OFF_VCA_ENV_VEL_AMT =  34;  // 0..127
   define int OFF_VCA_ENV_DELAY   =  35;  // 0..127
   define int OFF_VCA_ENV_ATTACK  =  36;  // 0..127
   define int OFF_VCA_ENV_DECAY   =  37;  // 0..127
   define int OFF_VCA_ENV_SUSTAIN =  38;  // 0..127
   define int OFF_VCA_ENV_RELEASE =  39;  // 0..127
   define int OFF_PAN_SPREAD      =  40;  // 0..127
   define int OFF_VOICE_VOLUME    =  41;  // 0..127
   define int OFF_LFO1_FREQ       =  42;  // 0..166  (0..150=unsynced, 151..158=div 32,16,8,6,4,3,2,1.5 159..166=mul 1,2/3,2,1/3,4,6,8,16
   define int OFF_LFO1_SHAPE      =  43;  // 0=tri,1=rev saw,2=saw,3=square,4=rand
   define int OFF_LFO1_AMT        =  44;  // 0..127
   define int OFF_LFO1_DST        =  45;  // 0..43 (see mod dst list)
   define int OFF_LFO1_KEY_SYNC   =  46;  // 0=off, 1=on
   define int OFF_LFO2_FREQ       =  47;  // 0..166  (0..150=unsynced, 151..158=div 32,16,8,6,4,3,2,1.5 159..166=mul 1,2/3,2,1/3,4,6,8,16
   define int OFF_LFO2_SHAPE      =  48;  // 0=tri,1=rev saw,2=saw,3=square,4=rand
   define int OFF_LFO2_AMT        =  49;  // 0..127
   define int OFF_LFO2_DST        =  50;  // 0..43 (see mod dst list)
   define int OFF_LFO2_KEY_SYNC   =  51;  // 0=off, 1=on
   define int OFF_LFO3_FREQ       =  52;  // 0..166  (0..150=unsynced, 151..158=div 32,16,8,6,4,3,2,1.5 159..166=mul 1,2/3,2,1/3,4,6,8,16
   define int OFF_LFO3_SHAPE      =  53;  // 0=tri,1=rev saw,2=saw,3=square,4=rand
   define int OFF_LFO3_AMT        =  54;  // 0..127
   define int OFF_LFO3_DST        =  55;  // 0..43 (see mod dst list)
   define int OFF_LFO3_KEY_SYNC   =  56;  // 0=off, 1=on
   define int OFF_LFO4_FREQ       =  57;  // 0..166  (0..150=unsynced, 151..158=div 32,16,8,6,4,3,2,1.5 159..166=mul 1,2/3,2,1/3,4,6,8,16
   define int OFF_LFO4_SHAPE      =  58;  // 0=tri,1=rev saw,2=saw,3=square,4=rand
   define int OFF_LFO4_AMT        =  59;  // 0..127
   define int OFF_LFO4_DST        =  60;  // 0..43 (see mod dst list)
   define int OFF_LFO4_KEY_SYNC   =  61;  // 0=off, 1=on
   define int OFF_ENV3_DST        =  62;  // 0..43 (see mod dst list)
   define int OFF_ENV3_AMT        =  63;  // 0..254 (-127..+127)
   define int OFF_ENV3_VEL_AMT    =  64;  // 0..127
   define int OFF_ENV3_DELAY      =  65;  // 0..127
   define int OFF_ENV3_ATTACK     =  66;  // 0..127
   define int OFF_ENV3_DECAY      =  67;  // 0..127
   define int OFF_ENV3_SUSTAIN    =  68;  // 0..127
   define int OFF_ENV3_RELEASE    =  69;  // 0..127
   define int OFF_ENV3_REPEAT     =  70;  // 0=off, 1=on
   define int OFF_MOD1_SRC        =  71;  // 0..20 (see mod src list)
   define int OFF_MOD1_AMT        =  72;  // 0..254 (-127..+127)
   define int OFF_MOD1_DST        =  73;  // 0..47 (see ext mod dst list)
   define int OFF_MOD2_SRC        =  74;  // 0..20 (see mod src list)
   define int OFF_MOD2_AMT        =  75;  // 0..254 (-127..+127)
   define int OFF_MOD2_DST        =  76;  // 0..47 (see ext mod dst list)
   define int OFF_MOD3_SRC        =  77;  // 0..20 (see mod src list)
   define int OFF_MOD3_AMT        =  78;  // 0..254 (-127..+127)
   define int OFF_MOD3_DST        =  79;  // 0..47 (see ext mod dst list)
   define int OFF_MOD4_SRC        =  80;  // 0..20 (see mod src list)
   define int OFF_MOD4_AMT        =  81;  // 0..254 (-127..+127)
   define int OFF_MOD4_DST        =  82;  // 0..47 (see ext mod dst list)
   define int OFF_MODWHEEL_AMT    =  83;  // 0..254 (-127..+127)
   define int OFF_MODWHEEL_DST    =  84;  // 0..47 (see ext mod dst list)
   define int OFF_PRESSURE_AMT    =  85;  // 0..254 (-127..+127)
   define int OFF_PRESSURE_DST    =  86;  // 0..47 (see ext mod dst list)
   define int OFF_BREATH_AMT      =  87;  // 0..254 (-127..+127)
   define int OFF_BREATH_DST      =  88;  // 0..47 (see ext mod dst list)
   define int OFF_VELOCITY_AMT    =  89;  // 0..254 (-127..+127)
   define int OFF_VELOCITY_DST    =  90;  // 0..47 (see ext mod dst list)
   define int OFF_FOOT_AMT        =  91;  // 0..254 (-127..+127)
   define int OFF_FOOT_DST        =  92;  // 0..47 (see ext mod dst list)
   define int OFF_UNISON_MODE     =  93;  // 0=1 voice, 1=all voices, 2=all voices detune1, 3=av detune2, 4=av detune3
   define int OFF_KEY_MODE        =  94;  // 0=low note, 1=low note retrig, 2=hi note, 3=hi note retrig, 4=last note, 5=last note retrig
   define int OFF_UNISON_EN       =  95;  // 0=off, 1=on
   define int OFF_PUSHIT_NOTE     =  96;  // 0..127 (C0..C10) (tetra)
   define int OFF_PUSHIT_VEL      =  97;  // 1..127 (tetra)
   define int OFF_PUSHIT_MODE     =  98;  // 0=normal, 1=toggle (tetra)
   define int OFF_SPLIT_POINT     =  99;  // 0..127 (60=C-3)
   define int OFF_KBD_MODE        = 100;  // 0=normal, 1=stack, 2=split
   define int OFF_BPM             = 101;  // 30..250
   define int OFF_CLK_DIV         = 102;  // 0..12 (1/2, 1/4, 1/8, 1/8 half swing, 1/8 full swing, 1/8 triplets, 1/16, 1/16 half swing, 1/16 full swing, 1/16 triplets, 1/32, 1/32 triplets, 1/64 triplets
   define int OFF_ARP_MODE        = 103;  // 0=up, 1=down, 2=up/down, 3=assign, 4=random, 5=2 oct up, 6=2 oct down, 7=2 oct up/down, 8=2 oct assign, 9=2 oct rand, 10=3 oct up, 11=3 oct down, 12=3 oct up/down, 13=3 oct assign, 14=3 oct rand
   define int OFF_ARP_EN          = 104;  // 0=off, 1=on
   define int OFF_SEQ_TRIG        = 105;  // 0=normal, 1=normal/no reset, 2=no gate, 3=no gate/no reset, 4=key step
   define int OFF_SEQ_EN          = 106;  // 0=off, 1=on ("gated sequencer")
   define int OFF_SEQ1_DST        = 107;  // 0..47 (see ext mod dst list)
   define int OFF_SEQ2_DST        = 108;  // 0..47 (see ext mod dst list)
   define int OFF_SEQ3_DST        = 109;  // 0..47 (see ext mod dst list)
   define int OFF_SEQ4_DST        = 110;  // 0..47 (see ext mod dst list)
   define int OFF_ASSIGN_PARAM_1  = 111;  // 0..183 (tetra)
   define int OFF_ASSIGN_PARAM_2  = 112;  // 0..183 (tetra)
   define int OFF_ASSIGN_PARAM_3  = 113;  // 0..183 (tetra)
   define int OFF_ASSIGN_PARAM_4  = 114;  // 0..183 (tetra)
   // <unused> 118
   define int OFF_EDITOR_BYTE     = 117;  // ???
   // <unused> 119
   define int OFF_SEQ1_STEP1      = 120;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP2      = 121;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP3      = 122;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP4      = 123;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP5      = 124;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP6      = 125;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP7      = 126;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP8      = 127;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP9      = 128;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP10     = 129;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP11     = 130;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP12     = 131;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP13     = 132;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP14     = 133;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP15     = 134;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ1_STEP16     = 135;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP1      = 136;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP2      = 137;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP3      = 138;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP4      = 139;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP5      = 140;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP6      = 141;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP7      = 142;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP8      = 143;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP9      = 144;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP10     = 145;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP11     = 146;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP12     = 147;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP13     = 148;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP14     = 149;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP15     = 150;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ2_STEP16     = 151;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP1      = 152;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP2      = 153;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP3      = 154;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP4      = 155;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP5      = 156;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP6      = 157;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP7      = 158;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP8      = 159;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP9      = 160;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP10     = 161;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP11     = 162;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP12     = 163;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP13     = 164;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP14     = 165;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP15     = 166;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ3_STEP16     = 167;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP1      = 168;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP2      = 169;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP3      = 170;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP4      = 171;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP5      = 172;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP6      = 173;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP7      = 174;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP8      = 175;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP9      = 176;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP10     = 177;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP11     = 178;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP12     = 179;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP13     = 180;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP14     = 181;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP15     = 182;  // 0..125, 126=reset, 127=rest
   define int OFF_SEQ4_STEP16     = 183;  // 0..125, 126=reset, 127=rest
   define int OFF_NAME_CHAR1      = 184;  // 32..127
   define int OFF_NAME_CHAR2      = 185;  // 32..127
   define int OFF_NAME_CHAR3      = 186;  // 32..127
   define int OFF_NAME_CHAR4      = 187;  // 32..127
   define int OFF_NAME_CHAR5      = 188;  // 32..127
   define int OFF_NAME_CHAR6      = 189;  // 32..127
   define int OFF_NAME_CHAR7      = 190;  // 32..127
   define int OFF_NAME_CHAR8      = 191;  // 32..127
   define int OFF_NAME_CHAR9      = 192;  // 32..127
   define int OFF_NAME_CHAR10     = 193;  // 32..127
   define int OFF_NAME_CHAR11     = 194;  // 32..127
   define int OFF_NAME_CHAR12     = 195;  // 32..127
   define int OFF_NAME_CHAR13     = 196;  // 32..127
   define int OFF_NAME_CHAR14     = 197;  // 32..127
   define int OFF_NAME_CHAR15     = 198;  // 32..127
   define int OFF_NAME_CHAR16     = 199;  // 32..127

}


// <class.png>
class Prophet08_Patch : Prophet08_Defs {
   EditMIDISynthFormDSIProphet08 *parent_editor;

   String patch_name;     // truncated to 8 chars during upload (ignored my M1K anyway)
   int    patch_category; // None, Bass, Lead, .. (see xfm)
   Buffer patch_data;     // 384+x bytes (tetra patch, p08 is a subset)



   // <method_init.png>
   public method init(EditMIDISynthFormDSIProphet08 _editor) {
      parent_editor <= _editor;

      patch_data.size = 384;
      patch_data.fillZero();
      patch_name = "<empty>";
   }

   // <method.png>
   public method copyFrom(Prophet08_Patch _o) {
      patch_data = _o.patch_data;
      patch_name = _o.patch_name;
      patch_category = _o.patch_category;
   }

   // <method.png>
   public method downloadPatch(short _patchNr) : boolean {

      // firmware 1.03 bugs / difference to MIDI spec:
      // (note) patchNr >= 256 download requires patch num to be set to 1 (otherwise patchnr=256 returns bank0:00)
      // (note) patchNr field in request must be set to 0 for patchNr <= 255
      // (note) seems that the patchNr fields acts as a bank select (patchNr >> 8)

      // parent_editor.midiSelectPatch(_patchNr);

      // Buffer b;
      // b.size = 1024;
      // b.offset = 0;

      // b.i8 = 0xF0;
      // b.i8 = 0x10;
      // b.i8 = 0x06;
      // b.i8 = 0x04; // Request data
      // b.i8 = 0x01; // Single patch from current bank
      // b.i8 = (_patchNr >> 8);//(_patchNr % 100);
      // b.i8 = 0xF7;

      // trace "[trc] Matrix1000: send download request:";
      // Utils.HexDump(b, 0, 7);

      // trace "[dbg] downloadPatch("+_patchNr+"): pn%100="+(_patchNr % 100);

      // parent_editor.sendBuffer(b);

      // if(parent_editor.waitForSysEx())
      // {
      //    trace "[trc] Matrix1000_Patch::download: got sysex";

      //    Utils.HexDump(parent_editor.sysex_buffer, 0, parent_editor.sysex_buffer.size);

      //    if(decodeSysexToPatchData())
      //    {
      //       trace "[dbg] Matrix1000_Patch::download: patch data decoded OK";

      //       patch_name = "        ";
      //       patch_name[0] = patch_data.peekI8(0);
      //       patch_name[1] = patch_data.peekI8(1);
      //       patch_name[2] = patch_data.peekI8(2);
      //       patch_name[3] = patch_data.peekI8(3);
      //       patch_name[4] = patch_data.peekI8(4);
      //       patch_name[5] = patch_data.peekI8(5);
      //       patch_name[6] = patch_data.peekI8(6);
      //       patch_name[7] = patch_data.peekI8(7);

      //       return true;
      //    }
      //    else
      //    {
      //       trace "[---] Matrix1000_Patch::download: FAILED to decode patch data";
      //    }

      // }

      return false;
   }

   // <method.png>
   public method downloadEditBuffer() : boolean {

      return false;
   }

   // <method.png>
   public method uploadToEditBuffer() : boolean {

      // (note) Crashes the synth on firmware 1.03

      // Buffer ob;
      // ob.size = 275;
      // ob.offset = 0;

      // ob.i8 = 0xF0;
      // ob.i8 = 0x10;
      // ob.i8 = 0x06;
      // ob.i8 = 0x0D; // Single Patch Data to Edit Buffer
      // ob.i8 = 0x00; //

      // patch_data.offset = 0;

      // byte checksum = 0;

      // loop(134)
      // {
      //    byte b = patch_data.u8;
      //    ob.i8 = b & 15;
      //    ob.i8 = (b >> 4) & 15;
      //    checksum += b;
      // }

      // ob.i8 = checksum;

      // ob.i8 = 0xF7;

      // parent_editor.sendBuffer(ob);

      // TKS.sleep(300);
   }

   // <method.png>
   public method uploadToPatch(short _patchNr) : boolean {
      // parent_editor.midiSelectPatch(_patchNr);

      // Buffer ob;
      // ob.size = 275;
      // ob.offset = 0;

      // ob.i8 = 0xF0;
      // ob.i8 = 0x10;
      // ob.i8 = 0x06;
      // ob.i8 = 0x01; // Single Patch Data
      // ob.i8 = _patchNr % 100;

      // trace "[dbg] uploadToPatch("+_patchNr+"): pn%100="+(_patchNr % 100);

      // // patch_data[27] = 50; // xxxx set VCF Initial Resonance
      // // patch_data[26] = 0; // xxxx set VCF Initial Frequency
      // // // patch_data[54] = 5; // xxxx set Env1 Initial Release Time (Filter Env)
      // // patch_data[53] = 48; // xxxx set Env 1 Sustain Level
      // // patch_data[63] = 5; // xxxx set Env2 Initial Release Time (Filter Env)

      // patch_data.offset = 0;

      // byte checksum = 0;

      // loop(134)
      // {
      //    byte b = patch_data.u8;
      //    ob.i8 = b & 15;
      //    ob.i8 = (b >> 4) & 15;
      //    checksum += b;
      // }

      // ob.i8 = checksum & 127;

      // ob.i8 = 0xF7;

      // trace "[trc] Matrix1000: send patch:";
      // trace "[trc] ob.offset="+ob.offset+" ob.size="+ob.size;
      // // patch_data.offset = 0;
      // Utils.HexDump(ob, 0, 275);

      // parent_editor.sendBuffer(ob);

      // TKS.sleep(300);

      return true;
   }

   // <method.png>
   protected method decodeSysexToPatchData() : boolean {
      boolean ret = false;
      // Buffer ib <= parent_editor.sysex_buffer;
      // patch_data.size = 134;
      // ib.offset = 0;

      // if(0x10 == ib.u8)
      // {
      //    if(0x06 == ib.u8)
      //    {
      //       if(0x01 == ib.u8) // Single patch data
      //       {
      //          byte patchNr = ib.u8;
      //          byte expChecksum = 0;
      //          loop(134)
      //          {
      //             byte b = ib.u8; // LSB
      //             b |= (ib.u8 << 4);
      //             expChecksum += b;
      //             patch_data.i8 = b;
      //          }
      //          expChecksum &= 127;
      //          byte haveChecksum = ib.u8;
      //          trace "[trc] Matrix1000::decodeSysexToPatchdata: expChecksum="+expChecksum+" haveChecksum="+haveChecksum;
      //          ret = (expChecksum == haveChecksum);

      //          Utils.HexDump(patch_data, 0, 134);
      //       }
      //    }
      // }

      return ret;
   }

   // <save.png>
   public method save(Stream _ofs) {
      // Version
      _ofs.i16 = 1;

      // Patch name
      Utils.WriteString(_ofs, patch_name);

      // Patch category
      _ofs.i8 = patch_category;

      // Patch data
      _ofs.writeBuffer(patch_data, 0, patch_data.size);
   }

   // <load.png>
   public method load(Stream _ifs) : boolean {
      short ver = _ifs.u16;

      if(ver >= 1)
      {
         Utils.ReadString(_ifs, patch_name);

         patch_category = _ifs.u8;

         patch_data.fillZero();
         _ifs.readBuffer(patch_data, 0, patch_data.size, false/*bResize*/);

         return true;
      }

      return false;
   }
}


// <class.png>
class MIDISynthProfileDataDSIProphet08 : MIDISynthProfileData {

   PointerArray patches;  // 1000 Prophet08_Patch instances (first 256 can be written to synth)

   short current_patch_nr;
   short first_patch_nr;
   short last_patch_nr;
   boolean b_autosend;


   // <method_init.png>
   public virtual init(MIDISynthProfile _profile) {
      MIDISynthProfileData::init(_profile);

      patches.alloc(1001);

      loop(1001)
      {
         Prophet08_Patch patch <= new Prophet08_Patch;
         patch.init(midi_profile.edit_form);
         patches.add(#(deref patch));
      }

      current_patch_nr = 0;
      first_patch_nr = 0;
      first_patch_nr = 0;
      b_autosend = true;
   }

   // <save.png>
   public virtual saveMIDIProfileData(Stream _ofs) {
      // Version
      _ofs.i16 = 1;

      _ofs.i16 = current_patch_nr;
      _ofs.i16 = first_patch_nr;
      _ofs.i16 = last_patch_nr;
      _ofs.i8  = b_autosend;

      int patchIdx = 0;
      loop(1001)
      {
         Prophet08_Patch p <= patches.get(patchIdx);
         p.save(_ofs);
         patchIdx++;
      }
   }

   // <load.png>
   public virtual loadMIDIProfileData(Stream _ifs, boolean _bFromUI) : boolean {
      short ver = _ifs.u16;

      if(ver >= 1)
      {
         if(!_bFromUI)
         {
            current_patch_nr = _ifs.u16;
         }
         else
         {
            int skip0 = _ifs.u16;
         }

         first_patch_nr = _ifs.u16;
         last_patch_nr = _ifs.u16;
         b_autosend = _ifs.b8;

         int patchIdx = 0;
         loop(1001)
         {
            Prophet08_Patch p <= patches.get(patchIdx);
            if(!p.load(_ifs))
            {
               trace "[---] failed to load Prophet08 patch "+patchIdx;
               return false;
            }
            patchIdx++;
         }

         return true;
      }

      return false;
   }

   // <save.png>
   public virtual saveProjectMIDIProfileData(Stream _ofs) {
      // Version
      _ofs.i16 = 1;

   }

   // <load.png>
   public virtual loadProjectMIDIProfileData(Stream _ifs) : boolean {
      short ver = _ifs.u16;

      if(ver >= 1)
      {
         return true;
      }

      return false;
   }
}


// <class.png>
class EditMIDISynthFormDSIProphet08 : EditMIDISynthForm, ActionProvider, MIDIMapEventListener, Prophet08_Defs {

   define String TA_MIDISEND;

   MIDISynthProfileDataDSIProphet08 *data;
   Prophet08_Patch *patch;  // Reference to current patch in data.patches[]. never null.
   STX_MIDIInDevice *in_dev;
   STX_MIDIOutDevice *out_dev;
   byte midi_ch;
   boolean b_have_sysex;
   Buffer sysex_buffer;

   short current_midi_patch_nr = -1; // to avoid unnecessary MIDI bank+program selects
   short queued_midi_patch_nr = -1;
   boolean b_queued_midi_send_patch;

   Prophet08_Patch *patch_clipboard;

   protected TabSwitch *ts_groups;

   // Patch
   protected CheckBox   *cb_patch_autosend;
   protected FloatParam *fp_patch_nr;
   protected TextField  *tf_patch_name;
   protected ComboBox   *cm_patch_category;
   protected Button     *bt_patch_catprev;
   protected Button     *bt_patch_catnext;
   protected FloatParam *fp_patch_nr_midi;
   protected CheckBox   *cb_patch_midi_follow;

   // Patch Utils
   protected FloatParam *fp_patch_first;
   protected FloatParam *fp_patch_last;
   protected Button     *bt_patch_send;
   protected Button     *bt_patch_receive;
   protected Button     *bt_patch_send_edit;
   protected Button     *bt_patch_receive_edit;

   // Patch Utils C'N'P
   protected Button *bt_patch_copy;
   protected Button *bt_patch_paste;
   protected Button *bt_patch_init;
   protected Button *bt_patch_saveinit;


   protected TimerAction *ta_midisend;

   protected boolean b_patch_midi_follow;


   // <method_init.png>
   public virtual init(MIDISynthProfile _profile) : boolean {

      if(initPakFile("Prophet08.xfm"))
      {
         if(autoResolveIds(this))
         {
            initMMC();

            initTimers();

            patch_clipboard <= new Prophet08_Patch;
            patch_clipboard.init(this);

            return true;
         }
      }

      return false;
   }

   // <midi_mmc.png>
   protected method initMMC() {

      mmcInit("EditMIDISynthFormDSIProphet08");

      ////addBaseMMCTargets(this);
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_midisend <= TimerAction.New(TA_MIDISEND, this, 100);
   }

   // <ui_show.png>
   public virtual showData(MIDISynthProfileDataDSIProphet08 _data,
                           STX_MIDIInDevice  _inDev,
                           STX_MIDIOutDevice _outDev,
                           byte              _midiCh
                           ) {
      data    <= _data;
      in_dev  <= _inDev;
      out_dev <= _outDev;
      midi_ch  = _midiCh;

      patch <= _data.patches.get(_data.current_patch_nr);

      updateUIFromPatch();

      if(null == in_dev)
      {
         Global.Error("Prophet08: input device not configured or found");
      }

      if(null == out_dev)
      {
         Global.Error("Prophet08: output device not configured or found");
      }
      else
      {
         // if(-1 == current_midi_patch_nr)
         // {
         //    midiSelectPatch(0);
         // }
      }

   }

   // <ui_show.png>
   public virtual enter() {
      b_queued_midi_send_patch = false;
      MIDI.AddMIDIMapEventListener(this);
   }

   // <ui_show.png>
   public virtual leave() {
      b_queued_midi_send_patch = false;
      MIDI.RemoveMIDIMapEventListener(this);
      ta_midisend.cancel();
   }

   // <ui_update.png>
   protected method updateUIFromPatch() {
      Global.Debug2("Prophet08::updateUIFromPatch: patch_nr="+data.current_patch_nr);

      Buffer pd <= patch.patch_data;

      fp_patch_first.setValue(data.first_patch_nr);
      fp_patch_last .setValue(data.last_patch_nr);

      // Patch
      fp_patch_nr_midi  .setValue(         current_midi_patch_nr);
      fp_patch_nr       .setValue(         data.current_patch_nr);
      cb_patch_autosend .setSelected(      data.b_autosend);
      tf_patch_name     .setText(          patch.patch_name);
      cm_patch_category .setSelectedOption(patch.patch_category);
      cb_patch_midi_follow .setSelected (b_patch_midi_follow);

      redraw();
   }

   // <ui_midi.png>
   public =replay= method midiSelectPatch(short _patch) {
      if(_patch < 256)
      {
         if(current_midi_patch_nr != _patch)
         {
            boolean bSendBank = true;

            if(-1 != current_midi_patch_nr)
            {
               bSendBank = (current_midi_patch_nr >> 7) != (_patch >> 7);
            }

            if(bSendBank)
            {
               out_dev.bankSelect(midi_ch, (current_midi_patch_nr >> 7));
               out_dev.send(milliSeconds());
               TKS.sleep(20);
            }

            out_dev.programChange(midi_ch, (_patch & 127));
            out_dev.send(milliSeconds());
            TKS.sleep(20);

            current_midi_patch_nr = _patch;

            fp_patch_nr_midi.setValue(_patch);
            fp_patch_nr_midi.redraw();
         }
      }
   }

   // <ui_midi.png>
   =replay= public method sendBuffer(Buffer _b) {
      out_dev.addBuffer(_b);
      out_dev.send(milliSeconds());
   }

   // <ui_midi.png>
   public virtual mmlHandleEventUI(MIDIMapEvent _ev) : boolean {
      Global.Debug3("Prophet08::mmlHandleEventUI");
      if(@(_ev.dev) == @(in_dev))
      {
         Global.Debug3("Prophet08::mmlHandleEventUI: is in_dev");

         if(MIDIMapDefs.TYPE_SYSEX == _ev.type)
         {
            sysex_buffer = _ev.sysex_buffer;
            b_have_sysex = true;
         }
      }
      return false;
   }

   // <ui_midi.png>
   public method waitForSysEx() : boolean {
      b_have_sysex = false;

      Global.Debug("Prophet08::waitForSysEx: in_dev="+#(in_dev));

      if(null != in_dev)
      {
         Global.Debug("Prophet08::waitForSysEx: in_dev.aliasOrDevName=\""+in_dev.getAliasOrDeviceName()+"\"");

         // 1 second timeout
         loop(10)
         {
            replay.processMidiMapUIEventQueue();

            if(b_have_sysex)
            {
               break;
            }

            TKS.sleep(100);
         }
      }

      return b_have_sysex;
   }

   // <ui_handle.png>
   protected method handlePatchAutosendChanged() {
      data.b_autosend = cb_patch_autosend.isSelected();
      Global.Print("Autosend is "+Utils.GetEnableString(data.b_autosend));

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }
   }

   // <ui_handle.png>
   protected method handlePatchNrChanged() {
      data.current_patch_nr = fp_patch_nr.getFloatValue();
      data.first_patch_nr = data.current_patch_nr;
      data.last_patch_nr = data.current_patch_nr;
      patch <= data.patches.get(data.current_patch_nr);
      Global.Print("Select patch "+data.current_patch_nr);
      updateUIFromPatch();

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }
      else if(b_patch_midi_follow)
      {
         queued_midi_patch_nr = data.current_patch_nr;
         scheduleMIDISend();
      }
   }

   // <ui_handle.png>
   protected method handleMIDIPatchNrChanged() {
      int patchNr = fp_patch_nr_midi.getFloatValue();
      queued_midi_patch_nr = patchNr;
      data.first_patch_nr = patchNr;
      data.last_patch_nr = patchNr;
      fp_patch_first.setValue(patchNr);
      fp_patch_first.redraw();
      fp_patch_last.setValue(patchNr);
      fp_patch_last.redraw();
      scheduleMIDISend();
   }

   // <ui_handle.png>
   protected method handlePatchMIDIFollowChanged() {
      b_patch_midi_follow = cb_patch_midi_follow.isSelected();
      Global.Print("MIDI follow is "+Utils.GetEnableString(b_patch_midi_follow));

      if(b_patch_midi_follow && !data.b_autosend)
      {
         queued_midi_patch_nr = data.current_patch_nr;
         scheduleMIDISend();
      }
   }

   // <ui_timer.png>
   protected method scheduleMIDISendPatch() {
      b_queued_midi_send_patch = true;
      ta_midisend.cancel();
      ta_midisend.schedule();
   }

   // <ui_timer.png>
   protected method scheduleMIDISendPatchAuto() {
      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }
   }

   // <ui_timer.png>
   protected method scheduleMIDISend() {
      ta_midisend.cancel();
      ta_midisend.schedule();
   }

   // <ui_timer.png>
   protected method handleMIDISendTimer() {
      if(-1 != queued_midi_patch_nr)
      {
         midiSelectPatch(queued_midi_patch_nr);
         queued_midi_patch_nr = -1;
      }

      if(b_queued_midi_send_patch)
      {
         b_queued_midi_send_patch = false;

         patch.uploadToEditBuffer();
      }
   }

   // <ui_handle.png>
   protected method handlePatchNameChanged() {
      patch.patch_name = tf_patch_name.getText();
      Buffer pd <= patch.patch_data;
      int charIdx = 0;
      loop(16)
      {
         pd.pokeI8(OFF_NAME_CHAR1 + charIdx, patch.patch_name.getc(charIdx));
         charIdx++;
      }
      Global.Print("Patch name is \""+patch.patch_name+"\"");
      scheduleMIDISendPatchAuto();
   }

   // <ui_handle.png>
   protected method handlePatchCategoryChanged() {
      patch.patch_category = cm_patch_category.getSelectedOption();
      Global.Print("Patch category is \""+cm_patch_category.getSelectedOptionName()+"\"");
   }

   // <ui_handle.png>
   protected method handlePatchCategoryPrev() {
      // (todo)
   }

   // <ui_handle.png>
   protected method handlePatchCategoryNext() {
      // (todo)
   }

   // <ui_handle.png>
   protected method handlePatchFirstChanged() {
      data.first_patch_nr = fp_patch_first.getFloatValue();
      data.last_patch_nr = data.first_patch_nr;
      fp_patch_last.setValue(data.first_patch_nr);
      fp_patch_last.redraw();
      Global.Print("Set first+last patch nr to "+data.first_patch_nr);
   }

   // <ui_handle.png>
   protected method handlePatchLastChanged() {
      data.last_patch_nr = fp_patch_last.getFloatValue();
      Global.Print("Set last patch nr to "+data.last_patch_nr);
   }

   // <ui_handle.png>
   protected method handlePatchReceive() {

      while(data.first_patch_nr <= data.last_patch_nr)
      {
         Prophet08_Patch dlPatch <= data.patches.get(data.first_patch_nr);

         if(dlPatch.downloadPatch(data.first_patch_nr))
         {
            Global.Success("Download patch "+data.first_patch_nr);

            if(@(dlPatch) == @(patch))
            {
               updateUIFromPatch();
            }

            if(data.first_patch_nr != data.last_patch_nr)
            {
               data.first_patch_nr++;
            }
            else
            {
               return;
            }
         }
         else
         {
            Global.Error("Failed to download patch "+data.first_patch_nr);
            return;
         }
      }
   }

   // <ui_handle.png>
   protected method handlePatchSend() {
      Prophet08_Patch ulPatch <= data.patches.get(data.first_patch_nr);

      if(ulPatch.uploadToPatch(data.first_patch_nr))
      {
         Global.Success("Upload patch "+data.first_patch_nr);
      }

      // (todo) send first..last
   }

   // <ui_handle.png>
   protected method handlePatchReceiveEdit() {

      if(patch.downloadEditBuffer())
      {
         Global.Success("Download patch edit buffer");

         updateUIFromPatch();
      }
      else
      {
         Global.Error("Failed to download patch edit buffer");
      }
   }

   // <ui_handle.png>
   protected method handlePatchSendEdit() {

      if(patch.uploadToEditBuffer())
      {
         Global.Success("Upload patch edit buffer ");
      }
   }

   // <ui_handle.png>
   protected method handlePatchCopy() {

      patch_clipboard.copyFrom(patch);

      Global.Print("Copy patch to clipboard");
   }

   // <ui_handle.png>
   protected method handlePatchPaste() {

      patch.copyFrom(patch_clipboard);

      updateUIFromPatch();

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }

      Global.Print("Paste patch clipboard");
   }

   // <ui_handle.png>
   protected method handlePatchInit() {

      Prophet08_Patch initPatch <= data.patches.get(1000);

      patch.copyFrom(initPatch);

      updateUIFromPatch();

      if(data.b_autosend)
      {
         queued_midi_patch_nr = 0;
         scheduleMIDISendPatch();
      }

      Global.Print("Initialize patch");
   }

   // <ui_handle.png>
   protected method handlePatchSaveInit() {

      Prophet08_Patch initPatch <= data.patches.get(1000);

      initPatch.copyFrom(patch);

      Global.Print("Save Init patch");
   }

   // <method_update.png>
   protected method updatePatchByte(int _off, byte _byte) {
      Buffer pd <= patch.patch_data;
      Byte ioOld = pd.peekI8(_off);
      pd.pokeI8(_off, _byte & 127);
      String constName = TKS.scriptClassConstantToString(#(_off), Prophet08_Defs, "OFF_");
      Byte io = _byte;
      Global.Print(constName+" is "+_byte+" ("+io.printf("$%02x")+", old="+ioOld.printf("$%02x")+")");
      scheduleMIDISendPatchAuto();
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {

      Global.Debug3("Prophet08::onKey: code="+_k.code+" pressed="+_k.pressed+" mod="+_k.mod);

      if(_k.modCtrl())
      {
         switch(_k.pressed)
         {
            case 's':
               Global.Debug("Prophet08: send patch manually");
               queued_midi_patch_nr = 0;
               scheduleMIDISendPatch();
               return true;
         }
      }

      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      StringAction *sac;

      // trace "[dbg] Prophet08::consumeAction: acName="+acName+" ap="+#(ap);

      if(TA_MIDISEND == acName)
      {
         handleMIDISendTimer();
         return true;
      }

      switch(@(ap))
      {
         case @(cb_patch_autosend):
            handlePatchAutosendChanged();
            return true;

         case @(fp_patch_nr):
            handlePatchNrChanged();
            return true;

         case @(tf_patch_name):
            handlePatchNameChanged();
            return true;

         case @(cm_patch_category):
            handlePatchCategoryChanged();
            return true;

         case @(bt_patch_catprev):
            handlePatchCategoryPrev();
            return true;

         case @(bt_patch_catnext):
            handlePatchCategoryNext();
            return true;

         case @(fp_patch_nr_midi):
            handleMIDIPatchNrChanged();
            return true;

         case @(cb_patch_midi_follow):
            handlePatchMIDIFollowChanged();
            return true;

         case @(fp_patch_first):
            handlePatchFirstChanged();
            return true;

         case @(fp_patch_last):
            handlePatchLastChanged();
            return true;

         case @(bt_patch_receive):
            handlePatchReceive();
            return true;

         case @(bt_patch_send):
            handlePatchSend();
            return true;

         case @(bt_patch_receive_edit):
            handlePatchReceiveEdit();
            return true;

         case @(bt_patch_send_edit):
            handlePatchSendEdit();
            return true;

         case @(bt_patch_copy):
            handlePatchCopy();
            return true;

         case @(bt_patch_paste):
            handlePatchPaste();
            return true;

         case @(bt_patch_init):
            handlePatchInit();
            return true;

         case @(bt_patch_saveinit):
            handlePatchSaveInit();
            return true;
      }

      return XMLForm::consumeAction(_action);
   }

}
