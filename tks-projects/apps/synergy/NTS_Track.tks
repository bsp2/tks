// ----
// ---- file   : NTS_Track.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2016-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 09Jul2016, 10Jul2016, 11Jul2016, 12Jul2016, 13Jul2016, 17Jul2016, 08Oct2016
// ----          09Oct2016, 16Oct2016, 11Dec2016, 12Dec2016, 19Dec2016, 30Jan2017, 31Jan2017
// ----          02Feb2017, 03Feb2017, 04Feb2017, 10Feb2017, 12Feb2017, 26Feb2017, 18Mar2017
// ----          01Jun2017, 05Jun2017, 12Aug2017, 18Aug2017, 03Sep2017, 09Oct2017, 14Oct2017
// ----          10Nov2017, 11Nov2017, 25Nov2017, 29Nov2017, 30Nov2017, 04Jan2018, 07Mar2018
// ----          12May2018, 21May2018, 27May2018, 28May2018, 01Jun2018, 17Jun2018, 24Jun2018
// ----          20Jul2019, 02Oct2019, 03Oct2019, 04Oct2019, 05Oct2019, 06Oct2019, 07Oct2019
// ----          08Oct2019, 09Oct2019, 14Oct2019, 16Oct2019, 17Oct2019, 18Oct2019, 19Oct2019
// ----          25Oct2019, 31Oct2019, 01Nov2019, 02Nov2019, 07Nov2019, 06Mar2020, 18Mar2020
// ----          05May2020, 26Oct2020, 27Oct2020, 30Oct2020, 02Nov2020, 03Nov2020, 10Nov2020
// ----          12Nov2020, 13Nov2020, 23Nov2020, 27Jan2021, 20Jun2021, 01Jan2022, 04Jan2022
// ----          21Feb2022, 07May2022, 21Jun2023, 14Oct2023, 27Nov2023, 01Dec2023, 02Dec2023
// ----          06Oct2024, 07Oct2024
// ----
// ----
// ----
module MNTS_Track;

use namespace ui;
use namespace st2;


// <class.png>
class NTS_Track {
   define int SLIDE_TICK_DURATION_OVERLAP = 1;  // for OUT_CHROMATIC_MONO slide

   int track_nr;

   NodeTrigSeq *parent_node;

   define int STATE_PLAY = 0;
   define int STATE_MUTE = 1;
   define int STATE_SOLO = 2;
   byte play_state;
   byte play_state_presolo;

   String name;
   int    bg_tint;

   define int MAX_STEPS = 64;

   NTS_Step *[] steps;
   boolean b_has_trigs_cache;  // 1 = track has trigs (see updateTrigCache(), called after edits)

   int play_length;  // num steps (1..64)

   // generated by dot_triplet.tks
   //   notelen indices pattern is 1/<dur>, 1/<dur>t, 1/<dur>d
   static FloatArray base_notelen_dur_tbl = [256, 128, 96, 72, 64, 48, 44, 40, 36, 32, 28, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];

   // generated by dot_triplet.tks:
   define int NOTELEN_256   = 0;
   define int NOTELEN_256T  = 1;
   define int NOTELEN_256D  = 2;
   define int NOTELEN_128   = 3;
   define int NOTELEN_128T  = 4;
   define int NOTELEN_128D  = 5;
   define int NOTELEN_96    = 6;     // == 1/64t
   define int NOTELEN_96T   = 7;
   define int NOTELEN_96D   = 8;     // == 1/64
   define int NOTELEN_72    = 9;     // == 1/48t
   define int NOTELEN_72T   = 10;
   define int NOTELEN_72D   = 11;    // == 1/48    1/32t
   define int NOTELEN_64    = 12;    // == 1/96d
   define int NOTELEN_64T   = 13;    // == 1/96
   define int NOTELEN_64D   = 14;
   define int NOTELEN_48    = 15;    // == 1/32t   1/72d
   define int NOTELEN_48T   = 16;    // == 1/72
   define int NOTELEN_48D   = 17;    // == 1/32
   define int NOTELEN_44    = 18;
   define int NOTELEN_44T   = 19;
   define int NOTELEN_44D   = 20;
   define int NOTELEN_40    = 21;
   define int NOTELEN_40T   = 22;
   define int NOTELEN_40D   = 23;
   define int NOTELEN_36    = 24;    // == 1/24t
   define int NOTELEN_36T   = 25;
   define int NOTELEN_36D   = 26;    // == 1/24    1/16t
   define int NOTELEN_32    = 27;    // == 1/48d
   define int NOTELEN_32T   = 28;    // == 1/48    1/72d
   define int NOTELEN_32D   = 29;
   define int NOTELEN_28    = 30;
   define int NOTELEN_28T   = 31;
   define int NOTELEN_28D   = 32;
   define int NOTELEN_24    = 33;    // == 1/16t   1/36d
   define int NOTELEN_24T   = 34;    // == 1/36
   define int NOTELEN_24D   = 35;    // == 1/16
   define int NOTELEN_23    = 36;
   define int NOTELEN_23T   = 37;
   define int NOTELEN_23D   = 38;
   define int NOTELEN_22    = 39;
   define int NOTELEN_22T   = 40;
   define int NOTELEN_22D   = 41;
   define int NOTELEN_21    = 42;    // == 1/14t
   define int NOTELEN_21T   = 43;
   define int NOTELEN_21D   = 44;
   define int NOTELEN_20    = 45;
   define int NOTELEN_20T   = 46;
   define int NOTELEN_20D   = 47;
   define int NOTELEN_19    = 48;
   define int NOTELEN_19T   = 49;
   define int NOTELEN_19D   = 50;
   define int NOTELEN_18    = 51;    // == 1/12t
   define int NOTELEN_18T   = 52;
   define int NOTELEN_18D   = 53;    // == 1/12    1/8t
   define int NOTELEN_17    = 54;
   define int NOTELEN_17T   = 55;
   define int NOTELEN_17D   = 56;
   define int NOTELEN_16    = 57;    // == 1/24d
   define int NOTELEN_16T   = 58;    // == 1/24    1/36d
   define int NOTELEN_16D   = 59;
   define int NOTELEN_15    = 60;    // == 1/10t
   define int NOTELEN_15T   = 61;
   define int NOTELEN_15D   = 62;    // == 1/10
   define int NOTELEN_14    = 63;
   define int NOTELEN_14T   = 64;    // == 1/21
   define int NOTELEN_14D   = 65;
   define int NOTELEN_13    = 66;
   define int NOTELEN_13T   = 67;
   define int NOTELEN_13D   = 68;
   define int NOTELEN_12    = 69;    // == 1/8t    1/18d
   define int NOTELEN_12T   = 70;    // == 1/18
   define int NOTELEN_12D   = 71;    // == 1/8
   define int NOTELEN_11    = 72;
   define int NOTELEN_11T   = 73;
   define int NOTELEN_11D   = 74;
   define int NOTELEN_10    = 75;    // == 1/15d
   define int NOTELEN_10T   = 76;    // == 1/15
   define int NOTELEN_10D   = 77;
   define int NOTELEN_9     = 78;    // == 1/6t
   define int NOTELEN_9T    = 79;
   define int NOTELEN_9D    = 80;    // == 1/6     1/4t
   define int NOTELEN_8     = 81;    // == 1/12d
   define int NOTELEN_8T    = 82;    // == 1/12    1/18d
   define int NOTELEN_8D    = 83;
   define int NOTELEN_7     = 84;
   define int NOTELEN_7T    = 85;
   define int NOTELEN_7D    = 86;
   define int NOTELEN_6     = 87;    // == 1/4t    1/9d
   define int NOTELEN_6T    = 88;    // == 1/9
   define int NOTELEN_6D    = 89;    // == 1/4
   define int NOTELEN_5     = 90;
   define int NOTELEN_5T    = 91;
   define int NOTELEN_5D    = 92;
   define int NOTELEN_4     = 93;    // == 1/6d
   define int NOTELEN_4T    = 94;    // == 1/6     1/9d
   define int NOTELEN_4D    = 95;
   define int NOTELEN_3     = 96;    // == 1/2t
   define int NOTELEN_3T    = 97;
   define int NOTELEN_3D    = 98;    // == 1/2
   define int NOTELEN_2     = 99;    // == 1/3d
   define int NOTELEN_2T    = 100;   // == 1/3
   define int NOTELEN_2D    = 101;
   define int NOTELEN_1     = 102;
   define int NOTELEN_1T    = 103;
   define int NOTELEN_1D    = 104;
   define int NOTELEN_FIT1Q = 105;
   define int NOTELEN_FIT2Q = 106;
   define int NOTELEN_FIT3Q = 107;
   define int NOTELEN_FIT4Q = 108;
   define int NOTELEN_FIT5Q = 109;
   define int NOTELEN_FIT6Q = 110;
   define int NOTELEN_FIT7Q = 111;
   define int NOTELEN_FIT8Q = 112;
   define int NOTELEN_NUM   = 113;

   // generated by dot_triplet.tks:
   static StringArray notelen_names = [
      "0: 1/256",  "1: 1/256t", "2: 1/256d", "3: 1/128",  "4: 1/128t", "5: 1/128d", "6: 1/96",   "7: 1/96t",  "8: 1/96d",
      "9: 1/72",   "10: 1/72t", "11: 1/72d", "12: 1/64",  "13: 1/64t", "14: 1/64d", "15: 1/48",  "16: 1/48t", "17: 1/48d",
      "18: 1/44",  "19: 1/44t", "20: 1/44d", "21: 1/40",  "22: 1/40t", "23: 1/40d", "24: 1/36",  "25: 1/36t", "26: 1/36d",
      "27: 1/32",  "28: 1/32t", "29: 1/32d", "30: 1/28",  "31: 1/28t", "32: 1/28d", "33: 1/24",  "34: 1/24t", "35: 1/24d",
      "36: 1/23",  "37: 1/23t", "38: 1/23d", "39: 1/22",  "40: 1/22t", "41: 1/22d", "42: 1/21",  "43: 1/21t", "44: 1/21d",
      "45: 1/20",  "46: 1/20t", "47: 1/20d", "48: 1/19",  "49: 1/19t", "50: 1/19d", "51: 1/18",  "52: 1/18t", "53: 1/18d",
      "54: 1/17",  "55: 1/17t", "56: 1/17d", "57: 1/16",  "58: 1/16t", "59: 1/16d", "60: 1/15",  "61: 1/15t", "62: 1/15d",
      "63: 1/14",  "64: 1/14t", "65: 1/14d", "66: 1/13",  "67: 1/13t", "68: 1/13d", "69: 1/12",  "70: 1/12t", "71: 1/12d",
      "72: 1/11",  "73: 1/11t", "74: 1/11d", "75: 1/10",  "76: 1/10t", "77: 1/10d", "78: 1/9",   "79: 1/9t",  "80: 1/9d",
      "81: 1/8",   "82: 1/8t",  "83: 1/8d",  "84: 1/7",   "85: 1/7t",  "86: 1/7d",  "87: 1/6",   "88: 1/6t",  "89: 1/6d",
      "90: 1/5",   "91: 1/5t",  "92: 1/5d",  "93: 1/4",   "94: 1/4t",  "95: 1/4d",  "96: 1/3",   "97: 1/3t",  "98: 1/3d",
      "99: 1/2",   "100: 1/2t", "101: 1/2d", "102: 1/1",  "103: 1/1t", "104: 1/1d"
                                       ];

   static StringArray notelen_names_fit = [
      "105: fit 1q", "106: fit 2q", "107: fit 3q", "108: fit 4q", "109: fit 5q", "110: fit 6q", "111: fit 7q", "112: fit 8q"
                                           ];

   // maps pre v21 save state step_note_length / repeat_note_length indices to new enumeration (generated by dot_triplet.tks)
   IntArray old_prev21_notelen_remap_tbl = [0, 2, 3, 5, 6, 9, 12, 14, 15, 18, 21, 23, 24, 27, 29, 30, 32, 33, 36, 38, 39, 41, 42, 45, 47, 48, 50, 51, 54, 56, 57, 59, 60, 63, 65, 66, 68, 69, 72, 74, 75, 77, 78, 81, 83, 84, 86, 87, 90, 92, 93, 95, 96, 99, 101, 102,
                                            NOTELEN_FIT1Q,
                                            NOTELEN_FIT2Q,
                                            NOTELEN_FIT3Q,
                                            NOTELEN_FIT4Q,
                                            NOTELEN_FIT5Q,
                                            NOTELEN_FIT6Q,
                                            NOTELEN_FIT7Q,
                                            NOTELEN_FIT8Q,
                                            ];

   int   step_note_length;        // NOTELEN_xxx
   float current_step_num_ticks;  // (cached) current step duration in ticks

   String *note_name_profile_id;  // null=use pattern profile
   float arg3; // output mode dependent, e.g. note/patternr/patternoff/channelnr/polystepnr

   float quantization_amount; // 0..1

   float swing_amount; // -0.5..0.5

   int last_played_step;
   int last_played_step_mod;
   int plugin_last_played_restore_step;  // used by NTS_EditorPlugin to restore color after playhead advanced

   int repeat_note_length; // see NOTELEN_xxx. -1=use step_note_length
   int num_repeats;        // 0=infinite

   int current_repeat_num_ticks;   // based on either repeat_note_length or pattern (global) repeat_note_length
   int current_num_repeats;        // either num_repeats or pattern (global) num_repeats

   FloatArray velocities;  // 4 entries, def=[127, 96, 65, 34]
   float velocity_jitter;  // neg=sub, pos=+-

   int default_note_duration_ticks;

   int rec_note_on_ticks;  // -1 = no note on  (>= 0: don't play any sequencer steps until note is released)

   NTS_EuclidParams euclid_params;

   boolean b_ui_trig_queued_on;
   boolean b_ui_trig_queued_off;

   byte ui_queued_step;

   float ui_queued_mod1;  // normalized(0..1), -1=none
   float ui_queued_mod2;  // normalized(0..1), -1=none

   boolean b_forced_out;
   short   forced_out_dev;  // -1=use node output dev
   byte    forced_out_ch;

   byte forced_output_mode;  // -1 = use default output mode

   float microtime_shift;   // relative to current_step_num_ticks
   float microtime_jitter;  // ^^

   float current_microtime_jitter;  // 0..1 (randomized)

   MIDIMapEventType mod1_type;
   float mod1_min;
   float mod1_max;
   float mod1_reset;
   float mod1_jitter;  // neg=sub, pos=+-

   MIDIMapEventType mod2_type;
   float mod2_min;
   float mod2_max;
   float mod2_reset;
   float mod2_jitter;  // neg=sub, pos=+-

   boolean b_forced_mod_out;
   short   forced_mod_out_dev;  // -1=use node output dev
   byte    forced_mod_out_ch;

   // for countering synth parameter smoothing by sending mods ahead of time (0..255 => 0..-255 ticks)
   byte mod_tickshift;

   boolean b_linnstrument_perf_trig_dur_scl;  // true=trig pad modulates duration in performance mode. false=trigger note


   // <method_init.png>
   public method init(NodeTrigSeq _seq, int _trackNr) {

      parent_node <= _seq;

      track_nr = _trackNr;

      name = "trk"+(track_nr+1);
      ////bg_tint = #37ec9307;
      ////bg_tint = #37ecc207;
      ////bg_tint = #2cebc107;
      if(UI.IsDarkOrMono())
         bg_tint = STConfig.node_trig_seq_default_track_color_dark;
      else
         bg_tint = STConfig.node_trig_seq_default_track_color_light;

      allocSteps(MAX_STEPS, _trackNr);

      play_length = 16;
      step_note_length = NOTELEN_16;

      note_name_profile_id <= null;
      arg3 = _trackNr;

      repeat_note_length   = -1;
      num_repeats          =  0;
      ////current_repeat_ticks = -1;

      velocities = [127 - 0*31,
                    127 - 1*31,
                    127 - 2*31,
                    127 - 3*31
                    ];

      default_note_duration_ticks = 6;  // 1 may cause lost notes with some synths

      microtime_shift = 0;
      microtime_jitter = 0;

      b_forced_out   = false;
      forced_out_dev = -1;
      forced_out_ch  = 0;

      forced_output_mode = -1;

      ui_queued_step = -1;

      ui_queued_mod1 = -1;
      ui_queued_mod2 = -1;

      euclid_params.init();

      mod1_type.initEventType();
      mod1_type.ext_type = 1;  // MW
      mod1_min    = 0.0f;
      mod1_max    = 127.0f;
      mod1_reset  = -1;
      mod1_jitter = 0;

      mod2_type.initEventType();
      mod2_type.ext_type = 2;  // BC
      mod2_min    = 0.0f;
      mod2_max    = 127.0f;
      mod2_reset  = -1;
      mod2_jitter = 0;

      b_forced_mod_out   = false;
      forced_mod_out_dev = -1;
      forced_mod_out_ch  = 0;

      mod_tickshift = 0;
   }

   // <method.png>
   public =replay= method copyFrom(NTS_Track _o) {

      play_state         = _o.play_state;
      play_state_presolo = _o.play_state_presolo;

      name    = _o.name;
      bg_tint = _o.bg_tint;

      int stepIdx = 0;
      loop(steps.numElements)
      {
         NTS_Step st  <= steps.get(stepIdx);
         NTS_Step ost <= _o.steps.get(stepIdx);
         st.copyFrom(ost);
         stepIdx++;
      }
      b_has_trigs_cache = _o.b_has_trigs_cache;

      play_length            = _o.play_length;
      step_note_length       = _o.step_note_length;
      current_step_num_ticks = _o.current_step_num_ticks;

      quantization_amount = _o.quantization_amount;
      swing_amount = _o.swing_amount;

      repeat_note_length = _o.repeat_note_length;
      num_repeats        = _o.num_repeats;

      velocities = _o.velocities;
      velocity_jitter = _o.velocity_jitter;

      default_note_duration_ticks = _o.default_note_duration_ticks;

      microtime_shift = _o.microtime_shift;
      microtime_jitter = _o.microtime_jitter;

      b_forced_out   = _o.b_forced_out;
      forced_out_dev = _o.forced_out_dev;
      forced_out_ch  = _o.forced_out_ch;

      forced_output_mode = _o.forced_output_mode;

      ui_queued_step = -1;

      mod1_type.copyFrom(_o.mod1_type);
      mod1_min    = _o.mod1_min;
      mod1_max    = _o.mod1_max;
      mod1_reset  = _o.mod1_reset;
      mod1_jitter = _o.mod1_jitter;

      mod2_type.copyFrom(_o.mod2_type);
      mod2_min    = _o.mod2_min;
      mod2_max    = _o.mod2_max;
      mod2_reset  = _o.mod2_reset;
      mod2_jitter = _o.mod2_jitter;

      b_forced_mod_out   = _o.b_forced_mod_out;
      forced_mod_out_dev = _o.forced_mod_out_dev;
      forced_mod_out_ch  = _o.forced_mod_out_ch;

      mod_tickshift = _o.mod_tickshift;

      b_linnstrument_perf_trig_dur_scl = _o.b_linnstrument_perf_trig_dur_scl;
   }

   // <method_get.png>
   public method isArg3NoteOffset(NodeTrigSeq _seq) : boolean {
      byte outputMode = (-1 != forced_output_mode) ? forced_output_mode : _seq.output_mode;
      return [NodeTrigSeq.OUT_SINGLECH_NOTE,
              NodeTrigSeq.OUT_SINGLECH_NOTE_PROBABILITY,
              NodeTrigSeq.OUT_MULTICH_NOTE,
              NodeTrigSeq.OUT_CHROMATIC,
              NodeTrigSeq.OUT_CHROMATIC_MONO].contains(outputMode);
   }

   // <method.png>
   public method allocSteps(int _num, int _trackIdx) : boolean {
      if(steps.alloc(_num))
      {
         int stepIdx = 0;
         loop(_num)
         {
            NTS_Step st <= new NTS_Step;
            st.init(stepIdx++, this);
            steps.add(#(deref st));
         }
         return true;
      }
      return false;
   }

   // <method.png>
   public method updateTrigCache() {
      NTS_Step *st;
      b_has_trigs_cache = false;
      NTS_Step stLastTrig <= null;
      int lastTrigIdx = -1;
      int stIdx = 0;
      int trigDistPendingIdx = -1;
      loop(play_length)
      {
         st <= steps.get(stIdx);
         if(st.b_trig || st.b_mod)
         {
            b_has_trigs_cache = true;
         }
         if(st.b_trig || st.b_repeat)
         {
            if(null != stLastTrig)
            {
               stLastTrig.slide_next_trig_dist_cache = stIdx - lastTrigIdx;
            }
            else
            {
               // First (trig) step => update slide dist for last trig (wrap-around)
               int stWrapIdx = play_length;
               while(--stWrapIdx >= 0)
               {
                  NTS_Step stWrap <= steps.get(stWrapIdx);
                  if(stWrap.b_trig || stWrap.b_repeat)
                  {
                     stWrap.slide_next_trig_dist_cache = (stIdx - stWrapIdx) + play_length;
                     break;
                  }
               }
            }
            stLastTrig <= st;
            lastTrigIdx = stIdx;
         }
         stIdx++;
      }
   }

   // <ui.png>
   public =replay= method queueMod1(float _mod1) {
      ui_queued_mod1 = _mod1;
   }

   // <ui.png>
   public =replay= method queueMod2(float _mod2) {
      ui_queued_mod2 = _mod2;
   }

   // <method_set.png>
   public =replay= method setModTickShift(byte _shift) {
      mod_tickshift = _shift;
   }

   // <method.png>
   public =replay= method clearAll(boolean _bMod) {
      NTS_Step *st;
      foreach st in steps
      {
         st.b_trig    = false;
         st.b_repeat  = false;
         st.b_mod     = _bMod;
         st.microtime = 0.0f;
         st.arg1      = 0.0f;
         st.arg2      = NodeTrigSeq.INVALID_VALUE;
         st.mod1      = NodeTrigSeq.INVALID_VALUE;
         st.mod2      = NodeTrigSeq.INVALID_VALUE;
         st.slide_next_trig_dist_cache = 1;
      }
      b_has_trigs_cache = false;
   }

   // <method.png>
   public =replay= method clearAndModAll() {
      NTS_Step *st;
      foreach st in steps
      {
         st.b_trig    = false;
         st.b_repeat  = false;
         st.b_mod     = false;
         st.microtime = 0.0f;
         st.arg1      = 0.0f;
         st.arg2      = NodeTrigSeq.INVALID_VALUE;
         st.mod1      = NodeTrigSeq.INVALID_VALUE;
         st.mod2      = NodeTrigSeq.INVALID_VALUE;
         st.slide_next_trig_dist_cache = 1;
      }
      b_has_trigs_cache = false;
   }

   // <method.png>
   public =replay= method clearTrigsAndRepeats() {
      NTS_Step *st;
      foreach st in steps
      {
         st.b_trig   = false;
         st.b_repeat = false;
         st.b_mod    = false;
         st.slide_next_trig_dist_cache = 1;
      }
      b_has_trigs_cache = false;
   }

   // <method.png>
   public =replay= method clearMicrotime() {
      NTS_Step *st;
      foreach st in steps
      {
         st.microtime = 0;
      }
   }

   // <method.png>
   public =replay= method clearArgs() {
      NTS_Step *st;
      foreach st in steps
      {
         st.arg1 = 0.0f;
         st.arg2 = NodeTrigSeq.INVALID_VALUE;
      }
      updateTrigCache();
   }

   // <method.png>
   public =replay= method clearMods() {
      NTS_Step *st;
      foreach st in steps
      {
         // (note) don't clear st.b_mod
         st.mod1 = NodeTrigSeq.INVALID_VALUE;
         st.mod2 = NodeTrigSeq.INVALID_VALUE;
      }
      updateTrigCache();
   }

   // <method_get.png>
   public method getCurrentNoteNameProfileId(NTS_Pattern _pat) : String {
      if(null == note_name_profile_id)
      {
         return _pat.note_name_profile_id;
      }
      return note_name_profile_id;
   }

   // <method_set.png>
   public =replay= method setArg3(float _arg3) {
      arg3 = _arg3;
   }

   // <method_set.png>
   public =replay= method setPlayLength(int _numSteps, NTS_Pattern _pat) {
      if(0 <= _numSteps <= 64)
      {
         play_length = _numSteps;

         calcCurrentStepNumTicks();
         calcCurrentRepeatNumTicks();
         updateTrigCache();
         _pat.b_recalc_common_repeat = true;
      }
   }

   // <method_set.png>
   public =replay= method setQuantizationAmount(float _quantAmount) {
      _quantAmount = mathClampf(_quantAmount, 0.0f, 1.0f);
      quantization_amount = _quantAmount;
   }

   // <method_set.png>
   public =replay= method setSwingAmount(float _swingAmount) {
      _swingAmount = mathClampf(_swingAmount, -0.5f, 0.5f);
      swing_amount = _swingAmount;
   }

   // <method_set.png>
   public =replay= method setStepNoteLength(int _lenIdx, NTS_Pattern _pat) {
      step_note_length = mathClampi(_lenIdx, 0, NTS_Track.NOTELEN_NUM-1);
      calcCurrentStepNumTicks();
      _pat.b_recalc_common_repeat = true;
   }

   // <method_set.png>
   public method getStepNoteLengthTicks() : float {
      return current_step_num_ticks;
   }

   // <method_get.png>
   public method getStepByIndex(int _stepIdx) : NTS_Step {
      return steps.get(_stepIdx);
   }

   // <method_get.png>
   public method findNextTrigStepAfter(int _stepIdx) : NTS_Step {
      // used by step note recording (see NodeTrigSeqEditor::mmlHandleEventUI())
      if(play_length > 1)
      {
         int stepIdx = (_stepIdx + 1) % play_length;
         loop(play_length)
         {
            NTS_Step st <= steps.get(stepIdx);
            if(st.b_trig)
               return st;
            stepIdx = (stepIdx + 1 ) % play_length;
         }
      }
      return null;
   }

   // <method_get.png>
   public =replay= method getLastPlayedStep() : int {
      return last_played_step;
   }

   // <method_set.png>
   public =replay= method setRepeatNoteLength(int _lenIdx) {
      repeat_note_length = _lenIdx;
      calcCurrentRepeatNumTicks();
   }

   // <method_set.png>
   public =replay= method setNumRepeats(int _num) {
      num_repeats = _num;
      current_num_repeats = num_repeats;
   }

   // <method_set.png>
   public =replay= method setVelocity(byte _index, byte _vel) {
      velocities[_index] = _vel;
   }

   // <method_set.png>
   public =replay= method setVelocityJitter(float _jitter) {
      velocity_jitter = _jitter;
   }

   // <method_get.png>
   public method findVelocityIndexByVelocity(byte _vel) : byte {
      int bestMatchIdx = 0;
      int bestMatchDist = 99999;
      int velIdx = 0;

      loop(4)
      {
         int dist = abs(_vel - velocities.get(velIdx));
         if(dist < bestMatchDist)
         {
            bestMatchIdx = velIdx;
            bestMatchDist = dist;
         }
         velIdx++;
      }

      // trace "xxx findVelocityIndex: vel="+_vel+" bestMatchIdx="+bestMatchIdx+" bestMatchDist="+bestMatchDist+" => vel="+velocities.get(bestMatchIdx);

      return bestMatchIdx;
   }

   // <method_set.png>
   public =replay= method setDefaultNoteDurationTicks(short _ticks) {
      default_note_duration_ticks = _ticks;
   }

   // <method_set.png>
   public =replay= method setEnableForcedOut(boolean _bEnable) {
      b_forced_out = _bEnable;
   }

   // <method_set.png>
   public =replay= method setForcedOutDev(short _dev) {
      forced_out_dev = _dev;
   }

   // <method_set.png>
   public =replay= method setForcedOutCh(byte _ch) {
      forced_out_ch = _ch;
   }

   // <method_set.png>
   public =replay= method setForcedOutputMode(byte _mode) {
      forced_output_mode = _mode;
   }

   // <method_get.png>
   public method getActualOutputMode() : int {
      return (-1 != forced_output_mode) ? forced_output_mode : parent_node.output_mode;
   }

   // <method_get.png>
   public method isNoteOutputMode(NodeTrigSeq _seq) : boolean {
      // (note) used by editor to determine whether to display arg3 as note
      byte outputMode = (-1 != forced_output_mode) ? forced_output_mode : _seq.output_mode;

      return [NodeTrigSeq.OUT_SINGLECH_NOTE,
              NodeTrigSeq.OUT_SINGLECH_NOTE_PROBABILITY,
              NodeTrigSeq.OUT_MULTICH_NOTE,
              NodeTrigSeq.OUT_CHROMATIC,
              NodeTrigSeq.OUT_CHROMATIC_MONO
              ].contains(outputMode);
   }

   // <method_set.png>
   public =replay= method setMicrotimeShift(float _shift) {
      microtime_shift = _shift;
   }

   // <method_get.png>
   public method getMicroTimeShiftTicks() : int {
      return microtime_shift * current_step_num_ticks;
   }

   // <method_set.png>
   public =replay= method setMicrotimeJitter(float _jitter) {
      microtime_jitter = _jitter;
   }

   // <method_get.png>
   public method getMicroTimeJitterTicks() : int {
      return microtime_jitter * current_step_num_ticks;
   }

   // <method_set.png>
   public =replay= method setEnableForcedModOut(boolean _bEnable) {
      b_forced_mod_out = _bEnable;
   }

   // <method_set.png>
   public =replay= method setForcedModOutDev(short _dev) {
      forced_mod_out_dev = _dev;
   }

   // <method_set.png>
   public =replay= method setForcedModOutCh(byte _ch) {
      forced_mod_out_ch = _ch;
   }

   // <method_set.png>
   public =replay= method setMod1Min(float _val) {
      mod1_min = _val;
   }

   // <method_set.png>
   public =replay= method setMod1Max(float _val) {
      mod1_max = _val;
   }

   // <method_set.png>
   public =replay= method setMod1Reset(float _val) {
      mod1_reset = _val;
   }

   // <method_set.png>
   public =replay= method setMod1Jitter(float _val) {
      mod1_jitter = _val;
   }

   // <method_set.png>
   public =replay= method setMod2Min(float _val) {
      mod2_min = _val;
   }

   // <method_set.png>
   public =replay= method setMod2Max(float _val) {
      mod2_max = _val;
   }

   // <method_set.png>
   public =replay= method setMod2Reset(float _val) {
      mod2_reset = _val;
   }

   // <method_set.png>
   public =replay= method setMod2Jitter(float _val) {
      mod2_jitter = _val;
   }

   // <method_get.png>
   public method getModCaption(NodeTrigSeq _seq, MIDIMapEventType _evType) : String {
      if(-1 != mod1_type.type)
      {
         int outDevIdx = getModOutDevIdx(_seq);
         NTS_Pattern pat <= _seq.nodeGetCurrentEditPattern();
         int outMidiCh = getModOutCh(_seq, pat);
         STX_MIDIOutDevice outDev <= MIDI.GetMIDIOutDeviceByIndex(outDevIdx);
         if(null != outDev)
         {
            MIDISynthProfile msp <= outDev.getMIDISynthProfile(outMidiCh);

            if(null == msp)
               msp <= MIDI.GetDefaultSynthProfile();

            switch(_evType.type)
            {
               case MIDIMapDefs.TYPE_POLY_PRESSURE:
                  return "Poly Pressure";

               case MIDIMapDefs.TYPE_CC:
                  return msp.getCCCaption(_evType.ext_type);

               case MIDIMapDefs.TYPE_PROGRAM_CHANGE:
                  return "Program Change";

               case MIDIMapDefs.TYPE_CHANNEL_PRESSURE:
                  return "Channel Pressure";

               case MIDIMapDefs.TYPE_PITCHBEND:
                  return "Pitchbend";

               case MIDIMapDefs.TYPE_RPN:
                  return msp.getRPNCaption(_evType.ext_type);

               case MIDIMapDefs.TYPE_NRPN:
                  return msp.getNRPNCaption(_evType.ext_type);

               case MIDIMapDefs.TYPEX_NOTE_NUMBER:
                  return "Note Number";

               case MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL:
                  return "Note Velocity *";

               case MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD:
                  return "Note Velocity +";

               case MIDIMapDefs.TYPEX_NOTE_DURATION:
                  return "Note Duration";
            }
         }
      }
      return "-";
   }

   // <method_get.png>
   public method getMod1Caption(NodeTrigSeq _seq) : String {
      return getModCaption(_seq, mod1_type);
   }

   // <method_get.png>
   public method getMod2Caption(NodeTrigSeq _seq) : String {
      return getModCaption(_seq, mod2_type);
   }

   // <method_set.png>
   public =replay= method setTemporaryRepeatNoteLength(NTS_TrackState _trackState, int _lenIdx) {
      // via RPN
      _trackState.temp_repeat_note_length = _lenIdx;
      current_repeat_num_ticks = CalcStepNumTicks(
         (-1 == _lenIdx) ? (-1 == repeat_note_length) ? step_note_length : repeat_note_length : _lenIdx,
         play_length
                                                  );
   }

   // <method_set.png>
   public =replay= method setCurrentRepeatNoteLength(NTS_TrackState _trackState, int _lenIdx) {
      // via RPN
      _trackState.temp_repeat_note_length = -1;
      current_repeat_num_ticks = CalcStepNumTicks(
         (-1 == _lenIdx) ? (-1 == repeat_note_length) ? step_note_length : repeat_note_length : _lenIdx,
         play_length
                                                  );
   }

   // <method_set.png>
   public =replay= method setTemporaryNumRepeats(NTS_TrackState _trackState, int _num) {
      // via RPN
      _trackState.temp_num_repeats = _num;
      current_num_repeats = (-1 == _num) ? num_repeats : _num;
   }

   // <method_set.png>
   public =replay= method setCurrentNumRepeats(NTS_TrackState _trackState, int _num) {
      // via RPN
      _trackState.temp_num_repeats = -1;
      current_num_repeats = (-1 == _num) ? num_repeats : _num;
   }

   // <method.png>
   public static CalcStepNumTicks(int _noteLen, int _numStepsHint) : float {
      float r = current_song.ppq * 4;

      switch(_noteLen)
      {
         default:
            r = r / base_notelen_dur_tbl.get(_noteLen / 3);
            if(1 == (_noteLen % 3))
               r *= 2.0 / 3.0;  // triplet
            else if(2 == (_noteLen % 3))
               r *= 1.5;        // dotted
            break;

         case NOTELEN_FIT1Q:
            r = (r / 4.0f) / _numStepsHint;
            break;

         case NOTELEN_FIT2Q:
            r = (r / (4.0f / 2.0f)) / _numStepsHint;
            break;

         case NOTELEN_FIT3Q:
            r = (r / (4.0f / 3.0f)) / _numStepsHint;
            break;

         case NOTELEN_FIT4Q:
            r = (r / (4.0f / 4.0f)) / _numStepsHint;
            break;

         case NOTELEN_FIT5Q:
            r = (r / (4.0f / 5.0f)) / _numStepsHint;
            break;

         case NOTELEN_FIT6Q:
            r = (r / (4.0f / 6.0f)) / _numStepsHint;
            break;

         case NOTELEN_FIT7Q:
            r = (r / (4.0f / 7.0f)) / _numStepsHint;
            break;

         case NOTELEN_FIT8Q:
            r = (r / (4.0f / 8.0f)) / _numStepsHint;
            break;
      }

      return r;
   }

   // <method.png>
   public method calcCurrentStepNumTicks() {
      current_step_num_ticks = CalcStepNumTicks(step_note_length, play_length);
   }

   // <method.png>
   public method calcCurrentRepeatNumTicks() {
      current_repeat_num_ticks = CalcStepNumTicks((-1 == repeat_note_length) ? step_note_length : repeat_note_length, play_length);
   }

   // <method_get.png>
   public method getNumTrigs() : int {
      // used by UI
      int r = 0;
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         if(st.b_trig || st.b_mod)
            r++;
      }
      return r;
   }

   // <method.png>
   public =replay= method rotateStepsLeft() {
      if(play_length > 1)
      {
         NTS_Step t;
         NTS_Step st <= steps.get(0);
         t.copyFrom(st);
         int stepIdx = 1;
         NTS_Step stp <= steps.get(0);
         loop(play_length -1)
         {
            NTS_Step stn <= steps.get(stepIdx);
            stp.copyFrom(stn);
            stp <= stn;
            stepIdx++;
         }
         stp.copyFrom(t);
      }
   }

   // <method.png>
   public =replay= method rotateStepsRight() {
      if(play_length > 1)
      {
         NTS_Step t;
         NTS_Step st <= steps.get(play_length - 1);
         t.copyFrom(st);
         int stepIdx = play_length - 2;
         NTS_Step stn <= steps.get(play_length - 1);
         loop(play_length -1)
         {
            NTS_Step stp <= steps.get(stepIdx);
            stn.copyFrom(stp);
            stn <= stp;
            stepIdx--;
         }
         stn.copyFrom(t);
      }
   }

   // <method.png>
   public =replay= method moveStepLeft(int _stepIdx) {
      if(play_length > 1)
      {
         if(0 <= _stepIdx < play_length)
         {
            NTS_Step *stDst;
            NTS_Step st <= steps.get(_stepIdx);
            int newX;

            if(0 == _stepIdx)
            {
               newX = play_length -1;
            }
            else
            {
               newX = _stepIdx - 1;
            }

            stDst <= steps.get(newX);

            if(!stDst.b_trig && !stDst.b_repeat && !stDst.b_mod)
            {
               stDst.copyFrom(st);
               st.b_trig   = false;
               st.b_repeat = false;
               st.b_mod    = false;
               updateTrigCache();
               return newX;
            }
         }
      }
      return -1;
   }

   // <method.png>
   public =replay= method moveStepRight(int _stepIdx)  : int {
      if(play_length > 1)
      {
         if(0 <= _stepIdx < play_length)
         {
            NTS_Step *stDst;
            NTS_Step st <= steps.get(_stepIdx);
            int newX;

            if((play_length - 1) == _stepIdx)
            {
               newX = 0;
            }
            else
            {
               newX = _stepIdx + 1;
            }

            stDst <= steps.get(newX);

            if(!stDst.b_trig && !stDst.b_repeat && !stDst.b_mod)
            {
               stDst.copyFrom(st);
               st.b_trig   = false;
               st.b_repeat = false;
               st.b_mod    = false;
               updateTrigCache();
               return newX;
            }
         }
      }
      return -1;
   }

   // <method.png>
   public =replay= method insertStep(int _stepIdx) {

      if(0 <= _stepIdx < (MAX_STEPS-1))
      {
         int stepIdx = MAX_STEPS - 2;
         NTS_Step stn <= steps.get(MAX_STEPS - 1);
         loop(MAX_STEPS - 1 - _stepIdx)
         {
            NTS_Step stp <= steps.get(stepIdx);
            stn.copyFrom(stp);
            stn <= stp;
            stepIdx--;
         }
         NTS_Step st <= steps.get(_stepIdx);
         st.b_trig = false;
         updateTrigCache();
      }
   }

   // <method.png>
   public =replay= method deleteStep(int _stepIdx) {

      if(0 <= _stepIdx < (MAX_STEPS-1))
      {
         int stepIdx = _stepIdx + 1;
         NTS_Step stp <= steps.get(stepIdx - 1);
         NTS_Step st <= stp;
         loop(64 - 1 - _stepIdx)
         {
            NTS_Step stn <= steps.get(stepIdx);
            stp.copyFrom(stn);
            stp <= stn;
            stepIdx++;
         }
         updateTrigCache();
      }
   }

   // <method.png>
   public method clearAllStepsAndResetPlayLength(NTS_Pattern _pat) {
      NTS_Step *st;
      foreach st in steps
      {
         st.clearStep();
      }
      play_length = 16;
      setStepNoteLength(NOTELEN_16, _pat);
      quantization_amount = 0.0f;
      swing_amount = 0.0f;
      updateTrigCache();
   }

   // <method.png>
   public =replay= method reverseSteps() {
      if(play_length > 1)
      {
         int stepIdxR = play_length - 1;
         int stepIdxL = 0;
         while(stepIdxL < stepIdxR)
         {
            NTS_Step t;
            NTS_Step stl <= steps.get(stepIdxL);
            t.copyFrom(stl);
            NTS_Step str <= steps.get(stepIdxR);
            stl.copyFrom(str);
            str.copyFrom(t);
            stepIdxL++;
            stepIdxR--;
         }
         updateTrigCache();
      }
   }

   // <method.png>
   public =replay= method randomizeArg1() {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.arg1 = mathClampf(rand(3.9f), 0.0f, 3.0f);
      }
   }

   // <method.png>
   public =replay= method initArg2(float _val) {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.arg2 = _val;
      }
   }

   // <method.png>
   public =replay= method loadArg2Identity() {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx);
         st.arg2 = stepIdx++;
      }
   }

   // <method.png>
   public =replay= method initMod1(float _val) {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.mod1 = _val;
      }
   }

   // <method.png>
   public =replay= method initMod2(float _val) {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.mod2 = _val;
      }
   }

   // <method.png>
   public =replay= method randomizeTrigs() {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.b_trig = rand(1+1);
      }
      updateTrigCache();
   }

   // <method.png>
   public =replay= method randomizeRepeats() {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.b_repeat = rand(1+1);
      }
      updateTrigCache();
   }

   // <method.png>
   public =replay= method randomizeMod1() {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.mod1 = rand(127.0);
      }
   }

   // <method.png>
   public =replay= method randomizeMod2() {
      int stepIdx = 0;
      loop(play_length)
      {
         NTS_Step st <= steps.get(stepIdx++);
         st.mod2 = rand(127.0);
      }
   }

   // <method_get.png>
   public method getStepNearTime(NTS_Pattern _pat, int _ticks, Boolean _bRetFuture, Integer _retTickDelta, Boolean _retStep1) : NTS_Step {

      int stepIdx = 0;
      float stepTime = 0.0;

      // trace "xxx current_step_num_ticks="+current_step_num_ticks;
      float ticksPerTrack = (current_step_num_ticks * play_length);
      float tickCountMod;
      // // float tickCountMod = _ticks % ticksPerTrack;
      float patMasterLenTicks = 0;
      if(_pat.master_len_16th > 0.0f)
      {
         patMasterLenTicks = current_song.getNumTicksPer16th() * _pat.master_len_16th;
         tickCountMod = _ticks % patMasterLenTicks;
         tickCountMod = tickCountMod % ticksPerTrack;
      }
      else
      {
         tickCountMod = _ticks % ticksPerTrack;
      }

      // // trace "xxx tickCountMod="+tickCountMod;

      int swingShift = (play_length & 1) & int(_ticks / ticksPerTrack);  // (todo) factor in master_len_16th

      NTS_Step bestMatchStep <= null;
      float bestMatchDist = 999999;

      if(null != _bRetFuture)
      {
         _bRetFuture = false;
      }

      NTS_Step *st;
      loop(play_length + 1)
      {
         if(stepIdx >= play_length)
            stepIdx -= play_length;
         st <= steps.get(stepIdx);

         float cStepTime = stepTime;/// + (st.microtime * current_step_num_ticks); // * 0.5

         if(int(stepIdx + swingShift)&1)
         {
            cStepTime += mathClampf(_pat.swing_offset + swing_amount, -0.5, 0.5) * current_step_num_ticks;
         }

         if(cStepTime < 0.0f)
         {
            if(_ticks >= current_step_num_ticks)
            {
               // trace "xxx wrap cStepTime";
               if(patMasterLenTicks > 0)
               {
                  //             *              *
                  // 0 1 2 3 4 5 6 7 8 9 10 11 12
                  // 0 1 2 3 4 5 0 1 2 3  4  5  0
                  // 0 1 2 3 0 1 0 1 2 3  0  1  0
                  tickCountMod = (_ticks - cStepTime) % patMasterLenTicks;
                  tickCountMod = tickCountMod % ticksPerTrack;
                  cStepTime = 0;
               }
               else
               {
                  cStepTime += ticksPerTrack; // first step
               }
            }
            else
            {
               // cornercase: first step (shifted ahead of time) after replay start
               cStepTime = 0;
            }

            // // cStepTime += ticksPerTrack; // first step
         }

         float dist = abs(tickCountMod - cStepTime);
         if(dist < bestMatchDist)
         {
            bestMatchDist = dist;
            bestMatchStep <= st;

            if(null != _bRetFuture)
            {
               _bRetFuture = (cStepTime >= tickCountMod);
            }

            if(null != _retTickDelta)
            {
               _retTickDelta = (tickCountMod - cStepTime);
            }
         }

         // Try next step
         stepIdx++;
         stepTime += current_step_num_ticks;
      }

      _retStep1 = (@(st) == steps.get(0));

      return bestMatchStep;
   }

   // <replay.png>
   public method trackReset(boolean _bSoft) {

      calcCurrentStepNumTicks();

      last_played_step = -1;
      last_played_step_mod = -1;

      calcCurrentRepeatNumTicks();
      current_num_repeats = num_repeats;

      // (note) track state is reset in nodeReset()

      rec_note_on_ticks = -1;

      b_ui_trig_queued_on  = false;
      b_ui_trig_queued_off = false;

      ui_queued_step = -1;

      current_microtime_jitter = 0;
   }

   // <method_get.png>
   public method getOutCh(NodeTrigSeq _seq, NTS_Pattern _pat) : int {
      // Called by NodeTrackerEditor::cmd_pattern_import_trigseq_handle_ok()
      if(b_forced_out)
      {
         return forced_out_ch;
      }

      byte outputMode = (-1 != forced_output_mode) ? forced_output_mode : _seq.output_mode;

      switch(outputMode)
      {
         default:
            return _seq.out_ch;

            // // return _seq.out_ch + track_nr;
         case NodeTrigSeq.OUT_MULTICH_NOTE:
         case NodeTrigSeq.OUT_MULTICH_CLOCKGATE:
         case NodeTrigSeq.OUT_MULTICH_GATE_SEEK_REL_RESET:
         case NodeTrigSeq.OUT_MULTICH_GATE_SEEK_REL:
         case NodeTrigSeq.OUT_MULTICH_DRUMPADSELECT:
            return (_seq.out_ch + arg3 + _pat.arg3_offset)&15;
      }
   }

   // <method_get.png>
   public method getModOutCh(NodeTrigSeq _seq, NTS_Pattern _pat) : int {
      if(b_forced_mod_out)
         return forced_mod_out_ch;
      return getOutCh(_seq, _pat);
   }

   // <method_get.png>
   public method getOutDevIdx(NodeTrigSeq _seq) : int {
      // Called by NodeTrackerEditor::cmd_pattern_import_trigseq_handle_ok()
      if(b_forced_out && (-1 != forced_out_dev))
      {
         return forced_out_dev;
      }

      return _seq.out_dev_idx;
   }

   // <method_get.png>
   public method getOutDev(NodeTrigSeq _seq) : STX_MIDIOutDevice {
      // Called by NodeTrackerEditor::cmd_pattern_import_trigseq_handle_ok()
      int outDevIdx = getOutDevIdx(_seq);
      return MIDI.GetMIDIOutDeviceByIndex(outDevIdx);
   }

   // <method_get.png>
   public method getModOutDevIdx(NodeTrigSeq _seq) : int {
      if(b_forced_mod_out && (-1 != forced_mod_out_dev))
      {
         return forced_mod_out_dev;
      }

      return getOutDevIdx(_seq);
   }

   // <method_get.png>
   public method getOutNoteHint(NodeTrigSeq _seq, NTS_Pattern _pat) : int {
      // called by tryEditSound()
      if(isArg3NoteOffset(_seq))
         return arg3 + _pat.arg3_offset;
      return 0;
   }

   // <ui.png>
   public =replay= method queueTrackTrigger(boolean _bOn) {
      if(_bOn)
         b_ui_trig_queued_on = true;
      else
         b_ui_trig_queued_off = true;
   }

   // <ui.png>
   public =replay= method queueStepReplay(byte _stepIdx) {
      ui_queued_step = _stepIdx;
   }

   // <method.png>
   public method recordOrPlayNoteOn(MIDIPipeFrame _framePlayOrNull,
                                    NodeTrigSeq   _seq,
                                    NTS_Pattern   _pat,
                                    float         _arg1,
                                    float         _arg2,
                                    boolean       _bAllowRecNote,
                                    boolean       _bAllowRecMod,
                                    float         _mod1,
                                    float         _mod2
                                    ) {
      rec_note_on_ticks = _seq.tick_nr;

      if(STConfig.b_node_tracker_rec_latency)
      {
         rec_note_on_ticks -= current_song.milliSecondsToTicks(STConfig.node_tracker_rec_latency);
      }
      rec_note_on_ticks -= current_pipe_root.pipeDelay;

      Integer tickDelta;
      Boolean bStep1;

      NTS_Step st <= getStepNearTime(_pat, rec_note_on_ticks, null/*bRetFuture*/, tickDelta, bStep1);

      if(null != _framePlayOrNull)
      {
         playStepArgs(_framePlayOrNull, _seq, _pat,
                      _arg1/*velIdx*/,
                      _arg2/*pev.duration*/,
                      true/*bInfOnOff*/,
                      bStep1,
                      (NodeTrigSeq.INVALID_VALUE != _mod1) ? _mod1 : (null != st) ? st.mod1 : _mod1,
                      (NodeTrigSeq.INVALID_VALUE != _mod2) ? _mod2 : (null != st) ? st.mod2 : _mod2,
                      true/*bLerpMod1*/,
                      true/*bLerpMod2*/,
                      st.slide_next_trig_dist_cache,
                      true/*bPlayMod*/
                      );
      }

      if(_seq.b_recording && _bAllowRecNote)
      {
          // trace "xxx NodeTrigSeq: rec step="+#(st);

         if(null != st)
         {
            st.b_trig    = true;
            st.arg1      = _arg1;

            if(_seq.b_rec_quantize)
            {
               st.microtime = 0.0f;
            }
            else
            {
               st.microtime = tickDelta / current_step_num_ticks;
               // trace "xxx tickDelta="+tickDelta+" step_num_ticks="+track.current_step_num_ticks+" ==> microtime="+st.microtime;
            }

            if(-1 != _pat.microtime_track_idx)
            {
               if(track_nr != _pat.microtime_track_idx)
               {
                  NTS_Track microtimeTrack <= _pat.getTrackByIndex(_pat.microtime_track_idx);

                  // // int srcStepIdx;

                  // // if(play_length & 1)
                  // // {
                  // //    // avoid shifting step times, can't repeat timing track (would skip trigs when track repeats)
                  // //    srcStepIdx = st.grid_x;
                  // // }
                  // // else
                  // // {
                  // //    // repeat timing track
                  // //    float ticksPerTrack = (current_step_num_ticks * play_length);
                  // //    float curTickNr = _seq.tick_nr * parent_node.rpn_com_pos_scl;
                  // //    srcStepIdx = st.grid_x + int(curTickNr / ticksPerTrack)*play_length;
                  // // }

                  // // st.microtime -= microtimeTrack.getMicrotimeTrackStepTickShift(srcStepIdx, current_step_num_ticks);
                  st.microtime -= microtimeTrack.getMicrotimeTrackStepTickShift(st.grid_x, current_step_num_ticks, _pat);
               }
            }

            st.b_repeat  = false;
            st.b_mod     = false;

            if(_bAllowRecMod)
            {
               st.mod1 = _mod1;
               st.mod2 = _mod2;
            }

            updateTrigCache();
            _seq.b_redraw_queued = true;
         }
      }
   }

   // <method.png>
   public method recordOrPlayNoteOff(MIDIPipeFrame _framePlayOrNull,
                                     NodeTrigSeq   _seq,
                                     NTS_Pattern   _pat,
                                     boolean       _bAllowRec
                                     ) {
      // trace "xxx off: track.rec_note_on_ticks="+track.rec_note_on_ticks;

      if(-1 != rec_note_on_ticks)
      {
         Boolean bFuture;
         Boolean bStep1;
         NTS_Step st <= getStepNearTime(_pat, rec_note_on_ticks, bFuture, null, bStep1);

         int seqTicks = _seq.tick_nr;
         if(STConfig.b_node_tracker_rec_latency)
         {
            seqTicks -= current_song.milliSecondsToTicks(STConfig.node_tracker_rec_latency);
         }
         seqTicks -= current_pipe_root.pipeDelay;

         if(null != st)
         {
            byte outputMode = (-1 != forced_output_mode) ? forced_output_mode : _seq.output_mode;

            // Note off
            switch(outputMode)
            {
               case NodeTrigSeq.OUT_SINGLECH_NOTE:
                  // arg2=duration
                  if(_bAllowRec)
                  {
                     st.arg2 = seqTicks - rec_note_on_ticks;
                  }

                  // Play note and, when pev.duration is 0, hold indefinitely until note off is received
                  if(null != _framePlayOrNull)
                  {
                     playStepArgs(_framePlayOrNull, _seq, _pat,
                                  0/*arg1*/,
                                  0/*arg2*/,
                                  false/*bInfOnOff*/,
                                  bStep1,
                                  NodeTrigSeq.INVALID_VALUE/*mod1*/,
                                  NodeTrigSeq.INVALID_VALUE/*mod2*/,
                                  false/*bLerpMod1*/,
                                  false/*bLerpMod2*/,
                                  st.slide_next_trig_dist_cache,
                                  true/*bPlayMod*/
                                  );
                  }
                  _seq.b_redraw_queued = true;
                  break;

               case NodeTrigSeq.OUT_SINGLECH_NOTE_PROBABILITY:
                  // arg2=probability
                  if(_bAllowRec)
                  {
                     st.arg2 = NodeTrigSeq.INVALID_VALUE;
                  }

                  // Play note and, when pev.duration is 0, hold indefinitely until note off is received
                  if(null != _framePlayOrNull)
                  {
                     playStepArgs(_framePlayOrNull,
                                  _seq,
                                  _pat,
                                  0/*arg1*/,
                                  0/*arg2*/,
                                  false/*bInfOnOff*/,
                                  bStep1,
                                  NodeTrigSeq.INVALID_VALUE/*mod1*/,
                                  NodeTrigSeq.INVALID_VALUE/*mod2*/,
                                  false/*bLerpMod1*/,
                                  false/*bLerpMod2*/,
                                  st.slide_next_trig_dist_cache,
                                  true/*bPlayMod*/
                                  );
                  }
                  _seq.b_redraw_queued = true;
                  break;

               case NodeTrigSeq.OUT_MULTICH_NOTE:
                  // arg2=duration
                  if(_bAllowRec)
                  {
                     st.arg2 = seqTicks - rec_note_on_ticks;
                  }

                  // Play note and, when pev.duration is 0, hold indefinitely until note off is received
                  if(null != _framePlayOrNull)
                  {
                     playStepArgs(_framePlayOrNull,
                                  _seq,
                                  _pat,
                                  0/*arg1*/,
                                  0/*arg2*/,
                                  false/*bInfOnOff*/,
                                  bStep1,
                                  NodeTrigSeq.INVALID_VALUE/*mod1*/,
                                  NodeTrigSeq.INVALID_VALUE/*mod2*/,
                                  false/*bLerpMod1*/,
                                  false/*bLerpMod2*/,
                                  st.slide_next_trig_dist_cache,
                                  true/*bPlayMod*/
                                  );
                  }
                  _seq.b_redraw_queued = true;
                  break;

               case NodeTrigSeq.OUT_SINGLECH_MUTE_TEMP:
                  break;

               case NodeTrigSeq.OUT_SINGLECH_PAT_CHG_OFF_RUN:
                  break;

               case NodeTrigSeq.OUT_SINGLECH_PAT_OFF_RUN:
                  break;

               case NodeTrigSeq.OUT_PAT_CHG_OFF:
                  break;

               case NodeTrigSeq.OUT_SINGLETRACK_POLYSTEP:
               case NodeTrigSeq.OUT_MULTITRACK_POLYSTEP:
               case NodeTrigSeq.OUT_MULTITRACK_POLYSTEP4:
                  break;

               case NodeTrigSeq.OUT_MULTICH_CLOCKGATE:
                  break;

               case NodeTrigSeq.OUT_MULTICH_CLOCKGATE_PAT_CHG_OFF:
                  break;

               case NodeTrigSeq.OUT_MULTICH_DRUMPADSELECT:
                  // arg2=duration
                  if(_bAllowRec)
                  {
                     st.arg2 = seqTicks - rec_note_on_ticks;
                  }

                  // Play note and, when pev.duration is 0, hold indefinitely until note off is received
                  if(null != _framePlayOrNull)
                  {
                     playStepArgs(_framePlayOrNull,
                                  _seq,
                                  _pat,
                                  0/*arg1*/,
                                  0/*arg2*/,
                                  false/*bInfOnOff*/,
                                  bStep1,
                                  NodeTrigSeq.INVALID_VALUE/*mod1*/,
                                  NodeTrigSeq.INVALID_VALUE/*mod2*/,
                                  false/*bLerpMod1*/,
                                  false/*bLerpMod2*/,
                                  st.slide_next_trig_dist_cache,
                                  true/*bPlayMod*/
                                  );
                  }
                  _seq.b_redraw_queued = true;
                  break;

               case NodeTrigSeq.OUT_CHROMATIC:
               case NodeTrigSeq.OUT_CHROMATIC_MONO:
                  break;
            }
         }

         rec_note_on_ticks = -1;
      }
   }

   // <method.png>
   protected method unmapPipeEventValue(MIDIMapEventType _evType, float _min, float _max, MIDIPipeEvent _pev) : float {
      // Returns normalized 0..127 mod value
      float r = -1;
      if(_evType.matchPipeEventType(_pev))
      {
         // t = (r - min) / (max - min)
         switch(mod1_type.type)
         {
            case MIDIMapDefs.TYPE_POLY_PRESSURE:
               r = (_pev.polyPressureValue - _min) / (_max - _min);
               r = mathClampf(r * 127.0f, 0.0f, 127.0f);
               break;

            case MIDIMapDefs.TYPE_CC:
               r = (_pev.ccValue - _min) / (_max - _min);
               r = mathClampf(r * 127.0f, 0.0f, 127.0f);
               break;

            case MIDIMapDefs.TYPE_PROGRAM_CHANGE:
               r = (_pev.prgChg - _min) / (_max - _min);
               r = mathClampf(r * 127.0f, 0.0f, 127.0f);
               break;

            case MIDIMapDefs.TYPE_CHANNEL_PRESSURE:
               r = (_pev.chPressure - _min) / (_max - _min);
               r = mathClampf(r * 127.0f, 0.0f, 127.0f);
               break;

            case MIDIMapDefs.TYPE_PITCHBEND:
               r = (_pev.pitchbend - _min) / (_max - _min);
               r = mathClampf(r * 127.0f, 0.0f, 127.0f);
               break;

            case MIDIMapDefs.TYPE_RPN:
               r = (_pev.rpnValue - _min) / (_max - _min);
               r = mathClampf(r * 127.0f, 0.0f, 127.0f);
               break;

            case MIDIMapDefs.TYPE_NRPN:
               r = (_pev.nrpnValue - _min) / (_max - _min);
               r = mathClampf(r * 127.0f, 0.0f, 127.0f);
               break;

            case MIDIMapDefs.TYPEX_NOTE_NUMBER:
            case MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL:
            case MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD:
            case MIDIMapDefs.TYPEX_NOTE_DURATION:
               // Not mappable (clashes with regular trig recording)
               break;
         }
      }
      return r;
   }

   // <method.png>
   public method recordAndPlayModOrArgFromPlugin(MIDIPipeFrame _framePlay,
                                                 NodeTrigSeq   _seq,
                                                 NTS_Pattern   _pat,
                                                 int           _type,  // 0=mod1 1=mod2 2=arg1 3=arg2
                                                 float         _modVal/*0..127*/
                                                 ) {
      // trace "xxx recordOrPlayModOrArgFromPlugin: type="+_type+" modVal="+_modVal;

      // Called while realtime recording is active (seq.b_recording && replay.b_playing)
      NTS_TrackState trackState <= _seq.getTrackStateByIndex(track_nr);

      switch(_type)
      {
         case 0:
            playMod(_framePlay, _seq, _pat, trackState, mod1_type, mathLerpf(mod1_min, mod1_max, _modVal / 127.0));
            break;

         case 1:
            playMod(_framePlay, _seq, _pat, trackState, mod2_type, mathLerpf(mod2_min, mod2_max, _modVal / 127.0));
            break;
      }

      Boolean bFuture;
      Boolean bStep1;
      NTS_Step *st;
      int seqTickNr = _seq.tick_nr;
      if(STConfig.b_node_tracker_rec_latency)
      {
         seqTickNr -= current_song.milliSecondsToTicks(STConfig.node_tracker_rec_latency);
      }
      seqTickNr -= current_pipe_root.pipeDelay;
      st <= getStepNearTime(_pat, seqTickNr, bFuture, null, bStep1);

      if(null != st)
      {
         switch(_type)
         {
            case 0:
               st.mod1 = _modVal;
               break;

            case 1:
               st.mod2 = _modVal;
               break;

            case 2:
               st.arg1 = _modVal;
               break;

            case 3:
               st.arg2 = _modVal;
               break;
         }
      }
   }

   // <method.png>
   public method recordOrPlayMod(MIDIPipeFrame   _framePlay,
                                 MIDIPipeFrame   _frame,
                                 NodeTrigSeq     _seq,
                                 NTS_Pattern     _pat,
                                 int             _fltDevIdx,
                                 int             _fltCh,
                                 boolean         _bAllowRec,
                                 boolean         _bAllowRpnCtl,
                                 boolean         _bPlaySeq,
                                 boolean         _bAllowModOutUnmap
                                 ) {
      NTS_TrackState trackState <= _seq.getTrackStateByIndex(track_nr);

      if(-1 != ui_queued_mod1)
      {
         playMod(_framePlay, _seq, _pat, trackState, mod1_type, mathLerpf(mod1_min, mod1_max, ui_queued_mod1));
         ui_queued_mod1 = -1;
      }

      if(-1 != ui_queued_mod2)
      {
         playMod(_framePlay, _seq, _pat, trackState, mod2_type, mathLerpf(mod2_min, mod2_max, ui_queued_mod2));
         ui_queued_mod2 = -1;
      }

      if(0 == _frame.numEvents)
         return;

      int rpnNr = Node.RPN_CTL_BASE + track_nr;

      Boolean bFuture;
      Boolean bStep1;
      NTS_Step *st;
      if(_bPlaySeq)
      {
         int seqTickNr = _seq.tick_nr;
         if(STConfig.b_node_tracker_rec_latency)
         {
            seqTickNr -= current_song.milliSecondsToTicks(STConfig.node_tracker_rec_latency);
         }
         seqTickNr -= current_pipe_root.pipeDelay;
         st <= getStepNearTime(_pat, seqTickNr, bFuture, null, bStep1);
      }
      else
      {
         st <= steps.get(_seq.ui_cursor_x);
      }

      if(null != st)
      {
         float modVal;

         if(_bAllowRpnCtl)
         {
            float rpnVal;

            // Mod 1 via RPN 100..115
            rpnVal = _frame.getFilteredRPN(_fltDevIdx, _fltCh, rpnNr + 0);

            // if(4 == track_nr)
            // trace "xxx rpn["+rpnNr+"] val="+rpnVal+" fltDev="+_fltDevIdx+" fltCh="+_fltCh;

            if(-1 != rpnVal)
            {
               // trace "xxx rpnVal="+rpnVal+" _bAllowRec="+_bAllowRec;

               modVal = rpnVal * (127.0 / 16383.0);

               if(_bAllowRec)
               {
                  st.mod1 = modVal;
                  _seq.b_redraw_queued = true;
                  // trace "xxx rec mod1 rpnVal="+rpnVal+" modVal="+modVal;
               }

               playMod(_framePlay,
                       _seq,
                       _pat,
                       trackState,
                       mod1_type,
                       mathLerpf(mod1_min, mod1_max, modVal / 127.0)
                       );
            }

            // Mod 2 via RPN 116..131
            rpnVal = _frame.getFilteredRPN(_fltDevIdx, _fltCh, rpnNr + 16);

            // // if(4 == track_nr)
            // //    trace "xxx rpn["+(rpnNr+16)+"] val="+rpnVal+" fltDev="+_fltDevIdx+" fltCh="+_fltCh;

            if(-1 != rpnVal)
            {
               modVal = rpnVal * (127.0 / 16383.0);

               if(_bAllowRec)
               {
                  st.mod2 = modVal;
                  _seq.b_redraw_queued = true;
                  // trace "xxx rec mod2 rpnVal="+rpnVal+" modVal="+modVal;
               }

               playMod(_framePlay, _seq, _pat, trackState, mod2_type,
                       mathLerpf(mod1_min, mod1_max, modVal / 127.0)
                       );
               // trace "xxx playMOd: modVal="+modVal;
            }
         } // if _bAllowRpnCtl

         // Mod via unmapped ctl output
         if(_bAllowModOutUnmap)
         {
            MIDIPipeEvent pev;
            int evIdx = 0;
            int modOutDevIdx = getModOutDevIdx(_seq);
            int modOutCh = getModOutCh(_seq, _pat);
            // // loop(_frame.getNumEventsByFlt(_fltDevIdx, _fltCh))
            loop(_frame.getNumEventsByFlt(modOutDevIdx, modOutCh))
            {
               // // _frame.getEventByIdxAndFlt(evIdx, pev, -1/*fltType*/, _fltDevIdx, _fltCh);
               _frame.getEventByIdxAndFlt(evIdx, pev, -1/*fltType*/, modOutDevIdx, modOutCh);

               // Mod 1
               modVal = unmapPipeEventValue(mod1_type, mod1_min, mod1_max, pev);
               if(modVal >= 0)
               {
                  if(_bAllowRec)
                  {
                     st.mod1 = modVal;
                     _seq.b_redraw_queued = true;
                     // trace "xxx rec mod1 modVal="+modVal+" fltCh="+_fltCh+" pev.midiCh="+pev.midiCh+" track_nr="+track_nr;
                  }

                  playMod(_framePlay, _seq, _pat, trackState, mod1_type,
                          mathLerpf(mod1_min, mod1_max, modVal / 127.0)
                          );
               }

               // Mod 2
               modVal = unmapPipeEventValue(mod2_type, mod2_min, mod2_max, pev);
               if(modVal >= 0)
               {
                  if(_bAllowRec)
                  {
                     st.mod2 = modVal;
                     _seq.b_redraw_queued = true;
                     // trace "xxx rec mod2 modVal="+modVal;
                  }

                  playMod(_framePlay, _seq, _pat, trackState, mod2_type,
                          mathLerpf(mod2_min, mod2_max, modVal / 127.0)
                          );
               }

               evIdx++;
            }
         }

      } // if st
   }

   // <replay.png>
   public method playMod(MIDIPipeFrame    _frame,
                         NodeTrigSeq      _seq,
                         NTS_Pattern      _pat,
                         NTS_TrackState   _trackState,
                         MIDIMapEventType _evType,
                         float            _modVal
                         ) {
      // (note) modVal is in range 0..127 (or 0..16383 in case of (N)RPNs and pitchbend)
      int outDevIdx = getModOutDevIdx(_seq);
      int outMidiCh = getModOutCh(_seq, _pat);

      switch(_evType.type)
      {
         case MIDIMapDefs.TYPE_POLY_PRESSURE:
            if(_trackState.last_note >= 0)
            {
               _modVal = mathClampf(_modVal, 0.0f, 127.0f);
               _frame.polyPressure(true/*bSet*/, outDevIdx, outMidiCh, _trackState.last_note, _modVal);
            }
            break;

         case MIDIMapDefs.TYPE_CC:
            _modVal = mathClampf(_modVal, 0.0f, 127.0f);
            // trace "xxx CC modVal="+_modVal+" outMidiCh="+outMidiCh;
            _frame.cc(true/*bSet*/, outDevIdx, outMidiCh, _evType.ext_type/*ccNr*/, _modVal);
            break;

         case MIDIMapDefs.TYPE_PROGRAM_CHANGE:
            _modVal = mathClampf(_modVal, 0.0f, 127.0f);
            _frame.prgChg(true/*bSet*/, outDevIdx, outMidiCh, _modVal);
            break;

         case MIDIMapDefs.TYPE_CHANNEL_PRESSURE:
            _modVal = mathClampf(_modVal, 0.0f, 127.0f);
            _frame.chPressure(true/*bSet*/, outDevIdx, outMidiCh, _modVal);
            break;

         case MIDIMapDefs.TYPE_PITCHBEND:
            _modVal = mathClampf(_modVal, 0.0f, 16383.0f);
            _frame.pitchbend(true/*bSet*/, outDevIdx, outMidiCh,
                             // // (_modVal < 64.0) ? (8192.0*(_modVal/64.0)) : (8191.0*(_modVal/63.0))
                             _modVal
                             );
            break;

         case MIDIMapDefs.TYPE_RPN:
            _modVal = mathClampf(_modVal, 0.0f, 16383.0f);
            _frame.rpn(true/*bSet*/, outDevIdx, outMidiCh, _evType.ext_type/*rpn*/, _modVal);
            break;

         case MIDIMapDefs.TYPE_NRPN:
            _modVal = mathClampf(_modVal, 0.0f, 16383.0f);
            _frame.nrpn(true/*bSet*/, outDevIdx, outMidiCh, _evType.ext_type/*nrpn*/, _modVal);
            break;

         case MIDIMapDefs.TYPEX_NOTE_NUMBER:
         case MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL:
         case MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD:
         case MIDIMapDefs.TYPEX_NOTE_DURATION:
            // handled in playStepArgs()
            break;
      }
   }

   // <method.png>
   public static CalcJitter(float _val, float _amount) : float {
      _amount = mathClampf(_amount, -1.0, 1.0);
      if(_amount < 0)
         return _val - rand(_val * -_amount);
      else
         return _val + rand(2.0 * _val * _amount) - _val * _amount;
   }

   // <replay.png>
   public method playStepArgs(MIDIPipeFrame _frame,
                              NodeTrigSeq   _seq,
                              NTS_Pattern   _pat,
                              float         _arg1,
                              float         _arg2,
                              boolean       _bInfOnOff,
                              boolean       _bStep1,
                              float         _mod1,
                              float         _mod2,
                              boolean       _bLerpMod1,
                              boolean       _bLerpMod2,
                              int           _slideDist,
                              boolean       _bPlayMod
                              ) {
      int outDevIdx = getOutDevIdx(_seq);

      NTS_TrackState trackState <= _seq.getTrackStateByIndex(track_nr);

      trackState.repeat_start_last_arg1 = _arg1; // Remember for repeat
      trackState.repeat_start_last_arg2 = _arg2;

      trackState.repeat_start_last_mod1 = _mod1; // Remember for repeat
      trackState.repeat_start_last_mod2 = _mod2;

      // trace "xxx playStepArgs: outDevIdx="+outDevIdx+" b_forced_out="+b_forced_out+" forced_out_ch="+forced_out_ch;

      // Used by Linnstrument plugin to highlight active tracks
      trackState.handleTrigReplay();

      if(trackState.isMuted())  // muted via auto a/b ?
         return;

      byte vel;
      float dur;
      byte outCh;
      float note;
      float pb;

      byte outputMode = (-1 != forced_output_mode) ? forced_output_mode : _seq.output_mode;

      float velJitter;

      if(false != _bInfOnOff)
      {
         current_microtime_jitter = (rand(2.0) - 1.0) * mathClampf(microtime_jitter + _pat.microtime_jitter_offset, 0.0, 1.0);
         // trace "xxx randomize: current_microtime_jitter="+current_microtime_jitter+" max="+microtime_jitter+" xxx="+(rand(2.0) - 1.0);
      }

      float mod1Val;
      float mod2Val;

      if((_mod1 >= 0) && (-1 != mod1_type.type))
      {
         mod1Val =
            _bLerpMod1
            ? mathLerpf(mod1_min, mod1_max,
                        mathClampf(CalcJitter(_mod1, _pat.mod1_jitter_offset + mod1_jitter), 0.0f, 127.0f) / 127.0f
                        )
            : _mod1
            ;
         playMod(_frame, _seq, _pat, trackState, mod1_type, mod1Val);
      }
      else
         mod1Val = NodeTrigSeq.INVALID_VALUE;

      if((_mod2 >= 0) && (-1 != mod2_type.type))
      {
         mod2Val =
            _bLerpMod2
            ? mathLerpf(mod2_min, mod2_max,
                        mathClampf(CalcJitter(_mod2, _pat.mod2_jitter_offset + mod2_jitter), 0.0f, 127.0f) / 127.0f
                        )
            : _mod2
            ;
         playMod(_frame, _seq, _pat, trackState, mod2_type, mod2Val);
      }
      else
         mod2Val = NodeTrigSeq.INVALID_VALUE;

      switch(outputMode)
      {
         case NodeTrigSeq.OUT_SINGLECH_NOTE:
            if(false == _bInfOnOff)
            {
               _frame.noteOff(true/*bset*/, outDevIdx,
                              b_forced_out ? forced_out_ch : _seq.out_ch,
                              trackState.last_note,
                              0/*vel*/
                              );
            }
            else
            {
               // Velocity
               vel = velocities.winLinear(mathClampf(_arg1, 0.0f, 3.0f))/*vel*/;
               if(mod1Val > NodeTrigSeq.INVALID_VALUE)
               {
                  if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod1_type.type)
                  {
                     vel *= mod1Val / 127.0;
                  }
                  else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod1_type.type)
                  {
                     vel += mod1Val;
                  }
               }
               if(mod2Val > NodeTrigSeq.INVALID_VALUE)
               {
                  if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod2_type.type)
                  {
                     vel *= mod2Val / 127.0;
                  }
                  else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod2_type.type)
                  {
                     vel += mod2Val;
                  }
               }
               vel = CalcJitter(vel, _pat.velocity_jitter_offset + velocity_jitter);
               vel = mathClampf(vel * _seq.rpn_com_vel_scl * trackState.rpn_vel_scl * (_seq.rpn_com_vel_scl_track.get(track_nr)) + _seq.rpn_com_vel_off,
                                1,
                                127
                                );

               // Duration
               dur = (_arg2 >= 1) ? _arg2 : (default_note_duration_ticks + _pat.default_note_duration_offset);
               if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod1_type.type))
               {
                  dur += mod1Val;
               }
               if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod2_type.type))
               {
                  dur += mod2Val;
               }
               dur = dur * _seq.rpn_com_dur_scl * trackState.rpn_dur_scl * (_seq.rpn_com_dur_scl_track.get(track_nr)) + _seq.rpn_com_dur_off;
               if(dur < 1)
                  dur = 1;

               // Note
               note = (arg3 + _pat.arg3_offset) + _seq.rpn_com_transpose;
               if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod1_type.type))
               {
                  note += mod1Val;
               }
               if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod2_type.type))
               {
                  note += mod2Val;
               }
               note = mathClampf(note, 0, 127);
               if(_pat.pitchbend_range_up > 0)
               {
                  pb = frac(note) / _pat.pitchbend_range_up;
                  pb *= 8191;
                  pb += 8192;
                  _frame.pitchbend(true/*bSet*/, outDevIdx,
                                   b_forced_out ? forced_out_ch : _seq.out_ch,
                                   pb
                                   );
               }
               // trace "xxx trigseq frame note on note="+note+" vel="+vel;
               _frame.noteOn(true/*bset*/, outDevIdx,
                             b_forced_out ? forced_out_ch : _seq.out_ch,
                             note,
                             vel,
                             (true == _bInfOnOff) ? 0 : dur/*dur*/
                             );
               trackState.last_note = note;
            }
            break;

         case NodeTrigSeq.OUT_SINGLECH_NOTE_PROBABILITY:
            if(false == _bInfOnOff)
            {
               _frame.noteOff(true/*bset*/, outDevIdx,
                              b_forced_out ? forced_out_ch : _seq.out_ch,
                              trackState.last_note,
                              0/*vel*/
                              );
            }
            else
            {
               boolean bRandPlay = (_arg2 < 0);
               if(!bRandPlay)
               {
                  bRandPlay = Utils.RollTheDice(_arg2);////(mathClampf(_arg2, 0, 100) > (100 - rand(100 + 1)));
               }

               if(bRandPlay)
               {
                  // Velocity
                  vel = velocities.winLinear(mathClampf(_arg1, 0.0f, 3.0f))/*vel*/;
                  if(mod1Val > NodeTrigSeq.INVALID_VALUE)
                  {
                     if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod1_type.type)
                     {
                        vel *= mod1Val / 127.0;
                     }
                     else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod1_type.type)
                     {
                        vel += mod1Val;
                     }
                  }
                  if(mod2Val > NodeTrigSeq.INVALID_VALUE)
                  {
                     if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod2_type.type)
                     {
                        vel *= mod2Val / 127.0;
                     }
                     else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod2_type.type)
                     {
                        vel += mod2Val;
                     }
                  }
                  vel = CalcJitter(vel, _pat.velocity_jitter_offset + velocity_jitter);
                  vel = mathClampf(vel * _seq.rpn_com_vel_scl * trackState.rpn_vel_scl * (_seq.rpn_com_vel_scl_track.get(track_nr)) + _seq.rpn_com_vel_off,
                                   1,
                                   127
                                   );

                  // Duration
                  dur = default_note_duration_ticks + _pat.default_note_duration_offset;
                  if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod1_type.type))
                  {
                     dur += mod1Val;
                  }
                  if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod2_type.type))
                  {
                     dur += mod2Val;
                  }
                  dur = dur * _seq.rpn_com_dur_scl * trackState.rpn_dur_scl * (_seq.rpn_com_dur_scl_track.get(track_nr)) + _seq.rpn_com_dur_off;
                  if(dur < 1)
                     dur = 1;

                  // Note
                  note = (arg3 + _pat.arg3_offset) + _seq.rpn_com_transpose;
                  if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod1_type.type))
                  {
                     note += mod1Val;
                  }
                  if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod2_type.type))
                  {
                     note += mod2Val;
                  }
                  note = mathClampf(note, 0, 127);
                  if(_pat.pitchbend_range_up > 0)
                  {
                     pb = frac(note) / _pat.pitchbend_range_up;
                     pb *= 8191;
                     pb += 8192;
                     _frame.pitchbend(true/*bSet*/, outDevIdx,
                                      b_forced_out ? forced_out_ch : _seq.out_ch,
                                      pb
                                      );
                  }
                  _frame.noteOn(true/*bset*/, outDevIdx,
                                b_forced_out ? forced_out_ch : _seq.out_ch,
                                note,
                                vel,
                                (true == _bInfOnOff) ? 0 : dur/*dur*/
                                );
                  trackState.last_note = note;
               }
            }
            break;

         case NodeTrigSeq.OUT_MULTICH_NOTE:
            if(false == _bInfOnOff)
            {
               _frame.noteOff(true/*bset*/, outDevIdx,
                              b_forced_out ? forced_out_ch : (_seq.out_ch + track_nr),
                              trackState.last_note,
                              0/*vel*/
                              );
            }
            else
            {
               // Velocity
               vel = velocities.winLinear(mathClampf(_arg1, 0.0f, 3.0f))/*vel*/;
               if(mod1Val > NodeTrigSeq.INVALID_VALUE)
               {
                  if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod1_type.type)
                  {
                     vel *= mod1Val / 127.0;
                  }
                  else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod1_type.type)
                  {
                     vel += mod1Val;
                  }
               }
               if(mod2Val > NodeTrigSeq.INVALID_VALUE)
               {
                  if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod2_type.type)
                  {
                     vel *= mod2Val / 127.0;
                  }
                  else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod2_type.type)
                  {
                     vel += mod2Val;
                  }
               }
               vel = CalcJitter(vel, _pat.velocity_jitter_offset + velocity_jitter);
               vel = mathClampf(vel * _seq.rpn_com_vel_scl * trackState.rpn_vel_scl * (_seq.rpn_com_vel_scl_track.get(track_nr)) + _seq.rpn_com_vel_off,
                                0,
                                127
                                );

               // Duration
               dur = (_arg2 >= 1) ? _arg2 : (default_note_duration_ticks + _pat.default_note_duration_offset);
               if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod1_type.type))
               {
                  dur += mod1Val;
               }
               if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod2_type.type))
               {
                  dur += mod2Val;
               }
               dur = dur * _seq.rpn_com_dur_scl * trackState.rpn_dur_scl * (_seq.rpn_com_dur_scl_track.get(track_nr)) + _seq.rpn_com_dur_off;
               if(dur < 1)
                  dur = 1;

               // Note
               note = (arg3 + _pat.arg3_offset) + _seq.rpn_com_transpose;
               if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod1_type.type))
               {
                  note += mod1Val;
               }
               if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod2_type.type))
               {
                  note += mod2Val;
               }
               note = mathClampf(note, 0, 127);
               if(_pat.pitchbend_range_up > 0)
               {
                  pb = frac(note) / _pat.pitchbend_range_up;
                  pb *= 8191;
                  pb += 8192;
                  _frame.pitchbend(true/*bSet*/, outDevIdx,
                                   b_forced_out ? forced_out_ch : _seq.out_ch,
                                   pb
                                   );
               }
               _frame.noteOn(true/*bset*/, outDevIdx,
                             b_forced_out ? forced_out_ch : (_seq.out_ch + track_nr),
                             note,
                             vel,
                             (true == _bInfOnOff) ? 0 : dur/*dur*/
                             );
               trackState.last_note = note;
            }
            break;

         case NodeTrigSeq.OUT_SINGLECH_MUTE_TEMP:
            _frame.rpn(true/*bSet*/, outDevIdx,
                       b_forced_out ? forced_out_ch : ((arg3 + _pat.arg3_offset)&15)/*ch*/,
                       (int(_arg1) < 2) ? Node.RPN_COMMON_MUTE_TEMP :
                       Node.RPN_COMMON_MUTE_TEMP_TOGGLE,
                       (0 == int(_arg1)) ? 0 : 1
                       );
            break;

         case NodeTrigSeq.OUT_SINGLECH_PAT_CHG_OFF_RUN:
            // - arg1: controls RPN_COMMON_RUN (0=keep, 1=true, 2=false)
            // - arg2 is optional pattern offset (RPN_COMMON_OFFSET)
            //    - optional. not set = do not send offset
            // - arg3 is pattern nr
            _frame.prgChg(true/*bSet*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          ((arg3 + _pat.arg3_offset)&127)
                          );
            if(int(_arg1) > 0)
            {
               _frame.rpn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          Node.RPN_COMMON_RUN,
                          (1 == int(_arg1)) ? 1 : 0
                          );
            }
            if(_arg2 >= 0)
               _frame.rpn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          Node.RPN_COMMON_SEEK_OFFSET,
                          _arg2&16383
                          );
            break;

         case NodeTrigSeq.OUT_SINGLECH_PAT_OFF_RUN:
            // - arg1: controls RPN_COMMON_RUN (0=keep, 1=true, 2=false)
            // - arg2 is optional pattern offset (RPN_COMMON_OFFSET)
            //    - optional. not set = use arg3
            // - arg3 is default pattern offset (RPN_COMMON_OFFSET)
            if(int(_arg1) > 0)
            {
               _frame.rpn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          Node.RPN_COMMON_RUN,
                          (1 == int(_arg1)) ? 1 : 0
                          );
            }
            if(_arg2 >= 0)
               _frame.rpn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          Node.RPN_COMMON_SEEK_OFFSET,
                          _arg2
                          );
            else
               _frame.rpn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          Node.RPN_COMMON_SEEK_OFFSET,
                          (arg3 + _pat.arg3_offset)&16383
                          );
            break;

         case NodeTrigSeq.OUT_PAT_CHG_OFF:
            // - arg1 is trigger type (0=dont' send offset, 1=send offset)
            // - arg2 is offset (default=0)
            // - arg3 is pattern nr (PrgChg)
            _frame.prgChg(true/*bSet*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          ((arg3 + _pat.arg3_offset)&127)
                          );
            if(int(_arg1) > 0)
            {
               _frame.rpn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          Node.RPN_COMMON_SEEK_OFFSET,
                          mathClampi((_arg2 > 0) ? _arg2 : 0, 0, 16383)
                          );
            }
            break;

         case NodeTrigSeq.OUT_SINGLETRACK_POLYSTEP:
            // - tracknr is poly index
            // - arg1 is additional poly step offset (+0, +1, +2, +3)
            // - arg2 is optional poly step offset
            // - arg3 is poly step index (0..n)
            _frame.rpn(true/*bset*/, outDevIdx,
                       b_forced_out ? forced_out_ch : _seq.out_ch,
                       Node.RPN_COMMON_POLY_STEP_1 + track_nr/*st.grid_y*/,
                       mathClampi(arg3 + _pat.arg3_offset + int(_arg1) + ((_arg2 > 0)?_arg2:0), 0, 16383)
                       );
            break;

         case NodeTrigSeq.OUT_MULTITRACK_POLYSTEP:
            // - tracknr is poly index
            // - arg1 is poly step index (0, 1, 2, 3)
            // - arg2 is additional poly step offset
            // - arg3 is poly track index (0..15)
            _frame.rpn(true/*bset*/, outDevIdx,
                       b_forced_out ? forced_out_ch : _seq.out_ch,
                       Node.RPN_COMMON_POLY_TRACK_1 + track_nr,
                       mathClampi(arg3 + _pat.arg3_offset, 0, 15)
                       );

            _frame.rpn(true/*bset*/, outDevIdx,
                       b_forced_out ? forced_out_ch : _seq.out_ch,
                       Node.RPN_COMMON_POLY_STEP_1 + track_nr,
                       mathClampi(int(_arg1) + ((_arg2 > 0)?_arg2:0), 0, 16383)
                       );
            break;

         case NodeTrigSeq.OUT_MULTITRACK_POLYSTEP4:
            // - tracknr is poly index
            // - arg1 is poly step index (0, 1, 2, 3)
            // - arg2 is additional poly step offset
            // - (arg3 / 4) is poly track index (0..3), (arg3 % 4) is poly step offset * 4
            //
            // (note) divides tracks into 4 groups, each group addresses up to 16 steps (0,4,8,12 via tracknr, +0..+3 via arg1/velocity)
            //
            _frame.rpn(true/*bset*/, outDevIdx,
                       b_forced_out ? forced_out_ch : _seq.out_ch,
                       Node.RPN_COMMON_POLY_TRACK_1 + track_nr,
                       mathClampi((arg3 + _pat.arg3_offset)/4, 0, 15)
                       );

            _frame.rpn(true/*bset*/, outDevIdx,
                       b_forced_out ? forced_out_ch : _seq.out_ch,
                       Node.RPN_COMMON_POLY_STEP_1 + track_nr,
                       mathClampi(int(_arg1) + ((_arg2 > 0)?_arg2:0) + ((arg3%4)*4), 0, 16383)
                       );
            break;

         case NodeTrigSeq.OUT_MULTICH_CLOCKGATE:
            _frame.rpn(true/*bSet*/, outDevIdx,
                       b_forced_out ? forced_out_ch : ((arg3 + _pat.arg3_offset)&15)/*ch*/,
                       (0 == int(_arg1)) ? Node.RPN_COMMON_CLOCKGATE :
                       (1 == int(_arg1)) ? Node.RPN_COMMON_CLOCK :
                       (2 == int(_arg1)) ? Node.RPN_COMMON_GATE :
                       Node.RPN_COMMON_RETRIG,
                       1
                       );
            break;

         case NodeTrigSeq.OUT_MULTICH_CLOCKGATE_PAT_CHG_OFF:
            // - arg1 is trigger type (0=send offset 0, 1=send offset 1, 2=send offset 2, 3=don't send offset)
            // - arg2 is optional pattern nr (PrgChg)
            // - arg3 is channel nr
            if(_arg2 >= 0)
            {
               _frame.prgChg(true/*bSet*/, outDevIdx,
                             b_forced_out ? forced_out_ch : ((arg3 + _pat.arg3_offset)&15),
                             _arg2 & 127
                             );
            }

            if(3 != int(_arg1))
            {
               _frame.rpn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : ((arg3 + _pat.arg3_offset)&15),
                          Node.RPN_COMMON_SEEK_OFFSET,
                          int(_arg1)
                          );
            }
            break;

         case NodeTrigSeq.OUT_MULTICH_GATE_SEEK_REL_RESET:
            if(_bStep1)
            {
               // trace "xxx NodeTrigSeq: is step 1";
               _frame.rpn(true/*bSet*/, outDevIdx,
                          b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15)/*ch*/,
                          Node.RPN_COMMON_RESET,
                          1
                          );
            }
            // Run into next case

         case NodeTrigSeq.OUT_MULTICH_GATE_SEEK_REL:

            vel = velocities.winLinear(mathClampf(_arg1, 0.0f, 3.0f))/*vel*/;

            // trace "xxx NodeTrigSeq: play step";

            _frame.rpn(true/*bSet*/, outDevIdx,
                       b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15)/*ch*/,
                       Node.RPN_COMMON_VELOCITY_SCL,
                       vel
                       );

            _frame.rpn(true/*bSet*/, outDevIdx,
                       b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15)/*ch*/,
                       NodeMonitor.RPN_COMMON_GATE,
                       (_arg2 > 0) ? (
                          (128 == _arg2) ? 1 : (
                             (_arg2 > 128) ? (_arg2 - 128) : _arg2
                                                )
                                      )
                       : 1
                       );

            _frame.rpn(true/*bSet*/, outDevIdx,
                       b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15)/*ch*/,
                       NodeMonitor.RPN_COMMON_SEEK_REL_POST,
                       (_arg2 > 0) ? _arg2 : 1
                       );
            break;

         case NodeTrigSeq.OUT_MULTICH_DRUMPADSELECT:

            if(false == _bInfOnOff)
            {
               // trace "xxx DRUMPADSELECT: noteOff ch="+((_seq.out_ch + arg3 + _pat.arg3_offset)&15);
               _frame.noteOff(true/*bset*/, outDevIdx,
                              b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15),
                              12*4/*c-4*/,
                              0/*vel*/
                              );
            }
            else
            {
               // Velocity
               vel = velocities.winLinear(mathClampf(_arg1, 0.0f, 3.0f))/*vel*/;
               if(mod1Val > NodeTrigSeq.INVALID_VALUE)
               {
                  if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod1_type.type)
                  {
                     vel *= mod1Val / 127.0;
                  }
                  else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod1_type.type)
                  {
                     vel += mod1Val;
                  }
               }
               if(mod2Val > NodeTrigSeq.INVALID_VALUE)
               {
                  if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod2_type.type)
                  {
                     vel *= mod2Val / 127.0;
                  }
                  else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod2_type.type)
                  {
                     vel += mod2Val;
                  }
               }
               vel = CalcJitter(vel, _pat.velocity_jitter_offset + velocity_jitter);
               vel = mathClampf(vel * _seq.rpn_com_vel_scl * trackState.rpn_vel_scl * (_seq.rpn_com_vel_scl_track.get(track_nr)) + _seq.rpn_com_vel_off,
                                1,
                                127
                                );

               // Duration
               dur = (_arg2 >= 1) ? _arg2 : (default_note_duration_ticks + _pat.default_note_duration_offset);
               dur = dur * _seq.rpn_com_dur_scl * trackState.rpn_dur_scl * (_seq.rpn_com_dur_scl_track.get(track_nr)) + _seq.rpn_com_dur_off;
               if(dur < 1)
                  dur = 1;

               note = 12*4/*c-4*/;
               _frame.noteOn(true/*bset*/, outDevIdx,
                             b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15),
                             note,
                             vel,
                             (true == _bInfOnOff) ? 0 : dur/*dur*/
                             );
               trackState.last_note = note;
            }

            _frame.rpn(true/*bSet*/, outDevIdx,
                       b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15)/*ch*/,
                       Node.RPN_PRE_DRUMPADSELECT,
                       1 + (b_forced_out ? forced_out_ch : ((_seq.out_ch + arg3 + _pat.arg3_offset)&15))
                       );

            break;

         case NodeTrigSeq.OUT_CHROMATIC:
            // arg2=note number (relative to arg3)

            // Velocity
            vel = velocities.winLinear(mathClampf(_arg1, 0.0f, 3.0f))/*vel*/;
            if(mod1Val > NodeTrigSeq.INVALID_VALUE)
            {
               if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod1_type.type)
               {
                  vel *= mod1Val / 127.0;
               }
               else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod1_type.type)
               {
                  vel += mod1Val;
               }
            }
            if(mod2Val > NodeTrigSeq.INVALID_VALUE)
            {
               if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod2_type.type)
               {
                  vel *= mod2Val / 127.0;
               }
               else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod2_type.type)
               {
                  vel += mod2Val;
               }
            }
            vel = CalcJitter(vel, _pat.velocity_jitter_offset + velocity_jitter);
            vel = mathClampf(vel * _seq.rpn_com_vel_scl * trackState.rpn_vel_scl * (_seq.rpn_com_vel_scl_track.get(track_nr)) + _seq.rpn_com_vel_off,
                             1,
                             127
                             );

            // Duration
            dur = (default_note_duration_ticks + _pat.default_note_duration_offset);
            if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod1_type.type))
            {
               dur += mod1Val;
            }
            if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod2_type.type))
            {
               dur += mod2Val;
            }
            dur = dur * _seq.rpn_com_dur_scl * trackState.rpn_dur_scl * (_seq.rpn_com_dur_scl_track.get(track_nr)) + _seq.rpn_com_dur_off;
            if(dur < 1)
               dur = 1;

            // Note
            note = mathMaxf(_arg2, 0.0f) + arg3 + _pat.arg3_offset + _seq.rpn_com_transpose;
            if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod1_type.type))
            {
               note += mod1Val;
            }
            if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod2_type.type))
            {
               note += mod2Val;
            }
            note = mathClampf(note, 0, 127);
            // trace "xxx OUT_CHROMATIC: note="+trackState.last_note+" vel="+vel+" dur="+dur;
            if(_pat.pitchbend_range_up > 0)
            {
               pb = frac(note) / _pat.pitchbend_range_up;
               // trace "xxx note="+note+" frac="+pb;
               pb *= 8191;
               pb += 8192;
               // trace "xxx note pb="+pb;
               _frame.pitchbend(true/*bSet*/, outDevIdx,
                                b_forced_out ? forced_out_ch : _seq.out_ch,
                                pb
                                );
            }
            _frame.noteOn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          note,
                          vel,
                          dur
                          );
            trackState.last_note = note;
            break;

         case NodeTrigSeq.OUT_CHROMATIC_MONO:
            // arg1=accent/slide flags
            // arg2=note number (relative to arg3)

            // Velocity
            vel = (int(_arg1) & 2)/*accent*/ ? 127 : 99;
            if(mod1Val > NodeTrigSeq.INVALID_VALUE)
            {
               if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod1_type.type)
               {
                  vel *= mod1Val / 127.0;
               }
               else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod1_type.type)
               {
                  vel += mod1Val;
               }
            }
            if(mod2Val > NodeTrigSeq.INVALID_VALUE)
            {
               if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_MUL == mod2_type.type)
               {
                  vel *= mod2Val / 127.0;
               }
               else if(MIDIMapDefs.TYPEX_NOTE_VELOCITY_ADD == mod2_type.type)
               {
                  vel += mod2Val;
               }
            }
            vel = CalcJitter(vel, _pat.velocity_jitter_offset + velocity_jitter);
            vel = mathClampf(vel * _seq.rpn_com_vel_scl * trackState.rpn_vel_scl * (_seq.rpn_com_vel_scl_track.get(track_nr)) + _seq.rpn_com_vel_off,
                             1,
                             127
                             );

            // Duration
            dur = (default_note_duration_ticks + _pat.default_note_duration_offset);
            if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod1_type.type))
            {
               dur += mod1Val;
            }
            if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_DURATION == mod2_type.type))
            {
               dur += mod2Val;
            }
            dur = dur * _seq.rpn_com_dur_scl * trackState.rpn_dur_scl * (_seq.rpn_com_dur_scl_track.get(track_nr)) + _seq.rpn_com_dur_off;
            if(int(_arg1) & 1) // slide ?
            {
               // Note overlap
               if(dur < (_slideDist * current_step_num_ticks + SLIDE_TICK_DURATION_OVERLAP))
                  dur = _slideDist * current_step_num_ticks + SLIDE_TICK_DURATION_OVERLAP;
            }
            // (note) not clipping to min duration allows other tracks to be used for sliding (via def note dur)
            // // else if(dur >= (_slideDist * current_step_num_ticks))
            // // {
            // //    dur = _slideDist * current_step_num_ticks) - SLIDE_TICK_DURATION_OVERLAP;
            // // }
            if(dur < 1)
               dur = 1;

            // Note
            // trace "xxx OUT_CHROMATIC: note="+trackState.last_note+" vel="+vel+" dur="+dur;
            note = mathMaxf(_arg2, 0.0f) + arg3 + _pat.arg3_offset + _seq.rpn_com_transpose;
            if((mod1Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod1_type.type))
            {
               note += mod1Val;
            }
            if((mod2Val > NodeTrigSeq.INVALID_VALUE) && (MIDIMapDefs.TYPEX_NOTE_NUMBER == mod2_type.type))
            {
               note += mod2Val;
            }
            note = mathClampf(note, 0, 127);
            if(_pat.pitchbend_range_up > 0)
            {
               pb = frac(note) / _pat.pitchbend_range_up;
               pb *= 8191;
               pb += 8192;
               _frame.pitchbend(true/*bSet*/, outDevIdx,
                                b_forced_out ? forced_out_ch : _seq.out_ch,
                                pb
                                );
            }
            _frame.noteOn(true/*bset*/, outDevIdx,
                          b_forced_out ? forced_out_ch : _seq.out_ch,
                          note,
                          vel,
                          dur
                          );
            trackState.last_note = note;
            break;
      }
   }

   // <replay.png>
   protected method playStep(MIDIPipeFrame _frame,
                             NTS_Step       st,
                             NodeTrigSeq   _seq,
                             NTS_Pattern   _pat,
                             boolean       _bStep1,
                             boolean       _bPlayMod
                             ) {
      int outDevIdx = _seq.getOutDevIdx();

      if((-1 != outDevIdx) || b_forced_out)
      {
         // // repeat_start_last_arg1 = st.arg1; // Remember for repeat
         // // repeat_start_last_arg2 = st.arg2;

         NTS_TrackState trackState <= _seq.getTrackStateByIndex(track_nr);

         if(-1 == trackState.current_repeat_ticks)
         {
            playStepArgs(_frame,
                         _seq,
                         _pat,
                         st.arg1,
                         st.arg2,
                         maybe/*bInfOnOff*/,
                         _bStep1,
                         (st.mod1 >= 0) ? st.mod1 : mod1_reset,
                         (st.mod2 >= 0) ? st.mod2 : mod2_reset,
                         (st.mod1 >= 0)/*bLerpMod1*/,
                         (st.mod2 >= 0)/*bLerpMod2*/,
                         st.slide_next_trig_dist_cache,
                         _bPlayMod
                         );
         }
      }
   }

   // <method_get.png>
   protected method getMicrotimeTrackStepTickShift(int _srcStepIdx, float _srcStepNumTicks, NTS_Pattern _pat) : float {

      NTS_Step *st;

      float qAmount = mathClampf(quantization_amount + _pat.quantization_offset, 0.0f, 1.0f);

      if(play_length <= 1)
      {
         st <= steps.get(0);
         return st.microtime * (1.0 - qAmount) + microtime_shift;
      }

      float stepIdx;
      stepIdx = (_srcStepIdx * (_srcStepNumTicks / current_step_num_ticks));

      float fracStep = frac(stepIdx);

      // // stepIdx = _seqTickNr / current_step_num_ticks;  // loop timing track when other track is shorter (==> BUG: skips trigs)

      NTS_Step *stl;
      NTS_Step *str;

      stepIdx = int(stepIdx) % play_length;
      // trace "xxx stepIdx="+stepIdx+" fracStep="+fracStep;

      if(stepIdx == (play_length - 1))
      {
         stl <= steps.get(stepIdx);
         str <= steps.get(0);
      }
      else
      {
         stl <= steps.get(stepIdx);
         str <= steps.get(stepIdx + 1);
      }
      float microTicks = mathLerpf(stl.microtime, str.microtime, fracStep) * (1.0 - qAmount) +  microtime_shift;

      // // st <= steps.get(stepNr);
      // // float microTicks = (st.microtime * current_step_num_ticks) * (1.0 - quant_amount);
      // trace "xxx stepIdx="+stepIdx+" fracStep="+fracStep+" microTicks="+microTicks;

      return microTicks;
   }

   // <replay.png>
   public method tick(MIDIPipeFrame _frame, boolean _bMuted, boolean _bPlaySeq, NodeTrigSeq _seq, NTS_Pattern _pat) {

      // if(_bPlaySeq)
      //    if(_bMuted)
      //       trace "xxx NTS: bMuted=true";

      NTS_TrackState trackState <= _seq.getTrackStateByIndex(track_nr);

      NTS_Step *st;

      if(b_ui_trig_queued_on)
      {
         b_ui_trig_queued_on = false;
         recordOrPlayNoteOn(_frame,
                            _seq,
                            _pat,
                            0/*velIdx arg1*/,
                            1/*pev.duration arg2*/,
                            false/*bAllowRecNote*/,
                            false/*bAllowRecMod*/,
                            NodeTrigSeq.INVALID_VALUE/*mod1*/,
                            NodeTrigSeq.INVALID_VALUE/*mod2*/
                            );
      }
      else if(b_ui_trig_queued_off)
      {
         b_ui_trig_queued_off = false;
         recordOrPlayNoteOff(_frame, _seq, _pat, false/*bAllowRec*/);
      }

      if(-1 != ui_queued_step)
      {
         // (note) always play step, even when muted
         NTS_Step qst <= getStepByIndex(ui_queued_step);
         ui_queued_step = -1;

         if(null != qst)
         {
            // trace "xxx play queued step";
            playStep(_frame, qst, _seq, _pat, true/*bStep1*/, true/*bPlayMod*/);
         }
      }

      if(!b_has_trigs_cache && !trackState.b_queued_repeat && (-1 == trackState.current_repeat_ticks))
      {
         last_played_step = -1;
         last_played_step_mod = -1;
         return;
      }


      _bMuted |= (STATE_MUTE == play_state);

      // // // _bMuted |= b_repeat_mute;

      NTS_Track *microtimeTrack;

      if(-1 != _pat.microtime_track_idx)
      {
         microtimeTrack <= _pat.tracks.get(_pat.microtime_track_idx);
      }
      else
      {
         microtimeTrack <= null;
      }

      if(_bPlaySeq)
      {
         if( (true == trackState.b_quantized_repeat_start_queued) &&
             (0 == (int(_seq.tick_nr) % _seq.repeat_start_quantization_ticks))
             )
         {
            trackState.queueRepeat(_seq,
                                   trackState.b_quantized_repeat_start_queued,
                                   false/*bMayQueue*/
                                   );
            trackState.b_quantized_repeat_start_queued = false;
         }

         boolean bPlayRepeat = false;

         int stepIdx = 0;
         float stepTime = 0.0;
         boolean bStep1 = true;
         boolean bStep1Play = false;

         // if(!_bMuted && (0 == track_nr))
         //    trace "xxx current_step_num_ticks="+current_step_num_ticks;
         float ticksPerTrack = (current_step_num_ticks * play_length);
         float curTickNr = _seq.tick_nr * parent_node.rpn_com_pos_scl;
         float tickCountMod;
         float patMasterLenTicks = 0;
         if(_pat.master_len_16th > 0.0f)
         {
            patMasterLenTicks = current_song.getNumTicksPer16th() * _pat.master_len_16th;
            tickCountMod = curTickNr % patMasterLenTicks;
            tickCountMod = tickCountMod % ticksPerTrack;
            // if(0 == track_nr)
            //    trace "xxx curTickNr="+curTickNr+" patMasterLenTicks="+patMasterLenTicks+" tickCountMod="+tickCountMod;
         }
         else
         {
            tickCountMod = curTickNr % ticksPerTrack;
         }
         // trace "xxx curTickNr="+curTickNr+" rawTicks="+_seq.tick_nr+" tickCountMod="+tickCountMod+" ticksPerTrack="+ticksPerTrack;
         // if(!_bMuted  && (0 == track_nr))
         //    trace "xxx tickCountMod="+tickCountMod;

         int swingShift = (play_length & 1) & int(curTickNr / ticksPerTrack);  // (todo) factor in master_len_16th

         // trace "xxx quantization_amount="+quantization_amount;

         loop(play_length)
         {
            st <= steps.get(stepIdx);

            float qAmount = mathClampf(quantization_amount + _pat.quantization_offset, 0.0f, 1.0f);

            float cStepTime = int(((st.microtime*(1.0 - qAmount) + microtime_shift + current_microtime_jitter) * current_step_num_ticks)); // * 0.5

            if(int(stepIdx + swingShift)&1)
            {
               cStepTime += mathClampf(_pat.swing_offset + swing_amount, -0.5, 0.5) * current_step_num_ticks;
            }

            if(null != microtimeTrack)
            {
               if(_pat.microtime_track_idx != track_nr)
               {
                  // Find timing track microtime
                  int mtAdd = int(microtimeTrack.getMicrotimeTrackStepTickShift(stepIdx,
                                                                                current_step_num_ticks,
                                                                                _pat
                                                                                )
                                  * current_step_num_ticks
                                  );
                  cStepTime += mtAdd;
               }
            }

            cStepTime += stepTime;

            // float xxxOrigcStepTime = cStepTime;
            float cStepTimeShift = 0.0f;

            if(cStepTime < 0.0f)
            {
               if(curTickNr >= current_step_num_ticks)
               {
                  // trace "xxx wrap cStepTime";
                  if(patMasterLenTicks > 0)
                  {
                     //             *              *
                     // 0 1 2 3 4 5 6 7 8 9 10 11 12
                     // 0 1 2 3 4 5 0 1 2 3  4  5  0
                     // 0 1 2 3 0 1 0 1 2 3  0  1  0
                     tickCountMod = (curTickNr - cStepTime) % patMasterLenTicks;
                     tickCountMod = tickCountMod % ticksPerTrack;
                     cStepTimeShift = cStepTime;
                     cStepTime = 0;
                  }
                  else
                  {
                     cStepTime += ticksPerTrack; // first step
                  }
               }
               else
               {
                  // cornercase: first step (shifted ahead of time) after replay start
                  // if(0 == track_nr)
                  //    trace "xxx curTickNr="+curTickNr+" cStepTime="+cStepTime+" stepIdx="+stepIdx;
                  cStepTimeShift = cStepTime;
                  cStepTime = 0;
               }
            }

            // if(!_bMuted && (5 == stepIdx))
            // if(!_bMuted)
            // {
            //    trace "xxx track_nr="+track_nr+" cStepTime="+cStepTime+" tickCountMod="+tickCountMod+" last_played_step="+last_played_step;
            // }

            boolean bAllowMod = (0 == mod_tickshift);

            // Send mod update(s) ahead of time to counter synth parameter smoothing (e.g. Rytm+Cycles)
            if(0 != mod_tickshift)
            {
               boolean bSendMod;

               if(patMasterLenTicks > 0)
               {
                  // (todo) test master_len_16th mod_tickshift
                  float tickCountModCtl = (curTickNr + mod_tickshift - cStepTimeShift) % patMasterLenTicks;
                  tickCountModCtl = tickCountModCtl % ticksPerTrack;
                  bSendMod = int(cStepTime) == int(tickCountModCtl);
               }
               else
               {
                  bSendMod = int((cStepTime + ticksPerTrack - mod_tickshift) % ticksPerTrack) == int(tickCountMod);
               }

               if(bSendMod)
               {
                  if(last_played_step_mod != stepIdx)
                  {
                     last_played_step_mod = stepIdx;

                     // (todo) use same probability for trig and mod
                     //         (difficult though since probability can be modulated externally)
                     if(Utils.RollTheDice(100 * ((_seq.rpn_com_prob_track.get(track_nr)) + _seq.rpn_com_prob_all_rel)))
                     {
                        if!(_bMuted || trackState.b_repeat_mute)
                        {
                           if(st.b_trig || st.b_mod)
                           {
                              if((st.mod1 >= 0) && (-1 != mod1_type.type))
                              {
                                 // trace "xxx bSendMod=1 tick_nr="+_seq.tick_nr+" track#="+(track_nr+1)+" mod_tickshift="+mod_tickshift+" st.mod1="+st.mod1;
                                 playMod(_frame, _seq, _pat, trackState, mod1_type, mathLerpf(mod1_min, mod1_max, st.mod1 / 127.0f));
                              }

                              if((st.mod2 >= 0) && (-1 != mod2_type.type))
                              {
                                 playMod(_frame, _seq, _pat, trackState, mod2_type, mathLerpf(mod2_min, mod2_max, st.mod2 / 127.0f));
                              }
                           }
                        }
                     }
                  }
               }
            }

            // if(0 == track_nr && 0 == stepIdx)
            //    trace "xxx mlen="+patMasterLenTicks+" tlen="+ticksPerTrack+" curTickNr="+curTickNr+" ocstep="+xxxOrigcStepTime+" compare cStepTime="+int(cStepTime)+" == "+int(tickCountMod)+((int(cStepTime) == int(tickCountMod))?"**************":"");

            if(int(cStepTime) == int(tickCountMod))
            {
               // if(st.b_trig) trace "xxx try playstep, last_played_step="+last_played_step+" stepIdx="+stepIdx;
               if(last_played_step != stepIdx)
               {
                  last_played_step = stepIdx;

                  bAllowMod |= (last_played_step_mod != last_played_step);  // first tick after replay start

                  if(bAllowMod)
                     last_played_step_mod = stepIdx;

                  if(Utils.RollTheDice(100 * ((_seq.rpn_com_prob_track.get(track_nr)) + _seq.rpn_com_prob_all_rel)))
                  {
                     // if(!_bMuted)
                     //    trace "xxx try playstep2 stepIdx="+stepIdx+" cStepTime="+cStepTime+" st.b_trig="+st.b_trig;
                     bStep1Play |= bStep1;

                     trackState.b_trig_state = st.b_trig;

                     if(st.b_mod || st.b_repeat)
                     {
                        if(st.mod1 >= 0)
                        {
                           trackState.repeat_start_last_mod1 = st.mod1;
                           trackState.repeat_last_mod1       = st.mod1;
                        }

                        if(st.mod2 >= 0)
                        {
                           trackState.repeat_start_last_mod2 = st.mod2;
                           trackState.repeat_last_mod2       = st.mod2;
                        }
                     }

                     if(st.b_mod && !(st.b_repeat || st.b_trig))
                     {
                        // Turn off repeat
                        trackState.current_repeat_ticks = -1;
                     }

                     if(st.b_trig && trackState.b_repeat_auto_off)
                     {
                        trackState.b_repeat_auto_off = false;
                        trackState.current_repeat_ticks = -1;
                     }

                     if( (maybe == trackState.b_quantized_repeat_start_queued) &&
                         (0 == (int(curTickNr) % _seq.repeat_start_quantization_ticks))
                         )
                     {
                        trackState.queueRepeat(_seq,
                                               trackState.b_quantized_repeat_start_queued,
                                               false/*bMayQueue*/
                                               );
                        trackState.b_quantized_repeat_start_queued = false;
                     }

                     // Play step
                     // trace "xxx try playstep3: bMuted="+_bMuted+" b_repeat_mute+"+b_repeat_mute;
                     if!(_bMuted || trackState.b_repeat_mute)
                     {
                        if(st.b_trig)
                        {
                           // trace "xxx nts: play step tick_nr="+_seq.tick_nr+" track#="+(track_nr+1);
                           if(-1 == rec_note_on_ticks)
                           {
                              playStep(_frame, st, _seq, _pat, bStep1Play, bAllowMod);
                           }
                        }
                        else if(st.b_mod && bAllowMod)
                        {
                           // Trig-less step, Just send mod update(s)
                           if((st.mod1 >= 0) && (-1 != mod1_type.type))
                           {
                              playMod(_frame, _seq, _pat, trackState, mod1_type, mathLerpf(mod1_min, mod1_max, st.mod1 / 127.0f));
                           }

                           if((st.mod2 >= 0) && (-1 != mod2_type.type))
                           {
                              playMod(_frame, _seq, _pat, trackState, mod2_type, mathLerpf(mod2_min, mod2_max, st.mod2 / 127.0f));
                           }
                        }
                     }
                     else if(st.b_trig)
                        trackState.handleTrigReplay();

                     if((st.b_repeat && -1 == trackState.current_repeat_ticks) ||
                        (
                           ((true == trackState.b_queued_repeat) || (trackState.b_trig_state && (maybe == trackState.b_queued_repeat))) &&
                           ((NodeTrigSeq.REPEAT_START_SYNC_STEP == _seq.repeat_start_mode) ||
                            (st.b_trig && (NodeTrigSeq.REPEAT_START_SYNC_TRIG == _seq.repeat_start_mode)) ||
                            ((NodeTrigSeq.REPEAT_START_SYNC_NOTELEN == _seq.repeat_start_mode) && (0 == (int(curTickNr) % current_repeat_num_ticks)))
                            )
                         )
                        )
                     {
                        // trace "xxx handle queued repeat";
                        trackState.b_queued_repeat = false;
                        trackState.b_quantized_repeat_start_queued = false;
                        bPlayRepeat = true;
                        trackState.current_repeat_ticks = 0;
                        trackState.current_repeat_count = 0;
                        trackState.repeat_last_arg1 = trackState.repeat_start_last_arg1;
                        trackState.repeat_last_arg2 = trackState.repeat_start_last_arg2;
                        trackState.repeat_last_mod1 = trackState.repeat_start_last_mod1;
                        trackState.repeat_last_mod2 = trackState.repeat_start_last_mod2;
                        // // current_repeat_tick_shift = (swing_amount * current_step_num_ticks);
                        trackState.b_repeat_auto_off = st.b_repeat;

                        if(st.b_repeat)
                        {
                           // Always use track settings for repeat (may have been overwritten by global repeat)
                           calcCurrentRepeatNumTicks();
                           current_num_repeats = num_repeats;
                           trackState.repeat_tick_shift = 0;
                        }
                     }

                  } // if Utils.RollTheDice()
               } // last_played != stepIdx
            } // if steptime match

            // Try next step
            stepIdx++;
            stepTime += current_step_num_ticks;
            bStep1 = false;
         } // loop steps

         if( (maybe == trackState.b_quantized_repeat_start_queued) &&
             (0 == (int(curTickNr) % _seq.repeat_start_quantization_ticks))
             )
         {
            trackState.queueRepeat(_seq,
                                   trackState.b_quantized_repeat_start_queued,
                                   false/*bMayQueue*/
                                   );
            trackState.b_quantized_repeat_start_queued = false;
         }

         if(((true == trackState.b_queued_repeat) || (trackState.b_trig_state && (maybe == trackState.b_queued_repeat))) &&
            ((NodeTrigSeq.REPEAT_START_IMMEDIATELY == _seq.repeat_start_mode) ||
             ((NodeTrigSeq.REPEAT_START_SYNC_NOTELEN == _seq.repeat_start_mode) &&
              (0 == (int(curTickNr) % current_repeat_num_ticks))
              )
             )
            )
         {
            trackState.b_queued_repeat = false;
            bPlayRepeat = true;
            trackState.current_repeat_ticks = 0;
            trackState.current_repeat_count = 0;
            // // current_repeat_tick_shift = 0;
            // trace "xxx handle queued repeat 2";
            if(-1 == trackState.repeat_last_arg1)
               trackState.repeat_last_arg1 = 0.0f;  // track with no trigs
         }

         if(-1 != trackState.current_repeat_ticks)
         {
            bPlayRepeat = (0 == ((trackState.current_repeat_ticks++ + trackState.repeat_tick_shift) % current_repeat_num_ticks));
         }

         // Play repeat
         if(bPlayRepeat && !(_bMuted || trackState.b_repeat_mute))
         {
            if(-1 != trackState.repeat_last_arg1)
            {
               // trace "xxx play repeat rec_note_on_ticks="+rec_note_on_ticks;

               if(-1 == rec_note_on_ticks)
               {
                  if(Utils.RollTheDice(100 * ((_seq.rpn_com_prob_track.get(track_nr)) + _seq.rpn_com_prob_all_rel)))
                  {
                     playStepArgs(_frame, _seq, _pat,
                                  trackState.repeat_last_arg1,
                                  trackState.repeat_last_arg2,
                                  maybe/*bInfOnOff*/,
                                  bStep1Play,
                                  trackState.repeat_last_mod1/*mod1*/,
                                  trackState.repeat_last_mod2/*mod2*/,
                                  true/*bLerpMod1*/,
                                  true/*bLerpMod2*/,
                                  1/*slideDist*/,
                                  true/*bPlayMod*/
                                  );
                  }
               }

               trackState.current_repeat_count++;

               if(0 != current_num_repeats)
               {
                  if(trackState.current_repeat_count >= current_num_repeats)
                  {
                     // trace "xxx stop repeat (count("+current_repeat_count+") >= num_repeats("+current_num_repeats+"))";
                     trackState.current_repeat_ticks = -1;
                     trackState.b_repeat_mute = false;
                  }
               }

            }
         }

      } // if bPlaySeq

      // Play editor step (return key)
      if(-1 != _seq.queued_step_idx)
      {
         if(!_bMuted)
         {
            st <= steps.get(_seq.queued_step_idx);
            if(null != st)
            {
               if(st.b_trig)
               {
                  if(-1 == rec_note_on_ticks)
                  {
                     playStep(_frame, st, _seq, _pat, bStep1Play, true/*bPlayMod*/);
                  }
               }
            }
         }
      }
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 22;

      // Write play_state (b_mute in v1, but unused)
      _ofs.i8 = play_state;
      _ofs.i8 = play_state_presolo; // v2+

      // Write name
      Utils.WriteString(_ofs, name);

      // Write bg_tint (v10+)
      _ofs.i32 = bg_tint;

      // Write steps
      _ofs.i16 = steps.numElements;
      NTS_Step *st;
      foreach st in steps
      {
         st.saveState(_ofs);
      }

      // Write play_length
      _ofs.i16 = play_length;

      // Write step_note_length
      _ofs.i16 = step_note_length;

      // Write note name profile id (v13+)
      Utils.WriteString(_ofs, note_name_profile_id);

      // Write arg3
      _ofs.f32 = arg3;

      // Write quantization_amount (v7+)
      _ofs.f32 = quantization_amount;

      // Write swing_amount
      _ofs.f32 = swing_amount;

      // Write repeat_note_length (v3+)
      _ofs.i8  = repeat_note_length;

      // Write num_repeats (v3+)
      _ofs.i8  = num_repeats;

      // Write velocities (v5+)
      _ofs.i8 = velocities.get(0);
      _ofs.i8 = velocities.get(1);
      _ofs.i8 = velocities.get(2);
      _ofs.i8 = velocities.get(3);

      // Write velocity jitter (v12+)
      _ofs.f32 = velocity_jitter;

      // Write default_note_duration_ticks (v5+)
      _ofs.i16 = default_note_duration_ticks;

      // Write forced_out (v8+)
      _ofs.i8  = b_forced_out;
      _ofs.i16 = forced_out_dev;
      _ofs.i8  = forced_out_ch;

      // Write microtime_shift (v8+)
      _ofs.f32 = microtime_shift;

      // Write microtime_jitter (v11+)
      _ofs.f32 = microtime_jitter;

      // Write forced output mode (v9+)
      _ofs.i8 = forced_output_mode;

      // Write euclid params (v6+)
      euclid_params.saveState(_ofs);

      // Write mod1 (v14+)
      _ofs.i8  = mod1_type.type;
      _ofs.i16 = mod1_type.ext_type;

      // Write mod1 range (v16+)
      _ofs.f32 = mod1_min;
      _ofs.f32 = mod1_max;

      // Write mod1 reset (v17+)
      _ofs.f32 = mod1_reset;

      // Write mod1 jitter (v18+)
      _ofs.f32 = mod1_jitter;

      // Write mod2 (v14+)
      _ofs.i8  = mod2_type.type;
      _ofs.i16 = mod2_type.ext_type;

      // Write mod2 range (v16+)
      _ofs.f32 = mod2_min;
      _ofs.f32 = mod2_max;

      // Write mod2 reset (v17+)
      _ofs.f32 = mod2_reset;

      // Write mod2 jitter (v18+)
      _ofs.f32 = mod2_jitter;

      // Write forced_mod_out (v15+)
      _ofs.i8  = b_forced_mod_out;
      _ofs.i16 = forced_mod_out_dev;
      _ofs.i8  = forced_mod_out_ch;

      // Write mod_tickshift (v22+)
      _ofs.i8  = mod_tickshift;

      // Linnstrument settings (v19+)
      _ofs.i8 = b_linnstrument_perf_trig_dur_scl;  // v19+
   }

   // <load.png>
   public method loadState(Stream _ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Read play_state
         play_state = _ifs.u8;  // b_mute in v1

         if(ver >= 2)
         {
            play_state_presolo = _ifs.u8;
         }

         // Read name
         Utils.ReadString(_ifs, name);

         if(ver >= 10)
         {
            // Read bg_tint (v10+)
            bg_tint = _ifs.i32;
         }

         // Read steps
         int numSteps = _ifs.u16;

         int stIdx = 0;

         loop(numSteps)
         {
            NTS_Step st <= steps.get(stIdx);

            if(!st.loadState(_ifs, _outDevIdxMap, _outDevUseCount))
            {
               trace "[---] NTS_Track::loadState: failed to load step idx="+stIdx+" (num="+numSteps+")";
               return false;
            }

            // Next step
            stIdx++;
         }

         // Read play_length
         play_length = _ifs.u16;

         // Read step_note_length
         step_note_length = _ifs.u16;

         if(ver >= 13)
         {
            // Read note name profile id (v13+)
            note_name_profile_id <= new String;
            Utils.ReadString(_ifs, note_name_profile_id);
            if(note_name_profile_id.isBlank())
               note_name_profile_id <= null;
         }

         // Read arg3
         arg3 = _ifs.f32;

         if(ver >= 7)
         {
            // Read quantization_amount
            quantization_amount = _ifs.f32;
         }

         // Read swing_amount
         swing_amount = _ifs.f32;

         if(ver >= 3)
         {
            // Read repeat_note_length
            repeat_note_length = _ifs.s8;

            // Read num_repeats
            num_repeats = _ifs.u8;
         }

         // Read velocities
         if(ver >= 5)
         {
            velocities.alloc(4);
            velocities.useAll();
            velocities[0] = _ifs.u8;
            velocities[1] = _ifs.u8;
            velocities[2] = _ifs.u8;
            velocities[3] = _ifs.u8;
         }

         if(ver >= 12)
         {
            // Read velocity jitter (v12+)
            velocity_jitter = _ifs.f32;
         }

         // Read default_note_duration_ticks
         if(ver >= 5)
         {
            default_note_duration_ticks = _ifs.u16;
         }

         // Fix note length mapping (changed in v4+)
         if(ver < 4)
         {
            if(9 <= step_note_length <= 11)
               step_note_length += 3;
            else if(step_note_length >= 12)
               step_note_length += 5;

            if(9 <= repeat_note_length <= 11)
               repeat_note_length += 3;
            else if(repeat_note_length >= 12)
               repeat_note_length += 5;
         }

         if(ver < 21)
         {
            step_note_length   = old_prev21_notelen_remap_tbl.get(step_note_length);
            if(-1 != repeat_note_length)
               repeat_note_length = old_prev21_notelen_remap_tbl.get(repeat_note_length);
         }

         // Read forced_out (v8+)
         if(ver >= 8)
         {
            b_forced_out   = _ifs.b8;
            forced_out_dev = _ifs.s16;
            forced_out_ch  = _ifs.u8 & 15;

            if(forced_out_dev >= 0)
            {
               _outDevUseCount.inc(forced_out_dev);

               // Remap to new MIDI out_devices index
               forced_out_dev = _outDevIdxMap.get(forced_out_dev);
            }
         }

         // Read microtime_shift (v8+)
         if(ver >= 8)
         {
            microtime_shift = _ifs.f32;
         }

         // Read microtime_shift (v11+)
         if(ver >= 11)
         {
            microtime_jitter = _ifs.f32;
         }

         // Read forced mode (v9+)
         if(ver >= 9)
         {
            forced_output_mode = _ifs.s8;

            if(ver < 20)
               if(forced_output_mode >= 9)
                  forced_output_mode++;  // OUT_MULTITRACK_POLYSTEP4 added in v20
         }

         // Read euclid params (v6+)
         if(ver >= 6)
         {
            if(!euclid_params.loadState(_ifs))
            {
               trace "[---] NTS_Track::loadState: failed to load euclid params";
               return false;
            }
         }

         if(ver >= 14)
         {
            // Read mod1 (v14+)
            mod1_type.type     = _ifs.s8;
            mod1_type.ext_type = _ifs.u16;

            if(ver >= 16)
            {
               // Read mod1 range (v16+)
               mod1_min = _ifs.f32;
               mod1_max = _ifs.f32;

               if(ver >= 17)
               {
                  // Read mod1 reset (v17+)
                  mod1_reset = _ifs.f32;
               }

               if(ver >= 18)
               {
                  // Read mod1 jitter (v18+)
                  mod1_jitter = _ifs.f32;
               }
            }

            // Read mod2 (v14+)
            mod2_type.type     = _ifs.s8;
            mod2_type.ext_type = _ifs.u16;

            if(ver >= 16)
            {
               // Read mod2 range (v16+)
               mod2_min = _ifs.f32;
               mod2_max = _ifs.f32;

               if(ver >= 17)
               {
                  // Read mod2 reset (v17+)
                  mod2_reset = _ifs.f32;
               }

               if(ver >= 18)
               {
                  // Read mod2 jitter (v18+)
                  mod2_jitter = _ifs.f32;
               }
            }
         }

         // Read forced_mod_out (v15+)
         if(ver >= 15)
         {
            b_forced_mod_out   = _ifs.b8;
            forced_mod_out_dev = _ifs.s16;
            forced_mod_out_ch  = _ifs.u8 & 15;

            if(forced_mod_out_dev >= 0)
            {
               _outDevUseCount.inc(forced_mod_out_dev);

               // Remap to new MIDI out_devices index
               forced_mod_out_dev = _outDevIdxMap.get(forced_mod_out_dev);
            }
         }

         if(ver >= 22)
         {
            // mod_tickshift (v22+)
            mod_tickshift = _ifs.u8;
         }

         if(ver >= 19)
         {
            // Linnstrument settings (v19+)
            b_linnstrument_perf_trig_dur_scl = _ifs.b8;  // v19+
         }

         // Succeeded
         updateTrigCache();

         return true;
      }
      else
      {
         trace "[---] NTS_Track::loadState: bad ver="+ver;
      }

      return false;
   }
}
