// ----
// ---- file   : global.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 14Sep2006, 17Sep2006, 20Sep2006, 15Oct2007, 20Oct2007, 21Oct2007, 22Oct2007,
// ----          30Oct2007, 31Oct2007, 04Nov2007, 05Nov2007, 10Nov2007, 21Dec2007, 04Jan2008
// ----          07Jan2008, 10Jan2008, 12Jan2008, 13Jan2008, 15Jan2008, 16Jan2008, 03Aug2008
// ----          09Aug2008, 24Aug2008, 31Aug2008, 17Sep2009, 18Sep2009, 20Sep2009, 21Sep2009
// ----          22Sep2009, 23Sep2009, 26Dec2009, 02Jan2010, 03Jan2010, 09Jan2010, 10Jan2010
// ----          11Jan2010, 16Jan2010, 25Jan2010, 27Jan2010, 29Jan2010, 06Feb2010, 25Feb2010
// ----          01Mar2010, 24Apr2010, 29Apr2010, 30Apr2010, 01May2010, 02May2010, 03May2010
// ----          04May2010, 11May2010, 14May2010, 15May2010, 16May2010, 06Jun2010, 10Jun2010
// ----          13Jun2010, 15Jun2010, 24Jun2010, 26Jun2010, 28Jun2010, 30Jun2010, 01Jul2010
// ----          02Jul2010, 04Jul2010, 06Jul2010, 10Jul2010, 12Jul2010, 16Jul2010, 17Jul2010
// ----          18Jul2010, 21Jul2010, 08Sep2010, 24Sep2010, 26Sep2010, 27Sep2010, 28Sep2010
// ----          04Oct2010, 08Oct2010, 09Oct2010, 10Oct2010, 12Oct2010, 13Oct2010, 14Oct2010
// ----          15Oct2010, 16Oct2010, 17Oct2010, 19Oct2010, 20Oct2010, 25Oct2010, 26Oct2010
// ----          02Nov2010, 09Nov2010, 16Nov2010, 21Nov2010, 19Jan2011, 23Jan2011, 03Feb2011
// ----          18Feb2011, 20Feb2011, 25Feb2011, 28Feb2011, 12Mar2011, 13Mar2011, 19Mar2011
// ----          30Mar2011, 02Apr2011, 06Apr2011, 20Apr2011, 11Jun2011, 08Jan2012, 09Jan2012
// ----          16Jan2012, 17Jan2012, 19Jan2012, 20Jan2012, 24Jan2012, 06Feb2012, 08Feb2012
// ----          13Feb2012, 14Feb2012, 19Feb2012, 20Feb2012, 24Feb2012, 25Feb2012, 13May2012
// ----          26Jun2012, 28Jun2012, 09Nov2012, 13Nov2012, 21Nov2012, 21Dec2012, 03Jan2013
// ----          04Jan2013, 05Jan2013, 06Jan2013, 09Jan2013, 28Feb2013, 23Mar2013, 01Apr2013
// ----          07Apr2013, 13Apr2013, 14Apr2013, 15Apr2013, 19Apr2013, 04May2013, 08May2013
// ----          09May2013, 10May2013, 13May2013, 14May2013, 15May2013, 24May2013, 26May2013
// ----          27May2013, 29May2013, 31May2013, 01Jun2013, 04Jun2013, 05Jun2013, 02Feb2014
// ----          09Feb2014, 11Feb2014, 09Aug2014, 11Aug2014, 12Aug2014, 14Aug2014, 15Aug2014
// ----          18Aug2014, 19Aug2014, 20Aug2014, 25Aug2014, 05Sep2014, 06Sep2014, 09Sep2014
// ----          15Sep2014, 16Sep2014, 17Sep2014, 20Sep2014, 22Sep2014, 23Sep2014, 17Oct2014
// ----          25Nov2014, 01Feb2015, 14Feb2015, 17Feb2015, 21Feb2015, 01Mar2015, 08Mar2015
// ----          21Apr2015, 03May2015, 15May2015, 17May2015, 11Sep2015, 12Sep2015, 24Sep2015
// ----          25Sep2015, 29Sep2015, 02Oct2015, 03Oct2015, 04Oct2015, 05Oct2015, 10Oct2015
// ----          11Oct2015, 12Oct2015, 23Oct2015, 31Oct2015, 06Nov2015, 12Nov2015, 15Nov2015
// ----          23Jan2016, 25Jan2016, 07Feb2016, 07Mar2016, 09Mar2016, 11Mar2016, 21Mar2016
// ----          25Mar2016, 09Apr2016, 10Apr2016, 11Jul2016, 30Sep2016, 13Jan2017, 03Mar2017
// ----          08Mar2017, 12Mar2017, 17Mar2017, 19Apr2017, 30Apr2017, 06May2017, 02Jun2017
// ----          07Jun2017, 16Jun2017, 18Jun2017, 20Jul2017, 20Aug2017, 22Aug2017, 09Sep2017
// ----          10Sep2017, 14Sep2017, 26Nov2017, 02Jan2018, 04Jan2018, 09Feb2018, 10Feb2018
// ----          27Feb2018, 03Mar2018, 26Mar2018, 02Apr2018, 05Apr2018, 21May2018, 23May2018
// ----          27May2018, 28May2018, 02Jun2018, 10Jun2018, 22Jul2018, 15Sep2018, 13Nov2018
// ----          24Nov2018, 28Nov2018, 01Dec2018, 08Dec2018, 10Jan2019, 13Jan2019, 22Jan2019
// ----          09Feb2019, 02Mar2019, 14Mar2019, 29Mar2019, 27Apr2019, 18May2019, 26May2019
// ----          30May2019, 09Jun2019, 20Jun2019, 25Jul2019, 02Aug2019, 05Aug2019, 28Aug2019
// ----          29Aug2019, 08Sep2019, 15Sep2019, 22Sep2019, 02Oct2019, 07Oct2019, 08Oct2019
// ----          14Oct2019, 15Oct2019, 16Oct2019, 22Oct2019, 25Oct2019, 27Oct2019, 31Oct2019
// ----          01Nov2019, 02Nov2019, 04Nov2019, 05Nov2019, 08Nov2019, 20Feb2020, 27Feb2020
// ----          06Mar2020, 13Mar2020, 22Mar2020, 04Apr2020, 12Apr2020, 17Apr2020, 24Apr2020
// ----          26Apr2020, 28Apr2020, 10May2020, 04Jun2020, 12Sep2020, 15Oct2020, 24Oct2020
// ----          27Oct2020, 07Nov2020, 27Nov2020, 26Jan2021, 10Feb2021, 02Apr2021, 17Apr2021
// ----          07May2021, 10May2021, 13May2021, 14May2021, 15May2021, 22May2021, 23May2021
// ----          26May2021, 27May2021, 31May2021, 02Jun2021, 14Jun2021, 20Jun2021, 16Jul2021
// ----          18Jul2021, 21Jul2021, 25Jul2021, 28Jul2021, 27Aug2021, 13Sep2021, 15Oct2021
// ----          24Oct2021, 26Oct2021, 28Oct2021, 31Oct2021, 13Nov2021, 21Nov2021, 03Dec2021
// ----          12Dec2021, 19Dec2021, 20Dec2021, 23Dec2021, 31Dec2021, 09Jan2022, 16Jan2022
// ----          13Feb2022, 23Feb2022, 27Feb2022, 18Mar2022, 20Mar2022, 01Apr2022, 03Apr2022
// ----          08Apr2022, 21Apr2022, 23Apr2022, 24Apr2022, 22Jun2022, 24Jun2022, 11Aug2022
// ----          13Aug2022, 30Sep2022, 01Oct2022, 07Oct2022, 08Oct2022, 22Oct2022, 29Oct2022
// ----          31Oct2022, 02Nov2022, 04Nov2022, 08Nov2022, 09Nov2022, 18Nov2022, 19Nov2022
// ----          25Nov2022, 10Dec2022, 16Dec2022, 23Dec2022, 27Jan2023, 01Feb2023, 05Feb2023
// ----          12Feb2023, 18Feb2023, 19Feb2023, 20Feb2023, 21Feb2023, 15Mar2023, 18Mar2023
// ----          31Mar2023, 01Apr2023, 21Apr2023, 14Jun2023, 23Jun2023, 28Jul2023, 03Aug2023
// ----          05Aug2023, 16Aug2023, 18Aug2023, 22Sep2023, 24Sep2023, 25Sep2023, 02Oct2023
// ----          04Oct2023, 06Oct2023, 08Oct2023, 03Nov2023, 04Nov2023, 30Nov2023, 02Dec2023
// ----          03Dec2023, 14Dec2023, 16Dec2023, 11Apr2024, 13Apr2024, 07Jul2024, 23Jul2024
// ----          22Aug2024, 15Sep2024, 02Oct2024, 05Oct2024, 22Nov2024, 23Nov2024, 24Nov2024
// ----          28Nov2024, 30Nov2024, 13Dec2024, 23Dec2024, 01Jan2025, 11Jan2025, 08Mar2025
// ----          14Mar2025, 29Mar2025, 30Mar2025, 27May2025, 29May2025, 09Jun2025
// ----
// ----
// ----
module MGlobal;

use namespace ui;
use namespace st2;


// <class.png>
class Global {

   define String DATE_STRING = "v2025.06.09";
   define String VERSION_STRING = "Synergy - "+DATE_STRING;
   define String VERSION_STRING_PUSH = "Synergy -"+DATE_STRING;

   define String PROJECT_FILE_SUFFIX  = ".flx";
   define String PIPE_FILE_SUFFIX     = ".spi";
   define String NODE_FILE_SUFFIX     = ".sno";
   define String CURVE_FILE_SUFFIX    = ".curve";
   define String AR_SOUND_FILE_SUFFIX = ".syx";
   define String MMS_FILE_SUFFIX      = ".mms";

   define String AUTOSAVE_CURRENT_FILENR_FILE = "synergy_autosave_current_filenr.dat";
   define String AUTOSAVE_FILENAME_PREFIX = "synergy_autosave_";

   static boolean b_initializing;

   static boolean b_loading; // true=skip some UI messages while loading a song

   static int last_autosave_timestamp = 0;

   static AppLookAndFeel_Light *app_lnf_light;
   static AppLookAndFeel_Dark  *app_lnf_dark;
   static AppLookAndFeel_Mono  *app_lnf_mono;

   // Print() from replay thread
   static Mutex mtx_print_replay;
   static StringArray print_replay_queue_strings;
   static IntArray print_replay_queue_timeouts;

   static FloatArray eqtemp_freq_table;

   // last selected or received AnalogRytm pattern (see node_analogrytm/NodeAnalogRytm.tks)
   static AR_Pattern ar_pattern_clipboard;

   static st2::StatusBarLogger logger;



   // <init.png>
   static Init() : boolean {
      Integer io;

      // // trace "\n\n\nxxx Global::Init: STConfig.lnf_idx="+STConfig.lnf_idx;
      UI.SetLookAndFeelByIdx(mathMaxi(0, STConfig.lnf_idx) % 3);

      app_lnf_light <= new AppLookAndFeel_Light;
      app_lnf_light.initAppLookAndFeel();

      app_lnf_dark  <= new AppLookAndFeel_Dark;
      app_lnf_dark.initAppLookAndFeel();

      app_lnf_mono <= new AppLookAndFeel_Mono;
      app_lnf_mono.initAppLookAndFeel();

      switch(STConfig.lnf_idx)
      {
         default:
         case LookAndFeel.IDX_LIGHT:
            app_lnf <= app_lnf_light;
            break;

         case LookAndFeel.IDX_DARK:
            app_lnf <= app_lnf_dark;
            break;

         case LookAndFeel.IDX_MONO:
            app_lnf <= app_lnf_mono;
            break;
      }

      STConfigBase.InitPostLNF();

      Global.Debug("Global::Init: lnf theme is \""+app_lnf.getName()+"\"");

      MIDI.Init();

      SongFile.TraceOnceBegin();

      DebugPrintCPUInfo();

      if(!STConfig.b_ignore_thread_affinity)
      {
         if(Configuration.debugLevel >= 2)
            Debug2("Setting process affinity mask to \""+STConfig.process_affinity_mask+"\"");
         Thread.SetProcessAffinityMaskByString(STConfig.process_affinity_mask);

         if(Configuration.debugLevel >= 2)
            Debug2("Setting UI affinity mask to \""+STConfig.ui_thread_affinity_mask+"\"");
         Thread uiThread <= GetCurrentThread();
         uiThread.setAffinityMaskByString(STConfig.ui_thread_affinity_mask);
      }

      b_initializing = true;

      // Set dummy song to prevent crashes during startup.
      //  (note) current_song is usually just a pointer into the all_songs array
      current_song <= new ST_Song;
      current_pipe_root <= current_song.pipe_root;

      MIDI.UpdateMIDINoteOctaves();

      if(!MIDI.OpenMIDITimer())
      {
         trace "[---] failed to open MIDI timer.";
         return false;
      }

      // Debug-print list of MIDI devices to console (for configuration)
      MIDI.EnumerateMIDIDevices();

      MIDI.InitMIDISynthProfiles();

      if(STConfig.b_enable_midi)
      {
         // Initialize MIDI device(s)
         if(!MIDI.InitMIDIOutDevices())
         {
            // (note) do not exit if a midi device is not present
            // return false;
         }

         // Initialize SysEx in/out devices
         SysEx.Init();

         MIDI.UpdateOutDeviceNames();

         if(!MIDI.InitMIDIInDevices())
         {
            // (note) do not exit if a midi device is not present
            // return false;
         }

         MIDI.UpdateInDeviceNames();

         MIDI.UpdateMIDIPipeRoot(current_pipe_root);  // alloc MIDIPipeDevs

         if(push.connect())
         {
            trace "[...] Push controller support enabled.";
         }
      }

      if(faderport.init())
      {
         trace "[...] FaderPort bidirectional controller support enabled.";
         bidi_ctls.add(faderport);
      }

      if(mf_twister.init())
      {
         trace "[...] MIDIFighter Twister bidirectional controller support enabled.";
         bidi_ctls.add(mf_twister);
      }

      if(console1.init())
      {
         trace "[...] Softube Console-1 bidirectional controller support enabled.";
         bidi_ctls.add(console1);
      }

      MIDI.InitMIDINoteNames();

      MIDI.UpdateMIDIInEnableParam();  // Enable/disable (N)RPN parser according to MIDI synth profile(s)
      MIDI.UpdateMIDIParamMode();      // configure (N)RPN MSB/LSB I/O mode according to MIDI synth profile(s)
      MIDI.UpdateMIDICCPerfLSB();      // configure 14bit performance controller CCs according to MIDI synth profile(s)
      MIDI.UpdateMIDIOverflowBuffers();

      if(STConfig.b_enable_midi)
      {
         MIDI.UpdateMIDIPipeDevFlags(current_pipe_root);  // for param mode
      }

      // Patnr names (e.g. for comboboxes)
      Node.InitPatNrOptions();

      // Parse main screen form
      root_form <= new RootForm;
      if(!root_form.initPakFile("RootForm.xfm"))
      {
         die "failed to parse RootForm.xfm";
      }

      // Load/parse XFMs
      if(!root_form.init())
      {
         trace "[---] RootForm::init() failed\n";
         return false;
      }

      // Initialize song (also clears all sub-songs)
      InitSong();

      CreateEqTempFreqTable();  // Create frequency table (e.g. for MTS editor)

      // Init MIDIMap event queues
      replay.init();

      Dialogs.Init();

      root_form.updateSongWidgets();

      // Init "Monitor" capture node (in "st2" namespace)
      mon_capture <= new NodeMonitor;
      mon_capture.captureInit();

      BidiHandleSelectOrEditScene();

      last_autosave_timestamp = milliSeconds();

      PrintMS("All right.", 2000);

      return true;
   }

   // <method.png>
   public static DebugPrintCPUInfo() {
      int num = Thread.GetNumCPUCores();
      int idx = 0;
      loop(num)
      {
         trace "[dbg] cpuinfo: core["+idx+"] p:"+Thread.IsPerformanceCPUCore(idx)+" e:"+Thread.IsEfficiencyCPUCore(idx)+" ht:"+Thread.IsCPUCoreShared(idx);
         idx++;
      }
   }

   // <method.png>
   public static BidiHandleSelectOrEditScene() {
      BidiCtl *bidiCtl;
      foreach bidiCtl in bidi_ctls
         bidiCtl.handleSelectOrEditScene();
   }

   // <method.png>
   static LoadIcon() {
      local PakFile f;
      if(f.open("synergy_icon.bmp"))
      {
         local Buffer b;
         f.readBuffer(b, 0, f.size, true/*bResize*/);
         f.close();
         if(SDL.setIconFromBMP(b))
         {
            if(Configuration.debugLevel >= 2)
               Debug2("Global::LoadIcon: loaded icon from \"synergy_icon.bmp\"");
         }
         else
         {
            if(Configuration.debugLevel >= 2)
               Debug2("Global::LoadIcon: failed to load icon from \"synergy_icon.bmp\"");
         }
      }
      else
      {
         trace "[---] Global::LoadIcon: failed to open \"synergy_icon.bmp\"";
      }
   }

   // <method.png>
   static =replay= LazyLoadTSL(String _libName) : boolean {

      if(Configuration.debugLevel >= 2)
         Global.Debug2("Global::LazyLoadTSL: libName=\""+_libName+"\"");

      if(!g_loaded_tsls.exists(_libName))
      {
         if(TKS.loadLocalTSL(_libName))
         {
            g_loaded_tsls[_libName] = true;
            return true;
         }
         else
         {
            trace "[---] Global::LazyLoadTSL: failed to load library \""+_libName+"\"";
            return false;
         }
      }
      // Already loaded
      return true;
   }

   // <method.png>
   static LazyLoadTSL_CSL(String _libNamesCSL) : boolean {
      local StringArray aTSL <= _libNamesCSL.splitChar(',');
      String *sTSL;
      foreach sTSL in aTSL
      {
         if(!LazyLoadTSL(sTSL))
         {
            trace "[---] Global::LazyLoadTSL_CSL: failed to load TSL \""+sTSL+"\"";
            return false;
         }
      }
      return true;
   }

   // <method.png>
   static LazyAccessNodeClass(String _className) : boolean {
      if(Configuration.debugLevel >= 2)
         Global.Debug2("Global::LazyAccessNodeClass: className=\""+_className+"\"");
      HashTable htTSLs  <= STConfig.node_type_tsls;
      if(htTSLs.exists(_className))
      {
         if(LazyLoadTSL_CSL(htTSLs.get(_className)))
         {
            if(g_stashed_raw_project_node_mmc_data.exists(_className))
            {
               Object clazz <= TKS.findScriptClass(null/*nsp*/, _className);
               if(clazz instanceof Node)
               {
                  Value ret;
                  if(TKS.evalMethodByName(clazz, "nodeGetEditor", null/*args*/, ret))
                  {
                     MIDIMapContext mmc <= ret.objectValue;
                     if(mmc instanceof MIDIMapContext)
                     {
                        Global.Debug2("Global::LazyAccessNodeClass: read stashed MMC for node class \""+_className+"\"");
                        Buffer bufMMC <= g_stashed_raw_project_node_mmc_data[_className];
                        bufMMC.offset = 0;
                        if(SongFileReader.ReadMMCHeader(bufMMC, bufMMC.size, mmc))
                        {
                           g_stashed_raw_project_node_mmc_data.delete(_className);
                        }
                        else
                        {
                           // not a fatal error but should not be reachable
                           trace "[~~~] Global::LazyAccessNodeClass: failed to read stashed MMC (MIDIMAP_NODEEDITOR_DATA chunk)";
                           // // return false;
                        }
                     }
                     else
                     {
                        // not a fatal error but should not be reachable
                        trace "[~~~] Global::LazyAccessNodeClass: node class \""+_className+"\" is not a MIDIMapContext";
                     }
                  }
                  else
                  {
                     // not a fatal error but should not be reachable
                     trace "[~~~] Global::LazyAccessNodeClass: node class \""+_className+"\" nodeGetEditor() failed";
                  }
               }
               else
               {
                  trace "[---] Global::LazyAccessNodeClass: node class \""+_className+"\" is not a Node";
                  return false;
               }
            }
            // else: no stashed MMC data
         }
         else
         {
            trace "[---] Global::LazyAccessNodeClass: failed to load TSLs for node class \""+_className+"\"";
            return false;
         }
      }
      // else: does not depend on TSLs
      return true;
   }

   // <method.png>
   static PreRun() {

      Debug("Global::PreRun: ENTER");

      UI.DrainEventQueue();

      b_initializing = false;

      if(STConfig.b_enable_midi)
      {
         // Start MIDI device threads
         SysEx.Start();

         MIDI.StartMIDIInDevices();
      }

      UI.DrainEventQueue();

      MIDI.StartMIDITimer();

      // Radias / Ax5k tests ..
      MIDI.InitSomePrivateTestCode();

      // UI thread has least priority, audio+midi threads have default priority (e.g. "nice -10 tks synergy")
      // // Thread cThread <= GetCurrentThread();
      // // cThread.priority = THREAD_PRIORITY_BELOW_NORMAL;//LOWEST;

      replay.handleMetronomeDevChanged();

      if(STConfig.b_push)
      {
         push.setMode(STConfig.push_mode);
      }

      UI.DrainEventQueue();

      root_form.showPage(STConfig.start_page, true);

      UI.DrainEventQueue();

      root_form.showBPM();

      LoadIcon();

      // // if(faderport.b_connected)
      // //    faderport.handleSelectOrEditScene();

      Debug("Global::PreRun: LEAVE");
   }

   // <ui_handle.png>
   static HandleOnClose() {
      int numModal = UI.GetNumModalFloatingLayers();

      if(0 == numModal)
      {
         // OK, quit it
         Global.cmd_file_quit();
      }
      else
      {
         // Do not exit as long as there are modal dialogs
         trace "[~~~] SDL_onClose: cannot exit since there are "+numModal+" modal windows";
      }
   }

   // <exit.png>
   static Exit() {
      trace "[...] Global::Exit() called.";

      MIDI.CloseMIDITimer();

      current_song.exit();

      if(STConfig.b_enable_midi)
      {
         SysEx.Exit();
         MIDI.ExitMIDIOutDevices();
         MIDI.ExitMIDIInDevices();
      }

      UI.Exit();

      trace "[...] Global::Exit() finished.";

      int oldLevel = Configuration.debugLevel;
      Configuration.debugLevel = 79;
      _DebugOC();
      Configuration.debugLevel = oldLevel;
   }

   // <log.png>
   static Error(String _text) {
      logger.logError(_text);
   }

   // <log.png>
   static FatalError(String _text) {
      logger.logFatal(_text);
   }

   // <log.png>
   static Warning(String _text) {
      logger.logWarning(_text);
   }

   // <log.png>
   static WarningLong(String _text) {
      logger.logWarningLong(_text);
   }

   // <log.png>
   static Success(String _text) {
      logger.logSuccess(_text);
   }

   // <log.png>
   static SuccessShort(String _text) {
      logger.logSuccessShort(_text);
   }

   // <log.png>
   static PrintMS(String _text, int _timeout) {
      int fg = UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_FG);
      int bg = UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_BG);

      root_form.pushStatusMessage(_text, _timeout, fg, bg, false/*bHead*/);

      // // trace "[dbg] Global.Print: \""+_text+"\".";
   }

   // <log.png>
   static PrintHead(String _text) {
      if(!b_loading)
      {
         int fg = UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_FG);
         int bg = UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_BG);

         root_form.pushStatusMessage(_text, 150/*350*/, fg, bg, true/*bHead*/);
      }
      // // trace "[dbg] Global.Print: \""+_text+"\".";
   }

   // <log.png>
   static Info(String _text) {
      // [...]
      logger.logInfo(_text);
   }

   // <debug.png>
   static Debug(local String _text) {
      // [dbg]
      if(STConfig.b_debug_lofreq)
      {
         logger.logDebug(_text);
      }
   }

   // <debug.png>
   static Debug2(local String _text) {
      // [trc]
      if(STConfig.b_debug_hifreq)
      {
         logger.logTrace(_text);
      }
   }

   // <debug.png>
   static Debug3(local String _text) {
      // [>>>]
      if(STConfig.b_debug_rt)
      {
         logger.logVerbose(_text);
      }
   }

   // <debug.png>
   static Debug4(local String _text) {
      // work-in-progress very-verbose debug messages (should be commented out when done)
      // // if(STConfig.b_debug_rt)
      // // {
         logger.logVerbose(_text);
      //    // trace "[xxx] "+_text;
      // // }
   }

   // <debug.png>
   static Profile(local String _text) {
      if(STConfig.b_debug_profile)
      {
         logger.logProfile(_text);
      }
   }

   // <log.png>
   static Print(String _text) {
      logger.logInfo(_text);
   }

   // <log.png>
   static PrintFast(String _text) {
      // (todo) should actually be called PrintSlow() (..)
      logger.logInfoFast(_text);
   }

   // <log.png>
   static PrintInteractive(String _text) {
      int fg = UI.lnf.getColor(LookAndFeel.COLOR_TEXT_FG);
      int bg = UI.MixColor32(#ff00ffff, UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_BG), 0.95);

      root_form.pushStatusMessage("$: "+_text, 10, fg, bg, false/*bHead*/);

      trace "[...] Global.PrintShortInteractive: \""+_text+"\".";
   }

   // <log.png>
   static PrintShortInteractive(String _text) {
      int fg = UI.lnf.getColor(LookAndFeel.COLOR_TEXT_FG);
      int bg = UI.MixColor32(#ff00ffff, UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_BG), 0.95);

      root_form.pushStatusMessage("$: "+_text, 500, fg, bg, false/*bHead*/);

      trace "[...] Global.PrintShortInteractive: \""+_text+"\".";
   }

   // <log.png>
   static PrintBegin(String _text) {
      int fg = #ffffffff;
      int bg = UI.MixColor32(#ffff9b00, UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_BG), 0.1);

      root_form.pushStatusMessage("Begin: "+_text, -1, fg, bg, false/*bHead*/);

      trace "[...] Global.Begin: \""+_text+"\".";
   }

   // <log.png>
   static PrintEndOK(String _text) {

      root_form.endStatusMessageLock();

      int fg = #ff000000;
      int bg = UI.MixColor32(#ff00ff00, UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_BG), 0.8);

      root_form.pushStatusMessage("End: "+_text, 10, fg, bg, false/*bHead*/);

      trace "[...] Global.End<OK>: \""+_text+"\".";
   }

   // <log.png>
   static PrintEndNOK(String _text) {

      root_form.endStatusMessageLock();

      int fg = #ff000000;
      int bg = UI.MixColor32(#ffff9b00, UI.lnf.getColor(LookAndFeel.COLOR_TEXT_EDIT_BG), 0.8);

      root_form.pushStatusMessage("End: "+_text, 10, fg, bg, false/*bHead*/);

      trace "[...] Global.End<NOK>: \""+_text+"\".";
   }

   // <log.png>
   static PrintFromReplay(String _text) {
      mtx_print_replay.lock();
      print_replay_queue_strings.add(_text);
      print_replay_queue_timeouts.add(10);
      mtx_print_replay.unlock();
      Events.SendNodeEditorReplayTick();
   }

   // <log.png>
   static PrintLongFromReplay(String _text) {
      mtx_print_replay.lock();
      print_replay_queue_strings.add(_text);
      print_replay_queue_timeouts.add(1000);
      mtx_print_replay.unlock();
      Events.SendNodeEditorReplayTick();
   }

   // <log.png>
   static HandleQueuedReplayPrints() {
      if(print_replay_queue_strings.numElements > 0)
      {
         mtx_print_replay.lock();
         int idx = 0;
         loop(print_replay_queue_strings.numElements)
         {
            PrintMS(print_replay_queue_strings.get(idx),
                    print_replay_queue_timeouts.get(idx)
                    );
            idx++;
         }
         print_replay_queue_strings.empty();
         print_replay_queue_timeouts.empty();
         mtx_print_replay.unlock();
      }
   }

   // <method.png>
   static ConfigureVSync() {

      UI.SetEnableForceHighFramerate(STConfig.b_force_high_framerate);

      Viewport.swapInterval(STConfig.b_vsync ? 1 : 0);

      // If vsync is enabled, disable timer-based framerate limiter
      if(STConfig.b_vsync && STConfig.b_force_high_framerate)
      {
         FPS.limit = 0;
      }
   }

   // <method.png>
   static ConfigureFullscreenDisplaySize() {
      if(STConfig.b_fullscreen_displaysize)
      {
         // 0= auto-detect screen resolution
         Viewport.setScreenResolution(0, 0, STConfig.fullscreen_bits);
      }
      else
      {
         Debug("Global::ConfigureFullscreenDisplaySize: non-native size=("+STConfig.fullscreen_sx+"; "+STConfig.fullscreen_sy+")");
         Viewport.setScreenResolution(STConfig.fullscreen_sx, STConfig.fullscreen_sy, STConfig.fullscreen_bits);
      }
   }

   // <method.png>
   static GetAutosaveDirPrefix() : String {
      String ret = "";

      if(!(STConfig.autosave_dir.isBlank()))
      {
         ret = Utils.ToNativePathName(STConfig.autosave_dir);
         ret.append("/");
      }

      return ret;
   }

   // <save.png>
   static CrashAutosave(boolean _bHard) {
      trace "\n\n\n[---] ooops. a ("+(_bHard?"hard":"soft")+") crash has occured, crash_autosave is currently "+Utils.GetEnableString(STConfig.b_crash_autosave);

      if(STConfig.b_crash_autosave)
      {
         String crashAutosaveName = GetAutosaveDirPrefix() + "crash_autosave-"+Utils.GetCurrentDateString()+"-"+Utils.GetCurrentTimeString()+".flx";

         trace "\n\n[...] writing crash autosave to file \""+crashAutosaveName+"\"";
         TKS.sleep(1000);
         cmd_file_saveas_2(crashAutosaveName, true/*bAutosave*/);
      }

      trace "\n\n\n";
      trace "[dbg] please consider sending the console log to bs@tkscript.de\n[dbg]  so I can try to fix the problem.";
      trace "[dbg]  If you do so, please try to describe how to reproduce the crash!";
      TKS.sleep(5000);
      trace "[dbg] please press return (in the console) window to continue..";
      String buf;
      StdInStream.readLine(buf, 10);
   }

   // <exit.png>
   static ExitSong() {
      ST_Song *s;
      foreach s in all_songs
      {
         if(null != s)
            s.exit();
      }
      all_songs.free();
      g_stashed_raw_project_midiprofiledata.free();
      g_stashed_raw_project_node_mmc_data.free();
   }

   // <init.png>
   static InitSong() {
      Global.Debug2("Global::InitSong: ENTER");

      ExitSong();

      g_stashed_raw_project_midiprofiledata.alloc(200);
      g_stashed_raw_project_node_mmc_data.alloc(200);

      // Init MIDI morph scenes
      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 3");

      MIDIMorphScene.AllocScenes();

      // Create sub-song #0
      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 4");

      NewSubSong();

      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 5");

      SelectSubSongByIdx(0, true/*bSaveUI*/, false/*bViaUI*/);

      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 6");

      current_song.reset();

      NA_TimelineForm.current_rec_node_gid = -1;

      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 8");

      MIDI.ResetDevs(); // Reset UnvailUseCount, aliases and profile ids, and b_project flag for each in/out device
      MIDI.SetDefaultVirtualDeviceAliases();  // <play_a>..<play_h>

      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 9");

      MIDI.UpdateMIDIPipeDevFlags(current_pipe_root);

      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 10");

      root_form.pg_node.deleteLastEditor(); // xxx unnecessary, just unset last node..?!

      if(Configuration.debugLevel >= 2)
         Global.Debug2("InitSong: 11");

      root_form.updatePipePages(); // make sure deleted nodes are not ref'd

      Global.Debug2("Global::InitSong: LEAVE");
   }

   // <api.png>
   static GetSubSongIdx() : int {
      return all_songs.indexOfPointer(current_song, 0);
   }

   // <api.png>
   static =replay= SelectSubSongByIdx(int _idx, boolean _bSaveUI, boolean _bViaUI) : boolean {
      return SelectSubSongByIdx_audiomtx(_idx, _bSaveUI, _bViaUI);
   }

   static =audio= SelectSubSongByIdx_audiomtx(int _idx, boolean _bSaveUI, boolean _bViaUI) : boolean {
      Debug("Global::SelectSubSongByIdx: idx="+_idx+" (prev)current_song="+#(current_song));

      if(current_song instanceof ST_Song)
      {
         // trace "xxx current_song addr="+#(current_song)+" yacMetaClassName()="+current_song.yacMetaClassName();
         // trace "xxx current_song="+#(current_song)+" root_form.pg_piperoot="+#(root_form.pg_piperoot);
         current_song.ui_last_selected_pipe_idx = root_form.pg_piperoot.getSelectedPipeIdx();
         current_song.ui_last_selected_node_idx = root_form.pg_pipe.getSelectedNodeIdx();
      }

      local ST_Song prevSong <= deref current_song;  // (note) first DUMMY instance is deletable
      ST_Song subSong  <= all_songs.get(_idx);

      if(null != subSong)
      {
         // Select different sub-song
         current_song <= all_songs.get(_idx);
         current_pipe_root <= current_song.pipe_root;

         root_form.pg_piperoot.selectPipeByIdx(current_song.ui_last_selected_pipe_idx);
         root_form.pg_pipe    .selectNodeByIdx(current_song.ui_last_selected_node_idx);

         // Update song attribute widgets
         root_form.updateSongWidgets();

         if(_bViaUI)
         {
            if(current_song.hasCtlTags() || ((prevSong instanceof ST_Song) && prevSong.hasCtlTags()))
            {
               MIDI.RebuildAllCtlNames();
            }
         }

         // iterate pipes and call nodeSongSelect() for each (script-)node
         current_pipe_root.songSelect();

         UI.RedrawAll();

         BidiHandleSelectOrEditScene();

         return true;
      }

      return false;
   }

   // <api.png>
   static SelectNextSubSong() {
      int songIdx = all_songs.indexOfPointer(current_song, 0);
      if(songIdx < (all_songs.numElements-1))
      {
         songIdx++;
      }
      else
      {
         songIdx = 0;
      }
      SelectSubSongByIdx(songIdx, true, true/*bViaUI*/);
   }

   // <api.png>
   static SelectPreviousSubSong() {
      int songIdx = all_songs.indexOfPointer(current_song, 0);
      if(songIdx > 0)
      {
         songIdx--;
      }
      else
      {
         songIdx = (all_songs.numElements-1);
      }
      SelectSubSongByIdx(songIdx, true, true/*bViaUI*/);

      MIDI.RebuildAllCtlNames();
   }

   // <api.png>
   static =replay= RemoveSubSongByIdx(int _idx) {
      RemoveSubSongByIdx_audiomtx(_idx);
   }

   static =audio= RemoveSubSongByIdx_audiomtx(int _idx) {
      RemoveSubSongByIdx2(_idx);
   }

   static =replay= protected RemoveSubSongByIdx2(int _idx) {

      // Select another sub-song if the song to be deleted is the current one
      int cIdx = all_songs.indexOfPointer(current_song, 0);
      int idx = 0;
      if(cIdx == _idx)
      {
         ST_Song *s;
         foreach s in all_songs
         {
            if(idx != _idx)
            {
               SelectSubSongByIdx(idx, false, true/*bViaUI*/);
               break;
            }
            idx++;
         }
      }

      // Delete sub-song
      s <= all_songs[_idx];
      s.exit();
      all_songs.delete(_idx);
   }

   // <api.png>
   static =replay= NewSubSong() : int {
      return NewSubSong_audiomtx();
   }

   static =audio= NewSubSong_audiomtx() : int {

      // Find first unused subsong
      int idx = 0;
      while(idx < all_songs.numElements)
      {
         if(null == all_songs[idx])
            break;

         idx++;
      }

      local ST_Song s;
      s.init();

      // trace "xxx NewSubSong idx="+idx+" s addr="+#(current_song)+" yacMetaClassName()="+s.yacMetaClassName();

      if(0 == idx)
         s.sub_name = "main";
      else
         s.sub_name = "sub #"+idx;

      all_songs[idx] = deref s;

      // caller MUST select this song now (using SelectSubSongByIdx())

      return idx;
   }

   // <api.png>
   static GetCurrentPipe() : MIDIPipe {
      return root_form.pg_piperoot.getSelectedPipe();
   }

   // <api.png>
   static GetCurrentNode() : MIDIPipeNode {
      MIDIPipe pipe <= GetCurrentPipe();
      if(null != pipe)
         return root_form.pg_pipe.getSelectedNode();
      return null;
   }

   // <api.png>
   static =replay= SoftPanic() {
      SoftPanic_audiomtx();
   }

   static =audio= SoftPanic_audiomtx() {
      // called when replay stops, do not reset macro players

      Debug("SoftPanic");

      STX_MIDIOutDevice *outDev;
      foreach outDev in MIDI.out_devices
      {
         if(outDev.isOpen())
         {
            outDev.queueSoftPanic();
         }
      }

      current_song.reset();
   }

   // <api.png>
   static =replay= Panic() {
      Panic_audiomtx();
   }

   static =audio= Panic_audiomtx() {
      // Stop all voices immediately, reset macro players (but do not reset FX)

      Debug("Panic");

      replay.resetNodes(false/*bSoft*/);
      current_song.hardReset();
   }

   // <api.png>
   static =replay= PanicFX() {
      PanicFX_audiomtx();
   }

   static =audio= PanicFX_audiomtx() {
      // Called when "Panic" button is pressed

      Debug("PanicFX");

      current_song.hardReset();
   }

   // <method.png>
   static RefocusDefault() {
      root_form.handlePageFocusDefault();
   }

   // <method.png>
   static RefocusDefaultOrFloatingLayer() {
      FloatingLayer fl <= UI.GetFrontMostFloatingLayer();
      if(null != fl)
      {
         UI.SetKeyboardFocus(fl);
      }
      else
      {
         RefocusDefault();
      }
   }

   // <api.png>
   static UpdateWindowTitle(String _fileName) {
      Debug("UpdateWindowTitle to \""+(_fileName + " -- " + Global.VERSION_STRING)+"\".");
      Viewport.caption = _fileName + " -- " + Global.VERSION_STRING;
   }

   // <api.png>
   static GetUISongOffset() {
      return current_song.ui_song_offset;
   }

   // <method.png>
   static NotPlaying(String _cmd) : boolean {
      explain "Check whether the replay is currently active and show an error dialog if this is the case.";

      if(replay.b_playing)
      {
         Dialogs.ShowErrorDialog("Error", "Command <"+_cmd+"> not available during replay");
         return false;
      }
      return true;
   }

   // --------------------------------------------------------------------------
   // - cmd_file_xxx
   // --------------------------------------------------------------------------
   static String file_open_suggested_file = "";
   static String file_save_suggested_file = "";
   static StringArray file_filter_names = [ "Synergy song (*.flx)" ];
   static StringArray file_filter_strings = [ "*.flx" ];


   // <method.png>
   static cmd_file_quit() {

      // debug: force soft crash
      // String s <= null;
      // trace s.length;

      // debug: force hard crash
      //  (note) hard crash code needs to be compiled into _Debug() method
      // _Debug();

      dialog_quit.run();
   }

   // <method.png>
   static cmd_file_quit_2() {

      if(STConfig.b_push)
         push.disconnect();

      root_form.beginExit();
   }

   // <method.png>
   static cmd_file_new_dlg() {
      dialog_newsong.run();
   }

   // <method.png>
   static cmd_file_new() {

      AudioLiveRecForm.ClearCaches();

      // Called by dialog_newsong
      local File f;
      local String templPathNameOrig = STConfig.project_rootpath + "/" + STConfig.newproject_template_filename;
      local String templPathName <= Utils.ToNativePathName(templPathNameOrig);
      if(f.openLocal(templPathName, IOS_IN))
      {
         // Template file exists, use it
         f.close();
         cmd_file_load(templPathNameOrig);
         return;
      }

      cmd_file_new_2();

      current_song.song_markers.add(384);
      current_song.song_markers.add(0);
      current_song.song_length = current_song.ppq * 4;

      // (virtual) device aliases may have changed
      MIDI.UpdateOutDeviceNames();
      MIDI.RebuildAllCtlNames();
      root_form.updateSongWidgets();

      MIDI.StartMIDITimer();

      UpdateWindowTitle("[new song]");

      UI.RedrawAll();
   }

   // <method.png>
   static cmd_file_new_2() {
      if(Configuration.debugLevel >= 2)
         Debug2("cmd_file_new_2: ENTER");

      if(!b_initializing)
      {
         if(Configuration.debugLevel >= 2)
            Debug2("cmd_file_new_2: StopMIDITimer");
         MIDI.StopMIDITimer();
      }

      replay.stopReplay(false, true/*bAllowPanic*/);

      cmd_file_new_2b();
   }

   // <method.png>
   static =replay= cmd_file_new_2b() {
      cmd_file_new_2b_audiomtx();
   }

   static =audio= cmd_file_new_2b_audiomtx() {
      // (note) replay/audio processing must have been stopped at this point

      file_save_suggested_file = "";

      // Re-initialize song
      InitSong();

      root_form.handleInitNewSong();

      if(Configuration.debugLevel >= 2)
         Debug2("cmd_file_new_2b: 3");

      replay.resetNodes(false/*bSoft*/);

      BidiHandleSelectOrEditScene();

      // (note) do NOT restart MIDI timer because this fxn is also called by LoadSong
   }

   // <method.png>
   static LoadSong(String _fileName) : boolean {

      // (note) MIDI timer + Audio devices must be stopped before calling this
      local String fileName <= Utils.ToNativePathName(_fileName);

      Debug("LoadSong(fileName=\""+fileName+"\")");

      boolean ret = false;

      if(SongFileReader.Load(fileName))
      {
         file_open_suggested_file = fileName;

         Success("Project loaded from file \""+fileName+"\".");

         UpdateWindowTitle(_fileName);

         replay.resetNodes(false/*bSoft*/);

         // Update/Restore BPM in case Remote ignored song load request due to unsaved changed
         SysEx.QueueSendSeqTempoSet(current_song.bpm, current_song.ppq);

         ret = true;
      }
      else
      {
         // Failed
         cmd_file_new_2();
         MIDI.RestartMIDITimer();
         ret = false;
      }

      // Update widgets
      root_form.updateSongWidgets();

      UI.RedrawAll();

      UI.ActivateFloatingLayer(null);

      // Show song comment if not empty
      if(STConfig.b_autoshowcomment)
      {
         if(!current_song.author_comment.isBlank())
         {
            dialog_songcomment.run();
         }
      }

      BidiHandleSelectOrEditScene();

      return ret;
   }

   // <method.png>
   static cmd_file_load(String _forceFilename) : boolean {

      boolean bLoaded = false;

      Debug2("cmd_file_load: fileName=\""+_forceFilename+"\".");

      String *fileName;
      if(null == _forceFilename)
      {
         String suggestedPath, suggestedFile;
         Utils.SplitPathname(file_open_suggested_file, suggestedPath, suggestedFile);

         fileName <= UI.OpenFileDialog(suggestedPath,
                                       suggestedFile,
                                       "Load song",
                                       file_filter_names, file_filter_strings,
                                       false, false
                                       );
      }
      else
      {
         // // if(!(_forceFilename & ":") && !_forceFilename.startsWith("/") && !st2::program_directory.isBlank())
         if(Utils.IsRelativePath(_forceFilename) && !st2::program_directory.isBlank())
         {
            fileName <= st2::program_directory + "/" + _forceFilename;
         }
         else
         {
            fileName <= _forceFilename;
         }
      }

      if(Configuration.debugLevel >= 2)
         Debug("cmd_file_load: trying to load file \""+fileName+"\".");

      if(fileName != null)
      {
         b_loading = true;

         cmd_file_new_2(); // stops MIDI timer

         if(!LoadSong(fileName))
         {
            // Show error dialog
            InfoDialog d;
            d <= InfoDialog.NewError("Load Error",
                                     "Failed to load song from file \""+fileName+"\".",
                                     null);
            d.showCentered();
         }
         else
         {
            // OK, song loaded
            file_open_suggested_file = fileName;
            file_save_suggested_file = fileName;

            // Notify audio process
            SysEx.QueueSendProjectLoad(current_song.song_name);

            bLoaded = true;
         }

         MIDI.StartMIDITimer();

         // ? select first node
         //  (note) currently needed to get rid of some stale node ptrs
         root_form.updatePipePages();

         // (virtual) device aliases may have changed
         MIDI.UpdateOutDeviceNames();

         MIDI.RebuildAllCtlNames();

         MIDI.UpdateMIDIInEnableParam();  // Enable/disable (N)RPN parser according to MIDI synth profile(s)
         MIDI.UpdateMIDIParamMode();      // configure (N)RPN MSB/LSB I/O mode according to MIDI synth profile(s)
         MIDI.UpdateMIDICCPerfLSB();      // configure 14bit performance controller CCs according to MIDI synth profile(s)
         MIDI.UpdateMIDIOverflowBuffers();

         if(STConfig.b_enable_midi)
         {
            MIDI.UpdateMIDIPipeDevFlags(current_pipe_root);  // for param mode
         }

         root_form.updateReplayTimeLabel(false/*bForceUpdate*/); // update songpos

         b_loading = false;

         BidiHandleSelectOrEditScene();
      }

      return bLoaded;
   }

   // <method.png>
   static cmd_file_save_nodlg(String _forceFileName) {

      // // if(!(_forceFileName & ":") && !_forceFileName.startsWith("/") && !st2::program_directory.isBlank())
      if(Utils.IsRelativePath(_forceFileName) && !st2::program_directory.isBlank())
      {
         file_save_suggested_file = st2::program_directory + "/" + _forceFileName;
      }
      else
      {
         file_save_suggested_file = _forceFileName;
      }

      cmd_file_save();
   }

   // <method.png>
   static cmd_file_save() {

      Debug("cmd_file_save: suggestedFile=\""+file_save_suggested_file+"\".");

      local File f;
      if(f.openLocal(Utils.ToNativePathName(file_save_suggested_file), IOS_IN))
      {
         f.close();

         dialog_overwritesong.run(file_save_suggested_file);
      }
      else
      {
         cmd_file_saveas_2(file_save_suggested_file, false/*bAutosave*/);
      }
   }

   // <method.png>
   static cmd_file_saveas_2(String _fileName, boolean _bAutosave) {

      local String fileName = Utils.ToNativePathName(_fileName);
      if(SongFileWriter.Save(fileName))
      {
         if(!_bAutosave)
         {
            file_save_suggested_file = fileName;
         }

         trace "[...] Project saved to file \""+fileName+"\".";

         Success("Saved project to file \""+fileName+"\".");

         if(!_bAutosave)
         {
            UpdateWindowTitle(_fileName);

            // Notify audio process
            SysEx.QueueSendProjectNameSet(current_song.song_name);
            SysEx.QueueSendProjectSave(current_song.song_name);
         }

      }
      else
      {
         Error("Failed to save song to file \""+fileName+"\".");
      }
   }

   // <method.png>
   static cmd_file_saveas_1() {
      Debug("Global::cmd_file_saveas_1");
      String dlgFileName;
      if(file_save_suggested_file.isBlank())
      {
         dlgFileName <= "unknown.flx";
      }
      else
      {
         dlgFileName <= file_save_suggested_file;
      }

      local String suggestedPath, suggestedFile;
      Utils.SplitPathname(dlgFileName, suggestedPath, suggestedFile);

      local String fileName <= UI.SaveFileDialog(suggestedPath,
                                                 suggestedFile,
                                                 "Save song",
                                                 file_filter_names, file_filter_strings,
                                                 false
                                                 );

      trace "[...] cmd_file_saveas: saving song to selected file \""+#(fileName)+"\".";

      if(fileName != null)
      {
         if(!fileName.endsWith(".flx"))
         {
            fileName.append(".flx");
         }

         local File f;
         fileName <= Utils.ToNativePathName(fileName);
         if(f.openLocal(fileName, IOS_IN))
         {
            f.close();

            dialog_overwritesong.run(fileName);
         }
         else
         {
            cmd_file_saveas_2(fileName, false/*bAutosave*/);
         }
      }
   }


   // --------------------------------------------------------------------------
   // - cmd_song_xxx
   // --------------------------------------------------------------------------

   // <method.png>
   static cmd_song_editcomment() {
      dialog_songcomment.run();
   }

   // <method.png>
   static cmd_song_panic() {
      SoftPanic();
   }

   // <method.png>
   static cmd_song_stop() {
      if(replay.b_playing)
      {
         replay.stopReplay(true/*bAllowBookmark*/, true/*bAllowPanic*/);
         SoftPanic();
      }
      else
      {
         Panic();
      }
   }

   // <method.png>
   static cmd_config_save() {
      ConfigIO.Save();
   }

   // last CMD tag (do not remove)

   // <method.png>
   static call_cmd_delegate(String _cmdName)  {
      Debug("calling cmd delegate \""+_cmdName+"\".");
      delegate (_cmdName) ();
   }

   // <method.png>
   static HandleAutosave() {

      if((true == STConfig.b_autosave) || ((maybe == STConfig.b_autosave) && !replay.b_playing))
      {
         int ms = milliSeconds();

         int secDelta = (ms - last_autosave_timestamp) / 1000;

         if(secDelta >= (60 * mathClampi(STConfig.autosave_interval, 1, 30)))
         {
            Debug("Global::HandleAutosave");

            last_autosave_timestamp = ms;

            int saveFileNr = 0;

            local String currentFileNrStr;
            local String fileNrFile = GetAutosaveDirPrefix() + AUTOSAVE_CURRENT_FILENR_FILE;

            if(currentFileNrStr.loadLocal(fileNrFile, true/*bRemoveCR*/))
            {
               currentFileNrStr.trim();
               saveFileNr = currentFileNrStr;
               saveFileNr = mathWrapi(saveFileNr + 1, 0, mathClampi(STConfig.num_autosave_files, 1, 100));
            }

            currentFileNrStr = saveFileNr;
            currentFileNrStr.saveLocal(fileNrFile);

            local String autosaveFilename = GetAutosaveDirPrefix() + AUTOSAVE_FILENAME_PREFIX + currentFileNrStr + ".flx";

            Debug("auto-saving to \""+autosaveFilename+"\"");

            cmd_file_saveas_2(autosaveFilename, true/*bAutosave*/);
         }
      }

   }

   // <method.png>
   static ASCIIBackButton(Button _bt) {
      _bt.setIcon(null);
      // // _bt.setCaption(tcchar(174)+"-");
      _bt.setCaption("<");
      _bt.setPadTop(0 );
      _bt.setPadBottom(0 );
      _bt.setAlignment(Layout.CENTERY);
   }

   // <method_find.png>
   static FindSampleUIDs(IntArray _retSmpUIDs) {
      ST_Song *song;
      foreach song in all_songs
      {
         song.findSampleUIDs(_retSmpUIDs);
      }
   }

   static method CreateEqTempFreqTable() {
      // 12-tET
      FloatArray r <= eqtemp_freq_table;
      float i = 0;
      r.alloc(129);
      loop(129)
      {
         r.add( ((440.0f/32.0f)*exp( ((i-9.0)/12.0)*log(2.0) )) );
         i++;
      }
   }

   static method NoteToFreq(float _note) : float {
      float r;
      r = eqtemp_freq_table.get(int(_note));
      if(_note < 128)
      {
         float r2 = eqtemp_freq_table.get(int(_note)+1);
         r += frac(_note) * (r2-r);
      }
      return r;
   }

   static method FreqToNote(float _freq) : float {
      int r = 0;
      loop(eqtemp_freq_table.numElements)
      {
         if(eqtemp_freq_table.get(r) > _freq)
         {
            break;
         }
         r++;
      }
      return (r - 1);
   }

   static method FreqToNoteWithFrac(float _freq) : float {
      int r = 0;
      loop(eqtemp_freq_table.numElements)
      {
         if(eqtemp_freq_table.get(r) >= _freq)
         {
            if((r > 0) && (eqtemp_freq_table.get(r) > _freq))
            {
               float off = eqtemp_freq_table.get(r) - eqtemp_freq_table.get(r - 1);
               r--;
               float cents = (_freq - eqtemp_freq_table.get(r)) / off;
               return (r + cents);
            }
            return r;
         }
         r++;
      }
      return (r - 1);
   }

   public static =replay= method SetARPatternClipboard(AR_Pattern _pat) {
      ar_pattern_clipboard = _pat;
   }

   // relocated from node_analogrytm/NodeAnalogRytm when moving AR code to TSL
   public static =replay= method GetARPatternClipboard() : AR_Pattern {
      if(2 == ar_pattern_clipboard.currentDataIdx)
      {
         return ar_pattern_clipboard;
      }
      return null;
   }

   // <method_get.png>
   public static GetPipeClipboardFileName() : String {
      return STConfig.temp + "/synergy_pipe_clipboard.dat";
   }

   // <method_get.png>
   public static GetSubSongClipboardFileName() : String {
      return STConfig.temp + "/synergy_subsong_clipboard.dat";
   }

   // <ui_handle.png>
   public static TryEditSoundAnalogRytm(STX_MIDIOutDevice _outDev,
                                        int               _outCh,
                                        MIDISynthProfile  _msp,
                                        int               _noteIdxHint
                                        ) : boolean {
      // Find + edit first NodeAnalogRytm instance when track outputs to AR
      if(_msp.midi_profile_id & "analogrytm")    // see "midi_synth_profiles/elektron_analog_rytm_track.msp"
      {
         local Integer retPipeIdx;
         local Integer retNodeIdx;
         //  (note) node_analogrytm.tsl may not be loaded, cannot find by Class reference (must use name instead)
         Node n <= current_song.findFirstNodeByClassName("NodeAnalogRytm", retPipeIdx, retNodeIdx);
         if(null != n)
         {
            // Remember this node (bookmark A)
            PageNode pgNode <= root_form.pg_node;
            pgNode.handlePipeNodeASet();

            PagePipeRoot pgPipeRoot <= root_form.pg_piperoot;
            pgPipeRoot.selectPipeAndNodeByIdx(retPipeIdx, retNodeIdx);
            root_form.showPagePipeMap();
            pgPipeRoot.handleEditPipeNode();

            // Remember AR node (bookmark B)
            //  => can jump back to TrigSeq with lctrl-x z
            pgNode.handlePipeNodeBSet();

            // Show Kit dialog
            n.nodeHandleEditSound(_outCh/*trackIdxHint*/, _noteIdxHint);
            return true;
         }
      }
      return false;
   }

   // <ui_handle.png>
   public static TryEditSoundSysEx(STX_MIDIOutDevice _outDev,
                                   int               _outCh,
                                   MIDISynthProfile  _msp,
                                   int               _noteIdxHint
                                   ) : boolean {
      // (todo) find SysEx editor when track outputs to MIDI
      if(_msp.hasDataClass())
      {
         MIDI.LazyAccessSynthEditor(_msp.midi_profile_id);
         MIDISynthProfileData profData <= MIDI.GetMIDISynthProfileData(_msp.midi_profile_id);
         if(null != profData)
         {
            // Remember this node (bookmark A+B)
            PageNode pgNode <= root_form.pg_node;
            pgNode.handlePipeNodeASet();
            pgNode.handlePipeNodeBSet();

            root_form.showPage(RootForm.PAGE_SYSEX, false/*bAllowHistory*/);
            PageSysEx pgSysEx <= root_form.pg_sysex;
            return pgSysEx.selectSynthByOutDevNameAndCh(_outDev.getAliasOrDeviceName(),
                                                        _outCh
                                                        );
         }
      }
      return false;
   }

   // <ui_handle.png>
   public static TryEditSoundSample(STX_MIDIOutDevice _outDev,
                                    int               _outCh,
                                    MIDISynthProfile  _msp,
                                    int               _noteIdxHint
                                    ) : boolean {
      // (todo) edit sample in Eureka when track outputs to "vst_?"
      int vstIdx = _outDev.getVSTDevIdx();
      trace "[dbg] TryEditSoundSample: vstIdx="+vstIdx+" noteIdxHint="+_noteIdxHint;
      if(vstIdx >= 0)
      {
         SysEx.QueueSendTrackShowByMIDIPort(vstIdx, _outCh, true/*bShowTrackPage*/, true/*bEditFirstMod*/, _noteIdxHint);
         return true;
      }
      return false;
   }

   // <ui_handle.png>
   public static TryEditSound(STX_MIDIOutDevice _outDev,
                              int               _outCh,
                              MIDISynthProfile  _msp,
                              int               _noteIdxHint
                              ) : boolean {

      if(TryEditSoundAnalogRytm(_outDev, _outCh, _msp, _noteIdxHint))
         return true;

      if(TryEditSoundSysEx(_outDev, _outCh, _msp, _noteIdxHint))
         return true;

      if(TryEditSoundSample(_outDev, _outCh, _msp, _noteIdxHint))
         return true;

      return false;
   }

}
