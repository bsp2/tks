// ----
// ---- file   : CtlIOPort.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2017-2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- created: 16Sep2017
// ---- changed: 17Sep2017, 21Sep2017, 02Nov2017, 09Nov2017, 04Jan2018, 07Mar2018, 02May2018
// ----          05May2018, 23May2018, 27May2018, 08Jun2018, 17Jun2018, 02Oct2019, 06Apr2020
// ----          29Mar2021, 30Mar2021
// ----
// ----
// ----

module MCtlIOPort;

use namespace ui;
use namespace st2;


// <class.png>
class CtlIOPort : MIDIMapDefs {
   // (note) used by NodeModular

   String  id;
   int     dev_idx;
   byte    dev_ch;  // -1=all ch (0..15 in NodeScript, can be -1 in NodeSeq)
   boolean b_enable;
   MIDIMapEventType mm_type;

   ActiveNoteState active_note_state;


   // <method.png>
   public method init() {
   }

   // <method.png>
   public =replay= method copyFrom(CtlIOPort _o) {
      id       = _o.id;
      dev_idx  = _o.dev_idx;
      dev_ch   = _o.dev_ch;
      b_enable = _o.b_enable;
      mm_type.copyFrom(_o.mm_type);
   }

   // <method_set.png>
   public =replay= method setId(String _s) : boolean {
      if(!_s.isBlank())
      {
         if(-1 == _s.charsetIndexOf("!\"§$%&/\\()=?`´\'#*+~-@|,.:;^°", 0))
         {
            id = _s;
            return true;
         }
      }
      return false;
   }

   // <method_set.png>
   public =replay= method setDevIdx(int _devIdx) {
      dev_idx = _devIdx;
   }

   // <method_set.png>
   public =replay= method setDevCh(int _devCh) {
      dev_ch = _devCh;
   }

   // <method_set.png>
   public =replay= method setEnable(boolean _bEnable) {
      b_enable = _bEnable;
   }

   // <save.png>
   public method saveState(Stream ofs) {
      ofs.i16 = 1; // Version

      Utils.WriteString(ofs, id);
      ofs.i32 = dev_idx;
      ofs.i8  = dev_ch;
      ofs.i8  = b_enable;
      ofs.i8  = mm_type.type;
      ofs.i16 = mm_type.ext_type;
   }

   // <load.png>
   public method loadState(Stream ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      short ver = ifs.i16;

      if(ver >= 1)
      {
         Utils.ReadString(ifs, id);
         dev_idx  = ifs.i32;
         dev_ch   = ifs.s8;
         b_enable = ifs.b8;
         mm_type.type     = ifs.u8;
         mm_type.ext_type = ifs.u16;

         _outDevUseCount.inc(dev_idx);
         dev_idx = _outDevIdxMap.get(dev_idx);

         return true;
      }

      return false;
   }

   // <replay.png>
   public method updateActiveNoteState(MIDIPipeFrame _frIn) {
      if(b_enable)
      {
         active_note_state.process(_frIn, dev_idx, dev_ch);
      }
   }
}
