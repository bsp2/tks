// ----
// ---- file   : NTS_ImportARDialog.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- license: (c) 2019-2023 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 24Oct2019
// ---- changed: 25Oct2019, 30Oct2019, 25Sep2023, 04Oct2023, 30Oct2023, 28Nov2023, 01Dec2023
// ----
// ----
// ----

module MNTS_ImportARDialog;

use namespace ui;


// <class.png>
class NTS_ImportARDialog extends Dialog, ActionProvider, MMTListener {

   define String ACTION_AR_IMPORT;
   define String ACTION_AR_CANCEL;

   protected XMLForm *xfm;

   protected ActionConsumer *recipient;

   public AR_Pattern ar_import_pattern;
   public boolean b_ar_import_pattern_valid;

   protected CheckBox *cb_masterlen;
   protected CheckBox *cb_chromatic;
   protected CheckBox *cb_singlech;
   protected CheckBox *cb_trc;
   protected CheckBox *cb_velocities;
   protected CheckBox *cb_accents;
   protected CheckBox *cb_note_durations;
   protected CheckBox *cb_micro_timings;
   protected CheckBox *cb_retrigs;
   protected CheckBox *cb_plocks;
   protected CheckBox *cb_plocks_reset;
   protected CheckBox *cb_nrpn;

   protected Button *bt_import;
   protected Button *bt_cancel;


   // <ui_init.png>
   public method init() : boolean {

      initDialog();

      xfm <= XMLForm.New_PakFile("NTS_ImportARDialog.xfm");
      if(null == xfm)
      {
         return false;
      }

      xfm.autoResolveIds(this);

      initWindow(xfm,
                 "Import Analog Rytm Pattern",
                 100, 100,
                 640, 240
                 );

      return true;
   }

   public method setRecipient(ActionConsumer _ac) {
      recipient <= _ac;
   }

   public virtual getProvidedActionNames() : StringArray {
      return [ACTION_AR_IMPORT, ACTION_AR_CANCEL];
   }

   public virtual isPopup() : boolean {
      return true;
   }

   public virtual isModal():boolean {
      return true;
   }

   public virtual isResizable() : boolean {
      return false;
   }

   // <ui_show.png>
   protected virtual preShow() {

      setWindowTitle("Import Analog Rytm Pattern");

      if(!b_layer_postinit_done)
      {
         resizeToMinimum();
      }

      // Make a copy of the current pattern clipboard
      AR_Pattern arPat <= /*NodeAnalogRytm*/Global.GetARPatternClipboard();
      if(null != arPat)
      {
         ar_import_pattern = arPat;
         b_ar_import_pattern_valid = true;
      }
      else
      {
         b_ar_import_pattern_valid = false;
      }

      bt_import.setEditable(b_ar_import_pattern_valid);

      Dialog::preShow();
   }

   // <ui_show.png>
   protected virtual postShow() {
      Dialog::postShow();
      UI.SetKeyboardFocus(b_ar_import_pattern_valid ? bt_import : bt_cancel);

      if(!b_ar_import_pattern_valid)
         Global.Warning("ImportAR: clipboard is empty (select pattern in AnalogRytm node)");
   }

   // <ui_handle.png>
   protected method handleCancel() {
      hide();

      if(recipient instanceof ActionConsumer)
      {
         StringAction ac <= Action.New(getProvidedActionAlias(ACTION_AR_CANCEL), this);
         recipient.consumeAction(ac);
         // Note: Do not add code below this line since the dialog instance may have been deleted by the recipient!
      }
   }

   // <ui_handle.png>
   protected method handleImport() {
      hide();

      if(recipient instanceof ActionConsumer)
      {
         StringAction ac <= Action.New(getProvidedActionAlias(ACTION_AR_IMPORT), this);
         recipient.consumeAction(ac);
         // Note: Do not add code below this line since the dialog instance may have been deleted by the recipient!
      }
   }

   // <method_get.png>
   public method doMasterLen() : boolean {
      return cb_masterlen.isSelected();
   }

   // <method_get.png>
   public method doChromatic() : boolean {
      return cb_chromatic.isSelected();
   }

   // <method_get.png>
   public method doSingleCh() : boolean {
      return cb_singlech.isSelected();
   }

   // <method_get.png>
   public method doConditional() : boolean {
      return cb_trc.isSelected();
   }

   // <method_get.png>
   public method doVelocities() : boolean {
      return cb_velocities.isSelected();
   }

   // <method_get.png>
   public method doAccents() : boolean {
      return cb_accents.isSelected();
   }

   // <method_get.png>
   public method doDurations() : boolean {
      return cb_note_durations.isSelected();
   }

   // <method_get.png>
   public method doMicroTimings() : boolean {
      return cb_micro_timings.isSelected();
   }

   // <method_get.png>
   public method doRetrigs() : boolean {
      return cb_retrigs.isSelected();
   }

   // <method_get.png>
   public method doPLocks() : boolean {
      return cb_plocks.isSelected();
   }

   // <method_get.png>
   public method doResetPLocks() : boolean {
      return cb_plocks_reset.isSelected();
   }

   // <method_get.png>
   public method doNRPN() : boolean {
      return cb_nrpn.isSelected();
   }

   // <ui_kbd.png>
   public virtual onKey(Key _key) : boolean {
      switch(_key.pressed)
      {
         case VKEY_ESCAPE:
            handleCancel();
            return true;

         case VKEY_RETURN:
         case VKEY_SPACE:
            handleImport();
            return true;

         default:
            break;
      }
      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _ac) : boolean {
      String name=_ac.getActionName();

      switch(name)
      {
         case "ok":
            handleImport();
            break;

         case "cancel":
            handleCancel();
            break;
      }

      switch(@(_ac.getActionProvider()))
      {
         case @(cb_chromatic):
            if(cb_chromatic.isSelected())
            {
               cb_singlech.setSelected(false);
               cb_singlech.setEditable(false);
               cb_singlech.redraw();
            }
            else
            {
               cb_singlech.setEditable(true);
               cb_singlech.redraw();
            }
            return true;

         case @(cb_singlech):
            if(cb_singlech.isSelected())
            {
               cb_chromatic.setSelected(false);
               cb_chromatic.setEditable(false);
               cb_chromatic.redraw();
            }
            else
            {
               cb_chromatic.setEditable(true);
               cb_chromatic.redraw();
            }
            return true;

         case @(bt_import):
             handleImport();
             return true;

         case @(bt_cancel):
             handleCancel();
             return true;
      }

      return true;
   }

}
