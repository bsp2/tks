// ----
// ---- file   : AppLookAndFeel.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2018-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 28Nov2018, 29Nov2018, 30Nov2018, 01Dec2018, 02Dec2018, 06Dec2018, 10Jan2019
// ----          08Jun2019, 20Sep2019, 24Sep2019, 04Oct2019, 05Oct2019, 23Oct2019, 25Oct2019
// ----          01Nov2019, 07Apr2020, 08Apr2020, 12Apr2020, 13Apr2020, 14Apr2020, 15Apr2020
// ----          16Apr2020, 17Apr2020, 23Apr2020, 24Apr2020, 06May2020, 08May2020, 09May2020
// ----          13May2020, 07Nov2020, 01Feb2021, 16Apr2021, 20Apr2021, 15May2021, 02Jun2021
// ----          20Jun2021, 25Jul2021, 28Jul2021, 12Feb2022, 21Feb2022, 22Feb2022, 18Mar2022
// ----          08Apr2022, 12Aug2022, 29Sep2022, 30Sep2022, 05Oct2022, 04Mar2023, 28Jul2023
// ----          01Nov2023, 02Nov2023, 02Oct2024, 07Jan2025, 24Jan2025, 26Jan2025
// ----
// ----
// ----

module MAppLookAndFeel;

use namespace ui;
use namespace st2;


// <class.png>
abstract class AppLookAndFeel : AppLookAndFeelDefs {

   IntArray colors;

   boolean b_arranger_timeline_border;      // 1:draw border around timeline area, 0:no border
   boolean b_arranger_timeline_clip_border; // 1:draw border around clips, 0:flat border (CLIP_START_FLAT)

   // NodeTracker PatternView colors
   IntArray nt_pv_colors_normal;
   IntArray nt_pv_colors_normal_ghost;
   IntArray nt_pv_colors_wrapped;
   IntArray nt_pv_colors_wrapped_ghost;
   IntArray nt_pv_colors_normal_timing;
   IntArray nt_pv_colors_normal_timing_ghost;
   IntArray nt_pv_colors_wrapped_timing;
   IntArray nt_pv_colors_wrapped_timing_ghost;

   // Default colors for EditTrackLayout->Cel colors->Generate
   //  (note) this array must at least contain the default-type a/b colors
   //  (note) also see NT_TEL.PAL_xxx
   IntArray nt_celcolor_palette;

   IntArray sceneoverlay_group_bg_tint;
   byte     sceneoverlay_bg_alpha;

   float nt_pv_overlay_highlight_row_timeout_alpha_scl;
   float statusbar_timelabel_tint_alpha_scl;
   float trig_seq_replay_cursor_ol_width;

   IntArray tv_pipeornode_solo_state_bgtints; // see MIDIPipe.h for state indices (play, mute, solo)
   IntArray tv_pipeornode_solo_state_fgtints; // used in PagePipeRoot and PagePipe
   IntArray tv_pipeornode_mute_state_bgtints;
   IntArray tv_pipeornode_mute_state_fgtints;

   boolean b_bezieredit_draw_tabfocus_border;

   boolean b_ascii_back_buttons;

   String pipemap_pipe_icon_name;

   boolean b_dark_modular;
   boolean b_modular_roundbutton_polygonsmooth;



   public method initAppLookAndFeel() {
      initColors();
      initNodeTrackerPatternViewColors();

      b_bezieredit_draw_tabfocus_border = false;

      pipemap_pipe_icon_name = "pipe";
   }

   public method getName() : String {
      return "?";
   }

   protected method initColors() {
      colors.alloc(TOTAL_NUM_COLORS);
      colors.useAll();
      colors.fill(#ffff00ff);
   }

   protected method initNodeTrackerPatternViewColors() {
   }

   public method getColor(int _colorIndex) : int {
      return colors.get(_colorIndex);
   }

   public method getColorAlpha(int _colorIndex, byte _alpha) : int {
      int c32 = colors.get(_colorIndex);
      return (c32&0x00ffffff) | ((_alpha&255)<<24);
   }

   public method getTintedColor(int _lnfIdx, int _tint32) : int {
      int c32 = colors.get(_lnfIdx);
      if(_tint32) // Colorize ?
      {
         c32 = UI.MixColor32(c32, 0xff000000 | (_tint32&0x00FFFFFF), ((_tint32>>24)&255)/255.0);
      }
      return c32;
   }

   public method lnfGetColor(int _lnfIdx) : int {
      return UI.lnf_colors.get(_lnfIdx);
   }

   public method lnfGetTintedColor(int _lnfIdx, int _tint32) : int {
      int c32 = UI.lnf_colors.get(_lnfIdx);
      if(_tint32) // Colorize ?
      {
         c32 = UI.MixColor32(c32, 0xff000000 | (_tint32&0x00FFFFFF), ((_tint32>>24)&255)/255.0);
      }
      return c32;
   }

   public method setColor(int _colorIndex, int _c32) {
      // for user defined color tweaks (e.g. when color grading is enabled)
      colors[_colorIndex] = _c32;
   }

   protected method calcPatternViewColors(int bg32, C0, C1, C2, C3, C4, C5, C6, TV_C2, TV_C3, TV_C4, TV_C5) {

      nt_pv_colors_normal = [ C0, C1, C2, C3, C4, C5, C6 ];

      nt_pv_colors_normal_ghost = [ UI.MixColor32(C0, bg32, STConfig.node_tracker_ghost_dim),
                                    UI.MixColor32(C1, bg32, STConfig.node_tracker_ghost_dim),
                                    UI.MixColor32(C2, bg32, STConfig.node_tracker_ghost_dim),
                                    UI.MixColor32(C3, bg32, STConfig.node_tracker_ghost_dim),
                                    UI.MixColor32(C4, bg32, STConfig.node_tracker_ghost_dim),
                                    UI.MixColor32(C5, bg32, STConfig.node_tracker_ghost_dim),
                                    UI.MixColor32(C6, bg32, STConfig.node_tracker_ghost_dim)
                                    ];

      // before song start/after song end:
      nt_pv_colors_wrapped = [ UI.MixColor32(C0, bg32, STConfig.node_tracker_wrap_dim),
                               UI.MixColor32(C1, bg32, STConfig.node_tracker_wrap_dim),
                               UI.MixColor32(C2, bg32, STConfig.node_tracker_wrap_dim),
                               UI.MixColor32(C3, bg32, STConfig.node_tracker_wrap_dim),
                               UI.MixColor32(C4, bg32, STConfig.node_tracker_wrap_dim),
                               UI.MixColor32(C5, bg32, STConfig.node_tracker_wrap_dim),
                               UI.MixColor32(C6, bg32, STConfig.node_tracker_wrap_dim)
                               ];

      float ghostDimWrap = STConfig.node_tracker_ghost_wrap_dim;
      nt_pv_colors_wrapped_ghost = [ UI.MixColor32(C0, bg32, ghostDimWrap),
                                     UI.MixColor32(C1, bg32, ghostDimWrap),
                                     UI.MixColor32(C2, bg32, ghostDimWrap),
                                     UI.MixColor32(C3, bg32, ghostDimWrap),
                                     UI.MixColor32(C4, bg32, ghostDimWrap),
                                     UI.MixColor32(C5, bg32, ghostDimWrap),
                                     UI.MixColor32(C6, bg32, ghostDimWrap)
                                     ];

      // Timing view:
      nt_pv_colors_normal_timing = [ C0, C1,
                                     UI.MixColor32(TV_C2, bg32, STConfig.node_tracker_timing_dim),
                                     UI.MixColor32(TV_C3, bg32, STConfig.node_tracker_timing_dim),
                                     UI.MixColor32(TV_C4, bg32, STConfig.node_tracker_timing_dim),
                                     UI.MixColor32(TV_C5, bg32, STConfig.node_tracker_timing_dim),
                                     C6
                                     ];

      float ghostDimTiming = STConfig.node_tracker_ghost_timing_dim;
      nt_pv_colors_normal_timing_ghost = [ C0, C1,
                                           UI.MixColor32(TV_C2, bg32, ghostDimTiming),
                                           UI.MixColor32(TV_C3, bg32, ghostDimTiming),
                                           UI.MixColor32(TV_C4, bg32, ghostDimTiming),
                                           UI.MixColor32(TV_C5, bg32, ghostDimTiming),
                                           C6
                                           ];

      float ghostDimWrapTiming = STConfig.node_tracker_ghost_wrap_timing_dim;
      nt_pv_colors_wrapped_timing = [ UI.MixColor32(C0,    bg32, STConfig.node_tracker_wrap_dim),
                                      UI.MixColor32(C1,    bg32, STConfig.node_tracker_wrap_dim),
                                      UI.MixColor32(TV_C2, bg32, STConfig.node_tracker_wrap_timing_dim),
                                      UI.MixColor32(TV_C3, bg32, STConfig.node_tracker_wrap_timing_dim),
                                      UI.MixColor32(TV_C4, bg32, STConfig.node_tracker_wrap_timing_dim),
                                      UI.MixColor32(TV_C5, bg32, STConfig.node_tracker_wrap_timing_dim),
                                      UI.MixColor32(C6,    bg32, STConfig.node_tracker_wrap_dim)
                                      ];

      nt_pv_colors_wrapped_timing_ghost = [ UI.MixColor32(C0,    bg32, ghostDimTiming),
                                            UI.MixColor32(C1,    bg32, ghostDimTiming),
                                            UI.MixColor32(TV_C2, bg32, ghostDimWrapTiming),
                                            UI.MixColor32(TV_C3, bg32, ghostDimWrapTiming),
                                            UI.MixColor32(TV_C4, bg32, ghostDimWrapTiming),
                                            UI.MixColor32(TV_C5, bg32, ghostDimWrapTiming),
                                            UI.MixColor32(C6,    bg32, ghostDimTiming)
                                            ];
   }
}


