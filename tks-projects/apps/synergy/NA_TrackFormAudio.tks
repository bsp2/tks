// ----
// ---- file   : NA_TrackFormAudio.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2017-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 11Apr2017
// ---- changed: 12Apr2017, 13Apr2017, 14Apr2017, 15Apr2017, 16Apr2017, 17Apr2017, 19Apr2017
// ----          20Apr2017, 25Apr2017, 27Apr2017, 30Apr2017, 26May2017, 14Jul2017, 15Jul2017
// ----          10Aug2017, 12Aug2017, 19Aug2017, 20Aug2017, 12Oct2017, 13Oct2017, 02Jan2018
// ----          03Jan2018, 04Jan2018, 05Jan2018, 06Jan2018, 05Apr2018, 22Jun2018, 17Nov2018
// ----          18Nov2018, 19Nov2018, 24Nov2018, 25Nov2018, 27Nov2018, 28Nov2018, 31May2019
// ----          19Aug2019, 21Sep2019, 22Sep2019, 31Oct2019, 01Nov2019, 09Nov2019, 26Apr2020
// ----          13May2021, 22May2021, 27May2021, 24Jul2021, 12Feb2022, 13Feb2022, 18Mar2022
// ----          11Aug2022, 12Aug2022, 11Feb2023, 15Mar2023, 21Sep2023, 03Oct2023, 05Oct2023
// ----          08Oct2023, 19Oct2023, 21Oct2023, 29Oct2023, 11Nov2023, 16Nov2023, 17Nov2023
// ----          02Feb2024, 03Feb2024, 22Mar2024, 24Mar2024, 02Oct2024, 16Jan2025, 26Jan2025
// ----
// ----
// ----

module MNA_TrackFormAudio;

use namespace ui;
use namespace st2;


// <class.png>
class NA_TrackFormAudio : NA_TrackForm {

   int audio_node_gid;

   ComboBox *cm_dev;
   ComboBox *cm_ch;

   PopupMenu *pm_menu;


   // <init.png>
   public method initAudio(NA_TimelineForm _parentTimeline, int _audioNodeGID) : boolean {
      parent_timeline <= _parentTimeline;
      audio_node_gid = _audioNodeGID;

      if(initPakFile("NA_TrackFormAudio.xfm"))
      {
         if(autoResolveIds(this))
         {
            setRequiredSizeX(NA_TrackForm.GetTrackSX());
            setRequiredSizeY(parent_timeline.data.getCurrentTrackSYScaled());

            postInitTrackForm();

            return true;
         }
      }

      return false;
   }

   // <method_get.png>
   public virtual isAudio() : boolean {
      return true;
   }

   // <method_get.png>
   public virtual getNodeGID() : int {
      return audio_node_gid;
   }

   // <ui_update.png>
   public method updateAudioNameTypeAndToolTip() {
      // Called during updateTrackForms()

      String ttCaption = "Audio track\n\n (note) triggers sample clips in Eureka audio host";
      tf_name.setToolTipCaption(ttCaption);

      // // lb_type.setCaption("Audio");
      // // lb_type.setToolTipCaption(ttCaption);
      // // lb_type.setToolTipFontOverride(UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED));

      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());

      if(null != track)
      {
         cm_dev.setSelectedOption(track.audio_dev_idx);
         cm_ch .setSelectedOption(track.audio_midi_ch + 1);

         updateAudioTrackNameAndDefaultSampleNamespace();

         tf_name.setText(track.audio_track_name);
      }

      tf_name.setToolTipFontOverride(UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED));

      // // if(!_bUniqueAutoDevCh)
      // // {
      // //    lb_type.setTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_AUTODEV_NOT_UNIQUE_LABEL_TINT));
      // // }
   }

   // <ui_update.png>
   public virtual updateMuteSoloLockState(NA_Track _track) {
      bt_mute.setToggleState(_track.b_mute);
      bt_solo.setToggleState(_track.b_solo);
      bt_lock.setToggleState(_track.b_lock);

      if(_track.b_mute)
      {
         bt_mute.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_MUTE_TINT));
         bt_mute.setEditable(true);
         bt_solo.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_SOLO_DEF_TINT));
      }
      else if(_track.b_solo)
      {
         bt_mute.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_MUTE_SOLO_TINT));
         bt_solo.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_SOLO_TINT));
         bt_mute.setEditable(false);
      }
      else
      {
         bt_mute.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_MUTE_DEF_TINT));
         bt_mute.setEditable(true);
         bt_solo.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_SOLO_DEF_TINT));
      }

      if(_track.b_lock)
         bt_lock.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_LOCK_TINT));
      else
         bt_lock.setBackgroundTint(app_lnf.getColor(AppLookAndFeel.COLOR_ARRANGER_TIMELINE_TRACK_LOCK_DEF_TINT));
   }

   // <ui_handle.png>
   protected virtual handleNameChanged() {
      // (todo) update track name

      // // parent_node.nodeSetName(tf_name.getText());
      // // Global.Print("Node name is \""+parent_node.nodeGetName()+"\"");
   }

   // <ui_handle.png>
   protected method handleMuteChanged() {

      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());

      if(null != track)
      {
         parent_timeline.data.toggleTrackMute(track);
         // // track.setEnableMute(bt_mute.getToggleState());

         // // parent_timeline.updateMuteSoloLockStates();

         Global.Print("Track is "+(track.b_mute ? "muted" : "unmuted"));
      }
   }

   // <ui_handle.png>
   protected virtual handleSoloChanged() {

      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());

      if(null != track)
      {
         parent_timeline.data.toggleTrackSolo(track);
         // // track.setEnableMute(false);
         // // track.setEnableSolo(bt_solo.getToggleState());

         // // parent_timeline.updateMuteSoloLockStates();

         Global.Print("Track solo is "+Utils.GetEnableString(track.b_solo));
      }
   }

   // <ui_handle.png>
   protected virtual handleLockChanged() {

      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());

      if(null != track)
      {
         track.setEnableLock(bt_lock.getToggleState());

         bt_lock.setBackgroundTint(track.b_lock ? #80ffff00 : 0);

         Global.Print("Track lock is "+Utils.GetEnableString(track.b_lock));
      }
   }

   // <ui_update.png>
   protected method updateAudioTrackNameAndDefaultSampleNamespace() {
      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());

      if(null != track)
      {
         String tt = "";

         SysExTrack sysTrack <= AudioLiveRecForm.FindTrackByDevIdxAndMidiCh(track.audio_dev_idx, track.audio_midi_ch);
         if(null != sysTrack)
         {
            // Global.Debug("updateAudioTrackNameAndDefaultSampleNamespace: found sysTrack.name=\""+sysTrack.name+"\"");
            track.audio_track_name = sysTrack.name;

            tf_name.setText(track.audio_track_name);

            if(-1 != sysTrack.smp_uid)
            {
               SysExSample sysSmp <= AudioLiveRecForm.FindSampleByUniqueId(sysTrack.smp_uid);
               if(null != sysSmp)
               {
                  track.audio_default_namespace = AudioLiveRecForm.GetSampleNamespaceNameById(sysSmp.namespace_id);

                  tt.append("default sample namespace: \""+track.audio_default_namespace+"\"");
               }
            }
         }
         else
         {
            if(SysEx.IsAudioConnected())
               track.audio_track_name = "-";
            // else: keep last seen track name from save state
         }

         tf_name.setText(track.audio_track_name);
         tf_name.setToolTipCaption(tt);

         local StringArray chOptions;
         chOptions.add("*");
         byte midiCh = 0;
         loop(16)
         {
            sysTrack <= AudioLiveRecForm.FindTrackByDevIdxAndMidiCh(track.audio_dev_idx, midiCh++);
            if(null != sysTrack)
               chOptions.add( midiCh+":"+sysTrack.name);
            else
               chOptions.add( midiCh+":-" );
         }
         cm_ch.setOptionsLong(chOptions);
      }

   }

   // <ui_handle.png>
   protected method handleDevChanged() {
      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());

      if(null != track)
      {
         track.setAudioDevIdxAndMidiCh(cm_dev.getSelectedOption(), track.audio_midi_ch);

         updateAudioTrackNameAndDefaultSampleNamespace();

         if(SysEx.IsAudioConnected())
            parent_timeline.updateAudioTimelineTrackModesFromSysEx(AudioLiveRecForm.all_tracks);

         Global.Print("Audio track MIDI port is "+track.getAudioMIDIPortString());
      }
   }

   // <ui_handle.png>
   protected method handleMidiChChanged() {
      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());

      if(null != track)
      {
         track.setAudioDevIdxAndMidiCh(track.audio_dev_idx, cm_ch.getSelectedOption() - 1);

         updateAudioTrackNameAndDefaultSampleNamespace();

         if(SysEx.IsAudioConnected())
            parent_timeline.updateAudioTimelineTrackModesFromSysEx(AudioLiveRecForm.all_tracks);

         Global.Print("xAudio track MIDI port is "+track.getAudioMIDIPortString()+" defNSP=\""+track.audio_default_namespace+"\"");
      }
   }

   // <ui_show.png>
   protected method showContextMenu() {

      pm_menu <= PopupMenu.New(this);
      PopupMenuButton *pmb;
      PopupMenu pm <= pm_menu;

      String sIcon_remove <= UI.IsDarkOrMono() ? "removes_mono" : "trashcan_sm";

      NA_State tstate <= parent_timeline.tstate;
      NA_Track track <= tstate.findTrackByGID(getNodeGID());
      int numTracks = tstate.tracks.numElements;
      int trackIdx = tstate.getTrackIdxByTrack(track);

      pmb <= pm.addDefaultButton("Move up", "atrk_moveup");
      pmb.setToolTipCaption("Move audio track up (GID="+getNodeGID()+")");
      pmb.setActive(trackIdx > 1);

      pmb <= pm.addDefaultButton("Move down", "atrk_movedown");
      pmb.setToolTipCaption("Move audio track down (GID="+getNodeGID()+")");
      pmb.setActive( (trackIdx + 1) < numTracks );

      pm.addSeparator();

      pmb <= pm.addIconButton("Delete audio track", sIcon_remove, "atrk_delete");
      pmb.setToolTipCaption("Delete audio track (GID="+getNodeGID()+")");

      pm.resizeToMinimum();
      pm.showNearMouse(0, 0);

      Global.Print("Show audio track menu");
   }

   // <ui_handle.png>
   public method handleDeleteTrack() {
      Global.Print("Delete audio track");

      parent_timeline.handleDeleteAudioTrackByNodeGID(getNodeGID());
      // (note) 'this' is now invalid
   }

   // <ui_mouse.png>
   public virtual onMouseClick(MouseEvent _ev) : boolean {
      if(_ev.isRightButton())
      {
         showContextMenu();
         return true;
      }
      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();
      StringAction *sac;

      // // trace "[>>>] NA_TrackFormAudio::consumeAction: acName="+acName+" ap="+#(ap);

      switch(@(ap))
      {
         case @(pm_menu):
            Global.Debug2("NA_TrackFormAudio: pm_menu acName="+acName);
            if(!PopupMenu.IsFocusAction(_action))
               refocusDefault();
            switch(acName)
            {
               case PopupMenu.ACTION_CANCEL:
               case "":
                  Global.Print("Close context menu.");
                  return true;

               default:
                  Global.Print("Select: "+acName);
                  return true;

               case "atrk_moveup":
                  parent_timeline.handleMoveAudioTrackUp(getNodeGID());
                  return true;

               case "atrk_movedown":
                  parent_timeline.handleMoveAudioTrackDown(getNodeGID());
                  return true;

               case "atrk_delete":
                  handleDeleteTrack();
                  return true;
            }
            return true;

         case @(tf_name):
            handleNameChanged();
            if(TextField.ACTION_TEXTENTERED == acName)
               parent_timeline.refocusDefault();
            return true;

         case @(bt_mute):
            handleMuteChanged();
            return true;

         case @(bt_solo):
            handleSoloChanged();
            return true;

         case @(bt_lock):
            handleLockChanged();
            return true;

         case @(cm_dev):
            handleDevChanged();
            return true;

         case @(cm_ch):
            handleMidiChChanged();
            return true;
      }

      return XMLForm::consumeAction(_action);
   }
}
