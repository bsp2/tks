// ----
// ---- file   : NodeModularPattern.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2022-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- created: 26Mar2021
// ---- changed: 27Mar2021, 29Mar2021, 30Mar2021, 31Mar2021, 01Apr2021, 02Apr2021, 13Apr2021
// ----          08May2021, 13May2021, 21Jun2021, 19Dec2021, 22Dec2021, 28Dec2021, 30Dec2021
// ----          01Jan2022, 08Oct2023, 03Feb2024, 12Oct2024
// ----
// ----
// ----

module MNodeModularPattern;

use namespace ui;
use namespace st2;
use namespace modularcv;


// <class.png>
class NodeModularPattern : NodePattern {
   Patch *patch;


   // <method_init.png>
   public virtual patInit(Node _parent, int _patNr) {
      NodePattern::patInit(_parent, _patNr);

      patch <= new Patch;
      patch.init();
      patch.parent_node <= _parent;

      // // patch.loadTestPatch();
   }

   // <method.png>
   public method isEmpty() : boolean {
      return patch.all_modules.isEmpty();
   }

   // <method.png>
   public virtual patCopyFrom(NodeModularPattern _o, boolean _bClear) {
      NodePattern::patCopyFrom(_o, _bClear);

      patCopyFromGeneric(_o);
   }

   // <save.png>
   public virtual patSaveState(Stream ofs) {

      NodePattern::patSaveState(ofs);

      ofs.i16 = 1; // Version

      patch.saveState(ofs);
   }

   // <load.png>
   public virtual patLoadState(Stream ifs, short _ver, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      if(NodePattern::patLoadState(ifs, _ver, _outDevIdxMap, _outDevUseCount))
      {
         short ver = ifs.u16;

         if(ver >= 1)
         {
            if(patch.loadState(ifs))
            {
               return true;
            }
            else
            {
               trace "[---] NodeModularPattern::patLoadState: failed to load patch";
            }
         }
      }
      return false;
   }

   // <replay.png>
   public method seek(int _ticks) {
   }

   // <replay.png>
   public method reset() {
      patch.reset();
   }

   // <replay.png>
   public method callOnPatternChanged() {
      patch.callOnPatternChanged();
   }

   // <replay.png>
   public method tick(int _tickNr, MIDIPipeFrame _frameRec, MIDIPipeFrame _framePlay, MIDIPipeFrame _frameOut) {
      patch.tick(_tickNr, _frameRec, _framePlay, _frameOut);
   }

}
