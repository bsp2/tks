// ----
// ---- file   : STX_MIDIOutDevice.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: ?????????, 23Jan2011, 07Apr2012, 20Dec2012, 23Mar2013, 09Apr2013, 05Jun2013
// ----          02Feb2014, 04Feb2014, 09Feb2014, 11Feb2014, 15Jun2014, 13Aug2014, 19Aug2014
// ----          31Aug2014, 15Sep2014, 14Feb2015, 17Feb2015, 21Feb2015, 23Feb2015, 08Mar2015
// ----          10Apr2015, 18Apr2015, 21Apr2015, 14Sep2015, 11Jan2016, 19Jan2016, 01Feb2016
// ----          28Feb2016, 29Feb2016, 04Mar2016, 10Mar2016, 09Sep2016, 16Feb2017, 03Mar2017
// ----          09Jun2017, 12Jun2017, 15Aug2017, 17Aug2017, 02Nov2017, 04Jan2018, 09Feb2018
// ----          22Jan2019, 20Feb2020, 01Nov2020, 12Nov2020, 31Jan2021, 14Jun2021, 24Jul2021
// ----          18Aug2021, 06Feb2022, 13Feb2022, 21Apr2022, 24Apr2022, 08Feb2023, 09Feb2023
// ----          24Sep2023, 04Oct2023, 04Jul2024, 15Sep2024, 05Oct2024, 14Mar2025
// ----
// ----
// ----

module MSTX_MIDIOutDevice;

use tkmidi;
use namespace st2;

boolean b_debug_mmc_spp = 0;


// <class.png>
class OutputMonitorEntry {
   int    timestamp;
   Buffer cmd_buffer;
   Buffer note_buffer;

   public method copyCmdBuffer(Buffer _o) {
      // // cmd_buffer = _o;  // don't, this also copies the buffer size (e.g. 32k even though only 4 bytes may be used)
      cmd_buffer.size = _o.offset;
      cmd_buffer.offset = 0;
      cmd_buffer.writeBuffer(_o, 0, _o.offset);
   }

   public method copyNoteBuffer(Buffer _o) {
      // // note_buffer = _o;  // don't, this also copies the buffer size (e.g. 32k even though only 4 bytes may be used)
      note_buffer.size = _o.offset;
      note_buffer.offset = 0;
      note_buffer.writeBuffer(_o, 0, _o.offset);
   }
}


// <class.png>
class STX_MIDIOutBuffer {
   float  time_ms;    // When to send this buffer (millisec timestamp, see milliSeconds() builtin function)
   Buffer out_buffer; // Raw output MIDI cache (used by writer thread)
}


// <callback.png>
function stx_midioutdevice_writer_thread(local Thread _th) {
   // // Global.Debug2("STX_MIDIOutDevice: started writer thread th="+#(_th)+"\n");
   local STX_MIDIOutDevice thiz <= _th.userdata;

   local Mutex out_mutex <= thiz.out_mutex;
   local MIDIOut midiout <= thiz.midiout;
   local Condition cond <= thiz.cond_write;

   local Thread thread <= GetCurrentThread();
   Global.Debug3("STX_MIDIOutDevice<"+thiz.getName()+">: threadId="+thread.id);

   // // thread.priority = THREAD_PRIORITY_TIME_CRITICAL;
   thread.priority = THREAD_PRIORITY_HIGHEST;

   if(!STConfig.b_ignore_thread_affinity)
   {
      thread.setAffinityMaskByString(STConfig.midiout_thread_affinity_mask);
      if(Configuration.debugLevel >= 2)
         trace "[dbg] onMIDITimer: set midiout_thread_affinity_mask=\""+STConfig.midiout_thread_affinity_mask+"\"";
   }

   while(thiz.b_running)
   {
      // // trace "xxx outdev writer thread running....";

      out_mutex.lock();

      if(thiz.num_buf_avail > 0)
      {
         // (todo) milliSeconds() should have 1ms precision on Linux resp. Win32 (w/ TKS_WIN32_USE_PERFCOUNTER)
         local float now = milliSeconds();

         // // trace "xxx num_buf_avail="+thiz.num_buf_avail;

         local STX_MIDIOutBuffer mob <= thiz.out_buffers.get(thiz.read_buf_index);

         // // if(mob.time_ms <= now) // (todo) handle int overflow
         if(1)
         {
            // // Utils.HexDump(mob.out_buffer, 0, mob.out_buffer.offset);

            if(!thiz.b_closed_temporarily)
            {
               // // if("Sub37" == thiz.getAlias())
               // //    trace "xxx name=Sub37 num_buf_avail="+thiz.num_buf_avail+" write_buf_index="+thiz.write_buf_index+" read_buf_index="+thiz.read_buf_index;

               midiout.sendBuffer(mob.out_buffer);

               thiz.num_buf_avail--;
               local PointerArray outBufs <= thiz.out_buffers;
               thiz.read_buf_index = (thiz.read_buf_index + 1) % (outBufs.numElements);
            }

            out_mutex.unlock();
         }
         else
         {
            // Buffer is available, Wait until event time is reached
            out_mutex.unlock();
            TKS.yield();
         }
      }
      else
      {
         // Wait until event becomes available
         out_mutex.unlock();

         // // TKS.yield();

         // // local int ts = milliSeconds();
         cond.wait(100/*millisec*/);
         // // local int te = milliSeconds();
         // // if((te-ts) > 50)
         // // {
         // //    trace "xxx waited "+(te-ts)+" milliseconds";
         // // }
      }

   } // while b_running
}


// <class.png>
class STX_MIDIOutDevice : STX_MIDIDevice {

   define int NUM_OUT_BUFFERS =    32;  // [12Nov2020] reduced from 512 to 32 buffers
   define int OUT_BUFFER_SIZE = 32768;  // [12Nov2020] increased from 16k to 32k for Elektron Model Cycles kit dumps

   int num_out_buffers;

   define int CMD_BUFFER_SIZE  = 32768;  // [12Nov2020] increased from 16k to 32k for Elektron Model Cycles kit dumps
   define int NOTE_BUFFER_SIZE =  4096;

   public    MIDIOut *midiout;         // Reference to native output device. null if device is not available.

   public    Mutex   mtx_buffer;

   public    Buffer  cmd_buffer;        // Stores ctl changes, .., immediates note on/off,
   public    Buffer  cmd_buffer_hidden; // SysEx remote_audio control messages (Eureka)
   public    Buffer  note_buffer;       // Stores queued note on/off commands, always sent after cmd_buffer

   public    STX_MIDIOutBuffer *[] out_buffers; // STX_MIDIOutBuffer instances, written by replay, read by writer thread
   public    int          write_buf_index;  // ring buffer index (0..out_buffers.numElements) (used by replay thread)
   public    int          read_buf_index;   // ring buffer index (0..out_buffers.numElements) (used by MIDI out writer thread)
   public    int          num_buf_avail;
   public    Mutex        out_mutex;        // Protects access to out_buffers
   boolean   b_invalid_state;  // after mutex timeout during send() (device driver hangs?)

   public    boolean b_running;
   protected boolean b_begun;
   protected Thread  writer_thread;

   public Condition cond_write;

   boolean b_clk;     // true=send MIDI timing clock
   boolean b_mmcrec;  // true=send MMCREC sysex cmd when replay/recording starts (e.g. for Reason)
   boolean b_mmcplay; // true=send MMCSTART/STOP sysex cmd when replay starts/stops
   boolean b_mtc;     // true=send MTC full-frame msg when replay starts, then send quarterframes message while replay is running
   boolean b_spp;     // true=send song position pointer (0xF2)

   boolean b_ui_only;  // only UI thread writes (false=only replay thread writes). used by Push class.

   public boolean b_softpanic_pending; // true=send all notes off during next replay tick()

   public boolean b_sysex_lock; // true=only send sysex data, collect everything else until lock is released
   public MIDIPipeFrame frame_sysex_collect_other;

   define int NOTE_OFF_MODE_NONE          = 0;
   define int NOTE_OFF_MODE_ALLNOTESOFF   = 1;
   define int NOTE_OFF_MODE_INDIV         = 2;
   define int NOTE_OFF_MODE_ALL_AND_INDIV = 3;
   // also see STConfig.midi_device_noteoffmode

   OutputMonitorEntry *[] output_monitor_history;  // OutputMonitorEntry instances

   protected IntArray param_mode;  // 0=MSBLSB, 1=LSBMSB, 2=MSB (see MIDIIn::MIDI_DATAENTRYMODE_xxx)


   // <init.png>
   public method init(MIDIOut _midiout) {
      midiout <= deref _midiout;

      cmd_buffer.size = CMD_BUFFER_SIZE;
      cmd_buffer.fillZero();

      cmd_buffer_hidden.size = CMD_BUFFER_SIZE;
      cmd_buffer_hidden.fillZero();

      note_buffer.size = NOTE_BUFFER_SIZE;
      note_buffer.fillZero();

      cond_write.create(false/*bManualReset*/);

      num_out_buffers = NUM_OUT_BUFFERS;
      initOutBuffers();

      param_mode.allocAndFill(16, MIDI_DATAENTRYMODE_MSBLSB/*0*/);

      if(null != midiout)
      {
         // // Global.Debug2("MIDIOutDevice::init: creating writer_thread.");
         startWriterThread();
         // // Global.Debug2("MIDIOutDevice::init: writer_thread created OK.");
      }

   }

   // <method.png>
   protected method startWriterThread() {
      b_running = true;
      writer_thread.userdata = this;
      writer_thread.priority = THREAD_PRIORITY_TIME_CRITICAL;
      writer_thread.create(stx_midioutdevice_writer_thread);
   }

   // <init.png>
   protected method initOutBuffers() {
      out_buffers.alloc(num_out_buffers);

      int i = 0;
      loop(num_out_buffers)
      {
         STX_MIDIOutBuffer mob <= new STX_MIDIOutBuffer;
         Buffer buf <= mob.out_buffer;
         buf.size = OUT_BUFFER_SIZE;
         buf.fillZero();
         out_buffers[i++] = deref mob;
      }

      read_buf_index  = 0;
      write_buf_index = 0;
      num_buf_avail   = 0;
   }

   // <method.png>
   public =replay= method resizeOutBuffers(int _num) {
      if!(0 < _num <= NUM_OUT_BUFFERS)
         _num = NUM_OUT_BUFFERS;

      if(_num != num_out_buffers)
      {
         Global.Debug("STX_MIDIOutDevice::resizeOutBuffers: name="+getAliasOrDeviceName()+" num="+_num);
         num_out_buffers = _num;
         initOutBuffers();
      }
   }

   // <method_get.png>
   public virtual isOpen() : boolean {
      return (null != midiout);
   }

   // <method.png>
   public method exit() {
      if(b_running)
      {
         b_running = false;
         Global.Debug3("midioutdevice: waiting for writer thread.");
         cond_write.raise();
         writer_thread.wait();
         Global.Debug3("midioutdevice: writer thread terminated.");
      }
   }

   // <method.png>
   public method begin() {
      mtx_buffer.lock();
      if(!b_begun)
      {
         cmd_buffer.offset        = 0;
         cmd_buffer_hidden.offset = 0;
         note_buffer.offset       = 0;
         b_begun = true;
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method beginSysExLock() {
      mtx_buffer.lock();
      if(!b_sysex_lock)
      {
         b_sysex_lock = true;
         frame_sysex_collect_other.empty();
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method endSysExLock() {
      mtx_buffer.lock();
      if(b_sysex_lock)
      {
         b_sysex_lock = false;
      }
      mtx_buffer.unlock();
   }

   // <method_get.png>
   public virtual getDeviceName() : String {
      return (null != midiout) ? midiout.deviceName : unavail_name;
   }

   // <method_get.png>
   public virtual getAlias() : String {
      if(null != midiout)
      {
         if(b_project)
            return project_alias;
         else
            return getGlobalAlias();
      }
      else
      {
         return getGlobalAlias();
      }
   }

   // <method_get.png>
   public virtual getGlobalAlias() : String {
      if(null != midiout)
      {
         return MIDI.GetGlobalOutDeviceAlias(midiout.deviceName);
      }
      else
      {
         String r <= MIDI.GetGlobalOutDeviceAlias(unavail_name);
         if(null != r)
            return r;
         else
            return unavail_alias;
      }
   }

   // <method_get.png>
   public virtual getName() : String {
      if(null != midiout)
      {
         // <alias>(<devname>) or <devname>
         return MIDI.GetFullMIDIOutDeviceName(midiout.deviceName);
      }
      else
      {
         return unavail_name;
      }
   }

   // <method_update.png>
   public virtual updateDeviceAlias(String _alias) {
      if(b_project)
      {
         project_alias <= null;

         if(null != _alias && !_alias.isBlank())
         {
            project_alias <= Object(_alias);
         }

         MIDI.UpdateOutDeviceNames();
      }
      else
      {
         MIDI.UpdateMIDIOutDeviceAlias(getDeviceName(), _alias);
      }
   }

   // <method_get.png>
   public method getNoteOffMode() : int {
      return MIDI.GetNoteOffMode(getAliasOrDeviceName());
   }

   // <method_set.png>
   public method setNoteOffMode(int _mode) {
      MIDI.SetNoteOffMode(getAliasOrDeviceName(), _mode);
   }

   // <method_get.png>
   public method getEnableMIDICache() : boolean {
      return MIDI.GetEnableMIDICache(getAliasOrDeviceName());
   }

   // <method_set.png>
   public =replay= method setEnableMIDICache(boolean _bEnabled) {
      MIDI.SetEnableMIDICache(getAliasOrDeviceName(), _bEnabled);

      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            pipeDev.setEnableMIDICache(_bEnabled);
      }
   }

   // <method_get.png>
   public method getEnableGlobal() : boolean {
      return MIDI.IsMIDIGlobalEnabled(getAliasOrDeviceName());
   }

   // <method_get.png>
   public =replay= method setEnableGlobal(boolean _bEnable) : boolean {
      // true=use output of last pipe as input of next pipe
      MIDI.SetMIDIGlobalEnabled(getAliasOrDeviceName(), _bEnable);

      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            pipeDev.setEnableGlobal(_bEnable);
      }
   }

   // <method_set.png>
   public =replay= method setParamMode(int _ch, int _mode) {
      param_mode[_ch] = _mode;

      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            pipeDev.setParamMode(_ch, _mode);
      }
   }

   // <method_get.png>
   public virtual getParamMode(local int _ch) : int {
      return param_mode.get(_ch);
   }

   // <method_set.png>
   public =replay= method setEnableUseOverflowBuffers(boolean _bEnable) {
      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            pipeDev.setEnableUseOverflowBuffers(_bEnable);
      }
   }

   // <method_get.png>
   public method getEnableUseOverflowBuffers() : boolean {
      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            return pipeDev.getEnableUseOverflowBuffers();
      }
      return false;
   }

   // <method_set.png>
   public =replay= method setEnableCCPerfLSB(int _ch, boolean _bEnable) {
      // (note) controlled via MIDISynthProfile "ccPerfLSB" attribute (b_cc_perf_lsb field)
      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            pipeDev.setEnableCCPerfLSB(_ch, _bEnable);
      }
   }

   // <method_set.png>
   public =replay= method setEnableChannelPressureAndNoteOff(boolean _bEnable) {

      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            pipeDev.setEnableChannelPressureAndNoteOff(_bEnable);
      }
   }

   // <method_set.png>
   public =replay= method setEnableRunningStatus(byte _ch, boolean _bEnable) {

      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         if(null != pipeDev)
            pipeDev.setEnableRunningStatus(_ch, _bEnable);
      }
   }

   // <method_get.png>
   public method getMIDIPipeDevice() : MIDIPipeDevice {
      if(null != current_pipe_root)
      {
         MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
         return pipeDev;
      }
      return null;
   }

   // <method.png>
   public =replay= method clearMIDICacheForCh(local byte _midiCh) {
      MIDIPipeDevice pipeDev <= current_pipe_root.getDeviceByIdx(dev_idx);
      if(null != pipeDev)
         pipeDev.clearMIDICacheForCh(_midiCh);
   }

   // <method.png>
   protected method allNotesOff(byte _midiCh) {
      mtx_buffer.lock();
      begin();
      cmd_buffer_hidden.i8 = 0xB0 | (_midiCh&15);
      // // cmd_buffer_hidden.i8 = 0x78;  // all sound off
      // // cmd_buffer_hidden.i8 = 0x79;  // reset all controllers
      cmd_buffer_hidden.i8 = 0x7B; // all notes off
      cmd_buffer_hidden.i8 = 0x00;
      mtx_buffer.unlock();
   }

   // <method.png>
   protected method allNotesOffIndiv(byte _midiCh) {
      mtx_buffer.lock();
      begin();
      byte noteNr = 0;
      loop(128)
      {
         cmd_buffer_hidden.i8 = 0x80 | (_midiCh&15);
         cmd_buffer_hidden.i8 = noteNr++;
         cmd_buffer_hidden.i8 = 0;
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method allNotesOffDef(byte _midiCh) {
      switch(getNoteOffMode())
      {
         case NOTE_OFF_MODE_NONE:
            break;

         case NOTE_OFF_MODE_ALLNOTESOFF:
         default:
            allNotesOff(_midiCh);
            break;

         case NOTE_OFF_MODE_INDIV:
            allNotesOffIndiv(_midiCh);
            break;

         case NOTE_OFF_MODE_ALL_AND_INDIV:
            allNotesOff(_midiCh);
            allNotesOffIndiv(_midiCh);
            break;
      }
   }

   // <method.png>
   =replay= public method queueSoftPanic() {
      b_softpanic_pending = true;
   }

   // <method.png>
   =replay= public method invalidateCaches() {
      // (todo)
   }

   // <method.png>
   public method noteOn(byte _midiCh, byte _note, byte _vel) {
      mtx_buffer.lock();
      begin();
      // // trace "xxx STX_MIDIOutDevice::noteOn: this="+#(this)+" ch="+_midiCh+" note="+_note+" vel="+_vel;
      cmd_buffer.i8 = 0x90 | (_midiCh&15);
      cmd_buffer.i8 = _note & 127;
      cmd_buffer.i8 = _vel & 127;
      // TODO add midi opt.
      mtx_buffer.unlock();
   }

   // <method.png>
   public method queueNoteOn(byte _midiCh, byte _note, byte _vel) {
      mtx_buffer.lock();
      begin();
      // // trace "xxx STX_MIDIOutDevice::noteOn: this="+#(this)+" ch="+_midiCh+" note="+_note+" vel="+_vel;
      note_buffer.i8 = 0x90 | (_midiCh&15);
      note_buffer.i8 = _note & 127;
      note_buffer.i8 = _vel & 127;
      // TODO add midi opt.
      mtx_buffer.unlock();
   }

   // <method.png>
   public method noteOff(byte _midiCh, byte _note, byte _vel) {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0x80 | (_midiCh&15);
      cmd_buffer.i8 = _note & 127;
      cmd_buffer.i8 = _vel & 127;
      // TODO add midi opt.
      mtx_buffer.unlock();
   }

   // <method.png>
   public method queueNoteOff(byte _midiCh, byte _note, byte _vel) {
      mtx_buffer.lock();
      begin();
      note_buffer.i8 = 0x80 | (_midiCh&15);
      note_buffer.i8 = _note & 127;
      note_buffer.i8 = _vel & 127;
      // TODO add midi opt.
      mtx_buffer.unlock();
   }

   // <method.png>
   public method channelPressure(byte _midiCh, byte _val) {
      mtx_buffer.lock();
      // aka polyphonic aftertouch
      begin();
      cmd_buffer.i8 = 0xD0 | (_midiCh&15);
      cmd_buffer.i8 = _val&127;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method ctlChange(byte _midiCh, byte _ctl, byte _val) {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0xB0 | (_midiCh&15);
      cmd_buffer.i8 = _ctl&127;
      cmd_buffer.i8 = _val&127;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method bankSelect(byte _midiCh, short _msblsb) {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0xB0 | (_midiCh&15);
      cmd_buffer.i8 = 0x00;
      cmd_buffer.i8 = (_msblsb>>8) & 127;
      cmd_buffer.i8 = 0xB0 | (_midiCh&15);
      cmd_buffer.i8 = 0x20;
      cmd_buffer.i8 = _msblsb & 127;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method rpn(byte _midiCh, short _rpn, short _value) {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0xB0 | (_midiCh&15);
      cmd_buffer.i8 = 101;
      cmd_buffer.i8 = (_rpn >> 7) & 127;
      cmd_buffer.i8 = 100;
      cmd_buffer.i8 = (_rpn & 127);

      switch(param_mode.get(_midiCh))
      {
         default:
         case MIDI_DATAENTRYMODE_MSBLSB/*0*/:
            cmd_buffer.i8 = 6;
            cmd_buffer.i8 = (_value >> 7) & 127;
            cmd_buffer.i8 = 38;
            cmd_buffer.i8 = (_value & 127);
            break;

         case MIDI_DATAENTRYMODE_LSBMSB/*1*/:
            cmd_buffer.i8 = 38;
            cmd_buffer.i8 = (_value & 127);
            cmd_buffer.i8 = 6;
            cmd_buffer.i8 = (_value >> 7) & 127;
            break;

         case MIDI_DATAENTRYMODE_MSB/*2*/:
            cmd_buffer.i8 = 6;
            cmd_buffer.i8 = (_value & 127);  // LSB => MSB  (there is no LSB)
            break;
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method nrpn(byte _midiCh, short _nrpn, short _value) {
      mtx_buffer.lock();
      begin();

      cmd_buffer.i8 = 0xB0 | (_midiCh&15);
      cmd_buffer.i8 = 99;
      cmd_buffer.i8 = (_nrpn >> 7) & 127;
      cmd_buffer.i8 = 98;
      cmd_buffer.i8 = (_nrpn & 127);

      switch(param_mode.get(_midiCh))
      {
         default:
         case MIDI_DATAENTRYMODE_MSBLSB/*0*/:
            // trace "xxx outdev::nrpn: midiCh="+_midiCh+" nrpn="+_nrpn+" value="+_value;
            cmd_buffer.i8 = 6;
            cmd_buffer.i8 = (_value >> 7) & 127;
            cmd_buffer.i8 = 38;
            cmd_buffer.i8 = (_value & 127);
            break;

         case MIDI_DATAENTRYMODE_LSBMSB/*1*/:
            cmd_buffer.i8 = 38;
            cmd_buffer.i8 = (_value & 127);
            cmd_buffer.i8 = 6;
            cmd_buffer.i8 = (_value >> 7) & 127;
            break;

         case MIDI_DATAENTRYMODE_MSB/*2*/:
            cmd_buffer.i8 = 6;
            cmd_buffer.i8 = (_value & 127);  // LSB => MSB  (there is no LSB)
            break;
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method midiClock() {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0xF8;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method midiSongPos(int _songOffset) {
      mtx_buffer.lock();
      begin();

      // Ticks to 16th note
      int sixteenth = _songOffset / (6  * (current_song.ppq / 24));

      // // (todo) Reason only ? this confuses the Machine Drum resulting in slightly delayed playback
      // // if(replay.b_playing)
      // // {
      // //    trace "xxx midiSongPos: send MIDI STOP";
      // //    cmd_buffer.i8 = 0xFC; // MIDI STOP
      // // }

      if(b_debug_mmc_spp) trace "xxx midiSongPos(16th="+sixteenth+") dev="+getAliasOrDeviceName();
      // trace "xxx spp sixteenth="+sixteenth;
      if(STConfig.b_midi_logic_spp_alt_pb_message && ("logic" == getAliasOrDeviceName()))
      {
         // (note) Logic Pro "Playhead (beats)" + "Part"="Beats" does not work correctly,
         //         => 'sixteenth' must be divided by four, then offset by 40 (offset 0 sets playhead to end? of song)
         sixteenth /= 4;
         sixteenth += 8;
         sixteenth += 32;
         // trace "xxx     send E0 SPP="+sixteenth;
         cmd_buffer.i8 = 0xE0;
         cmd_buffer.i8 = (sixteenth & 127);        // LSB
         cmd_buffer.i8 = (sixteenth >> 7) & 127;   // MSB
      }
      else
      {
         cmd_buffer.i8 = 0xF2;
         cmd_buffer.i8 = (sixteenth & 127);        // LSB
         cmd_buffer.i8 = (sixteenth >> 7) & 127;   // MSB
      }

      if(b_debug_mmc_spp)
         Global.Debug("STX_MIDIOutDevice::midiSongPos: sixteenth="+sixteenth+" this="+getAliasOrDeviceName());

      // // (todo) Reason only ? this confuses the Machine Drum resulting in slightly delayed playback
      // // if(replay.b_playing)
      // // {
      // //    trace "xxx midiSongPos: send MIDI CONTINUE";
      // //    cmd_buffer.i8 = 0xFB; // MIDI CONTINUE
      // // }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method midiStart() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx midiStart() dev="+getAliasOrDeviceName();
      // (note) always starts from the beginning (i.e. offset 0)
      Global.Debug3("STX_MIDIOutDevice::midiStart: this="+getAliasOrDeviceName());
      begin();
      cmd_buffer.i8 = 0xFA;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method midiContinue() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx midiContinue() dev="+getAliasOrDeviceName();
      Global.Debug3("STX_MIDIOutDevice::midiContinue: this="+getAliasOrDeviceName());
      begin();
      cmd_buffer.i8 = 0xFB;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method midiStop() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx midiStop() dev="+getAliasOrDeviceName();
      Global.Debug3("STX_MIDIOutDevice::midiStop: this="+getAliasOrDeviceName());
      begin();
      cmd_buffer.i8 = 0xFC;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method mtcSendQuarterFrameTimePiece() {
      // (note) https://en.wikipedia.org/wiki/MIDI_timecode

      // (note) MIDI-OX test msg: SYSX: F0 7F 7F 01 01 60 00 00 00 F7   (sent when starting at 00:00:00:00, recognized by Studio One 5)
      //                                               0x6x = SMPTE Type=0b110 = 30 FPS  (0=24fps,1=25fps,2=30fps_drop-frame_29.97fps,3=30fps)

      // (note) MIDI-OX quarter-frame message: 0xF1 <xy>
      //          x: time code piece 0..7 (0=frlsb,1=frmsb,2=sclsb,3=scmsb,4=mnlsb,5=mnmsb,6=hrlsb,7=hrmsb+rate)

      mtx_buffer.lock();
      begin();

      float tapeMs = (milliSeconds() - replay.mtc_start_sys_ms)/*time since replay start*/ + replay.mtc_start_tape_ms;
      int hr = int(tapeMs / (1000.0f * 60 * 60)) % 24;
      int mn = int(tapeMs / (1000.0f * 60)) % 60;
      int sc = int(tapeMs / 1000.0f) % 60;
      int fr = int((30.0f * tapeMs) / 1000.0f) % 30;
      if(tapeMs < 0)
      {
         trace "[!!!] MTC: tapeMs="+tapeMs;  // should not be reachable
         mtx_buffer.unlock();
         return;
      }

      // trace "xxx send SMPTE MTC timepiece "+hr+":"+mn+":"+sc+":"+fr+"  tapeMs="+tapeMs;

      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x00 | (fr & 15); // frame LSB
      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x10 | (fr >> 4); // frame MSB

      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x20 | (sc & 15); // second LSB
      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x30 | (sc >> 4); // second MSB

      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x40 | (mn & 15); // minute LSB
      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x50 | (mn >> 4); // minute MSB

      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x60 | (hr & 15); // hour LSB
      cmd_buffer.i8 = 0xF1;
      cmd_buffer.i8 = 0x70 | (3/*rate=30fps*/ << 1) | (hr >> 4); // hour MSB + rate

      mtx_buffer.unlock();
   }

   // <method.png>
   public method mtcSendFullTimeCode() {
      mtx_buffer.lock();
      begin();

      float songMs = current_song.ticksToMilliSeconds(current_song.song_offset);
      float offsetMs = current_song.sixteenthToMilliSeconds(STConfig.midi_mtc_offset_16th);
      float tapeMs = mathMaxf(0, songMs + offsetMs - STConfig.midi_mtc_prerun_ms);
      replay.mtc_start_sys_ms = milliSeconds();
      replay.mtc_start_tape_ms = tapeMs;
      int hr = int(tapeMs / (1000.0f * 60 * 60)) % 24;
      int mn = int(tapeMs / (1000.0f * 60)) % 60;
      int sc = int(tapeMs / 1000.0f) % 60;
      int fr = int((30.0f * tapeMs) / 1000.0f) % 30;
      // trace "xxx mtcSendFullTimeCode: "+hr+":"+mn+":"+sc+":"+fr+"  sysMs="+replay.mtc_start_sys_ms+" songMs="+songMs+" tapeMs="+tapeMs;
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F; // rt universal
      cmd_buffer.i8 = 0x7F; // channel=all (global broadcast)
      cmd_buffer.i8 = 0x01; // time-code msg id
      cmd_buffer.i8 = 0x01; // full-time-code sub id
      cmd_buffer.i8 = (3/*30fps*/ << 5) | hr;
      cmd_buffer.i8 = mn;
      cmd_buffer.i8 = sc;
      cmd_buffer.i8 = fr;
      cmd_buffer.i8 = 0xF7;

      // Convert back to sequencer ticks and calc initial tick-delay
      //  - wait until tape-recorder has reached actual start position
      //  - the tick-delay is the delta between the SMPTE frame start and the actual seq start, i.e. up to 30ms
      float ms = ((fr*1000.0f)/30.0f) + (sc * 1000.0f) + (mn * 1000.0f * 60.0f) + (hr * 1000.0f * 60.0f * 60.0f);
      ms -= offsetMs;
      ms += STConfig.midi_mtc_prerun_ms;
      float seqDelayMs = songMs - ms;
      // trace "xxx mtcSendFullTimeCode: frameDelayMs="+seqDelayMs;
      seqDelayMs += STConfig.midi_mtc_prerun_ms + STConfig.midi_mtc_seq_align_ms;
      // trace "xxx mtcSendFullTimeCode: seqDelayMs="+seqDelayMs;
      replay.mtc_delayed_start_ms = replay.mtc_start_sys_ms + seqDelayMs;
      // trace "xxx mtcSendFullTimeCode: mtc_delayed_start_ms="+replay.mtc_delayed_start_ms+" tNow="+milliSeconds();

      // if(replay.precount_tick_countdown > 0)
      // {
      // }

      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcStart() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcStart() dev="+getAliasOrDeviceName();
      begin();

      // // (OLD) testcode: (note: Unfortunately, Reason does not react to GOTO command.)
      // // // goto: 0xF0 0x7F <deviceID> 0x06 0x44 0x06 0x01 <hr> <mn> <sc> <fr> <ff> 0xF7
      // // cmd_buffer.i8 = 0xF0;
      // // cmd_buffer.i8 = 0x7F;
      // // cmd_buffer.i8 = 0x7F;
      // // cmd_buffer.i8 = 0x06;
      // // cmd_buffer.i8 = 0x44;
      // // cmd_buffer.i8 = 0x06;
      // // cmd_buffer.i8 = 0x01;
      // // cmd_buffer.i8 = 0x00; // hr
      // // cmd_buffer.i8 = 0x00; // mn
      // // cmd_buffer.i8 = 0x00; // sc
      // // cmd_buffer.i8 = 0x00; // fr
      // // cmd_buffer.i8 = 0x00; // ff
      // // cmd_buffer.i8 = 0xF7;

      // Start:
      //  (note) ignored by slave when MTC sync is used (must continuously send MTC quarterframe messages)
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x06;
      cmd_buffer.i8 = 0x02;
      cmd_buffer.i8 = 0xF7;

      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcStop() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcStop() dev="+getAliasOrDeviceName();
      begin();
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x06;
      cmd_buffer.i8 = 0x01;
      cmd_buffer.i8 = 0xF7;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcPause() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcPause() dev="+getAliasOrDeviceName();
      begin();
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x06;
      cmd_buffer.i8 = 0x09;
      cmd_buffer.i8 = 0xF7;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcRec() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcRec dev="+getAliasOrDeviceName();
      begin();

      if(STConfig.b_midi_logic_mmc_rec_alt_message && ("logic" == getAliasOrDeviceName()))
      {
         // trigger "Record" key command (must be mapped in Logic)
         cmd_buffer.i8 = 0x90;
         cmd_buffer.i8 = 0x7F;
         cmd_buffer.i8 = 0x7F;
      }
      else
      {
         cmd_buffer.i8 = 0xF0;
         cmd_buffer.i8 = 0x7F;
         cmd_buffer.i8 = 0x7F;
         cmd_buffer.i8 = 0x06;
         cmd_buffer.i8 = 0x06; // Record Strobe (punch in)
         cmd_buffer.i8 = 0xF7;
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcRecExit() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcRecExit dev="+getAliasOrDeviceName();
      begin();
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x06;
      cmd_buffer.i8 = 0x07;  // Record Exit (punch out)
      cmd_buffer.i8 = 0xF7;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcRecPause() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcRecPause dev="+getAliasOrDeviceName();
      begin();
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x06;
      cmd_buffer.i8 = 0x08;
      cmd_buffer.i8 = 0xF7;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcForward() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcForward dev="+getAliasOrDeviceName();
      begin();
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x06;
      cmd_buffer.i8 = 0x04;
      cmd_buffer.i8 = 0xF7;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method mmcRewind() {
      mtx_buffer.lock();
      if(b_debug_mmc_spp) trace "xxx mmcRewind dev="+getAliasOrDeviceName();
      begin();
      cmd_buffer.i8 = 0xF0;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x7F;
      cmd_buffer.i8 = 0x06;
      cmd_buffer.i8 = 0x05;
      cmd_buffer.i8 = 0xF7;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method pitchBendf(byte _midiCh, float _pitchbend) {
      mtx_buffer.lock();
      begin();
      // // trace "xxx STX_MIDIOutDevice::pitchBendf: midiCh="+_midiCh+" bend="+_pitchbend;

      short val;

      if(_pitchbend >= 0.0f)
      {
         if(_pitchbend > 1.0f)
         {
            val = 0x3fff;
         }
         else
         {
            val = 0x2000 + (_pitchbend * 8191);
         }
      }
      else
      {
         if(_pitchbend < -1.0f)
         {
            val = 0x0000;
         }
         else
         {
            val = 0x2000 + (_pitchbend * 8192);
         }
      }

      // // Integer io = val;
      // // trace "xxx pitchbendf: val="+io.printf("0x%04x");

      cmd_buffer.i8 = 0xE0 | (_midiCh&15);
      cmd_buffer.i8 = (val & 127);    // LSB
      cmd_buffer.i8 = (val>>7) & 127; // MSB

      // // short val = (_bend*0x3f3f) + 0x4000;
      // // cmd_buffer.i8 = 0xE0 | (_midiCh&15);
      // // cmd_buffer.i8 = (val>>1)&127; // LSB  <--- wrong calculation of LSB
      // // cmd_buffer.i8 = (val>>8)&127; // MSB

      mtx_buffer.unlock();
   }

   // <method.png>
   public method programChange(byte _midiCh, byte _program) {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0xC0 | (_midiCh&15);
      cmd_buffer.i8 = _program & 127;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method bankLSB(byte _midiCh, byte _bankLSB) {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0xB0 | (_midiCh&15);
      cmd_buffer.i8 = 32/*bank LSB*/;
      cmd_buffer.i8 = _bankLSB & 127;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method bankMSB(byte _midiCh, byte _bankMSB) {
      mtx_buffer.lock();
      begin();
      cmd_buffer.i8 = 0xB0 | (_midiCh&15);
      cmd_buffer.i8 = 0/*bank LSB*/;
      cmd_buffer.i8 = _bankMSB & 127;
      mtx_buffer.unlock();
   }

   // <method.png>
   public method addBuffer(Buffer _b) {
      mtx_buffer.lock();
      begin();
      // trace "xxx STX_MIDIOutDevice::addBuffer: _b.offset="+_b.offset;
      if(_b.offset)
         cmd_buffer.writeBuffer(_b, 0, _b.offset);
      mtx_buffer.unlock();
   }

   // <method.png>
   public method sysEx(Buffer _syx) {
      mtx_buffer.lock();
      begin();
      // trace "xxx MIDIOutDevice::sysEx: _syx.offset="+_syx.offset;
      if(_syx.offset)
      {
         cmd_buffer.i8 = 0xF0;
         cmd_buffer.writeBuffer(_syx, 0, _syx.offset);
         cmd_buffer.i8 = 0xF7;
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method sysExHidden(Buffer _syx) {
      // called by SysEx.Send() (remote_audio control messages)
      mtx_buffer.lock();
      begin();
      // trace "xxx MIDIOutDevice::sysExHidden: _syx.offset="+_syx.offset;
      if(_syx.offset)
      {
         cmd_buffer_hidden.i8 = 0xF0;
         cmd_buffer_hidden.writeBuffer(_syx, 0, _syx.offset);
         cmd_buffer_hidden.i8 = 0xF7;
      }
      mtx_buffer.unlock();
   }

   // <method.png>
   public method sysExRaw(Buffer _syx) {
      mtx_buffer.lock();
      begin();
      // trace "xxx MIDIOutDevice::sysExRaw: _syx.offset="+_syx.offset;
      if(_syx.offset)
         cmd_buffer.writeBuffer(_syx, 0, _syx.offset);
      mtx_buffer.unlock();
   }

   // <method.png>
   =replay= public method unlinkOutputMonitorHistory() : PointerArray {
      // Called by UI thread
      PointerArray ret <= deref output_monitor_history;
      output_monitor_history <= null;
      return deref ret;
   }

   // <method.png>
   protected method lockOutMutex() : boolean {
      if(1)
         return out_mutex.timedLock(10/*sec*/);

      out_mutex.lock();
      return true;
   }

   // <method.png>
   public method send(local float _timeMillisec) {
      // (note) usually called once per replay tick

      mtx_buffer.lock();

      if(!b_closed_temporarily && !b_invalid_state)
      {
         if(b_begun)
         {
            local boolean bLocked = lockOutMutex();

            if(bLocked)
            {
               local boolean bReady;
               local int waitCount = 0;

               loop(30)
               {
                  bReady = (num_buf_avail < out_buffers.numElements);
                  if(bReady)
                     break;
                  else
                  {
                     // trace "[~~~] STX_MIDIOutDevice::send<"+getAliasOrDeviceName()+">: buffer overflow <"+waitCount+">, wait..";
                     out_mutex.unlock();
                     TKS.sleep(1);
                     bLocked = lockOutMutex();
                     if(!bLocked)
                     {
                        trace "[---] STX_MIDIOutDevice::send<"+getAliasOrDeviceName()+">: failed to lock out_mutex";
                        break;
                     }
                     waitCount++;
                  }
               }

               if(bReady)
               {
                  // // if(cmd_buffer.offset > 0)
                  // //    if("Sub37" == getAlias())
                  // //       trace "xxx send name=Sub37 num_buf_avail="+num_buf_avail+" write_buf_index="+write_buf_index+" read_buf_index="+read_buf_index;

                  local STX_MIDIOutBuffer mob <= out_buffers[write_buf_index];

                  local Buffer buf <= mob.out_buffer;
                  buf.offset = 0;

                  local boolean bAvail = false;
                  local boolean bOk = true;

                  if(replay.b_output_monitor && ((cmd_buffer.offset > 1) || (note_buffer.offset > 0)))
                  {
                     local OutputMonitorEntry outMonEntry <= new OutputMonitorEntry;
                     outMonEntry.timestamp = _timeMillisec;
                     outMonEntry.copyCmdBuffer(cmd_buffer);
                     outMonEntry.copyNoteBuffer(note_buffer);

                     if(null == output_monitor_history)
                        output_monitor_history <= new PointerArray;

                     output_monitor_history.add(#(deref outMonEntry));

                     if(output_monitor_history.numElements > STConfig.output_mon_max_log_entries)
                        output_monitor_history.delete(0);
                  }

                  if(cmd_buffer_hidden.offset)
                  {
                     if(STConfig.b_midi_debug_out_cmd && 1 != cmd_buffer_hidden.offset)
                     {
                        Global.Debug2("STX_MIDIOutDevice::send: dev="+getDeviceName()+" cmd_buffer_hidden.offset="+cmd_buffer_hidden.offset);
                        Utils.HexDump(cmd_buffer_hidden, 0, cmd_buffer_hidden.offset);
                     }

                     if((buf.offset + cmd_buffer_hidden.offset) <= buf.size)
                     {
                        buf.writeBuffer(cmd_buffer_hidden, 0, cmd_buffer_hidden.offset);
                        bAvail = true;
                     }
                     else
                     {
                        trace "[---] STX_MIDIOutDevice::send: buf overflow (bufOff="+buf.offset+" bufSz="+buf.size+" cmd_buffer_hidden.offset="+cmd_buffer_hidden.offset+")";
                        bOk = false;
                     }
                  }

                  if(bOk && cmd_buffer.offset)
                  {
                     if(STConfig.b_midi_debug_out_cmd && 1 != cmd_buffer.offset) // filter 0xF8 clock
                     {
                        Global.Debug2("STX_MIDIOutDevice::send: dev="+getDeviceName()+" cmd_buffer.offset="+cmd_buffer.offset);
                        Utils.HexDump(cmd_buffer, 0, cmd_buffer.offset);
                     }

                     if((buf.offset + cmd_buffer.offset) <= buf.size)
                     {
                        buf.writeBuffer(cmd_buffer, 0, cmd_buffer.offset);
                        bAvail = true;
                     }
                     else
                     {
                        trace "[---] STX_MIDIOutDevice::send: buf overflow (bufOff="+buf.offset+" bufSz="+buf.size+" cmd_buffer.offset="+cmd_buffer.offset+")";
                        bOk = false;
                     }
                  }

                  if(bOk)
                  {
                     if(note_buffer.offset)
                     {
                        // trace "xxx STX_MIDIOutDevice::send: note_buffer.offset="+note_buffer.offset+" midi_timing_ticks="+replay.midi_timing_ticks;
                        if(STConfig.b_midi_debug_out_note)
                        {
                           Global.Debug2("STX_MIDIOutDevice::send: dev="+getDeviceName()+" note_buffer.offset="+note_buffer.offset);
                           Utils.HexDump(note_buffer, 0, note_buffer.offset);
                        }

                        if((buf.offset + note_buffer.offset) <= buf.size)
                        {
                           buf.writeBuffer(note_buffer, 0, note_buffer.offset);
                           bAvail = true;
                        }
                        else
                        {
                           trace "[---] STX_MIDIOutDevice::send: buf overflow (bufOff="+buf.offset+" bufSz="+buf.size+" note_buffer.offset="+note_buffer.offset+")";
                        }
                     }
                  }

                  if(bAvail)
                  {
                     mob.time_ms = _timeMillisec;

                     num_buf_avail++;
                     write_buf_index = (write_buf_index + 1) % (out_buffers.numElements);

                     // Wake-up writer thread
                     cond_write.raise();
                  }

                  b_begun = false;
               } // if bRead
               else
               {
                  trace "[~~~] STX_MIDIOutDevice::send<"+getAliasOrDeviceName()+">: failed, device not ready.";
               }

               if(bLocked)
                  out_mutex.unlock();

            } // if timedlock
            else
            {
               trace "[!!!] STX_MIDIOutDevice::send: timedLock() failed after 10 seconds (dev=\""+getAliasOrDeviceName()+"\") (device driver hangs?)";
               b_invalid_state = true;
               b_begun = false;
            }
         } // if b_begun
      }
      else
      {
         // Closed temporarily
         b_begun = false;
      }

      mtx_buffer.unlock();
   }

   // <method_get.png>
   public method getVSTDevIdx() : byte {
      return MIDI.GetVSTOutDeviceIdxByName(getAliasOrDeviceName());
   }

   // <method.png>
   public method localMIDICheckForNewConnection() {
      // implemented by STX_LocalMIDI*Device
   }

}
