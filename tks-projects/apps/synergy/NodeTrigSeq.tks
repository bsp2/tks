// ----
// ---- file   : NodeTrigSeq.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2016-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 09Jul2016, 10Jul2016, 11Jul2016, 12Jul2016, 13Jul2016, 17Jul2016, 08Oct2016
// ----          09Oct2016, 16Oct2016, 11Dec2016, 12Dec2016, 19Dec2016, 30Jan2017, 31Jan2017
// ----          02Feb2017, 03Feb2017, 04Feb2017, 10Feb2017, 12Feb2017, 26Feb2017, 18Mar2017
// ----          01Jun2017, 05Jun2017, 12Aug2017, 18Aug2017, 03Sep2017, 09Oct2017, 14Oct2017
// ----          10Nov2017, 11Nov2017, 25Nov2017, 29Nov2017, 30Nov2017, 04Jan2018, 07Mar2018
// ----          12May2018, 21May2018, 27May2018, 28May2018, 01Jun2018, 17Jun2018, 24Jun2018
// ----          20Jul2019, 02Oct2019, 03Oct2019, 04Oct2019, 05Oct2019, 06Oct2019, 07Oct2019
// ----          08Oct2019, 09Oct2019, 14Oct2019, 16Oct2019, 17Oct2019, 18Oct2019, 19Oct2019
// ----          25Oct2019, 31Oct2019, 01Nov2019, 02Nov2019, 07Nov2019, 06Mar2020, 18Mar2020
// ----          05May2020, 26Oct2020, 27Oct2020, 30Oct2020, 02Nov2020, 03Nov2020, 10Nov2020
// ----          12Nov2020, 13Nov2020, 23Nov2020, 27Jan2021, 20Jun2021, 01Jan2022, 04Jan2022
// ----          21Feb2022, 07May2022, 21Jun2023, 14Oct2023, 27Nov2023, 01Dec2023, 02Dec2023
// ----          06Oct2024
// ----
// ----
// ----
module MNodeTrigSeq;

use namespace ui;
use namespace st2;


// <class.png>
class NodeTrigSeq : Node {

   define int RPN_TRIGSEQ_GLOBAL_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 0;
   define int RPN_TRIGSEQ_GLOBAL_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 1;
   define int RPN_TRIGSEQ_GLOBAL_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 2;

   define int RPN_TRIGSEQ_TRACK1_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 10;
   define int RPN_TRIGSEQ_TRACK1_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 11;
   define int RPN_TRIGSEQ_TRACK1_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 12;
   define int RPN_TRIGSEQ_TRACK1_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 13;
   define int RPN_TRIGSEQ_TRACK1_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 14;

   define int RPN_TRIGSEQ_TRACK2_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 20;
   define int RPN_TRIGSEQ_TRACK2_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 21;
   define int RPN_TRIGSEQ_TRACK2_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 22;
   define int RPN_TRIGSEQ_TRACK2_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 23;
   define int RPN_TRIGSEQ_TRACK2_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 24;

   define int RPN_TRIGSEQ_TRACK3_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 30;
   define int RPN_TRIGSEQ_TRACK3_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 31;
   define int RPN_TRIGSEQ_TRACK3_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 32;
   define int RPN_TRIGSEQ_TRACK3_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 33;
   define int RPN_TRIGSEQ_TRACK3_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 34;

   define int RPN_TRIGSEQ_TRACK4_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 40;
   define int RPN_TRIGSEQ_TRACK4_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 41;
   define int RPN_TRIGSEQ_TRACK4_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 42;
   define int RPN_TRIGSEQ_TRACK4_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 43;
   define int RPN_TRIGSEQ_TRACK4_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 44;

   define int RPN_TRIGSEQ_TRACK5_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 50;
   define int RPN_TRIGSEQ_TRACK5_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 51;
   define int RPN_TRIGSEQ_TRACK5_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 52;
   define int RPN_TRIGSEQ_TRACK5_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 53;
   define int RPN_TRIGSEQ_TRACK5_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 54;

   define int RPN_TRIGSEQ_TRACK6_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 60;
   define int RPN_TRIGSEQ_TRACK6_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 61;
   define int RPN_TRIGSEQ_TRACK6_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 62;
   define int RPN_TRIGSEQ_TRACK6_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 63;
   define int RPN_TRIGSEQ_TRACK6_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 64;

   define int RPN_TRIGSEQ_TRACK7_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 70;
   define int RPN_TRIGSEQ_TRACK7_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 71;
   define int RPN_TRIGSEQ_TRACK7_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 72;
   define int RPN_TRIGSEQ_TRACK7_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 73;
   define int RPN_TRIGSEQ_TRACK7_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 74;

   define int RPN_TRIGSEQ_TRACK8_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 80;
   define int RPN_TRIGSEQ_TRACK8_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 81;
   define int RPN_TRIGSEQ_TRACK8_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 82;
   define int RPN_TRIGSEQ_TRACK8_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 83;
   define int RPN_TRIGSEQ_TRACK8_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 84;

   define int RPN_TRIGSEQ_TRACK9_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 90;
   define int RPN_TRIGSEQ_TRACK9_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 91;
   define int RPN_TRIGSEQ_TRACK9_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 92;
   define int RPN_TRIGSEQ_TRACK9_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 93;
   define int RPN_TRIGSEQ_TRACK9_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 94;

   define int RPN_TRIGSEQ_TRACK10_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 100;
   define int RPN_TRIGSEQ_TRACK10_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 101;
   define int RPN_TRIGSEQ_TRACK10_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 102;
   define int RPN_TRIGSEQ_TRACK10_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 103;
   define int RPN_TRIGSEQ_TRACK10_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 104;

   define int RPN_TRIGSEQ_TRACK11_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 110;
   define int RPN_TRIGSEQ_TRACK11_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 111;
   define int RPN_TRIGSEQ_TRACK11_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 112;
   define int RPN_TRIGSEQ_TRACK11_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 113;
   define int RPN_TRIGSEQ_TRACK11_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 114;

   define int RPN_TRIGSEQ_TRACK12_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 120;
   define int RPN_TRIGSEQ_TRACK12_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 121;
   define int RPN_TRIGSEQ_TRACK12_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 122;
   define int RPN_TRIGSEQ_TRACK12_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 123;
   define int RPN_TRIGSEQ_TRACK12_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 124;

   define int RPN_TRIGSEQ_TRACK13_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 130;
   define int RPN_TRIGSEQ_TRACK13_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 131;
   define int RPN_TRIGSEQ_TRACK13_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 132;
   define int RPN_TRIGSEQ_TRACK13_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 133;
   define int RPN_TRIGSEQ_TRACK13_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 134;

   define int RPN_TRIGSEQ_TRACK14_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 140;
   define int RPN_TRIGSEQ_TRACK14_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 141;
   define int RPN_TRIGSEQ_TRACK14_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 142;
   define int RPN_TRIGSEQ_TRACK14_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 143;
   define int RPN_TRIGSEQ_TRACK14_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 144;

   define int RPN_TRIGSEQ_TRACK15_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 150;
   define int RPN_TRIGSEQ_TRACK15_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 151;
   define int RPN_TRIGSEQ_TRACK15_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 152;
   define int RPN_TRIGSEQ_TRACK15_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 153;
   define int RPN_TRIGSEQ_TRACK15_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 154;

   define int RPN_TRIGSEQ_TRACK16_REPEAT_ENABLE      = RPN_TRIGSEQ_BASE + 160;
   define int RPN_TRIGSEQ_TRACK16_REPEAT_NOTE_LENGTH = RPN_TRIGSEQ_BASE + 161;
   define int RPN_TRIGSEQ_TRACK16_NUM_REPEATS        = RPN_TRIGSEQ_BASE + 162;
   define int RPN_TRIGSEQ_TRACK16_VELOCITY_SCALING   = RPN_TRIGSEQ_BASE + 163;
   define int RPN_TRIGSEQ_TRACK16_DURATION_SCALING   = RPN_TRIGSEQ_BASE + 164;

   // moved to synergy_config.tks:
   // // define int NOTE_GLOBAL_MUTE                  = 55;  // G-4
   // // define int NOTE_GLOBAL_REPEAT_ENABLE_IF_TRIG = 57;  // A-4
   // // define int NOTE_GLOBAL_REPEAT_ENABLE         = 59;  // B-4
   // // define int NOTE_TRACK1_REPEAT_ENABLE         = 60;  // C-5 (..D#6 for track 16)

   define float INVALID_VALUE = -999999.0f;

   static NodeTrigSeqEditor *editor;

   PointerArray patterns; // NTS_Pattern instances

   // increases monotonically each replay tick.
   // max range is 0..16777217  (16777217/(192*4) = 21845 bars 4/4 @192ppq = 41942.4sec = 11.65h @bpm=125)
   //  (i.e. outside this range, the 32bit float does not have enough precision to store integer values)
   float tick_nr;

   float tick_nr_gate;  // in extclk mode, tick_nr before GATE was received

   boolean b_extclk_resetval;
   boolean b_extclk;

   int gate_time;  // ticks (def=1/16th)
   boolean b_clock;     // true=have clock signal (RPN_COMMON_CLOCK, RPN_COMMON_CLOCKGATE) (auto-resets to false)
   int gate_countdown;  // counts down to 0, then seeks back to tick_nr_gate or (b_clock=true) to tick_nr_gate+gate_time
   int gate_time_mul;
   int gate_time_div;

   boolean b_run;

   int out_dev_idx; // or -1
   byte out_ch;

   // - arg1 is velocity
   // - arg2 is note duration
   // - arg3 is note
   define int OUT_SINGLECH_NOTE                  =  0;

   // - arg1 is velocity
   // - arg2 is probability
   // - arg3 is note
   define int OUT_SINGLECH_NOTE_PROBABILITY      =  1;

   // - tracknr is channel offset, relative to output ch
   // - arg1 is velocity
   // - arg2 is note duration
   // - arg3 is note
   define int OUT_MULTICH_NOTE                   =  2;

   // - trigger mute/unmutes/toggle mute state
   // - arg1 is mode, 0=mute,1=unmute,2=toggle
   // - arg2 is ?
   // - arg3 is ?
   define int OUT_SINGLECH_MUTE_TEMP             =  3;

   // - arg1: controls RPN_COMMON_RUN (0=keep, 1=true, 2=false)
   // - arg2 is optional pattern offset (RPN_COMMON_OFFSET)
   //    - optional. not set = do not send offset
   // - arg3 is pattern nr
   // - trigger changes pattern and optionally sends offset and/or changes run status
   define int OUT_SINGLECH_PAT_CHG_OFF_RUN       =  4;

   // - arg1: controls RPN_COMMON_RUN (0=keep, 1=true, 2=false)
   // - arg2 is optional pattern offset (RPN_COMMON_OFFSET)
   //    - optional. not set = use arg3
   // - arg3 is default pattern offset (RPN_COMMON_OFFSET)
   // - trigger changes pattern offset and/or change run status
   define int OUT_SINGLECH_PAT_OFF_RUN           =  5;

   // - arg1 is trigger type (0=don't send, 1=send offset)
   // - arg2 is offset (def=0)
   // - arg3 is pattern nr (PrgChg)
   define int OUT_PAT_CHG_OFF                    =  6;

   // - tracknr is poly index
   // - arg1 is additional poly step nr offset (+0, +1, +2, +3)
   // - arg2 is optional poly step nr offset
   // - arg3 is poly step nr (1..n)
   define int OUT_SINGLETRACK_POLYSTEP           =  7;

   // - tracknr is poly index
   // - arg1 is additional poly step nr offset (+0, +1, +2, +3)
   // - arg2 is optional poly step nr offset
   // - arg3 is poly track idx (0..15)
   define int OUT_MULTITRACK_POLYSTEP            =  8;

   // - tracknr is poly index
   // - arg1 is additional poly step nr offset (+0, +1, +2, +3)
   // - arg2 is optional poly step nr offset
   // - (arg3/4) is poly track idx (0..15), ((arg3 % 4) * 4) is poly step nr offset
   define int OUT_MULTITRACK_POLYSTEP4           =  9;

   // - arg1 is trigger type (0=clock+gate, 1=clock, 2=gate, 3=retrig?)
   // - arg2 is optional gate time multiplier
   // - arg3 is channel nr
   define int OUT_MULTICH_CLOCKGATE              = 10;

   // - arg1 is trigger type (0=send offset 0, 1=send offset 1, 2=send offset 2, 3=don't send offset)
   // - arg2 is optional pattern nr (PrgChg)
   // - arg3 is channel nr
   define int OUT_MULTICH_CLOCKGATE_PAT_CHG_OFF  = 11;

   // - arg1 is velocity (via RPN_COMMON_VELOCITY_SCL)
   // - arg2 is optional number of frames (def=1)
   // - arg3 is midi channel offset
   define int OUT_MULTICH_GATE_SEEK_REL          = 12;

   // - arg1 is velocity (via RPN_COMMON_VELOCITY_SCL)
   // - arg2 is optional number of frames (def=1)
   // - arg3 is midi channel offset
   //  (note) send RPN_COMMON_RESET on first step
   define int OUT_MULTICH_GATE_SEEK_REL_RESET    = 13;

   // - arg1 is velocity (via RPN_COMMON_VELOCITY_SCL)
   // - arg2 is note duration
   // - arg3 is midi channel offset
   define int OUT_MULTICH_DRUMPADSELECT          = 14;

   // - arg1 is velocity
   // - arg2 is note
   // - arg3 is note offset
   define int OUT_CHROMATIC                      = 15;

   // - arg1 is accent/slide mode (1=slide, 2=accent, 3=accent+slide)
   // - arg2 is note
   // - arg3 is note offset
   define int OUT_CHROMATIC_MONO                 = 16;

   define int OUT_NUM                            = 17;

   int output_mode;

   static StringArray output_mode_names_short = [
      "Note and Duration",
      "Note and Probability",
      "MultiCh Note",
      "Mute Temp",
      "Pattern Change/Offset/Run",
      "Pattern Offset/Run",
      "Pattern Change + Offset",
      "SingleTrack Polystep",
      "MultiTrack Polystep",
      "MultiTrack Polystep 4",
      "MultiCh Clock/Gate",
      "MultiCh Clock+Gate + Pat.Chg/Off",
      "MultiCh Gate+Seek Rel",
      "MultiCh Gate+Seek Rel (Rst)",
      "MultiCh Drum Pad Select + Note",
      "Chromatic",
      "Chromatic Mono (Acc+Slide)"
                                           ];

   static StringArray output_mode_names_long = [
      "SingleChannel Note and Duration",
      "SingleChannel Note and Probability",
      "MultiChannel Note",
      "Mute Temp",
      "SingleChannel Pattern Change/Offset/Run",
      "SingleChannel Pattern Offset/Run",
      "Pattern Change + Offset",
      "SingleTrack Polystep",
      "MultiTrack Polystep",
      "MultiTrack Polystep 4",
      "MultiChannel Clock/Gate",
      "MultiChannel Clock+Gate + Pattern Change/Offset",
      "MultiChannel Gate + Seek Rel",
      "MultiChannel Gate + Seek Rel (Reset on Step 1)",
      "MultiChannel Drum Pad Select (A/B) + Note",
      "Chromatic (arg2=note)",
      "Chromatic Mono (arg1=Accent+Slide, arg2=note)",
                                           ];

   static StringArray output_mode_tooltip_captions = [
      "SingleChannel Note and Duration:\n- arg1 is velocity\n- arg2 is note duration\n- arg3 is note",
      "SingleChannel Note and Probability:\n- arg1 is velocity\n- arg2 is probability (0..100%)\n- arg3 is note",
      "MultiChannel Note\n- tracknr is channel offset, relative to output ch\n- arg1 is velocity\n- arg2 is note duration\n- arg3 is note",
      "Mute Temp\n- mute/unmute/toggle mute state of target node\n- arg1 is mode, 0=unmute,1=mute,2=toggle\n- arg2 is unused\n- arg3 is unused",
      "SingleChannel Pattern Change/Offset/Run\n- arg1: controls RPN_COMMON_RUN (0=keep, 1=true, 2=false)\n- arg2 is optional pattern offset (RPN_COMMON_OFFSET)\n   - optional. not set = do not send offset\n- arg3 is pattern nr\n- trigger changes pattern and optionally sends offset and/or changes run status\n\n      *** NOT IMPLEMENTED, YET ***",
      "SingleChannel Pattern Offset/Run\n- arg1: controls RPN_COMMON_RUN (0=keep, 1=true, 2=false)\n- arg2 is optional pattern offset (RPN_COMMON_OFFSET)\n   - optional. not set = use arg3\n- arg3 is default pattern offset (RPN_COMMON_OFFSET)\n- trigger changes pattern offset and/or change run status\n\n      *** NOT IMPLEMENTED, YET ***",
      "Pattern Change + Offset\n- arg1 is trigger type (0=don\'t send offset, 1=send offset)\n- arg2 is offset (default=0) (Com: Seek Offset RPN)\n- arg3 is pattern nr (PrgChg)",
      "SingleTrack Polystep\n- tracknr is poly index\n- arg1 is additional poly step offset (+0, +1, +2, +3)\n- arg2 is optional poly step offset\n- arg3 is poly step index (0..n)",
      "MultiTrack Polystep\n- tracknr is poly index\n- arg1 is poly step index (0, 1, 2, 3)\n- arg2 is optional poly step offset\n- arg3 is poly track index (0..15)",
      "MultiTrack Polystep 4\n- tracknr is poly index\n- arg1 is poly step index (0, 1, 2, 3)\n- arg2 is optional poly step offset\n- (arg3/4) is poly track index (0..15), (arg3%4)*4 is poly step offset\n\n (note) divides tracks into 4 groups, each group addresses up to 16 steps (0,4,8,12 via tracknr, +0..+3 via arg1/velocity)",
      "MultiChannel Clock/Gate\n- arg1 is trigger type (0=clock+gate, 1=clock, 2=gate, 3=retrig?)\n- arg2 is optional gate time multiplier (unset=use arg3)\n- arg3 is channel nr",
      "MultiChannel Clock+Gate + Pattern Change/Offset\n- arg1 is trigger type (0=send offset 0, 1=send offset 1, 2=send offset 2, 3=don't send offset)\n- arg2 is optional pattern nr (PrgChg)\n- arg3 is channel nr\n\n      *** NOT IMPLEMENTED, YET ***",
      "MultiChannel Gate + Seek Rel\n- arg1 is velocity (via RPN_COMMON_VELOCITY_SCL)\n- arg2 is optional number of frames/steps (def=1)\n- arg3 is MIDI channel offset\n\n (note) play continuously\n\n (note) plays multiple steps if node supports it (e.g. Monitor)",
      "MultiChannel Gate + Seek Rel (Reset on Step 1)\n- arg1 is velocity (via RPN_COMMON_VELOCITY_SCL)\n- arg2 is optional number of frames/steps (def=1)\n- arg3 is MIDI channel offset\n\n (note) plays multiple steps if node supports it (e.g. Monitor)\n\n (note) reset target node when step 1 is reached",
      "MultiChannel Drum Pad Select: Send RPN 400 (Pre: Drum Pad Select) and C-4 note on/off.\n- arg1 is velocity\n- arg3 is note duration\n- arg3 is MIDI channel and RPN value offset",
      "Chromatic:\n- arg1 is velocity\n- arg2 is note offset\n- arg3 is note base offset\n\n (note) hold LCTRL or RCTRL to record step notes (must set trigs first)",
      "Chromatic Mono:\n- arg1 is accent(vel=99/127) / slide mode\n- arg2 is note offset\n- arg3 is note base offset\n\n (note) hold LCTRL or RCTRL to record step notes (must set trigs first)",
                                              ];


   static StringArray arg3_names = [
      "Note",              //  0: OUT_SINGLECH_NOTE
      "Note",              //  1: OUT_SINGLECH_NOTE_PROBABILITY
      "Note",              //  2: OUT_MULTICH_NOTE
      "-",                 //  3: OUT_SINGLECH_MUTE_TEMP
      "Pattern Nr",        //  4: OUT_SINGLECH_PAT_CHG_OFF_RUN
      "Pattern Off",       //  5: OUT_SINGLECH_PAT_OFF_RUN
      "Pattern Nr",        //  6: OUT_PAT_CHG_OFF
      "PolyStep Nr",       //  7: OUT_SINGLETRACK_POLYSTEP
      "PolyStep Track Nr", //  8: OUT_MULTITRACK_POLYSTEP
      "PolyStep Track Nr", //  9: OUT_MULTITRACK_POLYSTEP4
      "MIDI Channel",      // 10: OUT_MULTICH_CLOCKGATE
      "MIDI Channel",      // 11: OUT_MULTICH_CLOCKGATE_PAT_CHG_OFF
      "MIDI Channel",      // 12: OUT_MULTICH_GATE_SEEK_REL
      "MIDI Channel",      // 13: OUT_MULTICH_GATE_SEEK_REL_RESET
      "MIDI Channel",      // 14: OUT_MULTICH_DRUMPADSELECT
      "Note",              // 15: OUT_CHROMATIC
      "Note",              // 16: OUT_CHROMATIC_MONO
                                    ];

   boolean ui_b_microtime_range_limit;  // true=limit microtime range to +-25% (display only)

   int queued_step_idx;

   int  repeat_note_length;      // see NOTELEN_xxx. -1=use track repeat_note_length (or -1=step_note_length)
   int  num_repeats;             // 0=infinite, -1=use track num_repeats

   int  current_repeat_note_length;
   int  current_num_repeats;

   boolean b_global_repeat;  // used to find diff

   define int REPEAT_START_IMMEDIATELY  = 0;
   define int REPEAT_START_SYNC_NOTELEN = 1;
   define int REPEAT_START_SYNC_STEP    = 2;
   define int REPEAT_START_SYNC_TRIG    = 3;
   int  repeat_start_mode;

   static StringArray repeat_start_mode_names = [
      "Immediately",
      "Sync Repeat Note Length",
      "Sync Step",
      "Sync Trig"
                                                 ];

   int repeat_start_quantization_note_length;  // -1=no quantization
   int repeat_start_quantization_ticks;        // -1=no quantization

   define int REC_UNMAP_CONFIG     = 0;  // use STConfig.node_trig_seq_rec_base_note linear mapping
   define int REC_UNMAP_C3         = 1;  // use linear mapping, starting with C-3
   define int REC_UNMAP_C3_WHITE   = 2;  // use linear mapping, white keys only, starting with C-3
   define int REC_UNMAP_C4         = 3;  // use linear mapping, starting with C-4
   define int REC_UNMAP_C4_WHITE   = 4;  // use linear mapping, white keys only, starting with C-4
   define int REC_UNMAP_C5         = 5;  // use linear mapping, starting with C-5
   define int REC_UNMAP_C5_WHITE   = 6;  // use linear mapping, white keys only, starting with C-5
   define int REC_UNMAP_OUT_NOTE   = 7;  // use track output notes to find track idx (pattern-specific)
   define int REC_UNMAP_OUT_MIDICH = 8;  // find track idx by output MIDI channel (e.g. Analog Rytm)

   static StringArray rec_unmap_type_names = [
      "Config rec_base_note",
      "C-3..D#4",
      "C-3..D-5 (white keys only)",
      "C-4..D#5",
      "C-4..D-6 (white keys only)",
      "C-5..D#6",
      "C-5..D-7 (white keys only)",
      "Output Note",
      "Output Channel"
                                              ];

   boolean b_rec;  // true=always record (also in bg), maybe=only record when node editor is visible (lctrl-x RSHIFT)
   boolean b_rec_mute_repeat;
   boolean b_rec_prev;
   int     rec_dev_idx;  // -1=all, output device idx otherwise
   byte    rec_ch;       // -1=all
   boolean b_rec_quantize;
   int     rec_unmap_type;
   boolean b_rec_mod_unmap;  // true=unmap mod output dev/ch (side effect: clamps values to min/max). maybe=enable when editor is visible

   boolean b_recording;  // true=record events to pattern (RCTRL)

   boolean b_force_step_record;  // true while LCTRL is pressed (step-record OUT_CHROMATIC* notes)

   boolean b_redraw_queued;

   boolean b_queued_rec_restart;
   MIDIPipeFrame fr_queued_rec_restart_rec;
   // // MIDIPipeFrame fr_queued_rec_restart_play;

   protected Buffer *buf_redo;  // has precedence over pat_redo
   protected Buffer *buf_undo;
   protected NTS_Pattern *pat_redo;
   protected NTS_Pattern *pat_undo;
   public boolean b_undone; // false=copy undo pattern, true=copy redo pattern
   protected boolean b_undo_started;

   protected float offlen_scale_ticks;
   protected float offlen_multiplier;
   protected float offlen_divisor;

   int learn_xform_dev_idx;  // -1=use node out_dev_idx
   int learn_xform_ch;
   boolean b_learn_xform;    // true=transform incoming events
   boolean b_learn_advance;  // true=auto-advance to next track
   static boolean b_learn_xform_active;  // temporarily true while TrackSetupDialog is visible

   PointerArray track_states;  // NTS_TrackState instances

   public int ui_cursor_x;  // save/restore when nodeeditor is hidden/shown
   public int ui_cursor_y;

   define int UI_STEPDETAILS_ALL       = 0;
   define int UI_STEPDETAILS_ARG2      = 1;
   define int UI_STEPDETAILS_MOD1      = 2;
   define int UI_STEPDETAILS_MOD2      = 3;
   define int NUM_UI_STEPDETAILS_MODES = 4;
   int ui_stepdetails_mode;

   int plugin_dev_idx;  // -1=none, >=0: HW interface plugin output device index
   int plugin_scene_group_idx;
   int plugin_scene_idx;

   NTS_EditorPlugin *editor_plugin;


   // <init.png>
   public virtual nodeInit(MIDIPipe _pipe, MIDIPipeNode _node) : boolean {

      Node::nodeInit(_pipe, _node);

      patterns.alloc(128);
      patterns.useAll();

      edit_pattern_nr = 0;
      play_pattern_nr = 0;

      out_dev_idx = -1;
      out_ch   = 0;

      output_mode = OUT_SINGLECH_NOTE;

      learn_xform_dev_idx = -1;  // -1 == use out_dev_idx

      ui_b_microtime_range_limit = true;

      queued_step_idx = -1;

      repeat_note_length = -1;
      num_repeats        = -1;
      repeat_start_mode  = REPEAT_START_SYNC_NOTELEN;

      repeat_start_quantization_note_length = -1;
      repeat_start_quantization_ticks       = -1;

      b_rec = maybe;
      b_rec_prev = false;
      rec_dev_idx = -1;
      rec_ch = -1;
      b_rec_quantize = true;
      rec_unmap_type = REC_UNMAP_CONFIG;
      b_rec_mod_unmap = maybe;

      b_recording = false;

      track_states.alloc(NTS_Pattern.NUM_TRACKS);
      loop(NTS_Pattern.NUM_TRACKS)
      {
         NTS_TrackState trackState <= new NTS_TrackState;
         trackState.init();
         trackState.reset();
         track_states.add(#(deref trackState));
      }

      ui_stepdetails_mode = UI_STEPDETAILS_ALL;

      plugin_dev_idx = -1;
      editor_plugin <= null;

      plugin_scene_group_idx = -1;
      plugin_scene_idx = -1;

      return true;
   }

   // <ui_init.png>
   public virtual nodeUIInit() {

      Node::nodeUIInit();

      NTS_Pattern pat <= new NTS_Pattern;
      pat.patInit(this, 0/*patIdx*/);
      patterns[0] = deref pat;

      b_learn_advance = true;
   }

   // <method_get.png>
   public virtual nodeGetTypeNameShort() : String {
      return "Trg";
   }

   // <method_get.png>
   public virtual nodeGetEditor() : NodeEditor {
      if(null == editor)
      {
         editor <= new NodeTrigSeqEditor;

         if(!editor.init())
         {
            editor <= null;
            return false;
         }
      }
      return editor;
   }

   // <method_get.png>
   public virtual nodeGetEditorIfExists() : NodeEditor {
      return editor;
   }

   // <method_get.png>
   public virtual nodeGetIcon() : Icon {
      if(LookAndFeel.IDX_MONO == STConfig.lnf_idx)
         return UI.GetIcon("node_trigseq_mono");
      else
         return UI.GetIcon("node_trigseq");
   }

   // <method.png>
   public virtual nodeGetPatternClassName() : String {
      return "NTS_Pattern";
   }

   // <method_get.png>
   public method getTrackStateByIndex(int _trackIndex) : NTS_TrackState {
      return track_states.get(_trackIndex);
   }

   // <method_get.png>
   public =replay= getQueuedRedrawAndReset() : boolean {
      boolean ret = b_redraw_queued;
      b_redraw_queued = false;
      return ret;
   }

   // <method_set.png>
   public =replay= method setOutDevIdx(int _devIdx) {
      out_dev_idx = _devIdx;
   }

   // <method_get.png>
   public method getOutDevIdx() : int {
      return out_dev_idx;
   }

   // <method_set.png>
   public =replay= method setOutCh(byte _ch) {
      out_ch = _ch;
   }

   // <method_get.png>
   public method getOutCh() : byte {
      return out_ch;
   }

   // <method_set.png>
   public =replay= method setOutputMode(int _mode) {
      output_mode = _mode;
   }

   // <method_set.png>
   public =replay= method setEnableExtClk(boolean _bEnable) {
      b_extclk_resetval = _bEnable;
      b_extclk = _bEnable;
   }

   // <method_set.png>
   public =replay= method setRepeatNoteLength(int _lenIdx) {
      repeat_note_length = _lenIdx;
      current_repeat_note_length = repeat_note_length;  // (todo) move to TrackState


      NTS_Pattern *pat;
      foreach pat in patterns
      {
         if(null != pat)
         {
            copyRepeatLenAndNumOverrideToTracks(pat);
         }
      }
   }

   // <method_set.png>
   public =replay= method setNumRepeats(int _num) {
      num_repeats = _num;
      current_num_repeats = num_repeats;

      NTS_Pattern *pat;
      foreach pat in patterns
      {
         if(null != pat)
         {
            copyRepeatLenAndNumOverrideToTracks(pat);
         }
      }
   }

   // <method_set.png>
   public =replay= method setRepeatStartMode(int _mode) {
      repeat_start_mode = _mode;
   }

   // <method.png>
   protected method calcRepeatStartQuantizationTicks() {
      if(repeat_start_quantization_note_length >= 0)
      {
         repeat_start_quantization_ticks = NTS_Track.CalcStepNumTicks(repeat_start_quantization_note_length, 1/*num steps hint*/);  // (todo) use pattern max steps ??
      }
      else
      {
         repeat_start_quantization_ticks = -1;
      }
   }

   // <method_set.png>
   public =replay= method setRepeatStartQuantization(int _noteLen) {
      repeat_start_quantization_note_length = _noteLen;

      calcRepeatStartQuantizationTicks();
   }

   // <method_set.png>
   public =replay= method setEnableRec(boolean _bEnable) {
      b_rec = _bEnable;
   }

   // <method_get.png>
   public method getEnableRec() : boolean {
      return b_rec;
   }

   // <method_set.png>
   public =replay= method setEnableRecPrev(boolean _bEnable) {
      b_rec_prev = _bEnable;
   }

   // <method_get.png>
   public method getEnableRecPrev() : boolean {
      return b_rec_prev;
   }

   // <method_set.png>
   public =replay= method setEnableRecMuteRepeat(boolean _bEnable) {
      b_rec_mute_repeat = _bEnable;
   }

   // <method_get.png>
   public method getEnableRecMuteRepeat() : boolean {
      return b_rec_mute_repeat;
   }

   // <method_set.png>
   public =replay= method setRecDevIdx(int _devIdx) {
      rec_dev_idx = _devIdx;
   }

   // <method_set.png>
   public =replay= method setRecCh(int _ch) {
      rec_ch = _ch;
   }

   // <method_set.png>
   public =replay= method setEnableRecQuantize(boolean _bEnable) {
      b_rec_quantize = _bEnable;
   }

   // <method_set.png>
   public =replay= method setRecUnmapType(int _type) {
      rec_unmap_type = _type;
   }

   // <method_set.png>
   public =replay= method setEnableRecModUnmap(boolean _bEnable) {
      b_rec_mod_unmap = _bEnable;
   }

   // <method_set.png>
   public =replay= method setLearnXformDevIdx(int _devIdx) {
      learn_xform_dev_idx = _devIdx;
   }

   // <method_get.png>
   public method getActualLearnXformDevIdx() : int {
      return (learn_xform_dev_idx >= 0) ? learn_xform_dev_idx : out_dev_idx;
   }

   // <method_set.png>
   public =replay= method setLearnXformCh(byte _ch) {
      learn_xform_ch = _ch;
   }

   // <method_get.png>
   public method getLearnXformCh() : byte {
      return learn_xform_ch;
   }

   // <method_set.png>
   public =replay= method setEnableLearnXform(boolean _bEnable) {
      b_learn_xform = _bEnable;
   }

   // <method_get.png>
   public method getEnableLearnXform() : boolean {
      return b_learn_xform;
   }

   // <method_set.png>
   public =replay= method setEnableLearnAdvance(boolean _bEnable) {
      b_learn_advance = _bEnable;
   }

   // <method_set.png>
   public method getEnableLearnAdvance() : boolean {
      return b_learn_advance;
   }

   // <method_set.png>
   public =replay= method setPluginDevIdx(int _devIdx) {
      plugin_dev_idx = _devIdx;
   }

   // <method_set.png>
   public =replay= method setEditorPlugin(NTS_EditorPlugin _plugin) {
      editor_plugin <= _plugin;
   }

   // <method.png>
   public =replay= method startRec() {
      b_recording = true;
   }

   // <method.png>
   public =replay= method stopRec() {
      b_recording = false;
   }

   // <method.png>
   public method uiSetCursorX(int _x) {
      ui_cursor_x = _x;
   }

   // <method.png>
   public method uiSetCursorY(int _y) {
      ui_cursor_y = _y;
   }

   // <method.png>
   module method recalcPatternStepNumTicks() {
      NTS_Pattern *pat;
      foreach pat in patterns
      {
         if(null != pat)
         {
            pat.patHandleSongSpeedChanged(true/*bPPQ*/, true/*bBPM*/);
            pat.patReset(false/*bSoft*/);
         }
      }
   }

   // <method.png>
   public virtual nodeHandleSongSpeedChanged(boolean _bPPQ, boolean _bBPM) {
      if(_bPPQ)
      {
         recalcPatternStepNumTicks();
         calcRepeatStartQuantizationTicks();
      }
      NTS_Pattern *pat;
      foreach pat in patterns
      {
         if(null != pat)
         {
            pat.b_recalc_common_repeat = true;
         }
      }
   }

   // <method.png>
   public =replay= method queueRecordRestart() {
      b_queued_rec_restart = true;
      fr_queued_rec_restart_rec.empty();
      // // fr_queued_rec_restart_play.empty();
   }

   // <method_handle.png>
   public virtual nodeHandleStartPlaying() {
      Node::nodeHandleStartPlaying();

      b_queued_rec_restart = false;
      fr_queued_rec_restart_rec.empty();
      // // fr_queued_rec_restart_play.empty();
   }

   // <method_handle.png>
   public virtual nodeHandleStopPlaying() {
      // Called from UI thread while =replay= is locked
      nodeStopOutputCapture();

      b_queued_rec_restart = false;
      fr_queued_rec_restart_rec.empty();
      // // fr_queued_rec_restart_play.empty();
   }

   // <replay.png>
   public virtual nodeReset(boolean _bSoft) {

      Node::nodeReset(_bSoft);

      tick_nr = 0;
      tick_nr_gate = 0;

      current_repeat_note_length = repeat_note_length;  // (todo) move to TrackState
      current_num_repeats        = num_repeats;

      b_global_repeat = false;

      NTS_Pattern pat <= nodeGetCurrentPlayPattern();
      if(null != pat)
      {
         pat.patReset(_bSoft);
      }

      // Reset mute and repeat states
      NTS_TrackState *st;
      foreach st in track_states
      {
         st.reset();
      }

      offlen_scale_ticks = (current_song.ppq / 4.0);
      offlen_multiplier = 1.0f;
      offlen_divisor = 1.0f;

      b_clock = false;
      b_extclk = b_extclk_resetval;
      gate_countdown = b_extclk ? 0 : 1;
      gate_time = current_song.ppq / 4.0;  // 1/16th
      gate_time_mul = 1;
      gate_time_div = 1;

      b_run = true;

      calcRepeatStartQuantizationTicks();

      if(null != editor_plugin)
         editor_plugin.handleNodeReset();
   }

   // <replay.png>
   public virtual nodeRestart() {
      nodeSetLastPatternStartSongOffset(current_song.song_offset);

      nodeSeek(nodeGetLastPatternStartSongOffset() + 0);
   }

   // <replay.png>
   public =replay= virtual nodeSeek(int _ticks) {

      // trace "xxx NTS: nodeSeek("+_ticks+" ticks)";

      tick_nr = _ticks - nodeGetLastPatternStartSongOffset();
      if(tick_nr < 0)
         tick_nr = 0;

      tick_nr_gate = tick_nr;
      // trace "xxx NodeTrigSeq::nodeSeek: new tick_nr="+tick_nr;
   }

   // <ui.png>
   public method nodeSetRelativeEditOffset(int _off) {
      NTS_Pattern pat <= nodeGetCurrentEditPattern();
      if(null != pat)
      {
         NTS_Track track <= pat.getTrackByIndex(ui_cursor_y);
         if(null != track)
         {
            ui_cursor_x = (_off % int(track.current_step_num_ticks * track.play_length)) / track.current_step_num_ticks;
            Global.Debug2("NodeTrigSeq::nodeSetRelativeEditOffset: off="+_off+", trackIdx="+ui_cursor_y+" => ui_cursor_x="+ui_cursor_x);
         }
      }
   }

   // <method_get.png>
   public virtual nodeGetCursorTrack() : int {
      return ui_cursor_y;
   }

   // <replay.png>
   public method nodeGetCurrentTickOffset() : int {
      return tick_nr;
   }

   // <method_get.png>
   public virtual nodeGetPatternsGeneric() : PointerArray {
      return patterns;
   }

   // <method_get.png>
   public virtual nodeIsPatternEmpty(int _patNr) : boolean {
      return (null == patterns.get(_patNr));
   }

   // <method_get.png>
   public virtual nodeGetTotalNumPatternEvents(int _patNr) : int {
      int r = 0;
      NTS_Pattern pat <= patterns.get(_patNr);
      if(null != pat)
      {
         NTS_Track *track;
         foreach track in pat.tracks
         {
            r += track.getNumTrigs();
         }
      }
      return r;
   }

   // <method_get.png>
   public virtual nodeGetPatternByIdx(int _idx) : NTS_Pattern {
      return patterns.get(_idx);
   }

   // <method_get.png>
   public =replay= virtual nodeGetCurrentPlayPattern() : NTS_Pattern {
      return patterns.get(play_pattern_nr);
   }

   // <method_get.png>
   public =replay= virtual nodeGetCurrentEditPattern() : NTS_Pattern {
      // trace "xxx nodeGetCurrentEditPattern: edit_pattern_nr="+edit_pattern_nr;
      return patterns.get(edit_pattern_nr);
   }

   // <method_get.png>
   public method findFirstUnusedPattern(int _startOff) : int {
      int patIdx = patterns.indexOfPointer(null, _startOff);
      return patIdx;
   }

   // <method_set.png>
   public =replay= virtual nodeSetPattern(int _idx, NTS_Pattern _pat) {
      patterns[_idx & 127] = deref _pat;
   }

   // <method_get.png>
   public virtual nodeGetPatternNumTicks(local byte _patternNr) : int {
      local NTS_Pattern pat <= patterns.get(_patternNr);
      int maxTicks = 0;
      if(null != pat)
      {
         if(pat.master_len_16th > 0.0f)
         {
            maxTicks = (pat.master_len_16th * current_song.ppq) / 4.0;
            return maxTicks;
         }

         if(pat.b_recalc_common_repeat)
         {
            local NTS_Track *track;
            foreach track in pat.tracks
            {
               local int tLen = track.current_step_num_ticks * track.play_length;
               if(tLen > 0)
               {
                  if(maxTicks > 0)
                     maxTicks = mathMaxi(maxTicks, Utils.CommonRepeat(maxTicks, tLen));
                  else
                     maxTicks = tLen;

                  local NTS_Track *trackO;
                  foreach trackO in pat.tracks
                  {
                     if(@(trackO) != @(track))
                     {
                        local int oLen = trackO.current_step_num_ticks * trackO.play_length;
                        if(oLen > 0)
                        {
                           maxTicks = mathMaxi(maxTicks, Utils.CommonRepeat(maxTicks, oLen));
                        }
                     }
                  }
               }
            }
            pat.b_recalc_common_repeat = false;
            pat.common_repeat_ticks_cache = maxTicks;
         }
         else
         {
            maxTicks = pat.common_repeat_ticks_cache;
         }

      }
      return maxTicks;
   }

   // <method.png>
   public virtual nodeGetCurrentPlayPatternTickOffset() : int {
      return tick_nr;
   }

   // <replay.png>
   public =replay= method queueStepReplay(int _stepIdx) {
      queued_step_idx = _stepIdx;
   }

   // <save.png>
   public virtual nodeSaveState(Stream ofs) {
      ofs.i16 = 19; // Version

      Node::nodeSaveState(ofs);

      // Write patterns
      NTS_Pattern *pat;
      int patIdx = 0;
      loop(128)
      {
         pat <= patterns.get(patIdx);

         if(null != pat)
         {
            ofs.i8 = true; // bUsed

            pat.patSaveState(ofs);
         }
         else
         {
            // Unused
            ofs.i8 = false; // bUsed
         }

         // Next pattern
         patIdx++;
      }

      // Write out_dev_idx
      ofs.i16 = out_dev_idx;

      // Write out_ch
      ofs.i8 = out_ch;

      // Write output_mode
      ofs.i8 = output_mode;

      // Write extclk
      ofs.i8 = b_extclk_resetval;  // v8+

      // Write ui_b_microtime_range_limit
      ofs.i8 = ui_b_microtime_range_limit;

      // Write pattern nr (v3+)
      // (note) [21Jun2021] moved to Node base class
      ofs.i8 = edit_pattern_nr;
      ofs.i8 = play_pattern_nr;

      // Write repeat_note_length (v4+)
      ofs.i8 = repeat_note_length;

      // Write num_repeats (v4+)
      ofs.i8 = num_repeats;

      // Write repeat_start_mode (v4+)
      ofs.i8 = repeat_start_mode;

      // Write repeat_start_quantization_note_length (v5+)
      ofs.i8 = repeat_start_quantization_note_length;

      // Write rec_dev_idx (v7+)
      ofs.i16 = rec_dev_idx;

      // Write rec_ch (v7+)
      ofs.i8 = rec_ch;

      // Write b_rec (v7+)
      ofs.i8 = b_rec;

      // Write b_rec_prev (v19+)
      ofs.i8 = b_rec_prev;

      // Write b_rec_mute_repeat (v13+)
      ofs.i8 = b_rec_mute_repeat;

      // Write b_rec_quantize (v7+)
      ofs.i8 = b_rec_quantize;

      // Rec unmap type (v13+)
      ofs.i8 = rec_unmap_type;

      // Rec mod unmap (v17+)
      ofs.i8 = b_rec_mod_unmap;

      // MIDI Learn (v9+)
      ofs.i16 = learn_xform_dev_idx;
      ofs.i8  = learn_xform_ch;
      ofs.i8  = b_learn_xform;
      ofs.i8  = b_learn_advance;  // v10+

      // Cursor pos (v11+)
      ofs.i16 = ui_cursor_x;
      ofs.i16 = ui_cursor_y;

      // Step detail mode (v14+)
      ofs.i8 = ui_stepdetails_mode;

      // Write plugin_dev_idx (v15+)
      ofs.i16 = plugin_dev_idx;

      // Write plugin scene idx (v16+)
      ofs.i8 = plugin_scene_group_idx;
      ofs.i8 = plugin_scene_idx;
   }

   // <load.png>
   public virtual nodeLoadState(Stream ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      short ver = ifs.i16;

      if(ver >= 1)
      {
         if(!Node::nodeLoadState(ifs, _outDevIdxMap, _outDevUseCount))
         {
            return false;
         }

         // Read patterns
         int patIdx = 0;
         loop(128)
         {
            boolean bUsed = ifs.i8;

            // trace "xxx try read patIdx="+patIdx+" bUsed="+bUsed;

            if(bUsed)
            {
               NTS_Pattern pat <= new NTS_Pattern;

               pat.patInit(this, patIdx);

               patterns[patIdx] = deref pat;

               if(!pat.patLoadState(ifs, 1, _outDevIdxMap, _outDevUseCount))
               {
                  return false;
               }
            }
            else
            {
               // Unused pattern slot
               patterns[patIdx] = null;
            }

            patIdx++;
         }

         // Read out_dev
         int outDevIdx = ifs.i16;

         if(-1 != outDevIdx)
         {
            _outDevUseCount.inc(outDevIdx);

            // Remap to new MIDI out_devices index
            out_dev_idx = _outDevIdxMap.get(outDevIdx);
         }
         else
         {
            out_dev_idx = -1;
         }

         // Read out_ch
         out_ch = ifs.u8 & 15;

         // Read output_mode
         output_mode = ifs.u8;

         if((ver < 12) && (output_mode >= 1))
         {
            // OUT_SINGLECH_NOTE_PROBABILITY=1 added in v12
            output_mode++;
         }

         if((ver < 18) && (output_mode >= 9))
         {
            // OUT_MULTITRACK_POLYSTEP4 added in v18
            output_mode++;
         }

         // Read extclk
         if(ver >= 8)
         {
            b_extclk_resetval = ifs.b8;  // v8+
         }

         if(ver >= 2)
         {
            // Read ui_b_microtime_range_limit
            ui_b_microtime_range_limit = ifs.i8;
         }

         // Read pattern nr (v3+)
         if(ver >= 3)
         {
            // (note) [21Jun2021] moved to Node base class
            edit_pattern_nr = ifs.u8 & 127;
            play_pattern_nr = ifs.u8 & 127;
         }

         if(ver >= 4)
         {
            // Read repeat_note_length
            repeat_note_length = ifs.s8;

            // Read num_repeats
            num_repeats = ifs.s8;

            // Read repeat_start_mode
            repeat_start_mode = ifs.u8;
         }

         if(ver >= 5)
         {
            // Read repeat_start_quantization_note_length
            repeat_start_quantization_note_length = ifs.s8;
         }

         if(ver >= 7)
         {
            // Read rec_dev_idx (v7+)
            int recDevIdx = ifs.i16;

            if(-1 != recDevIdx)
            {
               _outDevUseCount.inc(recDevIdx);

               // Remap to new MIDI out_devices index
               rec_dev_idx = _outDevIdxMap.get(recDevIdx);
            }
            else
            {
               rec_dev_idx = -1;
            }

            // Read rec_ch (v7+)
            rec_ch = ifs.s8;

            // Read b_rec (v7+)
            b_rec = ifs.s8;

            // Read b_rec_prev (v19+)
            if(ver >= 19)
            {
               b_rec_prev = ifs.s8;
            }

            // Read b_rec_mute_repeat (v13+)
            if(ver >= 13)
            {
               b_rec_mute_repeat = ifs.b8;
            }
            else
            {
               b_rec_mute_repeat = b_rec;
            }

            // Read b_rec_quantize (v7+)
            b_rec_quantize = ifs.b8;

            // Rec unmap type (v13+)
            if(ver >= 13)
            {
               rec_unmap_type = ifs.u8;
            }

            // Rec mod unmap (v17+)
            if(ver >= 17)
            {
               b_rec_mod_unmap = ifs.s8;
            }
         }

         if(ver >= 9)
         {
            // MIDI Learn (v9+)
            learn_xform_dev_idx = ifs.s16;
            learn_xform_ch      = ifs.i8;
            b_learn_xform       = ifs.b8;

            if(learn_xform_dev_idx >= 0)
            {
               _outDevUseCount.inc(learn_xform_dev_idx);

               // Remap to new MIDI out_devices index
               learn_xform_dev_idx = _outDevIdxMap.get(learn_xform_dev_idx);
            }

            if(ver >= 10)
            {
               b_learn_advance = ifs.b8;  // v10+
            }
         }

         if(ver >= 11)
         {
            // Cursor pos (v11+)
            ui_cursor_x = ifs.i16;
            ui_cursor_y = ifs.i16;
         }

         if(ver >= 14)
         {
            // Step details mode (v14+)
            ui_stepdetails_mode = ifs.u8;
         }

         if(ver >= 15)
         {
            // Read plugin_dev_idx (v15+)
            plugin_dev_idx = ifs.s16;

            if(plugin_dev_idx >= 0)
            {
               _outDevUseCount.inc(plugin_dev_idx);

               // Remap to new MIDI out_devices index
               plugin_dev_idx = _outDevIdxMap.get(plugin_dev_idx);
            }

            if(ver >= 16)
            {
               // Read plugin scene idx (v16+)
               plugin_scene_group_idx = ifs.s8;
               plugin_scene_idx       = ifs.s8;
            }
         }

         // fix old version
         if(ver < 6)
         {
            if(9 <= repeat_note_length <= 11)
               repeat_note_length += 3;
            else if(repeat_note_length >= 12)
               repeat_note_length += 5;

            if(9 <= repeat_start_quantization_note_length <= 11)
               repeat_start_quantization_note_length += 3;
            else if(repeat_start_quantization_note_length >= 12)
               repeat_start_quantization_note_length += 5;
         }

         // Recalc speed, e.g. after node clone during replay
         recalcPatternStepNumTicks();
         calcRepeatStartQuantizationTicks();

         return true;
      }

      return false;
   }

   // <ui_undo.png>
   public =replay= method undoBegin() {

      if(!b_undo_started)
      {
         b_undo_started = true;

         NTS_Pattern pat <= nodeGetCurrentEditPattern();

         if(null != pat)
         {
            if(null == pat_undo)
            {
               pat_undo <= new NTS_Pattern;
               // trace "xxx NodeTrigSeq::undoBegin: pat_undo="+#(pat_undo);
               Global.Debug2("NodeTrigSeq::undoBegin: this="+#(this));
               pat_undo.patInit(this, 0/*patNr*/);
            }

            pat_undo.patCopyFromGeneric(pat);

            b_undone = false;
         }
      }
   }

   // <ui_undo.png>
   public method undoEnd() {
      if(b_undo_started)
      {
         Global.Debug2("NodeTrigSeq::undoEnd");
         b_undo_started = false;
      }
   }

   // <ui_undo.png>
   public method undoBeginBuffer() {
      undoInvalidate();
      buf_undo <= new Buffer;
      nodeSaveStateToBuffer(buf_undo);
   }

   // <ui_undo.png>
   public method undoInvalidate() {
      undoInvalidateBuffer();
      undoInvalidatePattern();
      b_undone = false;
   }

   // <ui_undo.png>
   public method undoInvalidatePattern() {
      // Global.Debug("NodeTrigSeq::undoInvalidatePattern");
      pat_redo <= null;
      pat_undo <= null;
      b_undo_started = false;
   }

   // <ui_undo.png>
   public method undoInvalidateBuffer() {
      if(null != buf_undo)
      {
         Global.Debug("NodeTrigSeq::undoInvalidateBuffer");
         buf_redo <= null;
         buf_undo <= null;
         b_undone = false;
         b_undo_started = false;
      }
   }

   // <ui_undo.png>
   public =replay= method undo(boolean _bSaveRedo) : boolean {
      boolean ret = false;

      if(null != buf_undo)
      {
         Global.Debug("NodeTrigSeq::undo<buffer>");
         if(_bSaveRedo)
         {
            buf_redo <= new Buffer;
            nodeSaveStateToBuffer(buf_redo);
         }
         buf_undo.offset = 0;
         int editPatNr = nodeGetCurrentEditPatternNr();
         int playPatNr = nodeGetCurrentPlayPatternNr();
         nodeLoadState(buf_undo,
                       MSongFileReader.piperoot_outdevidxmap,
                       MSongFileReader.piperoot_outdevusecount
                       );
         nodeSetCurrentEditPatternNr(editPatNr);
         nodeSetCurrentPlayPatternNr(playPatNr);
         ret = true;
         b_undone = _bSaveRedo;
      }
      else if(null != pat_undo)
      {
         Global.Debug("NodeTrigSeq::undo<pat>");
         NTS_Pattern pat <= nodeGetCurrentEditPattern();

         if(null != pat)
         {
            if(_bSaveRedo)
            {
               if(null == pat_redo)
               {
                  pat_redo <= new NTS_Pattern;
                  pat_redo.patInit(this, 0/*patNr*/);
               }
               
               pat_redo.patCopyFromGeneric(pat);
            }

            pat.patCopyFromGeneric(pat_undo);
            pat.patReset(true/*bSoft*/);
            pat.patHandleSongSpeedChanged(true/*bPPQ*/, true/*bBPM*/);
            ret = true;
            b_undone = _bSaveRedo;
         }
      }

      return ret;
   }

   // <ui_undo.png>
   public =replay= method redo() : boolean {
      boolean ret = false;

      if(null != buf_redo)
      {
         Global.Debug("NodeTrigSeq::redo<buffer>");
         buf_undo <= new Buffer;
         nodeSaveStateToBuffer(buf_undo);
         buf_redo.offset = 0;
         int editPatNr = nodeGetCurrentEditPatternNr();
         int playPatNr = nodeGetCurrentPlayPatternNr();
         nodeLoadState(buf_redo,
                       MSongFileReader.piperoot_outdevidxmap,
                       MSongFileReader.piperoot_outdevusecount
                       );
         nodeSetCurrentEditPatternNr(editPatNr);
         nodeSetCurrentPlayPatternNr(playPatNr);
         ret = true;
         b_undone = false;
      }
      else if(null != pat_redo)
      {
         Global.Debug("NodeTrigSeq::redo<pat>");
         NTS_Pattern pat <= nodeGetCurrentEditPattern();

         if(null != pat)
         {
            pat.patCopyFromGeneric(pat_redo);
            pat.patReset(true/*bSoft*/);
            pat.patHandleSongSpeedChanged(true/*bPPQ*/, true/*bBPM*/);
            ret = true;
            b_undone = false;
         }
      }

      return ret;
   }

   // <method.png>
   protected method mirrorTempPlayStatesToTrackMasks() {
      NTS_TrackState *trackState;
      int trackBit = 1;
      foreach trackState in track_states
      {
         if(NTS_Track.STATE_SOLO == trackState.temp_play_state)
         {
            node_solo_temp_track_mask |=  trackBit;
            node_mute_temp_track_mask &= ~trackBit;
         }
         else if(NTS_Track.STATE_MUTE == trackState.temp_play_state)
         {
            node_solo_temp_track_mask &= ~trackBit;
            node_mute_temp_track_mask |=  trackBit;
         }
         else // STATE_PLAY
         {
            node_solo_temp_track_mask &= ~trackBit;
            node_mute_temp_track_mask &= ~trackBit;
         }

         trackBit = trackBit << 1;
      }
   }

   // <method.png>
   protected method toggleTempSoloState(int _trackNr) {
      // Called from replay thread

      NTS_TrackState *t;
      NTS_TrackState trackState <= track_states.get(_trackNr);

      if(null != trackState)
      {
         int newState = (NTS_Track.STATE_SOLO == trackState.temp_play_state) ? NTS_Track.STATE_PLAY : NTS_Track.STATE_SOLO;

         boolean bOtherSolo = false;
         foreach t in track_states
         {
            if(@(t) != @(trackState))
            {
               if(NTS_Track.STATE_SOLO == t.temp_play_state)
               {
                  bOtherSolo = true;
                  break;
               }
            }
         }

         if(NTS_Track.STATE_SOLO == trackState.temp_play_state)
         {
            // Solo => Play (or mute)

            if(!bOtherSolo)
            {
               // Restore pre-solo state
               foreach t in track_states
               {
                  if(NTS_Track.STATE_PLAY != t.temp_play_state)
                  {
                     t.temp_play_state = t.temp_play_state_presolo;

                     if(@(t) == @(trackState))
                     {
                        newState = t.temp_play_state;
                     }
                  }
               }
            }
            else
            {
               newState = NTS_Track.STATE_MUTE;
            }
         }

         if(NTS_Track.STATE_SOLO == newState)
         {
            if(!bOtherSolo)
            {
               // Save pre-solo states
               foreach t in track_states
               {
                  // trace "xxx save presolo state="+t.temp_play_state;
                  t.temp_play_state_presolo = t.temp_play_state;
                  t.temp_play_state = NTS_Track.STATE_MUTE;
               }
            }
         }

         trackState.temp_play_state = newState;
      }
   }

   // <method.png>
   protected method updateTempSoloStates() {
      int trackIdx = 0;
      int trackBit = 1;
      NTS_TrackState *trackState;
      foreach trackState in track_states
      {
         if(node_solo_temp_track_mask & trackBit)
         {
            // Should be solo'd
            // trace "xxx solo trackIdx="+trackIdx+" play_state="+trackState.temp_play_state;
            if(NTS_Track.STATE_SOLO != trackState.temp_play_state)
               toggleTempSoloState(trackIdx);
         }
         else
         {
            // Should be unsolo'd
            if(NTS_Track.STATE_SOLO == trackState.temp_play_state)
               toggleTempSoloState(trackIdx);
         }

         // Next track
         trackIdx++;
         trackBit = trackBit << 1;
      }

      mirrorTempPlayStatesToTrackMasks();
   }

   // <method.png>
   protected method updateTempMuteStates8(int _diff, int _trackOffset) {
      // trace "xxx updateTempMuteStates: diff="+_diff;
      int trackIdx = _trackOffset;
      int trackBitSrc = 1;
      int trackBitDst = 1 << trackIdx;
      loop(8)
      {
         if(_diff & trackBitSrc)
         {
            NTS_TrackState trackState <= getTrackStateByIndex(trackIdx);

            // trace "xxx updateTempMuteState: diff trackIdx="+trackIdx;
            // toggleTempMuteState:
            if(NTS_Track.STATE_MUTE == trackState.temp_play_state)
            {
               trackState.temp_play_state = NTS_Track.STATE_PLAY;
               node_mute_temp_track_mask &= ~trackBitDst;
               node_solo_temp_track_mask &= ~trackBitDst;
            }
            else
            {
               trackState.temp_play_state = NTS_Track.STATE_MUTE;
               node_mute_temp_track_mask |=  trackBitDst;
               node_solo_temp_track_mask &= ~trackBitDst;
            }
         }

         // Next track
         trackIdx++;
         trackBitSrc = trackBitSrc << 1;
         trackBitDst = trackBitDst << 1;
      }
   }

   // <method_handle.png>
   protected method handlePrgChg(MIDIPipeFrame _frame) {
      int numPC = _frame.getNumEventsPrgChg();

      if(numPC > 0)
      {
         int pcIdx = 0;

         loop(numPC)
         {
            MIDIPipeEvent ev;
            _frame.getEventByIdx(pcIdx, ev, MIDIPIPE_EVENT_TYPE_PRGCHG);

            if(b_auto_filter_a && b_auto_recv_prgchg_a)
            {
               if( (-1 == auto_dev_filter_a) || (auto_dev_filter_a == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_a) || (auto_ch_filter_a == ev.midiCh) )
                  {
                     play_pattern_nr = ev.arg1;
                     if(STConfig.b_node_trig_seq_edit_pattern_follows_replay_pattern)
                        edit_pattern_nr = play_pattern_nr;
                     Events.SendPlayPat();

                     Global.Debug3("nts: queued pattern "+play_pattern_nr+" via PrgChg A");
                  }
               }
            }

            if(b_auto_filter_b && b_auto_recv_prgchg_b)
            {
               if( (-1 == auto_dev_filter_b) || (auto_dev_filter_b == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_b) || (auto_ch_filter_b == ev.midiCh) )
                  {
                     play_pattern_nr = ev.arg1;
                     if(STConfig.b_node_trig_seq_edit_pattern_follows_replay_pattern)
                        edit_pattern_nr = play_pattern_nr;
                     Events.SendPlayPat();

                     Global.Debug3("nts: queued pattern "+play_pattern_nr+" via PrgChg B");
                  }
               }
            }

            pcIdx++;
         }
      }

      // Handle timeline recordable program change
      short t = getFrameRPN(_frame, RPN_COMMON_UI_PRGCHG);
      if(t >= 0)
      {
         play_pattern_nr = t;
         if(STConfig.b_node_trig_seq_edit_pattern_follows_replay_pattern)
            edit_pattern_nr = play_pattern_nr;
         Events.SendPlayPat();
         replay.addUIPrgChgEntry(getNodeGID(), t);
      }
   }

   // <method.png>
   public =replay= method copyRepeatLenAndNumOverrideToTracks(NTS_Pattern _pat) {
      // Copy override note length/num repeats settings
      NTS_Track *track;
      int trackIdx = 0;
      foreach track in _pat.tracks
      {
         NTS_TrackState trackState <= track_states.get(trackIdx);
         track.setCurrentRepeatNoteLength(trackState,
                                          (-1 == current_repeat_note_length) ? track.repeat_note_length : current_repeat_note_length);
         track.setCurrentNumRepeats(trackState,
                                    (-1 == current_num_repeats) ? track.num_repeats : current_num_repeats);
         trackIdx++;
      }
   }

   // <method.png>
   protected method handleGlobalRepeatEnable(NTS_Pattern _pat, boolean _bEnable, int _autoOffTicks) {
      NTS_Track *track;

      b_global_repeat = _bEnable;

      if(false != _bEnable)
      {
         copyRepeatLenAndNumOverrideToTracks(_pat);
      }

      NTS_TrackState *trackState;
      foreach trackState in track_states
      {
         trackState.queueRepeat(this,
                                _bEnable,
                                true/*bMayQueue*/
                                );
         // for UI
         trackState.handleGlobalRepeat(false != _bEnable, _autoOffTicks);
      }
   }

   // <method.png>
   protected method transformLearnNotes(MIDIPipeFrame _frame) {
      MIDIPipeEvent pev;
      int evIdx;

      MIDIPipeFrame frameXform; frameXform.empty();
      int xformDevIdx = getActualLearnXformDevIdx();

      int numNoteOff = _frame.getNumEventsNoteOff();
      evIdx = 0;
      loop(numNoteOff)
      {
         if(_frame.getEventByIdx(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_OFF))
         {
            frameXform.noteOff(true/*bSet*/, xformDevIdx, learn_xform_ch, pev.note, pev.velocity);
         }

         // Next event
         evIdx++;
      }

      // Parse note on
      int numNoteOn = _frame.getNumEventsNoteOn();
      evIdx = 0;
      loop(numNoteOn)
      {
         if(_frame.getEventByIdx(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_ON))
         {
            frameXform.noteOn(true/*bSet*/, xformDevIdx, learn_xform_ch, pev.note, pev.velocity, pev.duration);
            // trace "xxx xform dev="+xformDevIdx+" learn_xform_ch="+learn_xform_ch+" note="+pev.note;
         }

         // Next event
         evIdx++;
      }

      _frame.deleteNoteOffsByFlt(-1, -1);
      _frame.deleteNoteOnsByFlt(-1, -1);

      // if(numNoteOn)
      // {
      //    trace "xxx #frame notes="+_frame.numEventsNoteOn;
      // }

      _frame.mergeFrame(frameXform);

      // if(numNoteOn)
      // {
      //    trace "xxx #xform notes="+frameXform.numEventsNoteOn;
      // }

   }

   // <method.png>
   protected method unmapRecordNoteToTrackIdx(byte    _note,
                                              byte    _midiCh,
                                              int     _recUnmapType,
                                              boolean _bAllowUnmapChromatic
                                              ) : int {

      if(!_bAllowUnmapChromatic)
         if([OUT_CHROMATIC, OUT_CHROMATIC_MONO].contains(output_mode))
            return -1;

      NTS_Pattern *pat;
      NTS_Track *track;
      int trackIdx;

      switch(_recUnmapType)
      {
         default:
         case REC_UNMAP_CONFIG:
            if(STConfig.node_trig_seq_rec_base_note <= _note < (STConfig.node_trig_seq_rec_base_note + NTS_Pattern.NUM_TRACKS))
            {
               return _note - STConfig.node_trig_seq_rec_base_note;
            }
            break;

         case REC_UNMAP_C3:
            if( (12*3) <= _note < ((12*3)+NTS_Pattern.NUM_TRACKS) )
            {
               return _note - 12*3;
            }
            break;

         case REC_UNMAP_C3_WHITE:
            if( (12*3) <= _note <= ((12*3)+26) )
            {
               return Scale.WhiteToIndex(_note, (12*3)/*base*/);
            }
            break;

         case REC_UNMAP_C4:
            if( (12*4) <= _note < ((12*4)+NTS_Pattern.NUM_TRACKS) )
            {
               return _note - 12*4;
            }
            break;

         case REC_UNMAP_C4_WHITE:
            if( (12*4) <= _note <= ((12*4)+26) )
            {
               return Scale.WhiteToIndex(_note, (12*4)/*base*/);
            }
            break;

         case REC_UNMAP_C5:
            if( (12*5) <= _note < ((12*5)+NTS_Pattern.NUM_TRACKS) )
            {
               return _note - 12*5;
            }
            break;

         case REC_UNMAP_C5_WHITE:
            if( (12*5) <= _note <= ((12*5)+26) )
            {
               return Scale.WhiteToIndex(_note, (12*5)/*base*/);
            }
            break;

         case REC_UNMAP_OUT_NOTE:
            // Find track that outputs the given _note
            pat <= nodeGetCurrentEditPattern();
            if(null != pat)
            {
               trackIdx = 0;
               foreach track in pat.tracks
               {
                  byte outputMode = (-1 != track.forced_output_mode) ? track.forced_output_mode : output_mode;
                  switch(outputMode)
                  {
                     case OUT_SINGLECH_NOTE:
                     case OUT_SINGLECH_NOTE_PROBABILITY:
                     case OUT_MULTICH_NOTE:
                        if( int(track.arg3 + pat.arg3_offset) == _note )
                           return trackIdx;
                        break;
                  }
                  trackIdx++;
               }
            }
            break;

         case REC_UNMAP_OUT_MIDICH:
            // Find track that outputs to the given MIDI channel
            pat <= nodeGetCurrentEditPattern();
            if(null != pat)
            {
               trackIdx = 0;
               foreach track in pat.tracks
               {
                  // trace "xxx REC_UNMAP_OUT_MIDICH: findMidiCh="+_midiCh+" track.getOutCh(this, pat)="+track.getOutCh(this, pat);
                  if(track.getOutCh(this, pat) == _midiCh)
                     return trackIdx;
                  trackIdx++;
               }
            }
            break;
      }

      // Not mapped to a track
      return -1;
   }

   // <method.png>
   public method mapTrackIdxToRecordNote(int _trackIdx, int _recUnmapType) : int {
      // Called by NTS_Linnstrument (from UI thread)
      byte note = -1;

      switch(_recUnmapType)
      {
         default:
         case REC_UNMAP_CONFIG:
            note = STConfig.node_trig_seq_rec_base_note + _trackIdx;
            break;

         case REC_UNMAP_C3:
            note = 12*3 + _trackIdx;
            break;

         case REC_UNMAP_C3_WHITE:
            note = Scale.IndexToWhite(_trackIdx, (12*3)/*base*/);
            break;

         case REC_UNMAP_C4:
            note = 12*4 + _trackIdx;
            break;

         case REC_UNMAP_C4_WHITE:
            note = Scale.IndexToWhite(_trackIdx, (12*4)/*base*/);
            break;

         case REC_UNMAP_C5:
            note = 12*5 + _trackIdx;
            break;

         case REC_UNMAP_C5_WHITE:
            note = Scale.IndexToWhite(_trackIdx, (12*5)/*base*/);
            break;

         case REC_UNMAP_OUT_NOTE:
            // Find track that outputs the given _note
            NTS_Pattern *pat <= nodeGetCurrentEditPattern();
            if(null != pat)
            {
               NTS_Track track <= pat.getTrackByIndex(_trackIdx);
               byte outputMode = (-1 != track.forced_output_mode) ? track.forced_output_mode : output_mode;
               switch(outputMode)
               {
                  case OUT_SINGLECH_NOTE:
                  case OUT_SINGLECH_NOTE_PROBABILITY:
                  case OUT_MULTICH_NOTE:
                     note = int(track.arg3 + pat.arg3_offset);
                     break;
               }
            }
            break;

         case REC_UNMAP_OUT_MIDICH:
            // (note) intentionally left blank
            break;
      }

      return note;
   }

   // <method.png>
   protected method parseRecordNote(MIDIPipeFrame _framePlay,
                                    MIDIPipeFrame _frame,
                                    NTS_Pattern   _pat,
                                    int           _fltDevIdx,
                                    int           _fltCh,
                                    boolean       _bAllowRec,
                                    int           _recUnmapType,
                                    boolean       _bAllowUnmapChromatic,
                                    boolean       _bFrameRec
                                    ) {
      // bAuto=true: don't record, just play
      // (note) bFrameRec: when false, don't record (framePlay) output from plugin
      MIDIPipeEvent pev;
      int evIdx;
      int trackIdx;
      NTS_Track *track;
      NTS_Step st;
      NTS_TrackState *trackState;

      // Parse note off
      int numNoteOff = _frame.getNumEventsNoteOffByFlt(_fltDevIdx, _fltCh);
      evIdx = 0;
      loop(numNoteOff)
      {
         if(_frame.getEventByIdxAndFlt(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_OFF, _fltDevIdx, _fltCh))
         {
            if( (-1 == plugin_dev_idx) || (pev.devIdx != plugin_dev_idx) )
            {
               trackIdx = unmapRecordNoteToTrackIdx(pev.note, pev.midiCh, _recUnmapType, _bAllowUnmapChromatic);

               if(-1 != trackIdx)
               {
                  track <= _pat.getTrackByIndex(trackIdx);

                  if(_bFrameRec ||
                     ((track.getOutDevIdx(this) != pev.devIdx) || (track.getOutCh(this, _pat) != pev.midiCh))
                     )
                  {
                     track.recordOrPlayNoteOff(_framePlay, this, _pat, _bAllowRec);

                     trackState <= getTrackStateByIndex(trackIdx);
                     trackState.handleTrig(false);
                  }
               }
            }
         }

         // Next event
         evIdx++;
      }

      // Parse note on
      int numNoteOn = _frame.getNumEventsNoteOnByFlt(_fltDevIdx, _fltCh);
      // if(numNoteOn > 0)
      //    trace "xxx numNoteOn="+numNoteOn;
      float velIdx;
      evIdx = 0;
      loop(numNoteOn)
      {
         if(_frame.getEventByIdxAndFlt(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_ON, _fltDevIdx, _fltCh))
         {
            if( (-1 == plugin_dev_idx) || (pev.devIdx != plugin_dev_idx) )
            {
               // trace "xxx nts: noteOn: plugin_dev_idx="+plugin_dev_idx+" pev.devIdx="+pev.devIdx;
               // trace "xxx pev.note="+pev.note;
               trackIdx = unmapRecordNoteToTrackIdx(pev.note, pev.midiCh, _recUnmapType, _bAllowUnmapChromatic);

               if(-1 != trackIdx)
               {
                  track <= _pat.getTrackByIndex(trackIdx);

                  if(_bFrameRec ||
                     ((track.getOutDevIdx(this) != pev.devIdx) || (track.getOutCh(this, _pat) != pev.midiCh))
                     )
                  {
                     // Note on
                     velIdx = track.findVelocityIndexByVelocity(pev.velocity);

                     track.recordOrPlayNoteOn(_framePlay,
                                              this,
                                              _pat,
                                              velIdx/*arg1*/,
                                              pev.duration/*arg2*/,
                                              _bAllowRec/*note*/,
                                              false/*bAllowRecMod*/,
                                              NodeTrigSeq.INVALID_VALUE/*mod1*/,
                                              NodeTrigSeq.INVALID_VALUE/*mod2*/
                                              );

                     trackState <= getTrackStateByIndex(trackIdx);
                     trackState.handleTrig(true);
                  }
               }
            }
         }

         // Next event
         evIdx++;
      }
   }

   // <method.png>
   protected method recordOrPlayMod(MIDIPipeFrame _framePlay,
                                    MIDIPipeFrame _frame,
                                    NTS_Pattern   _pat,
                                    int           _fltDevIdx,
                                    int           _fltCh,
                                    boolean       _bAllowRec,
                                    boolean       _bAllowRpnCtl,
                                    boolean       _bPlaySeq,
                                    boolean       _bAllowModOutUnmap
                                    ) {
      NTS_Track *track;

      foreach track in _pat.tracks
      {
         track.recordOrPlayMod(_framePlay,
                               _frame,
                               this,
                               _pat,
                               _fltDevIdx,
                               _fltCh,
                               _bAllowRec,
                               _bAllowRpnCtl,
                               _bPlaySeq,
                               _bAllowModOutUnmap
                               );
      }
   }

   // <method.png>
   protected method handleMuteRepeatAutoOffTicks(NTS_Pattern _pat) {
      NTS_Track *track;
      int trackIdx = 0;

      foreach track in _pat.tracks
      {
         NTS_TrackState trackState <= getTrackStateByIndex(trackIdx);

         if(trackState.global_mute_auto_off_ticks > 0)
         {
            if(0 == --trackState.global_mute_auto_off_ticks)
            {
               node_queued_b_mute_temp = false;
               trackState.handleGlobalMute(false, 0/*autoOffTicks*/);
            }
         }

         if(trackState.flip_mute_auto_off_ticks > 0)
         {
            if(0 == --trackState.flip_mute_auto_off_ticks)
            {
               trackState.handleFlipMute(false, 0/*autoOffTicks*/);
            }
         }

         if(trackState.repeat_auto_off_ticks > 0)
         {
            if(0 == --trackState.repeat_auto_off_ticks)
            {
               trackState.queueRepeat(this,
                                      false/*bEnable*/,
                                      false/*bMayQueue*/
                                      );
               trackState.handleRepeat(false, 0/*autoOffTicks*/);
            }
         }

         // Next track
         trackIdx++;
      }
   }

   // <method.png>
   protected method parseTrackMuteRepeat2(MIDIPipeFrame _frame, NTS_Pattern _pat, int _devFilter, int _chFilter) {
      int numRPN;
      MIDIPipeEvent pev;
      int evIdx;
      int rpnSubIdx;
      int trackIdx;
      NTS_Track *track;
      NTS_TrackState *trackState;

      numRPN = _frame.getNumEventsRPNByFlt(_devFilter, _chFilter);

      evIdx = 0;
      loop(numRPN)
      {
         if(_frame.getEventByIdxAndFlt(evIdx, pev, MIDIPIPE_EVENT_TYPE_RPN, _devFilter, _chFilter))
         {
            if(RPN_TRIGSEQ_TRACK1_REPEAT_ENABLE <= pev.rpn <= RPN_TRIGSEQ_TRACK16_NUM_REPEATS)
            {
               rpnSubIdx = (pev.rpn - RPN_TRIGSEQ_TRACK1_REPEAT_ENABLE) % 10;
               trackIdx = (pev.rpn - RPN_TRIGSEQ_TRACK1_REPEAT_ENABLE) / 10;

               track <= _pat.getTrackByIndex(trackIdx);
               trackState <= getTrackStateByIndex(trackIdx);

               switch(rpnSubIdx)
               {
                  case 0: // REPEAT_ENABLE
                     boolean bRepEnable = (0 == pev.rpnValue) ? false : (2 == pev.rpnValue) ? maybe : true;
                     trackState.queueRepeat(this,
                                            bRepEnable,
                                            true/*bMayQueue*/
                                            );
                     trackState.handleRepeat(false != bRepEnable, 0/*autoNoteOffTicks*/);
                     break;

                  case 1: // REPEAT_NOTE_LENGTH
                     track.setTemporaryRepeatNoteLength(trackState, (pev.rpnValue >= 64) ? -1 : pev.rpnValue);
                     break;

                  case 2: // NUM_REPEATS
                     track.setTemporaryNumRepeats(trackState, (pev.rpnValue >= 64) ? -1 : pev.rpnValue);
                     break;

                  case 3: // VELOCITY_SCALING
                     if(pev.rpnValue > 255)
                        trackState.rpn_vel_scl = 1.0;
                     else
                        trackState.rpn_vel_scl = Utils.Bipolar8ToScale(pev.rpnValue, 8, 8);
                     break;

                  case 4: // DURATION_SCALING
                     if(pev.rpnValue > 255)
                        trackState.rpn_dur_scl = 1.0;
                     else
                        trackState.rpn_dur_scl = Utils.Bipolar8ToScale(pev.rpnValue, 4, 4);
                     break;
               }
            }
            else if(RPN_TRIGSEQ_GLOBAL_REPEAT_ENABLE == pev.rpn)
            {
               handleGlobalRepeatEnable(_pat,
                                        (0 == pev.rpnValue) ? false : (2 == pev.rpnValue) ? maybe : true,
                                        0/*autoNoteOffTicks*/
                                        );
            }
            else if(RPN_TRIGSEQ_GLOBAL_REPEAT_NOTE_LENGTH == pev.rpn)
            {
               current_repeat_note_length = (pev.rpnValue >= 64) ? -1 : pev.rpnValue;
            }
            else if(RPN_TRIGSEQ_GLOBAL_NUM_REPEATS == pev.rpn)
            {
               current_num_repeats = (pev.rpnValue >= 64) ? -1 : pev.rpnValue;
            }
         }

         // Next event
         evIdx++;
      }

      // Parse note off
      int numNoteOff = _frame.getNumEventsNoteOffByFlt(_devFilter, _chFilter);
      evIdx = 0;
      loop(numNoteOff)
      {
         if(_frame.getEventByIdxAndFlt(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_OFF, _devFilter, _chFilter))
         {
            if((STConfig.node_trig_seq_rec_global_repeat == pev.note) || (STConfig.node_trig_seq_rec_global_repeat_if_trig == pev.note))
            {
               handleGlobalRepeatEnable(_pat,
                                        false/*bEnable*/,
                                        0/*autoNoteOffTicks*/
                                        );
            }
            else if(STConfig.node_trig_seq_rec_roll_base_note <= pev.note < (STConfig.node_trig_seq_rec_roll_base_note + NTS_Pattern.NUM_TRACKS))
            {
               trackIdx = pev.note - STConfig.node_trig_seq_rec_roll_base_note;
               track <= _pat.getTrackByIndex(trackIdx);
               trackState <= getTrackStateByIndex(trackIdx);
               trackState.queueRepeat(this,
                                      false/*bEnable*/,
                                      false/*bMayQueue*/
                                      );
               trackState.handleRepeat(false, 0/*autoOffTicks*/);
            }
            else if(STConfig.node_trig_seq_rec_mute_base_note <= pev.note < (STConfig.node_trig_seq_rec_mute_base_note + NTS_Pattern.NUM_TRACKS))
            {
               trackIdx = pev.note - STConfig.node_trig_seq_rec_mute_base_note;
               trackState <= getTrackStateByIndex(trackIdx);
               trackState.handleFlipMute(false, 0/*autoOffTicks*/);
            }
            else if(STConfig.node_trig_seq_rec_global_mute == pev.note)
            {
               node_queued_b_mute_temp = false;
               foreach trackState in track_states
               {
                  trackState.handleGlobalMute(false, 0/*autoOffTicks*/);
               }
            }
         }

         // Next event
         evIdx++;
      }

      // Parse note on
      int numNoteOn = _frame.getNumEventsNoteOnByFlt(_devFilter, _chFilter);
      evIdx = 0;
      loop(numNoteOn)
      {
         if(_frame.getEventByIdxAndFlt(evIdx, pev, MIDIPIPE_EVENT_TYPE_NOTE_ON, _devFilter, _chFilter))
         {
            if(STConfig.node_trig_seq_rec_global_repeat_if_trig == pev.note)
            {
               handleGlobalRepeatEnable(_pat,
                                        maybe/*bEnable*/,
                                        pev.duration/*autoOffTicks*/
                                        );
            }
            if(STConfig.node_trig_seq_rec_global_repeat == pev.note)
            {
               handleGlobalRepeatEnable(_pat,
                                        true/*bEnable*/,
                                        pev.duration/*autoOffTicks*/
                                        );
            }
            else if(STConfig.node_trig_seq_rec_roll_base_note <= pev.note < (STConfig.node_trig_seq_rec_roll_base_note + NTS_Pattern.NUM_TRACKS))
            {
               trackIdx = pev.note - STConfig.node_trig_seq_rec_roll_base_note;
               track <= _pat.getTrackByIndex(trackIdx);
               trackState <= getTrackStateByIndex(trackIdx);
               track.setCurrentRepeatNoteLength(trackState,
                                                (-1 == current_repeat_note_length) ? track.repeat_note_length : current_repeat_note_length
                                                );
               track.setCurrentNumRepeats(trackState,
                                          (-1 == current_num_repeats) ? track.num_repeats : current_num_repeats
                                          );
               trackState.queueRepeat(this,
                                      true/*bEnable*/,
                                      true/*bMayQueue*/
                                      );
               trackState.handleRepeat(true, pev.duration/*autoOffTicks*/);
            }
            else if(STConfig.node_trig_seq_rec_mute_base_note <= pev.note < (STConfig.node_trig_seq_rec_mute_base_note + NTS_Pattern.NUM_TRACKS))
            {
               trackIdx = pev.note - STConfig.node_trig_seq_rec_mute_base_note;
               trackState <= getTrackStateByIndex(trackIdx);
               trackState.handleFlipMute(true, pev.duration/*autoOffTicks*/);
            }
            else if(STConfig.node_trig_seq_rec_global_mute == pev.note)
            {
               node_queued_b_mute_temp = true;
               foreach trackState in track_states
               {
                  trackState.handleGlobalMute(true, pev.duration/*autoOffTicks*/);
               }
            }
         }

         // Next event
         evIdx++;
      }
   }

   // <method.png>
   protected method parseTrackMuteRepeat(MIDIPipeFrame _frame, NTS_Pattern _pat) {
      // Handle RPN_TRIGSEQ_TRACK1_REPEAT_ENABLE..RPN_TRIGSEQ_TRACK16_NUM_REPEATS

      if(b_auto_filter_a)
      {
         parseTrackMuteRepeat2(_frame, _pat, auto_dev_filter_a, auto_ch_filter_a);
      }

      if(b_auto_filter_b)
      {
         parseTrackMuteRepeat2(_frame, _pat, auto_dev_filter_b, auto_ch_filter_b);
      }
   }

   // <method_set.png>
   public =replay= method setEnableForceStepRecord(boolean _bEnable) {
      b_force_step_record = _bEnable;
   }

   // <method_get.png>
   public virtual nodeIsArmedForRecording() : boolean {
      return b_recording;
   }

   // <method_set.png>
   public =replay= virtual nodeArmForRecording(boolean _bEnable) : boolean {
      if(b_recording)
         stopRec();
      else
         startRec();
      return b_recording;
   }

   // <method.png>
   public virtual nodeSupportsHWInterface(int _outDevIdx, byte _midiCh) : boolean {
      return (plugin_dev_idx == _outDevIdx);
   }

   // <method_get.png>
   public virtual nodeGetSupportedRPNs() : IntArray {
      return [
         // RPN_CTL_0,  RPN_CTL_1, RPN_CTL_2,  RPN_CTL_3,  RPN_CTL_4,  RPN_CTL_5,  RPN_CTL_6,  RPN_CTL_7,
         // RPN_CTL_8,  RPN_CTL_9, RPN_CTL_10, RPN_CTL_11, RPN_CTL_12, RPN_CTL_13, RPN_CTL_14, RPN_CTL_15,

         RPN_COMMON_UI_PRGCHG,
         RPN_COMMON_MUTE_TEMP, // nodeParseRPN_Mute
         RPN_COMMON_MUTE_TEMP_TOGGLE,
         RPN_COMMON_MUTE_TEMP_1_8,
         RPN_COMMON_MUTE_TEMP_9_16,
         RPN_COMMON_SOLO_TEMP_1_8,
         RPN_COMMON_SOLO_TEMP_9_16,
         RPN_COMMON_UI_NODE_MUTE,
         RPN_COMMON_UI_NODE_SOLO,
         RPN_COMMON_UI_PIPE_MUTE,
         RPN_COMMON_UI_PIPE_SOLO,

         RPN_COMMON_TRANSPOSE,  // nodeParseRPN_Transpose

         RPN_COMMON_VELOCITY_OFF,  // nodeParseRPN_Vel_Dur_Speed
         RPN_COMMON_VELOCITY_SCL,

         RPN_COMMON_VEL_SCL_TRACK_1,
         RPN_COMMON_VEL_SCL_TRACK_2,
         RPN_COMMON_VEL_SCL_TRACK_3,
         RPN_COMMON_VEL_SCL_TRACK_4,
         RPN_COMMON_VEL_SCL_TRACK_5,
         RPN_COMMON_VEL_SCL_TRACK_6,
         RPN_COMMON_VEL_SCL_TRACK_7,
         RPN_COMMON_VEL_SCL_TRACK_8,
         RPN_COMMON_VEL_SCL_TRACK_9,
         RPN_COMMON_VEL_SCL_TRACK_10,
         RPN_COMMON_VEL_SCL_TRACK_11,
         RPN_COMMON_VEL_SCL_TRACK_12,
         RPN_COMMON_VEL_SCL_TRACK_13,
         RPN_COMMON_VEL_SCL_TRACK_14,
         RPN_COMMON_VEL_SCL_TRACK_15,
         RPN_COMMON_VEL_SCL_TRACK_16,

         RPN_COMMON_DURATION_OFF,
         RPN_COMMON_DURATION_SCL,
         RPN_COMMON_SPEED,
         RPN_COMMON_POSITION,
         RPN_COMMON_SPEEDSYNCRATE,

         RPN_COMMON_PROB_ALL_REL,  // nodeParseRPN_Probability
         RPN_COMMON_PROB_TRACK_1,
         RPN_COMMON_PROB_TRACK_2,
         RPN_COMMON_PROB_TRACK_3,
         RPN_COMMON_PROB_TRACK_4,
         RPN_COMMON_PROB_TRACK_5,
         RPN_COMMON_PROB_TRACK_6,
         RPN_COMMON_PROB_TRACK_7,
         RPN_COMMON_PROB_TRACK_8,
         RPN_COMMON_PROB_TRACK_9,
         RPN_COMMON_PROB_TRACK_10,
         RPN_COMMON_PROB_TRACK_11,
         RPN_COMMON_PROB_TRACK_12,
         RPN_COMMON_PROB_TRACK_13,
         RPN_COMMON_PROB_TRACK_14,
         RPN_COMMON_PROB_TRACK_15,
         RPN_COMMON_PROB_TRACK_16,

         RPN_COMMON_RESET,
         RPN_COMMON_RUN,
         // RPN_COMMON_LENGTH,
         // RPN_COMMON_LENGTH_QUEUED,
         RPN_COMMON_OFFSET,
         RPN_COMMON_RESTART,
         RPN_COMMON_EXTCLK,
         RPN_COMMON_OFFLEN_MUL,
         RPN_COMMON_OFFLEN_DIV,
         RPN_COMMON_OFFLEN_SCALE,
         // RPN_COMMON_OFFSET_ADD,
         // RPN_COMMON_OFFSET_QUEUED,
         RPN_COMMON_SEEK_OFFSET,
         // RPN_COMMON_SEEK_REL_PRE,
         RPN_COMMON_GATE,
         RPN_COMMON_GATETIME_MUL,
         RPN_COMMON_GATETIME_DIV,
         RPN_COMMON_GATETIME,
         // RPN_COMMON_SEEK_REL_POST,
         // RPN_COMMON_RETRIG,
         RPN_COMMON_CLOCKGATE,
         RPN_COMMON_CLOCK,

         RPN_TRIGSEQ_GLOBAL_REPEAT_ENABLE,
         RPN_TRIGSEQ_GLOBAL_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_GLOBAL_NUM_REPEATS,

         RPN_TRIGSEQ_TRACK1_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK1_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK1_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK1_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK1_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK2_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK2_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK2_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK2_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK2_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK3_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK3_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK3_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK3_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK3_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK4_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK4_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK4_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK4_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK4_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK5_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK5_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK5_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK5_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK5_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK6_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK6_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK6_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK6_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK6_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK7_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK7_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK7_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK7_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK7_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK8_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK8_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK8_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK8_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK8_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK9_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK9_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK9_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK9_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK9_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK10_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK10_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK10_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK10_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK10_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK11_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK11_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK11_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK11_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK11_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK12_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK12_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK12_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK12_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK12_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK13_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK13_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK13_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK13_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK13_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK14_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK14_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK14_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK14_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK14_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK15_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK15_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK15_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK15_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK15_DURATION_SCALING,

         RPN_TRIGSEQ_TRACK16_REPEAT_ENABLE,
         RPN_TRIGSEQ_TRACK16_REPEAT_NOTE_LENGTH,
         RPN_TRIGSEQ_TRACK16_NUM_REPEATS,
         RPN_TRIGSEQ_TRACK16_VELOCITY_SCALING,
         RPN_TRIGSEQ_TRACK16_DURATION_SCALING,
              ];
   }

   // <method_get.png>
   public virtual nodeGetSupportedRPNSubMenus() : StringArray {
      return ["700..716: Probability",
              "800..815: Track Velocity Scale",
              "10010..10014: Track 1",
              "10020..10024: Track 2",
              "10030..10034: Track 3",
              "10040..10044: Track 4",
              "10050..10054: Track 5",
              "10060..10064: Track 6",
              "10070..10074: Track 7",
              "10080..10084: Track 8",
              "10090..10094: Track 9",
              "10100..10104: Track 10",
              "10110..10114: Track 11",
              "10120..10124: Track 12",
              "10130..10134: Track 13",
              "10140..10144: Track 14",
              "10150..10154: Track 15",
              "10160..10164: Track 16",
              ];
   }

   // <replay.png>
   public virtual nodeProcessFrame(MIDIPipeFrame _framePlay,
                                   MIDIPipeFrame _frameRec,
                                   boolean       _bMuted,
                                   boolean       _bPlaySeq
                                   ) {

      boolean bEditFocus = nodeIsEditorVisible();
      boolean bEditable = (maybe == b_rec) ? bEditFocus : b_rec;
      if(!bEditFocus)
      {
         if(node_gid == current_song.locked_keyjazz_node_gid)
         {
            bEditFocus = true;

            // don't allow step-edit from any MIDI input when node is armed for recording but replay is not running
            //  (note) "arm-for-recording" enables b_recording
            bEditable = b_recording && replay.b_playing;
         }
      }
      if(-1 != current_song.locked_keyjazz_node_gid &&
         (current_song.locked_keyjazz_node_gid != node_gid)
         )
      {
         // Editor is visible but keyjazz is locked to other node
         bEditFocus = false;
         bEditable  = false;
      }

      if(bEditFocus)
         nodeHandleContextSensitiveAutoDevEvents(_frameRec, _framePlay);

      // // if(_bPlaySeq)
      // //    if(_bMuted)
      // //       trace "xxx NTS::nodeProcessFrame: bMuted=true";

      boolean bCapture = b_capture && replay.b_playing;
      MIDIPipeFrame frOutCapture;
      MIDIPipeFrame *frOutReplay;
      if(bCapture)
      {
         frOutCapture.empty();
         frOutReplay <= frOutCapture;
      }
      else
      {
         frOutReplay <= _framePlay;
      }

      boolean bAllowSeekPrgChgAndMute = !b_node_ignore_seek_prgchg_mute;

      if(-1 != plugin_dev_idx && !_bMuted)
      {
         if(null != editor_plugin)
         {
            editor_plugin.processFrame(_framePlay,
                                       _frameRec,
                                       bCapture ? frOutReplay : null,
                                       _bMuted,
                                       _bPlaySeq
                                       );
         }
      }

      if(bAllowSeekPrgChgAndMute)
      {
         handlePrgChg(_frameRec);
         handlePrgChg(_framePlay);
      }

      nodeSendQueuedPrgChgOut(_framePlay);


      NTS_Pattern *pat <= nodeGetCurrentPlayPattern();

      // [06Oct2024] master_len_16th is handled in NTS_Track::tick()
      // // if(null != pat)
      // // {
      // //    if(pat.master_len_16th > 0.0f)
      // //    {
      // //       int patMasterTicks = (pat.master_len_16th * current_song.ppq) / 4.0;
      // //       if(tick_nr >= patMasterTicks)
      // //       {
      // //          // // trace "xxx patMasterTicks="+patMasterTicks+" nodeGetLastPatternStartSongOffset()="+nodeGetLastPatternStartSongOffset();
      // //          // // nodeSeek(nodeGetLastPatternStartSongOffset());
      // //          tick_nr -= patMasterTicks;
      // //          // trace "xxx patMasterTicks="+patMasterTicks+" => tick_nr="+tick_nr;
      // //       }
      // //    }
      // // }

      if(_framePlay.numEventsRPN > 0 || _frameRec.numEventsRPN > 0)
      {
         short t;
         // trace "xxx frameRec.numEventsRPN="+_frameRec.numEventsRPN;

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_EXTCLK);
         if(t >= 0)
         {
            b_extclk = (0 != t);
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_RESTART);
         if(t >= 0)
         {
            nodeRestart();
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_RESET);
         if(t > 0)
         {
            nodeReset(false/*bSoft*/);
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_RUN);
         if(-1 != t)
         {
            b_run = (t > 0);
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFLEN_MUL);
         if(-1 != t)
         {
            if(t < 1)
               t = 1;
            offlen_multiplier = t;
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFLEN_DIV);
         if(-1 != t)
         {
            if(t < 1)
               t = 1;
            offlen_divisor = t;
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFLEN_SCALE);
         if(-1 != t)
         {
            if(t < 1)
               t = 1;
            offlen_scale_ticks = t;
         }

         if(bAllowSeekPrgChgAndMute)
         {
            t = getRPN(_framePlay, _frameRec, RPN_COMMON_OFFSET);
            if(t >= 0)
            {
               // (todo) queue seek
               nodeSeek(nodeGetLastPatternStartSongOffset() +
                        (t * offlen_scale_ticks * offlen_multiplier) / offlen_divisor
                        );
            }

            t = getRPN(_framePlay, _frameRec, RPN_COMMON_SEEK_OFFSET);
            if(t >= 0)
            {
               // seek immediately
               nodeSeek(nodeGetLastPatternStartSongOffset() +
                        (t * offlen_scale_ticks * offlen_multiplier) / offlen_divisor
                        );
            }
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATETIME_MUL);
         if(t >= 1)
         {
            gate_time_mul = t;
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATETIME_DIV);
         if(t >= 1)
         {
            gate_time_div = t;
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATETIME);
         if(t >= 1)
         {
            gate_time = t;
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_GATE);
         if(t >= 0)
         {
            gate_countdown = ((gate_time * gate_time_mul) / gate_time_div);
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_CLOCKGATE);
         if(t >= 0)
         {
            // trace "xxx ["+current_song.song_offset+"] TrigSeq recv extclk";

            gate_countdown = ((gate_time * gate_time_mul) / gate_time_div);

            if(b_clock)
            {
               // New clock signal before gate time expired
               tick_nr = tick_nr_gate + ((gate_time * gate_time_mul) / gate_time_div);
               tick_nr_gate = tick_nr;
            }
            else
            {
               b_clock = true;
            }
         }

         t = getRPN(_framePlay, _frameRec, RPN_COMMON_CLOCK);
         if(t >= 0)
         {
            if(b_clock)
            {
               // New clock signal before gate time expired
               tick_nr = tick_nr_gate + ((gate_time * gate_time_mul) / gate_time_div);
               tick_nr_gate = tick_nr;
            }
            else
            {
               b_clock = true;
            }
         }

         // Handle RPN_COMMON_VELOCITY_OFF, RPN_COMMON_VELOCITY_SCL, RPN_COMMON_DURATION_OFF, RPN_COMMON_DURATION_SCL, RPN_COMMON_SPEED
         nodeParseRPN_Vel_Dur_Speed(_framePlay, _frameRec);
         nodeParseRPN_Vel_Track(_framePlay, _frameRec);
         nodeParseRPN_Dur_Track(_framePlay, _frameRec);

         nodeParseRPN_Transpose(_framePlay, _frameRec);

         // Handle MUTE, MUTE_TOGGLE, MUTE_TEMP, MUTE_TEMP_TOGGLE
         if(bAllowSeekPrgChgAndMute)
         {
            int oldSoloMask = node_solo_temp_track_mask;
            nodeParseRPN_Mute(_framePlay, _frameRec);
            if(node_solo_temp_track_mask != oldSoloMask)
            {
               // (note) may update node_mute_temp_track_mask
               updateTempSoloStates();
            }
            if(-1 != queued_node_mute_temp_track_mask_1_8)
            {
               if(queued_node_mute_temp_track_mask_1_8 != (node_mute_temp_track_mask & 255))
               {
                  updateTempMuteStates8((node_mute_temp_track_mask&255) ^ queued_node_mute_temp_track_mask_1_8,
                                        0/*trackOffset*/
                                        );
               }

               queued_node_mute_temp_track_mask_1_8 = -1;
            }
            if(-1 != queued_node_mute_temp_track_mask_9_16)
            {
               if(queued_node_mute_temp_track_mask_9_16 != (node_mute_temp_track_mask >> 8))
               {
                  updateTempMuteStates8((node_mute_temp_track_mask >> 8) ^ queued_node_mute_temp_track_mask_9_16,
                                        8/*trackOffset*/
                                        );
               }

               queued_node_mute_temp_track_mask_9_16 = -1;
            }
         }

         nodeParseRPN_Probability(_framePlay, _frameRec);
      }

      _bPlaySeq = _bPlaySeq && b_run;


      // Play pattern/tracks
      NTS_Track *track;

      if(null != pat)
      {
         if(b_learn_xform_active && b_learn_xform)
         {
            transformLearnNotes(_frameRec);
         }
         else
         {
            // Auto-disable mute/repeat (when starting via note-on with non-zero duration)
            handleMuteRepeatAutoOffTicks(pat);

            // Handle Note On/Off and RPN_TRIGSEQ_TRACK1_REPEAT_ENABLE..RPN_TRIGSEQ_TRACK16_NUM_REPEATS
            if(!b_force_step_record)
            {
               parseTrackMuteRepeat(_framePlay, pat); // auto a+b
               parseTrackMuteRepeat(_frameRec, pat);
            }

            MIDIPipeFrame frameRecCur <= _frameRec;
            MIDIPipeFrame frameRecRestart;
            if(_bPlaySeq && b_queued_rec_restart)
            {
               if(0 == int(tick_nr) % current_song.getNumTicksPerBeat())
               {
                  b_queued_rec_restart = false;
                  frameRecRestart = fr_queued_rec_restart_rec;
                  fr_queued_rec_restart_rec.empty();
                  frameRecRestart.mergeFrame(_frameRec);
                  frameRecCur <= frameRecRestart;
                  // // nodeSeek(nodeGetLastPatternStartSongOffset() + 0);
                  current_song.seek(nodeGetLastPatternStartSongOffset());
               }
               else
               {
                  fr_queued_rec_restart_rec.mergeFrame(_frameRec);
                  _frameRec.empty();
               }
            }

            if(bEditable && !b_force_step_record && !_bMuted)
            {
               if(b_rec_prev)
               {
                  parseRecordNote(_framePlay, _framePlay,
                                  pat,
                                  rec_dev_idx, rec_ch,
                                  !_bMuted/*bAllowRec*/,
                                  rec_unmap_type,
                                  false/*bAllowUnmapChromatic*/,
                                  false/*bFrameRec*/
                                  );
               }
               parseRecordNote(_framePlay, frameRecCur,
                               pat,
                               rec_dev_idx, rec_ch,
                               !_bMuted/*bAllowRec*/,
                               rec_unmap_type,
                               false/*bAllowUnmapChromatic*/,
                               true/*bFrameRec*/
                               );

               // (note) mute/repeat keys might collide with track record keys (depending on rec_unmap_type)
               if(b_rec_mute_repeat)
               {
                  parseTrackMuteRepeat2(_framePlay, pat, rec_dev_idx, rec_ch);
                  parseTrackMuteRepeat2(_frameRec, pat, rec_dev_idx, rec_ch);
               }

               // Record Mod1+2 via 'play' frame / rec_dev+ch or modOut dev/ch (while editor is visible)
               recordOrPlayMod(_framePlay,
                               _framePlay,
                               pat,
                               rec_dev_idx,
                               rec_ch,
                               (b_rec_prev && b_recording && !_bMuted)/*bAllowRec*/,
                               bEditFocus/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               false/*bAllowModOutUnmap*/
                               );

               // Record Mod1+2 via 'rec' frame / rec_dev+ch (while editor is visible)
               recordOrPlayMod(_framePlay,
                               frameRecCur,
                               pat,
                               rec_dev_idx,
                               rec_ch,
                               (bEditable && b_recording && !_bMuted)/*bAllowRec*/,
                               bEditFocus/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               false/*bAllowModOutUnmap*/
                               );
            }

            if( (true == b_rec_mod_unmap) || (bEditFocus && (maybe == b_rec_mod_unmap)) )
            {
               // Record Mod1+2 via 'play' frame / modOut dev/ch
               recordOrPlayMod(_framePlay,
                               _framePlay,
                               pat,
                               9999999/*fltDev*/,
                               9999999/*fltCh*/,
                               (b_rec_prev && b_recording && !_bMuted)/*bAllowRec*/,
                               false/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               true/*bAllowModOutUnmap*/
                               );

               // Record Mod1+2 via 'rec' frame / modOut dev/ch
               recordOrPlayMod(_framePlay,
                               frameRecCur,
                               pat,
                               rec_dev_idx,
                               rec_ch,
                               (bEditable && b_recording && !_bMuted)/*bAllowRec*/,
                               false/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               true/*bAllowModOutUnmap*/
                               );
            }


            if(b_auto_filter_a && !b_force_step_record && !_bMuted)
            {
               parseRecordNote(_framePlay, _framePlay,
                               pat,
                               auto_dev_filter_a, auto_ch_filter_a,
                               false/*bAllowRec*/,
                               REC_UNMAP_CONFIG,
                               true/*bAllowUnmapChromatic*/,
                               false/*bFrameRec*/
                               );
               parseRecordNote(_framePlay, frameRecCur,
                               pat,
                               auto_dev_filter_a, auto_ch_filter_a,
                               false/*bAllowRec*/,
                               REC_UNMAP_CONFIG,
                               true/*bAllowUnmapChromatic*/,
                               true/*bFrameRec*/
                               );

               // Record Mod1+2 via 'play' frame / auto A (supports bg-recording)
               recordOrPlayMod(_framePlay,
                               _framePlay,
                               pat,
                               auto_dev_filter_a,
                               auto_ch_filter_a,
                               (b_rec_prev && b_recording && !_bMuted)/*bAllowRec*/,
                               true/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               false/*bAllowModOutUnmap*/
                               );

               // Record Mod1+2 via 'rec' frame / auto A
               recordOrPlayMod(_framePlay,
                               frameRecCur,
                               pat,
                               auto_dev_filter_a,
                               auto_ch_filter_a,
                               (bEditable && b_recording && !_bMuted)/*bAllowRec*/,
                               true/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               false/*bAllowModOutUnmap*/
                               );
            }

            if(b_auto_filter_b && !b_force_step_record && !_bMuted)
            {
               parseRecordNote(_framePlay, _framePlay,
                               pat,
                               auto_dev_filter_b, auto_ch_filter_b,
                               false/*bAllowRec*/,
                               REC_UNMAP_CONFIG,
                               true/*bAllowUnmapChromatic*/,
                               false/*bFrameRec*/
                               );
               parseRecordNote(_framePlay, frameRecCur,
                               pat,
                               auto_dev_filter_b, auto_ch_filter_b,
                               false/*bAllowRec*/,
                               REC_UNMAP_CONFIG,
                               true/*bAllowUnmapChromatic*/,
                               true/*bFrameRec*/
                               );

               // Record Mod1+2 via 'play' frame / auto B (supports bg-recording)
               recordOrPlayMod(_framePlay,
                               _framePlay,
                               pat,
                               auto_dev_filter_b,
                               auto_ch_filter_b,
                               (b_rec_prev && b_recording && !_bMuted)/*bAllowRec*/,
                               true/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               false/*bAllowModOutUnmap*/
                               );

               // Record Mod1+2 via 'rec' frame / auto B
               recordOrPlayMod(_framePlay,
                               frameRecCur,
                               pat,
                               auto_dev_filter_b,
                               auto_ch_filter_b,
                               (bEditable && b_recording && !_bMuted)/*bAllowRec*/,
                               true/*bAllowRpnCtl*/,
                               _bPlaySeq,
                               false/*bAllowModOutUnmap*/
                               );
            }

            if(bEditFocus)
            {
               // // _frameRec.deleteNoteOnsByFlt(rec_dev_idx, rec_ch);
               // // _frameRec.deleteNoteOffsByFlt(rec_dev_idx, rec_ch);

               // [06Oct2024] remove _all_ events
               //              (note) otherwise, e.g. polypressure would still be passed on to e.g. remote_audio dev
               _frameRec.deleteEventsByFlt(rec_dev_idx, rec_ch);
            }
         }

         // Update muted state and include temporary mutes
         _bMuted |= nodeHandleQueuedMuteTemp();

         if(gate_countdown > 0)
         {
            foreach track in pat.tracks
            {
               track.tick(frOutReplay, _bMuted, _bPlaySeq, this, pat);
            }
         }
      }
      else
      {
         _bMuted |= nodeHandleQueuedMuteTemp();
      }

      if(bCapture)
      {
         mon_capture.captureAdd(frOutReplay, true/*bAdvance*/);
         _framePlay.mergeFrame(frOutReplay);
      }

      if(_bPlaySeq)
      {
         if(b_extclk)
         {
            if(gate_countdown > 0)
            {
               gate_countdown--;

               if(gate_countdown <= 0)
               {
                  if(b_clock)
                  {
                     // Advance
                     b_clock = false;
                     tick_nr = tick_nr_gate + ((gate_time * gate_time_mul) / gate_time_div);
                     tick_nr_gate = tick_nr;
                  }
                  else
                  {
                     // Back to gate start
                     tick_nr = tick_nr_gate;
                  }
               }
               else
               {
                  tick_nr += rpn_com_speed_scl;
               }
            }
         }
         else
         {
            tick_nr += rpn_com_speed_scl;
         }
      }

      queued_step_idx = -1;
   }

}
