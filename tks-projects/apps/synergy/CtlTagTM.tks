// ----
// ---- file   : CtlTagTM.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2015-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- changed: 17May2015, 14Nov2015, 08Dec2018, 14Oct2023, 22Mar2024
// ----
// ----
// ----

module MCtlTagTM;

use namespace ui;
use namespace st2;


// <class.png>
class CtlTagTM : TableModel {

   define int COL_DEV  = 0;
   define int COL_CH   = 1;
   define int COL_TYPE = 2;
   define int COL_TAG  = 3;


   public virtual getNumColumns() : int {
      return 4;
   }

   public virtual getColumnCaption(int _col) : String {
      return ["Device", "Ch.", "Event Type", "Tag Name"][_col];
   }

   public virtual getNumRows() : int {
      return current_song.ctltag_entries.numElements;
   }

   public virtual getCellCaption(int _col, _row) : String {
      CtlTagEntry en <= current_song.ctltag_entries.get(_row);

      if(null != en)
      {
         switch(_col)
         {
            case COL_DEV:
               return en.do_dev;

            case COL_CH:
               return en.do_ch;

            case COL_TYPE:
               return en.do_type;

            case COL_TAG:
               return en.b_name_edited ? (en.tag_name+"*") : en.tag_name;
         }
      }
   }

   public virtual getMinimumColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_DEV:
            return 100;

         case COL_CH:
            return 24;

         case COL_TYPE:
            return 170;

         case COL_TAG:
            return 100;
      }
   }

   public virtual getPreferredColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_DEV:
            return 120;

         case COL_CH:
            return 24;

         case COL_TYPE:
            return 240;

         case COL_TAG:
            return 120;
      }
   }

   public virtual getCellRenderer(int _col, int _row, int _visibleRow) : Layer {
      Label lb <= TableModel::getCellRenderer(_col, _row, _visibleRow);

      if(COL_TAG == _col)
         lb.setFontByName("big8");
      else
         lb.setFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL);

      lb.setBackgroundTint(0);

      CtlTagEntry en <= current_song.ctltag_entries.get(_row);
      if(null != en)
      {
         if(en.group_idx == (root_form.pg_ctltag.cur_group_idx))
            lb.setBackgroundTint(#20004f4f);
      }

      return lb;
   }

   // <ui_handle.png>
   public virtual handleCellEditing(TableCellEditor _tce) {
      switch(_tce.table_col)
      {
         case COL_TAG:
            // // handleCellEdited(_tce);
            break;
      }
   }

   // <ui_handle.png>
   public virtual handleCellEdited(TableCellEditor _tce) {
      CtlTagEntry en <= current_song.ctltag_entries.get(_tce.table_row);
      if(null != en)
      {
         TableCellEditorString *tcestr;

         switch(_tce.table_col)
         {
            case COL_TAG:
               tcestr <= _tce;
               local String name = tcestr.getText();
               en.tag_name = name;
               tableModelChanged();
               PageCtlTag pgCtlTag <= root_form.pg_ctltag;
               pgCtlTag.handleEntrySelected();  // update tf_name
               break;
         }
      }
   }

   // <ui.png>
   public virtual getCellEditor(int _col, int _row) : TableCellEditor {
      CtlTagEntry en <= current_song.ctltag_entries.get(_row);
      if(null != en)
      {
         TableCellEditorString *tcestr;

         switch(_col)
         {
            case COL_TAG:
               tcestr <= new TableCellEditorString;
               tcestr.initStringEditor(en.tag_name);
               tcestr.setMaxCols(32);
               return deref tcestr;
         }
      }
   }
}
