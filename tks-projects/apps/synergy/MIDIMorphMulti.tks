// ----
// ---- file   : MIDIMorphMulti.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2018-2020 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 06Jun2018
// ---- changed: 20Feb2020
// ----
// ----
// ----

module MMIDIMorphSceneMulti;

use namespace st2;


// <class.png>
class MIDIMorphMulti {
   String   name;
   IntArray scene_indices;  // scene idx per group, -1=don't change


   // <method_init.png>
   public method init() {
      scene_indices.allocAndFill(MIDIMorphScene.NUM_GROUPS, -1);
   }

   // <method_init.png>
   public method clear() {
      scene_indices.fill(-1);
   }

   // <method.png>
   public method copyFrom(MIDIMorphMulti _o) {
      name          = _o.name;
      scene_indices = _o.scene_indices;
   }

   // <method_get.png>
   public method getSceneNrStringByGroupIdx(int _groupIdx) {
      int idx = scene_indices.get(_groupIdx);
      if(idx >= 0)
      {
         MIDIMorphScene mms <= MIDIMorphScene.GetSceneByIdx(_groupIdx, idx);
         return String(idx + 1)+":"+mms.mms_name;
      }
      else
      {
         return "-";
      }
   }

   // <method.png>
   public method incGroup(int _groupIdx) : int {
      int idx = scene_indices.get(_groupIdx);
      if(idx < (MIDIMorphScene.NUM_SCENES_PER_GROUP-1))
      {
         scene_indices[_groupIdx] = idx + 1;
      }
      else
      {
         scene_indices[_groupIdx] = -1;
      }
      return scene_indices[_groupIdx];
   }

   // <method.png>
   public method decGroup(int _groupIdx) : int {
      int idx = scene_indices.get(_groupIdx);
      if(idx >= 0)
      {
         scene_indices[_groupIdx] = idx - 1;
      }
      else
      {
         scene_indices[_groupIdx] = MIDIMorphScene.NUM_SCENES_PER_GROUP - 1;
      }
      return scene_indices[_groupIdx];
   }

   // <save.png>
   public method saveState(Stream ofs) {
      // Ver
      ofs.i16 = 2;

      // Write name (v2+)
      Utils.WriteString(ofs, name);

      // Write Per group scene indices
      Utils.WriteIntArray(ofs, scene_indices);
   }

   // <load.png>
   public method loadState(Stream ifs) : boolean {
      // Ver
      short ver = ifs.i16;

      if(ver >= 1)
      {
         if(ver >= 2)
         {
            // Read name (v2+)
            Utils.ReadString(ifs, name);
         }

         // Read Per group scene indices
         Utils.ReadIntArray(ifs, scene_indices);

         return true;
      }
      return false;
   }

}
