// ----
// ---- file   : NodeKeymap.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2016-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- changed: 21Jul2016
// ---- changed: 22Jul2016, 23Jul2016, 24Jul2016, 16Sep2016, 21Jan2017, 04Feb2017, 30Jul2017
// ----          10Aug2017, 12Aug2017, 03Sep2017, 04Jan2018, 07Mar2018, 04Apr2018, 27May2018
// ----          17Jun2018, 19Oct2019, 07Nov2019, 23Oct2020, 25Oct2020, 30Oct2020, 10Nov2020
// ----          02Jun2021, 21Jun2021, 01Jan2022, 03Feb2024, 28Feb2025
// ----
// ----
// ----

module MNodeKeymap;

use namespace ui;
use namespace st2;


// <class.png>
class NodeKeymapEntry {

   String  name;
   boolean b_auto_name;  // true=automatically generated name, false=user defined name. resets to auto when name is blank.

   define int NOTE_NONE   = 0;
   define int NOTE_ON     = 1;
   define int NOTE_OFF    = 2;
   define int NOTE_ON_OFF = 3;

   static StringArray note_mode_names = [
      "-",
      "On",
      "Off",
      "On/Off"
                                         ];

   byte match_note;      // 0..127
   int  match_note_mode; // NOTE_xxx

   byte note_range;

   int  dst_dev_idx;
   byte dst_ch;

   byte fixed_send_note;
   int  fixed_send_note_mode; // NOTE_xxx
   int  fixed_send_note_duration;

   byte    velocity_min;
   byte    velocity_max;
   boolean b_normalize_velocity;

   define int VEL_CURVE_NONE   = 0;
   define int VEL_CURVE_EXP1   = 1;
   define int VEL_CURVE_EXP2   = 2;
   define int VEL_CURVE_EXP3   = 3;
   define int VEL_CURVE_LOG1   = 4;
   define int VEL_CURVE_LOG2   = 5;
   define int VEL_CURVE_LOG3   = 6;
   define int VEL_CURVE_TRI    = 7;
   define int VEL_CURVE_SIN    = 8;
   define int VEL_CURVE_GAUSS1 = 9;
   define int VEL_CURVE_GAUSS2 = 10;
   define int VEL_CURVE_GAUSS3 = 11;
   define int VEL_CURVE_GAUSS4 = 12;
   define int VEL_CURVE_GAUSS5 = 13;

   byte    velocity_curve_idx;  // 0=none/linear

   static StringArray velocity_curve_names = [
      "-",
      "A: Exponential 1",
      "B: Exponential 2",
      "C: Exponential 3",
      "D: Logarithmic 1",
      "E: Logarithmic 2",
      "F: Logarithmic 3",
      "G: Triangle",
      "H: Sin",
      "I: Gauss 1",
      "J: Gauss 2",
      "K: Gauss 3",
      "L: Gauss 4",
      "M: Gauss 5"
                                              ];

   static PointerArray velocity_curves = [
      // A: Exponential 1
      [ 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 36, 37, 38, 40, 42, 43, 45, 47, 49, 51, 53, 55, 57, 60, 62, 65, 67, 70, 73, 76, 79, 82, 85, 89, 92, 96, 100, 104, 108, 112, 117, 122, 127 ],

      // B: Exponential 2
      [ 0, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27, 28, 28, 29, 30, 30, 31, 32, 33, 33, 34, 35, 36, 37, 38, 38, 39, 40, 41, 42, 43, 44, 45, 47, 48, 49, 50, 51, 52, 54, 55, 56, 58, 59, 61, 62, 64, 65, 67, 68, 70, 72, 73, 75, 77, 79, 81, 83, 84, 87, 89, 91, 93, 95, 97, 100, 102, 105, 107, 110, 112, 115, 118, 121, 124, 127 ],

      // C: Exponential 3
      [ 0, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 25, 26, 26, 27, 27, 28, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 42, 42, 43, 44, 44, 45, 46, 47, 47, 48, 49, 50, 50, 51, 52, 53, 54, 55, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 79, 80, 81, 83, 84, 85, 87, 88, 89, 91, 92, 94, 95, 97, 98, 100, 101, 103, 105, 106, 108, 110, 111, 113, 115, 117, 119, 121, 123, 125, 127 ],

      // D: Logarithmic 1
      [ 0, 4, 9, 14, 18, 22, 26, 30, 34, 37, 41, 44, 47, 50, 53, 56, 59, 61, 64, 66, 69, 71, 73, 75, 77, 79, 81, 83, 84, 86, 88, 89, 90, 92, 93, 94, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 107, 108, 109, 109, 110, 111, 111, 112, 112, 113, 114, 114, 115, 115, 115, 116, 116, 117, 117, 117, 118, 118, 118, 119, 119, 119, 120, 120, 120, 120, 121, 121, 121, 121, 121, 122, 122, 122, 122, 122, 123, 123, 123, 123, 123, 123, 123, 123, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 126, 126, 126, 127 ],

      // E: Logarithmic 2
      [ 0, 3, 6, 9, 12, 14, 17, 20, 23, 25, 28, 30, 33, 35, 37, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 59, 61, 63, 64, 66, 68, 69, 71, 72, 74, 75, 76, 78, 79, 80, 81, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 100, 101, 102, 103, 103, 104, 105, 105, 106, 107, 107, 108, 109, 109, 110, 110, 111, 111, 112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 116, 117, 117, 118, 118, 118, 119, 119, 119, 120, 120, 120, 121, 121, 121, 122, 122, 122, 122, 123, 123, 123, 123, 124, 124, 124, 124, 125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 126, 127, 127, 127 ],

      // F: Logarithmic 3
      [ 0, 2, 4, 6, 8, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 30, 32, 34, 36, 37, 39, 41, 43, 44, 46, 47, 49, 50, 52, 53, 55, 56, 58, 59, 60, 62, 63, 64, 66, 67, 68, 69, 71, 72, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 84, 85, 86, 87, 87, 88, 89, 90, 91, 92, 93, 94, 94, 95, 96, 97, 98, 98, 99, 100, 101, 101, 102, 103, 103, 104, 105, 105, 106, 107, 107, 108, 108, 109, 110, 110, 111, 111, 112, 112, 113, 114, 114, 115, 115, 116, 116, 116, 117, 117, 118, 118, 119, 119, 120, 120, 120, 121, 121, 122, 122, 122, 123, 123, 124, 124, 124, 125, 125, 125, 126, 126, 126, 127],

      // G: Triangle
      [ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 127, 125, 123, 121, 119, 117, 115, 113, 111, 109, 107, 105, 103, 101, 98, 96, 94, 92, 90, 88, 86, 84, 82, 80, 78, 76, 74, 72, 70, 68, 66, 64, 62, 60, 58, 56, 54, 52, 50, 48, 46, 44, 42, 40, 38, 36, 34, 32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2, 0 ],

      // H: Sin
      [ 0, 3, 6, 9, 12, 15, 18, 21, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 54, 57, 60, 63, 66, 68, 71, 73, 76, 79, 81, 83, 86, 88, 90, 92, 95, 97, 99, 101, 103, 104, 106, 108, 110, 111, 113, 114, 115, 117, 118, 119, 120, 121, 122, 123, 124, 124, 125, 125, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 126, 126, 125, 125, 124, 124, 123, 122, 121, 120, 119, 118, 117, 115, 114, 113, 111, 110, 108, 106, 104, 103, 101, 99, 97, 95, 92, 90, 88, 86, 83, 81, 79, 76, 73, 71, 68, 66, 63, 60, 57, 54, 52, 49, 46, 43, 40, 37, 34, 31, 28, 25, 21, 18, 15, 12, 9, 6, 3, 0 ],

      // I: Gauss 1
      [ 0, 2, 4, 7, 9, 12, 14, 17, 19, 22, 25, 27, 30, 32, 35, 38, 41, 43, 46, 49, 52, 54, 57, 60, 62, 65, 68, 70, 73, 76, 78, 81, 83, 86, 88, 90, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 112, 114, 115, 117, 118, 119, 121, 122, 123, 124, 124, 125, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 126, 126, 125, 124, 124, 123, 122, 121, 119, 118, 117, 115, 114, 112, 111, 109, 107, 105, 103, 101, 99, 97, 95, 93, 90, 88, 86, 83, 81, 78, 76, 73, 70, 68, 65, 62, 60, 57, 54, 52, 49, 46, 43, 41, 38, 35, 32, 30, 27, 25, 22, 19, 17, 14, 12, 9, 7, 4, 2, 0 ],

      // J: Gauss 2
      [ 0, 1, 2, 4, 5, 7, 8, 10, 12, 13, 15, 17, 19, 21, 23, 25, 28, 30, 32, 35, 37, 40, 42, 45, 47, 50, 53, 56, 58, 61, 64, 67, 69, 72, 75, 78, 81, 83, 86, 89, 91, 94, 97, 99, 101, 104, 106, 108, 110, 112, 114, 116, 117, 119, 120, 121, 123, 124, 124, 125, 126, 126, 126, 127, 127, 126, 126, 126, 125, 124, 124, 123, 121, 120, 119, 117, 116, 114, 112, 110, 108, 106, 104, 101, 99, 97, 94, 91, 89, 86, 83, 81, 78, 75, 72, 69, 67, 64, 61, 58, 56, 53, 50, 47, 45, 42, 40, 37, 35, 32, 30, 28, 25, 23, 21, 19, 17, 15, 13, 12, 10, 8, 7, 5, 4, 2, 1, 0 ],

      // K: Gauss 3
      [ 0, 0, 0, 1, 1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 9, 10, 11, 12, 14, 15, 17, 19, 21, 23, 25, 27, 29, 32, 34, 37, 40, 43, 46, 49, 52, 55, 58, 62, 65, 69, 72, 76, 79, 82, 86, 89, 93, 96, 99, 102, 105, 108, 111, 113, 116, 118, 120, 121, 123, 124, 125, 126, 126, 127, 127, 126, 126, 125, 124, 123, 121, 120, 118, 116, 113, 111, 108, 105, 102, 99, 96, 93, 89, 86, 82, 79, 76, 72, 69, 65, 62, 58, 55, 52, 49, 46, 43, 40, 37, 34, 32, 29, 27, 25, 23, 21, 19, 17, 15, 14, 12, 11, 10, 9, 7, 6, 6, 5, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0 ],

      // L: Gauss 4
      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10, 12, 13, 15, 17, 19, 21, 23, 26, 28, 31, 34, 37, 41, 44, 48, 51, 55, 59, 63, 67, 72, 76, 80, 84, 88, 92, 96, 100, 104, 107, 111, 114, 116, 119, 121, 123, 124, 125, 126, 127, 127, 126, 125, 124, 123, 121, 119, 116, 114, 111, 107, 104, 100, 96, 92, 88, 84, 80, 76, 72, 67, 63, 59, 55, 51, 48, 44, 41, 37, 34, 31, 28, 26, 23, 21, 19, 17, 15, 13, 12, 10, 9, 8, 7, 6, 5, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],

      // M: Gauss 5
      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 4, 4, 5, 6, 7, 9, 10, 11, 13, 15, 17, 20, 22, 25, 28, 31, 34, 38, 42, 46, 50, 55, 59, 64, 69, 74, 78, 83, 88, 93, 97, 102, 106, 110, 113, 116, 119, 122, 124, 125, 126, 127, 127, 126, 125, 124, 122, 119, 116, 113, 110, 106, 102, 97, 93, 88, 83, 78, 74, 69, 64, 59, 55, 50, 46, 42, 38, 34, 31, 28, 25, 22, 20, 17, 15, 13, 11, 10, 9, 7, 6, 5, 4, 4, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]

                                           ];

   boolean b_fixed_velocity;
   byte    fixed_velocity;

   boolean b_fixed_polyat;
   byte    fixed_polyat;

   boolean b_fixed_pitchbend;
   short   fixed_pitchbend;

   boolean b_fixed_modwheel;
   byte    fixed_modwheel;

   boolean b_fixed_expression;
   byte    fixed_expression;

   boolean b_fixed_breathcontrol;
   byte    fixed_breathcontrol;

   define int PRGCHG_DISPLAY_DEC   = 0;
   define int PRGCHG_DISPLAY_HEX   = 1;
   define int PRGCHG_DISPLAY_PATNR = 2;

   boolean b_fixed_prgchg;  // maybe=send RPN_COMMON_UI_PRGCHG
   byte    fixed_prgchg;
   byte    fixed_prgchg_display_type;  // PRGCHG_DISPLAY_xxx

   define int RPN_PRESET_RESET               =  0;
   define int RPN_PRESET_RUN                 =  1;
   define int RPN_PRESET_STOP                =  2;
   define int RPN_PRESET_CLOCKGATE           =  3;
   define int RPN_PRESET_CLOCK               =  4;
   define int RPN_PRESET_GATE                =  5;
   define int RPN_PRESET_RETRIG              =  6;
   define int RPN_PRESET_RESTART             =  7;
   define int RPN_PRESET_TRACKS_MUTE         =  8;
   define int RPN_PRESET_TRACKS_UNMUTE       =  9;
   define int RPN_PRESET_RESVD_10            = 10;  // [19Oct2019] removed, was TRACKS_TOGGLE_MUTE
   define int RPN_PRESET_TEMP_MUTE           = 11;
   define int RPN_PRESET_TEMP_UNMUTE         = 12;
   define int RPN_PRESET_TEMP_TOGGLE_MUTE    = 13;
   define int RPN_PRESET_UI_NODE_MUTE        = 14;
   define int RPN_PRESET_UI_NODE_UNMUTE      = 15;
   define int RPN_PRESET_UI_NODE_TOGGLE_MUTE = 16;
   define int RPN_PRESET_UI_NODE_SOLO        = 17;
   define int RPN_PRESET_UI_NODE_UNSOLO      = 18;
   define int RPN_PRESET_UI_NODE_TOGGLE_SOLO = 19;
   define int RPN_PRESET_UI_PIPE_MUTE        = 20;
   define int RPN_PRESET_UI_PIPE_UNMUTE      = 21;
   define int RPN_PRESET_UI_PIPE_TOGGLE_MUTE = 22;
   define int RPN_PRESET_UI_PIPE_SOLO        = 23;
   define int RPN_PRESET_UI_PIPE_UNSOLO      = 24;
   define int RPN_PRESET_UI_PIPE_TOGGLE_SOLO = 25;

   static StringArray fixed_rpn_preset_names = [
      "Reset",               //  0
      "Run",                 //  1
      "Stop",                //  2
      "Clock+Gate",          //  3
      "Clock",               //  4
      "Gate",                //  5
      "Retrig",              //  6
      "Restart",             //  7
      "Mute Tracks",         //  8
      "Unmute Tracks",       //  9
      "-resvd 10-",          // 10   // was "Toggle Mute Tracks", [19Oct2019] removed
      "Mute Temp",           // 11
      "Unmute Temp",         // 12
      "Toggle Mute Temp",    // 13
      "UI Node Mute",        // 14
      "UI Node Unmute",      // 15
      "UI Node Toggle Mute", // 16
      "UI Node Solo",        // 17
      "UI Node Un-Solo",     // 18
      "UI Node Toggle Solo", // 19
      "UI Pipe Mute",        // 20
      "UI Pipe Unmute",      // 21
      "UI Pipe Toggle Mute", // 22
      "UI Pipe Solo",        // 23
      "UI Pipe Un-Solo",     // 24
      "UI Pipe Toggle Solo"  // 25
                                          ];

   boolean b_fixed_rpn_preset;
   byte    fixed_rpn_preset;




   // <method_init.png>
   public method init() {
      b_auto_name = true;

      match_note = 48;
      match_note_mode = NOTE_ON;

      note_range = 1;

      dst_dev_idx = -1;
      dst_ch = -1;

      fixed_send_note = -1;
      fixed_send_note_mode = NOTE_ON_OFF;
      fixed_send_note_duration = current_song.ppq / 4;  // 1/16

      velocity_min = 0;
      velocity_max = 127;
      b_normalize_velocity = true;
      velocity_curve_idx = 0;

      b_fixed_velocity = false;
      fixed_velocity = 127;

      b_fixed_polyat = false;
      fixed_polyat = 127;

      b_fixed_pitchbend = false;
      fixed_pitchbend = 0x2000;

      b_fixed_modwheel = false;
      fixed_modwheel = 64;

      b_fixed_expression = false;
      fixed_expression = 64;

      b_fixed_breathcontrol = false;
      fixed_breathcontrol = 64;

      b_fixed_prgchg = false;
      fixed_prgchg = 0;
      fixed_prgchg_display_type = PRGCHG_DISPLAY_PATNR;

      b_fixed_rpn_preset = false;
      fixed_rpn_preset = RPN_PRESET_UI_NODE_TOGGLE_MUTE;
   }

   // <method.png>
   public method copyFrom(NodeKeymapEntry _o) {

      name = _o.name;
      b_auto_name = _o.b_auto_name;

      match_note      = _o.match_note;
      match_note_mode = _o.match_note_mode;

      note_range = _o.note_range;

      dst_dev_idx = _o.dst_dev_idx;
      dst_ch      = _o.dst_ch;

      fixed_send_note          = _o.fixed_send_note;
      fixed_send_note_mode     = _o.fixed_send_note_mode;
      fixed_send_note_duration = _o.fixed_send_note_duration;

      velocity_min         = _o.velocity_min;
      velocity_max         = _o.velocity_max;
      b_normalize_velocity = _o.b_normalize_velocity;
      velocity_curve_idx   = _o.velocity_curve_idx;

      b_fixed_velocity = _o.b_fixed_velocity;
      fixed_velocity   = _o.fixed_velocity;

      b_fixed_polyat = _o.b_fixed_polyat;
      fixed_polyat   = _o.fixed_polyat;

      b_fixed_pitchbend = _o.b_fixed_pitchbend;
      fixed_pitchbend   = _o.fixed_pitchbend;

      b_fixed_modwheel  = _o.b_fixed_modwheel;
      fixed_modwheel    = _o.fixed_modwheel;

      b_fixed_expression = _o.b_fixed_expression;
      fixed_expression   = _o.fixed_expression;

      b_fixed_breathcontrol = _o.b_fixed_breathcontrol;
      fixed_breathcontrol   = _o.fixed_breathcontrol;

      b_fixed_prgchg            = _o.b_fixed_prgchg;
      fixed_prgchg              = _o.fixed_prgchg;
      fixed_prgchg_display_type = _o.fixed_prgchg_display_type;

      b_fixed_rpn_preset = _o.b_fixed_rpn_preset;
      fixed_rpn_preset   = _o.fixed_rpn_preset;
   }

   // <method_get.png>
   public method getDevName() : String {
      STX_MIDIOutDevice dev <= MIDI.GetMIDIOutDeviceByIndex(dst_dev_idx);
      if(null != dev)
      {
         return dev.getAliasOrDeviceName();
      }
      return "-";
   }

   // <method_get.png>
   public method getMidiChString() : String {
      return dst_ch+1;
   }

   // <method_get.png>
   public method getMatchNoteName() : String {
      if(note_range > 1)
      {
         return (MIDI.midi_notes.get(match_note))+".."+(MIDI.midi_notes.get(match_note + note_range - 1));
      }
      else
      {
         return MIDI.midi_notes.get(match_note);
      }
   }

   // <method_get.png>
   public method getMatchNoteModeName() : String {
      return note_mode_names.get(match_note_mode);
   }

   // <method_get.png>
   public method getSendNoteName() : String {
      if(note_range > 1)
      {
         return (MIDI.midi_notes.get(fixed_send_note))+".."+(MIDI.midi_notes.get(fixed_send_note + note_range - 1));
      }
      else
      {
         return MIDI.midi_notes.get(fixed_send_note);
      }
   }

   // <method_get.png>
   public method getSendNoteModeName() : String {
      return note_mode_names.get(fixed_send_note_mode);
   }

   // <method_get.png>
   public method getSendCtlString() : String {
      String r; r.empty();
      if(b_fixed_velocity)
         r.append("V");
      else
         r.append("-");
      if(b_fixed_polyat)
         r.append("A");
      else
         r.append("-");
      if(b_fixed_pitchbend)
         r.append("P");
      else
         r.append("-");
      if(b_fixed_modwheel)
         r.append("M");
      else
         r.append("-");
      if(b_fixed_expression)
         r.append("E");
      else
         r.append("-");
      if(b_fixed_breathcontrol)
         r.append("B");
      else
         r.append("-");
      if(false != b_fixed_prgchg)
         if(maybe == b_fixed_prgchg)
            r.append("U");
         else
            r.append("C");
      else
         r.append("-");
      if(b_fixed_rpn_preset)
         r.append("R");
      else
         r.append("-");
      return r;
   }

   // <method.png>
   protected method calcAutoName() : String {
      String ret = "";

      // Check "map note to prgchg" case
      if(NOTE_ON == match_note_mode)
      {
         if(NOTE_NONE == fixed_send_note_mode)
         {
            if( !b_fixed_velocity   &&
                !b_fixed_polyat     &&
                !b_fixed_pitchbend  &&
                !b_fixed_modwheel   &&
                !b_fixed_expression &&
                !b_fixed_breathcontrol &&
                !b_fixed_rpn_preset &&
                b_fixed_prgchg
                )
            {
               ret = "PC "+ (Node.patnr_options.get(fixed_prgchg));
               return ret;
            }
         }
      }

      return null;
   }

   // <method.png>
   public method updateAutoGeneratedName() {

      String autoName <= calcAutoName();

      boolean bIsAutoName = false;

      if(null != autoName)
      {
         bIsAutoName = (autoName == name);
      }

      if(name.isBlank() || b_auto_name || bIsAutoName)
      {
         b_auto_name = true;

         name = autoName;

         // Fallback
         // (todo)
      }
   }

   // <save.png>
   public saveState(Stream ofs) {
      // Version
      ofs.i16 = 4;

      // Write name
      Utils.WriteString(ofs, name);

      // Write b_auto_name (v3+)
      ofs.i8 = b_auto_name;

      // Write match_note
      ofs.i8 = match_note;
      ofs.i8 = match_note_mode;

      // Write note_range (v2+)
      ofs.i8 = note_range;

      // Write dst dev/ch
      ofs.i16 = dst_dev_idx;
      ofs.i8  = dst_ch;

      // Write fixed_send_note
      ofs.i8 = fixed_send_note;
      ofs.i8 = fixed_send_note_mode;
      ofs.i16 = fixed_send_note_duration;

      // Write velocity
      ofs.i8 = velocity_min;
      ofs.i8 = velocity_max;
      ofs.i8 = b_normalize_velocity;
      ofs.i8 = velocity_curve_idx;

      // Write fixed velocity
      ofs.i8 = b_fixed_velocity;
      ofs.i8 = fixed_velocity;

      // Write fixed polyat
      ofs.i8 = b_fixed_polyat;
      ofs.i8 = fixed_polyat;

      // Write fixed pitchbend
      ofs.i8 = b_fixed_pitchbend;
      ofs.i16 = fixed_pitchbend;

      // Write fixed modwheel
      ofs.i8 = b_fixed_modwheel;
      ofs.i8 = fixed_modwheel;

      // Write fixed expression
      ofs.i8 = b_fixed_expression;
      ofs.i8 = fixed_expression;

      // Write fixed breath control
      ofs.i8 = b_fixed_breathcontrol;
      ofs.i8 = fixed_breathcontrol;

      // Write fixed prgchg
      ofs.i8 = b_fixed_prgchg;
      ofs.i8 = fixed_prgchg;
      ofs.i8 = fixed_prgchg_display_type;

      // Write fixed RPN preset (v4+)
      ofs.i8 = b_fixed_rpn_preset;
      ofs.i8 = fixed_rpn_preset;
   }

   // <load.png>
   public loadState(Stream ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      short ver = ifs.u16;

      if(ver >= 1)
      {
         // Read name
         Utils.ReadString(ifs, name);

         if(ver >= 3)
         {
            b_auto_name = ifs.b8;
         }

         // Read match_note
         match_note = ifs.s8;
         match_note_mode = ifs.u8;

         if(ver >= 2)
         {
            // Read note_range (v2+)
            note_range = ifs.u8 & 127;
         }

         // Read dst dev/ch
         dst_dev_idx = ifs.s16;

         if(-1 != dst_dev_idx)
         {
            _outDevUseCount.inc(dst_dev_idx);

            dst_dev_idx = _outDevIdxMap.get(dst_dev_idx);
         }

         dst_ch = ifs.u8 & 15;

         // Read fixed_send_note
         fixed_send_note = ifs.s8;
         fixed_send_note_mode = ifs.u8;
         fixed_send_note_duration = ifs.u16;

         // Read velocity
         velocity_min = ifs.u8;
         velocity_max = ifs.u8;
         b_normalize_velocity = ifs.b8;
         velocity_curve_idx = ifs.s8;

         // Read fixed velocity
         b_fixed_velocity = ifs.b8;
         fixed_velocity = ifs.u8;

         // Read fixed polyat
         b_fixed_polyat = ifs.b8;
         fixed_polyat = ifs.u8;

         // Read fixed pitchbend
         b_fixed_pitchbend = ifs.b8;
         fixed_pitchbend = ifs.u16;

         // Read fixed modwheel
         b_fixed_modwheel = ifs.u8;
         fixed_modwheel = ifs.u8;

         // Read fixed expression
         b_fixed_expression = ifs.b8;
         fixed_expression = ifs.u8;

         // Read fixed breath control
         b_fixed_breathcontrol = ifs.b8;
         fixed_breathcontrol = ifs.u8;

         // Read fixed prgchg
         b_fixed_prgchg = ifs.i8;  // mixed state
         fixed_prgchg = ifs.u8;
         fixed_prgchg_display_type = ifs.u8;

         // Read fixed RPN preset (v4+)
         if(ver >= 4)
         {
            b_fixed_rpn_preset = ifs.b8;
            fixed_rpn_preset   = ifs.u8;
         }

         return true;
      }
      else
      {
         trace "[---] NodeKeymapEntry::loadState: invalid version ("+ver+")";
      }

      return false;
   }

   // <method.png>
   module method playEntry(MIDIPipeFrame _frameOut, boolean _bNoteOnHint, byte _noteOffset, byte _vel, int _dur) {
      // trace "xxx playEntry: bNoteOnHint="+_bNoteOnHint+" noteOffset="+_noteOffset+" vel="+_vel+" dur="+_dur;

      if(-1 != dst_dev_idx)
      {
         if(-1 != dst_ch)
         {
            if(-1 != fixed_send_note)
            {
               int dur = (0 == fixed_send_note_duration) ? _dur : fixed_send_note_duration;
               byte vel = _vel;
               byte note = fixed_send_note + _noteOffset;

               if(b_normalize_velocity)
               {
                  vel -= velocity_min;
                  vel = 127 * (vel / float(velocity_max - velocity_min));
               }

               if(b_fixed_velocity)
               {
                  vel = fixed_velocity;
               }
               else
               {
                  // Map velocity curve
                  if(VEL_CURVE_NONE != velocity_curve_idx)
                  {
                     IntArray curve <= velocity_curves.get(velocity_curve_idx - 1);
                     // trace "xxx oldVel="+vel;
                     vel = curve.get(vel);
                     // trace "xxx   newVel="+vel;
                  }
               }

               switch(fixed_send_note_mode)
               {
                  case NodeKeymapEntry.NOTE_NONE:
                     break;

                  case NodeKeymapEntry.NOTE_ON:
                     // trace "xxx playEntry: NOTE_ON note="+note+" vel="+vel+" dur="+dur;
                     _frameOut.noteOn(true/*bSet*/, dst_dev_idx, dst_ch, note, vel, dur);
                     break;

                  case NodeKeymapEntry.NOTE_OFF:
                     _frameOut.noteOff(true/*bSet*/, dst_dev_idx, dst_ch, note, vel);
                     break;

                  case NodeKeymapEntry.NOTE_ON_OFF:
                     if(_bNoteOnHint)
                     {
                        _frameOut.noteOn(true/*bSet*/, dst_dev_idx, dst_ch, note, vel, dur);
                     }
                     else
                     {
                        _frameOut.noteOff(true/*bSet*/, dst_dev_idx, dst_ch, note, vel);
                     }
                     break;
               }

               if(b_fixed_polyat)
               {
                  _frameOut.polyPressure(true/*bSet*/, dst_dev_idx, dst_ch, note, fixed_polyat);
               }

            } // -1 != fixed_send_note

            if(b_fixed_pitchbend)
            {
               _frameOut.pitchbend(true/*bSet*/, dst_dev_idx, dst_ch, fixed_pitchbend);
            }

            if(b_fixed_modwheel)
            {
               _frameOut.cc(true/*bSet*/, dst_dev_idx, dst_ch, 1, fixed_modwheel);
            }

            if(b_fixed_expression)
            {
               _frameOut.cc(true/*bSet*/, dst_dev_idx, dst_ch, 11, fixed_expression);
            }

            if(b_fixed_breathcontrol)
            {
               _frameOut.cc(true/*bSet*/, dst_dev_idx, dst_ch, 2, fixed_breathcontrol);
            }

            if(false != b_fixed_prgchg)
            {
               if(maybe == b_fixed_prgchg)
               {
                  _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                Node.RPN_COMMON_UI_PRGCHG,
                                fixed_prgchg
                                );
               }
               else
               {
                  _frameOut.prgChg(true/*bSet*/, dst_dev_idx, dst_ch, fixed_prgchg);
               }
            }

            if(b_fixed_rpn_preset)
            {
               switch(fixed_rpn_preset)
               {
                  case RPN_PRESET_RESET:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_RESET,
                                   1
                                   );
                     break;

                  case RPN_PRESET_RUN:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_RUN,
                                   1
                                   );
                     break;

                  case RPN_PRESET_STOP:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_RUN,
                                   0
                                   );
                     break;

                  case RPN_PRESET_CLOCKGATE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_CLOCKGATE,
                                   0
                                   );
                     break;

                  case RPN_PRESET_CLOCK:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_CLOCK,
                                   0
                                   );
                     break;

                  case RPN_PRESET_GATE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_GATE,
                                   0
                                   );
                     break;

                  case RPN_PRESET_RETRIG:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_RETRIG,
                                   1
                                   );
                     break;

                  case RPN_PRESET_RESTART:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_RESTART,
                                   1
                                   );
                     break;

                  case RPN_PRESET_TRACKS_MUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_MUTE_TEMP_1_8,
                                   255
                                   );
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_MUTE_TEMP_9_16,
                                   255
                                   );
                     break;

                  case RPN_PRESET_TRACKS_UNMUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_MUTE_TEMP_1_8,
                                   0
                                   );
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_MUTE_TEMP_9_16,
                                   0
                                   );
                     break;

                  case RPN_PRESET_RESVD_10:  // was TRACKS_TOGGLE_MUTE   [19Oct2019] removed
                     //
                     // // _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                     // //               Node.RPN_COMMON_MUTE_TOGGLE,
                     // //               255
                     // //               );
                     break;

                  case RPN_PRESET_TEMP_MUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_MUTE_TEMP,
                                   1
                                   );
                     break;

                  case RPN_PRESET_TEMP_UNMUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_MUTE_TEMP,
                                   0
                                   );
                     break;

                  case RPN_PRESET_TEMP_TOGGLE_MUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_MUTE_TEMP_TOGGLE,
                                   1
                                   );
                     break;

                  case RPN_PRESET_UI_NODE_MUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_NODE_MUTE,
                                   1
                                   );
                     break;

                  case RPN_PRESET_UI_NODE_UNMUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_NODE_MUTE,
                                   0
                                   );
                     break;

                  case RPN_PRESET_UI_NODE_TOGGLE_MUTE:
                     // trace "xxx RPN_PRESET_UI_NODE_TOGGLE_MUTE";
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_NODE_MUTE,
                                   2
                                   );
                     break;

                  case RPN_PRESET_UI_NODE_SOLO:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_NODE_SOLO,
                                   1
                                   );
                     break;

                  case RPN_PRESET_UI_NODE_UNSOLO:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_NODE_SOLO,
                                   0
                                   );
                     break;

                  case RPN_PRESET_UI_NODE_TOGGLE_SOLO:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_NODE_SOLO,
                                   2
                                   );
                     break;

                  case RPN_PRESET_UI_PIPE_MUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_PIPE_MUTE,
                                   1
                                   );
                     break;

                  case RPN_PRESET_UI_PIPE_UNMUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_PIPE_MUTE,
                                   0
                                   );
                     break;

                  case RPN_PRESET_UI_PIPE_TOGGLE_MUTE:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_PIPE_MUTE,
                                   2
                                   );
                     break;

                  case RPN_PRESET_UI_PIPE_SOLO:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_PIPE_SOLO,
                                   1
                                   );
                     break;

                  case RPN_PRESET_UI_PIPE_UNSOLO:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_PIPE_SOLO,
                                   0
                                   );
                     break;

                  case RPN_PRESET_UI_PIPE_TOGGLE_SOLO:
                     _frameOut.rpn(true/*bSet*/, dst_dev_idx, dst_ch,
                                   Node.RPN_COMMON_UI_PIPE_SOLO,
                                   2
                                   );
                     break;

               } // switch fixed_rpn_preset
            } // if b_fixed_rpn_preset
         } // if -1 != dst_ch
      } // if -1 != dst_dev
   }

}


// <class.png>
class NodeKeymapPattern : NodePattern {
   byte note_offset;
   byte note_modulo;

   PointerArray entries;  // NodeKeymapEntry instances


   // <method_init.png>
   public virtual patInit(Node _parent, int _patNr) {
      NodePattern::patInit(_parent, _patNr);

   }

   // <method.png>
   public virtual patCopyFrom(NMM_Pattern _o, boolean _bClear) {
      NodePattern::patCopyFromGeneric(_o);
   }

   // <method_get.png>
   public method getEntryByIndex(int _idx) : NodeKeymapEntry {
      return entries.get(_idx);
   }

   // <method.png>
   public =replay= method insertEntryAt(NodeKeymapEntry _n, int _idx) {
      entries.insert(_idx, #(deref _n));
   }

   // <method.png>
   public =replay= method removeEntryAt(int _idx) {
      entries.delete(_idx);
   }

   // <method.png>
   public =replay= method moveEntryUp(int _idx) : boolean {

      if(_idx > 0)
      {
         if(_idx < entries.numElements)
         {
            entries.swap(_idx, _idx - 1);
            return true;
         }
      }
      return false;
   }

   // <method.png>
   public =replay= method moveEntryDown(int _idx) : boolean {

      if(_idx < (entries.numElements - 1))
      {
         if(_idx >= 0)
         {
            entries.swap(_idx, _idx + 1);
            return true;
         }
      }
      return false;
   }


   // <method_set.png>
   public =replay= method setNoteOffset(byte _off) {
      note_offset = _off;
   }

   // <method_set.png>
   public =replay= method setNoteModulo(byte _mod) {
      note_modulo = _mod;
   }

   // <method.png>
   public =replay= method swapMatchAndSendNotes() {
      NodeKeymapEntry *en;
      foreach en in entries
      {
         byte matchNote = en.match_note;
         en.match_note = en.fixed_send_note;
         en.fixed_send_note = matchNote;
      }
   }

   // <save.png>
   public patSaveState(Stream ofs) {

      NodePattern::patSaveState(ofs);

      ofs.i16 = 1; // Version

      // Offset + Modulo
      ofs.i8 = note_offset;
      ofs.i8 = note_modulo;

      // Entries
      ofs.i16 = entries.numElements;
      NodeKeymapEntry *en;
      foreach en in entries
      {
         en.saveState(ofs);
      }
   }

   // <load.png>
   public virtual patLoadState(Stream ifs, short _ver, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      if(NodePattern::patLoadState(ifs, _ver, _outDevIdxMap, _outDevUseCount))
      {
         short ver = ifs.u16;

         if(ver >= 1)
         {
            // Read Offset + Modulo
            note_offset = ifs.s8;
            note_modulo = ifs.u8;

            // Read entries
            int numEntries = ifs.u16;
            if(entries.alloc(numEntries))
            {
               loop(numEntries)
               {
                  NodeKeymapEntry en <= new NodeKeymapEntry;
                  en.init();

                  if(en.loadState(ifs, _outDevIdxMap, _outDevUseCount))
                  {
                     entries.add(#(deref en));
                  }
                  else
                  {
                     trace "[---] NodeKeymapPattern: failed to load entry "+(entries.numElements+1)+"/"+numEntries;
                     return false;
                  }
               }
            }

            return true;
         }
      }
      return false;
   }
}


// <class.png>
class NodeKeymap : Node {

   define int RPN_KEYMAP_xxx = RPN_KEYMAP_BASE + 0;

   static NodeKeymapEditor *editor;

   PointerArray patterns; // NTS_Pattern instances

   boolean b_remove_input_events;  // false=keep input events, maybe=remove input event when at least entry matches, true=remove all input events (note on+off)

   public int learn_mode; // see NodeKeymapEditor. If != 0, do not record midi events.

   public boolean b_learn_velocity;
   public boolean b_learn_polyat;
   public boolean b_learn_pitchbend;
   public boolean b_learn_modwheel;
   public boolean b_learn_expression;
   public boolean b_learn_breathcontrol;
   public boolean b_learn_prgchg;

   define int LEARN_TRIG_NOTE_ON        = 0;
   define int LEARN_TRIG_NOTE_OFF       = 1;
   define int LEARN_TRIG_NOTE_ON_HOLD   = 2;
   define int LEARN_TRIG_NOTE_ON_OR_OFF = 3;
   define int LEARN_TRIG_UPDATE_SEND    = 4;
   define int LEARN_TRIG_UPDATE_MATCH   = 5;
   define int LEARN_TRIG_KEYPRESS       = 6;

   public int learn_trig_mode;

   static StringArray learn_trig_mode_names = [
      "Note On",
      "Note Off",
      "Note On Hold",
      "Note On Or Off",
      "Update Send",
      "Update Match",
      "Keypress"
                                               ];

   public byte learn_next_match_note;
   public boolean b_learn_next_match_note_black_and_white;

   MIDIPipeFrame fr_learn;

   protected int queued_entry_idx;


   // <init.png>
   public virtual nodeInit(MIDIPipe _pipe, MIDIPipeNode _node) : boolean {

      Node::nodeInit(_pipe, _node);

      patterns.alloc(128);
      patterns.useAll();

      play_pattern_nr = 0;
      edit_pattern_nr = 0;

      queued_entry_idx = -1;

      return true;
   }

   // <ui_init.png>
   public virtual nodeUIInit() {

      Node::nodeUIInit();

      NodeKeymapPattern pat <= new NodeKeymapPattern;
      pat.patInit(this, 0/*patIdx*/);
      patterns[0] = deref pat;

      learn_next_match_note = STConfig.node_keymap_first_match_note;
      b_learn_next_match_note_black_and_white = STConfig.b_node_keymap_next_match_note_black_and_white;
   }

   // <method_get.png>
   public virtual nodeGetEditor() : NodeEditor {
      if(null == editor)
      {
         editor <= new NodeKeymapEditor;

         if(!editor.init())
         {
            editor <= null;
            return false;
         }
      }
      return editor;
   }

   // <method_get.png>
   public virtual nodeGetEditorIfExists() : NodeEditor {
      return editor;
   }

   // <method_get.png>
   public virtual nodeGetIcon() : Icon {
      if(LookAndFeel.IDX_MONO == STConfig.lnf_idx)
         return UI.GetIcon("node_keymap_mono");
      else
         return UI.GetIcon("node_keymap");
   }

   // <method.png>
   public virtual nodeGetPatternClassName() : String {
      return "NodeKeymapPattern";
   }

   // <replay.png>
   public virtual nodeReset(boolean _bSoft) {

      Node::nodeReset(_bSoft);
   }

   // <replay.png>
   public virtual nodeRestart() {
      nodeSetLastPatternStartSongOffset(current_song.song_offset);

      nodeSeek(nodeGetLastPatternStartSongOffset() + 0);
   }

   // <replay.png>
   public =replay= virtual nodeSeek(int _ticks) {
   }

   // <method_get.png>
   public virtual nodeGetPatternsGeneric() : PointerArray {
      return patterns;
   }

   // <method_get.png>
   public virtual nodeIsPatternEmpty(int _patNr) : boolean {
      return (null == patterns.get(_patNr));
   }

   // <method_get.png>
   public =replay= method getOrCreateCurrentEditPattern() : NodeKeymapPattern {
      NodeKeymapPattern pat <= patterns.get(edit_pattern_nr);

      if(null == pat)
      {
         pat <= new NodeKeymapPattern;
         pat.patInit(this, edit_pattern_nr);
         patterns[edit_pattern_nr] = deref pat;
      }

      return pat;
   }

   // <method_get.png>
   public virtual nodeGetPatternByIdx(int _idx) : NodeKeymapPattern {
      return patterns.get(_idx);
   }

   // <method_get.png>
   public =replay= virtual nodeGetCurrentPlayPattern() : NodeKeymapPattern {
      return patterns.get(play_pattern_nr);
   }

   // <method_get.png>
   public =replay= virtual nodeGetCurrentEditPattern() : NodeKeymapPattern {
      return patterns.get(edit_pattern_nr);
   }

   // <method_get.png>
   public method findFirstUnusedPattern(int _startOff) : int {
      int patIdx = patterns.indexOfPointer(null, _startOff);

      return patIdx;
   }

   // <method_set.png>
   public =replay= virtual nodeSetPattern(int _idx, NTS_Pattern _pat) {
      patterns[_idx & 127] = deref _pat;
   }

   // <method.png>
   public =replay= method queueEntryIdx(int _idx) {
      queued_entry_idx = _idx;
   }

   // <method_set.png>
   public =replay= method setEnableRemoveInputEvents(boolean _bEnable) {
      b_remove_input_events = _bEnable;
   }

   // <method.png>
   public method calcNextMatchNote(byte _startNote) : byte {
      byte r;

      if(b_learn_next_match_note_black_and_white)
      {
         // Black and white keys
         r = (_startNote + 1) & 127;
      }
      else
      {
         // White keys only
         byte oct = _startNote / 12;
         r = _startNote % 12;
         switch(r)
         {
            case 0: r = 2; break;
            case 1: r = 2; break;
            case 2: r = 4; break;
            case 3: r = 4; break;
            case 4: r = 5; break;
            case 5: r = 7; break;
            case 6: r = 7; break;
            case 7: r = 9; break;
            case 8: r = 9; break;
            case 9: r = 11; break;
            case 10: r = 11; break;
            case 11: r = 0; oct++; break;
         }
         r = r + oct*12;
      }

      return r;
   }

   // <save.png>
   public virtual nodeSaveState(Stream ofs) {
      ofs.i16 = 5; // Version

      Node::nodeSaveState(ofs);

      // Patterns
      NodeKeymapPattern *pat;
      int patIdx = 0;
      loop(128)
      {
         pat <= patterns.get(patIdx);

         if(null != pat)
         {
            ofs.i8 = 1;
            pat.patSaveState(ofs);
         }
         else
         {
            ofs.i8 = 0; // ver (0 == unused pat slot)
         }

         // Next pattern
         patIdx++;
      }

      // (note) [21Jun2021] moved to Node base class
      ofs.i8 = edit_pattern_nr;
      ofs.i8 = play_pattern_nr;

      // v2+
      ofs.i8 = b_learn_velocity;
      ofs.i8 = b_learn_polyat;
      ofs.i8 = b_learn_pitchbend;
      ofs.i8 = b_learn_modwheel;
      ofs.i8 = b_learn_expression;
      ofs.i8 = b_learn_breathcontrol;
      ofs.i8 = b_learn_prgchg;
      ofs.i8 = learn_trig_mode;

      // v3+
      ofs.i8 = learn_next_match_note;

      // v4+
      ofs.i8 = b_learn_next_match_note_black_and_white;

      // v5+
      ofs.i8 = b_remove_input_events;
   }

   // <load.png>
   public virtual nodeLoadState(Stream ifs, IntArray _outDevIdxMap, IntArray _outDevUseCount) : boolean {
      short ver = ifs.i16;

      if(ver >= 1)
      {
         if(!Node::nodeLoadState(ifs, _outDevIdxMap, _outDevUseCount))
         {
            return false;
         }

         // Patterns
         int patIdx = 0;
         loop(128)
         {
            NodeKeymapPattern *pat;

            boolean bPatUsed = ifs.i8;
            if(bPatUsed)
            {
               pat <= new NodeKeymapPattern;
               pat.patInit(this, patIdx);
               patterns[patIdx] = deref pat;

               if(!pat.patLoadState(ifs, 1, _outDevIdxMap, _outDevUseCount))
               {
                  trace "[---] NodeKeymap::loadState: patLoadState failed (patIdx="+patIdx+")";
                  return false;
               }
            }

            // Next pattern
            patIdx++;
         }

         edit_pattern_nr = ifs.u8;
         play_pattern_nr = ifs.u8;

         if(ver >= 2)
         {
            b_learn_velocity      = ifs.b8;
            b_learn_polyat        = ifs.b8;
            b_learn_pitchbend     = ifs.b8;
            b_learn_modwheel      = ifs.b8;
            b_learn_expression    = ifs.b8;
            b_learn_breathcontrol = ifs.b8;
            b_learn_prgchg        = ifs.b8;
            learn_trig_mode       = ifs.u8;
         }

         if(ver >= 3)
         {
            learn_next_match_note = ifs.u8 & 127;
         }

         if(ver >= 4)
         {
            b_learn_next_match_note_black_and_white = ifs.b8;
         }

         if(ver >= 5)
         {
            b_remove_input_events = ifs.s8;  // v5+
         }

         return true;

      } // if ver >= 1

      return false;
   }

   // <method.png>
   public =replay= method clearLearnEvents() {
      fr_learn.empty();
   }

   // <method_find.png>
   public method findEntryBySendNoteAndDevCh(byte _note, boolean _bNoteOn, int _devIdx, byte _ch) : NodeKeymapEntry {
      NodeKeymapPattern pat <= nodeGetCurrentPlayPattern();

      NodeKeymapEntry *en;

      foreach en in pat.entries
      {
         if(en.fixed_send_note == _note)
         {
            if(en.dst_dev_idx == _devIdx)
            {
               if(en.dst_ch == _ch)
               {
                  switch(en.fixed_send_note_mode)
                  {
                     case NodeKeymapEntry.NOTE_NONE:
                        break;

                     case NodeKeymapEntry.NOTE_ON:
                        if(_bNoteOn)
                        {
                           return en;
                        }
                        break;

                     case NodeKeymapEntry.NOTE_OFF:
                        if(!_bNoteOn)
                        {
                           return en;
                        }
                        break;

                     case NodeKeymapEntry.NOTE_ON_OFF:
                        return en;
                  }
               }
            }
         }
      }

      return null;
   }

   // <method_find.png>
   public method findEntryByNote(byte _note, boolean _bNoteOn, byte _vel, Integer _retNoteOffset, int _enIdx) : NodeKeymapEntry {
      NodeKeymapPattern pat <= nodeGetCurrentPlayPattern();

      NodeKeymapEntry *en;

      _note = (_note + pat.note_offset) & 127;

      int matchIdx = 0;

      foreach en in pat.entries
      {
         boolean bMatchNote;

         if(0 != pat.note_modulo)
         {
            bMatchNote = false;
            byte cNote = _note % pat.note_modulo;
            byte mNote = en.match_note % pat.note_modulo;

            bMatchNote = (mNote <= cNote < (mNote + en.note_range));

            if(bMatchNote)
            {
               _retNoteOffset = cNote - mNote;
            }
            else
            {
               if((mNote + en.note_range) >= pat.note_modulo)
               {
                  bMatchNote |= (0 <= cNote < ((mNote + en.note_range) - pat.note_modulo));
                  _retNoteOffset = cNote + ((mNote + en.note_range) - pat.note_modulo);
               }
            }

            // // loop(en.note_range)
            // // {
            // //    if(mNote == cNote)
            // //    {
            // //       bMatchNote = true;
            // //       break;
            // //    }
            // //    mNote = (mNote + 1) % pat.note_modulo;
            // // }
         }
         else
         {
            bMatchNote = (en.match_note <= _note < (en.match_note + en.note_range));
            _retNoteOffset = _note - en.match_note;
         }

         // if(bMatchNote)
         // trace "xxx bMatchNote="+bMatchNote+" en.match_note="+en.match_note+" _note="+_note;

         if(bMatchNote)
         {
            if(en.velocity_min <= _vel <= en.velocity_max)
            {
               if(matchIdx == _enIdx)
               {
                  switch(en.match_note_mode)
                  {
                     case NodeKeymapEntry.NOTE_NONE:
                        break;

                     case NodeKeymapEntry.NOTE_ON:
                        if(_bNoteOn)
                        {
                           return en;
                        }
                        break;

                     case NodeKeymapEntry.NOTE_OFF:
                        if(!_bNoteOn)
                        {
                           return en;
                        }
                        break;

                     case NodeKeymapEntry.NOTE_ON_OFF:
                        return en;
                  }
               }
               matchIdx++;
            }
         }
      }

      return null;
   }

   // <method.png>
   protected method processFrame(MIDIPipeFrame _frameIn, MIDIPipeFrame _frameOut, int _devFlt, byte _chFlt) {

      int evIdx;
      int numEvents;
      MIDIPipeEvent ev;
      NodeKeymapEntry *en;
      Integer noteOffset;
      int enIdx;
      boolean bFound;
      IntArray removeNoteOffs; removeNoteOffs.empty();
      IntArray removeNoteOns;  removeNoteOns.empty();

      // Process note offs
      evIdx = 0;
      numEvents = _frameIn.getNumEventsNoteOffByFlt(_devFlt, _chFlt);

      while(evIdx < numEvents)
      {
         bFound = false;

         if(_frameIn.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_OFF, _devFlt, _chFlt))
         {
            enIdx = 0;

            loop(16)
            {
               en <= findEntryByNote(ev.note, false/*bNoteOn*/, ev.velocity, noteOffset, enIdx);

               if(null != en)
               {
                  en.playEntry(_frameOut, false/*bNoteOnHint*/, noteOffset, ev.velocity, ev.duration);
                  bFound = true;
                  enIdx++;
               }
               else
               {
                  break;
               }
            }
         }

         if(bFound && (maybe == b_remove_input_events))
         {
            removeNoteOffs.add(ev.note);
         }

         evIdx++;
      }

      // Process note ons
      evIdx = 0;
      numEvents = _frameIn.getNumEventsNoteOnByFlt(_devFlt, _chFlt);

      // trace "xxx numEventsNoteOn="+numEvents;

      while(evIdx < numEvents)
      {
         bFound = false;

         if(_frameIn.getEventByIdxAndFlt(evIdx, ev, MIDIPIPE_EVENT_TYPE_NOTE_ON, _devFlt, _chFlt))
         {
            enIdx = 0;

            loop(16)
            {
               en <= findEntryByNote(ev.note, true/*bNoteOn*/, ev.velocity, noteOffset, enIdx);

               // trace "xxx note="+ev.note+" en="+#(en);

               if(null != en)
               {
                  en.playEntry(_frameOut, true/*bNoteOnHint*/, noteOffset, ev.velocity, ev.duration);
                  bFound = true;
                  enIdx++;
               }
               else
               {
                  break;
               }
            }
         }

         if(bFound && (maybe == b_remove_input_events))
         {
            removeNoteOns.add(ev.note);
         }

         evIdx++;
      }

      // Remove incoming events
      if(maybe == b_remove_input_events)
      {
         // Delete all matching input events
         int note;
         // trace "xxx removeNoteOns="+removeNoteOns+" devFlt="+_devFlt+" chFlt="+_chFlt;

         foreach note in removeNoteOffs
            _frameIn.noteOff(false/*bSet*/, _devFlt, _chFlt, note, 0/*vel*/);

         foreach note in removeNoteOns
            _frameIn.noteOn(false/*bSet*/, _devFlt, _chFlt, note, 0/*vel*/, 0/*dur*/);
      }
      else if(true == b_remove_input_events)
      {
         // Delete all input events
         _frameIn.deleteNoteOffsByFlt(_devFlt, _chFlt);
         _frameIn.deleteNoteOnsByFlt(_devFlt, _chFlt);
      }

   }

   // <method_handle.png>
   protected method handleQueuedEntryIdx(MIDIPipeFrame _frameOut) {
      if(-1 != queued_entry_idx)
      {
         NodeKeymapPattern pat <= nodeGetCurrentPlayPattern();

         if(null != pat)
         {
            NodeKeymapEntry en <= pat.getEntryByIndex(queued_entry_idx);

            if(null != en)
            {
               en.playEntry(_frameOut, true/*bNoteOnHint*/, 0/*noteOffset*/, 127/*velocity*/, 1/*duration*/);
            }
         }

         queued_entry_idx = -1;
      }
   }

   // <method_handle.png>
   protected method handlePrgChg(MIDIPipeFrame _frame) {
      int numPC = _frame.getNumEventsPrgChg();

      if(numPC > 0)
      {
         int pcIdx = 0;

         loop(numPC)
         {
            MIDIPipeEvent ev;
            _frame.getEventByIdx(pcIdx, ev, MIDIPIPE_EVENT_TYPE_PRGCHG);

            if(b_auto_filter_a && b_auto_recv_prgchg_a)
            {
               if( (-1 == auto_dev_filter_a) || (auto_dev_filter_a == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_a) || (auto_ch_filter_a == ev.midiCh) )
                  {
                     nodeSetCurrentPlayPatternNr(ev.arg1);
                     Events.SendPlayPat();

                     Global.Debug3("nkm: queued pattern "+play_pattern_nr+" via PrgChg A");
                  }
               }
            }

            if(b_auto_filter_b && b_auto_recv_prgchg_b)
            {
               if( (-1 == auto_dev_filter_b) || (auto_dev_filter_b == ev.devIdx) )
               {
                  if( (-1 == auto_ch_filter_b) || (auto_ch_filter_b == ev.midiCh) )
                  {
                     nodeSetCurrentPlayPatternNr(ev.arg1);
                     Events.SendPlayPat();

                     Global.Debug3("nkm: queued pattern "+play_pattern_nr+" via PrgChg B");
                  }
               }
            }

            pcIdx++;
         }
      }

      // Handle timeline recordable program change
      short t = getFrameRPN(_frame, RPN_COMMON_UI_PRGCHG);
      if(t >= 0)
      {
         nodeSetCurrentPlayPatternNr(t);
         Events.SendPlayPat();
         replay.addUIPrgChgEntry(getNodeGID(), t);
      }
   }

   // <method_get.png>
   public virtual nodeGetSupportedRPNs() : IntArray {
      return [RPN_COMMON_UI_PRGCHG,
              RPN_COMMON_MUTE_TEMP, // nodeParseRPN_Mute
              RPN_COMMON_MUTE_TEMP_TOGGLE,
              // RPN_COMMON_MUTE_TEMP_1_8,
              // RPN_COMMON_MUTE_TEMP_9_16,
              // RPN_COMMON_SOLO_TEMP_1_8,
              // RPN_COMMON_SOLO_TEMP_9_16,
              RPN_COMMON_UI_NODE_MUTE,
              RPN_COMMON_UI_NODE_SOLO,
              RPN_COMMON_UI_PIPE_MUTE,
              RPN_COMMON_UI_PIPE_SOLO,

              // RPN_COMMON_SEEK_OFFSET,
              ];
   }

   // <replay.png>
   public virtual nodeProcessFrame(MIDIPipeFrame _framePlay,
                                   MIDIPipeFrame _frameRec,
                                   boolean       _bMuted,
                                   boolean       _bPlaySeq
                                   ) {


      if(0 != learn_mode)
      {
         // Collect notes/ctls
         fr_learn.mergeFrame(_framePlay);
         fr_learn.mergeFrame(_frameRec);
      }
      else
      {
         boolean bAllowSeekPrgChgAndMute = !b_node_ignore_seek_prgchg_mute;

         if((_framePlay.numEventsRPN > 0) || (_frameRec.numEventsRPN > 0))
         {
            // short t = getRPN(_framePlay, _frameRec, RPN_MONOPOLY_OUTPUT);
            // if(t >= 0)
            // {
            //    next_out_idx = (t & 3);
            // }
         }

         if(bAllowSeekPrgChgAndMute)
            _bMuted |= nodeHandleQueuedMuteTemp();

         if(!_bMuted)
         {
            if(bAllowSeekPrgChgAndMute)
            {
               handlePrgChg(_framePlay);
               handlePrgChg(_frameRec);
            }

            nodeSendQueuedPrgChgOut(_framePlay);
         }


         if(!_bMuted)
         {
            NodeKeymapPattern pat <= nodeGetCurrentPlayPattern();

            if(null != pat)
            {
               MIDIPipeFrame framePlayOut;
               framePlayOut.empty();

               MIDIPipeFrame frameRecOut;
               frameRecOut.empty();

               if(_frameRec.hasEvents())
               {
                  if(b_auto_filter_a && (-1 != auto_dev_filter_a))
                  {
                     processFrame(_frameRec, frameRecOut, auto_dev_filter_a, auto_ch_filter_a);
                  }

                  if(b_auto_filter_b && (-1 != auto_dev_filter_b))
                  {
                     processFrame(_frameRec, frameRecOut, auto_dev_filter_b, auto_ch_filter_b);
                  }
               }

               if(_framePlay.hasEvents())
               {
                  if(b_auto_filter_a && (-1 != auto_dev_filter_a))
                  {
                     processFrame(_framePlay, framePlayOut, auto_dev_filter_a, auto_ch_filter_a);
                  }

                  if(b_auto_filter_b && (-1 != auto_dev_filter_b))
                  {
                     processFrame(_framePlay, framePlayOut, auto_dev_filter_b, auto_ch_filter_b);
                  }
               }

               handleQueuedEntryIdx(framePlayOut);

               // (todo) add option that allows merging from frameRec to framePlay ??

               _frameRec.mergeFrame(frameRecOut);
               _framePlay.mergeFrame(framePlayOut);
            }
         }
      }

   }

}
