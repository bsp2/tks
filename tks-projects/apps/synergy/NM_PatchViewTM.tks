// ----
// ---- file   : NM_PatchViewTM.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2019-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- changed: 14Sep2019
// ---- changed: 28Feb2025
// ----
// ----
// ----

module MNM_PatchViewTM;

use namespace ui;
use namespace st2;


class NM_PatchViewTMEntry {
   NM_Pattern *pat;
   int         pat_idx;

   String nr;
   String name;
   String num_frames;
   String first_frame_dev;
   String out_xform;
   String in_flt;

   int first_frame_dev_idx;
   int first_frame_midi_ch;
}

class NM_PatchViewTM : TableModel {

   define int COL_NR          = 0;
   define int COL_NAME        = 1;
   define int COL_NUM_FRAMES  = 2;
   define int COL_FF_DEV      = 3;
   define int COL_OUT_XFORM   = 4;
   define int COL_IN_FLT      = 5;
   define int NUM_COLS        = 6;

   NM_PatchViewTMEntry *[] entries;  // NM_PatchViewTMEntry instances (ref to editor.patchview_entries)


   public virtual getNumColumns() : int {
      return NUM_COLS;
   }

   public virtual getColumnCaption(int _col) : String {
      return ["Pattern", "Name", "# Frames", "First Frame Event Dev", "Output XForm", "Input Filter"][_col];
   }

   public virtual getNumRows() : int {
      return entries.numElements;
   }

   public virtual getCellCaption(int _col, _row) : String {
      NM_PatchViewTMEntry entry <= entries.get(_row);

      if(null != entry)
      {
         switch(_col)
         {
            case COL_NR:
               return entry.nr;

            case COL_NAME:
               return entry.name;

            case COL_NUM_FRAMES:
               return entry.num_frames;

            case COL_FF_DEV:
               return entry.first_frame_dev;

            case COL_OUT_XFORM:
               return entry.out_xform;

            case COL_IN_FLT:
               return entry.in_flt;
         }
      }
   }

   public virtual getMinimumColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_NR:
            return 50;

         case COL_NAME:
            return 140;

         case COL_NUM_FRAMES:
            return 50;

         case COL_FF_DEV:
            return 140;

         case COL_OUT_XFORM:
            return 140;

         case COL_IN_FLT:
            return 140;
      }
   }

   public virtual getPreferredColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_NR:
            return 50;

         case COL_NAME:
            return 140;

         case COL_NUM_FRAMES:
            return 50;

         case COL_FF_DEV:
            return 440;

         case COL_OUT_XFORM:
            return 440;

         case COL_IN_FLT:
            return 440;
      }
   }

   public virtual handleCellEditing(TableCellEditor _tce) {
      switch(_tce.table_col)
      {
         case COL_NAME:
            handleCellEdited(_tce);
            break;
      }
   }

   public virtual handleCellEdited(TableCellEditor _tce) {

      NM_PatchViewTMEntry entry <= entries.get(_tce.table_row);

      if(null != entry)
      {
         TableCellEditorString *tcestr;

         switch(_tce.table_col)
         {
            case COL_NAME:
               tcestr <= _tce;
               entry.name = tcestr.getText();
               entry.pat.patSetName(entry.name);

               tableModelChanged();
               break;
         }
      }
   }

   public virtual getCellEditor(int _col, int _row) : TableCellEditor {

      NM_PatchViewTMEntry entry <= entries.get(_row);

      if(null != entry)
      {
         TableCellEditorString *tcestr;

         switch(_col)
         {
            case COL_NAME:
               tcestr <= new TableCellEditorString;
               tcestr.initStringEditor(entry.name);
               tcestr.setMaxCols(32);
               return deref tcestr;
         }
      }
   }

}
