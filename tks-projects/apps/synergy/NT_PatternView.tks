// ----
// ---- file   : NT_PatternView.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi/audio sequencer.
// ----
// ---- changed: 14Sep2006, 17Sep2006, 20Sep2006, 02Oct2006, 03Oct2006, 08Mar2007, 09Mar2007,
// ----          10Mar2007, 15Oct2007, 16Oct2007, 20Oct2007, 21Oct2007, 22Oct2007, 04Nov2007
// ----          10Nov2007, 03Jan2008, 04Jan2008, 10Jan2008, 12Jan2008, 14Jan2008, 15Jan2008
// ----          16Jan2008, 21Jan2008, 27Jan2008, 03Aug2008, 04Aug2008, 05Aug2008, 07Aug2008
// ----          11Aug2008, 13Aug2008, 24Aug2008, 27Aug2008, 16Feb2009, 18Sep2009, 19Sep2009
// ----          20Sep2009, 21Sep2009, 22Sep2009, 23Dec2009, 26Dec2009, 27Dec2009, 03Jan2010
// ----          04Jan2010, 05Jan2010, 06Jan2010, 07Jan2010, 09Jan2010, 10Jan2010, 11Jan2010
// ----          13Jan2010, 16Jan2010, 17Jan2010, 29Jan2010, 25Feb2010, 01Mar2010, 25Apr2010
// ----          30Apr2010, 01May2010, 02May2010, 03May2010, 04May2010, 14May2010, 15May2010
// ----          06Jun2010, 15Jun2010, 16Jun2010, 26Jun2010, 30Jun2010, 01Jul2010, 02Jul2010
// ----          03Jul2010, 06Jul2010, 07Jul2010, 10Jul2010, 13Jul2010, 21Jul2010, 02Aug2010
// ----          28Sep2010, 19Oct2010, 25Oct2010, 09Nov2010, 22Jan2011, 03Feb2011, 06Feb2011
// ----          07Feb2011, 20Feb2011, 22Feb2011, 24Feb2011, 25Feb2011, 14Mar2011, 15Mar2011
// ----          20Mar2011, 26Mar2011, 20Apr2011, 05Jul2011, 04Jan2012, 08Jan2012, 09Jan2012
// ----          16Jan2012, 17Jan2012, 24Jan2012, 29Jan2012, 03Feb2012, 07Feb2012, 14Feb2012
// ----          19Feb2012, 20Feb2012, 21Feb2012, 14May2012, 03Nov2012, 06Dec2012, 12Dec2012
// ----          23Dec2012, 03Jan2013, 04Jan2013, 05Jan2013, 06Jan2013, 28Feb2013, 29Mar2013
// ----          07Apr2013, 19Apr2013, 22Apr2013, 12May2013, 14May2013, 15May2013, 25May2013
// ----          26May2013, 27May2013, 31May2013, 01Jun2013, 04Jun2013, 05Jun2013, 02Feb2014
// ----          17Jan2015, 19Jan2015, 23Jan2015, 24Jan2015, 26Jan2015, 27Jan2015, 28Jan2015
// ----          29Jan2015, 30Jan2015, 01Feb2015, 02Feb2015, 03Feb2015, 09Feb2015, 11Feb2015
// ----          15Feb2015, 18Feb2015, 22Feb2015, 24Feb2015, 01Mar2015, 02Mar2015, 05Mar2015
// ----          14Mar2015, 09Apr2015, 19Apr2015, 20Apr2015, 25Apr2015, 29Apr2015, 03May2015
// ----          04May2015, 14May2015, 26Jul2015, 28Jul2015, 24Aug2015, 12Sep2015, 26Sep2015
// ----          27Sep2015, 28Sep2015, 29Sep2015, 02Oct2015, 23Oct2015, 24Oct2015, 25Oct2015
// ----          26Oct2015, 06Nov2015, 11Nov2015, 12Nov2015, 17Dec2015, 30Dec2015, 31Dec2015
// ----          10Jan2016, 17Jan2016, 23Jan2016, 29Jan2016, 12Sep2016, 19Sep2016, 30Sep2016
// ----          25Nov2016, 28Jan2017, 04Feb2017, 09Feb2017, 10Feb2017, 13Feb2017, 26Feb2017
// ----          05Mar2017, 10Mar2017, 17Mar2017, 18Mar2017, 20Mar2017, 24Mar2017, 07Apr2017
// ----          19Apr2017, 05Jun2017, 16Jun2017, 29Jun2017, 01Jul2017, 14Jul2017, 04Oct2017
// ----          13Oct2017, 29Oct2017, 04Jan2018, 06Mar2018, 24May2018, 28May2018, 01Jun2018
// ----          27Nov2018, 30Nov2018, 10Jan2019, 13Jan2019, 17Jan2019, 18Jan2019, 27Apr2019
// ----          08Jun2019, 19Jun2019, 29Aug2019, 22Sep2019, 09Oct2019, 22Oct2019, 23Oct2019
// ----          31Oct2019, 26Feb2020, 22Mar2020, 03Apr2020, 25Apr2020, 26Apr2020, 28Apr2020
// ----          24Sep2020, 23Oct2020, 24Oct2020, 25Oct2020, 08Nov2020, 26Jan2021, 27Jan2021
// ----          19Feb2021, 02Jun2021, 20Jun2021, 20Jul2021, 11Dec2021, 30Dec2021, 04Jan2022
// ----          18Mar2022, 19Mar2022, 08Apr2022, 16Apr2022, 19Apr2022, 06May2022, 22Jun2022
// ----          23Jun2022, 24Jun2022, 04Feb2023, 09Feb2023, 18Feb2023, 27Jul2023, 29Jul2023
// ----          03Oct2023, 15Oct2023, 30Oct2023, 02Nov2023, 17Nov2023, 18Nov2023, 03Feb2024
// ----          06May2024, 01Oct2024, 31Jan2025, 28Feb2025, 07Jun2025, 11Sep2025, 16Sep2025
// ----          17Sep2025
// ----
// ----
// ----

module MNT_PatternView;

use namespace ui;
use namespace st2;


// Generated from STConfig.node_tracker_ctlcolor_palette
IntArray ctlcolor_palette_wrapped;


StringArray ctl_names = [
   "CTL_NOTE1",      "CTL_NOTE2",      "CTL_NOTE3",      "CTL_NOTE4",      "CTL_NOTE5",
   "CTL_VEL1",       "CTL_VEL2",       "CTL_VEL3",       "CTL_VEL4",       "CTL_VEL5",
   "CTL_DUR1",       "CTL_DUR2",       "CTL_DUR3",       "CTL_DUR4",       "CTL_DUR5",
   "CTL_POLYAT1",    "CTL_POLYAT2",    "CTL_POLYAT3",    "CTL_POLYAT4",    "CTL_POLYAT5",
   "CTL_INSTR",      "CTL_PC",         "CTL_AT",         "CTL_PB",         "CTL_SLIDE",
   "CTL_DELAY",      "CTL_RETRIG",     "CTL_BPM",        "CTL_MUTE",       "CTL_SEEK",
   "CTL_BPM_MUL",    "CTL_GROOVE"
   // ..user controllers 32-48 are instrument-specific..
];

IntArray default_ctl_styles = [
   NT_CEL.STYLE_NOTE,    //  0: CTL_NOTE1
   NT_CEL.STYLE_NOTE,    //  1: CTL_NOTE2
   NT_CEL.STYLE_NOTE,    //  2: CTL_NOTE3
   NT_CEL.STYLE_NOTE,    //  3: CTL_NOTE4
   NT_CEL.STYLE_NOTE,    //  4: CTL_NOTE5
   NT_CEL.STYLE_HEX,     //  5: CTL_VEL1
   NT_CEL.STYLE_HEX,     //  6: CTL_VEL2
   NT_CEL.STYLE_HEX,     //  7: CTL_VEL3
   NT_CEL.STYLE_HEX,     //  8: CTL_VEL4
   NT_CEL.STYLE_HEX,     //  9: CTL_VEL5
   NT_CEL.STYLE_HEX,     // 10: CTL_DUR1
   NT_CEL.STYLE_HEX,     // 11: CTL_DUR2
   NT_CEL.STYLE_HEX,     // 12: CTL_DUR3
   NT_CEL.STYLE_HEX,     // 13: CTL_DUR4
   NT_CEL.STYLE_HEX,     // 14: CTL_DUR5
   NT_CEL.STYLE_HEX,     // 15: CTL_POLYAT1
   NT_CEL.STYLE_HEX,     // 16: CTL_POLYAT2
   NT_CEL.STYLE_HEX,     // 17: CTL_POLYAT3
   NT_CEL.STYLE_HEX,     // 18: CTL_POLYAT4
   NT_CEL.STYLE_HEX,     // 19: CTL_POLYAT5
   NT_CEL.STYLE_LETTER,  // 20: CTL_INSTR
   NT_CEL.STYLE_HEX,     // 21: CTL_PC
   NT_CEL.STYLE_HEX,     // 22: CTL_AT
   NT_CEL.STYLE_HEX,     // 23: CTL_PB
   NT_CEL.STYLE_HEX,     // 24: CTL_SLIDE
   NT_CEL.STYLE_HEX,     // 25: CTL_DELAY
   NT_CEL.STYLE_HEX,     // 26: CTL_RETRIG
   NT_CEL.STYLE_HEX,     // 27: CTL_BPM
   NT_CEL.STYLE_LETTER,  // 28: CTL_MUTE
   NT_CEL.STYLE_HEX,     // 29: CTL_SEEK
   NT_CEL.STYLE_HEX,     // 30: CTL_BPM_MUL
   NT_CEL.STYLE_HEX,     // 31: CTL_GROOVE

   0//dummy
];

IntArray default_ctl_ranges = [
   NT_CEL.RANGE_0_127,     //  0: CTL_NOTE1
   NT_CEL.RANGE_0_127,     //  1: CTL_NOTE2
   NT_CEL.RANGE_0_127,     //  2: CTL_NOTE3
   NT_CEL.RANGE_0_127,     //  3: CTL_NOTE4
   NT_CEL.RANGE_0_127,     //  4: CTL_NOTE5
   NT_CEL.RANGE_0_127,     //  5: CTL_VEL1
   NT_CEL.RANGE_0_127,     //  6: CTL_VEL2
   NT_CEL.RANGE_0_127,     //  7: CTL_VEL3
   NT_CEL.RANGE_0_127,     //  8: CTL_VEL4
   NT_CEL.RANGE_0_127,     //  9: CTL_VEL5
   NT_CEL.RANGE_0_127,     // 10: CTL_DUR1
   NT_CEL.RANGE_0_127,     // 11: CTL_DUR2
   NT_CEL.RANGE_0_127,     // 12: CTL_DUR3
   NT_CEL.RANGE_0_127,     // 13: CTL_DUR4
   NT_CEL.RANGE_0_127,     // 14: CTL_DUR5
   NT_CEL.RANGE_0_127,     // 15: CTL_POLYAT1
   NT_CEL.RANGE_0_127,     // 16: CTL_POLYAT2
   NT_CEL.RANGE_0_127,     // 17: CTL_POLYAT3
   NT_CEL.RANGE_0_127,     // 18: CTL_POLYAT4
   NT_CEL.RANGE_0_127,     // 19: CTL_POLYAT5
   NT_CEL.RANGE_0_127,     // 20: CTL_INSTR
   NT_CEL.RANGE_0_127,     // 21: CTL_PC
   NT_CEL.RANGE_0_127,     // 22: CTL_AT
   NT_CEL.RANGE_M64_P63,   // 23: CTL_PB
   NT_CEL.RANGE_0_127,     // 24: CTL_SLIDE
   NT_CEL.RANGE_0_255,     // 25: CTL_DELAY
   NT_CEL.RANGE_0_255,     // 26: CTL_RETRIG
   NT_CEL.RANGE_0_255,     // 27: CTL_BPM
   NT_CEL.RANGE_0_255,     // 28: CTL_MUTE
   NT_CEL.RANGE_0_255,     // 29: CTL_SEEK
   NT_CEL.RANGE_0_255,     // 30: CTL_BPM_MUL
   NT_CEL.RANGE_0_127,     // 31: CTL_GROOVE

   0//dummy
];


StringArray midi_notes = [
   // (note) actually, MIDI note #0 == C-2 (am.) resp. C-3 (ger.). ST² starts with C-0
   "C-0", "C#0", "D-0", "D#0", "E-0", "F-0", "F#0", "G-0", "G#0", "A-0", "A#0", "B-0", //   0.. 11
   "C-1", "C#1", "D-1", "D#1", "E-1", "F-1", "F#1", "G-1", "G#1", "A-1", "A#1", "B-1", //  12.. 23
   "C-2", "C#2", "D-2", "D#2", "E-2", "F-2", "F#2", "G-2", "G#2", "A-2", "A#2", "B-2", //  24.. 35
   "C-3", "C#3", "D-3", "D#3", "E-3", "F-3", "F#3", "G-3", "G#3", "A-3", "A#3", "B-3", //  36.. 47
   "C-4", "C#4", "D-4", "D#4", "E-4", "F-4", "F#4", "G-4", "G#4", "A-4", "A#4", "B-4", //  48.. 59
   "C-5", "C#5", "D-5", "D#5", "E-5", "F-5", "F#5", "G-5", "G#5", "A-5", "A#5", "B-5", //  60.. 71
   "C-6", "C#6", "D-6", "D#6", "E-6", "F-6", "F#6", "G-6", "G#6", "A-6", "A#6", "B-6", //  72.. 83
   "C-7", "C#7", "D-7", "D#7", "E-7", "F-7", "F#7", "G-7", "G#7", "A-7", "A#7", "B-7", //  84.. 95
   "C-8", "C#8", "D-8", "D#8", "E-8", "F-8", "F#8", "G-8", "G#8", "A-8", "A#8", "B-8", //  96..107
   "C-9", "C#9", "D-9", "D#9", "E-9", "F-9", "F#9", "G-9", "G#9", "A-9", "A#9", "B-9", // 108..119
   "C-A", "C#A", "D-A", "D#A", "E-A", "F-A", "F#A", "G-A", "G#A", "A-A", "A#A", "B-A", // xxx F#A is actually the highest note (127)..
   "C-B", "C#B", "D-B", "D#B", "E-B", "F-B", "F#B", "G-B", "G#B", "A-B", "A#B", "B-B"
];

// <function.png>
function UpdateMIDINoteOctaves() {
   byte oct = mathClampi(STConfig.midi_note_octave_offset, -2, 0);
   int noteIdx = 0;
   loop(128)
   {
      String sNote <= midi_notes[noteIdx++];

      if(STConfig.b_node_tracker_note_octave_offset_glyphs)
      {
         if(oct > 9)
            sNote[2] = 'A'+(oct-10);
         else if(-1 == oct)
            sNote[2] = 129;  // pattern_font.png char 129 (px 768) = -1
         else if(-2 == oct)
            sNote[2] = 130;  // pattern_font.png char 130 (px 776) = -2
         else
            sNote[2] = '0'+oct;
      }
      else
      {
         if(oct < 0)
         {
            sNote.replace("-", "~");
            sNote.replace("#", "=");
         }
         if(oct > 9)
            sNote[2] = 'A'+(oct-10);
         else
            sNote[2] = '0'+abs(oct);
      }

      if(0 == (noteIdx % 12))
         oct++;
   }
}

StringArray instr_letters = [ "0","1","2","3","4","5","6","7","8","9",
                            "A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z",
                            "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"
];

StringArray hex_ff = [ "00","01","02","03","04","05","06","07","08","09","0A","0B","0C","0D","0E","0F",
                       "10","11","12","13","14","15","16","17","18","19","1A","1B","1C","1D","1E","1F",
                       "20","21","22","23","24","25","26","27","28","29","2A","2B","2C","2D","2E","2F",
                       "30","31","32","33","34","35","36","37","38","39","3A","3B","3C","3D","3E","3F",
                       "40","41","42","43","44","45","46","47","48","49","4A","4B","4C","4D","4E","4F",
                       "50","51","52","53","54","55","56","57","58","59","5A","5B","5C","5D","5E","5F",
                       "60","61","62","63","64","65","66","67","68","69","6A","6B","6C","6D","6E","6F",
                       "70","71","72","73","74","75","76","77","78","79","7A","7B","7C","7D","7E","7F",
                       "80","81","82","83","84","85","86","87","88","89","8A","8B","8C","8D","8E","8F",
                       "90","91","92","93","94","95","96","97","98","99","9A","9B","9C","9D","9E","9F",
                       "A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","AA","AB","AC","AD","AE","AF",
                       "B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","BA","BB","BC","BD","BE","BF",
                       "C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","CA","CB","CC","CD","CE","CF",
                       "D0","D1","D2","D3","D4","D5","D6","D7","D8","D9","DA","DB","DC","DD","DE","DF",
                       "E0","E1","E2","E3","E4","E5","E6","E7","E8","E9","EA","EB","EC","ED","EE","EF",
                       "F0","F1","F2","F3","F4","F5","F6","F7","F8","F9","FA","FB","FC","FD","FE","FF"
];

StringArray patnr3_strings = [ "01A", "01B", "01C", "01D", "02A", "02B", "02C", "02D",
                               "03A", "03B", "03C", "03D", "04A", "04B", "04C", "04D",
                               "05A", "05B", "05C", "05D", "06A", "06B", "06C", "06D",
                               "07A", "07B", "07C", "07D", "08A", "08B", "08C", "08D",
                               "09A", "09B", "09C", "09D", "10A", "10B", "10C", "10D",
                               "11A", "11B", "11C", "11D", "12A", "12B", "12C", "12D",
                               "13A", "13B", "13C", "13D", "14A", "14B", "14C", "14D",
                               "15A", "15B", "15C", "15D", "16A", "16B", "16C", "16D",
                               "17A", "17B", "17C", "17D", "18A", "18B", "18C", "18D",
                               "19A", "19B", "19C", "19D", "20A", "20B", "20C", "20D",
                               "21A", "21B", "21C", "21D", "22A", "22B", "22C", "22D",
                               "23A", "23B", "23C", "23D", "24A", "24B", "24C", "24D",
                               "25A", "25B", "25C", "25D", "26A", "26B", "26C", "26D",
                               "27A", "27B", "27C", "27D", "28A", "28B", "28C", "28D",
                               "29A", "29B", "29C", "29D", "30A", "30B", "30C", "30D",
                               "31A", "31B", "31C", "31D", "32A", "32B", "32C", "--/"
                               ];

StringArray patnr2_strings = [ "1A", "1B", "1C", "1D", "2A", "2B", "2C", "2D",
                               "3A", "3B", "3C", "3D", "4A", "4B", "4C", "4D",
                               "5A", "5B", "5C", "5D", "6A", "6B", "6C", "6D",
                               "7A", "7B", "7C", "7D", "8A", "8B", "8C", "8D",
                               "9A", "9B", "9C", "9D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "?D",
                               "?A", "?B", "?C", "?D", "?A", "?B", "?C", "-/"
                               ];




NT_BlockInterpolationDialog *dlg_blockinterpol;


// <class.png>
class NT_TimingBBox {
   float xl;
   float yt;
   float xr;
   float yb;

   int track_nr;
   int ctl_id;
   int dur_ctl_id;  // note cels only (DUR1..4), or -1 (not a note ctl or using node default duration)
   int offset;      // ticks (event start offset)
   int dur_offset;  // duration offset ticks, or -1 (not a note ctl)
   int dur_ticks;   // duration in ticks, or -1 (not a note ctl)

   // <method_init.png>
   public method init(float _xl, float _yt, float _xr, float _yb,
                      int _trackNr,
                      int _ctlId,
                      int _durCtlId,
                      int _offset,
                      int _durOffset,
                      int _durTicks
                      ) {
      xl = _xl;
      yt = _yt;
      xr = _xr;
      yb = _yb;
      track_nr   = _trackNr;
      ctl_id     = _ctlId;
      dur_ctl_id = _durCtlId;
      offset     = _offset;
      dur_offset = _durOffset;
      dur_ticks  = _durTicks;
   }
}

// <class.png>
class NT_PatternView : Control, NT_Defs {

   NodeTrackerEditor *parent_editor;
   NodeTracker *parent_node;

   define String EV_REDRAWPATTERN;
   define String EV_SCROLLDOWNPATTERN;  // scroll down pattern after MIDI note was recorded or last note off was received

   define int MAX_ROWS = 96;

   define int NUM_SONGPOS_COLS = 10; // first cols (songoffset resp. bar/beat/tick position) 000-00-000

   define int TRACK_LABEL_HEIGHT = 24*2; // (todo) should be dynamic / depending on actual label height (line breaks!)

   define int TRACK_MUTE_MINY = 21*1;
   define int TRACK_MUTE_MAXY = 24*3;

   define String FONTNAME_TRACKNAME = "default bold 13";

   define int REDRAW_TIMEOUT_SHORT  = 33;
   define int REDRAW_TIMEOUT_MEDIUM = 100;
   define int REDRAW_TIMEOUT_LONG   = 500;

   define String TA_REDRAW            = "onRedrawTimer";
   define String TA_REDRAW_OVERLAYS   = "onRedrawOverlaysTimer";
   define String TA_REDRAW_ALL        = "onRedrawAllTimer";
   define String TA_AUTOSCROLL        = "onAutoscrollTimer";
   define String TA_AUTOSCROLL_TRACKS = "onAutoscrollTracksTimer";
   define String TA_RECORDMIDIEND     = "onRecordMIDIEnd";
   define String TA_MINIHEX;
   define String TA_PIANO_WIDGET;

   protected TimerAction *ta_redraw;
   protected TimerAction *ta_redraw_overlays;
   protected TimerAction *ta_redraw_all;
   protected TimerAction *ta_autoscroll;
   protected TimerAction *ta_autoscroll_tracks;
   public    TimerAction *ta_recordmidiend;
   protected TimerAction *ta_minihex;
   public    TimerAction *ta_piano_widget;

   define String MIDIMAP_REC_NOTE = "rec_note";
   define String MIDIMAP_REC_CTL  = "rec_ctl";

   public boolean b_block_quiet; // true=don't print messages during block ops (used for macro-like commands)
   protected boolean b_block_anc_active; // true=anchor selection (lshift+cursor keys)
   protected int block_swapback_start_pat_offset;
   protected int block_swapback_start_cursor_track;
   protected int block_swapback_start_cursor_x;
   protected int block_swapback_end_pat_offset;
   protected int block_swapback_end_cursor_track;
   protected int block_swapback_end_cursor_x;
   protected PopupMenu *pm_block;

   // block selection modes
   define int BLOCK_MODE_CTL     = 0;
   define int BLOCK_MODE_TRACK   = 1;
   define int BLOCK_MODE_PATTERN = 2;
   define int NUM_BLOCK_MODES    = 3;
   public int block_mode = BLOCK_MODE_TRACK;
   protected boolean b_block_in_clipboard; // true=currently selected block was copied to clipboard

   protected int col_limit = 1024;

   protected int num_rows;
   public int center_row;

   public int real_char_width = 8;   // unscaled char width
   public int real_char_height = 12; // unscaled char height
   public int char_width;        // scaled char width
   public int char_height;       // scaled char height
   protected float char_vheight; // for texture coordinates

   protected int bg_color = 0xFFccc8c0;//0xFFc6c2bb; //0xFFc0bcb5; // UIConstants.COLOR32_CONTROL_BG

   protected boolean b_render_all;

   protected IntArray stripes; // indexes texture stripes
   protected IntArray dirty_rows;
   protected StringArray strings;
   protected IntArray *[] colors; // 0..num_rows. c32 per column

   protected IntArray     mesh_row_vbos;  // 0..num_rows
   protected IntArray     mesh_row_zoom_vbos;  // 0..num_rows
   protected IntArray     mesh_row_num_verts;

   // // protected FloatArray   bg_mesh_vertices; // 2d quads
   // // protected IntArray     bg_mesh_colors;
   // // protected FloatArray   bg_mesh_colors_f;  // see STConfig.b_node_tracker_use_colorarray4f
   // // protected FloatArray   bg_mesh_cliptop_vertices; // 2d quads
   // // protected FloatArray   bg_mesh_clipbottom_vertices; // 2d quads
   // // protected IntArray     bg_mesh_clip_colors;
   // // protected FloatArray   bg_mesh_clip_colors_f;  // see STConfig.b_node_tracker_use_colorarray4f
   protected int bg_mesh_vbo_id;
   protected int bg_mesh_clip_vbo_id;
   protected int bg_mesh_num_verts;

   protected PointerArray bar_strings; // Array of PointerArray of StringArrays ( [0..2=>3/5/7] [rangeId] [intval] )

   public boolean b_bg_mesh   = true; // true = draw background mesh (for cels that have a tinted background)
   public boolean b_hlcenter  = true; // true = highlight center row (darker bg)

   define int HIGHLIGHT_MAX_TIMEOUT = 30;
   define int HIGHLIGHT_MOUSEOVER_TIMEOUT = 2;
   define int HIGHLIGHT_CURSORMOVE_TIMEOUT = 6*2;

   define int HIGHLIGHT_NEIGHBOUR_TIMEOUT = 30;
   protected int neighbour_hl_countdown;

   protected Texture tex_screen;
   public    Texture tex_font; // font texture is shared with ControllerStatusView
   protected Texture tex_eq;

   protected boolean b_mouse_selection;

   public    int cursor_x; // Current column within track (note,instr,vel,dur) (mirror of track.cursor_x / node.pv_cursor_x)
   public    int bookmark_pat_offset;
   public    int step_resolution; // Number of ticks per visible line
   public    int step_advance; // Number of steps to scroll down after an event has been entered. -1=go to next event
   public    int page_num_steps; // page 1 quarter (4 steps)
   public    int page_fast_num_steps; // page 2 quarters (8 steps)
   public    int highlight_info_last_cursor_track; // Remember last printed cell to avoid superfluous statusline prints
   public    int highlight_info_last_cursor_x;
   public    int highlight_row_timeout;
   public    int highlight_row_y; // row pixel offset

   public int time_replaystart;

   protected int        autoscroll_dir; // -1=up, 1=down
   protected MouseEvent autoscroll_ev;

   protected int autoscroll_tracks_dir; // -1=left, 1=right

   FloatParamEditor *fp_detailedit;
   int detailedit_patpos;
   int detailedit_ctlid;

   Font *label_font;

   boolean block_modify_start; // for block selection via mouse drag

   boolean b_insdel_shiftall_mode; // 1=shift all following events when insert/delete is pressed (default), 0=only shift next event (relative shift mode)

   protected PopupMenu *trackmenu;

   int     freedraw_cursor_track; // used while drawing bar-style envelopes (RMB). -1=freedraw inactive
   int     freedraw_cursor_x;
   float   freedraw_last_val;
   int     freedraw_last_patoffset;
   boolean freedraw_deletemode;

   protected int marker_playoffset;

   protected boolean b_rmb_scrolldrag;
   protected float rmb_scrolldrag_delta;

   protected int last_multimute_tracknr = -1;

   protected StringDialog           *dlg_trackname;
   protected NT_Track       *dlg_trackname_track;
   protected NT_SetTickModuloDialog  dlg_tickmodulo;
   protected TextInputDialog        *dlg_stepalignment;
   protected NT_JumpToStepDialog    *dlg_jumptostep;
   protected NT_AudioDialog         *dlg_audio;
   public    NT_RandomDialog        *dlg_random;
   public    NT_QuantizeDialog      *dlg_quantize;

   protected boolean b_minihex_lsb_save; // temp, saved in onKey
   protected boolean b_minihex_lsb;

   protected boolean b_minihex_last_auto_msb;  // used for horizontal HEX editing when shift/caps is pressed to automove to MSB

   protected int minipat3_last_auto;  // used for horizontal PATNR editing when shift/caps is pressed to automove to TSB
   protected int minipat3_last_patnr; // used for two-digit shortcut (1..9, e.g. '9D')

   protected int cur_rotate_count;  // while rotating pattern up/down, resets when cursor is moved. <0=up, >0=down

   // protected int replay_ticks_since_replay_stop;  // counts down to 0 while replay is stopped

   protected ActiveNoteState chord_detect;

   protected PointerArray timing_bboxes;  // NT_TimingBBox instances
   define int TIMING_DRAG_NONE   = 0;
   define int TIMING_DRAG_START  = 1;
   define int TIMING_DRAG_CENTER = 2;
   define int TIMING_DRAG_END    = 3;
   protected int timing_mouse_drag_mode;  // TIMING_DRAG_xxx
   protected boolean b_timing_mouse_drag;
   protected NT_TimingBBox timing_mouse_drag_bbox;
   protected float timing_mouse_drag_start_y;
   protected int timing_mouse_drag_current_offset;
   protected int timing_mouse_drag_bbox_dur1_ticks;
   protected int timing_mouse_drag_bbox_dur2_ticks;
   protected int timing_mouse_drag_bbox_dur3_ticks;
   protected int timing_mouse_drag_bbox_dur4_ticks;
   protected int timing_mouse_drag_bbox_dur5_ticks;
   protected boolean b_timing_mouse_drag_start_lmb;  // true=drag was started with LMB, false=started with RMB

   protected int next_keyjazz_note_ctl;  // -1=none, CTL_NOTEx (0..4) otherwise  (for lshift-return)

   namespace boolean b_queue_verify_track_shift;

   protected byte last_ghost_pattern_nr;

   protected StringArray   *audiosampleselector_sample_names;  // see showAudioSampleSelectorAt()
   protected IntArray      *audiosampleselector_sample_ids;    // UIDs or MIDI Program Change Nr (depending on instrument.b_audio mode)
   protected int            audiosampleselector_editpatpos;
   protected ComboBoxPopup *cmp_audiosampleselector;


   // <init.png>
   public method init(NodeTrackerEditor _parentEditor) {

      initControl();

      parent_editor <= _parentEditor;

      // Copy configuration

      char_width  = real_char_width  * (1 + useDoubleWidth());
      char_height = real_char_height * (1 + useDoubleHeight());

      initTimers();

      loadFontTexture();
      loadEQTexture();

      genBarStrings();

      genCtlColorPaletteWrapped();

      cursor_x = 0;

      step_resolution      = current_song.ppq / 4;
      step_advance         = 1;
      bookmark_pat_offset  = 0;

      page_num_steps       = 4;
      page_fast_num_steps  = 8;

      highlight_info_last_cursor_track = -1;
      highlight_info_last_cursor_x     = -1;
      highlight_row_timeout            = 0;

      b_insdel_shiftall_mode   = true;

      NodeTracker.SelectClipboard(NodeTracker.CB_DEFAULT);
      b_block_quiet = false;

      fp_detailedit <= new FloatParamEditor;
      fp_detailedit.initEditor();
      fp_detailedit.addActionConsumer(this);

      freedraw_cursor_track = -1;

      dlg_blockinterpol <= NT_BlockInterpolationDialog.New(this);
      dlg_tickmodulo    <= new NT_SetTickModuloDialog;

      allocRows();
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_redraw            <= TimerAction.New(TA_REDRAW,            this, REDRAW_TIMEOUT_MEDIUM);
      ta_redraw_overlays   <= TimerAction.New(TA_REDRAW_OVERLAYS,   this, REDRAW_TIMEOUT_SHORT );
      ta_redraw_all        <= TimerAction.New(TA_REDRAW_ALL,        this, REDRAW_TIMEOUT_MEDIUM); // dynamic timeout
      ta_autoscroll        <= TimerAction.New(TA_AUTOSCROLL,        this, (1000/30)            );
      ta_autoscroll_tracks <= TimerAction.New(TA_AUTOSCROLL_TRACKS, this, 300                  );
      ta_recordmidiend     <= TimerAction.New(TA_RECORDMIDIEND,     this, STConfig.midi_step_record_undo_timeout);
      ta_minihex           <= TimerAction.New(TA_MINIHEX,           this, 1000                 );
      ta_piano_widget      <= TimerAction.New(TA_PIANO_WIDGET,      this, (1000/50)            );

      ta_redraw    .setDefaultTicks(0, REDRAW_TIMEOUT_SHORT, REDRAW_TIMEOUT_MEDIUM, REDRAW_TIMEOUT_LONG);
      ta_redraw_all.setDefaultTicks(0, REDRAW_TIMEOUT_SHORT, REDRAW_TIMEOUT_MEDIUM, REDRAW_TIMEOUT_LONG);
   }

   // <method_get.png>
   protected method useDoubleCenter() : boolean {
      return
         UI.IsHiDPI()
         ? STConfig.b_node_tracker_doublecenter_hidpi
         : STConfig.b_node_tracker_doublecenter_lodpi
         ;
   }

   // <method_get.png>
   protected method useDoubleWidth() : boolean {
      if(null != parent_node)
      {
         return
            (UI.IsHiDPI()
             ? STConfig.b_node_tracker_doublewidth_hidpi
             : STConfig.b_node_tracker_doublewidth_lodpi
             )
            ||
            (parent_node.b_ui_timing_view && STConfig.b_node_tracker_timing_view_autodouble_width)
            ;
      }
      else
      {
         return
            UI.IsHiDPI()
            ? STConfig.b_node_tracker_doublewidth_hidpi
            : STConfig.b_node_tracker_doublewidth_lodpi
            ;
      }
   }

   // <method_get.png>
   protected method useDoubleHeight() : boolean {
      if(null != parent_node)
      {
         return
            (UI.IsHiDPI()
             ? STConfig.b_node_tracker_doubleheight_hidpi
             : STConfig.b_node_tracker_doubleheight_lodpi
             )
            ||
            (parent_node.b_ui_timing_view && STConfig.b_node_tracker_timing_view_autodouble_height)
            ;
      }
      else
      {
         return
            UI.IsHiDPI()
            ? STConfig.b_node_tracker_doubleheight_hidpi
            : STConfig.b_node_tracker_doubleheight_lodpi
            ;
      }
   }

   // <method_handle.png>
   public method handleInitNewSong() {

      step_resolution = current_song.ppq / 4;

      resetCursor();
      redrawAll();
   }

   // <ui_init.png>
   protected method genBarStringU(int _v, float _max, int _numChars, String _s) {
      // Unsigned

      int maxPix = (8 * _numChars);
      int numPix = mathClampf(0.5 + _v / (float(_max) / maxPix), 0, maxPix);

      loop(_numChars)
      {
         if(numPix < 8)
         {
            _s.append(tcchar(192+int(numPix)));
            break;
         }
         else
         {
            _s.append(tcchar(192+8));
            numPix -= 8;
            _numChars--;
         }
      }
      while(--_numChars > 0)
      {
         _s.append(tcchar(192));
      }

   }

   // <ui_init.png>
   protected method genBarStringS(int _v, float _center, float _max, int _numChars, String _s) {
      // Signed

      _numChars /= 2;

      if(_v > _center)
      {
         // RHS
         loop(_numChars)
            _s.append(tcchar(192));

         genBarStringU(_v - _center, _max, _numChars, _s);
      }
      else
      {
         // LHS
         int maxPix = (8 * _numChars);
         int numPix = mathClampf(-(_v-_center) / (float(_max+1) / maxPix), 1, maxPix);

         int x = maxPix - 8;
         loop(_numChars)
         {
            if(numPix >= x)
            {
               if((numPix-x) > 8)
                  _s.append(tcchar(192+9+8));
               else
                  _s.append(tcchar(192+9+int(numPix-x)));
            }
            else
            {
               _s.append(tcchar(192));
            }

            x -= 8;
         }

         loop(_numChars)
            _s.append(tcchar(192));
      }

   }

   // <ui_init.png>
   protected method genBarStringB(int _v, float _max, int _numChars, String _s) {
      if(_v >= (_max * 0.5))
      {
         // On
         loop(_numChars)
            _s.append(tcchar(192+8));
      }
      else
      {
         // Off
         loop(_numChars)
            _s.append(tcchar(192));
      }
   }

   // <ui_init.png>
   protected method genBarStrings() {

      bar_strings.alloc(4); // 4,8,16,32

      int numChars;

      foreach numChars in [4, 8, 16, 32]
      {
         PointerArray aRange <= new PointerArray;
         aRange.alloc(6); // num RANGE_xxx

         bar_strings.add(#(deref aRange));

         int range = NT_CEL.RANGE_0_255; // 0
         loop(6)
         {
            StringArray aStr <= new StringArray;
            aStr.alloc(256);

            aRange.add(#(deref aStr));

            int v = 0;
            loop(256)
            {
               String s <= aStr.nextFree;

               switch(range)
               {
                  case NT_CEL.RANGE_0_255:
                     genBarStringU(v, 255, numChars, s);
                     break;

                  case NT_CEL.RANGE_0_127:
                     genBarStringU(v, 127, numChars, s);
                     break;

                  case NT_CEL.RANGE_M128_P127:
                     genBarStringS(v, 128, 127, numChars, s);
                     break;

                  case NT_CEL.RANGE_M64_P63:
                     genBarStringS(v, 64, 63, numChars, s);
                     break;

                  case NT_CEL.RANGE_BINARY_127:
                     genBarStringB(v, 127, numChars, s);
                     break;

                  case NT_CEL.RANGE_BINARY_255:
                     genBarStringB(v, 255, numChars, s);
                     break;
               }

               v++;
            }

            range++;
         }
      }
   }

   // <method.png>
   protected method genCtlColorPaletteWrapped() {
      IntArray pal <= STConfig.node_tracker_ctlcolor_palette;

      int c32;
      foreach c32 in pal
      {
         c32 = UI.MixColor32(c32, lnf_colors.get(LookAndFeel.COLOR_WINDOW_BG), STConfig.node_tracker_wrap_dim);
         ctlcolor_palette_wrapped.add(c32);
      }
   }

   // <ui_show.png>
   public method showNode(NodeTracker _node) {
      parent_node <= _node;

      cursor_x        = parent_node.pv_cursor_x;
      step_resolution = parent_node.pv_step_resolution;

      handleTimingViewAutoDouble();

      // Fix
      if(replay.b_playing)
      {
         NT_MetaPattern mpatCur <= parent_node.getCurrentEditMetaPattern();

         if(null != mpatCur)
         {
            int relTickOff = current_song.song_offset - parent_node.nodeGetLastPatternStartSongOffset();
            if(relTickOff < 0)
               relTickOff = 0;
            if(parent_node.doAutoScroll())
            {
               parent_node.setEditOffset(relTickOff);
            }
            parent_node.setReplayUIPatOffset(relTickOff);
         }
      }

      renderPattern();

      validateCursorX();
      cursorTrackChanged();
      verifyTrackShift(true/*bAlignRight*/);

      cur_rotate_count = 0;

      if(STConfig.b_arranger_force_mute_edit)
         NodeArranger.SetEnableForceMute(true);

      timing_mouse_drag_mode = TIMING_DRAG_NONE;
      b_timing_mouse_drag = false;

      next_keyjazz_note_ctl = -1;

      if(parent_node.b_ui_piano)
         ta_piano_widget.reschedule();
   }

   // <ui_show.png>
   public method showNodeQuiet(NodeTracker _node) {
      parent_node <= _node;
   }

   // <method.png>
   public method cancelAllTimers() {
      ta_redraw           .cancel();
      ta_redraw_overlays  .cancel();
      ta_redraw_all       .cancel();
      ta_autoscroll       .cancel();
      ta_autoscroll_tracks.cancel();
      ta_recordmidiend    .cancel();
      ta_minihex          .cancel();
      ta_piano_widget     .cancel();
   }

   // <ui_hide.png>
   public method leaveNode() {

      cancelAllTimers();

      if(null != parent_node)
      {
         parent_node.pv_cursor_x        = cursor_x;
         parent_node.pv_step_resolution = step_resolution;

         // (note) do NOT unset parent_node
      }

      if(STConfig.b_arranger_force_mute_edit)
      {
         NodeArranger.SetEnableForceMute(false);
      }
   }

   // <ui.png>
   public virtual calcPreferredSizeY() {
      preferred_size_y = 1024*4;
   }

   // <ui.png>
   public virtual calcMinimumSizeY() {
      minimum_size_y = 62;
   }

   // <ui_kbd.png>
   public virtual isTabCycleMember() : boolean {
      return true;
   }

   // <ui_handle.png>
   public method handleCharSizeChanged() {

      char_width  = real_char_width  * (1 + useDoubleWidth());
      char_height = real_char_height * (1 + useDoubleHeight());

      allocRows();

      renderAndRedrawAll();
   }

   // <method_set.png>
   public method toggleDoubleCharWidth() {
      if(UI.IsHiDPI())
         STConfig.b_node_tracker_doublewidth_hidpi = !STConfig.b_node_tracker_doublewidth_hidpi;
      else
         STConfig.b_node_tracker_doublewidth_lodpi = !STConfig.b_node_tracker_doublewidth_lodpi;

      handleCharSizeChanged();

      Global.Print("Double char width is now "+Utils.GetEnableString(UI.IsHiDPI()
                                                                     ? STConfig.b_node_tracker_doublewidth_hidpi
                                                                     : STConfig.b_node_tracker_doublewidth_lodpi
                                                                     )
                   );
   }

   // <method_set.png>
   public method toggleDoubleCharHeight() {
      if(UI.IsHiDPI())
         STConfig.b_node_tracker_doubleheight_hidpi = !STConfig.b_node_tracker_doubleheight_hidpi;
      else
         STConfig.b_node_tracker_doubleheight_lodpi = !STConfig.b_node_tracker_doubleheight_lodpi;

      handleCharSizeChanged();

      Global.Print("Double char height is now "+Utils.GetEnableString(UI.IsHiDPI()
                                                                      ? STConfig.b_node_tracker_doubleheight_hidpi
                                                                      : STConfig.b_node_tracker_doubleheight_lodpi
                                                                      )
                   );
   }

   // <method_set.png>
   public method toggleAutoScroll() {
      STConfig.b_node_tracker_autoscroll = ! STConfig.b_node_tracker_autoscroll;

      if(parent_node.doAutoScroll())
      {
         // Jump to current song position if autoscroll was enabled
         parent_node.setEditOffset(parent_node.getReplayUIPatOffset());
      }

      ta_redraw_all.scheduleShort();

      Global.Print("Autoscroll is now "+Utils.GetEnableString(STConfig.b_node_tracker_autoscroll));
   }

   // <method_set.png>
   public method togglePatternWrapAroundMode() {
      STConfig.b_node_tracker_wraparound = ! STConfig.b_node_tracker_wraparound;

      Global.Print("Warp-around mode is now "+Utils.GetEnableString(STConfig.b_node_tracker_wraparound));
   }

   // <method_set.png>
   public method toggleMeshZoomMode() {
      if(UI.IsHiDPI())
         STConfig.b_node_tracker_doublecenter_hidpi = ! STConfig.b_node_tracker_doublecenter_hidpi;
      else
         STConfig.b_node_tracker_doublecenter_lodpi = ! STConfig.b_node_tracker_doublecenter_lodpi;

      renderAndRedrawAll();

      Global.Print("Center row height is now "+((UI.IsHiDPI()
                                                 ? STConfig.b_node_tracker_doublecenter_hidpi
                                                 : STConfig.b_node_tracker_doublecenter_lodpi
                                                 )
                                                ? "doubled":"normal"
                                                )
                   );
   }

   // <method_set.png>
   public method toggleRelativeShiftMode() {
      b_insdel_shiftall_mode = ! b_insdel_shiftall_mode;

      Global.Print("INS/DEL will now shift "+(b_insdel_shiftall_mode?"all events":"only the next event"));
   }

   // <method_set.png>
   public method toggleSwapStopBookmark() {
      STConfig.b_node_tracker_swapstopbookmark = !STConfig.b_node_tracker_swapstopbookmark;
   }

   // <ui_init.png>
   protected method allocRows() {
      num_rows = MAX_ROWS;
      center_row = 33;

      dirty_rows.alloc(num_rows);
      dirty_rows.numElements = num_rows;
      dirty_rows.fill(0);
      stripes.alloc(num_rows);
      stripes.identity(num_rows);

      strings.alloc(num_rows);
      strings.numElements = strings.maxElements;

      // Init color tables
      colors.alloc(num_rows);
      loop(num_rows)
      {
         IntArray colsI <= new IntArray();
         colsI.alloc(col_limit);
         colsI.useAll();
         colsI.fill(UIConstants.COLOR32_TEXT_FG);
         colors.add(#(deref colsI));
      }
   }

   // <ui.png>
   public virtual layoutHierarchy(local boolean _bInvalidateSizeCaches, local boolean _bLayoutFinal) {
      invalidateAbsolutePositions();
   }

   // <method_set.png>
   public method setEnableDrawBGMesh(boolean _bEnabled) : boolean {
      b_bg_mesh = _bEnabled;

      // // bg_mesh_cliptop_vertices    = bg_mesh_vertices;
      // // bg_mesh_clipbottom_vertices = bg_mesh_vertices;

      updateBGMesh();
      redraw();
   }

   // <method_get.png>
   public method isEditable() : boolean {
      if(null != parent_node)
      {
         if(null != parent_editor)
         {
            return
               (NodeTracker.PV_EDIT_NONE != parent_node.pv_edit_mode) &&
               (hasKeyboardFocus() || (parent_editor.envelope_view.data.hasKeyboardFocus()))
               ;
         }
      }
      return false;
   }

   // <method_get.png>
   public method isEditableNoFocus() : boolean {
      if( (null != parent_node) && (null != parent_editor) )
         return (NodeTracker.PV_EDIT_NONE != parent_node.pv_edit_mode);
      return false;
   }

   // <method_get.png>
   public method isRecordingIfFocused() : boolean {
      return (NodeTracker.PV_EDIT_NONE != parent_node.pv_edit_mode);
   }

   // <method_set.png>
   public =replay= method nextEditMode() {

      parent_node.pv_edit_mode = (parent_node.pv_edit_mode +1 ) % NodeTracker.NUM_PV_EDIT_MODES;

      if(NodeTracker.PV_EDIT_NONE == parent_node.pv_edit_mode)
      {
         if(STConfig.b_node_tracker_undo_record_single_transaction)
         {
            if(replay.b_playing)
            {
               // Edit mode was deactivated while recording => end transaction
               parent_node.stopTapMode(false/*bForce*/);
               parent_node.undoEnd();
            }
         }
      }
      else
      {
         if(replay.b_playing && parent_node.b_tap_mode)
         {
            parent_node.b_rt_record = true;
         }


         if(parent_node.b_rt_record) // replay was started while recording
         {
            if(STConfig.b_node_tracker_undo_record_single_transaction)
            {
               if(replay.b_playing)
               {
                  // Edit mode was activated during replay => start transaction
                  parent_node.undoBeginNested("record start");
               }
            }
         }
      }

      redraw();

      Global.Print("Edit mode is now "+((parent_node.pv_edit_mode==0)?"OFF":"ON"));
   }

   // <method_set.png>
   public method setEditMode(int _mode) {
      parent_node.pv_edit_mode = _mode;

      parent_node.rec_clear_start = -1;
   }

   // <method_set.png>
   public =replay= method gotoPatPosition(int _position, boolean _bClip) {
      int editOffset = parent_node.getEditOffset();
      if(_position != editOffset)
      {
         if(_bClip)
            editOffset = parent_node.getClippedPatOffset(_position);
         else
            editOffset = _position;

         if(editOffset < 0)
            editOffset = 0;

         parent_node.setEditOffset(editOffset);

         if(parent_node.doAutoScroll())
         {
            // (note) st² auto-extends songlength here

            if(!replay.b_playing && (replay.ticks_to_play <= 0))
            {
               current_song.seek(parent_node.getSongEditOffset());
            }
         }

         ta_redraw_all.scheduleShort();
      }
   }

   // <method_set.png>
   public method setStepResolution(int _res) {
      step_resolution = _res;

      // Save to node
      //  (note) during init, node is null
      if(null != parent_node)
      {
         parent_node.pv_step_resolution = step_resolution;

         if(!replay.b_playing || !parent_node.doAutoScroll())
         {
            // Goto aligned step offset
            parent_node.setEditOffset(parent_node.getAlignedPatOffset(parent_node.getEditOffset()));
            redrawAll();
         }
      }
   }

   // <method_set.png>
   public method setStepAdvance(int _adv) {
      step_advance = _adv;

      Global.Print("Step advance set to "+((_adv >= 0) ? Utils.GetNumString(_adv, "step") : "<next event>"));
   }

   // <method_get.png>
   public method getCurrentTrackNr() : int {
      if(null != parent_node)
         return /*track_shift + */parent_node.pv_cursor_track;
      return -1;
   }

   // <method_get.png>
   public method setCurrentTrackNr(int _trackNr) {
      if(null != parent_node)
         parent_node.pv_cursor_track = _trackNr;
   }

   // <method_get.png>
   public method getNumTracks() : int {
      return parent_node.tracks.numElements;
   }

   // <method_get.png>
   public method getTrack(local int _trackNr) : NT_Track {
      if(null != parent_node)
      {
         local NT_Track t <= parent_node.getTrack(_trackNr);
         return t;
      }
      else
      {
         return null;
      }
   }

   // <method_get.png>
   public method getCurrentTrack() : NT_Track {
      return getTrack(getCurrentTrackNr());
   }

   // <method_get.png>
   public method getCurrentTrackLayout() : NT_TEL {
      local NT_Track track <= getCurrentTrack();
      if(null != track)
         return track.getTrackLayout();
      else
         return null;
   }

   // <method_get.png>
   public method getTrackLayout(int _trackNr) : NT_TEL {
      local NT_Track track <= getTrack(_trackNr);
      if(null != track)
         return track.getTrackLayout();
      else
         return null;
   }

   // <method_get.png>
   public method getCurrentControllerLayout() : NT_CEL {
      local NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         local int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
         return tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
      }
      else
      {
         return null;
      }
   }

   // <method_get.png>
   public method getCurrentCelId() : int {
      local NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         local int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
         return ctlMapId & NT_TEL.CTLID_MASK; // mask out MSB_FLAG
      }
      else
      {
         return 0;
      }
   }

   // <method_get.png>
   public method getControllerName(NT_Track _track, int _ctlId) : String {

      NT_Instrument ins <= parent_node.getInstrument(_track.keyjazz_instr_nr);

      return NodeTracker.GetControllerName(ins, _ctlId);
   }

   // <method_get.png>
   public method getCurrentController() : int {
      NT_CEL cel <= getCurrentControllerLayout();
      if(null != cel)
         return cel.ctl_id;

      trace "[---] PatternView::getCurrentController: cel==NULL, THIS SHOULD NOT HAVE HAPPENED.";
      return 0; // should not be reachable
   }

   // <method_get.png>
   public method getNumVisibleTracks() : int {
      // TODO: cache this value until track_shift changes

      // trace "xxx getNumVisibleTracks: size_x="+size_x+" track_shift="+parent_node.pv_track_shift;

      int cols = getSizeX() / char_width;
      cols -= NUM_SONGPOS_COLS; // Offset to first track
      int i = parent_node.pv_track_shift;
      int ret = 0;
      while(cols > 0)
      {
         NT_Track track <= parent_node.getTrack(i);
         if(null != track)
         {
            // trace "xxx track.getTrackLayout().total_char_width="+(track.getTrackLayout().total_char_width);
            cols -= track.getTrackLayout().total_char_width;
            if(cols >= 0)
            {
               ret++;
               i++;
            }
         }
         else
         {
            return ret;
         }
      }
      return ret;
   }

   // <method_get.png>
   public method getNumVisibleRows() : int {
      return getSizeY() / char_height;
   }

   // <method_get.png>
   public method getCurrentPattern() : NT_TrackPattern {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_TrackPattern pat <= track.getCurrentEditPattern();
         return pat;
      }
      return null;
   }

   // <method_get.png>
   public method getOrCreateCurrentPattern() : NT_TrackPattern {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         int patNr = parent_node.nodeGetCurrentEditPatternNr();
         NT_TrackPattern pat <= track.getOrCreatePattern(patNr);
         return pat;
      }
      return null;
   }

   // <method_get.png>
   public method getCurrentEnvelope(int _ctl) : Envelope {
      NT_TrackPattern pat <= getCurrentPattern();
      if(null != pat)
      {
         Envelope env <= pat.getEnvelope(_ctl);
         return env;
      }
      return void;
   }

   // <method_get.png>
   public method getOrCreateCurrentEnvelope(int _ctl) : Envelope {
      NT_TrackPattern pat <= getOrCreateCurrentPattern();
      if(null != pat)
      {
         Envelope env <= pat.getCreateEnvelope(_ctl);
         return env;
      }
      return null;
   }

   // <method.png>
   public method toggleCurrentEnvelopeShReset() : boolean {
      // used for tiny synergy replay modseq retrig
      NT_CEL cel <= getCurrentControllerLayout();
      int ctlId = cel.ctl_id;
      Global.Debug("toggleCurrentEnvelopeShReset: ctlId="+ctlId);
      Envelope env <= getOrCreateCurrentEnvelope(ctlId);
      if(null != env)
      {
         if(ENV_SHRESET == env.interpolation)
            env.interpolation = ENV_SH;
         else
            env.interpolation = ENV_SHRESET;
         return (ENV_SHRESET == env.interpolation);
      }
      return false;
   }

   // <method_get.png>
   protected method getColumnExtents(int _track, _cursorX) : IntArray {
      IntArray ret;
      int relTrackNr = _track - parent_node.pv_track_shift;
      int px;
      NT_TEL *tel;

      px = NUM_SONGPOS_COLS; // Song position
      int i = parent_node.pv_track_shift;
      loop(relTrackNr)
      {
         tel <= parent_node.getTrack(i).getTrackLayout();
         px += tel.total_char_width;
         i++;
      }

      NT_Track track <= parent_node.getTrack(_track);
      if(null != track)
      {
         tel <= track.getTrackLayout();

         px += tel.cursor_extents[_cursorX*2 +0]; // char offset
         ret[0] = px*char_width;
         ret[1] = tel.cursor_extents[_cursorX*2 +1] * char_width; // column width
         return ret;
      }
      else
      {
         return [0, 0];
      }
   }

   // <method_get.png>
   protected method getCursorXAtPixel(int _px) : int {
      explain "Horizontal pixel position to cursor position. Return (track<<16)|(cursor_pos) or -1 if the pixel does not belong to any cursor cell.";
      if(parent_node.tracks.numElements)
      {
         // // trace "xxx PatternView::getCursorXAtPixel: track_shift="+parent_node.pv_track_shift;
         int trackNr = parent_node.pv_track_shift;
         int cx = NUM_SONGPOS_COLS; // skip song position
         _px /= char_width; // convert pixel to character cell position
         NT_TEL *tel;
         do
         {
            NT_Track track <= parent_node.getTrack(trackNr);
            if(null != track)
            {
               tel <= track.getTrackLayout();
               int cpos = 0;
               int cellSx;
               loop(tel.num_cursor_positions)
               {
                  int clx = cx + tel.cursor_extents[cpos*2 +0]; // offset
                  int crx = clx + tel.cursor_extents[cpos*2 +1]; // size
                  if(clx <= _px < crx)
                  {
                     // Found
                     return (trackNr<<16) | cpos;
                  }
                  cpos++;
               }
               cx += tel.total_char_width;
               trackNr++;
            }
            else return -1;
         } while(trackNr < (parent_node.tracks.numElements));
      }
      return -1;
   }

   // <method_get.png>
   protected method getPixelXAtCursorPosition() : int {
      int cursorTrack = getCurrentTrackNr();
      int cursorX        = cursor_x;
      int cx = NUM_SONGPOS_COLS * char_width; // skip song position

      if(parent_node.tracks.numElements)
      {
         int trackNr = parent_node.pv_track_shift;
         NT_TEL *tel;
         do
         {
            tel <= parent_node.getTrack(trackNr).getTrackLayout();
            if(trackNr == cursorTrack)
            {
               // Ok, found track. Now calculate exact position
               cx += char_width * tel.cursor_extents[cursorX*2 +0]; // add column offset to pixel position
               break;
            }
            else
            {
               // Next track
               cx += tel.total_char_width * char_width;
               trackNr++;
            }
         } while(trackNr < (parent_node.tracks.numElements));
      }
      return cx;
   }

   // <method_get.png>
   protected method getTrackPixelOffsetAndWidth(int _trackNr, Integer _retOffset, Integer _retWidth) {

      _retOffset = -1;

      if(parent_node.tracks.numElements)
      {
         int cx = 6 * char_width; // skip song position + space before first track
         int sx;
         int trackNr = 0;
         NT_TEL *tel;
         for(;;)
         {
            tel <= parent_node.getTrack(trackNr).getTrackLayout();
            // Ok, found track. Now calculate exact position
            sx = char_width * (tel.total_char_width - 1); // -1 for space between tracks

            if(trackNr == _trackNr)
            {
               _retOffset = cx;
               _retWidth  = sx;
               return;
            }

            // Next track
            if(trackNr >= parent_node.pv_track_shift)
            {
               cx += sx + char_width;
            }
            trackNr++;
         }
      }
   }

   // <replay.png>
   public =replay= method playStep() {

      current_song.seek(parent_node.getSongEditOffset());
      replay.playTicks(step_resolution, -1/*rewindTicks*/, false/*bMuted*/);

      replay.setPatternNode(parent_node);  // see STConfig.b_node_tracker_ignore_seek_prgchg_mute_during_pattern_replay

      if(step_advance > 0)
      {
         scrollDown();
      }
      else if(-1 == step_advance)
      {
         gotoNextEvent();
      }
   }

   // <replay.png>
   public =replay= method playNoteAndCycle() {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_TEL tel <= track.getTrackLayout();
         NT_CEL cel <= getCurrentControllerLayout();

         if(-1 == next_keyjazz_note_ctl)
         {
            if(cel.isNoteCtl())
               next_keyjazz_note_ctl = cel.ctl_id;
         }
         else
         {
            // Find next visible note cel
            cel <= tel.findVisibleNoteCelByIdx((next_keyjazz_note_ctl + 1) % NT_TrackPattern.NUM_NOTESLOTS);
            if(null != cel)
               next_keyjazz_note_ctl = cel.ctl_id;
            else
               next_keyjazz_note_ctl = -1;
         }

         if(-1 == next_keyjazz_note_ctl)
         {
            // Find first visible note cel
            cel <= tel.findVisibleNoteCelByIdx(0);
            if(null != cel)
               next_keyjazz_note_ctl = cel.ctl_id;
         }

         if(-1 != next_keyjazz_note_ctl)
         {
            var noteVal = parent_node.getTrackEventAt(next_keyjazz_note_ctl, parent_node.getEditOffset());
            if(typeid(noteVal) == YAC_TYPE_FLOAT)
            {
               int noteVel = parent_node.getTrackVelocityAt(next_keyjazz_note_ctl, parent_node.getEditOffset());
               int noteDurTicks = parent_node.getTrackDurationTicksAt(next_keyjazz_note_ctl, parent_node.getEditOffset());
               parent_node.keyJazzNoteOnTicks(noteVal, noteVel, noteDurTicks);
            }
         }
      }
   }

   // <replay.png>
   public =replay= method restartPattern() {
      // called when pressing return while playing/recording a pattern
      replay.b_playing = false;

      if(isEditable())
         parent_node.undoEndCondPat();

      // Restart replay
      loopCurrentPattern(false/*bFromCurOffset*/, true/*bStop*/);
   }

   // <method_set.png>
   public method setPatternReplayOffsetToCursor()  {
      if(!replay.b_playing)
      {
         NT_Track track <= getCurrentTrack();
         if(null != track)
         {
            NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();

            if(null != mpat)
            {
               int relPatTime = parent_node.getEditOffset();
               mpat.ui_pattern_replay_start_offset = relPatTime;

               int absStartOffset = current_song.song_offset - relPatTime;
               Global.Debug("nt::setPatternReplayOffsetToCursor: song_offset="+RootForm.GetSongPosString(current_song.song_offset)+" relPatTime="+relPatTime+" => new lastPatternStart*Offset="+RootForm.GetSongPosString(absStartOffset));
               if(absStartOffset < 0)
                  absStartOffset = 0; // should not happen
               parent_node.nodeSetLastPatternStartSongOffset(absStartOffset);
               parent_node.nodeSetLastPatternStartEditorSongOffset(absStartOffset);

               ta_redraw_all.scheduleShort(); // "*" indicates replay start offset

               Global.Print("Replay offset set to +"+(relPatTime/step_resolution)+" ("+relPatTime+" ticks). Pattern reference offset is "+RootForm.GetSongPosString(parent_node.nodeGetLastPatternStartSongOffset())+".");
            }
         }
      }
   }

   // <replay.png>
   public =replay= method loopCurrentPattern(boolean _bFromCurOffset, boolean _bStop) {

      parent_editor.cmd_replay_pat();

      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();

      if(null != mpat)
      {
         if(_bStop)
         {
            replay.stopReplay(false/*bAllowBookmark*/, true/*bAllowPanic*/);
         }

         bookmark_pat_offset = parent_node.getEditOffset();

         int songOffsetPatStart = parent_node.nodeGetLastPatternStartEditorSongOffset();

         // Offset start by editor replay start position
         if(!_bFromCurOffset)
         {
            int patStartOff;
            if(parent_node.b_block_loop)
               patStartOff = parent_node.block_loop_start - songOffsetPatStart;
            else
               patStartOff = mpat.ui_pattern_replay_start_offset;

            parent_node.setReplayUIPatOffset(patStartOff);

            if(parent_node.doAutoScroll())
            {
               parent_node.setEditOffset(parent_node.getReplayUIPatOffset());
            }

            if(parent_node.getReplayUIPatOffset() != bookmark_pat_offset)
            {
               ta_redraw_all.scheduleShort();
            }
         }
         else
         {
            parent_node.setReplayUIPatOffset(parent_node.getEditOffset());
         }

         if(!parent_node.b_block_loop)
            parent_node.nodeCopyLastPatternStartSongOffsetFromEditor();

         Global.Debug2("PV: loopCurrentPattern: songOffsetPatStart="+songOffsetPatStart);

         parent_node.nodeSetCurrentPlayPatternNr(parent_node.nodeGetCurrentEditPatternNr());

         if(parent_node.b_block_loop)
         {
            current_song.b_block_loop = true;

            // Loop block selection (previously marked with lctrl-RETURN)
            current_song.seek(parent_node.block_loop_start);
            current_song.last_played_song_offset = parent_node.block_loop_start;

            replay.startReplay(false/*bCustomCycle*/);  // [15Nov2020] start after seek

            current_song.playLoop(parent_node.block_loop_start,  // start ticks
                                  parent_node.block_loop_start + parent_node.block_loop_len,  // end ticks
                                  parent_node.block_loop_start   // repeat offset
                                  );
            // trace "xxx start block loop: off="+parent_node.block_loop_start+" len="+parent_node.block_loop_len;

         }
         else
         {
            current_song.b_block_loop = false;  // should already be false

            // Regular pattern play
            current_song.playLoop(
               songOffsetPatStart + parent_node.getReplayUIPatOffset(),  /* start offset */
               songOffsetPatStart + mpat.num_ticks,        /* end offset */
               songOffsetPatStart                          /* repeat offset */
                                  );

            parent_node.startEditorLoop(parent_node.getReplayUIPatOffset(),
                                        mpat.num_ticks
                                        );

            replay.startReplay(false/*bCustomCycle*/);  // [15Nov2020] start after seek
         }

         replay.setPatternNode(parent_node);

         Global.Debug2("PV: loopCurrentPattern at offset = " + (current_song.song_offset)+" length = "+(current_song.current_end_offset - current_song.song_offset));
      }
   }

   // <replay.png>
   public method updatePatternLoop() {
      // Update loop range while playing
      current_song.queueNewLoop(parent_node.nodeGetLastPatternStartEditorSongOffset(),
                                parent_node.nodeGetLastPatternStartEditorSongOffset() + parent_node.getCurrentEditMetaPatternLength(),
                                true/*bQuiet*/
                                );

      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();
      if(null != mpat)
      {
         parent_node.startEditorLoop(parent_node.getReplayUIPatOffset(),
                                     mpat.num_ticks
                                     );
      }
   }

   // <replay.png>
   public method handleStopPlaying(boolean _bAllowBookmark) {

      ta_recordmidiend.cancel();
      parent_node.undoEndNested("record MIDI");

      parent_node.nodeHandleStopRecording();

      if(parent_node.queued_undo_record_restart_ticks >= 0)
      {
         replay.setEnableDiscardCtlCollect(false);
         parent_node.queued_undo_record_restart_ticks = -1;
      }

      // Reset eq_anim
      parent_node.resetEQ();

      if(_bAllowBookmark)
      {
         if(parent_node.doAutoScroll())
         {
            gotoBookmark();
         }
      }

      printCursorStatusInfo();

      queueRedrawAll();
   }

   // <replay.png>
   public =replay= method handleStartPlaying() {

      if(parent_node.doAutoScroll())
      {
         if(parent_node.getReplayUIPatOffset() != parent_node.getEditOffset())
         {
            parent_node.setEditOffset(parent_node.getReplayUIPatOffset());

            ta_redraw_all.scheduleShort();
         }
      }

      if(parent_node.nodeIsEditorVisible())
      {
         parent_editor.piano.clearNotes();

         // Also see NodeTracker::nodeHandleStartRecording() (called when editor is not visible)
         if(STConfig.b_node_tracker_undo_record_single_transaction)
         {
            if(isEditable() || parent_node.nodeIsArmedForRecording())
            {
               // (note) b_rt_record is true when handleKeyRShift() was used to start recording
               if(parent_node.doAutoScroll() || parent_node.b_rt_record)
               {
                  // Replay was started while edit mode is active => start transaction
                  parent_node.b_rt_record = true;

                  parent_node.undoBeginNested("record start");

                  Global.Debug2("pv: start recording (editor)");
               }
            }
         }
      }
   }

   // <replay.png>
   public =replay= method startReplay() {
      // Start (song) replay from current step on

      ST_Song song <= current_song;

      if(replay.b_playing == false)
      {
         bookmark_pat_offset  = parent_node.getEditOffset();
         parent_node.setReplayUIPatOffset(parent_node.getEditOffset());

         current_song.ui_song_offset = parent_node.nodeGetLastPatternStartEditorSongOffset() + parent_node.getEditOffset();

         song.playLoop(parent_node.nodeGetLastPatternStartEditorSongOffset() + parent_node.getEditOffset(),
                       parent_node.nodeGetLastPatternStartEditorSongOffset() + parent_node.getCurrentEditMetaPatternLength(),
                       parent_node.nodeGetLastPatternStartEditorSongOffset()
                       );

         replay.startReplay(true/*bCustomCycle*/);

         Global.Debug("PatternView::startReplay: continue replay from "+parent_node.getEditOffset());
      }
      else
      {
         // Already playing, simply update play region
         updatePatternLoop();
      }
   }

   // <replay.png>
   public =replay= method undoRecording() {
      // Called before restarting recording
      //  - undo
      //  - turn off rt recording
      //  - continue regular replay until restart position is reached
      if(isEditable() && replay.b_playing && parent_node.b_rt_record)
      {
         if(STConfig.b_node_tracker_undo_record_single_transaction)
         {
            NT_UndoEntry e <= parent_node.ui_undo_entry;
            if(null != e)
            {
               if(e.name == "record start")
               {
                  if(parent_node.undoEnd())
                     parent_node.undo(false/*do not restore cursor position*/);

                  queueRedrawAll();
                  parent_node.num_rec_notes = 0; // for RASTER rec_mode
                  parent_node.rec_clear_start = -1;
                  // // Restart/continue pattern replay
                  parent_node.b_rt_record = false; // set to false by stopReplay(), re-enabled when restart position is reached
                  parent_node.pv_edit_mode = NodeTracker.PV_EDIT_NONE;
                  replay.setEnableDiscardCtlCollect(true);
                  return true;
               }
            }
         }
      }
   }

   // <replay.png>
   public =replay= method restartRecording() {
      // (note) undo already done in undoRecording()
      if(replay.b_playing)
      {
         if(STConfig.b_node_tracker_undo_record_single_transaction)
         {
            parent_node.undoBeginNested("record start");
            queueRedrawAll();
            parent_node.num_rec_notes = 0; // for RASTER rec_mode
            parent_node.rec_clear_start = -1;
            // Restart pattern recording
            boolean bOrigTapMode = parent_node.b_tap_mode;
            replay.stopReplay(!STConfig.b_node_tracker_swapstopbookmark, false/*bAllowPanic*/);
            if(bOrigTapMode)
               parent_node.startTapMode();
            parent_node.b_rt_record = true; // set to false by stopReplay()
            parent_node.pv_edit_mode = NodeTracker.PV_EDIT_STEP;
            loopCurrentPattern(false/*bFromCurOffset*/, false/*bStop*/);
            replay.setEnableDiscardCtlCollect(false);
            return true;
         }
      }
   }

   // <replay.png>
   public =replay= method undoAndRestartRecordingExec() {
      // Undo and immediately restart recording
      if(isEditable() && replay.b_playing && parent_node.b_rt_record)
      {
         if(STConfig.b_node_tracker_undo_record_single_transaction)
         {
            NT_UndoEntry e <= parent_node.ui_undo_entry;
            if(null != e)
            {
               if(e.name == "record start")
               {
                  if(parent_node.undoEnd())
                     parent_node.undo(false/*do not restore cursor position*/);

                  parent_node.undoBeginNested("record start");
                  queueRedrawAll();
                  parent_node.num_rec_notes = 0; // for RASTER rec_mode
                  parent_node.rec_clear_start = -1;

                  // Restart pattern recording
                  boolean bOrigTapMode = parent_node.b_tap_mode;
                  replay.stopReplay(!STConfig.b_node_tracker_swapstopbookmark, false/*bAllowPanic*/);

                  if(bOrigTapMode)
                     parent_node.startTapMode();

                  parent_node.b_rt_record = true; // set to false by stopReplay()
                  loopCurrentPattern(false/*bFromCurOffset*/, false/*bStop*/);
                  return true;
               }
            }
         }
      }
   }

   // <replay.png>
   public =replay= method undoAndRestartRecording() : boolean {
      // allow active recording transaction to be undone while recording
      if(isEditable() && replay.b_playing && parent_node.b_rt_record)
      {
         if(STConfig.b_node_tracker_undo_record_single_transaction)
         {
            if((-1 != parent_node.queued_undo_record_restart_ticks) || (STConfig.node_tracker_record_restart_quantization < 0))
            {
               // Undo+Restart immediately
               parent_node.queued_undo_record_restart_ticks = -1;
               return undoAndRestartRecordingExec();
            }
            else
            {
               // Queue restart
               if(STConfig.node_tracker_record_restart_quantization > 0)
               {
                  int numTicksPerNote = current_song.ppq * 4;
                  float numTicksPerBeat = (numTicksPerNote / float(current_song.sig_notelen));
                  int curTicks = parent_node.tick_nr;
                  int curBeatNr = int(curTicks / numTicksPerBeat);
                  int restartBeatNr = (int(curBeatNr / STConfig.node_tracker_record_restart_quantization) + 1) * STConfig.node_tracker_record_restart_quantization;
                  // trace "xxx restartBeatNr="+restartBeatNr+" curTicks="+curTicks+" (/48 = "+(curTicks/48)+")";
                  parent_node.queued_undo_record_restart_ticks = numTicksPerBeat * restartBeatNr;
               }
               else
               {
                  parent_node.queued_undo_record_restart_ticks = (parent_node.tick_nr - parent_node.nodeGetCurrentTickOffset()) + parent_node.getCurrentEditMetaPatternLength();
               }

               // trace "xxx queued_undo_record_restart_ticks="+queued_undo_record_restart_ticks+" curTicks="+curTicks;

               // Undo but keep on playing until restart position
               undoRecording();
            }

            return true;
         }
      }

      return false;
   }

   // <method_handle.png>
   public =replay= method handleReplayTickUI() {
      // called from UI thread when replay is running (via NodeTrackerEditor.handleReplayTickUI())
      // (note) this is not called every tick

      NodeTracker otherNode <= parent_node.nodeFindOtherQuickJumpNode();
      if(otherNode instanceof NodeTracker)
      {
         byte ghostPatNr = otherNode.nodeGetCurrentPlayPatternNr();
         // trace "xxx handleReplayTickUI: ghostPatNr="+ghostPatNr+" last_ghost_pattern_nr="+last_ghost_pattern_nr;
         if( (ghostPatNr != last_ghost_pattern_nr) || otherNode.checkResetUIGhostSeek() )
         {
            otherNode.nodeSetCurrentEditPatternNr(ghostPatNr);
            renderAndRedrawAll();
         }
      }

      redraw();
   }

   // <replay.png>
   public method handleReplayTick() {
      // called from replay thread via NodeTrackerEditor.handleReplayTick()
      explain "Called while song is playing. If replay_tick_count==step_resolution then scroll down pattern.
 This method is called from the replay/audio thread so we must not render anything here!";

      // (note) called at the end of a replay tick

      // also see handleDelayedRenderAndRedraw()

      if(replay.b_playing)
      {
         if(0 == (parent_node.jam_current_ticks % step_resolution))
         {
            // Repaint this window as soon as possible
            //  send asynchronous event to UI thread.
            //  (note) we can NOT call redraw() here since tkui itself is not thread-safe!
            //  (note) when event is recv'd, NodeTrackerEditor.handleReplayTickUI() is called
            Events.SendNodeEditorReplayTick();
         }
      }

      if(-1 != parent_node.queued_undo_record_restart_ticks)
      {
         if(parent_node.tick_nr >= parent_node.queued_undo_record_restart_ticks)
         {
            // trace "xxx parent_node.tick_nr="+parent_node.tick_nr+" parent_node.queued_undo_record_restart_ticks="+parent_node.queued_undo_record_restart_ticks;
            parent_node.queued_undo_record_restart_ticks = -1;

            // (todo) this actually happens at least one tick too late but doing the undo in the replay thread is not an option
            // // undoAndRestartRecordingExec();
            restartRecording();
         }
      }
   }

   // <method.png>
   public method handleTrackLayoutChanged() {
      // called by EditTrackLayout and ManageColumnsDialog
      validateCursorX();
      cursorTrackChanged();
      verifyTrackShift(true);
      redrawAll();
   }

   // <method.png>
   public method gotoBookmark() {
      parent_node.setEditOffset(bookmark_pat_offset);

      ta_redraw_all.scheduleShort();
   }

   // <ui_init.png>
   protected method loadEQTexture() {
      tex_eq.unload();
      tex_eq.loadImage("eq-64x64.png", 0,0,0);
      if(255 == STConfig.node_tracker_eq_opacity)
      {
         tex_eq.flags = TEX_MAGFILTERLINEAR;
      }
      else
      {
         tex_eq.flags = TEX_MAGFILTERLINEAR | TEX_MODULATE;
      }
   }

   // <ui_init.png>
   protected method genTexFontEnvGfx(Texture _tex8) {
      _tex8.drawFilledBox(0, 16, 2048, 16, #10101010);
      int cy;
      int ix;
      int cx = 0;
      int w;

      cy = 16+2;
      loop(8)
      {
         ix = 0;
         loop(8*9*2)
         {
            if(!((ix^cy)&1))
            {
               _tex8.setXY32(ix, cy, #07070707);
            }
            ix++;
         }
         cy++;
      }


      for(w=0; w<=8; w++)
      {
         _tex8.drawFilledBox(cx, 16, w, 1, #6f6f6f6f);
         _tex8.drawFilledBox(cx, 16+1, w, 1, #3f3f3f3f);
         _tex8.drawFilledBox(cx, 16+2, w, 8, #bfbfbfbf);
         _tex8.drawFilledBox(cx, 16+10, w, 1, #3f3f3f3f);
         _tex8.drawFilledBox(cx, 16+11, w, 1, #6f6f6f6f);
         cy = 16+2;
         loop(8)
         {
            ix = cx;
            loop(w)
            {
               if(!((ix^cy)&1))
               {
                  _tex8.setXY32(ix, cy, #7f7f7f7f);
               }
               ix++;
            }
            cy++;
         }
         cx += 8;
      }

      cx = 8*9;
      for(w=0; w<=8; w++)
      {
         _tex8.drawFilledBox(cx+(8-w), 16, w, 1, #6f6f6f6f);
         _tex8.drawFilledBox(cx+(8-w), 16+1, w, 1, #3f3f3f3f);
         _tex8.drawFilledBox(cx+(8-w), 16+2, w, 8, #bfbfbfbf);
         _tex8.drawFilledBox(cx+(8-w), 16+10, w, 1, #3f3f3f3f);
         _tex8.drawFilledBox(cx+(8-w), 16+11, w, 1, #6f6f6f6f);
         cy = 16+2;
         loop(8)
         {
            ix = cx+(8-w);
            loop(w)
            {
               if(!((ix^cy)&1))
               {
                  _tex8.setXY32(ix, cy, #7f7f7f7f);
               }
               ix++;
            }
            cy++;
         }
         cx += 8;
      }

      // For CTL_COLOR cels (fully opaque 8x8 block)
      //  charCode: 192+18 = 210 = 0xD2
      //  (todo) [20Jun2021] REMOVE (replaced by CTL_GROOVE)

      // 0xd2 = side block / continued SH
      cx = 8*18;
      _tex8.drawFilledBox(cx, 16, 2, 16, #ffffffff);
      _tex8.setXY32(cx+2, 16+0, #FFFFFFFF);
      _tex8.setXY32(cx+3, 16+1, #FFFFFFFF);
      _tex8.setXY32(cx+2, 16+2, #FFFFFFFF);
      _tex8.setXY32(cx+3, 16+3, #FFFFFFFF);
      _tex8.setXY32(cx+2, 16+4, #FFFFFFFF);
      _tex8.setXY32(cx+3, 16+5, #FFFFFFFF);
      _tex8.setXY32(cx+2, 16+6, #FFFFFFFF);
      _tex8.setXY32(cx+3, 16+7, #FFFFFFFF);
      _tex8.setXY32(cx+2, 16+8, #FFFFFFFF);
      _tex8.setXY32(cx+3, 16+9, #FFFFFFFF);
      _tex8.setXY32(cx+2, 16+10, #FFFFFFFF);
      _tex8.setXY32(cx+3, 16+11, #FFFFFFFF);

      // 0xD3 = header block
      cx = 8*19;
      _tex8.drawFilledBox(cx, 16, 8, 16, #ffffffff);

      // 0xD4 = empty note step in timing view (left)
      cx = 8*20;
      _tex8.drawFilledBox(cx, 16,   8, 1,    #ffffffff);
      _tex8.drawFilledBox(cx, 16+1, 8, 16-1, #00000000);
      cy = 1;
      loop(11)
      {
         _tex8.setXY32(cx+0, 16+cy, #ffffffff);
         cy++;
      }

      // 0xD5 = empty note step in timing view (middle)
      cx = 8*21;
      _tex8.drawFilledBox(cx, 16,   8, 1,    #ffffffff);
      _tex8.drawFilledBox(cx, 16+1, 8, 16-1, #00000000);

      // 0xD6 = empty note step in timing view (right)
      cx = 8*22;
      _tex8.drawFilledBox(cx, 16,   8, 1,    #ffffffff);
      _tex8.drawFilledBox(cx, 16+1, 8, 16-1, #00000000);
      cy = 1;
      loop(11)
      {
         _tex8.setXY32(cx+7, 16+cy, #ffffffff);
         cy++;
      }

      // 0xD7 = single-char empty ctl in timing view
      cx = 8*23;
      _tex8.drawFilledBox(cx, 16,   8, 1,    #ffffffff);
      _tex8.drawFilledBox(cx, 16+1, 8, 16-1, #00000000);
      cy = 1;
      loop(11)
      {
         _tex8.setXY32(cx+0, 16+cy, #ffffffff);
         _tex8.setXY32(cx+7, 16+cy, #ffffffff);
         cy++;
      }

   }

   // <ui_init.png>
   protected method loadFontTexture() {
      tex_font.unload();
      tex_font.freeImage();
      // Upper 16 pixel high region is used for chars, lower 16 pixels are used for env. graphics
      //  (note) in GLcore profile, texture() fetch returns alpha channel in GL_RED channel (=> use BeginTextured*Triangle*Alpha())
      tex_font.flags = TEX_MODULATE | TEX_ALPHA;
      tex_font.alloc(2048, 32, 1);

      Texture tmp;
      tmp.loadImage("pattern_font.png", 0,0,1);
      tex_font.copyRegion(tmp, 0, 0, tmp.sx, tmp.sy, 0, 0);
      tmp.freeImage();
      genTexFontEnvGfx(tex_font);
      tex_font.upload();

      char_vheight = float(real_char_height) / tex_font.sy;
   }

   // <ui_init.png>
   public virtual onOpen() {
      if(Configuration.debugLevel >= 2)
         Global.Debug2("NT_PatternView::onOpen");

      mesh_row_vbos     .allocAndFill(num_rows, 0);
      mesh_row_zoom_vbos.allocAndFill(num_rows, 0);
      mesh_row_num_verts.allocAndFill(num_rows, 0);
      int rowIdx = 0;
      loop(num_rows)
      {
         mesh_row_vbos     [rowIdx] = sdvg_CreateVBO(col_limit * (2*3) * (2*4 + 4 + 2*4));
         mesh_row_zoom_vbos[rowIdx] = sdvg_CreateVBO(col_limit * (2*3) * (2*4 + 4 + 2*4));
         rowIdx++;
      }

      bg_mesh_vbo_id      = sdvg_CreateVBO(col_limit * (2*3) * (4 + 2*4));
      bg_mesh_clip_vbo_id = sdvg_CreateVBO(col_limit * (2*3) * (4 + 2*4));

      loadFontTexture();
      loadEQTexture();

      if(RootForm.PAGE_NODE == root_form.getCurrentPageNr())
         flagRenderAll();
   }

   // <ui_render.png>
   public /*=replay=*/ method redrawCurrentRow() {
      dirty_rows[center_row] = true;
      updateMeshes();
      redraw();
   }

   // <ui_render.png>
   public method redrawRow(int _row) {
      if(_row >= 0)
      {
         if(_row < dirty_rows.numElements)
         {
            dirty_rows[_row] = true;
            updateMeshes();
            redraw();
         }
      }
   }

   // <ui_render.png>
   protected method redrawAllRows() {
      stripes.identity(num_rows);
      dirty_rows.fill(true);
      redraw();
   }

   // <ui_render.png>
   protected method renderPattern() {
      redrawAllRows();
      renderPatPosition(parent_node.getEditOffset(), -1);
      updateMeshes();
   }

   // <method_handle.png>
   protected method handleEnvelopeViewPositionChanged() {
      parent_editor.envelope_view.handlePositionChanged();
   }

   // <ui_render.png>
   protected method redrawEnvelopeView() {
      parent_editor.envelope_view.data.redraw();
   }

   // <ui_render.png>
   public method queueRedraw() {
      ta_redraw.schedule();
   }

   // <ui_render.png>
   public method queueRedrawAll() {
      // Calls renderAndRedrawAll() when timer expires
      ta_redraw_all.scheduleShort();
   }

   // <ui_render.png>
   public method redrawAll() {
      renderAndRedrawAll();
      redraw();
   }

   // <ui_render.png>
   public virtual redraw() {
      // Regular redraw
      Control::redraw();
   }

   // <ui_render.png>
   public method renderAndRedrawAll() {

      // Clip/wrap-around according to pattern length
      //  (note) this fixes the cursor position when changing patterns
      if(null != parent_node)
      {
         int jamLen = parent_node.getCurrentEditMetaPatternLength();
         if(jamLen > 0)
         {
            if(parent_node.getEditOffset() >= jamLen)
               parent_node.setEditOffset(parent_node.getEditOffset() % jamLen);

            if(parent_node.getReplayUIPatOffset() >= jamLen)
               parent_node.setReplayUIPatOffset(parent_node.getReplayUIPatOffset() % jamLen);
         }

         renderPattern();
         redrawEnvelopeView();
      }
   }

   // <ui_render.png>
   public == method flagRenderAll() {
      b_render_all = true; // Render all next time onDraw() is called

      if(null != parent_node) // is null when called from onOpen() during startup
      {
         int patOffset = parent_node.jam_current_ticks;

         // Clip/wrap-around according to pattern length
         //  (note) this fixes the cursor position when changing patterns
         int jamLen = parent_node.getCurrentEditMetaPatternLength();
         if(jamLen > 0)
            patOffset = patOffset % jamLen;

         parent_node.setReplayUIPatOffset((patOffset / step_resolution) * step_resolution);

         if(parent_node.doAutoScroll())
         {
            // trace "xxx doAutoScroll (all): replay_ui_pat_offset="+replay_ui_pat_offset+" (step="+(replay_ui_pat_offset / step_resolution)+")";
            parent_node.setEditOffset(parent_node.getReplayUIPatOffset());
         }
      }
   }

   // <ui_render.png>
   protected method updateMeshes() {
      //
      // prepare/update texture resp. mesh data for onDraw() call
      //
      if(b_bg_mesh)
         updateBGMesh();

      updateMesh();
   }

   // <ui_render.png>
   protected method updateBGMesh() {
      // create/update.. bg mesh

      float trackPx = NUM_SONGPOS_COLS * char_width;

      // // bg_mesh_vertices.empty();
      // // bg_mesh_cliptop_vertices.empty();
      // // bg_mesh_clipbottom_vertices.empty();
      // // bg_mesh_colors.empty();
      // // bg_mesh_colors_f.empty();
      // // bg_mesh_clip_colors.empty();
      // // bg_mesh_clip_colors_f.empty();

      int numVisTracks = getNumVisibleTracks();
      int trackNr = parent_node.pv_track_shift;
      boolean bBigEndian = TKS.isBigEndian();

      local Buffer buf;      buf    .size = col_limit * (2*3) * (4 + (2*4));
      local Buffer bufClip;  bufClip.size = col_limit * (2*3) * (4 + (2*4));

      loop(numVisTracks + 1) // + 1 for partially visible track
      {
         NT_Track track <= parent_node.getTrack(trackNr);
         if(null != track)
         {
            NT_TEL tel <= track.getTrackLayout();
            NT_CEL *cel;
            int cursorX = 0;
            loop(tel.num_cursor_positions)
            {
               // Get cel for cursor position
               int celId = tel.cursor_to_ctl_map.get(cursorX);
               cel <= tel.ctl_layouts[celId & NT_TEL.CTLID_MASK];

               if(cel.bg_tint)
               {
                  float px = trackPx + (tel.cursor_extents.get(cursorX*2+0))*char_width; // offset
                  float sx = (tel.cursor_extents.get(cursorX*2+1)) * char_width;         // width

                  // Song/Replay-area vertices

                  int c32 = cel.bg_tint & 0x00FFFFFF;
                  int a8  = mathClampf((((cel.bg_tint>>24)&255) * STConfig.node_tracker_celcolor_alpha) >> 8, 0, 255);
                  int c32Clip = c32;
                  int a8Clip = a8 * (1.0 - STConfig.node_tracker_wrap_dim_bgalpha);

                  c32 = argb( ((a8     )&255), // a
                              ((c32>>16)&255), // r
                              ((c32>> 8)&255), // g
                              ((c32    )&255)  // b
                              );

                  c32Clip = argb( ((a8Clip     )&255), // a
                                  ((c32Clip>>16)&255), // r
                                  ((c32Clip>> 8)&255), // g
                                  ((c32Clip    )&255)  // b
                                  );

                  // 1
                  buf.rgba = c32;
                  buf.add2f(px,    0.0f);

                  buf.rgba = c32;
                  buf.add2f(px+sx, 0.0f);

                  buf.rgba = c32;
                  buf.add2f(px+sx, 1.0f);  // (note) normalized y

                  // 2
                  buf.rgba = c32;
                  buf.add2f(px,    0.0f);

                  buf.rgba = c32;
                  buf.add2f(px+sx, 1.0f);  // (note) normalized y

                  buf.rgba = c32;
                  buf.add2f(px,    1.0f);  // (note) normalized y

                  // 1
                  bufClip.rgba = c32Clip;
                  bufClip.add2f(px,    0.0f);

                  bufClip.rgba = c32Clip;
                  bufClip.add2f(px+sx, 0.0f);

                  bufClip.rgba = c32Clip;
                  bufClip.add2f(px+sx, 1.0f);  // (note) normalized y

                  // 2
                  bufClip.rgba = c32Clip;
                  bufClip.add2f(px,    0.0f);

                  bufClip.rgba = c32Clip;
                  bufClip.add2f(px+sx, 1.0f);  // (note) normalized y

                  bufClip.rgba = c32Clip;
                  bufClip.add2f(px,    1.0f);  // (note) normalized y
               }

               // Next cursor position
               cursorX++;
            }

            trackPx += tel.total_char_width * char_width;

         } // if track

         // Next track
         trackNr++;

      } // loop numVisTracks

      // // bg_mesh_cliptop_vertices    = bg_mesh_vertices;
      // // bg_mesh_clipbottom_vertices = bg_mesh_vertices;

      sdvg_UpdateVBO(bg_mesh_vbo_id,      0/*offset*/, buf.offset/*numBytes*/, buf);
      sdvg_UpdateVBO(bg_mesh_clip_vbo_id, 0/*offset*/, bufClip.offset/*numBytes*/, bufClip);
      sdvg_UnbindVBO();

      bg_mesh_num_verts = buf.offset / (4 + (2*4));
   }

   // <ui_render.png>
   protected method updateMesh() {
      explain "Create/update mesh stripes. ";
      // trace "xxx updateMesh: ENTER";

      int linenr = 0;
      int num = mathMini(strings.numElements, num_rows);
      float charUS = float(real_char_width) / tex_font.sx;

      boolean bBigEndian = TKS.isBigEndian();

      loop(num)
      {
         int stripeNr = stripes[linenr];

         if(dirty_rows[linenr])
         {
            IntArray    col    <= colors  [stripeNr];
            String      text   <= strings [stripeNr];

            int iter = 0;  // 0=normal, 1=zoom
            loop(2)
            {
               int meshVBO;
               float charH;
               int numVerts = 0;

               if(iter > 0)
               {
                  meshVBO = mesh_row_zoom_vbos[stripeNr];
                  charH = char_height * 2.0f;
               }
               else
               {
                  meshVBO = mesh_row_vbos[stripeNr];
                  charH = char_height;
               }

               sdvg_MapVBO(meshVBO);
               sdvg_BeginVBO(text.numChars*6, (2*4)+4+(2*4));
               // trace "xxx updateMesh: expected VBO offset="+(text.numChars*6*((2*4)+4+(2*4)));

               int i = 0;
               float cx = 0;
               loop(text.numChars)
               {
                  // trace "xxx i="+i+" text=\""+text+"\"";
                  char c = text[i];
                  int c32;
                  float u;
                  float v;
                  if(c >= 192)
                  {
                     // Bar gfx character
                     u = (c-192) * charUS;
                     v = 0.5f;
                     // // trace "xxx c["+i+"]="+c+" u="+u+" us="+charUS;
                  }
                  else if(c > ' ')
                  {
                     // Regular ASCII character
                     u = (c-33) * charUS;
                     v = 0.0f;
                     // // trace "xxx c["+i+"]="+c+" u="+u+" us="+charUS;
                  }
                  else
                  {
                     // Non-printable character
                     u = -1.0f;
                  }

                  if(u >= 0.0f)
                  {
                     c32 = col[i] | #ff000000;
                     // c32 = #ffffffff;

                     // 1
                     sdvg_TexCoord2f(u, v);
                     sdvg_ColorARGB(c32);
                     sdvg_Vertex2f(cx, 0);

                     sdvg_TexCoord2f(u + charUS, v);
                     sdvg_ColorARGB(c32);
                     sdvg_Vertex2f(cx+char_width, 0);

                     sdvg_TexCoord2f(u + charUS, v + char_vheight);
                     sdvg_ColorARGB(c32);
                     sdvg_Vertex2f(cx+char_width, charH);

                     // 2
                     sdvg_TexCoord2f(u, v);
                     sdvg_ColorARGB(c32);
                     sdvg_Vertex2f(cx, 0);

                     sdvg_TexCoord2f(u + charUS, v + char_vheight);
                     sdvg_ColorARGB(c32);
                     sdvg_Vertex2f(cx+char_width, charH);

                     sdvg_TexCoord2f(u, v + char_vheight);
                     sdvg_ColorARGB(c32);
                     sdvg_Vertex2f(cx, charH);

                     numVerts += 6;
                  }

                  i++;
                  cx += char_width;
               }
               sdvg_End();
               // trace "xxx updateMesh: VBOoffset="+sdvg_GetMappedVBOOffset();
               sdvg_UnmapVBO();

               // trace "xxx stripeNr="+stripeNr+" iter="+iter+" numVerts="+numVerts;
               mesh_row_num_verts[stripeNr] = numVerts;

               iter++;
            } // loop 2 (zoom)

            dirty_rows[linenr] = false;
         }
         linenr++;
      }
      sdvg_UnbindVBO();
      // trace "xxx updateMesh: LEAVE";
   }

   // <ui_render.png>
   protected method redrawRecordedPatPosition(int _patOff) {
      // used during keyjazz recording (recorded event may be placed on next instead of center row)
      ta_redraw_all.scheduleShort();
   }

   // <method.png>
   protected =replay= method calcOtherGhostOff(NodeTracker otherNode, boolean bDebug) {
      int thisStartOff  = parent_node.nodeGetLastPatternStartEditorSongOffset();
      int otherStartOff = otherNode.nodeGetLastPatternStartSongOffset();
      int otherRelOff   = otherStartOff - thisStartOff;
      return -otherRelOff;
   }

   // <ui_render.png>
   public /*=replay=*/ method renderPatPosition(int _offset, int _lineNr) {
      explain "Convert pattern to ASCII text. No actual font rendering is done here";

      // (todo) first step after song end is rendered twice when scrolling down line-per-line (instead of pageup/down)

      // trace "xxx renderPatPosition: ui_song_offset="+current_song.ui_song_offset+" pv_pat_offset="+parent_node.pv_pat_offset+" _offset="+_offset;
      // trace "xxx renderPatPosition: offset="+_offset+" _lineNr="+_lineNr;

      parent_node.setEditOffset(_offset);

      NodeTracker otherNode <= parent_node.nodeFindOtherQuickJumpNode();
      int editOff = parent_node.getEditOffset();
      if(otherNode instanceof NodeTracker)
      {
         byte ghostPatNr = otherNode.nodeGetCurrentPlayPatternNr();

         if(Node.EMPTY_PAT_NR != ghostPatNr)
         {
            int otherOff = calcOtherGhostOff(otherNode, (-1 == _lineNr) );
            int ghostEditOff;

            if(replay.b_playing)
            {
               int editorStartSongOff = parent_node.nodeGetLastPatternStartEditorSongOffset();
               int ghostRelOff = otherNode.ghost_jam_current_ticks_song_offset - editorStartSongOff;
               int otherTicks;
               if(-1 == otherNode.jam_current_ticks)
                  otherTicks = otherNode.jam_offset * otherNode.jam_tick_multiplier;  // pattern restart queued
               else
                  otherTicks = otherNode.jam_current_ticks;
               otherTicks -= ghostRelOff +1;
               otherTicks = ( otherTicks / step_resolution) * step_resolution;
               ghostEditOff = editOff + otherTicks;
            }
            else
            {
               ghostEditOff = editOff + otherOff;
            }

            // ghost track(s)
            renderPatPosition2(otherNode,   editOff, ghostEditOff, _lineNr, true/*bAllowEmpty*/,  true/*bFirst*/);
            renderPatPosition2(parent_node, editOff, editOff,      _lineNr, false/*bAllowEmpty*/, false/*bFirst*/);

            if(-1 == _lineNr)
               last_ghost_pattern_nr = ghostPatNr;
         }
         else
         {
            renderPatPosition2(parent_node, editOff, editOff, _lineNr, true/*bAllowEmpty*/,  true/*bFirst*/);
         }
      }
      else
      {
         renderPatPosition2(parent_node, editOff, editOff, _lineNr, true/*bAllowEmpty*/,  true/*bFirst*/);
      }

      handleEnvelopeViewPositionChanged();
   }

   // <ui_render.png>
   public /*=replay=*/ method renderPatPosition2(NodeTracker _node, int _offset, int _offsetEv, int _lineNr, boolean _bAllowEmpty, boolean _bFirst) {
      boolean bGhost = @(_node) != @(parent_node);

      ST_Song song <= current_song;
      NT_Track *track;
      NT_Track *trackEv;
      NT_TrackPattern *pat;
      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();
      NT_MetaPattern mpatEv <= _node.getCurrentEditMetaPattern();
      Envelope *env;
      float val;
      var vVar;
      float v;
      int idx;
      int clength;
      int clengthEv;

      if(null != mpat)
         clength = mpat.num_ticks;
      else
         clength = 0;

      if(null != mpatEv)
      {
         clengthEv = mpatEv.num_ticks;

         if(clengthEv > 0)
         {
            while(_offsetEv >= clengthEv)
               _offsetEv -= clengthEv;

            while(_offsetEv < 0)
               _offsetEv += clengthEv;
         }
      }
      else
      {
         clengthEv = 0;
      }

      int coffset;
      int coffsetEv;
      int patOffset;
      int patOffsetEv;
      String line;
      int trackNr;

      int lineNr = 0;
      Integer io;
      IntArray cols;
      _offset -= center_row * step_resolution;
      _offsetEv -= center_row * step_resolution;
      boolean bRenderLine;
      int colNr;
      String shex;

      int numTicksPerNote = current_song.ppq * 4;
      float numTicksPerBeat = (numTicksPerNote / float(current_song.sig_notelen));
      float numTicksPerBar = numTicksPerBeat * current_song.sig_beats;

      boolean bForceWrapOffset = false;

      int ctlCol32;

      boolean bTimingView = parent_node.b_ui_timing_view;

      loop(num_rows)
      {
         int stripeNr = stripes[lineNr];

         colNr = 0;

         bRenderLine = (-1 == _lineNr);
         if(!bRenderLine)
            bRenderLine = (_lineNr == lineNr);

         if(bRenderLine)
         {
            line <= strings[stripeNr];
            if(_bFirst)
               line.empty();

            cols <= colors[stripeNr];

            IntArray *colors;
            IntArray *colorsGhost;
            IntArray *colorsTiming;
            IntArray *colorsTimingGhost;
            IntArray *colorsEv;

            boolean bWrapOffset = bForceWrapOffset;

            coffset = _offset;
            if(coffset >= clength)
            {
               coffset -= clength;
               _offset = coffset;
               bWrapOffset = true;
               bForceWrapOffset = true;
            }
            else if(coffset < 0)
            {
               coffset += clength;
               bWrapOffset = true;
            }

            coffsetEv = _offsetEv;
            if(coffsetEv >= clengthEv)
            {
               coffsetEv -= clengthEv;
               _offsetEv = coffsetEv;
            }
            else if(coffsetEv < 0)
            {
               coffsetEv += clengthEv;
               _offsetEv = coffsetEv;
            }

            // Add song offset (ticks) column
            io.value = coffset + parent_node.nodeGetLastPatternStartEditorSongOffset();

            if(_bFirst)
            {
               if(coffset >= 0)
               {
                  Integer ioBar   = 1 + int(io / numTicksPerBar);
                  if(ioBar > 999)
                     ioBar = 999;
                  Integer ioBeat  = 1 + (int(io / numTicksPerBeat) % current_song.sig_beats);
                  Integer ioTick  = 1 + int((10*io) % (10*numTicksPerBeat)) / 10;

                  shex = ioBar.printf("%03d-") + ioBeat.printf("%02d-") + ioTick.printf("%03d ");
                  line.append(shex);
               }
               else
               {
                  line.append("           ");
               }
            }

            // Determine palette
            if(bWrapOffset)
            {
               colors            <= app_lnf.nt_pv_colors_wrapped;
               colorsGhost       <= app_lnf.nt_pv_colors_wrapped_ghost;
               colorsTiming      <= app_lnf.nt_pv_colors_wrapped_timing;
               colorsTimingGhost <= app_lnf.nt_pv_colors_wrapped_timing_ghost;
            }
            else
            {
               colors            <= app_lnf.nt_pv_colors_normal;
               colorsGhost       <= app_lnf.nt_pv_colors_normal_ghost;
               colorsTiming      <= app_lnf.nt_pv_colors_normal_timing;
               colorsTimingGhost <= app_lnf.nt_pv_colors_normal_timing_ghost;
            }

            if(bTimingView)
               colorsEv <= bGhost ? colorsTimingGhost : colorsTiming;
            else
               colorsEv <= bGhost ? colorsGhost : colors;

            cols[colNr++] = colors[0]; // songpos
            cols[colNr++] = colors[0];
            cols[colNr++] = colors[0];
            cols[colNr++] = colors[0];
            cols[colNr++] = colors[0];

            cols[colNr++] = colors[0]; // extended songpos bar-beat-ticks
            cols[colNr++] = colors[0]; // extended songpos bar-beat-ticks
            cols[colNr++] = colors[0]; // extended songpos bar-beat-ticks
            cols[colNr++] = colors[0]; // extended songpos bar-beat-ticks
            cols[colNr++] = colors[0]; // extended songpos bar-beat-ticks

            cols[colNr++] = colors[0]; // space

            boolean bAddSpace = false;
            trackNr = parent_node.pv_track_shift;
            int numVisTracks = (parent_node.tracks.numElements) - parent_node.pv_track_shift;

            loop(numVisTracks)
            {
               if(bAddSpace)
               {
                  if(_bFirst)
                  {
                     line.append(" ");
                     cols[colNr++] = colors[0];
                  }
                  else
                     colNr++;
               }
               else
               {
                  bAddSpace = true;
               }

               track <= parent_node.tracks[trackNr];
               trackEv <= _node.tracks.get(trackNr++);
               NT_TEL tel <= track.getTrackLayout();

               if(null != trackEv)
                  pat <= trackEv.getCurrentEditPattern();
               else
                  pat <= null;
               patOffset = coffset;
               patOffsetEv = coffsetEv;

               // Append pattern step column
               io.value = (patOffset / step_resolution) & 4095/*0xFFF*/;

               Integer ioPatOff;
               if(STConfig.b_node_tracker_shift_patternoffset)
               {
                  ioPatOff = io + 1;
               }
               else
               {
                  ioPatOff = io;
               }

               if(_bFirst)
               {
                  if(STConfig.b_node_tracker_decimal_patternoffset)
                  {
                     ioPatOff.printf("%03d") => shex;
                  }
                  else
                  {
                     ioPatOff.printf("%03x") => shex;
                  }

                  line.append(shex);
               }

               cols[colNr++] = colors[1];
               cols[colNr++] = colors[1];
               cols[colNr++] = colors[1];

               if(_bFirst)
               {
                  if(null != mpat)
                  {
                     if( (mpat.ui_pattern_replay_start_offset / step_resolution) == io )
                     {
                        line.append("*");
                     }
                     else
                     {
                        line.append(" ");
                     }
                  }
                  else
                  {
                     line.append(" ");
                  }
               }
               cols[colNr++] = colors[6];

               NT_CEL *cel;

               if(null != mpat)
               {
                  int celId = 0;
                  env <= null;

                  boolean bCtlColHdr = false;
                  StringArray *aStr;

                  // Append currently visible controllers
                  int numCels = tel.ctl_layouts.numElements;
                  int celNr = 0;
                  loop(numCels)
                  {
                     cel <= tel.ctl_layouts[celId];

                     if(cel.b_visible)
                     {
                        if(null != pat)
                           env <= pat.getEnvelope(cel.ctl_id);
                        if(null != env)
                        {
                           vVar = env.valueAtTimeRaster(patOffsetEv, step_resolution); // Relative pattern time
                        }
                        else
                        {
                           vVar = void;
                        }
                        int celStyle = cel.style;
                        boolean bFloat = (typeid(vVar) == YAC_TYPE_FLOAT); // Is there an event at this position ?
                        String *sVal;
                        if(bFloat)
                        {
                           v = vVar;

                           // Found event

                           if(NT_CEL.STYLE_NOTE == celStyle)
                           {
                              if(v >= 0)
                              {
                                 // Note-on
                                 if(v < 128)
                                 {
                                    sVal <= midi_notes[v];
                                 }
                                 else
                                 {
                                    // Cannot be displayed with this style
                                    sVal <= "???";
                                 }
                                 if(_bFirst)
                                    line.append(sVal);
                                 else
                                    line.replaceRegion(colNr, colNr+3, sVal);

                                 if(celNr & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                              {
                                 // Note-off
                                 if(v > -128)
                                 {
                                    sVal <= midi_notes[-v];
                                 }
                                 else if(NT_TrackPattern.MAGIC_NOTE_ALLTRACKNOTESOFF == v) // -128
                                 {
                                    sVal <= "==="; // All track notes off
                                 }
                                 else if(NT_TrackPattern.MAGIC_NOTE_ALLCHANNELNOTESOFF == v) // -129
                                 {
                                    sVal <= "###"; // All generator notes off
                                 }
                                 else
                                 {
                                    // Cannot be displayed with this style
                                    sVal <= "???";
                                 }
                                 if(_bFirst)
                                    line.append(sVal);
                                 else
                                    line.replaceRegion(colNr, colNr+3, sVal);

                                 if(celId & 1)
                                 {
                                    cols[colNr++] = colorsEv[5];
                                    cols[colNr++] = colorsEv[5];
                                    cols[colNr++] = colorsEv[5];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[4];
                                    cols[colNr++] = colorsEv[4];
                                    cols[colNr++] = colorsEv[4];
                                 }
                              }
                           }
                           else if(NT_CEL.STYLE_LETTER == celStyle)
                           {
                              if(0 <= v < 62)
                              {
                                 if(_bFirst)
                                    line.append(instr_letters[v]);
                                 else
                                    line.replaceRegion(colNr, colNr + 1, instr_letters[v]);
                              }
                              else
                              {
                                 // Cannot be displayed with this style
                                 if(_bFirst)
                                    line.append("?");
                                 else
                                    line.replaceRegion(colNr, colNr + 1, "?");
                              }
                              if(celNr & 1)
                                 cols[colNr++] = colorsEv[3];
                              else
                                 cols[colNr++] = colorsEv[2];
                           }
                           else if(NT_CEL.STYLE_HEX == celStyle)
                           {
                              if(0 <= v < 256)
                              {
                                 sVal <= hex_ff[v];
                              }
                              else if(NT_TrackPattern.CTL_DUR1 <= cel.ctl_id <= NT_TrackPattern.CTL_DUR5)
                              {
                                 // Duration exceeds displayable value
                                 sVal <= ">>";
                              }
                              else
                              {
                                 // Cannot be displayed with this style
                                 sVal <= "??";
                              }

                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+2, sVal);

                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_BAR4 == celStyle)
                           {
                              aStr <= bar_strings[0][cel.range];
                              sVal <= aStr.get(int(v));
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+4, sVal);
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_BAR8 == celStyle)
                           {
                              aStr <= bar_strings[1][cel.range];
                              sVal <= aStr.get(int(v));
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+8, sVal);
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_BAR16 == celStyle)
                           {
                              aStr <= bar_strings[2][cel.range];
                              sVal <= aStr.get(int(v));
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+16, sVal);
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_BAR32 == celStyle)
                           {
                              aStr <= bar_strings[3][cel.range];
                              sVal <= aStr.get(int(v));
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+32, sVal);
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_PATNR3 == celStyle)
                           {
                              if(int(v) > 127)
                              {
                                 sVal <= "--/";
                              }
                              else
                              {
                                 sVal <= patnr3_strings[int(v) & 127];
                              }
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+3, sVal);

                              if(celId & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_PATNR2 == celStyle)
                           {
                              if(int(v) > 127)
                              {
                                 sVal <= "-/";
                              }
                              else
                              {
                                 sVal <= patnr2_strings[int(v) & 127];
                              }
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+2, sVal);

                              if(celId & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_COLOR == celStyle)
                           {
                              if(bWrapOffset)
                              {
                                 ctlCol32 = ctlcolor_palette_wrapped.get(
                                    int(v) % (ctlcolor_palette_wrapped.numElements)
                                                                         );
                              }
                              else
                              {
                                 ctlCol32 = STConfig.node_tracker_ctlcolor_palette.get(
                                    int(v) % (STConfig.node_tracker_ctlcolor_palette.numElements)
                                                                                            );
                              }

                              if(_bFirst)
                              {
                                 loop(3)
                                 {
                                    line.append(tcchar(0xD3));
                                    cols[colNr++] = ctlCol32;
                                 }
                                 if(bCtlColHdr)
                                 {
                                    line.append(tcchar(0xD3));
                                 }
                                 else
                                 {
                                    line.append(tcchar(0xD2));
                                 }
                              }
                              else
                              {
                                 loop(3)
                                 {
                                    line.replaceRegion(colNr, colNr+1, tcchar(0xD3));
                                    cols[colNr++] = ctlCol32;
                                 }
                                 if(bCtlColHdr)
                                 {
                                    line.replaceRegion(colNr, colNr+1, tcchar(0xD3));
                                 }
                                 else
                                 {
                                    line.replaceRegion(colNr, colNr+1, tcchar(0xD2));
                                 }
                              }

                              cols[colNr++] = ctlCol32;
                           }
                           else if(NT_CEL.STYLE_HI_NIBBLE == celStyle)
                           {
                              if(0 <= v < 256)
                              {
                                 sVal <= instr_letters[int(v) >> 4];
                              }
                              else
                              {
                                 // Cannot be displayed with this style
                                 sVal <= "?";
                              }
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+1, sVal);
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                           else if(NT_CEL.STYLE_LO_NIBBLE == celStyle)
                           {
                              if(0 <= v < 256)
                              {
                                 sVal <= instr_letters[int(v) & 15];
                              }
                              else
                              {
                                 // Cannot be displayed with this style
                                 sVal <= "?";
                              }
                              if(_bFirst)
                                 line.append(sVal);
                              else
                                 line.replaceRegion(colNr, colNr+1, sVal);
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                              }
                           }
                        }
                        else  // if(bFloat)
                        {
                           // No event at this position

                           if(NT_CEL.STYLE_NOTE == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 if(parent_node.b_ui_timing_view)
                                 {
                                    line.append(tcchar(0xD4));
                                    line.append(tcchar(0xD5));
                                    line.append(tcchar(0xD6));
                                 }
                                 else
                                 {
                                    line.append("---");
                                 }
                                 if(celId & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 3;
                           }
                           else if(NT_CEL.STYLE_LETTER == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 if(parent_node.b_ui_timing_view)
                                    line.append(tcchar(0xD7));
                                 else
                                    line.append(".");

                                 if(celNr & 1)
                                    cols[colNr++] = colorsEv[3];
                                 else
                                    cols[colNr++] = colorsEv[2];
                              }
                              else
                                 colNr++;
                           }
                           else if(NT_CEL.STYLE_HEX == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 if(parent_node.b_ui_timing_view)
                                 {
                                    line.append(tcchar(0xD4));
                                    line.append(tcchar(0xD6));
                                 }
                                 else
                                 {
                                    line.append("..");
                                 }

                                 if(celNr & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 2;
                           }
                           else if(NT_CEL.STYLE_BAR4 == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 line.append("."+tcchar(0x80)+tcchar(0x80)+".");
                                 if(celNr & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 4;
                           }
                           else if(NT_CEL.STYLE_BAR8 == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 line.append(tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80));
                                 if(celNr & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 8;
                           }
                           else if(NT_CEL.STYLE_BAR16 == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 //line.append("................");
                                 line.append(tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80));
                                 if(celNr & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 16;
                           }
                           else if(NT_CEL.STYLE_BAR32 == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 //line.append("................");
                                 line.append(tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80)+tcchar(0x80));
                                 if(celNr & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 32;
                           }
                           else if(NT_CEL.STYLE_PATNR3 == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 if(parent_node.b_ui_timing_view)
                                 {
                                    line.append(tcchar(0xD4));
                                    line.append(tcchar(0xD5));
                                    line.append(tcchar(0xD6));
                                 }
                                 else
                                 {
                                    line.append("...");
                                 }

                                 if(celId & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 3;
                           }
                           else if(NT_CEL.STYLE_PATNR2 == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 if(parent_node.b_ui_timing_view)
                                 {
                                    line.append(tcchar(0xD4));
                                    line.append(tcchar(0xD6));
                                 }
                                 else
                                 {
                                    line.append("..");
                                 }

                                 if(celId & 1)
                                 {
                                    cols[colNr++] = colorsEv[3];
                                    cols[colNr++] = colorsEv[3];
                                 }
                                 else
                                 {
                                    cols[colNr++] = colorsEv[2];
                                    cols[colNr++] = colorsEv[2];
                                 }
                              }
                              else
                                 colNr += 2;
                           }
                           else if(NT_CEL.STYLE_COLOR == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 loop(4)
                                 {
                                    line.append(tcchar(0xD2));
                                    cols[colNr++] = #FF000000;
                                 }
                              }
                              else
                                 colNr += 4;
                           }
                           else if(NT_CEL.STYLE_HI_NIBBLE == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 if(parent_node.b_ui_timing_view)
                                    line.append(tcchar(0xD7));
                                 else
                                    line.append(".");

                                 if(celNr & 1)
                                    cols[colNr++] = colorsEv[3];
                                 else
                                    cols[colNr++] = colorsEv[2];
                              }
                              else
                                 colNr++;
                           }
                           else if(NT_CEL.STYLE_LO_NIBBLE == celStyle)
                           {
                              if(_bAllowEmpty)
                              {
                                 if(parent_node.b_ui_timing_view)
                                    line.append(tcchar(0xD7));
                                 else
                                    line.append(".");

                                 if(celNr & 1)
                                    cols[colNr++] = colorsEv[3];
                                 else
                                    cols[colNr++] = colorsEv[2];
                              }
                              else
                                 colNr++;
                           }
                        }

                        celNr++;
                     } // if cel visible

                     celId++;

                  } // foreach cel

               } // pat!=null
               else
               {
                  // (note) due to recent changes (Feb'2015), this will probably not be reached anymore

                  // Pattern does not exist, append place holders ("???")
                  celId = 0;
                  numCels = tel.ctl_layouts.numElements;
                  ////foreach cel in tel.ctl_layouts
                  loop(numCels)
                  {
                     cel <= tel.ctl_layouts[celId++];

                     if(cel.b_visible)
                     {
                        switch(cel.style)
                        {
                           default:
                           case NT_CEL.STYLE_NOTE:
                              line.append("???");
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_LETTER:
                              line.append("?");
                              if(celNr & 1)
                                 cols[colNr++] = colorsEv[3];
                              else
                                 cols[colNr++] = colorsEv[2];
                              break;

                           case NT_CEL.STYLE_HEX:
                              line.append("??");
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_BAR4:
                              line.append("????");
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_BAR8:
                              line.append("????????");
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_BAR16:
                              line.append("????????????????");
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_BAR32:
                              line.append("????????????????????????????????");
                              if(celNr & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_PATNR3:
                              line.append("???");

                              if(celId & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_PATNR2:
                              line.append("??");

                              if(celId & 1)
                              {
                                 cols[colNr++] = colorsEv[3];
                                 cols[colNr++] = colorsEv[3];
                              }
                              else
                              {
                                 cols[colNr++] = colorsEv[2];
                                 cols[colNr++] = colorsEv[2];
                              }
                              break;

                           case NT_CEL.STYLE_COLOR:
                              line.append("????");
                              loop(4)
                                 cols[colNr++] = #FF000000;
                              break;

                           case NT_CEL.STYLE_HI_NIBBLE:
                              line.append("?");
                              if(celNr & 1)
                                 cols[colNr++] = colorsEv[3];
                              else
                                 cols[colNr++] = colorsEv[2];
                              break;

                           case NT_CEL.STYLE_LO_NIBBLE:
                              line.append("?");
                              if(celNr & 1)
                                 cols[colNr++] = colorsEv[3];
                              else
                                 cols[colNr++] = colorsEv[2];
                              break;
                        }
                     }
                  } // foreach cel
               } // else null!=pat

            } // loop tracks

         } // if bRenderLine

         // Proceed to next step
         _offset += step_resolution;
         if(_offset >= clength)
         {
            _offset = 0;
            bForceWrapOffset = true;
         }

         _offsetEv += step_resolution;
         if(_offsetEv >= clengthEv)
            _offsetEv = 0;

         lineNr++;
      } // loop rows

      if(-1 == _lineNr)
         redrawAllRows();
   }

   // <method_set.png>
   protected method resetCursor() {
      setCurrentTrackNr(0);
      setCursorX(0);
      parent_node.pv_track_shift = 0;
   }

   // <method_set.png>
   public method setCursorX(int _x) {
      // (note) _x should already be clipped to maximum column index
      NT_Track track <= getCurrentTrack();
      if(null != track)
         track.cursor_x = _x;

      cursor_x = _x;
      parent_node.pv_cursor_x = _x;

      handleEnvelopeViewPositionChanged();
      parent_editor.queueUpdateBidirectionalControls();
   }

   // <method_handle.png>
   public =replay= method cursorTrackChanged() {
      explain "Called whenever cursor_track has changed (to its final value).";

      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         // Restore KeyJazz settings
         if(parent_editor.isPatternViewActive()) // (note) don't set instrument when in InstrumentView
         {
            parent_editor.keyJazzSelectInstrument(track.keyjazz_instr_nr, true/*bMakeVisible*/, true/*bQuiet*/);
            parent_editor.keyJazzSetNoteOnVelocity(track.keyjazz_on_velocity, true/*bQuiet*/);
            parent_editor.keyJazzSetNoteOffVelocity(track.keyjazz_off_velocity, true/*bQuiet*/);
            parent_editor.keyJazzSetDuration(track.keyjazz_duration, true/*bQuiet*/);
            parent_editor.keyJazzSetOctave(track.keyjazz_octave, true/*bQuiet*/);
            parent_editor.updateKeyJazzWidgets();
         }

         track.hltrackname_countdown = 1.0;

         NT_TEL tel <= track.getTrackLayout();
         tel.calcCursorExtents();
      }

      handleEnvelopeViewPositionChanged();
   }

   // <method_get.png>
   protected method getSizeXOfVisibleTracks(int visTracks) : boolean {
      float trackPx = 0;

      int trackNr = parent_node.pv_track_shift;
      trackPx = NUM_SONGPOS_COLS * char_width;

      int lastVisTrackNr = parent_node.pv_track_shift + visTracks ;

      while(trackNr < lastVisTrackNr) // (note) <= makes the track following current_track visible as well (if possible) (config-option?)
      {
         NT_Track track <= parent_node.getTrack(trackNr);
         if(null != track)
         {
            NT_TEL tel <= track.getTrackLayout();
            trackPx += tel.total_char_width * char_width;
         }

         // Next track
         trackNr++;
      }

      return trackPx;
   }

   // <method_get.png>
   protected method areAllCelsOfLastVisibleTrackVisible(int visTracks) : boolean {
      int trackPx = getSizeXOfVisibleTracks(visTracks);
      return (trackPx <= getSizeX());
   }

   // <method.png>
   protected method tryDecreaseTrackShift() {
      boolean bTryNext;
      do
      {
         bTryNext = false;

         int visTracks = getNumVisibleTracks();

         if(parent_node.pv_track_shift > 0)
         {
            int trackPx = getSizeXOfVisibleTracks(visTracks);

            if(trackPx < getSizeX())
            {
               NT_Track track <= getTrack(parent_node.pv_track_shift - 1);
               NT_TEL tel <= track.getTrackLayout();

               if( (tel.total_char_width*char_width) <= (size_x - trackPx) )
               {
                  parent_node.pv_track_shift--;
                  bTryNext = true;
               }
            }
         }
      }
      while(bTryNext);
   }

   // <method.png>
   protected method clipCursorTrack(int visTracks) {
      int cursorTrack = getCurrentTrackNr();
      if(cursorTrack < parent_node.pv_track_shift)
      {
         parent_node.pv_track_shift = cursorTrack;
      }
      else if( (parent_node.pv_track_shift + visTracks) <= cursorTrack )
      {
         parent_node.pv_track_shift = cursorTrack - visTracks + 1;
      }
   }

   // <method.png>
   public method verifyTrackShift(boolean _bAlignRight) {

      // trace "--------------------------------\nxxx verifyTrackShift cursor_track="+getCurrentTrackNr()+" cursor_x="+cursor_x+" editOffset="+getEditOffset();

      if(parent_node.tracks.numElements)
      {
         int visTracks = getNumVisibleTracks();
         int oldTrackShift = parent_node.pv_track_shift;

         // trace "xxx OLD cursor_track="+getCurrentTrackNr()+" track_shift="+parent_node.pv_track_shift+" #vis="+visTracks;

         clipCursorTrack(visTracks);

         // trace "xxx NEW cursor_track="+getCurrentTrackNr()+" track_shift="+parent_node.pv_track_shift+" #vis="+getNumVisibleTracks();

         // Check again if all tracks fit on screen
         visTracks = getNumVisibleTracks();

         clipCursorTrack(visTracks);

         if( (parent_node.pv_track_shift+visTracks-1) == getCurrentTrackNr() )
         {
            // trace "xxx checkAllCelsVisible: track_shift="+parent_node.pv_track_shift+" visTracks="+visTracks+ " size_x="+size_x;

            // Check whether all cels of 'border' track are visible
            if(!areAllCelsOfLastVisibleTrackVisible(visTracks))
            {
               parent_node.pv_track_shift = getCurrentTrackNr() - visTracks +2;

               // Handle case where only one track (many cels) fits on screen
               visTracks = getNumVisibleTracks();

               if(parent_node.pv_track_shift > getCurrentTrackNr())
               {
                  parent_node.pv_track_shift = getCurrentTrackNr();
               }
               else if( (parent_node.pv_track_shift + visTracks) <= getCurrentTrackNr() )
               {
                  parent_node.pv_track_shift = getCurrentTrackNr();
               }

               if( (parent_node.pv_track_shift+visTracks-1) == getCurrentTrackNr() )
               {
                  if(!areAllCelsOfLastVisibleTrackVisible(visTracks))
                  {
                     parent_node.pv_track_shift = getCurrentTrackNr();
                  }
               }
            }
         }
         else
         {
            clipCursorTrack(visTracks);
         }

         // Check whether track_shift can be decreased
         if(_bAlignRight)
            tryDecreaseTrackShift();

         if(oldTrackShift != parent_node.pv_track_shift)
         {
            renderPattern();
            ta_redraw_all.scheduleShort();
         }

         // // trace "xxx verifyTrackShift END cursor_x="+cursor_x+" editOffset="+getEditOffset();

         parent_editor.autoEnableAndConfigureTracksScroller();
         return;
      }

      parent_node.pv_track_shift  = 0;
      setCurrentTrackNr(0);
      setCursorX(0);

      ta_redraw_all.scheduleShort();

      ////trace "track_shift="+parent_node.pv_track_shift+" cursor_track="+getCurrentTrackNr()+" visTrack="+visTracks;

      parent_editor.autoEnableAndConfigureTracksScroller();
   }

   // <ui_cursor.png>
   public method moveCursorToStart() {
      parent_node.setEditOffset(0);
      redrawAllRows();
      renderPatPosition(0, -1);

      if(!replay.b_playing && (replay.ticks_to_play <= 0))
      {
         current_song.seek(parent_node.getSongEditOffset());
      }
   }

   // <ui_cursor.png>
   public method moveCursorToEnd() {
      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();
      if(null != mpat)
      {
         if(mpat.num_ticks >= step_resolution)
         {
            int off = parent_node.getAlignedPatOffset(mpat.num_ticks - step_resolution);
            parent_node.setEditOffset(off);

            if(!replay.b_playing && (replay.ticks_to_play <= 0))
            {
               current_song.seek(parent_node.getSongEditOffset());
            }

            redrawAllRows();
            renderPatPosition(off, -1);
         }
      }
   }

   // <ui_cursor.png>
   public method moveCursorToStartOfPreviousTrack() {
      // Called by cmd_track_delete
      setCursorX(0);
      moveCursorToFirstColumnOrPreviousTrack();
   }

   // <ui_cursor.png>
   public method moveCursorToLastColumnOrNextTrack() {
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         if(cursor_x != (tel.num_cursor_positions-1))
         {
            setCursorX(tel.num_cursor_positions - 1);
            printCursorStatusInfo();
            redraw();
         }
         else
         {
            moveCursorToStartOfNextTrack();
         }
      }
   }

   // <ui_cursor.png>
   public method moveCursorToFirstColumnOrPreviousTrack() {
      if(cursor_x > 0)
      {
         moveCursorToFirstColumn();
      }
      else
      {
         int cursorTrack = getCurrentTrackNr();
         cursorTrack--;
         if(cursorTrack <0)
         {
            cursorTrack = (parent_node.tracks.numElements)-1;
            if(cursorTrack < 0) // no tracks
            {
               setCurrentTrackNr(0);
               parent_node.pv_track_shift = 0;
               return;
            }
         }
         setCurrentTrackNr(cursorTrack);
         cursorTrackChanged();
         verifyTrackShift(false);
         NT_TEL tel <= getCurrentTrackLayout();
         setCursorX(tel.num_cursor_positions - 1);
         printCursorStatusInfo();
         redraw();
      }
   }

   // <ui_cursor.png>
   public method moveCursorToStartOfNextTrack() {
      int cursorTrack = getCurrentTrackNr();
      cursorTrack++;
      if(cursorTrack >= (parent_node.tracks.numElements))
         cursorTrack = 0;

      setCurrentTrackNr(cursorTrack);
      setCursorX(0);
      cursorTrackChanged();
      verifyTrackShift(false);
      printCursorStatusInfo();
      redraw();
   }

   // <ui_cursor.png>
   public method moveCursorToTrack(int _trackNr) {
      // Used by OrderListView

      if(0 <= _trackNr < (parent_node.tracks.numElements))
      {
         if(_trackNr < getCurrentTrackNr())
         {
            while(getCurrentTrackNr() != _trackNr)
               moveCursorToPreviousTrackX(false/*bAlignRight*/);
         }
         else
         {
            while(getCurrentTrackNr() != _trackNr)
               moveCursorToNextTrackX();
         }
      }
   }

   // <ui_cursor.png>
   public method moveCursorToNextTrackX() {
      int cursorTrack = getCurrentTrackNr();
      cursorTrack++;
      if(cursorTrack >= (parent_node.tracks.numElements))
         cursorTrack = 0;

      setCurrentTrackNr(cursorTrack);

      // Restore cursor X position
      NT_Track track <= (parent_node.tracks.get(getCurrentTrackNr()));
      if(null != track)
         setCursorX(track.cursor_x);

      cursorTrackChanged();
      verifyTrackShift(true);
      printCursorStatusInfo();
      redraw();
   }

   // <ui_cursor.png>
   public method moveCursorToPreviousTrackX(boolean _bAlignRight) {
      int cursorTrack = getCurrentTrackNr();
      cursorTrack--;
      if(cursorTrack < 0)
         cursorTrack = (parent_node.tracks.numElements) - 1;

      setCurrentTrackNr(cursorTrack);

      // Restore cursor X position
      NT_Track track <= (parent_node.tracks.get(getCurrentTrackNr()));
      if(null != track)
         setCursorX(track.cursor_x);

      cursorTrackChanged();
      verifyTrackShift(_bAlignRight);
      printCursorStatusInfo();
      redraw();
   }

   // <ui_cursor.png>
   public method moveCursorToNextTrackXClip() {
      int numTracks = getNumTracks();
      if(numTracks > 0)
      {
         if( getCurrentTrackNr() != (numTracks - 1) )
            moveCursorToNextTrackX();
      }
   }

   // <ui_cursor.png>
   public method moveCursorToPreviousTrackXClip(boolean _bAlignRight) {
      if(getCurrentTrackNr() > 0)
      {
         moveCursorToPreviousTrackX(_bAlignRight);
      }
   }

   // <ui_cursor.png>
   public method moveCursorLeft() : boolean {
      // trace "xxx moveCursorLeft cursor_x="+cursor_x+" editOffset="+getEditOffset();

      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         if(cursor_x > 0)
         {
            setCursorX(cursor_x - 1);
         }
         else
         {
            int cursorTrack = getCurrentTrackNr();
            if(--cursorTrack < 0)
               cursorTrack = (parent_node.tracks.numElements)-1;

            setCurrentTrackNr(cursorTrack);

            tel <= getCurrentTrackLayout();
            if(null != tel)
            {
               cursorTrackChanged();
               verifyTrackShift(false);
               setCursorX(tel.num_cursor_positions - 1);
            }
         }

         printCursorStatusInfo();
         redraw();

         if(STConfig.b_node_tracker_highlight_cursormovex)
         {
            highlightCursorMove();
         }
      }
      else
      {
         trace "[---] PatternView::moveCursorLeft: tel==null";
      }
      return true;
   }

   // <ui_cursor.png>
   public method moveCursorRight() : boolean {
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         if((cursor_x + 1) < tel.num_cursor_positions)
         {
            setCursorX(cursor_x + 1);
         }
         else
         {
            int cursorTrack = getCurrentTrackNr();
            cursorTrack++;
            if(cursorTrack >= (parent_node.tracks.numElements))
               cursorTrack = 0;

            setCurrentTrackNr(cursorTrack);
            setCursorX(0);
            cursorTrackChanged();
            verifyTrackShift(true);
         }

         printCursorStatusInfo();
         redraw();

         if(STConfig.b_node_tracker_highlight_cursormovex)
         {
            highlightCursorMove();
         }
      }
      return true;
   }

   // <ui_cursor.png>
   public method moveCursorToFirstColumn() {
      setCursorX(0);
      printCursorStatusInfo();
      redraw();
   }

   // <ui_cursor.png>
   public method moveCursorToColumn(int _col) {
      setCursorX(_col);
      printCursorStatusInfo();
      redraw();
   }

   // <ui_cursor.png>
   public method moveCursorToPreviousColumnGroup() {
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         int i = cursor_x;
         int k;
         int ctlMapId = tel.cursor_to_ctl_map[cursor_x] & NT_TEL.CTLID_MASK;
         k = ctlMapId;

         while(ctlMapId == k)
         {
            if(--i < 0)
               i = tel.num_cursor_positions - 1;

            k = tel.cursor_to_ctl_map[i] & NT_TEL.CTLID_MASK;
         }

         int celStyle = tel.ctl_layouts[k].style;

         if((celStyle == NT_CEL.STYLE_HEX) || (celStyle == NT_CEL.STYLE_PATNR2))
         {
            i--; // Move to MSB column
         }
         else if(celStyle == NT_CEL.STYLE_PATNR3)
         {
            i -= 2; // Move to first cel column
         }

         setCursorX(i);
         printCursorStatusInfo();
         redraw();
      }
   }

   // <ui_cursor.png>
   public method moveCursorToNextColumnGroup() {
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         int i = cursor_x;
         int k;
         int ctlMapId = tel.cursor_to_ctl_map[cursor_x] & NT_TEL.CTLID_MASK;
         k = ctlMapId;
         while(ctlMapId == k)
         {
            if(++i >= tel.num_cursor_positions)
               i = 0;

            k = tel.cursor_to_ctl_map[i] & NT_TEL.CTLID_MASK;
         }
         setCursorX(i);
         printCursorStatusInfo();
         redraw();
      }
   }

   // <ui_cursor.png>
   public method moveCursorToColumnGroupDelta(int _delta) {
      if(_delta > 0)
      {
         loop(_delta)
           moveCursorToNextColumnGroup();
      }
      else if(_delta < 0)
      {
         loop(-_delta)
           moveCursorToPreviousColumnGroup();
      }
   }

   // <ui_cursor.png>
   public method moveCursorToCel(int _celId) {
      // (note) ctl must be visible
      // (note) called from NT_EditTrackLayoutDialog when column (group) is selected
      // trace "[dbg] NT_PatternView::moveCursorToCel celId="+_celId;
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         int i = 0;
         for(;;)
         {
            if(i >= tel.num_cursor_positions)
            {
               // should not be reached
               return;
            }
            int ctlMapId = tel.cursor_to_ctl_map[i] & NT_TEL.CTLID_MASK;
            if(ctlMapId == _celId)
               break;
            else
               i++;
         }
         setCursorX(i);
         printCursorStatusInfo();
         redraw();
      }
   }

   // <ui_cursor.png>
   public method validateCursorX() {
      // called after track layout has changed
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         ////trace "xxx validateCursorX: cursor_x="+cursor_x+" tel.num_cursor_positions="+tel.num_cursor_positions;
         if(cursor_x >= tel.num_cursor_positions)
            setCursorX(tel.num_cursor_positions - 1);
      }
   }

   // <ui_cursor.png>
   protected method startCaretTimer() {
      redraw();
   }

   // <method.png>
   protected =replay= method importSMF(MIDIFile _smf) {

      if(!replay.b_playing)
      {
         int trackIdx = 0;

         if(isEditable())
         {
            NT_Track track <= getCurrentTrack();
            if(null != track)
            {
               NT_Instrument kjIns <= null;

               if(null != track)
                  kjIns <= parent_node.getInstrument(track.keyjazz_instr_nr);

               int kjDevIdx;
               byte kjMidiCh;

               if(null != kjIns)
               {
                  if(null != kjIns.out_device)
                  {
                     kjDevIdx = kjIns.out_device.dev_idx;
                     kjMidiCh  = kjIns.midi_channel;

                     parent_node.b_rt_record = true;
                     replay.b_playing = true;

                     handleStartPlaying();

                     int origEditOffset = parent_node.getEditOffset();
                     int origSongOffset = current_song.song_offset;
                     int origSongTickNr = current_song.tick_nr;
                     int origPatLen = parent_node.getCurrentEditMetaPatternLength();

                     boolean bOrigRecLatency = STConfig.b_node_tracker_rec_latency;
                     STConfig.b_node_tracker_rec_latency = false;

                     boolean bOrigRecUsrCtlNoteOn = STConfig.b_node_tracker_recordusrctlnoteon;
                     STConfig.b_node_tracker_recordusrctlnoteon = false;

                     int origLockedKeyjazzNodeGID = current_song.locked_keyjazz_node_gid;
                     current_song.locked_keyjazz_node_gid = -1;

                     setPatternLength(current_song.ppq * 2048);

                     int maxLen = 0;

                     loop(_smf.getNumTracks())
                     {
                        MIDIFileTrack smfTrack <= _smf.getTrackByIdx(trackIdx);

                        Integer evAbsTime;

                        if(smfTrack.replayStart(current_song.ppq))
                        {
                           for(;;)
                           {
                              MIDIPipeFrame fr <= smfTrack.replayGetNextEvent(evAbsTime);

                              if(null != fr)
                              {
                                 MIDIPipeFrame frRec = fr;

                                 frRec.setDevIdxAndMidiCh(kjDevIdx, kjMidiCh);

                                 // trace "xxx importSMF: frRec.numEvents="+frRec.numEvents+" numNoteOn="+frRec.numEventsNoteOn+" numNoteOff="+frRec.numEventsNoteOff+" evAbsTime="+evAbsTime;

                                 parent_node.setEditOffset(evAbsTime);
                                 parent_node.tick_nr = evAbsTime;  // for recordMIDICtl()
                                 current_song.tick_nr = evAbsTime;
                                 current_song.song_offset = evAbsTime + parent_node.nodeGetLastPatternStartEditorSongOffset();

                                 parent_node.recordFrame(frRec, false/*bFramePlay*/, true/*bMuted*/, false/*bForceEditable*/, null/*frOut*/);
                                 float bpmChange = fr.getFilteredRPN(0/*devIdx*/, 0/*midich*/, NodeTracker.RPN_TRACKER_INJECT_CTL0+NT_TrackPattern.CTL_BPM);
                                 if(bpmChange > 0)
                                 {
                                    trace "xxx change BPM to "+bpmChange+" evAbsTime="+evAbsTime;
                                    parent_node.insertReplaceTrackEventAt(NT_TrackPattern.CTL_BPM, bpmChange, evAbsTime);
                                 }
                              }
                              else
                              {
                                 int trackLen = smfTrack.replayGetTrackLength();

                                 if(trackLen > maxLen)
                                    maxLen = trackLen;

                                 break;
                              }
                           }
                        }

                        // Next track
                        trackIdx++;
                     }

                     handleStopPlaying(false/*bAllowBookmark*/);

                     parent_node.b_rt_record = false;
                     replay.b_playing = false;

                     parent_node.setEditOffset(origEditOffset);
                     current_song.song_offset = origSongOffset;
                     current_song.tick_nr = origSongTickNr;

                     STConfig.b_node_tracker_rec_latency = bOrigRecLatency;
                     STConfig.b_node_tracker_recordusrctlnoteon = bOrigRecUsrCtlNoteOn;
                     current_song.locked_keyjazz_node_gid = origLockedKeyjazzNodeGID;

                     if(0 != maxLen)
                     {
                        // Align to bar
                        int ticksPerBar = current_song.getNumTicksPerBar();
                        maxLen = ((maxLen + ticksPerBar-1) / ticksPerBar) * ticksPerBar;

                        setPatternLength(maxLen);
                     }
                     else
                     {
                        setPatternLength(origPatLen);
                     }

                     parent_editor.updatePatLen();

                     Global.Success("ImportSMF: recorded "+_smf.getNumTracks()+" track"+Utils.GetPluralString(_smf.getNumTracks())+" (len="+trackLen+" / "+(trackLen / step_resolution)+"s)");
                  }
                  else
                  {
                     Global.Error("ImportSMF: KJ instrument has no MIDI device");
                  }
               }
               else
               {
                  Global.Error("ImportSMF: Please create an instrument first");
               }
            }
            else
            {
               Global.Error("ImportSMF: Please create a track first");
            }
         }
         else
         {
            Global.Warning("ImportSMF: Please enable edit mode first");
         }
      }
      else
      {
         Global.Warning("ImportSMF: Please stop replay first");
      }
   }

   // <load.png>
   public method importSMFFromLocalFile(String _pathName) {
      local MIDIFile smf;

      if(smf.loadLocal(_pathName))
      {
         importSMF(smf);
      }
   }

   // <ui_handler.png>
   public virtual onDropFiles(StringArray _fileNames) : boolean {
      Global.Debug("PatternView::onDropFiles: fileNames="+#(_fileNames));

      if(1 == _fileNames.numElements)
      {
         importSMFFromLocalFile(_fileNames.get(0));
         return true;
      }

      return false;
   }

   // <ui_cursor.png>
   protected method scrollDownNoRedraw(boolean _bIgnoreWrapAround) {

      if(STConfig.b_node_tracker_wraparound && !_bIgnoreWrapAround)
      {
         if(isLastPatStep())
         {
            // Goto first step of current pattern

            parent_node.setEditOffset(0);

            if(!replay.b_playing && (replay.ticks_to_play <= 0))
            {
               current_song.seek(parent_node.getSongEditOffset());
            }

            return true;
         }
      }

      int newOff = parent_node.getClippedPatOffset(parent_node.getEditOffset() + step_resolution);

      if(newOff == (parent_node.getEditOffset() + step_resolution))
      {
         dirty_rows.delete(0);
         dirty_rows.add(true);

         stripes.add(stripes[0]);
         stripes.delete(0);

         renderPatPosition(parent_node.getEditOffset()+step_resolution, num_rows-1);

         if(0 == replay.ticks_to_play)
         {
            if(!replay.b_playing && (replay.ticks_to_play <= 0))
            {
               current_song.seek(parent_node.getSongEditOffset());
            }
         }
      }

      return false;
   }

   // <ui_cursor.png>
   public =replay= method scrollDownEventEntered() {
      if(step_advance >= 0)
      {
         loop(step_advance)
            scrollDownNoRedraw(false/*bIgnoreWrapAround*/);
      }
      else
      {
         gotoNextEvent();
      }

      ta_redraw_all.scheduleShort();
      updateMeshes();
      redraw();
   }

   // <ui_cursor.png>
   public method scrollDown() {

      if(replay.b_playing && parent_node.doAutoScroll())
         return;

      if(scrollDownNoRedraw(false))
         renderAndRedrawAll();

      updateMeshes();
      redraw();

      highlightCursorMove();
      printCursorStatusInfo();
   }

   // <ui_cursor.png>
   public method scrollUp() {

      if(replay.b_playing && parent_node.doAutoScroll())
         return;

      if(STConfig.b_node_tracker_wraparound)
      {
         if(isFirstPatStep())
         {
            int lastOff = parent_node.getCurrentEditMetaPatternLength() - step_resolution;

            if(lastOff >= 0)
            {
               parent_node.setEditOffset(lastOff);
               redrawAllRows();
               renderPatPosition(lastOff, -1);

               if(!replay.b_playing)
                  current_song.seek(parent_node.getSongEditOffset());

               updateMeshes();
               redraw();
               highlightCursorMove();
               printCursorStatusInfo();
            }
            return;
         }
      }

      int editOffset = parent_node.getEditOffset();

      if(editOffset > 0)
      {
         editOffset -= step_resolution;
         if(editOffset < 0)
            editOffset = 0;

         parent_node.setEditOffset(editOffset);

         dirty_rows.insert(0, true);
         dirty_rows.delete(num_rows);

         stripes.insert(0, stripes[num_rows-1]);
         stripes.delete(num_rows);

         renderPatPosition(editOffset, 0);

         updateMeshes();
         redraw();
         highlightCursorMove();
         printCursorStatusInfo();

         if(!replay.b_playing)
            current_song.seek(parent_node.getSongEditOffset());
      }
   }

   // <ui_cursor.png>
   public method pageDown() {
      loop(page_num_steps)
         scrollDown();
   }

   // <ui_show.png>
   public method showHighlightTickModuloDialog() {
      dlg_tickmodulo.run(this, parent_node.ui_highlight_tick_modulo);
   }

   // <ui_handle.png>
   public method highlightTickModuloDialog2(int _ticks) {
      parent_node.ui_highlight_tick_modulo = mathClampi(_ticks, 0, 8192);

      renderAndRedrawAll();

      Global.Print("Tick highlight modulo is "+parent_node.ui_highlight_tick_modulo);
   }

   // <ui_show.png>
   public method showStepAlignmentDialog() {

      dlg_stepalignment <= TextInputDialog.New("Step alignment",
                                               "Enter number of steps",
                                               "Ok",
                                               "Cancel",
                                               parent_node.ui_step_alignment,
                                               3/*maxCols*/, 3,
                                               this/*recipient*/
                                               );

      dlg_stepalignment.showNearMouse(-100, -100);
   }

   // <ui_handle.png>
   public method stepAlignmentDialog2(int _val) {
      if(null != dlg_stepalignment)
      {
         parent_node.ui_step_alignment = mathClampi(_val, 1, 8192);

         Global.Print("Step alignment is "+parent_node.ui_step_alignment);
      }
   }

   // <ui_show.png>
   public method showJumpToStepDialog() {

      int relPatTime = parent_node.getEditOffset();
      int cStep = (relPatTime / step_resolution);

      if(null == dlg_jumptostep)
         dlg_jumptostep <= new NT_JumpToStepDialog;

      if(STConfig.b_node_tracker_shift_patternoffset)
         cStep++;

      dlg_jumptostep.run(this, cStep);
   }

   // <ui_handle.png>
   public method jumpToStep2(int _stepNr) {
      // called from NT_JumpToStepDialog
      if(STConfig.b_node_tracker_shift_patternoffset)
         _stepNr--;
      if(_stepNr < 0)
         _stepNr = 0;

      int ticks = _stepNr * step_resolution;

      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();
      if(null != mpat)
         ticks = ticks % mpat.num_ticks;
      else
         ticks = 0;

      _stepNr = ticks / step_resolution;

      parent_node.setEditOffset(ticks);
      queueRedrawAll();

      if(!replay.b_playing)
         current_song.seek(parent_node.getSongEditOffset());

      local Integer nStep = STConfig.b_node_tracker_shift_patternoffset ? (_stepNr + 1) : _stepNr;
      Global.Print("Jump to step "+_stepNr+" ($"+nStep.printf("%x")+")  ticks="+ticks);
   }

   // <ui_cursor.png>
   public method pageDownAlign() {

      int relPatTime = parent_node.getEditOffset();
      int cStep = (relPatTime / step_resolution);
      int aStep = ((cStep / parent_node.ui_step_alignment) + 1) * parent_node.ui_step_alignment;
      while(cStep < aStep)
      {
         scrollDown();
         cStep++;
      }
   }

   // <ui_cursor.png>
   public method pageDownFast() {
      loop(page_fast_num_steps)
         scrollDown();
   }

   // <ui_cursor.png>
   public method pageUp() {
      loop(page_num_steps)
         scrollUp();
   }

   // <ui_cursor.png>
   public method pageUpAlign() {

      int relPatTime = parent_node.getEditOffset();

      int cStep = (relPatTime / step_resolution);
      int aStep = ((cStep / parent_node.ui_step_alignment)) * parent_node.ui_step_alignment;
      if(cStep == aStep)
      {
         loop(parent_node.ui_step_alignment)
            scrollUp();
      }
      else
      {
         while(cStep > aStep)
         {
            scrollUp();
            cStep--;
         }
      }
   }

   // <ui_cursor.png>
   public method pageUpFast() {
      loop(page_fast_num_steps)
         scrollUp();
   }

   // <method.png>
   protected method isLastPatStep() : boolean {
      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();

      if(null != mpat)
      {
         int patStep = parent_node.getEditOffset() / step_resolution;
         int lastStep = mpat.num_ticks / step_resolution;
         return (patStep >= (lastStep - 1));
      }
      return true;
   }

   // <method.png>
   protected method isFirstPatStep() : boolean {
      int patStep = parent_node.getEditOffset() / step_resolution;
      return (0 == patStep);
   }

   // <ui_cursor.png>
   public method gotoNextEvent() {
      // trace "xxx gotoNextEvent: songOff="+ui_song_offset;
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_TEL tel <= track.getTrackLayout();
         if(null != tel)
         {
            int editOffset = parent_node.getEditOffset();
            NT_TrackPattern pat <= track.getCurrentEditPattern();
            if(null != pat)
            {
               int relPatTime = editOffset;
               int absEnvTime;

               NT_CEL *cel;

               int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
               cel <= tel.ctl_layouts[ctlMapId & 31]; // mask out MSB_FLAG

               Envelope env <= pat.getEnvelope(cel.ctl_id);

               if(null != env)
               {
                  int envIdx = env.timeToIndex(relPatTime);
                  // trace "xxx timeToIndex: relPatTime="+relPatTime+" envIdx="+envIdx;
                  if(-1 != envIdx)
                  {
                     if(-2 == envIdx)
                     {
                        // before first event => goto first event
                        gotoPatPosition(env[0], true);
                     }
                     else
                     {
                        if(env.numElements > ((envIdx+1)*2))
                        {
                           // Goto next event
                           // trace "xxx envIdx="+envIdx+" relPatTime="+relPatTime+" patStartTime="+patStartTime+" songOff="+ui_song_offset;
                           gotoPatPosition(env.indexToTime(envIdx+1), true);
                        }
                        else
                        {
                           if(STConfig.b_node_tracker_wraparound)
                           {
                              // Goto first event
                              gotoPatPosition(env[0], true);
                           }
                        }
                     }
                  } // -1 != envIdx
               } // if env
            } // if pat
         } // if tel
      } // if track
   }

   // <ui_cursor.png>
   public method gotoPreviousEvent() {
      // trace "xxx gotoPreviousEvent: songOff="+ui_song_offset;
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_TEL tel <= track.getTrackLayout();
         if(null != tel)
         {
            int editOffset = parent_node.getEditOffset();
            NT_TrackPattern pat <= track.getCurrentEditPattern();
            if(null != pat)
            {
               int relPatTime = editOffset;
               int absEnvTime;

               NT_CEL *cel;

               int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
               cel <= tel.ctl_layouts[ctlMapId & 31]; // mask out MSB_FLAG

               Envelope env <= pat.getEnvelope(cel.ctl_id);
               if(null != env)
               {
                  int envIdx = env.timeToIndex(relPatTime);
                  // // trace "xxx timeToIndex: relPatTime="+relPatTime+" envIdx="+envIdx;
                  if(-1 != envIdx)
                  {
                     if(-2 == envIdx)
                     {
                        if(STConfig.b_node_tracker_wraparound)
                        {
                           // before first event => goto last event
                           gotoPatPosition(env.indexToTime((env.numElements-2)/2), false);
                        }
                     }
                     else
                     {
                        int envTime = env.indexToTime(envIdx);
                        // // trace "xxx envTime="+envTime;

                        if(relPatTime > envTime)
                        {
                           gotoPatPosition(envTime, false);
                        }
                        else
                        {
                           if(envIdx > 0)
                           {
                              // Goto previous event
                              // trace "xxx envIdx="+envIdx+" relPatTime="+relPatTime+" patStartTime="+patStartTime+" songOff="+ui_song_offset;
                              gotoPatPosition(env.indexToTime(envIdx-1), false);
                           }
                           else
                           {
                              if(STConfig.b_node_tracker_wraparound)
                              {
                                 // Goto last event
                                 gotoPatPosition(env.indexToTime((env.numElements-2)/2), false);
                              }
                           }
                        } // else if relPatTime > envTime
                     }
                  } // -1 != envIdx
               } // if env
            } // if pat
         } // if tel
      } // if track
   }

   // <method.png>
   protected method incDecCurrentCtl(int _dir, boolean _bCoarse) {
      Global.Debug("PatternView::incDecCurrentCtl: dir="+_dir+" bCoarse="+_bCoarse);

      NT_CEL cel <= getCurrentControllerLayout();
      if(null != cel) // always non-null ? (empty song?)
      {
         var cval = parent_node.getTrackEventAt(cel.ctl_id, parent_node.getEditOffset());
         if(typeid(cval) == YAC_TYPE_FLOAT)
         {
            float delta;
            if(_bCoarse)
               delta = STConfig.node_tracker_incdec_coarse_deltas.get(cel.ctl_id);
            else
               delta = STConfig.node_tracker_incdec_fine_deltas.get(cel.ctl_id);

            // trace "xxx incDecCurrentCtl: cval="+cval+" delta="+(abs(delta)*_dir);

            boolean bNegative = (cval <  0);

            if(bNegative) // Note Off
               cval = cval - abs(delta) * _dir;
            else
               cval = cval + abs(delta) * _dir;

            // Align ?
            if(delta > 1)
            {
               if(int(delta) == delta)
               {
                  if(_dir > 0)
                  {
                     // Round up
                     cval = int(cval / delta) * delta;
                  }
                  else
                  {
                     // Round down
                     cval = int((cval+(delta-1)) / delta) * delta;
                  }
               }
            }

            boolean bClipped = false;

            if(bNegative)
            {
               if(cval >= 0)
               {
                  cval = -1;
                  bClipped = true;
               }
            }
            else
            {
               if(cval < 0)
               {
                  cval = 0;
                  bClipped = true;
               }
            }

            float cvalPreClip = cval;
            cval = cel.clipCtlValue(cval);
            bClipped |= (cval != cvalPreClip);

            if(!bClipped)
            {
               int recPatOffset = parent_node.getEditOffset();
               Integer recRaster = step_resolution;
               recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

               parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, cval, recPatOffset, recRaster);

               Integer ioHex = cval;
               Global.Print("Value is 0x"+ioHex.printf("%02x")+" ("+cval+")");

               ta_redraw_all.scheduleShort();
            }
            else
            {
               Global.Warning("inc/dec: clipped");
            }
         }
      }
   }

   // <method.png>
   =replay= public method insertReplaceTrackEvent(int _ctl, float _value) {
      explain "Replace/insert controller value in the current pattern/track/position";
      parent_node.insertReplaceTrackEventAt(_ctl, _value, parent_node.getEditOffset());
   }

   // <method.png>
   public method insertReplaceEventMSB4AtRes(NT_Track _track, int _ctl, float _value, int _patOffset, int _res) {
      ////trace "xxx insertReplaceTrackEvent track="+#(track)+" songOffset="+_songOffset;
      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      if(null != pat)
      {
         if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctl);
            parent_node.undoTouchController(_track.track_nr, patNr, _ctl, env);
            env.insertReplaceEventMSB4(_patOffset, _value, _res);
         }
      } // if pat
   }

   // <method.png>
   =replay= public method insertReplaceTrackEventMSB4AtRes(int _ctl, float _value, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         insertReplaceEventMSB4AtRes(track, _ctl, _value, _patOffset, _res);
      } // if track
   }

   // <method.png>
   public method insertReplaceEventLSB4AtRes(NT_Track _track, int _ctl, float _value, int _patOffset, int _res) {
      // trace "xxx insertReplaceTrackEvent track="+#(_track)+" patOffset="+_patOffset;
      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      if(null != pat)
      {
         if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctl);
            parent_node.undoTouchController(_track.track_nr, patNr, _ctl, env);
            env.insertReplaceEventLSB4(_patOffset, _value, _res);
         }
      } // if pat
   }

   // <method.png>
   =replay= public method insertReplaceTrackEventLSB4AtRes(int _ctl, float _value, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         insertReplaceEventLSB4AtRes(track, _ctl, _value, _patOffset, _res);
   }

   // <method.png>
   public method insertReplaceEventPat1AtRes(NT_Track _track, int _ctl, float _value, int _patOffset, int _res) {
      ////trace "xxx insertReplaceTrackEvent track="+#(track)+" songOffset="+_songOffset;
      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      if(null != pat)
      {
         if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctl);
            parent_node.undoTouchController(_track.track_nr, patNr, _ctl, env);
            env.insertReplaceEventPat1(_patOffset, _value, _res);
         }
      } // if pat
   }

   // <method.png>
   =replay= public method insertReplaceTrackEventPat1AtRes(int _ctl, float _value, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         insertReplaceEventPat1AtRes(track, _ctl, _value, _patOffset, _res);
   }

   // <method.png>
   public method insertReplaceEventPat2AtRes(NT_Track _track, int _ctl, float _value, int _patOffset, int _res) {
      ////trace "xxx insertReplaceTrackEvent track="+#(track)+" songOffset="+_songOffset;
      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      if(null != pat)
      {
         if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctl);
            parent_node.undoTouchController(_track.track_nr, patNr, _ctl, env);
            env.insertReplaceEventPat2(_patOffset, _value, _res);
         }
      } // if pat
   }

   // <method.png>
   =replay= public method insertReplaceTrackEventPat2AtRes(int _ctl, float _value, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         insertReplaceEventPat2AtRes(track, _ctl, _value, _patOffset, _res);
   }

   // <method.png>
   public method insertReplaceEventPat3AtRes(NT_Track _track, int _ctl, float _value, int _patOffset, int _res) {
      ////trace "xxx insertReplaceTrackEvent track="+#(track)+" songOffset="+_songOffset;
      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getOrCreatePattern(patNr);
      if(null != pat)
      {
         if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            Envelope env <= pat.getCreateEnvelope(_ctl);
            parent_node.undoTouchController(_track.track_nr, patNr, _ctl, env);
            env.insertReplaceEventPat3(_patOffset, _value, _res);
         }
      } // if pat
   }

   // <method.png>
   =replay= public method insertReplaceTrackEventPat3AtRes(int _ctl, float _value, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         insertReplaceEventPat3AtRes(track, _ctl, _value, _patOffset, _res);
   }

   // <method.png>
   =replay= public method removeTrackEvent(int _ctl) {
      parent_node.removeTrackEventAt(_ctl, parent_node.getEditOffset());
   }

   // <method.png>
   =replay= public method removeTrackEventRes(int _ctl, int _res) {
      parent_node.removeTrackEventAtRes(_ctl, parent_node.getEditOffset(), _res);
   }

   // <method.png>
   =replay= public method removeAllTrackEventsAtEditOffsetRes(int _res) {
      parent_node.removeAllTrackEventsAtRes(parent_node.getEditOffset(), _res);
   }

   // <method.png>
   =replay= public method removeAllTrackEventsAtEditOffset() {
      parent_node.removeAllTrackEventsAtRes(parent_node.getEditOffset(), parent_node.pv_step_resolution);
   }

   // <method.png>
   =replay= public method shiftAllTrackEventsAtEditOffsetRes(int _res) {
      parent_node.shiftAllTrackEventsAtRes(parent_node.getEditOffset(), _res);
   }

   // <method.png>
   =replay= public method shiftAllTrackEventsAtEditOffset() {
      parent_node.shiftAllTrackEventsAtRes(parent_node.getEditOffset(), parent_node.pv_step_resolution);
   }

   // <method.png>
   =replay= public method getNextTrackEventStepOffset(int _ctl) : int {
      // if ctl=-1, return minimum offset (all ctls)
      int nextOff = parent_node.getNextTrackEventOffsetAt(_ctl, parent_node.getEditOffset());
      return nextOff - (nextOff / step_resolution) * step_resolution;
   }

   // <method.png>
   public method shiftTrackEvents(int _ctl) {
      parent_node.shiftTrackEventsAt(_ctl, parent_node.getEditOffset());
   }

   // <method.png>
   public method shiftTrackEventsRes(int _ctl, int _res) {
      parent_node.shiftTrackEventsAtRes(_ctl, parent_node.getEditOffset(), _res);
   }

   // <method.png>
   public method removeNextEventAt(NT_Track _track, int _ctl, int _patOffset, int _raster) : boolean {
      // _ctl=-1 ==> remove all controller events
      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getPattern(patNr);
      if(null != pat)
      {
         Envelope *env;

         if(-1 == _ctl)
         {
            // Remove step in all controllers

            // Determine minimum time to next event
            int nextT = 999999;
            float t;
            foreach env in pat.controllers
            {
               if(null != env)
               {
                  t = env.getNextEventTimeAfter(_patOffset);
                  if(-1 != t)
                  {
                     if(t < nextT)
                        nextT = t;
                  }
               }
            }

            if(999999 != nextT)
            {
               // Shift next event step (block) one row up
               int nextTStepOff = nextT;
               int oldEditOff = parent_node.getEditOffset();
               NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
               b_block_quiet = true;
               parent_node.setEditOffset(nextTStepOff);
               Key k;
               k.mod = VMOD_LSHIFT;
               blockAncTryBegin(k);
               blockAncTryUpdate(k);
               blockCopy();
               blockDelete(true/*bShift*/, false/*bUndoStartEnd*/); // calls selectNone()
               nextTStepOff -= _raster;
               if(nextTStepOff >= 0)
               {
                  if(nextTStepOff >= oldEditOff)
                  {
                     parent_node.setEditOffset(nextTStepOff);
                     blockPaste(false/*bShift*/, false/*bUndoStartEnd*/, false/*bScrollDown*/);
                  }
               }
               selectNone();
               NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);
               parent_node.setEditOffset(oldEditOff);
               b_block_quiet = false;

               return true;
            }
            // else: no next event, nothing to shift
         }
         else if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            env <= pat.getEnvelope(_ctl);
            if(null != env)
            {
               parent_node.undoTouchController(_track.track_nr, patNr, _ctl, env);

               env.removeRangeUntilNext(_patOffset, _raster, 999999);

               return true;
            }
         }
      } // if pat
      return false;
   }

   // <method.png>
   =replay= public method removeNextTrackEventAt(int _ctl, int _patOffset) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         removeNextEventAt(track, _ctl, _patOffset, step_resolution);
   }

   // <method.png>
   =replay= public method removeNextTrackEventAtRes(int _ctl, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         removeNextEventAt(track, _ctl, _patOffset, _res);
   }

   // <method.png>
   =replay= public method removeNextTrackEvent(int _ctl) {
      removeNextTrackEventAt(_ctl, parent_node.getEditOffset());
   }

   // <method.png>
   =replay= public method removeNextTrackEventTick(int _ctl) {
      removeNextTrackEventAtRes(_ctl, parent_node.getEditOffset(), 1/*res*/);
   }

   // <method.png>
   =replay= public method removeNextTrackEventRes(int _ctl, int _res) {
      removeNextTrackEventAtRes(_ctl, parent_node.getEditOffset(), _res);
   }

   // <method.png>
   protected method shiftNextEventAt(NT_Track _track, int _ctl, int _patOffset, int _raster) : boolean {
      // ctl=-1 ==> shift all controllers

      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= _track.getPattern(patNr);
      if(null != pat)
      {
         Envelope env;
         if(-1 == _ctl)
         {
            // Shift all controllers

            // Determine minimum time to next event
            int nextT = 999999;
            float t;
            foreach env in pat.controllers
            {
               if(null != env)
               {
                  t = env.getNextEventTimeAfter(_patOffset);
                  if(-1 != t)
                  {
                     if(t < nextT)
                        nextT = t;
                  }
               }
            }

            int nextTStepOff = nextT;

            if(999999 != nextT)
            {
               // Determine minimum time to event after that
               int nextNextT = 999999;
               foreach env in pat.controllers
               {
                  if(null != env)
                  {
                     t = env.getNextEventTimeAfter(nextTStepOff+step_resolution);
                     if(-1 != t)
                     {
                        if(t < nextNextT)
                           nextNextT = t;
                     }
                  }
               }

               if(999999 == nextNextT)
               {
                  // No event after next, simply shift
               }
               else
               {
                  if((nextNextT - nextTStepOff) <= step_resolution)
                  {
                     // Can't shift, an event already exists at the new position
                     return false;
                  }
               }


               // Shift next event step (block) one row down
               int oldEditOff = parent_node.getEditOffset();
               int oldBlockMode = block_mode;
               block_mode = BLOCK_MODE_TRACK;  // in case we are currently in CTL or PATTERN mode
               int oldCursorTrackNr = getCurrentTrackNr();
               moveCursorToTrack(_track.track_nr);
               NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
               b_block_quiet = true;
               parent_node.setEditOffset(nextTStepOff);
               Key k;
               k.mod = VMOD_LSHIFT;
               blockAncTryBegin(k);
               blockAncTryUpdate(k);
               blockCopy();
               blockDelete(true/*bShift*/, false/*bUndoStartEnd*/); // calls selectNone()
               nextTStepOff += _raster;
               if(nextTStepOff > 0)
               {
                  parent_node.setEditOffset(nextTStepOff);
                  blockPaste(false/*bShift*/, false/*bUndoStartEnd*/, false/*bScrollDown*/);
               }
               block_mode = oldBlockMode;
               moveCursorToTrack(oldCursorTrackNr);
               selectNone();
               NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);
               parent_node.setEditOffset(oldEditOff);
               b_block_quiet = false;

               return true;
            }
            // else: no events at all, nothing to shift
         }
         else if(_ctl < NT_TrackPattern.CTL_NUM)
         {
            // Shift only one controller envelope
            env <= pat.getEnvelope(_ctl);
            if(null != env)
            {
               parent_node.undoTouchController(_track.track_nr, patNr, _ctl, env);

               env.shiftNextEvent(_patOffset, _raster, 999999);
               return true;
            }
         }
      } // if pat
      return false;
   }

   // <method.png>
   =replay= protected method shiftNextTrackEventAt(int _ctl, int _patOffset) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         shiftNextEventAt(track, _ctl, _patOffset, step_resolution);
   }

   // <method.png>
   =replay= protected method shiftNextTrackEventAtRes(int _ctl, int _patOffset, int _res) {
      NT_Track track <= getCurrentTrack();
      if(null != track)
         shiftNextEventAt(track, _ctl, _patOffset, _res);
   }

   // <method.png>
   protected method shiftNextTrackEvent(int _ctl) {
      shiftNextTrackEventAt(_ctl, parent_node.getEditOffset());
   }

   // <method.png>
   protected method shiftNextTrackEventRes(int _ctl, int _res) {
      shiftNextTrackEventAtRes(_ctl, parent_node.getEditOffset(), _res);
   }

   // <method.png>
   protected =replay= method shiftNextEventAllTracksAtEditOffsetRes(int _patOffset, int _res) {
      // (todo) ideally we would need check each track to see if all events can be moved. not doing that for now, though.
      local NT_Track *track;
      foreach track in parent_node.tracks
         shiftNextEventAt(track, -1/*allCtls*/, _patOffset, _res);
   }

   // <method.png>
   protected method shiftNextEventAllTracks() {
      shiftNextEventAllTracksAtEditOffsetRes(parent_node.getEditOffset(), step_resolution);
   }

   // <method.png>
   protected method shiftNextEventAllTracksRes(int _res) {
      shiftNextEventAllTracksAtEditOffsetRes(parent_node.getEditOffset(), _res);
   }

   // <method.png>
   public method deleteCurrentTrackEnvelope() {
      if(isEditable())
      {
         NT_TEL tel <= getCurrentTrackLayout();
         if(null != tel)
         {
            int ctlId = getCurrentController();

            String undoName = "delete track#"+getCurrentTrackNr()+" envelope #"+ctlId;
            parent_node.undoBeginNested(undoName);
            deleteTrackEnvelope(ctlId);
            parent_node.undoEndNested(undoName);
         }
      }
      else
      {
         Global.Warning("delete current track envelope failed: please change edit mode.");
      }
   }

   // <method.png>
   public method deleteAllCurrentTrackEnvelopes2() {
      // (note) undo transaction must be started by caller

      Global.Debug("PatternView::deleteCurrentTrackEnvelopes2");

      int i = 0;
      loop(NT_TrackPattern.CTL_NUM)
         deleteTrackEnvelope(i++);
   }

   // <method.png>
   public method deleteCurrentTrackEnvelope2() {
      // (note) undo transaction must be started by caller

      int ctlId = getCurrentController();
      deleteTrackEnvelope(ctlId);
   }

   // <method.png>
   public =replay= method deleteAllCurrentTrackEnvelopes() {
      // "Clear current pattern"
      //   - delete either the current envelope or all track envelopes, depending on block mode

      if(isRecordingIfFocused()) // for Metronome recording
      {
         Global.Debug("PatternView::deleteAllCurrentTrackEnvelopes");

         String undoName;

         // Clear current pattern
         if(BLOCK_MODE_CTL != block_mode)
         {
            undoName = "delete track#"+getCurrentTrackNr()+" envelopes";
            parent_node.undoBeginNested(undoName);
            deleteAllCurrentTrackEnvelopes2();
            parent_node.undoEndNested(undoName);
         }
         else
         {
            int ctlId = getCurrentController();
            undoName = "delete track#"+getCurrentTrackNr()+" envelope #"+ctlId;
            parent_node.undoBeginNested(undoName);
            deleteCurrentTrackEnvelope2();
            parent_node.undoEndNested(undoName);
         }
      }
      else
      {
         Global.Warning("clear current pattern failed: please change edit mode.");
      }
   }

   // <method.png>
   protected method deleteTrackEnvelope(int _ctlId) {
      // Delete current pattern envelope 'ctlId
      Integer patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_TrackPattern pat <= getCurrentPattern();
      if(null != pat)
      {
         Envelope env <= pat.getEnvelope(_ctlId);
         if(null != env)
         {
            parent_node.undoTouchController(getCurrentTrackNr(), patNr, _ctlId, env);

            pat.deleteEnvelope(_ctlId);

            redrawAll();

            String msg = "Deleted envelope #" + _ctlId;

            // Append controller name to message (if ctl is currently visible)
            NT_TEL tel <= getCurrentTrackLayout();
            if(null != tel)
            {
               NT_CEL cel <= tel.findVisibleCelForCtlById(_ctlId);
               if(null != cel)
                  msg.append(" ("+getControllerName(getCurrentTrack(), _ctlId) +")");
            }
            Global.Print(msg);
         }
      }
   }

   // <method.png>
   public method toggleRecordNoteOffMode() {
      STConfig.b_node_tracker_recordnoteoff = ! STConfig.b_node_tracker_recordnoteoff;
      Global.Print("Pattern note off recording is "+Utils.GetEnableString(STConfig.b_node_tracker_recordnoteoff));
   }

   // <method.png>
   public method toggleRecordNoteOffReplayMode() {
      STConfig.b_node_tracker_recordnoteoff_replay = ! STConfig.b_node_tracker_recordnoteoff_replay;
      Global.Print("Pattern note off recording mode is \""+(STConfig.b_node_tracker_recordnoteoff_replay ? "always" : "only during replay")+"\"");
   }

   // <method.png>
   public method toggleRecordNoteOffDurMode() {
      STConfig.b_node_tracker_recordnoteoff_dur = ! STConfig.b_node_tracker_recordnoteoff_dur;
      Global.Print("Pattern CTL_DURn recording is "+Utils.GetEnableString(STConfig.b_node_tracker_recordnoteoff_dur));
   }

   // <method.png>
   public method toggleRecordQuantizeMode() {
      STConfig.b_node_tracker_recordquantize = ! STConfig.b_node_tracker_recordquantize;
      Global.Print("Pattern quantized recording mode is "+Utils.GetEnableString(STConfig.b_node_tracker_recordquantize));
   }

   // <method.png>
   public method toggleRecordUsrCtlNoteOn() {
      STConfig.b_node_tracker_recordusrctlnoteon = ! STConfig.b_node_tracker_recordusrctlnoteon;
      Global.Print("Pattern UsrCtl-NoteOn recording mode is "+Utils.GetEnableString(STConfig.b_node_tracker_recordusrctlnoteon));
   }

   // <method.png>
   public method toggleRecLatency() {
      STConfig.b_node_tracker_rec_latency = ! STConfig.b_node_tracker_rec_latency;
      Global.Print("Recording latency is "+Utils.GetEnableString(STConfig.b_node_tracker_rec_latency)+" ("+(STConfig.b_node_tracker_rec_latency ? STConfig.node_tracker_rec_latency : 0)+" ms)");
   }

   // <method.png>
   public method patternClear() {
      parent_editor.cmd_pattern_free(false/*bFreeMeta*/, true/*bUndoBegin*/);
   }

   // <ui_selection.png>
   public method getBlockModeName() : String {
      switch(block_mode)
      {
         case BLOCK_MODE_CTL:
            return "CTL";

         case BLOCK_MODE_TRACK:
            return "TRACK";

         case BLOCK_MODE_PATTERN:
            return "PATTERN";
      }
   }

   // <ui_selection.png>
   public method isPatternBlockMode() : boolean {
      return (BLOCK_MODE_PATTERN == block_mode);
   }

   // <ui_selection.png>
   public method nextBlockMode() {
      block_mode = (block_mode +1 ) % NUM_BLOCK_MODES;

      parent_editor.updateBlockModeName();

      Global.Print("Block selection mode is now "+getBlockModeName());
   }

   // <ui_selection.png>
   public method blockAncTryBegin(Key _k) {
      if(_k.modShift())
      {
         if(!b_block_anc_active)
            blockAncBegin();
      }
      else
      {
         if(b_block_anc_active)
         {
            blockAncCancel();
            selectNone();
         }
      }
   }

   // <ui_selection.png>
   public method blockAncTryUpdate(Key _k) {
      if(b_block_anc_active)
         blockAncUpdate();
   }

   // <ui_selection.png>
   public method blockAncBegin() {

      selectNone();
      b_block_anc_active = true;

      blockBegin(true);
   }

   // <ui_selection.png>
   public method blockAncUpdate() {

      blockEnd(false);

      if(verifyBlockStartAndEnd())
         swapBackBlockStartAndEnd();

      ////trace "xxx blockAncUpdate: start: off="+parent_node.pv_block_start_song_offset+" trk="+parent_node.pv_block_start_cursor_track+" x="+parent_node.pv_block_start_cursor_x;
      ////trace "xxx blockAncUpdate:   end: off="+parent_node.pv_block_end_song_offset+" trk="+parent_node.pv_block_end_cursor_track+" x="+parent_node.pv_block_end_cursor_x;

   }

   // <ui_selection.png>
   public method blockAncCancel() {
      b_block_anc_active = false;
   }

   // <ui_selection.png>
   protected method swapBackBlockStartAndEnd() {
      parent_node.pv_block_start_pat_offset   = block_swapback_start_pat_offset;
      parent_node.pv_block_start_cursor_track = block_swapback_start_cursor_track;
      parent_node.pv_block_start_cursor_x     = block_swapback_start_cursor_x;

      parent_node.pv_block_end_pat_offset   = block_swapback_end_pat_offset;
      parent_node.pv_block_end_cursor_track = block_swapback_end_cursor_track;
      parent_node.pv_block_end_cursor_x     = block_swapback_end_cursor_x;
   }

   // <ui_selection.png>
   protected method verifyBlockStartAndEnd() : boolean {
      // Swap block start/end if necessary
      // return true if vertical order has changed

      block_swapback_start_pat_offset   = parent_node.pv_block_start_pat_offset;
      block_swapback_start_cursor_track = parent_node.pv_block_start_cursor_track;
      block_swapback_start_cursor_x     = parent_node.pv_block_start_cursor_x;

      block_swapback_end_pat_offset   = parent_node.pv_block_end_pat_offset;
      block_swapback_end_cursor_track = parent_node.pv_block_end_cursor_track;
      block_swapback_end_cursor_x     = parent_node.pv_block_end_cursor_x;

      boolean r = false;
      boolean rx = false;

      if(parent_node.pv_block_end_pat_offset < parent_node.pv_block_start_pat_offset)
      {
         parent_node.swapBlockStartAndEnd();
         r = true;
      }
      else if(parent_node.pv_block_end_pat_offset == parent_node.pv_block_start_pat_offset)
      {
         if(parent_node.pv_block_end_cursor_track < parent_node.pv_block_start_cursor_track)
         {
            parent_node.swapBlockStartAndEnd();
            r = true;
         }
         else if(parent_node.pv_block_end_cursor_track == parent_node.pv_block_start_cursor_track)
         {
         }
      }

      if(parent_node.pv_block_start_cursor_track == parent_node.pv_block_end_cursor_track)
      {
         if(parent_node.pv_block_end_cursor_x < parent_node.pv_block_start_cursor_x)
         {
            swapBlockCursorX();
            r = true;
         }
      }

      blockBeginAutoExpand();
      blockEndAutoExpand();

      return r;
   }

   // <ui_selection.png>
   protected method swapBlockCursorX() {
      int t = parent_node.pv_block_start_cursor_x;
      parent_node.pv_block_start_cursor_x = parent_node.pv_block_end_cursor_x;
      parent_node.pv_block_end_cursor_x = t;
   }

   // <ui_selection.png>
   protected method verifyBlockCursorX() : boolean {
      if(parent_node.pv_block_end_cursor_x < parent_node.pv_block_start_cursor_x)
      {
         swapBlockCursorX();
         return true;
      }
   }

   // <method.png>
   public =replay= method splitPatternToClipboard(boolean _bPasteNewPattern) {
      // Copy second half of pattern to clipboard then delete it
      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();
      if((null != mpat) && !mpat.patIsEmpty())
      {
         int numTicks1 = mpat.num_ticks / 2;
         int numTicks2 = mpat.num_ticks - numTicks1;

         parent_node.undoBeginNested("split_pattern");
         int origPatNr = parent_node.nodeGetCurrentEditPatternNr();
         int newPatNr;
         parent_node.undoTouchNodeState();  // for undoing pattern allocation

         // Determine initial controller values (value at first step of second pattern half)
         //  (todo) make this a utility function ?
         NT_Track *track;
         foreach track in parent_node.tracks
         {
            NT_TrackPattern trackPat <= track.getPattern(origPatNr);
            int ctlId = NT_TrackPattern.CTL_VEL1;  // skip note 1..5
            loop(CTL_NUM - ctlId)
            {
               Envelope env <= trackPat.getEnvelope(ctlId);
               if(null != env)
               {
                  var ctlVal = env.valueAtTimeSH(numTicks1);
                  if(YAC_TYPE_FLOAT == typeid(ctlVal))
                  {
                     // Copy to first step of new pattern (second half of current pattern)
                     env.insertReplaceEvent(numTicks1, ctlVal, 1.0/*windowSz*/);
                  }
               }
               // Next controller envelope
               ctlId++;
            }
         }

         // Select, copy, and delete second half
         b_block_quiet = true;
         int oldBlockMode = block_mode;
         block_mode = BLOCK_MODE_PATTERN;

         blockSelectPatRange(numTicks1/*startOff*/,   getCurrentTrackNr(), cursor_x,
                             mpat.num_ticks/*endOff*/, getCurrentTrackNr(), cursor_x
                             );
         blockCopy();
         blockDelete(false/*bShift*/, false/*bUndoStartEnd*/);
         selectNone();
         gotoPatPosition(0, false/*bClip*/);

         mpat.num_ticks = numTicks1;

         if(_bPasteNewPattern)
         {
            if(parent_editor.cmd_pattern_alloc(true/*bSub*/))
            {
               mpat <= parent_node.getCurrentEditMetaPattern();
               mpat.num_ticks = numTicks2;
               newPatNr = parent_node.nodeGetCurrentEditPatternNr();
               blockPaste(false/*bShift*/, false/*bUndoStartEnd*/, false/*bScrollDown*/);
            }
         }

         block_mode = oldBlockMode;
         b_block_quiet = false;

         parent_node.undoEndNested("split_pattern");

         parent_editor.updatePatLen();
         queueRedrawAll();

         if(_bPasteNewPattern)
            Global.Print("Split pattern "+(Node.patnr_options.get(origPatNr))+" to new pattern "+(Node.patnr_options.get(origPatNr))+"  ("+numTicks2+" ticks)");
         else
            Global.Print("Split pattern to clipboard ("+numTicks2+" ticks)");
      }

   }

   // <ui_selection.png>
   protected method blockBeginAutoExpand() {
      // Auto-expand selection depending on block mode
      switch(block_mode)
      {
         case BLOCK_MODE_CTL:
            // determine whether current
            NT_TEL tel <= getTrackLayout(parent_node.pv_block_start_cursor_track);
            if(null != tel)
            {
               int ctlMapId = tel.cursor_to_ctl_map[parent_node.pv_block_start_cursor_x];
               NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
               if((cel.style == NT_CEL.STYLE_HEX) || (cel.style == NT_CEL.STYLE_PATNR2))
               {
                  if(! (ctlMapId & NT_TEL.MSB_FLAG))
                  {
                     parent_node.pv_block_start_cursor_x--; // also select msb
                  }
               }
               else if(cel.style == NT_CEL.STYLE_PATNR3)
               {
                  if(ctlMapId & NT_TEL.MSB_FLAG)
                  {
                     parent_node.pv_block_start_cursor_x--; // also select first column
                  }
                  else if!(ctlMapId & NT_TEL.TSB_FLAG)
                  {
                     parent_node.pv_block_start_cursor_x -= 2; // also select first column
                  }
               }
            }
            break;

            case BLOCK_MODE_TRACK:
               parent_node.pv_block_start_cursor_x = 0;
               break;

            case BLOCK_MODE_PATTERN:
               parent_node.pv_block_start_cursor_track = 0;
               parent_node.pv_block_start_cursor_x     = 0;
               break;
      }
   }

   // <ui_selection.png>
   public method blockSelectPatRange(int _startOff, _startTrack, _startX,
                                     int _endOff, _endTrack, _endX) {

      ////trace "xxx blockSelectPatRange: start off="+_startOff+" track="+_startTrack+" x="+_startX;
      ////trace "xxx blockSelectPatRange:   end off="+_endOff+" track="+_endTrack+" x="+_endX;

      parent_node.blockSelectPatRangeRaw(_startOff, _startTrack, _startX,
                                         _endOff,   _endTrack,   _endX
                                         );

      blockBeginAutoExpand();
      blockEndAutoExpand();
   }

   // <ui_selection.png>
   public method blockSelectCurrentPattern() {
      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();
      if(null != mpat)
      {
         blockSelectPatRange(0/*startTime*/, getCurrentTrackNr(), cursor_x,
                             mpat.num_ticks, getCurrentTrackNr(), cursor_x
                             );
         b_block_anc_active = true; // next cursor move selects none [29Jun2017]
      }
   }

   // <ui_selection.png>
   public method blockSelectCurrentPatternOrNone() {
      if(parent_node.haveSelection())
         selectNone();
      else
         blockSelectCurrentPattern();
   }

   // <ui_selection.png>
   public method blockBegin(boolean _bAllowSelectNone) {
      blockBeginAt(parent_node.getEditOffset(), _bAllowSelectNone);
   }

   // <ui_selection.png>
   public method blockBeginAt(int _patOffset, boolean _bAllowSelectNone) {
      // Set block start to current cursor position

      b_block_in_clipboard = false;

      int totalNumTracks = parent_node.tracks.numElements;
      if(0 == totalNumTracks)
         return;

      int oldPatOffset   = parent_node.pv_block_start_pat_offset;
      int oldCursorTrack = parent_node.pv_block_start_cursor_track;
      int oldCursorX     = parent_node.pv_block_start_cursor_x;

      // Save block start position
      parent_node.pv_block_start_pat_offset   = _patOffset;
      parent_node.pv_block_start_cursor_track = getCurrentTrackNr();
      parent_node.pv_block_start_cursor_x     = cursor_x;

      // Auto-expand selection depending on block mode
      if(-1 != parent_node.pv_block_end_pat_offset)
      {
         if(verifyBlockStartAndEnd()) // auto expand
            swapBackBlockStartAndEnd();
      }
      else
      {
         blockBeginAutoExpand();
      }


      // Discard selection if lctrl-b is pressed twice at the same cursor position
      if( (oldPatOffset   == parent_node.pv_block_start_pat_offset)   &&
          (oldCursorTrack == parent_node.pv_block_start_cursor_track) &&
          (oldCursorX     == parent_node.pv_block_start_cursor_x)     &&
          _bAllowSelectNone
          )
      {
         selectNone();
      }
      else
      {
         if(!b_block_quiet)
            Global.Print("set block start to (offset="+parent_node.pv_block_start_pat_offset+" track="+parent_node.pv_block_start_cursor_track+" x="+parent_node.pv_block_start_cursor_x+")");
      }
   }

   // <ui_selection.png>
   protected method blockEndAutoExpand() {
      // Auto-expand selection depending on block mode

      int totalNumTracks = parent_node.tracks.numElements;

      NT_TEL tel <= getTrackLayout(parent_node.pv_block_end_cursor_track);
      //trace "xxx parent_node.pv_block_end_cursor_track="+parent_node.pv_block_end_cursor_track+" tel="+#(tel);
      switch(block_mode)
      {
         case BLOCK_MODE_CTL:
            // determine whether current
            if(null != tel)
            {
               int ctlMapId = tel.cursor_to_ctl_map[parent_node.pv_block_end_cursor_x];
               NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG

               if((cel.style == NT_CEL.STYLE_HEX) || (cel.style == NT_CEL.STYLE_PATNR2))
               {
                  if((ctlMapId & NT_TEL.MSB_FLAG))
                  {
                     ////trace "xxx blockEndAutoExpand: start: off="+parent_node.pv_block_start_pat_offset+" trk="+parent_node.pv_block_start_cursor_track+" x="+parent_node.pv_block_start_cursor_x;
                     ////trace "xxx blockEndAutoExpand:   end: off="+parent_node.pv_block_end_pat_offset+" trk="+parent_node.pv_block_end_cursor_track+" x="+parent_node.pv_block_end_cursor_x;
                     parent_node.pv_block_end_cursor_x++; // also select LSB
                  }
               }
               else if(cel.style == NT_CEL.STYLE_PATNR3)
               {
                  if(ctlMapId & NT_TEL.TSB_FLAG)
                     parent_node.pv_block_end_cursor_x += 2; // also select 2nd and 3rd columns
                  else if(ctlMapId & NT_TEL.MSB_FLAG)
                     parent_node.pv_block_end_cursor_x++; // also select 3rd column
               }
            }
            break;

            case BLOCK_MODE_TRACK:
               parent_node.pv_block_end_cursor_x = tel.num_cursor_positions - 1;
               break;

            case BLOCK_MODE_PATTERN:
               parent_node.pv_block_end_cursor_track = totalNumTracks - 1;
               parent_node.pv_block_end_cursor_x = tel.num_cursor_positions - 1;
               break;
      }
   }

   // <ui_selection.png>
   public method blockEnd(boolean _bAllowCancel) {
      blockEndAt(parent_node.getEditOffset(), _bAllowCancel);
   }

   // <ui_selection.png>
   public method blockEndAt(int _patOffset, boolean _bAllowCancel) {
      // Set block end to current cursor position + step_resolution

      b_block_in_clipboard = false;

      int totalNumTracks = parent_node.tracks.numElements;
      if(0 == totalNumTracks)
         return;

      int oldPatOffset   = parent_node.pv_block_end_pat_offset;
      int oldCursorTrack = parent_node.pv_block_end_cursor_track;
      int oldCursorX     = parent_node.pv_block_end_cursor_x;

      // Save block end position
      parent_node.pv_block_end_pat_offset   = _patOffset;
      parent_node.pv_block_end_cursor_track = getCurrentTrackNr();
      parent_node.pv_block_end_cursor_x     = cursor_x;

      // Auto-expand selection depending on block mode
      if(-1 != parent_node.pv_block_start_pat_offset)
      {
         if(verifyBlockStartAndEnd())
            swapBackBlockStartAndEnd();
      }
      else
      {
         blockEndAutoExpand();
      }

      if(_bAllowCancel)
      {
         // Discard selection if lctrl-e is pressed twice at the same cursor position
         if( (oldPatOffset   == parent_node.pv_block_end_pat_offset)   &&
             (oldCursorTrack == parent_node.pv_block_end_cursor_track) &&
             (oldCursorX     == parent_node.pv_block_end_cursor_x)
             )
         {
            selectNone();
            return;
         }
      }

      if(!b_block_quiet)
         Global.Print("set block end to (offset="+parent_node.pv_block_end_pat_offset+" track="+parent_node.pv_block_end_cursor_track+" x="+parent_node.pv_block_end_cursor_x+")");
   }

   // <ui_selection.png>
   public method selectNone() {
      ////trace "[dbg] PatternView::selectNone";
      parent_node.selectNoneRaw();
      blockAncCancel();
   }

   // <ui_selection.png>
   public =replay= method blockQuantizeEx(int _forceQuantTickRange, int _minTicksThreshold, float _amount, boolean _bWrapAround, boolean _bUndoBegin) : int {
      // Quantize block (v2, w/ extended settings)
      //
      //    forceQuantTickRange: always quantize when quantized tick distance is <= range (fix small timing deviations, possibly keep larger ones)
      //      minTicksThreshold: quantize only when quantized tick distance is >= threshold (keep small timing deviations)
      //                 amount: quantization strength (0..1 => 0..100%)
      //            bWrapAround: move quantized events to pattern start when they would otherwise be moved beyond the end of the pattern
      //
      // returns: number of quantized events (0=no change)
      //

      if(_forceQuantTickRange > (step_resolution/2))
         _forceQuantTickRange = (step_resolution/2);

      if(_bUndoBegin)
         parent_node.undoBeginNested("patternBlockQuantizeEx");

      boolean bAutoSelectAll = !parent_node.haveSelection();

      if(bAutoSelectAll)
         blockSelectCurrentPattern();

      int numQuantizedEv = 0;

      if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
      {
         // Swap start/end if necessary
         verifyBlockStartAndEnd();

         int trackNr = parent_node.pv_block_start_cursor_track;
         int cursorX = parent_node.pv_block_start_cursor_x;

         int mpatNumTicks = parent_node.getCurrentEditMetaPatternLength();
         local Envelope envNew;
         int blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;

         local IntArray ctlDoneList;

         while(trackNr <= parent_node.pv_block_end_cursor_track)
         {
            NT_Track track <= parent_node.getTrack(trackNr);
            NT_TEL   tel   <= track.getTrackLayout();
            int              numCursorX = tel.num_cursor_positions;

            if(trackNr == parent_node.pv_block_end_cursor_track)
            {
               numCursorX = parent_node.pv_block_end_cursor_x + 1;
            }

            NT_TrackPattern pat <= track.getCurrentEditPattern();
            if(null != pat)
            {
               ctlDoneList.empty();

               while(cursorX < numCursorX)
               {
                  int ctlMapId = tel.cursor_to_ctl_map[cursorX];
                  NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                  int ctlId = cel.ctl_id;

                  // // trace "xxx trackNr="+trackNr+" cursorX="+cursorX+" cel mapId="+ctlMapId+" ctlId="+ctlId;

                  if(!ctlDoneList.contains(ctlId))
                  {
                     ctlDoneList.add(ctlId);

                     Envelope env <= pat.getEnvelope(ctlId);
                     if(null != env)
                     {
                        int envTimeOrig = env.time;
                        envNew.empty();
                        envNew.speed = env.speed;
                        envNew.interpolation = env.interpolation;

                        int numEv = env.numElements / 2;
                        int evIdx = 0;
                        int patOff = 0;
                        int numQ = 0;
                        int lastInsertOff = 0;
                        int dt;

                        loop(numEv)
                        {
                           patOff += env[evIdx + 0];
                           float v = env[evIdx + 1];

                           if((patOff < parent_node.pv_block_start_pat_offset) ||
                              (patOff >= blockEndOff)
                              )
                           {
                              // Copy as-is
                              dt = patOff - lastInsertOff;
                              envNew.add(dt);
                              envNew.add(v);
                              lastInsertOff = patOff;
                           }
                           else
                           {
                              // Quantize
                              int qPatOff = ( (patOff+step_resolution/2) / step_resolution) * step_resolution;
                              boolean bKeep = true;

                              if(patOff != qPatOff)
                              {
                                 int dist = qPatOff - patOff;
                                 int distAbs = abs(dist);
                                 boolean bForceHardQuant = (distAbs <= _forceQuantTickRange);

                                 if( bForceHardQuant ||
                                     (distAbs >= _minTicksThreshold)
                                     )
                                 {
                                    if(!bForceHardQuant)
                                       qPatOff = patOff + dist * _amount;

                                    if(patOff != qPatOff)
                                    {
                                       if(_bWrapAround && (qPatOff >= mpatNumTicks))
                                          qPatOff -= mpatNumTicks;

                                       // Insert quantized event in new envelope
                                       dt = qPatOff - lastInsertOff;
                                       envNew.add(dt);
                                       envNew.add(v);
                                       lastInsertOff = qPatOff;
                                       bKeep = false;

                                       numQ++;
                                    }
                                 }
                              }

                              if(bKeep)
                              {
                                 // Already quantized, or skipped
                                 dt = patOff - lastInsertOff;
                                 envNew.add(dt);
                                 envNew.add(v);
                                 lastInsertOff = patOff;
                              }
                           }

                           // Next event
                           evIdx += 2;
                        }

                        if(numQ > 0)
                        {
                           if(!parent_node.b_block_no_undo)
                              parent_node.undoTouchController(track, parent_node.edit_pattern_nr, ctlId, env);

                           // Replace envelope
                           env = envNew;
                           env.time = envTimeOrig;

                           numQuantizedEv += numQ;
                        }

                     } // if env
                  } // if !ctl done

                  cursorX++;

               } // loop cursor positions

            } // if pat

            cursorX = 0;
            trackNr++;

         } // iterate tracks

         if(_bUndoBegin)
            parent_node.undoEndNested("patternBlockQuantizeEx");

         ta_redraw_all.scheduleShort();

         if(bAutoSelectAll)
            selectNone();

         Global.Print("Quantize block ("+numQuantizedEv+" event"+Utils.GetPluralString(numQuantizedEv)+")");

      } // if selection

      return numQuantizedEv;
   }

   // <ui_handle.png>
   public method blockQuantizeAmt(float _amount) {
      blockQuantizeEx(0/*forceQuantTickRange*/,
                      0/*minTicksThreshold*/,
                      _amount,
                      false/*bWrapAround*/,
                      true/*bUndoBegin*/
                      );
   }

   // <ui_show.png>
   public method showQuantizeDialog() {
      if(null == dlg_quantize)
      {
         dlg_quantize <= new NT_QuantizeDialog();
         if(!dlg_quantize.init())
         {
            trace "[---] NT_PatternView::showQuantizeDialog: failed to init NT_QuantizeDialog";
            return false;
         }
      }
      dlg_quantize.showQuantizeDialog(parent_editor, this, parent_node);
   }

   // <ui_handle.png>
   public method blockQuantizeMethod(int _method) {
      STConfig.node_tracker_quantization_last_method = _method;
      switch(_method)
      {
         case 0:
            showQuantizeDialog();
            break;

         case 1:
            blockQuantizeAmt(1.0);
            break;

         case 2:
            blockQuantizeAmt(0.5);
            break;

         case 3:
            blockQuantizeAmt(0.25);
            break;
      }
   }

   // <ui_handle.png>
   public method blockQuantizeLastMethod() {
      blockQuantizeMethod(STConfig.node_tracker_quantization_last_method);
   }

   // <ui_handle.png>
   public =replay= method blockSortNotes() {

      parent_node.undoBeginNested("blockSortNotes");
      int numSorted = 0;

      if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
      {
         // Swap start/end if necessary
         verifyBlockStartAndEnd();

         int trackNr = parent_node.pv_block_start_cursor_track;
         int blockStartOff = (parent_node.pv_block_start_pat_offset / step_resolution) * step_resolution;
         int blockEndOff = (parent_node.pv_block_end_pat_offset / step_resolution) * step_resolution + step_resolution;

         local ValueArray vaNote;
         local FloatArray aNote;
         local FloatArray aVel;
         local FloatArray aDur;
         local IntArray aSorted;

         while(trackNr <= parent_node.pv_block_end_cursor_track)
         {
            NT_Track track <= parent_node.getTrack(trackNr);
            NT_TEL   tel   <= track.getTrackLayout();

            NT_TrackPattern pat <= track.getCurrentEditPattern();
            if(null != pat)
            {
               int patOff = blockStartOff;
               while(patOff < blockEndOff)
               {
                  vaNote.empty();
                  aNote.empty();
                  aVel.empty();
                  aDur.empty();

                  int noteIdx = 0;
                  loop(NT_TrackPattern.NUM_NOTESLOTS)
                  {
                     if(tel.findVisibleCelForCtlById(NT_TrackPattern.CTL_NOTE1 + noteIdx))
                     {
                        vaNote.add(#(parent_node.getEventAt(track, NT_TrackPattern.CTL_NOTE1 + noteIdx, patOff, step_resolution)));
                        if(YAC_TYPE_FLOAT == typeid(vaNote.last))
                        {
                           aNote.add(vaNote.last);
                           aVel.add(parent_node.getVelocityAt(track, noteIdx, patOff, step_resolution));
                           aDur.add(parent_node.getDurationAt(track, noteIdx, patOff, step_resolution));
                        }
                     }
                     else
                        vaNote.addVoid();

                     // Next note slot
                     noteIdx++;
                  }

                  if(aNote.numElements > 0)
                  {
                     aNote.sortByValue(aSorted);
                     int sortIdx = 0;
                     noteIdx = 0;
                     loop(NT_TrackPattern.NUM_NOTESLOTS)
                     {
                        // trace "xxx    vaNote.get(noteIdx="+noteIdx+")="+#(vaNote.get(noteIdx));
                        if(YAC_TYPE_FLOAT == typeid(vaNote.get(noteIdx)))
                        {
                           int sortedIdx = aSorted[sortIdx];

                           int insertOff = parent_node.fixOffsetToExistingEventAtWindow(NT_TrackPattern.CTL_NOTE1 + noteIdx, patOff, step_resolution);
                           parent_node.insertReplaceEventAtRes(track, NT_TrackPattern.CTL_NOTE1 + noteIdx, aNote[sortedIdx], insertOff, step_resolution);

                           if(tel.findVisibleCelForCtlById(NT_TrackPattern.CTL_VEL1 + noteIdx))
                           {
                              insertOff = parent_node.fixOffsetToExistingEventAtWindow(NT_TrackPattern.CTL_VEL1 + noteIdx, patOff, step_resolution);
                              parent_node.insertReplaceEventAtRes(track, NT_TrackPattern.CTL_VEL1 + noteIdx,  aVel[sortedIdx], insertOff, step_resolution);
                           }

                           if(tel.findVisibleCelForCtlById(NT_TrackPattern.CTL_DUR1 + noteIdx))
                           {
                              insertOff = parent_node.fixOffsetToExistingEventAtWindow(NT_TrackPattern.CTL_DUR1 + noteIdx, patOff, step_resolution);
                              parent_node.insertReplaceEventAtRes(track, NT_TrackPattern.CTL_DUR1 + noteIdx,  aDur[sortedIdx], insertOff, step_resolution);
                           }

                           numSorted++;
                           sortIdx++;
                        }

                        // Next note slot
                        noteIdx++;
                     }
                  }

                  // Next step
                  patOff += step_resolution;
               }
            }

            // Next track
            trackNr++;
         }

         parent_node.undoEndNested("blockSortNotes");

         ta_redraw_all.scheduleShort();

         Global.Print("Sort "+numSorted+" note"+Utils.GetPluralString(numSorted));

      } // if selection
   }

   // <ui_selection.png>
   public =replay= method blockClear() {

      parent_node.undoBeginNested("patternBlockClear");

      boolean bAutoSelectAll = !parent_node.haveSelection();
      if(bAutoSelectAll)
         blockSelectCurrentPattern();

      int numClearedEv = 0;

      if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
      {
         // Swap start/end if necessary
         verifyBlockStartAndEnd();

         int trackNr = parent_node.pv_block_start_cursor_track;
         int cursorX = parent_node.pv_block_start_cursor_x;

         while(trackNr <= parent_node.pv_block_end_cursor_track)
         {
            NT_Track track <= parent_node.getTrack(trackNr);
            NT_TEL   tel   <= track.getTrackLayout();
            int              numCursorX = tel.num_cursor_positions;

            if(trackNr == parent_node.pv_block_end_cursor_track)
               numCursorX = parent_node.pv_block_end_cursor_x + 1;

            while(cursorX < numCursorX)
            {
               int ctlMapId = tel.cursor_to_ctl_map[cursorX];
               NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
               int ctlId = cel.ctl_id;

               // // trace "xxx trackNr="+trackNr+" cursorX="+cursorX+" cel mapId="+ctlMapId+" ctlId="+ctlId;

               int blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;
               int patOff = blockEndOff - 1;

               var e;
               while(patOff >= parent_node.pv_block_start_pat_offset)
               {
                  e = parent_node.getEventAt(track, ctlId, patOff, 1);

                  if(typeid(e) == YAC_TYPE_FLOAT)
                  {
                     // Remove step
                     parent_node.removeEventAt(track, ctlId, patOff, 1);
                     parent_node.shiftEventsAt(track, ctlId, patOff, 1);

                     numClearedEv++;
                  }
                  patOff--;
               }

               cursorX++;

            } // loop cursor positions

            cursorX = 0;
            trackNr++;

         } // iterate tracks

         parent_node.undoEndNested("patternBlockClear");

         ta_redraw_all.scheduleShort();

         if(bAutoSelectAll)
            selectNone();

         Global.Print("Clear block ("+numClearedEv+" event"+Utils.GetPluralString(numClearedEv)+")");

      } // if selection

   }

   // <ui_selection.png>
   public =replay= method blockTranspose(float _delta) {

      if(isEditable())
      {
         boolean bAutoSelectAll = false;

         parent_node.undoBeginNested("patternBlockTranspose");

         if( (-1 == parent_node.pv_block_start_pat_offset) || (-1 == parent_node.pv_block_end_pat_offset) )
         {
            // Select current pattern if no block selection exists
            blockSelectCurrentPattern();
            bAutoSelectAll = true;
         }

         if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
         {
            // Swap start/end if necessary
            verifyBlockStartAndEnd();

            int trackNr = parent_node.pv_block_start_cursor_track;
            int cursorX = parent_node.pv_block_start_cursor_x;

            while(trackNr <= parent_node.pv_block_end_cursor_track)
            {
               NT_Track track <= parent_node.getTrack(trackNr);
               NT_TEL   tel   <= track.getTrackLayout();
               int              numCursorX = tel.num_cursor_positions;

               if(trackNr == parent_node.pv_block_end_cursor_track)
                  numCursorX = parent_node.pv_block_end_cursor_x + 1;

               while(cursorX < numCursorX)
               {
                  int ctlMapId = tel.cursor_to_ctl_map[cursorX];
                  NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                  int ctlId = cel.ctl_id;

                  int blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;
                  int patOff = blockEndOff - 1;

                  if(NT_TrackPattern.CTL_NOTE1 <= ctlId <= NT_TrackPattern.CTL_NOTE5)
                  {
                     var e;
                     boolean bClipped = false;

                     // Dry-run, check if any value is clipped
                     while(patOff >= parent_node.pv_block_start_pat_offset)
                     {
                        e = parent_node.getEventAt(track, ctlId, patOff, 1);

                        if(typeid(e) == YAC_TYPE_FLOAT)
                        {
                           if(e < 0)
                           {
                              e -= _delta; // Note off
                              bClipped |= (e >= 0) || (e < -127);
                           }
                           else
                           {
                              e += _delta; // Note on
                              bClipped |= (e < 0) || (e > 127);
                           }

                           if(bClipped)
                              break;
                        }
                        patOff--;
                     }

                     if(!bClipped)
                     {
                        patOff = blockEndOff - 1;

                        // Transpose
                        while(patOff >= parent_node.pv_block_start_pat_offset)
                        {
                           e = parent_node.getEventAt(track, ctlId, patOff, 1);

                           if(typeid(e) == YAC_TYPE_FLOAT)
                           {
                              if(e < 0)
                                 e -= _delta; // Note off
                              else
                                 e += _delta; // Note on

                              parent_node.insertReplaceEventAtRes(track, ctlId, e, patOff, 1);
                           }
                           patOff--;
                        }
                     }
                  }

                  cursorX++;

               } // loop cursor positions

               cursorX = 0;
               trackNr++;

            } // iterate tracks

            ta_redraw_all.scheduleShort();

         } // if selection

         if(bAutoSelectAll)
            selectNone();

         parent_node.undoEndNested("patternBlockTranspose");

         Global.SuccessShort("block transposed "+((_delta > 0) ? "up" : "down"));

      } // if isEditable
      else
      {
         Global.Warning("block transpose failed: please change edit mode.");
      }
   }

   // <ui_selection.png>
   public =replay= method blockNegHarmony(int _key) {

      if(isEditableNoFocus())
      {
         boolean bAutoSelectAll = false;
         int numChanged = 0;

         parent_node.undoBeginNested("patternBlockNegHarmony");

         if( (-1 == parent_node.pv_block_start_pat_offset) || (-1 == parent_node.pv_block_end_pat_offset) )
         {
            // Select current pattern if no block selection exists
            blockSelectCurrentPattern();
            bAutoSelectAll = true;
         }

         if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
         {
            // Swap start/end if necessary
            verifyBlockStartAndEnd();

            int trackNr = parent_node.pv_block_start_cursor_track;
            int cursorX = parent_node.pv_block_start_cursor_x;

            while(trackNr <= parent_node.pv_block_end_cursor_track)
            {
               NT_Track track <= parent_node.getTrack(trackNr);
               NT_TEL   tel   <= track.getTrackLayout();
               int              numCursorX = tel.num_cursor_positions;

               if(trackNr == parent_node.pv_block_end_cursor_track)
                  numCursorX = parent_node.pv_block_end_cursor_x + 1;

               while(cursorX < numCursorX)
               {
                  int ctlMapId = tel.cursor_to_ctl_map[cursorX];
                  NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                  int ctlId = cel.ctl_id;

                  int blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;
                  int patOff = blockEndOff - 1;

                  if(NT_TrackPattern.CTL_NOTE1 <= ctlId <= NT_TrackPattern.CTL_NOTE5)
                  {
                     var e;
                     patOff = blockEndOff - 1;

                     // Negative Harmony
                     while(patOff >= parent_node.pv_block_start_pat_offset)
                     {
                        e = parent_node.getEventAt(track, ctlId, patOff, 1);

                        if(typeid(e) == YAC_TYPE_FLOAT)
                        {
                           if(-127 <= e <= 127)
                           {
                              if(e < 0)
                              {
                                 // Note off
                                 e = -Scale.NegativeHarmony(-e, _key);
                              }
                              else
                              {
                                 // Note on
                                 e = Scale.NegativeHarmony(e, _key);
                              }
                              numChanged++;
                           }

                           parent_node.insertReplaceEventAtRes(track, ctlId, e, patOff, 1);
                        }
                        patOff--;
                     }
                  }

                  cursorX++;

               } // loop cursor positions

               cursorX = 0;
               trackNr++;

            } // iterate tracks

            ta_redraw_all.scheduleShort();

         } // if selection

         if(bAutoSelectAll)
            selectNone();

         parent_node.undoEndNested("patternBlockNegHarmony");

         Global.SuccessShort("negative harmony: modified "+numChanged+" note"+Utils.GetPluralString(numChanged));

      } // if isEditable
      else
      {
         Global.Warning("block negative harmony failed: please change edit mode.");
      }
   }

   // <ui_selection.png>
   public =replay= method blockRandCtl(float _min, float _max, int _type) {
      // type: 0=abs, 1=delta, 2=rel

      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         boolean bAutoSelectAll = !parent_node.haveSelection();

         if(bAutoSelectAll)
            blockSelectCurrentPattern();

         if(parent_node.haveSelection())
         {
            // Swap start/end if necessary
            verifyBlockStartAndEnd();

            NT_CEL cel <= getCurrentControllerLayout();
            if(null != cel)
            {
               int numChanged = 0;
               int ctlId = cel.ctl_id;

               int blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;
               int patOff = blockEndOff - 1;
               var e;

               float clipMin = cel.getMinVal();
               float clipMax = cel.getMaxVal();

               parent_node.undoBeginNested("patternBlockRandCtl");

               while(patOff >= parent_node.pv_block_start_pat_offset)
               {
                  e = parent_node.getEventAt(track, ctlId, patOff, 1);

                  if(typeid(e) == YAC_TYPE_FLOAT)
                  {
                     if(e >= 0)
                     {
                        switch(_type)
                        {
                           default:
                           case 1: // abs
                              trace "xxx rand(_max - _min)="+rand(_max - _min);
                              e = rand(_max - _min) + _min;
                              break;

                           case 2: // delta
                              e = rand(_max - _min) + _min + e;
                              break;

                           case 3: // rel
                              e = e * (rand(_max - _min) + _min);
                              break;
                        }

                        e = mathClampf(e, clipMin, clipMax);

                        parent_node.insertReplaceTrackEventAt(ctlId, e, patOff);

                        numChanged++;
                     }
                  }

                  patOff--;
               }

               ta_redraw_all.scheduleShort();

               parent_node.undoEndNested("patternBlockRandCtl");

               Global.Print("randomize ctl: randomized "+numChanged+" value"+Utils.GetPluralString(numChanged));
            } // if cel
         } // if haveSelection

         if(bAutoSelectAll)
            selectNone();

      } // if track
   }

   // <ui_selection.png>
   public =replay= method blockIncDecCurrentCtl(int _dir, boolean _bCoarse) {

      // (note) caller must start/stop undo transaction

      if(isEditable())
      {
         NT_CEL cursorCel <= getCurrentControllerLayout();

         if(null != cursorCel)
         {
            if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
            {
               // Swap start/end if necessary
               verifyBlockStartAndEnd();

               float delta;
               if(_bCoarse)
                  delta = STConfig.node_tracker_incdec_coarse_deltas.get(cursorCel.ctl_id);
               else
                  delta = STConfig.node_tracker_incdec_fine_deltas.get(cursorCel.ctl_id);

               boolean bClipped = false;

               int trackNr = parent_node.pv_block_start_cursor_track;
               int cursorX = parent_node.pv_block_start_cursor_x;

               NT_Track *track;
               NT_TEL   *tel;
               int               numCursorX;
               NT_CEL   *cel;
               int               ctlMapId;
               int               ctlId;
               int blockEndOff;
               int patOff;
               var e;
               boolean bNegative;
               float ePreClip;
               local IntArray ctlIdDone;

               // Dry-run: Check for clipping
               while(trackNr <= parent_node.pv_block_end_cursor_track)
               {
                  track <= parent_node.getTrack(trackNr);
                  tel   <= track.getTrackLayout();
                  numCursorX = tel.num_cursor_positions;

                  if(trackNr == parent_node.pv_block_end_cursor_track)
                     numCursorX = parent_node.pv_block_end_cursor_x + 1;

                  while(cursorX < numCursorX)
                  {
                     ctlMapId = tel.cursor_to_ctl_map[cursorX];
                     cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG

                     if(cel.typeMatches(cursorCel))
                     {
                        ctlId = cel.ctl_id;

                        if(!ctlIdDone.contains(ctlId))
                        {
                           ctlIdDone.add(ctlId);

                           blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;
                           patOff = blockEndOff - 1;

                           boolean bChange;

                           while(patOff >= parent_node.pv_block_start_pat_offset)
                           {
                              e = parent_node.getEventAt(track, ctlId, patOff, 1);

                              if(typeid(e) == YAC_TYPE_FLOAT)
                              {
                                 bNegative = (e <  0);

                                 if(cel.isNoteCtl())
                                    bChange = (e > NT_TrackPattern.MAGIC_NOTE_ALLTRACKNOTESOFF);
                                 else
                                    bChange = true;

                                 if(bChange)
                                 {
                                    if(bNegative) // Note Off
                                    {
                                       e = e - abs(delta) * _dir;
                                    }
                                    else
                                    {
                                       e = e + abs(delta) * _dir;
                                    }

                                    ePreClip = e;

                                    if(bNegative)
                                    {
                                       if(e >= 0)
                                          e = -1;
                                    }
                                    else if(e < 0)
                                       e = 0;

                                    e = cel.clipCtlValue(e);

                                    bClipped |= (e != ePreClip);

                                    if(bClipped)
                                       break;
                                 }
                              } // if is float

                              patOff--;
                           } // while patOff
                        } // !ctlId done
                     } // if typeMatches(cursorCel)

                     cursorX++;

                  } // loop cursor positions

                  cursorX = 0;
                  trackNr++;

               } // iterate tracks

               if(!bClipped)
               {
                  trackNr = parent_node.pv_block_start_cursor_track;
                  cursorX = parent_node.pv_block_start_cursor_x;

                  // Transpose / shift
                  int totalNumEvents = 0;

                  while(trackNr <= parent_node.pv_block_end_cursor_track)
                  {
                     track <= parent_node.getTrack(trackNr);
                     tel   <= track.getTrackLayout();
                     numCursorX = tel.num_cursor_positions;

                     if(trackNr == parent_node.pv_block_end_cursor_track)
                        numCursorX = parent_node.pv_block_end_cursor_x + 1;

                     ctlIdDone.empty();

                     while(cursorX < numCursorX)
                     {
                        ctlMapId = tel.cursor_to_ctl_map[cursorX];
                        cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG

                        if(cel.typeMatches(cursorCel))
                        {
                           ctlId = cel.ctl_id;

                           if(!ctlIdDone.contains(ctlId))
                           {
                              ctlIdDone.add(ctlId);

                              blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;
                              patOff = blockEndOff - 1;

                              while(patOff >= parent_node.pv_block_start_pat_offset)
                              {
                                 e = parent_node.getEventAt(track, ctlId, patOff, 1);

                                 if(typeid(e) == YAC_TYPE_FLOAT)
                                 {
                                    if(cel.isNoteCtl())
                                    {
                                       bChange = (e > NT_TrackPattern.MAGIC_NOTE_ALLTRACKNOTESOFF);
                                    }
                                    else
                                    {
                                       bChange = true;
                                    }

                                    if(bChange)
                                    {
                                       bNegative = (e <  0);

                                       if(bNegative) // Note Off
                                       {
                                          e = e - abs(delta) * _dir;
                                       }
                                       else
                                       {
                                          e = e + abs(delta) * _dir;
                                       }

                                       parent_node.insertReplaceEventAtRes(track, ctlId, e, patOff, 1);

                                       totalNumEvents++;
                                    }

                                 } // if is float

                                 patOff--;
                              } // while patOff
                           } // !ctlId done
                        } // if typeMatches(cursorCel)

                        cursorX++;

                     } // loop cursor positions

                     cursorX = 0;
                     trackNr++;

                  } // iterate tracks

                  ta_redraw_all.scheduleShort();

                  Global.SuccessShort("block inc/dec: shift "+totalNumEvents+" event(s) "+((delta < 0) ? "up" : "down"));
               }
               else
               {
                  Global.Warning("block inc/dec: clipped");
               }

            } // if selection

         } // if cursorCel
         else
         {
            Global.Warning("block inc/dec failed: no cursor cel (no pattern?).");
         }
      } // if isEditable
      else
      {
         Global.Warning("block inc/dec failed: please change edit mode.");
      }
   }

   // <ui_selection.png>
   public =replay= method blockScaleCurrentCtl(float _factor) {

      // (note) invert ctl when factor is negative
      // (note) don't touch alltracknotesoff(===) and allchannelnotesoff(###) events
      // (note) clip durations to min=1 unless the duration was 0 (inf)
      // (note) never convert note-ons to noteoffs and vice versa
      // (note) handle ctl bias (e.g. pitchbend)

      NT_CEL cursorCel <= getCurrentControllerLayout();

      if(null != cursorCel)
      {
         boolean bAutoSelectAll = !parent_node.haveSelection();

         if(bAutoSelectAll)
            blockSelectCurrentPattern();

         if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
         {
            // Swap start/end if necessary
            verifyBlockStartAndEnd();

            int trackNr = parent_node.pv_block_start_cursor_track;
            int cursorX = parent_node.pv_block_start_cursor_x;

            NT_Track *track;
            NT_TEL   *tel;
            int               numCursorX;
            NT_CEL   *cel;
            int               ctlMapId;
            int               ctlId;
            int blockEndOff;
            int patOff;
            var e;
            local IntArray ctlIdDone;

            parent_node.undoBeginNested("patternBlockScaleCurrentCtl");

            trackNr = parent_node.pv_block_start_cursor_track;
            cursorX = parent_node.pv_block_start_cursor_x;

            // Transpose / shift
            int totalNumEvents = 0;

            while(trackNr <= parent_node.pv_block_end_cursor_track)
            {
               track <= parent_node.getTrack(trackNr);
               tel   <= track.getTrackLayout();
               numCursorX = tel.num_cursor_positions;

               if(trackNr == parent_node.pv_block_end_cursor_track)
               {
                  numCursorX = parent_node.pv_block_end_cursor_x + 1;
               }

               while(cursorX < numCursorX)
               {
                  ctlMapId = tel.cursor_to_ctl_map[cursorX];
                  cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG

                  if(cel.typeMatches(cursorCel))
                  {
                     ctlId = cel.ctl_id;

                     if(!ctlIdDone.contains(ctlId))
                     {
                        ctlIdDone.add(ctlId);

                        blockEndOff = parent_node.pv_block_end_pat_offset + step_resolution;
                        patOff = blockEndOff - 1;
                        boolean bChange;

                        float celBias = cel.getValueBias();

                        // (todo) iterate events, not ticks
                        while(patOff >= parent_node.pv_block_start_pat_offset)
                        {
                           e = parent_node.getEventAt(track, ctlId, patOff, 1);

                           if(typeid(e) == YAC_TYPE_FLOAT)
                           {
                              if(cel.isNoteCtl())
                              {
                                 bChange = (e > NT_TrackPattern.MAGIC_NOTE_ALLTRACKNOTESOFF);
                              }
                              else
                              {
                                 bChange = true;
                              }

                              if(bChange)
                              {
                                 if(e <  0) // Note Off
                                 {
                                    if(e >= -127)  // not === or ### ?
                                    {
                                       e = cel.clipCtlValue(e * abs(_factor));
                                    }
                                 }
                                 else
                                 {
                                    if(_factor >= 0)
                                    {
                                       if(cel.isDurCtl() && (e > 0))
                                       {
                                          e = e * _factor;
                                          if(e < 1)
                                             e = 1;
                                       }
                                       else
                                       {
                                          e = cel.clipCtlValue(((e - celBias) * _factor) + celBias);
                                       }
                                    }
                                    else
                                    {
                                       // Invert
                                       if(cel.isDurCtl() && (e > 0))
                                       {
                                          e = e * abs(_factor);
                                          if(e < 1)
                                             e = 1;
                                       }
                                       else
                                       {
                                          e = cel.clipCtlValue(cel.getMaxVal() - (((e - celBias) * -_factor) + celBias));
                                       }
                                    }
                                 }

                                 parent_node.insertReplaceEventAtRes(track, ctlId, e, patOff, 1);

                                 totalNumEvents++;
                              }

                           } // if is float

                           patOff--;
                        } // while patOff
                     } // !ctlIdDone
                  } // if typeMatches(cursorCel)

                  cursorX++;

               } // loop cursor positions

               cursorX = 0;
               trackNr++;

            } // iterate tracks

            parent_node.undoEndNested("patternBlockScaleCurrentCtl");

            ta_redraw_all.scheduleShort();

            Global.SuccessShort("block scale ctl: scaled "+totalNumEvents+" event"+Utils.GetPluralString(totalNumEvents)+" by "+_factor);

         } // if selection

         if(bAutoSelectAll)
            selectNone();

      } // if cursorCel
      else
      {
         Global.Warning("block scale ctl: no cursor cel (no pattern?).");
      }
   }

   // <ui_selection.png>
   public =replay= method blockShiftUpRes(int _res, boolean _bAllowScroll, boolean _bQuiet) : boolean {

      // (note) bAllowScroll is true when called from lctrl-lshift-UP/DOWN/LEFT/RIGHT
      // (note) bAllowScroll is false when called from timing view mouse drag

      if(isEditable())
      {
         if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
         {
            // Swap start/end if necessary
            verifyBlockStartAndEnd();

            NT_Track *track;
            NT_TEL *tel;
            NT_CEL *cel;
            int numCursorX;
            int trackNr;
            int cursorX;
            int ctlMapId;
            int ctlId;
            int patOff;
            // // int blockEndOff;
            int relPatTime;
            int relPatTimeEnd;
            NT_TrackPattern *pat;
            int patNr;
            Envelope *env;
            var e;

            // Calc shifted block position
            relPatTime = parent_node.pv_block_start_pat_offset - _res;

            if(relPatTime < 0)
            {
               // Unable to shift up
               if(!_bQuiet)
                  Global.Error("unable to shift block up (pattern start hit)");
               return false;
            }

            // Calc block end offset in relative pattern time
            relPatTimeEnd = parent_node.pv_block_end_pat_offset/* + step_resolution*/;

            if(_bAllowScroll)
            {
               if(1 == _res)
                  relPatTimeEnd += step_resolution - 1;
            }
            else
            {
               relPatTimeEnd -= (_res -1);
            }


            //
            // Check whether shift up is possible
            //

            trackNr = parent_node.pv_block_start_cursor_track;
            cursorX = parent_node.pv_block_start_cursor_x;

            while(trackNr <= parent_node.pv_block_end_cursor_track)
            {
               track <= parent_node.getTrack(trackNr);
               tel   <= track.getTrackLayout();
               numCursorX = tel.num_cursor_positions;

               if(trackNr == parent_node.pv_block_end_cursor_track)
               {
                  numCursorX = parent_node.pv_block_end_cursor_x + 1;
               }

               // Get track pattern
               patNr = parent_node.nodeGetCurrentEditPatternNr();
               pat <= track.getPattern(patNr);
               if(null != pat)
               {
                  // Loop block cursor positions for current track
                  while(cursorX < numCursorX)
                  {
                     ctlMapId = tel.cursor_to_ctl_map[cursorX];
                     cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                     ctlId = cel.ctl_id;

                     env <= pat.getEnvelope(ctlId);
                     if(null != env)
                     {
                        e = env.valueAtTimeRaster(relPatTime, _res);
                        if(YAC_TYPE_VOID != typeid(e))
                        {
                           // Unable to shift up (event already exists at shifted position)
                           Global.Error("unable to shift block up since an event already exists at shifted position");
                           return false;
                        }
                     }

                     // Next cursor position
                     cursorX = cel.getNextCelCursorPosition(cursorX, ctlMapId);

                  } // loop track cursor positions

               } // if null != pat

               // Next track
               trackNr++;

               cursorX = 0;

            } // loop tracks

            //
            // Ok, shift up is possible.
            //

            parent_node.undoBeginNested("patternBlockShiftUp");

            trackNr = parent_node.pv_block_start_cursor_track;
            cursorX = parent_node.pv_block_start_cursor_x;

            while(trackNr <= parent_node.pv_block_end_cursor_track)
            {
               track <= parent_node.getTrack(trackNr);
               tel   <= track.getTrackLayout();
               numCursorX = tel.num_cursor_positions;

               if(trackNr == parent_node.pv_block_end_cursor_track)
               {
                  numCursorX = parent_node.pv_block_end_cursor_x + 1;
               }

               // Get track pattern
               patNr = parent_node.nodeGetCurrentEditPatternNr();
               pat  <= track.getPattern(patNr);
               if(null != pat)
               {
                  // Loop block cursor positions for current track
                  while(cursorX < numCursorX)
                  {
                     ctlMapId = tel.cursor_to_ctl_map[cursorX];
                     cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                     ctlId = cel.ctl_id;

                     env <= pat.getEnvelope(ctlId);
                     if(null != env)
                     {
                        // Shift events up
                        if(env.numElements > 0)
                        {
                           parent_node.undoTouchController(track.track_nr, patNr, ctlId, env);

                           // Shift events up
                           env.removeRange(relPatTime, _res);

                           // Shift events after block end down
                           env.shiftEvents(relPatTimeEnd, _res);
                        }
                     }

                     // Next cursor position
                     cursorX = cel.getNextCelCursorPosition(cursorX, ctlMapId);

                  } // loop track cursor positions

               } // if null != pat

               // Next track
               trackNr++;
               cursorX = 0;

            } // loop tracks

            parent_node.undoEndNested("patternBlockShiftUp");

            ta_redraw_all.scheduleShort();

            parent_node.pv_block_start_pat_offset -= _res;
            parent_node.pv_block_end_pat_offset -= _res;

            if(step_resolution == _res)
            {
               if(_bAllowScroll)
                  scrollUp();
            }
            else
            {
               ta_redraw_all.scheduleShort();
            }

            if(!_bQuiet)
            {
               if(_res != step_resolution)
               {
                  int blShift = parent_node.pv_block_start_pat_offset - (parent_node.pv_block_start_pat_offset / step_resolution) * step_resolution;
                  Global.SuccessShort("block shifted up (+"+blShift+")");
               }
               else
               {
                  Global.SuccessShort("block shifted up");
               }
            }

            return true;

         } // if have block

      } // isEditable?
      else
      {
         if(!_bQuiet)
            Global.Warning("block shift up failed: please change edit mode.");
      }
      return false;
   }

   // <ui_selection.png>
   public method blockShiftUp() : boolean {
      return blockShiftUpRes(step_resolution, true/*bAllowScroll*/, false/*bQuiet*/);
   }

   // <ui_selection.png>
   public =replay= method blockShiftDownRes(int _res, boolean _bAllowScroll, boolean _bQuiet)  : boolean {

      if(isEditable())
      {
         if( (-1 != parent_node.pv_block_start_pat_offset) && (-1 != parent_node.pv_block_end_pat_offset) )
         {
            // Swap start/end if necessary
            verifyBlockStartAndEnd();

            NT_Track *track;
            NT_TEL *tel;
            NT_CEL *cel;
            int numCursorX;
            int trackNr;
            int cursorX;
            int ctlMapId;
            int ctlId;
            int patOff;
            // // int blockEndOff;
            int relPatTime;
            int relPatTimeEnd;
            NT_TrackPattern *pat;
            int patNr;
            int patLen;
            Envelope *env;
            var e;

            // Calc shifted block position
            relPatTime = parent_node.pv_block_start_pat_offset + _res;

            // Calc shifted block end offset in relative pattern time
            relPatTimeEnd = parent_node.pv_block_end_pat_offset + (_bAllowScroll ? step_resolution : 1);

            patLen = parent_node.getCurrentEditMetaPatternLength();


            //
            // Check whether shift down is possible
            //

            if(relPatTimeEnd >= patLen)
            {
               // Unable to shift down
               if(!_bQuiet)
                  Global.Error("unable to shift block down (pattern end hit)");
               return false;
            }

            trackNr = parent_node.pv_block_start_cursor_track;
            cursorX = parent_node.pv_block_start_cursor_x;

            while(trackNr <= parent_node.pv_block_end_cursor_track)
            {
               track <= parent_node.getTrack(trackNr);
               tel   <= track.getTrackLayout();
               numCursorX = tel.num_cursor_positions;

               if(trackNr == parent_node.pv_block_end_cursor_track)
                  numCursorX = parent_node.pv_block_end_cursor_x + 1;

               // Get track pattern
               patNr = parent_node.nodeGetCurrentEditPatternNr();
               pat  <= track.getPattern(patNr);
               if(null != pat)
               {
                  // Loop block cursor positions for current track
                  while(cursorX < numCursorX)
                  {
                     ctlMapId = tel.cursor_to_ctl_map[cursorX];
                     cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                     ctlId = cel.ctl_id;

                     env <= pat.getEnvelope(ctlId);
                     if(null != env)
                     {
                        e = env.valueAtTimeRaster(relPatTimeEnd, _res);
                        if(YAC_TYPE_VOID != typeid(e))
                        {
                           // Unable to shift down (event already exists at shifted position)
                           if(!_bQuiet)
                              Global.Error("unable to shift block down since an event already exists at shifted position");
                           return false;
                        }
                     }

                     // Next cursor position
                     cursorX = cel.getNextCelCursorPosition(cursorX, ctlMapId);

                  } // loop track cursor positions

               } // if pat != null

               // Next track
               trackNr++;
               cursorX = 0;

            } // loop tracks

            //
            // Ok, shift down is possible.
            //

            parent_node.undoBeginNested("patternBlockShiftDown");

            trackNr = parent_node.pv_block_start_cursor_track;
            cursorX = parent_node.pv_block_start_cursor_x;

            while(trackNr <= parent_node.pv_block_end_cursor_track)
            {
               track <= parent_node.getTrack(trackNr);
               tel   <= track.getTrackLayout();
               numCursorX = tel.num_cursor_positions;

               if(trackNr == parent_node.pv_block_end_cursor_track)
               {
                  numCursorX = parent_node.pv_block_end_cursor_x + 1;
               }

               // Get track pattern
               patNr = parent_node.nodeGetCurrentEditPatternNr();
               pat  <= track.getPattern(patNr);
               if(null != pat)
               {
                  // Loop block cursor positions for current track
                  while(cursorX < numCursorX)
                  {
                     ctlMapId = tel.cursor_to_ctl_map[cursorX];
                     cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
                     ctlId = cel.ctl_id;

                     env <= pat.getEnvelope(ctlId);
                     if(null != env)
                     {
                        // Shift events down
                        if(env.numElements > 0)
                        {
                           parent_node.undoTouchController(track.track_nr, patNr, ctlId, env);

                           // Shift events down
                           env.shiftEvents(relPatTime - _res, _res);

                           // Shift events after block end up
                           env.removeRange(relPatTimeEnd + _res, _res);
                        }
                     }

                     // Next cursor position
                     cursorX = cel.getNextCelCursorPosition(cursorX, ctlMapId);

                  } // loop track cursor positions

               } // if null != pat

               // Next track
               trackNr++;
               cursorX = 0;

            } // loop tracks

            parent_node.undoEndNested("patternBlockShiftDown");

            ta_redraw_all.scheduleShort();

            parent_node.pv_block_start_pat_offset += _res;
            parent_node.pv_block_end_pat_offset += _res;

            if(step_resolution == _res)
            {
               if(_bAllowScroll)
                  scrollDown();
            }
            else
            {
               // // parent_node.setEditOffset(parent_node.getEditOffset() + _res);
               ta_redraw_all.scheduleShort();
            }

            if(!_bQuiet)
            {
               if(_res != step_resolution)
               {
                  int blShift = parent_node.pv_block_start_pat_offset - (parent_node.pv_block_start_pat_offset / step_resolution) * step_resolution;
                  Global.SuccessShort("block shifted down (+"+blShift+")");
               }
               else
               {
                  Global.SuccessShort("block shifted down");
               }
            }

            return true;

         } // if have block

      } // isEditable?
      else
      {
         if(!_bQuiet)
            Global.Warning("block shift down failed: please change edit mode.");
      }
      return false;
   }

   // <ui_selection.png>
   public method blockShiftDown()  : boolean {
      return blockShiftDownRes(step_resolution, true/*bAllowScroll*/, false/*bQuiet*/);
   }

   // <ui_selection.png>
   public =replay= method blockCopy() {
      // Copy block to (pattern) clipboard

      if(parent_node.haveSelection())
      {
         verifyBlockStartAndEnd();

         int uiTotalNumEvents = parent_node.blockCopyRaw(step_resolution);

         b_block_in_clipboard = true;

         if(!b_block_quiet)
            Global.Print("block copied to clipboard ("+(NodeTracker.GetClipboardBlockLength())+" ticks, "+uiTotalNumEvents+" events)");
      }
      else
      {
         // No selection, copy entire pattern
         parent_editor.cmd_pattern_copy(true/*bInvBlock*/);
      }
   }

   // <ui_selection.png>
   =replay= public method blockPaste(boolean _bShift, boolean _bUndoStartEnd, boolean _bScrollDown) {
      // Paste (pattern) clipboard at current cursor position, shift all following events

      if(-1 == NodeTracker.GetClipboardBlockLength())
      {
         parent_editor.cmd_pattern_paste();
         return;
      }

      int totalNumTracks = parent_node.tracks.numElements;

      // // trace "xxx PatternView::blockPaste() totalNumTracks="+totalNumTracks+" block_length="+(NodeTracker.GetClipboardBlockLength())+" bShift="+_bShift;

      if(0 == totalNumTracks)
         return;

      if(-1 != NodeTracker.GetClipboardBlockLength())
      {
         if(_bUndoStartEnd)
            parent_node.undoBeginNested("patternBlockPaste");

         int cursorX = cursor_x;
         int trackNr = getCurrentTrackNr();

         // Align cursor_x to track start or pattern start, depending on blockmode
         switch(block_mode)
         {
            default:
            case BLOCK_MODE_CTL:
               // no alignment
               break;

            case BLOCK_MODE_TRACK:
               // align to start of track
               cursorX = 0;
               break;

            case BLOCK_MODE_PATTERN:
               // align to start of pattern
               cursorX = 0;
               trackNr = 0;
               break;
         }

         int tStart = milliSeconds();
         int uiTotalNumEvents = parent_node.blockPasteRaw(trackNr, cursorX, _bShift);
         // trace "xxx blockPasteRaw() took "+(milliSeconds()-tStart)+"ms";  // ==> [22Mar2020] now ~0..1 ms instead of up to several thousand

         int editOffset = parent_node.getEditOffset();

         if(cursor_x == parent_node.pv_block_start_cursor_x)
         {
            if(parent_node.pv_block_start_pat_offset < editOffset < parent_node.pv_block_end_pat_offset)
            {
               selectNone();
            }
            else if( (editOffset == (parent_node.pv_block_start_pat_offset+(NodeTracker.GetClipboardBlockLength()))) )
            {
               parent_node.pv_block_start_pat_offset += NodeTracker.GetClipboardBlockLength();
               parent_node.pv_block_end_pat_offset   += NodeTracker.GetClipboardBlockLength();
            }
         }

         parent_node.setEditOffset(editOffset + (NodeTracker.GetClipboardBlockLength() - step_resolution));

         if(_bScrollDown)
            scrollDownEventEntered();

         if(_bUndoStartEnd)
         {
            parent_node.undoEndNested("patternBlockPaste");

            if(!b_block_quiet)
               Global.Print("block pasted from clipboard ("+NodeTracker.GetClipboardBlockLength()+" ticks, "+uiTotalNumEvents+" events) mode="+(_bShift?"INSERT":"REPLACE"));
         }

         ta_redraw_all.scheduleShort();
      }
   }

   // <ui_selection.png>
   =replay= protected method blockDelete(boolean _bShift, boolean _bUndoStartEnd) {
      // Delete all events in selected block, shift all following events if _bShift=true

      if(_bUndoStartEnd)
      {
         if(!isEditable())
         {
            Global.Warning("delete block failed: please change edit mode.");
            return;
         }
      }

      int totalNumTracks = parent_node.tracks.numElements;

      ////trace "xxx PatternView::blockDelete: totalNumTracks="+totalNumTracks+" bShift="+_bShift;

      if(0 == totalNumTracks)
         return;

      if(parent_node.haveSelection())
      {
         if(_bUndoStartEnd)
            parent_node.undoBeginNested("patternBlockDelete");

         verifyBlockStartAndEnd();
         int blkLen = parent_node.pv_block_end_pat_offset + step_resolution - parent_node.pv_block_start_pat_offset;
         // trace "xxx PatternView::blockDelete: block start="+parent_node.pv_block_start_pat_offset+" end="+parent_node.pv_block_end_pat_offset+" length="+blkLen;

         int trackNr = parent_node.pv_block_start_cursor_track;
         int cursorX = parent_node.pv_block_start_cursor_x;
         while(trackNr <= parent_node.pv_block_end_cursor_track)
         {
            //trace "xxx delete trackNr="+trackNr+"/"+totalNumTracks;

            NT_Track track <= parent_node.getTrack(trackNr);
            NT_TEL   tel   <= track.getTrackLayout();
            int              numCursorX = tel.num_cursor_positions;

            if(trackNr == parent_node.pv_block_end_cursor_track)
               numCursorX = parent_node.pv_block_end_cursor_x + 1;

            int lastCtlId = -1;

            while( (cursorX < numCursorX) )
            {
               int ctlMapId = tel.cursor_to_ctl_map[cursorX];
               NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
               int ctlId = cel.ctl_id;

               if(ctlId != lastCtlId)
               {
                  int blkEndOff = parent_node.pv_block_start_pat_offset + blkLen;

                  // Regular "single-digit" envelope
                  int patOff = parent_node.pv_block_start_pat_offset;

                  if(_bShift)
                  {
                     // Clear + Keep absolute time of events after block (shift back)
                     parent_node.deleteTrackEnvRegionAndShift(track, ctlId, patOff, blkLen);
                  }
                  else
                  {
                     // Clear + Move events after block up
                     parent_node.deleteTrackEnvRegion(track, ctlId, patOff, blkLen);
                  }

                  lastCtlId = ctlId;

               } // if ctlId != lastCtlId

               cursorX = cel.getNextCelCursorPosition(cursorX, ctlMapId);
            }

            cursorX = 0;
            trackNr++;
         }

         if(!b_block_quiet)
            Global.Print("block cleared ("+blkLen+" ticks) mode="+(_bShift?"OVERWRITE":"DELETE"));

         if(!_bShift)
            parent_node.setEditOffset(parent_node.pv_block_start_pat_offset);

         selectNone();

         if(_bUndoStartEnd)
            parent_node.undoEndNested("patternBlockDelete");

         ta_redraw_all.scheduleShort();
      }
   }

   // <ui_selection.png>
   protected =replay= method blockInterpol(int _type) {
      ////trace "xxx blockinterpol OK: interpolType="+_type;

      if(parent_node.haveSelection())
      {
         // Swap start/end if necessary
         verifyBlockStartAndEnd();

         NT_CEL cel <= getCurrentControllerLayout();
         if(null != cel)
         {
            int ctlId = cel.ctl_id;

            // Get start value
            var e = parent_node.getTrackEventAt(ctlId, parent_node.pv_block_start_pat_offset);
            if(typeid(e) != YAC_TYPE_FLOAT)
            {
               Global.Error("block interpolation: first step is empty");
               return;
            }
            float beginVal = e;

            // Get destination value
            e = parent_node.getTrackEventAt(ctlId, parent_node.pv_block_end_pat_offset);
            if(typeid(e) != YAC_TYPE_FLOAT)
            {
               Global.Error("block interpolation: last step is empty");
               return;
            }
            float endVal = e;

            // Interpolate steps
            int numSteps = (parent_node.pv_block_end_pat_offset - parent_node.pv_block_start_pat_offset) / step_resolution - 1;
            ////trace "xxx blockinterpol: numSteps="+numSteps+" beginVal="+beginVal+" endVal="+endVal;
            if(numSteps > 0)
            {
               parent_node.undoBeginNested("patternBlockInterpol");

               float range = (endVal - beginVal);
               float dt = 1.0 / (numSteps+1);
               float t  = dt;
               int coff = parent_node.pv_block_start_pat_offset + step_resolution;
               loop(numSteps)
               {
                  float cVal;
                  float rt = t;
                  switch(_type)
                  {
                     default:
                     case NT_BlockInterpolationDialog.IPOL_LINEAR:
                        break;

                     case NT_BlockInterpolationDialog.IPOL_SMOOTHSTEP:
                        rt = mathSmoothStepf(0, 1, rt);
                        break;

                     case NT_BlockInterpolationDialog.IPOL_COSINE:
                        rt = (1.0f - cos(PI * rt)) * 0.5;
                        break;

                     case NT_BlockInterpolationDialog.IPOL_SMOOTHSTEP_COSINE:
                        rt = mathSmoothStepf(0, 1, rt);
                        rt = (1.0f - cos(PI * rt)) * 0.5;
                        break;

                     case NT_BlockInterpolationDialog.IPOL_COSINE_SMOOTHSTEP:
                        rt = (1.0f - cos(PI * rt)) * 0.5;
                        rt = mathSmoothStepf(0, 1, rt);
                        break;

                     case NT_BlockInterpolationDialog.IPOL_RAND:
                        rt = rand(1.0);
                        break;
                  }

                  cVal = beginVal + rt * range;

                  parent_node.insertReplaceTrackEventAt(ctlId, cVal, coff);

                  coff += step_resolution;

                  // Next step
                  t += dt;
               }

               ta_redraw_all.scheduleShort();

               parent_node.undoEndNested("patternBlockInterpol");

               Global.Print("block interpolation: interpolated from "+beginVal+" to "+endVal+" in "+numSteps+" steps");
            }
         }
      }
   }

   // <ui_show.png>
   public method showBlockInterpolationDialog() {
      // called by Global.cmd_block_interpol
      if(parent_node.haveSelection())
      {
         dlg_blockinterpol.showCentered();
      }
      else
      {
         Global.Error("block interpolation: no block selected");
      }
   }

   // <ui_show.png>
   protected method showBlockContextMenu(boolean _bHaveSel, boolean _bFocusFirst) {
      // Create context-sensitive popupmenu
      pm_block <= PopupMenu.New(this);

      boolean bEdit = isEditable() && !replay.b_playing;

      PopupMenuButton *pmb;

      pmb <= pm_block.addDefaultButton("Copy", "block_copy");
      pmb.setActive(_bHaveSel);
      pmb.setAccelerators("lctrl-c", "");

      pmb <= pm_block.addDefaultButton("Paste (replace)", "block_pastereplace");
      pmb.setActive(bEdit && b_block_in_clipboard);
      pmb.setAccelerators("lctrl-v", "");

      pmb <= pm_block.addDefaultButton("Paste (insert)", "block_pasteinsert");
      pmb.setActive(bEdit && b_block_in_clipboard);
      pmb.setAccelerators("lshift-lctrl-v", "");

      pm_block.addSeparator();

      pmb <= pm_block.addDefaultButton("Quantize (again)", "block_quantize_last");
      pmb.setActive(_bHaveSel);
      pmb.setAccelerators("lshift-lctrl-a", "");

      pmb <= pm_block.addDefaultButton("Quantize (100%)", "block_quantize_100");
      pmb.setActive(_bHaveSel);

      pmb <= pm_block.addDefaultButton("Quantize (50%)", "block_quantize_50");
      pmb.setActive(_bHaveSel);

      pmb <= pm_block.addDefaultButton("Quantize (25%)", "block_quantize_25");
      pmb.setActive(_bHaveSel);

      pmb <= pm_block.addDefaultButton("Quantize..", "block_quantize_dialog");
      pmb.setActive(_bHaveSel);

      pm_block.addSeparator();
      pmb <= pm_block.addDefaultButton("Interpolate..", "block_interpolate");
      pmb.setActive(bEdit && _bHaveSel);
      pmb.setAccelerators("lctrl-x 1", "lctrl-i");

      pmb <= pm_block.addDefaultButton("Sort Notes", "block_sortnotes");
      pmb.setActive(bEdit && _bHaveSel);
      pmb.setAccelerators("lshift-s", "");
      pmb.setToolTipCaption("Sort notes (and velocity / duration) on each step in the selection");

      pm_block.addSeparator();
      pmb <= pm_block.addDefaultButton("Transpose up", "block_transposeup");
      pmb.setActive(bEdit && _bHaveSel);
      pmb.setAccelerators("lshift-f2", null);

      pmb <= pm_block.addDefaultButton("Transpose down", "block_transposedown");
      pmb.setActive(bEdit && _bHaveSel);
      pmb.setAccelerators("lshift-f1", null);

      // // pm_block.addSeparator();
      // // pmb <= pm_block.addDefaultButton("Select none", "block_selectnone");
      // // pmb.setActive(_bHaveSel);
      // // pmb.setAccelerators("lshift-lctrl-a", "");

      pm_block.showAtXY(UI.GetMouseX(), UI.GetMouseY());
      if(_bFocusFirst)
         pm_block.focusNextMenuItem();
   }

   // <ui_show.png>
   protected method showTrackContextMenu(MouseEvent _ev) {
      // Create context-sensitive track popupmenu

      int pos = getCursorXAtPixel(_ev.getMouseRelX());
      if(-1 != pos)
      {
         if(((pos>>16)&0xffff) == getCurrentTrackNr())
         {
            // Cursor track did not change, keep selected cel
            selectTrackAtPos((pos&0xffff0000) | cursor_x);
         }
         else
         {
            // Select new cursor track (and cel)
            selectTrackAtPos(pos);
         }

         NT_Track track <= getCurrentTrack();

         if(null != track)
         {
            trackmenu <= PopupMenu.New(this);

            PopupMenuButton *pmb;

            pmb <= trackmenu.addCheckButton("Mute", track.isMuted(), "track_togglemute");
            pmb.setAccelerators("lctrl-q", "");
            pmb <= trackmenu.addCheckButton("Solo", track.isSolo(), "track_togglesolo");
            pmb.setAccelerators("lctrl-w", "");

            trackmenu.addSeparator();
            pmb <= trackmenu.addDefaultButton("Rename..", "track_rename");
            pmb.setToolTipCaption("Rename track\n\n(note) For multi-line tracknames, use the ',' character to separate lines");

            trackmenu.addSeparator();
            pmb <= trackmenu.addDefaultButton("Delete..", "track_delete");

            trackmenu.addSeparator();
            pmb <= trackmenu.addDefaultButton("Edit layout..", "track_editlayout");
            pmb.setAccelerators(null, "lctrl-x s");

            pmb <= trackmenu.addDefaultButton("Add note cel", "track_addnotecel");
            pmb.setAccelerators(null, "lctrl-x n");
            NT_TEL tel <= track.getTrackLayout();
            pmb.setActive(tel.canAddNoteCel());

            pmb <= trackmenu.addDefaultButton("Select cel", "track_selectcel");
            pmb.setAccelerators(null, "lctrl-x SPACE");

            trackmenu.showAtXY(UI.GetMouseX(), UI.GetMouseY());

         } // if current track
      } // if mouse over track
   }

   // <method.png>
   protected method showAudioSampleSelectorAt(NT_Instrument _ins, int _editPatPos) : boolean {
      // (note) caller must ensure that 'ins' is an audio instrument and audio process is currently connected
      int vstDevIdx = _ins.getVSTOutDeviceIndex();
      Global.Debug2("NT_PatternView::showAudioSampleSelectorAt: find track for vstDevIdx="+vstDevIdx);
      if(vstDevIdx >= 0)
      {
         // Query samples
         SysEx.QueueSendQuerySamples(null/*namePattern*/, 5*12/*targetNote=C-5*/);
         if(SysEx.WaitForQuerySamples())
         {
            // Query tracks
            SysEx.QueueSendQueryTracks();
            if(SysEx.WaitForQueryTracks())
            {
               // Find track that matches output device/ch
               SysExTrack *syxTrack;
               foreach syxTrack in SysEx.queued_recv_tracks
               {
                  if(syxTrack.dev_idx == vstDevIdx)
                  {
                     if(-1 == syxTrack.midi_ch || syxTrack.midi_ch == _ins.midi_channel)
                     {
                        // Found track
                        Global.Debug2("NT_PatternView::showAudioSampleSelectorAt: found track \""+syxTrack.name+"\" vstDevIdx="+vstDevIdx+" chIdx="+syxTrack.midi_ch+" modSampleNSP="+syxTrack.modsample_namespace_id);

                        var e = parent_node.getTrackEventAt(NT_Defs.CTL_PC, _editPatPos);

                        if(null == audiosampleselector_sample_names)
                        {
                           audiosampleselector_sample_names <= new StringArray;
                           audiosampleselector_sample_ids   <= new IntArray;
                        }
                        else
                        {
                           audiosampleselector_sample_names.empty();
                           audiosampleselector_sample_ids  .empty();
                        }

                        float msPer16th = current_song.sixteenthToMilliSeconds(1.0);

                        // Find samples that match track's modsample_namespace_id
                        int curOptIdx = -1;
                        local Integer ioId;
                        SysExSample *syxSmp;
                        foreach syxSmp in SysEx.queued_recv_samples
                        {
                           if(syxSmp.namespace_id == syxTrack.modsample_namespace_id)
                           {
                              Global.Debug2("NT_PatternView::showAudioSampleSelectorAt: found sample \""+syxSmp.name+"\" prg="+syxSmp.prg_id+" uid="+syxSmp.unique_id);
                              float num16 = int(int(10 * (syxSmp.millisecs + msPer16th*0.5)) / msPer16th) / 10.0;
                              int optIdx = audiosampleselector_sample_names.numElements;
                              if(true == _ins.b_audio)
                              {
                                 // MIDI Program change mode
                                 if(syxSmp.prg_id == e)
                                    curOptIdx = optIdx;
                                 ioId = syxSmp.prg_id;
                                 audiosampleselector_sample_names.add(ioId.printf("Prg $%02x: \"")+syxSmp.name+"\"   \t"+num16+" 16ths, "+syxSmp.millisecs+"ms"+(syxSmp.b_stereo?" stereo":" mono"));
                                 audiosampleselector_sample_ids.add(syxSmp.prg_id);
                              }
                              else
                              {
                                 // RPN smp_uid mode
                                 if(syxSmp.unique_id == e)
                                    curOptIdx = optIdx;
                                 ioId = syxSmp.unique_id;
                                 audiosampleselector_sample_names.add(ioId.printf("RPN $%04x: \"")+syxSmp.name+"\"   \t"+num16+" 16ths, "+syxSmp.millisecs+"ms"+(syxSmp.b_stereo?" stereo":" mono"));
                                 audiosampleselector_sample_ids.add(syxSmp.unique_id);
                              }
                           }
                        }

                        if(!audiosampleselector_sample_names.isEmpty())
                        {
                           ComboBoxPopup cmp <= ComboBoxPopup.NewComboBoxPopup(this,
                                                                               null/*fontOrNull*/,
                                                                               audiosampleselector_sample_names,
                                                                               null/*optionsLongOrNull*/,
                                                                               curOptIdx,
                                                                               270*UI.font_scaling/*prefSx*/,
                                                                               null/*toolTipCaptions*/,
                                                                               null/*optionBGColors*/,
                                                                               null/*option_fgtints*/
                                                                               );

                           cmp.showNearMouse(4, 0);
                           cmp.centerRow();
                           cmp.focusFirstTabCycleMember();
                           cmp.setEnableHideOnFirstEntryUp(false);
                           cmp.setPageSize(4);
                           cmp_audiosampleselector <= deref cmp;

                           float px = getPixelXAtCursorPosition();
                           float py = getAbsolutePositionY() + calcCenterY() + 24*UI.font_scaling; // root window coordinates
                           cmp.moveToPosition2f(px, py);

                           audiosampleselector_editpatpos = _editPatPos;

                           return true;
                        }
                        else
                        {
                           Global.Warning("No samples found (vstDevIdx="+vstDevIdx+", ch="+(_ins.midi_channel+1)+" nsp="+syxTrack.modsample_namespace_id);
                        }

                     } // if match midich
                  } // if match dev
               } // loop tracks
            } // if query tracks
         } // if query samples
      }
      else
      {
         Global.Warning("Instrument out_device is not a VST output device");
      }
      return false;
   }

   // <ui_handle.png>
   protected method handleAudioSampleSelection(int _optIdx) {
      cmp_audiosampleselector <= null;

      NT_Track track <= parent_node.getTrack(getCurrentTrackNr());
      if(null != track)  // should not be null at this point
      {
         parent_node.undoBeginNested("audiosampleselection");

         local Integer io = audiosampleselector_sample_ids.get(_optIdx);
         parent_node.insertReplaceTrackEventAtRes(NT_Defs.CTL_PC,
                                                  io,
                                                  audiosampleselector_editpatpos,
                                                  step_resolution
                                                  );

         parent_node.undoEndNested("audiosampleselection");

         String s <= audiosampleselector_sample_names.get(_optIdx);
         Global.Print("Select sample "+(s.substring(0, s.indexOf("   \t", 0))));

         renderAndRedrawAll();
      }
   }

   // <method.png>
   public method showDetailEditAt(int editCursorTrack, int editCursorX, int editPatPos) {
      NT_Track track <= parent_node.getTrack(editCursorTrack);
      if(null != track)
      {
         NT_TEL tel <= track.getTrackLayout();
         if(null != tel)
         {
            int ctlMapId = tel.cursor_to_ctl_map[editCursorX];
            NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
            if(null != cel)
            {
               int ctlId = cel.ctl_id;

               detailedit_patpos = editPatPos;
               detailedit_ctlid   = cel.ctl_id;

               String ctlName <= getControllerName(track, ctlId);
//                trace("xxx songpos="+editSongPos+" Track: "+(editCursorTrack+1)+" Controller: "+cel.ctl_id+" ("+ctlName+")"+
//                      ((cel.style==ControllerEventLayout.STYLE_HEX)?(ctlMapId&TrackEventLayout.MSB_FLAG)?" [MSB]":" [LSB]":"")
//                      +".");

               var e = parent_node.getTrackEventAt(cel.ctl_id, editPatPos);

               if(parent_editor.isPatternEditable("cmd_edit_detail"))
               {
                  boolean bDone = false;
                  if(NT_TrackPattern.CTL_PC == ctlId)
                  {
                     if(SysEx.IsAudioConnected())
                     {
                        NT_Instrument ins <= parent_node.getInstrument(track.current_instrument_nr);
                        if(null != ins)
                        {
                           if(ins.b_audio)
                           {
                              showAudioSampleSelectorAt(ins, editPatPos);
                              bDone = true;
                           }
                        }
                     }
                  }
                  else if(NT_TrackPattern.CTL_INSTR == ctlId)
                  {
                     // (todo) show instrument selector
                  }
                  if(!bDone)
                  {
                     // Show FloatParam editor

                     float minVal = cel.getMinVal();
                     float maxVal = cel.getMaxVal();
                     float curVal = e;
                     float stepFine = 0.1;
                     float stepCoarse = 1.0;
                     int precision = 1000;
                     fp_detailedit.showEditor(minVal, maxVal, curVal,
                                              stepFine, stepCoarse,
                                              precision,
                                              false/*bMinEditable*/,
                                              !cel.isNoteCtl()/*bMaxEditable*/
                                              );

                     // Calc editor window position
                     float px = getPixelXAtCursorPosition();
                     float py = getAbsolutePositionY() + calcCenterY() + 24*UI.font_scaling; // root window coordinates

                     float sx = fp_detailedit.getSizeX();

                     // Clip to right screen border
                     if(px > (UI.viewport_width - sx))
                        px = UI.viewport_width - sx;

                     fp_detailedit.moveToPosition2f(px, py);

                     parent_node.undoBeginNested("detail edit cel");
                  }
               }

               return true;
            } // if cel
         } // if tel
      } // if track
   }

   // <method.png>
   public method showDetailEditAtCurrentPosition() {
      showDetailEditAt(getCurrentTrackNr(), cursor_x, parent_node.getEditOffset());
   }

   // <method.png>
   public =replay= method toggleNoteOffAtCursorOrShowDetailEdit() {
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
         NT_CEL cel <= tel.ctl_layouts[ctlMapId&31]; // mask out MSB_FLAG
         int editOffset = parent_node.getEditOffset();
         if(cel.isNoteCtl())
         {
            int patOffset = editOffset;

            var e = parent_node.getTrackEventAt(cel.ctl_id, editOffset);
            if(typeid(e) == YAC_TYPE_FLOAT)
            {
               parent_node.undoBeginNested("toggle noteoff");

               int recPatOffset = patOffset;
               Integer recRaster = step_resolution;
               recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

               parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, -float(e), recPatOffset, recRaster);

               renderPatPosition(patOffset, center_row);
               redrawCurrentRow();

               parent_node.undoEndNested("toggle noteoff");
            }
         }
         else
         {
            showDetailEditAt(getCurrentTrackNr(), cursor_x, editOffset);
         }
      }
   }

   // <method.png>
   public =replay= method toggleSlideAtCursor() {

      int numToggled = 0;

      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         NT_TrackPattern trackPat <= getCurrentPattern();
         if(null != trackPat)
         {
            NT_Track track <= getCurrentTrack();
            int editOffset = parent_node.getEditOffset();
            float durTicks = parent_node.dur_ticks_resetval;
            int patNr = parent_node.nodeGetCurrentEditPatternNr();
            NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();

            parent_node.undoBeginNested("toggle slide");

            int noteCelIdx = 0;
            loop(NT_TrackPattern.NUM_NOTESLOTS)
            {
               NT_CEL noteCel <= tel.findVisibleNoteCelByIdx(noteCelIdx);
               if(null != noteCel)
               {
                  int noteCtlId = noteCel.ctl_id;  // 0..4 => CTL_NOTE1...NOTE5

                  NT_CEL durCel <= tel.findVisibleDurCel(noteCtlId);
                  if(null != durCel)
                  {
                     var noteVal = parent_node.getTrackEventAt(noteCtlId, editOffset);
                     if(typeid(noteVal) == YAC_TYPE_FLOAT)
                     {
                        if(noteVal >= 0) // note-on ?
                        {
                           Envelope envNote <= trackPat.getEnvelope(noteCelIdx);
                           int noteTicks = envNote.getNextEventTimeAfter(editOffset);  // find exact position of note trig at cursor
                           int noteEvIdx = envNote.timeToIndex(noteTicks);
                           // trace "xxx editOffset="+editOffset+" noteVal="+noteVal+" noteTicks="+noteTicks+" noteEvIdx="+noteEvIdx;
                           if(noteEvIdx > 0)
                           {
                              noteEvIdx--;
                           }
                           else
                           {
                              // Wrap-around
                              int wrapNoteTicks = envNote.getPreviousEventTimeBefore(mpat.num_ticks);
                              // trace "xxx wrapNoteTicks="+wrapNoteTicks+" noteTicks="+noteTicks;
                              if(wrapNoteTicks != noteTicks)
                              {
                                 noteEvIdx = envNote.timeToIndex(wrapNoteTicks);
                              }
                              else
                              {
                                 // Only one note event, skip
                                 noteEvIdx = -1;
                              }
                           }

                           if(noteEvIdx >= 0)
                           {
                              int prevNoteTicks = envNote.indexToTime(noteEvIdx);
                              int tickDist = noteTicks - prevNoteTicks + 1;
                              if(tickDist < 0)
                                 tickDist += mpat.num_ticks; // wrap-around
                              int durDist = int( (tickDist + durTicks - 1) / durTicks );//// * durTicks;
                              var durVal = parent_node.getEventAt(track, durCel.ctl_id, prevNoteTicks, 1);
                              Envelope envDur <= trackPat.getEnvelope(durCel.ctl_id);

                              parent_node.undoTouchController(track.track_nr, patNr, durCel.ctl_id, envDur);

                              // trace "xxx  durVal="+durVal+" durDist="+durDist;
                              boolean bDefDur = true;
                              if(typeid(durVal) == YAC_TYPE_FLOAT)
                              {
                                 if(durVal < durDist)
                                    bDefDur = false;
                              }
                              else
                                 bDefDur = false;

                              if(bDefDur)
                              {
                                 // Slide off (reset to default duration)
                                 parent_node.insertReplaceEventAtRes(track, durCel.ctl_id, track.keyjazz_duration, prevNoteTicks, 1);
                              }
                              else
                              {
                                 // Slide on (increase duration of previous note)
                                 parent_node.insertReplaceEventAtRes(track, durCel.ctl_id, durDist, prevNoteTicks, 1);
                              }

                              // trace "xxx envDur.time="+envDur.time+" envDur.deltaTime="+envDur.deltaTime+" index="+envDur.currentIndex+"  pre time="+xxxDurAbsTime+" pre deltaTime="+xxxDurDeltaTime+" pre index="+xxxCurrentIndex;

                              numToggled++;
                           } // if noteEvIdx > 0
                        } // if noteVal > 0
                     } // if noteVal
                  } // if durCel

                  // Next note cel
                  noteCelIdx++;
               }
               else
               {
                  break;
               }
            } // loop noteslots

            parent_node.undoEndNested("toggle slide");

         } // if trackPat
      } // if tel

      Global.Print("Toggle "+numToggled+" slide"+Utils.GetPluralString(numToggled));

      if(numToggled > 0)
         queueRedrawAll();
   }

   // <method.png>
   public method toggleSlideOrSortNotes() {
      if(parent_node.haveSelection())
      {
         if(isEditable())
            blockSortNotes();
         else
            Global.Warning("sort notes failed. please change edit mode.");
      }
      else
      {
         if(isEditable())
            toggleSlideAtCursor();
         else
            Global.Warning("toggle slide failed. please change edit mode.");
      }
   }

   // <method.png>
   public =replay= method patternTimeMulConst(float _factor, boolean _bAllTracks) {

      Global.Debug("PatternView::patternTimeMulConst: factor="+_factor+" bAllTracks="+_bAllTracks+" isEditable="+isEditable());

      if(parent_node.tracks.numElements)
      {
         parent_node.undoBeginNested("patternTimeMulConst");

         int trackNr;
         int endTrackNr;

         if(_bAllTracks)
         {
            trackNr = 0;
            endTrackNr = parent_node.tracks.numElements - 1;
         }
         else
         {
            trackNr = getCurrentTrackNr();
            endTrackNr = trackNr;
         }

         int patNr = parent_node.nodeGetCurrentEditPatternNr();

         int minDt = 0;

         while(trackNr <= endTrackNr)
         {
            NT_Track track <= parent_node.tracks.get(trackNr);
            NT_TrackPattern pat <= track.getPattern(patNr);

            if(null != pat)
            {
               Envelope *env;
               int ctlId = 0;
               foreach env in pat.controllers
               {
                  if(null != env)
                  {
                     if(env.numElements)
                     {
                        parent_node.undoTouchController(track.track_nr, patNr, ctlId, env);

                        int envIdx = 0;
                        loop(env.numElements / 2)
                        {
                           int dt = env[envIdx];

                           dt *= _factor;

                           if(dt < 1)
                           {
                              if(envIdx > 0)
                              {
                                 // Delta-time scaling caused at least two envelope events to happen simultaneously ==> abort and undo
                                 parent_node.undoEndNested("patternTimeMulConst");
                                 parent_editor.cmd_edit_undo();
                                 Global.Error("delta time scaling aborted to prevent loss of events");
                                 return;
                              }
                           }

                           if(dt > 0)
                           {
                              if((dt < minDt) || (0 == minDt))
                                 minDt = dt;
                           }

                           env[envIdx] = dt;

                           // Next event
                           envIdx += 2;
                        }
                     } // if env has events
                  }
                  // Next controller envelope
                  ctlId++;
               }
            }
            // Next track
            trackNr++;
         }

         ta_redraw_all.scheduleShort();

         parent_node.undoEndNested("patternTimeMulConst");

         Global.Success("delta times of "+(_bAllTracks?"all tracks":"current track")+" scaled by "+_factor+". min delta-time is now "+minDt);

      } // if node has tracks
   }

   // <method.png>
   public method abortFreeDraw() {
      freedraw_cursor_track = -1;
      freedraw_deletemode   = false;

      parent_node.undoEndNested("freedraw ctl bar");
   }

   // <method.png>
   protected method freeDrawCtlBarAt(MouseEvent _ev, int _pos, boolean _bLeftButtonDown) : boolean {
      if(-1 == freedraw_cursor_track)
      {
         // Start free draw
         selectTrackAtPos(_pos);
         freedraw_cursor_track = (_pos>>16);
         freedraw_cursor_x     = (_pos&0xFFFF);
         freedraw_deletemode   = false;
         freedraw_last_patoffset = -1;
         freedraw_last_val     = 0.0f;
      }

      NT_Track track <= parent_node.getTrack(freedraw_cursor_track);
      if(null != track)
      {
         NT_TEL tel <= track.getTrackLayout();
         if(null != tel)
         {
            int ctlMapId = tel.cursor_to_ctl_map[freedraw_cursor_x];
            NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
            if(null != cel)
            {
               if( (NT_CEL.STYLE_BAR4  == cel.style) ||
                   (NT_CEL.STYLE_BAR8  == cel.style) ||
                   (NT_CEL.STYLE_BAR16 == cel.style) ||
                   (NT_CEL.STYLE_BAR32 == cel.style)
                   )
               {
                  int patPos = getPatPosAtMouseRelY(_ev.getMouseRelY(), null);
                  if(_ev.isLeftButtonDown())
                  {
                     // Delete event
                     freedraw_deletemode = true;
                     parent_node.removeTrackEventAt(cel.ctl_id, patPos);
                     parent_node.shiftTrackEventsAt(cel.ctl_id, patPos);
                  }
                  else if(!freedraw_deletemode)
                  {
                     // Insert/replace event
                     Object cursorOffSize <= getColumnExtents(freedraw_cursor_track, freedraw_cursor_x);
                     int cursorOff = cursorOffSize[0];
                     int cursorSize = cursorOffSize[1];
                     float v;
                     float rx = mathClampf((_ev.mouse_rel_x - cursorOff) / (cursorSize-1), 0, 1);
                     switch(cel.range)
                     {
                        case NT_CEL.RANGE_0_255:
                        case NT_CEL.RANGE_M128_P127:
                           v = rx * 255;
                           break;
                        case NT_CEL.RANGE_0_127:
                        case NT_CEL.RANGE_M64_P63:
                           v = rx * 127;
                           break;
                        case NT_CEL.RANGE_BINARY_127:
                           v = (rx >= 0.5) ? 127 : 0;
                           break;
                        case NT_CEL.RANGE_BINARY_255:
                           v = (rx >= 0.5) ? 255 : 0;
                           break;
                     }

                     int recPatOffset;
                     Integer recRaster;

                     ////trace "xxx freeDrawCtlBarAt: cursorOff="+cursorOff+" cursorSize="+cursorSize+" rx="+rx+" v="+v;
                     if(-1 != freedraw_last_patoffset)
                     {
                        if( abs(patPos - freedraw_last_patoffset) > step_resolution )
                        {
                           // Interpolate
                           int numSteps = (patPos - freedraw_last_patoffset) / step_resolution;
                           int interpolOff = freedraw_last_patoffset;
                           float interpolVal = freedraw_last_val;
                           float interpolAdd = (v - freedraw_last_val) / abs(numSteps);
                           int interpolStep = (freedraw_last_patoffset > patPos) ? -step_resolution : step_resolution;
                           while(interpolOff != patPos)
                           {
                              recRaster = step_resolution;
                              recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, interpolOff, recRaster);

                              parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, interpolVal, recPatOffset, recRaster);

                              interpolVal += interpolAdd;
                              interpolOff += interpolStep;
                           }
                        }
                     }

                     recPatOffset = patPos;
                     recRaster = step_resolution;
                     recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                     parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, v, recPatOffset, recRaster);

                     freedraw_last_patoffset = patPos;
                     freedraw_last_val = v;

                     Global.Print("Trk "+freedraw_cursor_track+" Ctl "+cel.ctl_id+" ("+getControllerName(track, cel.ctl_id)+") value changed to "+v);
                  }

                  ta_redraw_all.scheduleShort();

                  return true;
               }

            } // if cel
         } // if tel
      } // if track

      freedraw_cursor_track = -1;
      parent_node.undoEndNested("freedraw ctl bar");
      return false;
   }

   // <method.png>
   public method setPatternLength(int _ticks) {
      // called by NT_SetPatternLengthDialog
      int patNr = parent_node.nodeGetCurrentEditPatternNr();
      NT_MetaPattern mpat <= parent_node.getOrCreateMetaPattern(patNr);
      mpat.setNumTicks(_ticks);
      queueRedrawAll();
   }

   // <method.png>
   public method setPatternLengthWithUndo(int _ticks) {
      parent_node.undoBeginNested("change pattern length");
      parent_node.undoTouchPattern(parent_node.nodeGetCurrentEditPatternNr());

      setPatternLength(_ticks);

      parent_node.undoEndNested("change pattern length");
   }

   // <method.png>
   public method getPatternLength() : int {
      return parent_node.getCurrentEditMetaPatternLength();
   }

   // <method.png>
   public method doublePattern(boolean _bCopy) {
      // called via cmd_pattern_double()

      int cLen = getPatternLength();

      if(cLen > 0)
      {
         int numTracks = getNumTracks();

         if(numTracks > 0)
         {
            parent_node.undoBeginNested("double pattern");

            int patNr = parent_node.nodeGetCurrentEditPatternNr();

            // Double pattern length
            int nLen = cLen * 2;

            parent_node.undoTouchPattern(patNr);

            setPatternLength(nLen);

            if(_bCopy)
            {
               // Copy first half into clipboard
               int oldBlockMode = block_mode;
               block_mode = BLOCK_MODE_PATTERN;

               parent_node.pv_block_start_pat_offset = 0;
               parent_node.pv_block_start_cursor_track = 0;
               parent_node.pv_block_start_cursor_x = 0;

               parent_node.pv_block_end_pat_offset = cLen-1;
               parent_node.pv_block_end_cursor_track = numTracks - 1;
               parent_node.pv_block_end_cursor_x = 0;

               blockEndAutoExpand();

               blockCopy();

               int oldEditOffset = parent_node.getEditOffset();
               int oldEditMode = parent_node.pv_edit_mode;
               parent_node.pv_edit_mode = NodeTracker.PV_EDIT_STEP;
               parent_node.setEditOffset(cLen);
               blockPaste(true/*bShift*/, false/*bUndoStartEnd*/, true/*bScrollDown*/);
               parent_node.pv_edit_mode = oldEditMode;

               block_mode = oldBlockMode;
               selectNone();
               parent_node.setEditOffset(oldEditOffset);
            }

            parent_node.undoEndNested("double pattern");

            parent_editor.updatePatLen();
         }
         else
         {
            Global.Warning("Pattern has no tracks");
         }
      }
      else
      {
         Global.Warning("Pattern has zero length");
      }
   }

   // <method.png>
   public method patternReverse(boolean _bPattern) {
      // called via cmd_pattern_reverse() / cmd_track_reverse()
      int cLen = getPatternLength();

      int numSteps = cLen / step_resolution;

      if(numSteps > 1)
      {
         int numTracks = getNumTracks();

         if(numTracks > 0)
         {
            parent_node.undoBeginNested("reverse pattern");

            int patNr = parent_node.nodeGetCurrentEditPatternNr();

            int oldEditOff = parent_node.getEditOffset();
            int oldEditMode = parent_node.pv_edit_mode;
            int oldBlockMode = block_mode;
            if(_bPattern)
               block_mode = BLOCK_MODE_PATTERN;
            else
               block_mode = BLOCK_MODE_TRACK;
            Key k;
            k.mod = VMOD_LSHIFT;

            parent_node.pv_edit_mode = NodeTracker.PV_EDIT_STEP;

            b_block_quiet = true;

            int sOff = 0;
            int dOff = (numSteps -1) * step_resolution;

            while(dOff > sOff)
            {
               // Copy upper step to clipboard
               NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);
               parent_node.setEditOffset(sOff);
               blockAncTryBegin(k);
               blockAncTryUpdate(k);
               blockCopy();
               selectNone();

               // Copy lower step to clipboard
               NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
               parent_node.setEditOffset(dOff);
               blockAncTryBegin(k);
               blockAncTryUpdate(k);
               blockCopy();
               selectNone();

               // Copy lower to upper step
               parent_node.setEditOffset(sOff);
               blockPaste(false/*bShift*/, false/*bUndoStartEnd*/, true/*bScrollDown*/);

               // Copy upper to lower step
               NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);
               parent_node.setEditOffset(dOff);
               blockPaste(false/*bShift*/, false/*bUndoStartEnd*/, true/*bScrollDown*/);

               // On to next step
               sOff += step_resolution;
               dOff -= step_resolution;
            }

            // Restore edit offset/mode/clipboard
            parent_node.setEditOffset(oldEditOff);
            parent_node.pv_edit_mode = oldEditMode;
            block_mode = oldBlockMode;
            NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);

            b_block_quiet = false;

            parent_node.undoEndNested("reverse pattern");
         }
      }
   }

   // <method.png>
   public method patternRotateUp(boolean _bPattern) {
      if(isEditable())
      {
         // called via cmd_pattern_rotate_up()
         int cLen = getPatternLength();

         int numSteps = cLen / step_resolution;

         if(numSteps > 1)
         {
            int numTracks = getNumTracks();

            if(numTracks > 0)
            {
               parent_node.undoBeginNested("rotate pattern up");

               int patNr = parent_node.nodeGetCurrentEditPatternNr();

               int oldEditOff = parent_node.getEditOffset();
               int oldEditMode = parent_node.pv_edit_mode;
               int oldBlockMode = block_mode;
               if(_bPattern)
                  block_mode = BLOCK_MODE_PATTERN;
               else
                  block_mode = BLOCK_MODE_TRACK;
               Key k;
               k.mod = VMOD_LSHIFT;

               parent_node.pv_edit_mode = NodeTracker.PV_EDIT_STEP;

               b_block_quiet = true;

               // Copy first step to clipboard
               NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
               parent_node.setEditOffset( 0 );
               blockAncTryBegin(k);
               blockAncTryUpdate(k);
               blockCopy();

               // Delete first step
               blockDelete(false/*bShift*/, false/*bUndoStartEnd*/);
               selectNone();

               // Copy first step (in clipboard) to last step
               parent_node.setEditOffset(step_resolution * (numSteps - 1));
               blockPaste(true/*bShift*/, false/*bUndoStartEnd*/, false/*bScrollDown*/);

               // Restore edit offset/mode/clipboard
               parent_node.setEditOffset(oldEditOff);
               parent_node.pv_edit_mode = oldEditMode;
               block_mode = oldBlockMode;
               NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);

               b_block_quiet = false;

               parent_node.undoEndNested("rotate pattern up");

               cur_rotate_count--;

               Global.Print("Rotate up ("+cur_rotate_count+")");
            }
         }
      }
      else
      {
         Global.Warning("Rotate pattern up failed: please change edit mode");
      }
   }

   // <method.png>
   public method patternRotateDown(boolean _bPattern) {
      // called via cmd_pattern_rotate_down()
      if(isEditable())
      {
         int cLen = getPatternLength();

         int numSteps = cLen / step_resolution;

         if(numSteps > 1)
         {
            int numTracks = getNumTracks();

            if(numTracks > 0)
            {
               parent_node.undoBeginNested("rotate pattern down");

               int patNr = parent_node.nodeGetCurrentEditPatternNr();

               int oldEditOff = parent_node.getEditOffset();
               int oldEditMode = parent_node.pv_edit_mode;
               int oldBlockMode = block_mode;
               if(_bPattern)
                  block_mode = BLOCK_MODE_PATTERN;
               else
                  block_mode = BLOCK_MODE_TRACK;
               Key k;
               k.mod = VMOD_LSHIFT;

               parent_node.pv_edit_mode = NodeTracker.PV_EDIT_STEP;

               b_block_quiet = true;

               // Copy last step to clipboard
               NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
               parent_node.setEditOffset( (numSteps - 1) * step_resolution);
               blockAncTryBegin(k);
               blockAncTryUpdate(k);
               blockCopy();

               // Delete last step
               blockDelete(false/*bShift*/, false/*bUndoStartEnd*/);
               selectNone();

               // Copy last step (in clipboard) to first step
               parent_node.setEditOffset(0);
               blockPaste(true/*bShift*/, false/*bUndoStartEnd*/, false/*bScrollDown*/);

               // Restore edit offset/mode/clipboard
               parent_node.setEditOffset(oldEditOff);
               parent_node.pv_edit_mode = oldEditMode;
               block_mode = oldBlockMode;
               NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);

               b_block_quiet = false;

               parent_node.undoEndNested("rotate pattern down");

               cur_rotate_count++;

               Global.Print("Rotate down ("+cur_rotate_count+")");
            }
         }
      }
      else
      {
         Global.Warning("Rotate pattern down failed: please change edit mode");
      }
   }

   // <method.png>
   protected =replay= method getRecordPatOffsetEditor(local boolean _bMayQuantize) : int {
      local int patOffset;

      if(!replay.b_playing || !parent_node.doAutoScroll())
      {
         // Use quantized edit cursor offset
         patOffset = parent_node.getEditOffset();
      }
      else
      {
         patOffset = parent_node.getRecordPatOffsetMidiRec(_bMayQuantize, false/*bForceReplayPos*/, true/*bFramePlay*/);
      }

      return patOffset;
   }

   // <method.png>
   public method calcDelayTicks() {

      NT_CEL cel <= getCurrentControllerLayout();
      if(null != cel)
      {
         boolean bUsr = NT_TrackPattern.CTL_USR <= cel.ctl_id < (NT_TrackPattern.CTL_USR + NT_TrackPattern.CTL_NUMUSR);
         if(!bUsr)
            bUsr = (cel.ctl_id == NT_TrackPattern.CTL_DELAY);  // nodetracker track delay
         if(!bUsr)
            bUsr = (cel.ctl_id == NT_TrackPattern.CTL_GROOVE); // pipe delay

         NT_Track destTrack <= getCurrentTrack();
         NT_Track *track;

         if(!bUsr)
         {
            // Find first cel that is mapped to param that contains substring "dly" or "delay"
            foreach track in parent_node.tracks
            {
               NT_TEL tel <= track.getTrackLayout();
               NT_Instrument kjIns <= parent_node.getInstrument(track.keyjazz_instr_nr);
               cel <= tel.findVisibleUsrCelWithNameSubstring(kjIns, "dly");

               if(null == cel)
                  cel <= tel.findVisibleUsrCelWithNameSubstring(kjIns, "delay");

               if(null != cel)
               {
                  bUsr = NT_TrackPattern.CTL_USR <= cel.ctl_id < (NT_TrackPattern.CTL_USR + NT_TrackPattern.CTL_NUMUSR);
                  if(bUsr)
                  {
                     destTrack <= track;
                     break;
                  }
               }
            }
         }

         if(bUsr)
         {
            int patOff = 0;

            NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();

            int numEv = 0;

            if(null != mpat)
            {
               if(mpat.num_ticks > 0)
               {
                  track <= getCurrentTrack();

                  parent_node.undoBeginNested("calcdelayticks");

                  while(patOff < mpat.num_ticks)
                  {
                     Integer retRaster = step_resolution;
                     int alignOff = parent_node.alignOffsetToFirstTrackEventAtWindow(track, patOff, retRaster);

                     if(alignOff != patOff)
                     {
                        parent_node.insertReplaceEventAtRes(destTrack, cel.ctl_id, (alignOff - patOff), patOff, step_resolution);
                        numEv++;
                     }
                     else
                     {
                        parent_node.insertReplaceEventAtRes(destTrack, cel.ctl_id, 0.0f, patOff, step_resolution);
                        numEv++;
                     }

                     patOff += step_resolution;
                  }

                  parent_node.undoEndNested("calcdelayticks");
               }
            }

            if(numEv > 0)
               ta_redraw_all.scheduleShort();

            Global.Print("CalcDelayTicks: wrote "+numEv+" event(s)");
         }
         else
         {
            Global.Warning("CalcDelayTicks: please place cursor on USR or DELAY cel");
         }
      }

   }

   // <method.png>
   public =replay= method collapse(boolean _bUndo) {

      NT_Track track <= getCurrentTrack();

      if(null != track)
      {
         if(_bUndo)
            parent_node.undoBeginNested("collapse");
         else
            parent_node.undoDisable();

         int origEditPatNr = parent_node.nodeGetCurrentEditPatternNr();
         int origEditOff = parent_node.getEditOffset();

         int lastTrackIdx = (parent_node.tracks.numElements) - 1;
         NT_Track lastTrack <= parent_node.tracks.get(lastTrackIdx);
         NT_TEL lastTEL <= lastTrack.getTrackLayout();
         int lastTrackCursorX = lastTEL.num_cursor_positions - 1;

         if(_bUndo)
            parent_node.undoTouchPattern(origEditPatNr);

         // Init and clear tmp pattern
         parent_editor.selectPatternByIdx(origEditPatNr);
         parent_editor.cmd_pattern_copy(true/*bInvBlock*/);
         parent_editor.selectPatternByIdx(Node.TMP_PAT_NR/*126*/);
         parent_editor.cmd_pattern_paste();  // paste meta (patlen)
         parent_node.nodeFreePatternTrackData(Node.TMP_PAT_NR/*126*/);

         NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
         int curDstTicks = 0;
         int curSrcTicks = 0;
         parent_node.setEditOffset(0);
         b_block_quiet = true;
         Key k;
         k.mod = VMOD_LSHIFT;
         int origBlockMode = block_mode;
         block_mode = BLOCK_MODE_PATTERN;

         // Iterate all tracks and find next note event
         boolean bEventFound;

         parent_editor.selectPatternByIdx(origEditPatNr);

         int numCollapsed = 0;

         do
         {
            int nearestEventOff = 999999;

            bEventFound = false;

            foreach track in parent_node.tracks
            {
               int noteIdx = 0;

               NT_TrackPattern pat <= track.patterns.get(origEditPatNr);

               loop(NT_TrackPattern.NUM_NOTESLOTS)
               {
                  Envelope env <= pat.controllers.get(noteIdx);

                  if(null != env)
                  {
                     int nextEvOff = env.getNextEventTimeAfter(curSrcTicks);

                     if(-1 != nextEvOff)
                     {
                        if(nextEvOff < nearestEventOff)
                        {
                           nearestEventOff = nextEvOff;
                           bEventFound = true;
                        }
                     }
                  }

                  noteIdx++;
               }
            }

            if(bEventFound)
            {
               Global.Debug("NTPV::collapse: event found, curSrcTicks="+curSrcTicks+" nearestEventOff="+nearestEventOff);

               parent_node.nodeSetCurrentEditPatternNr(origEditPatNr);
               parent_node.blockSelectPatRangeRaw(nearestEventOff, 0/*startTrack*/, 0/*startX*/,
                                                  nearestEventOff+step_resolution, lastTrackIdx, lastTrackCursorX
                                                  );
               blockCopy();

               parent_node.nodeSetCurrentEditPatternNr(Node.TMP_PAT_NR/*tmp=126*/);
               parent_node.setEditOffset(curDstTicks);
               parent_node.blockPasteRaw(0/*trackNr*/, 0/*cursorX*/, false/*bShift*/);

               curDstTicks += step_resolution;
               curSrcTicks = nearestEventOff + step_resolution;
               numCollapsed++;
            }

         }
         while(bEventFound);

         // Copy tmp to current pattern
         parent_editor.selectPatternByIdx(Node.TMP_PAT_NR/*126*/);
         parent_editor.cmd_pattern_copy(true/*bInvBlock*/);
         parent_editor.selectPatternByIdx(origEditPatNr);
         parent_editor.cmd_pattern_paste();

         // Restore offset/clipboard/block mode
         parent_editor.selectPatternByIdx(origEditPatNr);
         parent_node.setEditOffset(0);
         NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);
         b_block_quiet = false;
         block_mode = origBlockMode;
         selectNone();

         renderAndRedrawAll();

         if(_bUndo)
            parent_node.undoEndNested("collapse");
         else
            parent_node.undoEnable();

         Global.Print(numCollapsed+" step(s) collapsed");
      }
   }

   // <method.png>
   public =replay= trimStartToCursor() {
      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();

      if(null != mpat)
      {
         int origEditOff = parent_node.getEditOffset();
         if(origEditOff >= step_resolution)
         {
            parent_node.undoBeginNested("trimstarttocursor");
            int origEditPatNr = parent_node.nodeGetCurrentEditPatternNr();
            int origBlockMode = block_mode;
            parent_node.undoTouchPattern(origEditPatNr);

            NodeTracker.SelectClipboard(NodeTracker.CB_SECONDARY);
            parent_node.setEditOffset(0);
            block_mode = BLOCK_MODE_PATTERN;
            b_block_quiet = true;
            blockBegin(false/*bAllowSelectNone*/);
            blockAncCancel();
            parent_node.setEditOffset(mathMaxi(0, origEditOff - step_resolution));
            blockEnd(false);
            blockDelete(false/*bShiftEv*/, false/*bUndoStartEnd*/);

            mpat.ui_pattern_replay_start_offset = mathMaxi(0, mpat.ui_pattern_replay_start_offset - origEditOff);

            NodeTracker.SelectClipboard(NodeTracker.CB_PRIMARY);
            b_block_quiet = false;
            block_mode = origBlockMode;
            selectNone();
            renderAndRedrawAll();
            parent_node.undoEndNested("trimstarttocursor");
            Global.Print("Trim pattern start to cursor (delete "+origEditOff+" tick"+Utils.GetPluralString(origEditOff)+")");
         }
      }
   }

   // <method.png>
   public =replay= method pasteMIDIOutputState() {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         local MIDIPipeFrame fr;
         NT_TEL tel <= track.tel;
         NT_CEL *cel;
         local NT_Instrument *kjIns;
         kjIns <= parent_node.getInstrument(track.keyjazz_instr_nr); // can be null
         local MIDIPipeDevice *pipeDev;
         if(null != kjIns)
            pipeDev <= kjIns.out_device.getMIDIPipeDevice();

         int recPatOffset = parent_node.getEditOffset();
         int recRaster = step_resolution;
         int evRecOffset;
         int numUpdated = 0;
         float val;
         parent_node.undoBeginNested("paste_midi_output_state");

         foreach cel in tel.ctl_layouts
         {
            if(cel.b_visible)
            {
               switch(cel.ctl_id)
               {
                  default:
                     if(CTL_USR <= cel.ctl_id <= (CTL_USR + CTL_NUMUSR))
                     {
                        int usrCtlId = cel.ctl_id - CTL_USR;
                        NT_MIDIParam mp <= kjIns.getUsrCtlParam(usrCtlId);
                        if(null != mp)
                        {
                           val = mp.getCurrentMIDIOutputStateForRecording(pipeDev, kjIns.midi_channel);
                           if(-1 != val)
                           {
                              evRecOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                              parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, val, evRecOffset, 1/*recRaster*/);
                              numUpdated++;
                           }
                        }
                     }
                     break;

                  case CTL_PC:
                     if(null != pipeDev)
                     {
                        val = pipeDev.getPrg(kjIns.midi_channel);
                        if(-1 != val)
                        {
                           evRecOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                           parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, val, evRecOffset, 1/*recRaster*/);
                           numUpdated++;
                        }
                     }
                     break;

                  case CTL_PB:
                     if(null != pipeDev)
                     {
                        val = pipeDev.getPitchbend(kjIns.midi_channel);
                        if(-1 != val)
                        {
                           val = val / 128;  // to 0..127 range
                           evRecOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                           parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, val, evRecOffset, 1/*recRaster*/);
                           numUpdated++;
                        }
                     }
                     break;

                  case CTL_BPM:
                     evRecOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                     parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, current_song.bpm, evRecOffset, 1/*recRaster*/);
                     numUpdated++;
                     break;

                  case CTL_BPM_MUL:
                     evRecOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                     parent_node.insertReplaceTrackEventAtRes(cel.ctl_id,
                                                              Utils.Bipolar8ToScaleRev(current_song.bpm_mul, 2.0, 2.0),
                                                              evRecOffset,
                                                              1/*recRaster*/
                                                              );
                     numUpdated++;
                     break;
               }
            }
         }

         parent_node.undoEndNested("paste_midi_output_state");

         if(numUpdated > 0)
            queueRedrawAll();

         Global.Print("Paste MIDI output state: update "+numUpdated+" ctl"+Utils.GetPluralString(numUpdated));
      }
   }

   // <ui_timer.png>
   protected =replay= method handleTARecordMIDIEndExpired() {
      // trace "xxx -------- handleTARecordMIDIEndExpired";
      if(!parent_node.b_rt_record)
      {
         parent_node.undoEndCondPat();
         parent_node.undoEndCond("record MIDI");
      }
      else
      {
         ta_recordmidiend.schedule();
         parent_node.b_ta_recordmidiend_scheduled = true;
         // trace "[~~~] PatternView::handleTARecordMIDIEndExpired: replay is running";
      }
   }

   // <method.png>
   protected method editTrackName(int _trackNr) {
      _trackNr = mathWrapf(_trackNr, 0, parent_node.tracks.numElements);

      NT_Track track <= parent_node.getTrack(_trackNr);
      if(null != track)
      {
         moveCursorToTrack(_trackNr);

         if(null == dlg_trackname)
         {
            dlg_trackname <= new StringDialog;
            dlg_trackname.init(null/*fontName*/);
         }

         Integer off, sx;
         getTrackPixelOffsetAndWidth(_trackNr, off, sx);
         off = off + 4*char_width;
         sx = sx - 4*char_width +2;

         dlg_trackname.configure(track.name, 48, mathMaxi(7, sx/9), this);
         dlg_trackname.showNearLayerOffset(this, off -2 + (sx - dlg_trackname.getSizeX())*0.5, 2+11);
         dlg_trackname_track <= track;
      }
   }

   // <method.png>
   public method editCurrentTrackName() {
      editTrackName(getCurrentTrackNr());
   }

   // <ui_cursor.png>
   public method printCursorStatusInfoAt(int _cursorTrack, int _cursorX, boolean _bChord) {

      if(b_timing_mouse_drag)  // don't overwrite block shift message
         return;

      NT_Track track <= parent_node.getTrack(_cursorTrack);

      if(null != track)
      {
         NT_TEL tel <= track.getTrackLayout();

         if(null != tel)
         {
            int ctlMapId = tel.cursor_to_ctl_map[_cursorX];
            NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG

            if(null != cel)
            {
               NT_Instrument ins <= parent_node.getInstrument(track.keyjazz_instr_nr);
               String ctlName <= NodeTracker.GetControllerName(ins, cel.ctl_id);

               String msg =
                  "Trk: "+(_cursorTrack+1)+" Ctl: "+cel.ctl_id+" ("+ctlName+")"+
                  ((cel.style==NT_CEL.STYLE_HEX)?(ctlMapId&NT_TEL.MSB_FLAG)?" [MSB]":" [LSB]":"")
                  +".";

               if(_bChord)
               {
                  if(!replay.b_playing)
                  {
                     if(NT_CEL.STYLE_NOTE == cel.style)
                     {
                        NT_TrackPattern pat <= getCurrentPattern();

                        if(null != pat)
                        {
                           int relPatTime = parent_node.getEditOffset();
                           IntArray activeNotes; activeNotes.empty();
                           pat.findActiveNotesAt(relPatTime, step_resolution, activeNotes);
                           if(activeNotes.numElements > 1)
                           {
                              chord_detect.setActiveNotes(activeNotes);
                              Integer chordBaseNote;
                              int chordIndex = chord_detect.findChordIndexAndBase(chordBaseNote);
                              if(-1 != chordIndex)
                              {
                                 if(chordBaseNote < 0)
                                    chordBaseNote += 12;
                                 msg.append(" Chord: ");
                                 msg.append(MIDI.base_note_names.get(chordBaseNote % 12));
                                 msg.append(Chord.chord_names_short.get(chordIndex));
                              }
                           }
                           parent_editor.updatePianoWidgetPressedNotes(activeNotes);
                        }
                     }
                  }
               }

               Global.Print(msg);
            } // if cel
         } // if tel
      } // if track
   }

   // <ui_cursor.png>
   public method printCursorStatusInfo() {
      // Called when scrolling with cursor keys
      printCursorStatusInfoAt(getCurrentTrackNr(), cursor_x, true/*bChord*/);
   }

   // <ui_cursor.png>
   public method printCursorStatusInfoChord() {
      // Called after note has been recorded in replay thread (via onDraw())
      printCursorStatusInfoAt(getCurrentTrackNr(), cursor_x, true/*bChord*/);
   }

   // <method.png>
   protected method incHighlightRowTimeout(int _i) {
      highlight_row_timeout += _i;
      if(highlight_row_timeout > HIGHLIGHT_MAX_TIMEOUT)
         highlight_row_timeout = HIGHLIGHT_MAX_TIMEOUT;

      float centerY = calcCenterY();
      highlight_row_y = centerY;

      ta_redraw_overlays.schedule();
   }

   // <method_set.png>
   protected method setMaxHighlightRowTimeout() {
      highlight_row_timeout = HIGHLIGHT_MAX_TIMEOUT;
      float centerY = calcCenterY();
      highlight_row_y = centerY;

      ta_redraw_overlays.schedule();
   }

   // <ui_cursor.png>
   protected method highlightCursorMove() {
      if(STConfig.b_node_tracker_highlight_cursormove)
         incHighlightRowTimeout(HIGHLIGHT_CURSORMOVE_TIMEOUT);
   }

   // <method.png>
   public method calcCenterY() : float {
      if(UI.IsHiDPI()
         ? STConfig.b_node_tracker_doublecenter_hidpi
         : STConfig.b_node_tracker_doublecenter_lodpi
         )
         return ((getSizeY() - char_height*2) / 2);
      else
         return ((getSizeY() - char_height) / 2);
   }

   // <method_get.png>
   protected method getLabelFont() : Font {
      if(null == label_font)
         label_font <= UI.GetFontByName(FONTNAME_TRACKNAME);
      return label_font;
   }

   // <method.png>
   public method selectInstrumentAtPos(int _pos) { // pos: upper word=trackidx, lower word=cursorx
      // (note) assumes that edit cursor is placed on the same line as the mouse

      int cursorTrack = (_pos >> 16);
      int cursorX     = (_pos & 0xFFFF);
      NT_CEL cel <= getCELAtPos(_pos);
      if(null != cel)
      {
         if(NT_TrackPattern.CTL_INSTR == cel.ctl_id)
         {
            NT_Track track <= parent_node.getTrack(cursorTrack);
            if(null != track)
            {
               var e = parent_node.getEventAt(track, NT_TrackPattern.CTL_INSTR, parent_node.getEditOffset(), step_resolution);
               if(typeid(e) == YAC_TYPE_FLOAT)
               {
                  parent_editor.keyJazzSelectInstrument(int(e), true/*bMakeVisible*/, false/*bQuiet*/);
               }
            }
         }
      }
   }

   // <method.png>
   public method selectInstrumentAtCurrentStep() : boolean {
      NT_Track track <= parent_node.getTrack(getCurrentTrackNr());
      if(null != track)
      {
         NT_Instrument ins <= parent_node.getInstrument(track.current_instrument_nr);
         if(null != ins)
         {
            if(ins.b_audio)
            {
               // Reserve lctrl-x a shortcut for NT_AudioDialog
               return false;
            }
         }
      }

      var e = parent_node.getTrackEventAt(NT_TrackPattern.CTL_INSTR, parent_node.getEditOffset());
      if(typeid(e) == YAC_TYPE_FLOAT)
      {
         parent_editor.keyJazzSelectInstrument(int(e), true/*bMakeVisible*/, false/*bQuiet*/);
         return true;
      }
      return false;
   }

   // <method_set.png>
   public method toggleMuteTrack() {
      NT_Track track <= parent_node.getTrack(getCurrentTrackNr());
      if(null != track)
      {
         track.toggleMute();

         redraw();
      }
   }

   // <method.png>
   public method copyCurrentCtlToClipboard(boolean _bClipboardB) {
      String msgPrefix <= _bClipboardB ? "copyctl<B>: " : "copyctl<A>: ";
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_Instrument ins <= parent_node.getInstrument(track.current_instrument_nr);
         if(null != ins)
         {
            NT_TEL tel <= track.getTrackLayout();
            if(null != tel)
            {
               int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
               NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
               if(null != cel)
               {
                  NMM_Arg clipboardEv <= _bClipboardB ? mmarg_clipboard_b : mmarg_clipboard_a;
                  STX_MIDIOutDevice *midiDev;
                  byte midiCh;

                  int ctlId = cel.ctl_id;
                  boolean bUsr = NT_TrackPattern.CTL_USR <= cel.ctl_id < (NT_TrackPattern.CTL_USR + NT_TrackPattern.CTL_NUMUSR);
                  if(bUsr)
                  {
                     int usrCtlId = cel.ctl_id - CTL_USR;
                     NT_MIDIParam mp <= ins.getUsrCtlParam(usrCtlId);
                     if(null != mp)
                     {
                        midiDev <= mp.getEffectiveDevice(ins);
                        midiCh   = mp.getEffectiveChannel(ins);

                        switch(mp.getMIDIMapEventType())
                        {
                           default:
                              Global.Warning(msgPrefix+"unsupported usrctl");
                              clipboardEv <= null;
                              break;

                           case MIDIMapDefs.TYPE_CC:
                              clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                            midiCh,
                                                            NMM_Arg.TYPE_CC,
                                                            mp.getMIDIMapEventExtType()/*ccNr*/,
                                                            -1/*rpnNr*/,
                                                            -1/*nrpnNr*/
                                                            );
                              break;

                           case MIDIMapDefs.TYPE_RPN:
                              clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                            midiCh,
                                                            NMM_Arg.TYPE_RPN,
                                                            -1/*ccNr*/,
                                                            mp.getMIDIMapEventExtType()/*rpnNr*/,
                                                            -1/*nrpnNr*/
                                                            );
                              break;

                           case MIDIMapDefs.TYPE_NRPN:
                              clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                            midiCh,
                                                            NMM_Arg.TYPE_NRPN,
                                                            -1/*ccNr*/,
                                                            -1/*rpnNr*/,
                                                            mp.getMIDIMapEventExtType()/*nrpnNr*/
                                                            );
                              break;

                           case MIDIMapDefs.TYPE_PROGRAM_CHANGE:
                              clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                            midiCh,
                                                            NMM_Arg.TYPE_PRGCHG,
                                                            -1/*ccNr*/,
                                                            -1/*rpnNr*/,
                                                            -1/*nrpnNr*/
                                                            );
                              break;
                        }
                     }
                     else
                     {
                        Global.Warning(msgPrefix+"unused usrctl");
                        clipboardEv <= null;
                     }
                  }
                  else
                  {
                     // Standard controller
                     midiDev <= ins.out_device;
                     midiCh = ins.midi_channel;
                     switch(ctlId)
                     {
                        default:
                           Global.Warning(msgPrefix+"not a MIDI cel");
                           break;

                        case NT_Defs.CTL_NOTE1:
                        case NT_Defs.CTL_NOTE2:
                        case NT_Defs.CTL_NOTE3:
                        case NT_Defs.CTL_NOTE4:
                        case NT_Defs.CTL_NOTE5:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_NOTE,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;

                        case NT_Defs.CTL_VEL1:
                        case NT_Defs.CTL_VEL2:
                        case NT_Defs.CTL_VEL3:
                        case NT_Defs.CTL_VEL4:
                        case NT_Defs.CTL_VEL5:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_VELOCITY,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;

                        case NT_Defs.CTL_DUR1:
                        case NT_Defs.CTL_DUR2:
                        case NT_Defs.CTL_DUR3:
                        case NT_Defs.CTL_DUR4:
                        case NT_Defs.CTL_DUR5:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_DURATION,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;

                        case NT_Defs.CTL_POLYAT1:
                        case NT_Defs.CTL_POLYAT2:
                        case NT_Defs.CTL_POLYAT3:
                        case NT_Defs.CTL_POLYAT4:
                        case NT_Defs.CTL_POLYAT5:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_POLYPRESSURE,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;

                        case NT_Defs.CTL_PC:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_PRGCHG,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;

                        case NT_Defs.CTL_AT:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_CHPRESSURE,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;

                        case NT_Defs.CTL_PB:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_PITCHBEND,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;

                        case NT_Defs.CTL_BPM:
                           clipboardEv.initFromCopiedCtl(midiDev.dev_idx,
                                                         midiCh,
                                                         NMM_Arg.TYPE_BPM,
                                                         -1/*ccNr*/,
                                                         -1/*rpnNr*/,
                                                         -1/*nrpnNr*/
                                                         );
                           break;
                     }
                  }

                  if(null != clipboardEv)
                     Global.Print(msgPrefix+"type="+clipboardEv.getClipboardTypeString()+" dev="+midiDev.getAliasOrDeviceName()+":"+(1+clipboardEv.dev_ch));
               }
               else
               {
                  Global.Warning(msgPrefix+"no cel");
               }
            }
            else
            {
               Global.Warning(msgPrefix+"no track layout");
            }
         }
         else
         {
            Global.Warning(msgPrefix+"no instrument");
         }
      }
      else
      {
         Global.Warning(msgPrefix+"no track");
      }
   }

   // <ui_render.png>
   protected method drawMuteAndEqualizersAndTrackNames(float centerY) {
      if(null == parent_node)
         return;

      boolean bDoubleCenter = useDoubleCenter();

      int totalNumTracks = parent_node.tracks.numElements;
      NT_Track *track;
      int trackNr = parent_node.pv_track_shift;
      float cx = (NUM_SONGPOS_COLS + 5)*char_width - 2;

      int numTracks = getNumVisibleTracks() +1; // +1 because of (potentially) partly visible track
      if(numTracks > (totalNumTracks - trackNr))
         numTracks = (totalNumTracks - trackNr);

      loop( numTracks )
      {
         track <= parent_node.tracks[trackNr++];
         NT_TEL tel <= track.getTrackLayout();
         int totalCharWidth = tel.total_char_width - 1 - 4;
         if(track.isMuted())
         {
            UIRenderer.EnableBlending();
            UIRenderer.SetColorARGB(app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TRACK_MUTE_LINE_COLOR));
            UIRenderer.SetLineWidth(2.0f);
            if(UIRenderer.BeginLinesAA(4))
            {
               UIRenderer.Vertex2f(cx, 0);
               UIRenderer.Vertex2f(cx+totalCharWidth * char_width +2, size_y);
               UIRenderer.Vertex2f(cx+totalCharWidth * char_width +2, 0);
               UIRenderer.Vertex2f(cx, size_y);
               UIRenderer.End();
            }
            UIRenderer.SetLineWidth(1.0f);
            UIRenderer.DisableBlending();
         }

         if(replay.b_playing)
         {
            if(STConfig.b_node_tracker_draweq)
            {
               if(255 != STConfig.node_tracker_eq_opacity)
               {
                  UIRenderer.EnableBlending();
               }
               UIRenderer.SetColorARGB(argb(STConfig.node_tracker_eq_opacity, 255, 255, 255));
               // Draw equalizer
               float eqT = centerY - (track.eq_anim * size_y * 0.25);
               float eqB = centerY;
               if(!bDoubleCenter)
               {
                  eqT -= 2;
                  eqB -= 2;
               }
               float eqV = (45.0/64) - (45.0/64)*track.eq_anim;
               float eqX = cx + (( (totalCharWidth*char_width) -32)*0.5);
               tex_eq.bind();
               UIRenderer.EnableTexture2D();
               if(UIRenderer.BeginTexturedTriangleFan(4))
               {
                  UIRenderer.TexCoord2f(1.0/64, eqV);
                  UIRenderer.Vertex2f(eqX, eqT);

                  UIRenderer.TexCoord2f(20.0/64, eqV);
                  UIRenderer.Vertex2f(eqX+32, eqT);

                  UIRenderer.TexCoord2f(20.0/64, 45.0/64);
                  UIRenderer.Vertex2f(eqX+32, eqB);

                  UIRenderer.TexCoord2f(1.0/64, 45.0/64);
                  UIRenderer.Vertex2f(eqX, eqB);

                  UIRenderer.End();
               }
               UIRenderer.DisableTexture2D();
               if(255 != STConfig.node_tracker_eq_opacity)
               {
                  UIRenderer.DisableBlending();
               }
            } // if STConfig.b_node_tracker_draweq
         } // if b_playing

         // Render track name
         if(STConfig.b_node_tracker_show_track_names)
         {
            Font *labelFont <= getLabelFont();
            float wAvail = totalCharWidth*char_width +2;

            String trackName = String(trackNr);
            if(track.isKeyJazzLocked())
               trackName.append("*");
            else
               trackName.append(":");
            trackName.append(track.name);
            trackName.replaceChar(',','\n');

            float wReq = labelFont.stringWidth(trackName);
            float hReq = labelFont.stringHeight(trackName);
            if(hReq < 21*UI.font_scaling) // TRACK_MUTE_MINY ?
               hReq = 21*UI.font_scaling;

            if(UI.font_scaling == 2.0)
               hReq *= 0.8;

            UIRenderer.EnableBlending();
            UIRenderer.DrawFilledRectangle(cx, 0, wAvail, hReq,
                                           app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TRACK_NAME_OVERLAY_BG)
                                           );
            UIRenderer.DisableBlending();

            int trackNameFg;
            if((trackNr-1) == getCurrentTrackNr())
            {
               trackNameFg = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TRACK_NAME_OVERLAY_FG_CURRENT);
            }
            else
            {
               trackNameFg = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TRACK_NAME_OVERLAY_FG_OTHER);
            }

            // Highlight trackname after track change
            if(track.hltrackname_countdown > 0.0)
            {
               if(FPS.limit == 30)
                  track.hltrackname_countdown -= 0.05*2;
               else
                  track.hltrackname_countdown -= 0.05;

               if(track.hltrackname_countdown < 0)
                  track.hltrackname_countdown = 0.0f;

               compositeAll();
            }

            int trackNameFgShadowC8 = track.hltrackname_countdown * 255;
            int trackNameFgShadowC32 = argb(127, trackNameFgShadowC8, trackNameFgShadowC8, trackNameFgShadowC8);

            UIRenderer.EnableBlending();
            UIRenderer.DrawTextClipped(trackName, labelFont,
                                       trackNameFgShadowC32, trackNameFgShadowC32,
                                       cx + (wAvail-wReq)*0.5 +1, 1,
                                       cx, 0,
                                       cx+totalCharWidth * char_width, hReq
                                       );
            UIRenderer.DisableBlending();
            UIRenderer.DrawTextClipped(trackName, labelFont,
                                       trackNameFg, trackNameFg,
                                       cx + (wAvail-wReq)*0.5, 0,
                                       cx, 0,
                                       cx+totalCharWidth * char_width, hReq
                                       );

            // Draw PolyStep highlight
            if(track.hlpolystep_countdown > 0.0)
            {
               if(FPS.limit == 30)
                  track.hlpolystep_countdown -= 0.05*2;
               else
                  track.hlpolystep_countdown -= 0.05;

               if(track.hlpolystep_countdown < 0)
                  track.hlpolystep_countdown = 0.0f;

               int hlPolyStepC8 = track.hlpolystep_countdown * 192;
               int hlPolyStepC32 = argb(hlPolyStepC8,255,255,255);

               int deltaRowOff;
               int hlPatOffset = track.hlpolystep_offset;
               int editOffset = parent_node.getEditOffset();
               float hlRowY = centerY;
               float hlRowH;

               // Correct pixel position/height when center row is doubled
               if(hlPatOffset == editOffset)
               {
                  hlRowH = bDoubleCenter ? (char_height*2) : char_height;
               }
               else if(hlPatOffset > editOffset)
               {
                  deltaRowOff = (hlPatOffset - editOffset) / step_resolution;
                  if(bDoubleCenter)
                     hlRowY += char_height;
                  hlRowY += (deltaRowOff * char_height);
                  hlRowH = char_height;
               }
               else
               {
                  deltaRowOff = (hlPatOffset - editOffset) / step_resolution;
                  hlRowY += (deltaRowOff * char_height);
                  hlRowH = char_height;
               }

               UIRenderer.EnableBlending();
               UIRenderer.DrawFilledRectangle(cx, hlRowY, totalCharWidth*char_width, hlRowH+2,
                                              hlPolyStepC32
                                              );
               UIRenderer.DisableBlending();

               compositeAll();
            }
         }

         cx += (totalCharWidth +1 + 4) * char_width;
      }
   }

   // <ui_render.png>
   protected method drawTickMarkers(float _centerY) {

      UIRenderer.EnableBlending();

      int tickMod = parent_node.ui_highlight_tick_modulo;
      if(tickMod < 0)
         tickMod = current_song.ppq * -parent_node.ui_highlight_tick_modulo;

      int editOffset = parent_node.getEditOffset();

      float cy = _centerY;
      cy -= (MAX_ROWS/2) * char_height;

      boolean bDoubleCenter = useDoubleCenter();

      int curOffset = editOffset - (MAX_ROWS/2)*step_resolution;

      loop(MAX_ROWS)
      {
         float sy = char_height;

         if(curOffset == editOffset)
         {
            if(bDoubleCenter)
               sy *= 2;
         }

         if(cy >= 0)
         {
            int coffset = curOffset;
            if(coffset < 0)
               coffset += parent_node.getCurrentEditMetaPatternLength();

            if(0 == (coffset % tickMod))
            {
               UIRenderer.DrawFilledRectangle(0, cy, getSizeX(), sy+1, app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_HLTICKMOD));
            }
         }

         cy += sy;

         curOffset += step_resolution;
      }

      UIRenderer.DisableBlending();
   }

   // <ui_render.png>
   protected method drawCenterAndReplayRowMarker(float centerY, boolean _bCenter) {
      // Highlight center/replay row
      float hlRowY = centerY;
      float hlRowH;

      boolean bDoubleCenter = useDoubleCenter();

      if(parent_node.doAutoScroll() || _bCenter)
      {
         // Allows hilite center row
         if(bDoubleCenter)
            hlRowH = char_height * 2;
         else
            hlRowH = char_height;
      }
      else
      {
         // Calc current replay row position/size
         int deltaRowOff;
         int hlPatOffset;
         hlPatOffset = parent_node.getReplayUIPatOffset();

         // Correct pixel position/height when center row is doubled
         int editOffset = parent_node.getEditOffset();
         if(hlPatOffset == editOffset)
         {
            hlRowH = bDoubleCenter ? (char_height*2) : char_height;
         }
         else if(hlPatOffset > editOffset)
         {
            deltaRowOff = (hlPatOffset - editOffset) / step_resolution;
            if(bDoubleCenter)
               hlRowY += char_height;
            hlRowY += (deltaRowOff * char_height);
            hlRowH = char_height;
         }
         else
         {
            deltaRowOff = (hlPatOffset - editOffset) / step_resolution;
            hlRowY += (deltaRowOff * char_height);
            hlRowH = char_height;
         }
      }

      // Draw current replay row highlight
      UIRenderer.EnableBlending();
      UIRenderer.DrawFilledRectangle(0, hlRowY, getSizeX(), hlRowH+2,
                                     app_lnf.getColor(_bCenter ? AppLookAndFeel.COLOR_NT_PV_HLCENTER : AppLookAndFeel.COLOR_NT_PV_HLREPLAY)
                                     );
      UIRenderer.DisableBlending();
   }

   // <ui_render.png>
   protected method drawMouseOverRowHighlights(float centerY) {
      if(highlight_row_timeout > 0)
      {
         int hly = highlight_row_y;
         int hlh = hly + char_height;

         boolean bDoubleCenter = useDoubleCenter();

         // Center row has double height in zoom mode
         if(bDoubleCenter)
         {
            if( (centerY-char_height*0.5) <= hly < (centerY + char_height))
            {
               hlh += char_height;
            }
         }

         // Clip
         if(hly < 0)
         {
            hlh += hly;
            hly = 0;
         }
         else if( hlh >= getSizeY() )
         {
            hlh = getSizeY();
         }

         if(hlh > 0)
         {
            int c8 = (highlight_row_timeout * app_lnf.nt_pv_overlay_highlight_row_timeout_alpha_scl);
            UIRenderer.SetColorARGB(argb(c8, 255, 255, 255));
            UIRenderer.EnableBlending();
            if(UIRenderer.BeginFilledTriangleFan(4))
            {
               UIRenderer.Vertex2f(0, hly);
               UIRenderer.Vertex2f(size_x, hly);
               UIRenderer.Vertex2f(size_x, hlh);
               UIRenderer.Vertex2f(0, hlh);
               UIRenderer.End();
            }
            UIRenderer.DisableBlending();
         }
      }
   }

   // <ui_render.png>
   protected method drawBGMesh() {

      float centerY = calcCenterY();
      float clipTop = 0.0f;
      float clipBottom = size_y;

      int editOffset = parent_node.getEditOffset();
      float patStartY = centerY - ((editOffset / step_resolution) * char_height);
      if(patStartY > 0)
      {
         // Clip top to pat start
         clipTop = patStartY;
      }

      boolean bDoubleCenter = useDoubleCenter();

      float patLen = parent_node.getCurrentEditMetaPatternLength();
      float patEndY = centerY + (((patLen - editOffset) / step_resolution) * char_height);
      if(bDoubleCenter)
         patEndY += char_height;
      if(patEndY < size_y)
         clipBottom = patEndY;

      // // int idx = 0;
      // // idx = 0;
      // // loop(numBGQuadVertices / 4)
      // // {
      // //    bg_mesh_vertices[idx + 1] = clipTop;
      // //    bg_mesh_vertices[idx + 3] = clipTop;
      // //    bg_mesh_vertices[idx + 5] = clipBottom;
      // //    bg_mesh_vertices[idx + 7] = clipBottom;

      // //    bg_mesh_cliptop_vertices[idx + 1] = 0.0f;
      // //    bg_mesh_cliptop_vertices[idx + 3] = 0.0f;
      // //    bg_mesh_cliptop_vertices[idx + 5] = clipTop;
      // //    bg_mesh_cliptop_vertices[idx + 7] = clipTop;

      // //    bg_mesh_clipbottom_vertices[idx + 1] = clipBottom;
      // //    bg_mesh_clipbottom_vertices[idx + 3] = clipBottom;
      // //    bg_mesh_clipbottom_vertices[idx + 5] = size_y;
      // //    bg_mesh_clipbottom_vertices[idx + 7] = size_y;

      // //    idx += (4 * 2);
      // // }

      UIRenderer.EnableBlending();
      UIRenderer.SetColorARGB(#ffffffff);

      // Top
      if(clipTop > 0.0f)
      {
         UIRenderer.PushModelMatrix();
         UIRenderer.ModelScale2f(1.0f, clipTop);
         sdvg_BindVBO(bg_mesh_clip_vbo_id);
         if(sdvg_BeginFilledGouraudTriangles(bg_mesh_num_verts))
         {
            sdvg_End();
         }
         UIRenderer.PopModelMatrix();
      }

      // Active pattern area
      UIRenderer.PushModelMatrix();
      UIRenderer.ModelTranslate2f(0.0f, patStartY);
      UIRenderer.ModelScale2f(1.0f, clipBottom - clipTop);
      sdvg_BindVBO(bg_mesh_vbo_id);
      if(sdvg_BeginFilledGouraudTriangles(bg_mesh_num_verts))
      {
         sdvg_End();
      }
      UIRenderer.PopModelMatrix();

      // Bottom
      if(clipBottom < size_y)
      {
         UIRenderer.PushModelMatrix();
         UIRenderer.ModelTranslate2f(0.0f, clipBottom);
         UIRenderer.ModelScale2f(1.0f, size_y - clipBottom);
         sdvg_BindVBO(bg_mesh_clip_vbo_id);
         if(sdvg_BeginFilledGouraudTriangles(bg_mesh_num_verts))
         {
            sdvg_End();
         }
         UIRenderer.PopModelMatrix();
      }

      sdvg_UnbindVBO();

      UIRenderer.DisableBlending();
   }

   // <ui_render.png>
   protected method drawPattern(float centerY) {
      // trace "xxx drawPattern";

      UIRenderer.EnableTexture2D();

      int rownr=0;
      int num = num_rows;
      int dy;
      dy = centerY - char_height * center_row;
      int charHeight;
      int charYOff;
      int y;
      int stripeNr;

      boolean bDoubleCenter = useDoubleCenter();

      // Draw pattern using quad-mesh (stripes)
      tex_font.bind();
      UIRenderer.SetColor4f(1,1,1,1);
      UIRenderer.EnableBlending();

      loop(num)
      {
         boolean bZoomRow = (bDoubleCenter && (rownr == center_row));
         float charH = bZoomRow ? (char_height*2.0f) : char_height;

         if( (dy + charH) >= 0 )
         {
            if( dy <= size_y )
            {
               stripeNr = stripes[rownr];
               String text <= strings[stripeNr];
               UIRenderer.ModelTranslate2f(0, dy);

               int meshVBO;
               if(bZoomRow)
               {
                  meshVBO = mesh_row_zoom_vbos[stripeNr];
               }
               else
               {
                  meshVBO = mesh_row_vbos[stripeNr];
               }

               sdvg_BindVBO(meshVBO);
               int numVerts = mesh_row_num_verts[stripeNr];
               // trace "xxx draw stripeNr="+stripeNr+" numVerts="+numVerts+" #############";
               if(sdvg_BeginTexturedGouraudTrianglesAlpha(numVerts))
               {
                  sdvg_End();
               }
               sdvg_BindVBO(0);
               // trace "xxx END draw stripeNr="+stripeNr+" numVerts="+numVerts;

               UIRenderer.ModelTranslate2f(0, -dy);

            } // cull bottom
         } // cull top

         dy += charH;

         rownr++;
      }

      UIRenderer.DisableBlending();
      UIRenderer.DisableTexture2D();
   }

   // <ui_render.png>
   protected method drawCursor(float centerY) {
      NT_TEL tel <= getCurrentTrackLayout();
      if(null != tel)
      {
         int c32;
         int bHlNeighbour = 0;
         int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
         if(ctlMapId & NT_TEL.MSB_FLAG)
            bHlNeighbour = 1;
         else if(cursor_x > 0)
            bHlNeighbour = - (NT_TEL.MSB_FLAG == (tel.cursor_to_ctl_map[cursor_x-1] & NT_TEL.MSB_FLAG));

         boolean bDoubleCenter = useDoubleCenter();

         int alpha = app_lnf.getColor(parent_node.b_ui_timing_view
                                      ? AppLookAndFeel.COLOR_NT_PV_CURSOR_ALPHA_TIMINGVIEW
                                      : AppLookAndFeel.COLOR_NT_PV_CURSOR_ALPHA_NORMAL
                                      );

         Object cursorOffSize <= getColumnExtents(getCurrentTrackNr(), cursor_x);
         float cursorOff = cursorOffSize[0] - 1 + 1;
         float cursorSize = cursorOffSize[1] + 1;
         if(cursorOff > 0) // Cursor visible ? (i.e. is there a track ?)
         {
            if(NodeTracker.PV_EDIT_NONE == parent_node.pv_edit_mode)
            {
               c32 = (alpha | app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_CURSOR_EDIT_NONE));//alpha|#222222);
            }
            else if(NodeTracker.PV_EDIT_STEP == parent_node.pv_edit_mode)
            {
               if(b_insdel_shiftall_mode)
                  c32 = (alpha | app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_CURSOR_EDIT_NORMAL));
               else
                  c32 = (alpha | app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_CURSOR_EDIT_RELSHIFT));
            }
            else
            {
               /* Never reached ?! */
               c32 = (alpha | app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_CURSOR_EDIT_unused));
            }

            float h = bDoubleCenter ? char_height*2 : char_height;

            float minX = cursorOff;
            float maxX = cursorOff + cursorSize;

            UIRenderer.EnableBlending();
            UIRenderer.SetColorARGB(c32);

            if(parent_node.b_ui_timing_view)
            {
               centerY++;
               cursorOff += 1;
               maxX--;
               cursorSize--;
            }

            if(parent_node.b_ui_timing_view && (NodeTracker.PV_EDIT_NONE != parent_node.pv_edit_mode))
            {
               centerY++;
               cursorOff += 1;
               maxX--;
               cursorSize--;
               c32 =
                  b_insdel_shiftall_mode
                  ? app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_CURSOR_EDIT_NORMAL_TIMINGVIEW)
                  : app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_CURSOR_EDIT_RELSHIFT_TIMINGVIEW)
                  ;
               UIRenderer.SetColorARGB(c32);
               if(UIRenderer.BeginFilledTriangleFan(4))
               {
                  UIRenderer.Vertex2f(cursorOff           , centerY);
                  UIRenderer.Vertex2f(cursorOff+cursorSize, centerY);
                  UIRenderer.Vertex2f(cursorOff+cursorSize, centerY + h);
                  UIRenderer.Vertex2f(cursorOff           , centerY + h);
                  UIRenderer.End();
               }
            }
            else
            {
               // trace "xxx cursorOff="+cursorOff+" cursorSize="+cursorSize+" centerY="+centerY+" h="+h;
               UIRenderer.SetLineWidth( (neighbour_hl_countdown > 0) ? 2.0f : 1.0 );
               if(UIRenderer.BeginLineStrip(5))
               {
                  UIRenderer.Vertex2f(cursorOff           , centerY);
                  UIRenderer.Vertex2f(cursorOff+cursorSize, centerY);
                  UIRenderer.Vertex2f(cursorOff+cursorSize, centerY + h);
                  UIRenderer.Vertex2f(cursorOff           , centerY + h);
                  UIRenderer.Vertex2f(cursorOff           , centerY);
                  UIRenderer.End();
               }
            }

            // Highlight neighbour cell if cursor is placed on MSB/LSB hex column
            if(bHlNeighbour && !parent_node.b_ui_timing_view)
            {
               // // glLineStipple(1.0f, 0xaaaa);
               // // glEnable(GL_LINE_STIPPLE);
               int c32Neighbour = (c32 & 0x00FFFFFF);
               if(neighbour_hl_countdown > 1)
                  c32Neighbour |= ((c32 >> 1)&0x7F000000);
               else
                  c32Neighbour |= ((c32 >> 2)&0x3F000000);

               UIRenderer.SetColorARGB(c32Neighbour);
               UIRenderer.SetLineWidth(1.0f);
               if(UIRenderer.BeginLineStrip(5))
               {
                  if(bHlNeighbour < 0)
                  {
                     minX = cursorOff - cursorSize + 2;
                     UIRenderer.Vertex2f(cursorOff-cursorSize+2, centerY);
                     UIRenderer.Vertex2f(cursorOff-1           , centerY);
                     UIRenderer.Vertex2f(cursorOff-1           , centerY+h);
                     UIRenderer.Vertex2f(cursorOff-cursorSize+2, centerY+h);
                     UIRenderer.Vertex2f(cursorOff-cursorSize+2, centerY);
                  }
                  else
                  {
                     maxX = cursorOff + cursorSize + char_width;
                     UIRenderer.Vertex2f(cursorOff+cursorSize+1         , centerY);
                     UIRenderer.Vertex2f(cursorOff+cursorSize+char_width, centerY);
                     UIRenderer.Vertex2f(cursorOff+cursorSize+char_width, centerY+h);
                     UIRenderer.Vertex2f(cursorOff+cursorSize+1         , centerY+h);
                     UIRenderer.Vertex2f(cursorOff+cursorSize+1         , centerY);
                  }
                  UIRenderer.End();
               }
               // // glDisable(GL_LINE_STIPPLE);
            }

            // Draw vertical cell background
            float y = 0;
            if(STConfig.b_node_tracker_show_track_names)
            {
               y += 21;
            }
            UIRenderer.EnableBlending();
            UIRenderer.DrawFilledRectangle(minX, y, maxX-minX, getSizeY()-y, app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_HLCENTER_X));
            UIRenderer.DisableBlending();
         }
      }
   }

   // <ui_render.png>
   protected method drawBlock(float centerY) {
      if(-1 == parent_node.pv_block_start_pat_offset)
         return;

      if(-1 == parent_node.pv_block_end_pat_offset)
         return;

      boolean bSwapStartEnd = verifyBlockStartAndEnd();
      // // trace "xxx bSwapStartEnd = "+bSwapStartEnd+" startOff="+parent_node.pv_block_start_song_offset+" endOff="+parent_node.pv_block_end_song_offset;

      if(parent_node.pv_block_end_cursor_track < parent_node.pv_track_shift)
      {
         if(bSwapStartEnd)
            swapBackBlockStartAndEnd();
         return;
      }
      int numVisTracks = getNumVisibleTracks();
      int trackNr = parent_node.pv_block_start_cursor_track;
      int blockTrackNr = 0;
      if(trackNr >= (parent_node.pv_track_shift + numVisTracks))
      {
         if(bSwapStartEnd)
            swapBackBlockStartAndEnd();
         return;
      }
      else if(trackNr < parent_node.pv_track_shift)
      {
         blockTrackNr += (parent_node.pv_track_shift - trackNr);
         trackNr = parent_node.pv_track_shift;
      }

      int editOffset = parent_node.getEditOffset();
      int blkStartRow = (parent_node.pv_block_start_pat_offset - (editOffset - center_row * step_resolution)) / step_resolution;
      if(blkStartRow > num_rows)
      {
         if(bSwapStartEnd)
            swapBackBlockStartAndEnd();
         return;
      }

      int blkEndRow = (parent_node.pv_block_end_pat_offset - (editOffset - center_row * step_resolution)) / step_resolution;
      if(blkEndRow < 0)
      {
         if(bSwapStartEnd)
            swapBackBlockStartAndEnd();
         return;
      }

      boolean bDoubleCenter = useDoubleCenter();

      int startY = centerY - char_height*center_row;
      int patOff = parent_node.pv_block_start_pat_offset;
      startY += blkStartRow * char_height;
      if(blkStartRow < 0)
      {
         patOff += -blkStartRow * step_resolution;
      }
      else if(bDoubleCenter && blkStartRow > center_row)
      {
         startY += char_height;
      }

      int endY = startY + (blkEndRow-blkStartRow+1) * char_height;
      if( (blkEndRow >= center_row) && (blkStartRow <= center_row) )
      {
         if(bDoubleCenter)
            endY += char_height;
      }

      float startX = 0;
      float endX = size_x;

      Object cursorOffSize <= getColumnExtents(trackNr, parent_node.pv_block_start_cursor_x);
      float startCursorOff = cursorOffSize[0] - 2;

      cursorOffSize <= getColumnExtents(parent_node.pv_block_end_cursor_track, parent_node.pv_block_end_cursor_x);
      float endCursorOff = cursorOffSize[0] - 2;
      float endCursorSize = cursorOffSize[1] + 2;

      startX = startCursorOff;
      endX = endCursorOff + endCursorSize;

      // trace "xxx drawBlock: start=("+startX+";"+startY+") end=("+endX+";"+endY+")";
      UIRenderer.EnableBlending();

      // Draw highlighted area
      int c32Top    = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_BLOCK_TOP);
      int c32Bottom = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_BLOCK_BOTTOM);
      if(UIRenderer.BeginFilledGouraudTriangleFan(4))
      {
         UIRenderer.ColorARGB(bSwapStartEnd ? c32Bottom : c32Top);
         UIRenderer.Vertex2f(startX, startY);

         UIRenderer.ColorARGB(bSwapStartEnd ? c32Bottom : c32Top);
         UIRenderer.Vertex2f(endX,   startY);

         UIRenderer.ColorARGB(bSwapStartEnd ? c32Top : c32Bottom);
         UIRenderer.Vertex2f(endX,   endY);

         UIRenderer.ColorARGB(bSwapStartEnd ? c32Top : c32Bottom);
         UIRenderer.Vertex2f(startX, endY);

         UIRenderer.End();
      }

      // Draw outline
      if(b_block_in_clipboard)
         UIRenderer.SetColorARGB(app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_BLOCK_OL_CLIPBOARD));
      else
         UIRenderer.SetColorARGB(app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_BLOCK_OL_DEF));

      UIRenderer.SetLineWidth(1.0f);
      if(UIRenderer.BeginLineStrip(5))
      {
         UIRenderer.Vertex2f(startX, startY);
         UIRenderer.Vertex2f(endX,   startY);
         UIRenderer.Vertex2f(endX,   endY);
         UIRenderer.Vertex2f(startX, endY);
         UIRenderer.Vertex2f(startX, startY);
         UIRenderer.End();
      }
      UIRenderer.SetLineWidth(1.0f);

      UIRenderer.DisableBlending();

      if(bSwapStartEnd)
         swapBackBlockStartAndEnd();
   }

   // <method.png>
   protected method timingViewPatOffsetToPy(int _offset, int _centerOffset, float _centerY) : float {
      float py;

      boolean bDoubleCenter = useDoubleCenter();

      if(bDoubleCenter)
      {
         if(_offset < _centerOffset)
         {
            py = _centerY + ( ((_offset - _centerOffset) * float(char_height)) / step_resolution );
         }
         else if(_offset >= (_centerOffset + step_resolution))
         {
            py = _centerY + ( ((_offset - _centerOffset) * float(char_height)) / step_resolution );
            py += char_height;
         }
         else if(_centerOffset <= _offset < (_centerOffset + step_resolution))
         {
            int alignOffset = int(_offset / step_resolution) * step_resolution;
            py = _centerY + ( ((alignOffset - _centerOffset) * float(char_height)) / step_resolution );
            int relCtrOffset = _offset - alignOffset;
            py += relCtrOffset * float(char_height*2) / step_resolution;
         }
      }
      else
      {
         py = _centerY + ( ((_offset - _centerOffset) * float(char_height)) / step_resolution );
      }

      return int(py+1.5);
   }

   // <ui_render.png>
   protected method drawTimingMesh(float _centerY) {
      timing_bboxes.free();

      if(0 == getNumTracks())
         return;

      NT_Track *track;
      NT_TrackPattern *pat;
      NT_MetaPattern mpat <= parent_node.getCurrentEditMetaPattern();
      int clength;
      if(null != mpat)
         clength = mpat.num_ticks;
      else
         return;

      int centerOffset = parent_node.getEditOffset();
      int topOffset = centerOffset - center_row*step_resolution;

      int trackNr;
      trackNr = parent_node.pv_track_shift;
      int numVisTracks = (parent_node.tracks.numElements) - parent_node.pv_track_shift;

      float offX = char_width * (11 + 4) + 1;  // skip songpos and patoff
      float numPixPerStep = float(char_height) / step_resolution;
      float px;
      float pw;
      float py;
      float pyb;
      int alignOffset;
      int relCtrOffset;

      int defDuration = parent_node.def_duration;

      int c32NoteTopEven  = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TIMINGBOX_NOTE_TOP_EVEN);
      int c32NoteTopOdd   = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TIMINGBOX_NOTE_TOP_ODD);
      int c32NoteFillEven = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TIMINGBOX_NOTE_FILL_EVEN);
      int c32NoteFillOdd  = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TIMINGBOX_NOTE_FILL_ODD);
      int c32NoteLeft     = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TIMINGBOX_NOTE_LEFT);
      int c32Other        = app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TIMINGBOX_OTHER);

      UIRenderer.EnableBlending();

      loop(numVisTracks)
      {
         track <= parent_node.tracks[trackNr];
         pat <= track.getCurrentEditPattern();

         if(null != pat)
         {
            NT_TEL tel <= track.getTrackLayout();
            int numCels = tel.ctl_layouts.numElements;
            int celNr = 0;

            Envelope envDur1 <= pat.getEnvelope(NT_TrackPattern.CTL_DUR1);
            Envelope envDur2 <= pat.getEnvelope(NT_TrackPattern.CTL_DUR2);
            Envelope envDur3 <= pat.getEnvelope(NT_TrackPattern.CTL_DUR3);
            Envelope envDur4 <= pat.getEnvelope(NT_TrackPattern.CTL_DUR4);
            Envelope envDur5 <= pat.getEnvelope(NT_TrackPattern.CTL_DUR5);

            loop(numCels)
            {
               NT_CEL cel <= tel.ctl_layouts[celNr];

               if(cel.b_visible)
               {
                  Envelope env <= pat.getEnvelope(cel.ctl_id);

                  if(null != env)
                  {
                     int offset = 0;
                     int envIdx = 0;

                     int noteNr = 0;

                     loop(env.numElements / 2)
                     {
                        offset += env[envIdx];
                        // trace "xxx track["+trackNr+"] cel["+celNr+"] ev["+(envIdx/2)+"] offset="+offset;
                        px = offX;
                        pw = cel.num_x * char_width;

                        py = timingViewPatOffsetToPy(offset, centerOffset, _centerY);

                        if(py >= size_y)
                           break;

                        var v;
                        int durTicks = -1;
                        int durCtlId = -1;
                        int durOffset = -1;
                        int durEvIdx;

                        // (note) use duration from prev note when current note duration is not available,
                        //         fallback to default note duration when prev note duration is also unavailable
                        switch(cel.ctl_id)
                        {
                           default:
                              // Other event
                              pyb = py;
                              break;

                           case NT_TrackPattern.CTL_NOTE1:
                              v = void;

                              if(null != envDur1)
                              {
                                 v = envDur1.valueAtTimeSH(offset);
                              }

                              if(YAC_TYPE_VOID != typeid(v))
                              {
                                 durTicks = v;
                                 durCtlId = NT_TrackPattern.CTL_DUR1;
                                 durEvIdx = envDur1.timeToIndex(offset);
                                 durOffset = envDur1.indexToTime(durEvIdx);
                              }
                              else
                                 durTicks = defDuration;
                              durTicks *= parent_node.dur_ticks;
                              pyb = timingViewPatOffsetToPy(offset + durTicks, centerOffset, _centerY);
                              break;

                           case NT_TrackPattern.CTL_NOTE2:
                              v = void;

                              if(null != envDur2)
                              {
                                 v = envDur2.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR2;
                                    durEvIdx = envDur2.timeToIndex(offset);
                                    durOffset = envDur2.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur1))
                              {
                                 v = envDur1.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR1;
                                    durEvIdx = envDur1.timeToIndex(offset);
                                    durOffset = envDur1.indexToTime(durEvIdx);
                                 }
                              }

                              if(YAC_TYPE_VOID == typeid(v))
                                 durTicks = defDuration;
                              durTicks *= parent_node.dur_ticks;
                              pyb = timingViewPatOffsetToPy(offset + durTicks, centerOffset, _centerY);
                              break;

                           case NT_TrackPattern.CTL_NOTE3:
                              v = void;

                              if(null != envDur3)
                              {
                                 v = envDur3.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR3;
                                    durEvIdx = envDur3.timeToIndex(offset);
                                    durOffset = envDur3.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur2))
                              {
                                 v = envDur2.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR2;
                                    durEvIdx = envDur2.timeToIndex(offset);
                                    durOffset = envDur2.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur1))
                              {
                                 v = envDur1.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR1;
                                    durEvIdx = envDur1.timeToIndex(offset);
                                    durOffset = envDur1.indexToTime(durEvIdx);
                                 }
                              }

                              if(YAC_TYPE_VOID == typeid(v))
                                 durTicks = defDuration;
                              durTicks *= parent_node.dur_ticks;
                              pyb = timingViewPatOffsetToPy(offset + durTicks, centerOffset, _centerY);
                              break;

                           case NT_TrackPattern.CTL_NOTE4:
                              v = void;

                              if(null != envDur4)
                              {
                                 v = envDur4.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR4;
                                    durEvIdx = envDur4.timeToIndex(offset);
                                    durOffset = envDur4.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur3))
                              {
                                 v = envDur3.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR3;
                                    durEvIdx = envDur3.timeToIndex(offset);
                                    durOffset = envDur3.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur2))
                              {
                                 v = envDur2.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR2;
                                    durEvIdx = envDur2.timeToIndex(offset);
                                    durOffset = envDur2.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur1))
                              {
                                 v = envDur1.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR1;
                                    durEvIdx = envDur1.timeToIndex(offset);
                                    durOffset = envDur1.indexToTime(durEvIdx);
                                 }
                              }

                              if(YAC_TYPE_VOID == typeid(v))
                                 durTicks = defDuration;
                              durTicks *= parent_node.dur_ticks;
                              pyb = timingViewPatOffsetToPy(offset + durTicks, centerOffset, _centerY);
                              break;

                           case NT_TrackPattern.CTL_NOTE5:
                              v = void;

                              if(null != envDur5)
                              {
                                 v = envDur5.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR5;
                                    durEvIdx = envDur5.timeToIndex(offset);
                                    durOffset = envDur5.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur4))
                              {
                                 v = envDur4.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR4;
                                    durEvIdx = envDur4.timeToIndex(offset);
                                    durOffset = envDur4.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur3))
                              {
                                 v = envDur3.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR3;
                                    durEvIdx = envDur3.timeToIndex(offset);
                                    durOffset = envDur3.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur2))
                              {
                                 v = envDur2.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR2;
                                    durEvIdx = envDur2.timeToIndex(offset);
                                    durOffset = envDur2.indexToTime(durEvIdx);
                                 }
                              }
                              if((YAC_TYPE_VOID == typeid(v)) && (null != envDur1))
                              {
                                 v = envDur1.valueAtTimeSH(offset);
                                 if(YAC_TYPE_VOID != typeid(v))
                                 {
                                    durTicks = v;
                                    durCtlId = NT_TrackPattern.CTL_DUR1;
                                    durEvIdx = envDur1.timeToIndex(offset);
                                    durOffset = envDur1.indexToTime(durEvIdx);
                                 }
                              }

                              if(YAC_TYPE_VOID == typeid(v))
                                 durTicks = defDuration;
                              durTicks *= parent_node.dur_ticks;
                              pyb = timingViewPatOffsetToPy(offset + durTicks, centerOffset, _centerY);
                              break;
                        }

                        // trace "xxx    p=("+px+";"+py+") s=("+pw+";"+(pyb-py)+")";

                        if(pyb >= 0)
                        {
                           if(cel.ctl_id <= NT_TrackPattern.CTL_NOTE5)
                           {
                              // Top
                              if(noteNr & 1)
                                 UIRenderer.SetColorARGB(c32NoteTopEven);
                              else
                                 UIRenderer.SetColorARGB(c32NoteTopOdd);
                              if(UIRenderer.BeginLineStrip(2))
                              {
                                 UIRenderer.Vertex2f(px, py);
                                 UIRenderer.Vertex2f(px + pw, py);
                                 UIRenderer.End();
                              }

                              // Fill
                              if(noteNr & 1)
                                 UIRenderer.SetColorARGB(c32NoteFillEven);
                              else
                                 UIRenderer.SetColorARGB(c32NoteFillOdd);
                              if(UIRenderer.BeginFilledTriangleFan(4))
                              {
                                 UIRenderer.Vertex2f(px, py);
                                 UIRenderer.Vertex2f(px + pw, py);
                                 UIRenderer.Vertex2f(px + pw, pyb);
                                 UIRenderer.Vertex2f(px, pyb);
                                 UIRenderer.End();
                              }

                              // Left
                              UIRenderer.SetColorARGB(c32NoteLeft);
                              if(UIRenderer.BeginLineStrip(2))
                              {
                                 UIRenderer.Vertex2f(px, py+1);
                                 UIRenderer.Vertex2f(px, pyb);
                                 UIRenderer.End();
                              }

                              noteNr++;
                           }
                           else
                           {
                              // red line above non-note event
                              UIRenderer.SetColorARGB(c32Other);
                              if(UIRenderer.BeginLineStrip(2))
                              {
                                 UIRenderer.Vertex2f(px, py);
                                 UIRenderer.Vertex2f(px + pw, pyb);  // [08Apr2022] (note) diagonal ??
                                 UIRenderer.End();
                              }
                           }

                           NT_TimingBBox bb <= new NT_TimingBBox;
                           bb.init(px, py, px+pw, pyb,
                                   trackNr,
                                   cel.ctl_id,
                                   durCtlId,
                                   offset,
                                   durOffset,
                                   durTicks
                                   );
                           // trace "xxx bbox["+(timing_bboxes.numElements)+"]: plt=("+px+";"+py+") prb=("+(px+pw)+";"+pyb+") trackNr="+trackNr+" ctlid="+cel.ctl_id+" durCtlId="+durCtlId+" offset="+offset+" durOffset="+durOffset+" durTicks="+durTicks;

                           timing_bboxes.add(#(deref bb));
                        }
                        else
                        {
                           // Clipped
                           if(cel.ctl_id <= NT_TrackPattern.CTL_NOTE5)
                              noteNr++;
                        }

                        // Next event
                        envIdx += 2;
                     }
                  }

                  // Next cel
                  offX += cel.num_x * char_width;
               }

               celNr++;
            }
         }

         // Next track
         trackNr++;
         offX += 5 * char_width;  // skip space+patoff
      }

      UIRenderer.DisableBlending();
   }

   // <method_get.png>
   protected =replay= method getJamCurrentTicksForRedraw() : int {
      int patOffset = parent_node.jam_current_ticks;
      if(-1 == patOffset)
         patOffset = parent_node.jam_offset * parent_node.jam_tick_multiplier;  // pattern restart queued

      // Align to step resolution
      patOffset = (patOffset / step_resolution) * step_resolution;

      return patOffset;
   }

   // <ui_render.png>
   protected method handleDelayedRenderAndRedraw() {
      //
      // Handle (replay) scrolling and update render buffers
      //
      //  called from onDraw()
      //
      int patOffset = getJamCurrentTicksForRedraw();

      if(b_render_all) // is the redraw all flag set ?
      {
         // Position jump in song; redraw all
         // Global.Debug("PatternView: position jump to " + patOffset);
         parent_node.setReplayUIPatOffset(patOffset);
         if(parent_node.doAutoScroll())
            parent_node.setEditOffset(patOffset);
         renderAndRedrawAll();
         b_render_all = false;
      }
      else
      {
         if(replay.b_playing)
         {
            if(parent_node.doAutoScroll())
            {
               if(patOffset < parent_node.getReplayUIPatOffset())
               {
                  // Global.Debug("PatternView: jam position jump to " + patOffset);
                  parent_node.setReplayUIPatOffset(patOffset);
                  parent_node.setEditOffset(patOffset);
                  renderAndRedrawAll();
               }
               else
               {
                  while(parent_node.getReplayUIPatOffset() < patOffset)
                  {
                     if(scrollDownNoRedraw(true/*bIgnoreWrapAround*/))
                        renderAndRedrawAll();
                     parent_node.setReplayUIPatOffset(parent_node.getReplayUIPatOffset() + step_resolution);
                  }
               }
            }
         }
      }

      if(parent_node.ui_polystep_grace_timeout > 0)
         parent_node.ui_polystep_grace_timeout--;

      if((0 == parent_node.ui_polystep_grace_timeout) || !replay.b_playing)
         parent_node.setReplayUIPatOffset(patOffset);

      // Update texture resp. uv/color arrays according to dirty_flags[]
      updateMeshes();
   }

   // <ui_render.png>
   protected method drawPatternViewOverlays() {
      float centerY = calcCenterY();

      Point2f abspos;
      calcAbsolutePositionFBO(abspos);

      sdvg_PushScissor(abspos.x+0.5, abspos.y+0.5, size_x+0.5, size_y+0.5);
      sdvg_EnableScissor();

      // Draw block selection
      drawBlock(centerY);

      // Draw cursor
      drawCursor(centerY);

      // Draw mute X, equalizers and track name
      drawMuteAndEqualizersAndTrackNames(centerY);

      // Highlight row under mouse ?!
      drawMouseOverRowHighlights(centerY);

      // Draw multimute area
      if(last_multimute_tracknr >= 0)
      {
         UIRenderer.EnableBlending();
         UIRenderer.DrawFilledRectangle(0, TRACK_MUTE_MINY*UI.font_scaling, size_x, getTrackMuteMaxY() - TRACK_MUTE_MINY*UI.font_scaling,
                                        app_lnf.getColor(AppLookAndFeel.COLOR_NT_PV_TRACK_MULTIMUTE_AREA_BG)
                                        );
         UIRenderer.DisableBlending();
      }

      sdvg_PopScissor();
      sdvg_DisableScissor();
   }

   // <ui_render.png>
   public virtual onDrawOverlays() {
      // called when FBO compositing is enabled (UI.b_fbo)
      drawPatternViewOverlays();
   }

   // <ui.png>
   public virtual onLookAndFeelChanged() {
      Layer::onLookAndFeelChanged();
      genCtlColorPaletteWrapped();
      queueRedrawAll();
   }

   // <ui_render.png>
   public virtual onDraw() {

      if(b_queue_verify_track_shift)
      {
         b_queue_verify_track_shift = false;
         verifyTrackShift(true/*bAlignRight*/);
      }

      // trace "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ off="+getEditOffset();

      // Determine number of tracks in current channel
      int totalNumTracks = parent_node.tracks.numElements;

      // Draw background and set clipping rectangle
      UIRenderer.DrawDefaultBackground(0, 0, getSizeX(), getSizeY());

      // Early out: no tracks
      if(0 == totalNumTracks)
         return;

      Point2f abspos;
      calcAbsolutePosition(abspos);

      sdvg_PushScissor(abspos.x+0.5, abspos.y+0.5, size_x+0.5, size_y+0.5);
      sdvg_EnableScissor();

      // Determine vertical center of pattern view
      float centerY = calcCenterY();

      // Highlight every 'nth' tick
      if(0 != parent_node.ui_highlight_tick_modulo)
         drawTickMarkers(centerY);

      // Highlight center/replay rows
      if(b_hlcenter)
         drawCenterAndReplayRowMarker(centerY, true); // center row

      if(replay.b_playing)
      {
         if(!parent_node.doAutoScroll())
            drawCenterAndReplayRowMarker(centerY, false); // replay marker
      }

      // Handle delayed replay repaints / Scroll/update pattern render buffers
      handleDelayedRenderAndRedraw();

      // Draw pattern custom-bgcolor cels
      if(!parent_node.b_ui_timing_view)
      {
         if(b_bg_mesh)
            drawBGMesh();
      }

      // Draw pattern text grid
      drawPattern(centerY);

      if(parent_node.b_ui_timing_view)
         drawTimingMesh(centerY);

      //  (note) when using FBO compositing, these are drawn in onDrawOverlays()
      if(!UI.b_fbo)
         drawPatternViewOverlays();

      // Disable clipping rectangle
      sdvg_PopScissor();
      sdvg_DisableScissor();

      // Queue next redraw to continue equalizer animation
      if(replay.b_playing)
      {
         if(STConfig.b_node_tracker_draweq)
         {
            if(UI.b_fbo)
            {
               // equalizer is drawn via overlays
               UI.CompositeAll();
            }
            else
            {
               redraw();
            }
         }

         if(STConfig.b_node_tracker_smoothscroll)
         {
            // (note) smoothscroll heavily increases CPU usage (+100MHz on 2,8Ghz machine)
            redraw();
         }
      }

      if(parent_node.b_ui_queued_status_info_chord)
      {
         parent_node.b_ui_queued_status_info_chord = false;
         printCursorStatusInfoChord();
      }

   }

   // <method.png>
   protected method selectTrackAtPos(int pos) { // pos: upper word=trackidx, lower word=cursorx
      int oldCursorTrack = getCurrentTrackNr();
      setCurrentTrackNr(pos >> 16);
      setCursorX( (pos&0xFFFF) );
      if(oldCursorTrack != getCurrentTrackNr())
      {
         cursorTrackChanged();
         verifyTrackShift(true);
      }
      printCursorStatusInfo();
      redraw();
   }

   // <method.png>
   protected method getCELAtPos(int pos) : NT_CEL {
      int cursorTrack = (pos>>16);
      int cursorX     = (pos&0xFFFF);

      NT_Track track <= parent_node.getTrack(cursorTrack);
      if(null != track)
      {
         NT_TEL tel <= track.getTrackLayout();
         if(null != tel)
         {
            int ctlMapId = tel.cursor_to_ctl_map[cursorX];
            NT_CEL cel <= tel.ctl_layouts[ctlMapId & NT_TEL.CTLID_MASK]; // mask out MSB_FLAG
            return cel;
         }
      }
      return null;
   }

   // <ui_handle.png>
   protected method handleTimingViewAutoDouble() {
      if(STConfig.b_node_tracker_timing_view_autodouble_width ||
         STConfig.b_node_tracker_timing_view_autodouble_height
         )
      {
         handleCharSizeChanged();
         verifyTrackShift(true/*bAlignRight*/);
      }
   }

   // <ui_handle.png>
   public method toggleTimingView() {
      if(b_timing_mouse_drag)
      {
         // End drag
         b_timing_mouse_drag = false;
         parent_node.undoEndNested("timing drag");
      }

      parent_node.b_ui_timing_view = !parent_node.b_ui_timing_view;
      abortFreeDraw();
      selectNone();

      handleTimingViewAutoDouble();

      renderAndRedrawAll();

      Global.Print("Toggle timing view"+(parent_node.b_ui_timing_view_move_lock?" (move lock active)":""));
   }

   // <ui_handle.png>
   public method toggleTimingViewMoveLock() {
      parent_node.b_ui_timing_view_move_lock = !parent_node.b_ui_timing_view_move_lock;

      Global.Print("Timing view move lock is "+Utils.GetEnableString(parent_node.b_ui_timing_view_move_lock));
   }

   // <method.png>
   protected method timingViewFindAllDurations() {
      var v;

      NT_Track track <= getTrack(timing_mouse_drag_bbox.track_nr);

      if(null != track)
      {
         // CTL_DUR1
         v = parent_node.getEventAt(track, NT_TrackPattern.CTL_DUR1, timing_mouse_drag_bbox.dur_offset, 1);
         if(typeid(v) != YAC_TYPE_VOID)
            timing_mouse_drag_bbox_dur1_ticks = v * parent_node.dur_ticks;
         else
            timing_mouse_drag_bbox_dur1_ticks = -1;

         // CTL_DUR2
         v = parent_node.getEventAt(track, NT_TrackPattern.CTL_DUR2, timing_mouse_drag_bbox.dur_offset, 1);
         if(typeid(v) != YAC_TYPE_VOID)
            timing_mouse_drag_bbox_dur2_ticks = v * parent_node.dur_ticks;
         else
            timing_mouse_drag_bbox_dur2_ticks = -1;

         // CTL_DUR3
         v = parent_node.getEventAt(track, NT_TrackPattern.CTL_DUR3, timing_mouse_drag_bbox.dur_offset, 1);
         if(typeid(v) != YAC_TYPE_VOID)
            timing_mouse_drag_bbox_dur3_ticks = v * parent_node.dur_ticks;
         else
            timing_mouse_drag_bbox_dur3_ticks = -1;

         // CTL_DUR4
         v = parent_node.getEventAt(track, NT_TrackPattern.CTL_DUR4, timing_mouse_drag_bbox.dur_offset, 1);
         if(typeid(v) != YAC_TYPE_VOID)
            timing_mouse_drag_bbox_dur4_ticks = v * parent_node.dur_ticks;
         else
            timing_mouse_drag_bbox_dur4_ticks = -1;

         // CTL_DUR5
         v = parent_node.getEventAt(track, NT_TrackPattern.CTL_DUR5, timing_mouse_drag_bbox.dur_offset, 1);
         if(typeid(v) != YAC_TYPE_VOID)
            timing_mouse_drag_bbox_dur5_ticks = v * parent_node.dur_ticks;
         else
            timing_mouse_drag_bbox_dur5_ticks = -1;
      }
      else
      {
         // should not be reachable
      }
   }

   // <ui_handle.png>
   protected method handleTimingViewMouseEv(MouseEvent _ev) : boolean {

      float mx = _ev.mouse_rel_x;
      float my = _ev.mouse_rel_y;

      NT_Track *track;

      if(b_timing_mouse_drag)
      {
         if(0 == _ev.current_state)
         {
            // End drag
            b_timing_mouse_drag = false;
            parent_node.undoEndNested("timing drag");
            return true;
         }

         if(
            (b_timing_mouse_drag_start_lmb && _ev.rightButtonDown()) ||
            (!b_timing_mouse_drag_start_lmb && _ev.leftButtonDown())
            )
         {
            b_timing_mouse_drag = false;
            parent_node.undoEndNested("timing drag");
            parent_editor.cmd_edit_undo();
            Global.Print("Undo timing mouse drag");
            return true;
         }

         float dragRelY = my - timing_mouse_drag_start_y;
         float numTicksPerPix = float(step_resolution) / char_height;
         float dragRelTicks;

         int raster;

         if(b_timing_mouse_drag_start_lmb)
         {
            // Quantize to step resolution
            dragRelTicks = numTicksPerPix * dragRelY;
            dragRelTicks = int(dragRelTicks / step_resolution) * step_resolution;
            raster = step_resolution;
         }
         else
         {
            dragRelTicks = dragRelY * 0.25;
            raster = 1;
         }

         track <= getTrack(timing_mouse_drag_bbox.track_nr);

         if(null != track)
         {
            NT_TEL tel <= track.getTrackLayout();

            int newOffset = timing_mouse_drag_bbox.offset + dragRelTicks;
            if(newOffset < 0)
               newOffset = 0;

            int deltaOffset = newOffset - timing_mouse_drag_current_offset;

            boolean bDragEnd = (TIMING_DRAG_END == timing_mouse_drag_mode);

            if((TIMING_DRAG_START == timing_mouse_drag_mode) || (TIMING_DRAG_CENTER == timing_mouse_drag_mode))
            {
               int shiftIter = deltaOffset / raster;

               NT_CEL cel <= tel.findVisibleCelForCtlById(timing_mouse_drag_bbox.ctl_id);
               if(null != cel)
               {
                  int oldBlockMode = block_mode;

                  block_mode = (VMOD_LSHIFT == UI.GetKeyMod()) ? BLOCK_MODE_TRACK : ((VMOD_LSHIFT|VMOD_LCTRL) == UI.GetKeyMod()) ? BLOCK_MODE_PATTERN : BLOCK_MODE_CTL;

                  parent_node.pv_block_start_cursor_track = timing_mouse_drag_bbox.track_nr;
                  parent_node.pv_block_start_cursor_x     = (BLOCK_MODE_CTL == block_mode) ? tel.calcCursorXByCelIdx(tel.getVisibleIdxForCel(cel)) : 0;

                  parent_node.pv_block_end_cursor_track = timing_mouse_drag_bbox.track_nr;
                  parent_node.pv_block_end_cursor_x     = (BLOCK_MODE_CTL == block_mode) ? tel.calcCursorXByCelIdx(tel.getVisibleIdxForCel(cel)) : 0;

                  if(shiftIter > 0)
                  {
                     loop(shiftIter)
                     {
                        parent_node.pv_block_start_pat_offset = timing_mouse_drag_current_offset;
                        parent_node.pv_block_end_pat_offset   = timing_mouse_drag_current_offset + raster - 1;

                        if(blockShiftDownRes(raster, false/*bAllowScroll*/, false/*bQuiet*/))
                        {
                           timing_mouse_drag_current_offset += raster;

                           if(BLOCK_MODE_CTL != block_mode)
                           {
                              timing_mouse_drag_bbox.dur_offset += raster;
                           }
                        }
                        else
                           break;
                     }
                     selectNone();
                     ta_redraw_all.scheduleShort();
                  }
                  else if(shiftIter < 0)
                  {
                     loop(-shiftIter)
                     {
                        parent_node.pv_block_start_pat_offset = timing_mouse_drag_current_offset;
                        parent_node.pv_block_end_pat_offset   = timing_mouse_drag_current_offset + raster - 1;

                        if(blockShiftUpRes(raster, false/*bAllowScroll*/, false/*bQuiet*/))
                        {
                           timing_mouse_drag_current_offset -= raster;

                           if(BLOCK_MODE_CTL != block_mode)
                              timing_mouse_drag_bbox.dur_offset -= raster;
                        }
                        else
                           break;
                     }
                     selectNone();
                     ta_redraw_all.scheduleShort();
                  }

                  block_mode = oldBlockMode;

                  if(TIMING_DRAG_START == timing_mouse_drag_mode)
                  {
                     // Now move end (modify duration)
                     dragRelTicks = -dragRelTicks;
                     bDragEnd = true;
                  }
               }
            }

            if(bDragEnd)
            {
               // Drag end
               int newDurTicks = timing_mouse_drag_bbox.dur_ticks + dragRelTicks;
               int newDurVal = newDurTicks / parent_node.dur_ticks;
               if(newDurVal < 1)
                  newDurVal = 1;

               if(-1 != timing_mouse_drag_bbox.dur_ctl_id)
               {
                  if(VMOD_LSHIFT == UI.GetKeyMod())
                  {
                     // Modify all available durations (=> chords)

                     // CTL_DUR1
                     if(-1 != timing_mouse_drag_bbox_dur1_ticks)
                     {
                        newDurTicks = timing_mouse_drag_bbox_dur1_ticks + dragRelTicks;
                        newDurVal = newDurTicks / parent_node.dur_ticks;
                        if(newDurVal < 1)
                           newDurVal = 1;

                        parent_node.insertReplaceEventAtRes(track,
                                                            NT_TrackPattern.CTL_DUR1,
                                                            newDurVal,
                                                            timing_mouse_drag_bbox.dur_offset,
                                                            1
                                                            );
                     }

                     // CTL_DUR2
                     if(-1 != timing_mouse_drag_bbox_dur2_ticks)
                     {
                        newDurTicks = timing_mouse_drag_bbox_dur2_ticks + dragRelTicks;
                        newDurVal = newDurTicks / parent_node.dur_ticks;
                        if(newDurVal < 1)
                           newDurVal = 1;

                        parent_node.insertReplaceEventAtRes(track,
                                                            NT_TrackPattern.CTL_DUR2,
                                                            newDurVal,
                                                            timing_mouse_drag_bbox.dur_offset,
                                                            1
                                                            );
                     }

                     // CTL_DUR3
                     if(-1 != timing_mouse_drag_bbox_dur3_ticks)
                     {
                        newDurTicks = timing_mouse_drag_bbox_dur3_ticks + dragRelTicks;
                        newDurVal = newDurTicks / parent_node.dur_ticks;
                        if(newDurVal < 1)
                           newDurVal = 1;

                        parent_node.insertReplaceEventAtRes(track,
                                                            NT_TrackPattern.CTL_DUR3,
                                                            newDurVal,
                                                            timing_mouse_drag_bbox.dur_offset,
                                                            1
                                                            );
                     }

                     // CTL_DUR4
                     if(-1 != timing_mouse_drag_bbox_dur4_ticks)
                     {
                        newDurTicks = timing_mouse_drag_bbox_dur4_ticks + dragRelTicks;
                        newDurVal = newDurTicks / parent_node.dur_ticks;
                        if(newDurVal < 1)
                           newDurVal = 1;

                        parent_node.insertReplaceEventAtRes(track,
                                                            NT_TrackPattern.CTL_DUR4,
                                                            newDurVal,
                                                            timing_mouse_drag_bbox.dur_offset,
                                                            1
                                                            );
                     }

                     // CTL_DUR5
                     if(-1 != timing_mouse_drag_bbox_dur5_ticks)
                     {
                        newDurTicks = timing_mouse_drag_bbox_dur5_ticks + dragRelTicks;
                        newDurVal = newDurTicks / parent_node.dur_ticks;
                        if(newDurVal < 1)
                           newDurVal = 1;

                        parent_node.insertReplaceEventAtRes(track,
                                                            NT_TrackPattern.CTL_DUR5,
                                                            newDurVal,
                                                            timing_mouse_drag_bbox.dur_offset,
                                                            1
                                                            );
                     }
                  }
                  else
                  {
                     // Modify single duration
                     parent_node.insertReplaceEventAtRes(track,
                                                         timing_mouse_drag_bbox.dur_ctl_id,
                                                         newDurVal,
                                                         timing_mouse_drag_bbox.dur_offset,
                                                         1
                                                         );
                  }
               }
               else
               {
                  // (note) this value is not displayed (except in timing view mode)
                  parent_node.def_duration = newDurVal;
               }
               ta_redraw_all.scheduleShort();
            }
         } // if track
      }
      else
      {
         // Find intersecting bbox
         float threshold = 4;

         UI.RevertCursor();

         NT_TimingBBox *bb;

         timing_mouse_drag_mode = TIMING_DRAG_NONE;

         foreach bb in timing_bboxes
         {
            if(mx >= bb.xl)
            {
               if(mx < bb.xr)
               {
                  if(my >= (bb.yt-threshold))
                  {
                     if(!parent_node.b_ui_timing_view_move_lock && (my <= (bb.yt+threshold)))
                     {
                        // Top handle
                        UI.ShowCursor(isEditable() ? ((bb.ctl_id <= NT_TrackPattern.CTL_NOTE5) ? UIConstants.CURSOR_MOVEY : UIConstants.CURSOR_MOVE) : UIConstants.CURSOR_DENIED);
                        timing_mouse_drag_mode = TIMING_DRAG_START;

                        if(isEditable() && (_ev.leftButtonDown() || _ev.rightButtonDown()))
                        {
                           // Start drag top handle
                           timing_mouse_drag_bbox = bb;
                           timing_mouse_drag_start_y = my;
                           timing_mouse_drag_current_offset = bb.offset;

                           // Remember all durations for LSHIFT modifier
                           if(-1 != bb.dur_offset)
                           {
                              trace "xxx begin drag start";
                              timingViewFindAllDurations();
                           }
                           else
                           {
                              // Modify default duration (node global)
                           }

                           b_timing_mouse_drag = true;
                           b_timing_mouse_drag_start_lmb = _ev.leftButtonDown();
                           parent_node.undoBeginNested("timing drag");
                           return true;
                        }
                        return false;
                     }
                     else if(my <= (bb.yb - (parent_node.b_ui_timing_view_move_lock ? 0 : threshold)))
                     {
                        // Center handle
                        UI.ShowCursor(isEditable() ? UIConstants.CURSOR_MOVE : UIConstants.CURSOR_DENIED);
                        timing_mouse_drag_mode = TIMING_DRAG_CENTER;

                        if(isEditable() && (_ev.leftButtonDown() || _ev.rightButtonDown()))
                        {
                           // Start drag center handle
                           timing_mouse_drag_bbox = bb;
                           timing_mouse_drag_start_y = my;
                           timing_mouse_drag_current_offset = bb.offset;
                           b_timing_mouse_drag = true;
                           b_timing_mouse_drag_start_lmb = _ev.leftButtonDown();
                           parent_node.undoBeginNested("timing drag");
                           return true;
                        }
                        return false;
                     }
                  }

                  if(my >= (bb.yb-threshold))
                  {
                     if(my <= (bb.yb+threshold))
                     {
                        // Bottom handle
                        UI.ShowCursor(isEditable() ? UIConstants.CURSOR_MOVEY : UIConstants.CURSOR_DENIED);
                        timing_mouse_drag_bbox = bb;
                        timing_mouse_drag_start_y = my;
                        timing_mouse_drag_mode = TIMING_DRAG_END;

                        if(isEditable() && (_ev.leftButtonDown() || _ev.rightButtonDown()))
                        {
                           // Start drag bottom handle
                           timing_mouse_drag_bbox = bb;
                           timing_mouse_drag_start_y = my;
                           timing_mouse_drag_current_offset = bb.offset;

                           // Remember all durations for LSHIFT modifier
                           if(-1 != bb.dur_offset)
                           {
                              timingViewFindAllDurations();
                           }
                           else
                           {
                              // Modify default duration (node global)
                           }

                           b_timing_mouse_drag = true;
                           b_timing_mouse_drag_start_lmb = _ev.leftButtonDown();
                           parent_node.undoBeginNested("timing drag");
                           return true;
                        }
                        return false;
                     }
                  }
               }
            }
         }
      }

      return false;
   }

   // <ui_show.png>
   public method showAudioDialog() : boolean {
      if(null == dlg_audio)
      {
         dlg_audio <= new NT_AudioDialog();
         if(!dlg_audio.init())
         {
            trace "[---] NT_PatternView::showAudioDialog: failed to init NT_AudioDialog";
            return false;
         }
      }
      dlg_audio.showAudioDialog(this, parent_node);
   }

   // <method_find.png>
   public method findSmpUID(Integer _retDevIdxOrNull, Byte _retMidiChOrNull) : short {
      // Called when changing audio pattern and by NT_AudioDialog
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_TrackPattern pat <= track.getCurrentEditPattern();
         if(null != pat)
         {
            int editOffset = parent_node.getEditOffset();
            Envelope *env;
            NT_Instrument instr <= null;

            env <= pat.getEnvelope(NT_TrackPattern.CTL_INSTR);
            if(null != env)
            {
               var lastInstrBeforeEditOffset = env.valueAtTimeSH(editOffset);
               if(lastInstrBeforeEditOffset > 0)
                  instr <= parent_node.getInstrument(lastInstrBeforeEditOffset);
            }

            if(null == instr)
               instr <= parent_node.getInstrument(track.keyjazz_instr_nr);

            if(null != instr)
            {
               if(maybe == instr.b_audio)  // RPN smp_uid program change mode ?
               {
                  env <= pat.getEnvelope(NT_TrackPattern.CTL_PC);
                  if(null != env)
                  {
                     var lastPCBeforeEditOffset = env.valueAtTimeSH(editOffset);
                     Global.Debug("NT_PatternView::findSmpUID: editOffset="+editOffset+" lastPCBeforeEditOffset="+lastPCBeforeEditOffset);
                     if(lastPCBeforeEditOffset >= 0)
                     {
                        if(null != instr.out_device)
                        {
                           if(null != _retDevIdxOrNull)
                              _retDevIdxOrNull = instr.out_device.dev_idx;
                           if(null != _retMidiChOrNull)
                              _retMidiChOrNull = instr.midi_channel;
                        }
                        else
                        {
                           if(null != _retDevIdxOrNull)
                              _retDevIdxOrNull = -1;
                           if(null != _retMidiChOrNull)
                              _retMidiChOrNull = -1;
                        }
                        return lastPCBeforeEditOffset;
                     }
                  }
               }
            }

            if(null != instr)
            {
               if(maybe == instr.b_audio)
               {
                  if(null != instr.out_device)
                  {
                     if(null != _retDevIdxOrNull)
                        _retDevIdxOrNull = instr.out_device.dev_idx;
                     if(null != _retMidiChOrNull)
                        _retMidiChOrNull = instr.midi_channel;
                  }
                  else
                  {
                     if(null != _retDevIdxOrNull)
                        _retDevIdxOrNull = -1;
                     if(null != _retMidiChOrNull)
                        _retMidiChOrNull = -1;
                  }
                  return instr.smp_uid;
               }
            }
         }
      }
      return -1;
   }

   // <ui_show.png>
   public method showRandomDialog() {
      if(null == dlg_random)
      {
         dlg_random <= new NT_RandomDialog();
         if(!dlg_random.init())
         {
            trace "[---] NT_PatternView::showRandomDialog: failed to init NT_RandomDialog";
            return false;
         }
      }
      dlg_random.run(parent_editor, this, parent_node);
   }

   // <method.png>
   public method toggleKJInsFrameRecToPlay() {
      parent_node.setEnableEchoFrameRecToPlay(!parent_node.b_echo_frame_rec_to_play);
      Global.Print("Echo frame-rec to keyjazz-instrument is "+Utils.GetEnableString(parent_node.b_echo_frame_rec_to_play));
   }

   // <ui_mouse.png>
   public virtual onMouseFocus() {
      grabKeyboardFocus();
   }

   // <ui_mouse.png>
   public virtual isMouseFocusLocked() : boolean {
      return b_mouse_selection || (-1 != last_multimute_tracknr);
   }

   // <ui_mouse.png>
   public virtual onMouseHold(MouseEvent _ev) : boolean {

      if(_ev.mouse_rel_y < TRACK_MUTE_MINY*UI.font_scaling) // // TRACK_LABEL_HEIGHT
      {
         editCurrentTrackName();
         return true;
      }

      return false;
   }

   // <ui_mouse.png>
   public virtual wantOnMouseClickAfterOnMouseWasHandled() : boolean {
      return true;
   }

   // <ui_mouse.png>
   public virtual onMouseDoubleClick(MouseEvent _ev) : boolean {

      if(isEditable() && (-1 == freedraw_cursor_track) && !parent_node.b_ui_timing_view)
      {
         int pos = getCursorXAtPixel(_ev.getMouseRelX());
         if(-1 != pos)
         {
            // Show detail edit dialog for cell under mousecursor
            int editCursorTrack = (pos >> 16);
            int editCursorX     = (pos & 0xFFFF);
            int editPatPos      = getPatPosAtMouseRelY(_ev.getMouseRelY(), null);
            if(editPatPos < 0)
               editPatPos = 0;
            showDetailEditAt(editCursorTrack, editCursorX, editPatPos);
            return true;
         }
      }

      return false;
   }

   // <ui_mouse.png>
   public virtual onMouseBeginDrag(MouseEvent _dragStart, MouseEvent _ev) : boolean {

      if(-1 != last_multimute_tracknr)
         return false;

      if(parent_node.b_ui_timing_view && b_timing_mouse_drag)
         return false;

      if(_ev.isLeftButtonDown() && (-1 == freedraw_cursor_track) && !parent_node.b_ui_timing_view)
      {
         int pos = getCursorXAtPixel(_dragStart.getMouseRelX());
         if(-1 != pos)
         {
            selectTrackAtPos(pos);
            Float fHighlightRowY;
            int patpos = getPatPosAtMouseRelY(_dragStart.getMouseRelY(), fHighlightRowY);
            if(patpos >= 0)
            {
               if(parent_node.haveSelection())
               {
                  // Modify current selection
                  if(patpos == parent_node.pv_block_start_pat_offset)
                  {
                     // Modify start
                     block_modify_start = true;
                     blockBeginAt(patpos, false);
                  }
                  else if(patpos == parent_node.pv_block_end_pat_offset)
                  {
                     // Modify end
                     blockEndAt(patpos, false);
                  }
               }
               else
               {
                  selectNone();
                  // Start new selection
                  blockBeginAt(patpos, false);
               }
            }
            return true;
         }
      }
      else if(_ev.isRightButtonDown() && (-1 == freedraw_cursor_track))
      {
         b_rmb_scrolldrag = true;
         rmb_scrolldrag_delta = 0.0f;
         UI.ShowCursor(UIConstants.CURSOR_GRABBED);
         return true;
      }

      return false;
   }

   // <ui_mouse.png>
   protected method handleAutoscrollTracks(MouseEvent _lastEv, MouseEvent _currentEv) {

      // Autoscroll tracks left if mouse is on the left hand side of the first visible track
      boolean bCurL  = (_currentEv.mouse_rel_x <  ((NUM_SONGPOS_COLS+5)*char_width + 48));
      boolean bLastR = (_lastEv   .mouse_rel_x < ((NUM_SONGPOS_COLS+5)*char_width + 48));
      if(bCurL && bLastR)
      {
         if(_currentEv.mouse_rel_x <= _lastEv.mouse_rel_x)
         {
            autoscroll_tracks_dir = -1;
            ta_autoscroll_tracks.schedule();
            return;
         }
      }
      else if(!bCurL && !bLastR)
      {
         ta_autoscroll_tracks.cancel();
      }

      // Autoscroll tracks right if mouse is within 16 pixels distance to the right screen border
      //  (note) this is a corner case where the last visible track cel is aligned with the screen border
      //          usually autoscroll-tracks-right is done by selecting a partially visible track
      bCurL  = (_currentEv.mouse_rel_x >= (size_x - 48));
      bLastR = (_lastEv   .mouse_rel_x >= (size_x - 48));

      if(bCurL && bLastR)
      {
         if(_currentEv.mouse_rel_x >= _lastEv.mouse_rel_x)
         {
            autoscroll_tracks_dir = 1;
            ta_autoscroll_tracks.schedule();
         }
      }
      else if(!bCurL && !bLastR)
      {
         ta_autoscroll_tracks.cancel();
      }
   }

   // <method.png>
   protected method getTrackMuteMaxY() : int {
      int syquart = getSizeY() * 0.25;
      return mathMini(TRACK_MUTE_MAXY, syquart);
   }

   // <ui_mouse.png>
   public virtual onMouseDrag(MouseEvent _lastEv, MouseEvent _currentEv) : boolean {
      // trace "xxx onMouseDrag";

      if(b_rmb_scrolldrag)
      {
         float dy = (_currentEv.getMouseRelY() - _lastEv.getMouseRelY()) * STConfig.node_tracker_rmbdrag_speed;
         dy = mathClampf(dy, -STConfig.node_tracker_rmbdrag_maxdelta_y, STConfig.node_tracker_rmbdrag_maxdelta_y);
         rmb_scrolldrag_delta += dy;
         if(rmb_scrolldrag_delta > 0)
         {
            loop(rmb_scrolldrag_delta)
            {
               scrollUp();
               rmb_scrolldrag_delta -= 1.0f;
            }
         }
         else
         {
            loop(-rmb_scrolldrag_delta)
            {
               scrollDown();
               rmb_scrolldrag_delta += 1.0f;
            }
         }
         return true;
      }

      // Update block selection
      int pos = getCursorXAtPixel(_currentEv.getMouseRelX());
      if(-1 != pos)
      {
         selectTrackAtPos(pos);
         int oldPatOff = parent_node.getEditOffset();
         float mouseRelY = _currentEv.getMouseRelY();
         highlightRowUnderMouseY(_currentEv, 1.0, false); // changes ui_song_offset

         Float fHighlightRowY;

         int patpos = getPatPosAtMouseRelY(mouseRelY, fHighlightRowY);
         if(patpos < 0)
            patpos = 0;

         if(block_modify_start)
            blockBeginAt(patpos, false);
         else
            blockEndAt(patpos, false);

         parent_node.setEditOffset(oldPatOff); // don't scroll pattern

         ta_redraw_all.cancel();
         ta_redraw.schedule();

         // Autoscroll if mouse is near top/bottom border
         if(mouseRelY < 64)
         {
            autoscroll_dir = -1;
            autoscroll_ev = _currentEv;

            ta_autoscroll.schedule();
         }
         else if(mouseRelY > (size_y - 64))
         {
            autoscroll_dir = 1;
            autoscroll_ev = _currentEv;

            ta_autoscroll.schedule();
         }
         else
         {
            ta_autoscroll.cancel();
         }

         // // trace "xxx startx="+parent_node.pv_block_start_cursor_x+" endx="+parent_node.pv_block_end_cursor_x;
      }

      handleAutoscrollTracks(_lastEv, _currentEv);

      return true;
   }

   // <ui_mouse.png>
   public virtual onMouseEndDrag(MouseEvent _ev) {
      ////trace "xxx onMouseEndDrag";
      UI.RevertCursor();
      ta_autoscroll.cancel();
      ta_autoscroll_tracks.cancel();
      block_modify_start = false;
      b_rmb_scrolldrag = false;
   }

   // <ui_mouse.png>
   public virtual onMouseClick(MouseEvent _ev) : boolean {
      // (note) cursor_x is set in onMouse() handler

      if(0 == UI.GetKeyMod())
      {
         if(_ev.rightButtonUp())
         {
            if(-1 != freedraw_cursor_track)
            {
               abortFreeDraw();
               return true;
            }
            else
            {
               if(parent_node.haveSelection())
               {
                  showBlockContextMenu(true/*bHaveSel*/, false/*bFocusFirst*/);
                  return true;
               }
               else if(b_block_in_clipboard)
               {
                  showBlockContextMenu(false/*bHaveSel*/, false/*bFocusFirst*/);
                  return true;
               }
            }
         }

         // // if(!parent_node.b_ui_timing_view)
         if(!b_timing_mouse_drag)
         {
            if(parent_node.b_ui_timing_view && (0 != _ev.current_state))
               return true;

            if((!replay.b_playing || !parent_node.doAutoScroll()) && (-1 == freedraw_cursor_track))
            {
               if((parent_node.tracks.numElements) > 0)
               {
                  float mouseRelY = _ev.mouse_rel_y;
                  Float fHighlightRowY;
                  int patpos = getPatPosAtMouseRelY(mouseRelY, fHighlightRowY);
                  if(patpos < 0)
                     patpos = 0;
                  gotoPatPosition(patpos, true/*bClip*/);
               }
            }
         }
         selectNone();
         grabKeyboardFocus();

         if(_ev.leftButtonUp())
            return true;
      }

      return false;
   }

   // <ui_mouse.png>
   public virtual onMouse(MouseEvent _ev) : boolean {
      int pos;
      boolean ret = false;
      boolean bRightButtonUp = _ev.rightButtonUp();

      if(bRightButtonUp)
      {
         if(-1 != freedraw_cursor_track)
         {
            abortFreeDraw();
            return true;
         }
         else
         {
            if(_ev.mouse_rel_y < TRACK_LABEL_HEIGHT)
            {
               showTrackContextMenu(_ev);
               return true;
            }
         }
      }

      if(_ev.isLeftButtonDown() && !parent_node.b_ui_timing_view)
      {
         if(_ev.mouse_rel_y < getTrackMuteMaxY())
         {
            boolean bAllowMuteToggle;
            pos = getCursorXAtPixel(_ev.getMouseRelX());
            if(-1 != pos) // -1 in between tracks
            {
               // Select new cursor track (and cel)
               selectTrackAtPos(pos);
            }

            if(_ev.mouse_rel_y >= TRACK_MUTE_MINY*UI.font_scaling)
            {
               int muteTrackNr = getCurrentTrackNr();
               if(_ev.leftButtonDown())
               {
                  last_multimute_tracknr = muteTrackNr;
                  bAllowMuteToggle = true;
               }
               else
               {
                  if(muteTrackNr != last_multimute_tracknr)
                  {
                     last_multimute_tracknr = muteTrackNr;
                     bAllowMuteToggle = true;
                  }
                  else
                  {
                     bAllowMuteToggle = false;
                  }
               }
               if(bAllowMuteToggle)
               {
                  parent_editor.cmd_track_togglemute();
               }
            }
            return true;
         }
      }
      else
      {
         last_multimute_tracknr = -1;
      }

      boolean bRightButtonDown = _ev.rightButtonDown();
      if(bRightButtonDown)
      {
         if(-1 == freedraw_cursor_track)
         {
            if(_ev.mouse_rel_y < 24)
            {
               // Consume RMB down before showTrackContextMenu()
               return true;
            }
         }
      }

      if(parent_node.b_ui_timing_view)
      {
         if(handleTimingViewMouseEv(_ev))
            return true;
      }

      boolean bLeftButtonDown  = _ev.leftButtonDown();

      if(bLeftButtonDown || STConfig.b_node_tracker_highlight_mouseover_col || STConfig.b_node_tracker_info_mouseover_col)
      {
         if(bLeftButtonDown || STConfig.b_node_tracker_highlight_mouseover_col || STConfig.b_node_tracker_info_mouseover_col)
         {
            pos = getCursorXAtPixel(_ev.getMouseRelX());
            int infoCursorTrack = (pos>>16);
            int infoCursorX = (pos&0xFFFF);
            if(-1 != pos)
            {
               if(bLeftButtonDown)
               {
                  // Save current cursor position, it is used in gotoSongPosition() which
                  //  is called by highlightRowUnderMouseY() (see below)
                  block_swapback_start_pat_offset   = parent_node.getEditOffset();
                  block_swapback_start_cursor_track = getCurrentTrackNr();
                  block_swapback_start_cursor_x     = cursor_x;

                  selectTrackAtPos(pos);

                  selectInstrumentAtPos(pos); // if mouse is over CTL_INSTR cell
               }
               else if(STConfig.b_node_tracker_info_mouseover_col)
               {
                  if( (highlight_info_last_cursor_track!=infoCursorTrack) ||
                      (highlight_info_last_cursor_x!=infoCursorX) )
                  {
                     highlight_info_last_cursor_track = infoCursorTrack;
                     highlight_info_last_cursor_x = infoCursorX;
                     printCursorStatusInfoAt( infoCursorTrack, infoCursorX, false/*bChord*/ );
                  }
               }

               if(_ev.isRightButtonDown())
               {
                  // Edit controller bar/envelope
                  if(isEditable())
                  {
                     if(bRightButtonDown)
                     {
                        // Begin draw
                        freedraw_cursor_track = -1;

                        parent_node.undoBeginNested("freedraw ctl bar");  // ended via timeout
                     }
                     ret = freeDrawCtlBarAt(_ev, pos, bLeftButtonDown);
                  }
               }

               if(!ret && bRightButtonUp && (-1 == freedraw_cursor_track) && !parent_node.b_ui_timing_view)
               {
                  if(isEditable())
                  {
                     selectTrackAtPos(pos);

                     // Show detail edit dialog for cell under mousecursor
                     int editCursorTrack = (pos >> 16);
                     int editCursorX     = (pos & 0xFFFF);
                     int editPatPos      = getPatPosAtMouseRelY(_ev.getMouseRelY(), null);
                     if(editPatPos < 0)
                        editPatPos = 0;
                     showDetailEditAt(editCursorTrack, editCursorX, editPatPos);
                  }
               }

               ret = true;
            }
         }

         if(!replay.b_playing || !parent_node.doAutoScroll())
         {
            // the following call may also update ui_song_offset (via gotoSongPosition())
            highlightRowUnderMouseY(_ev, 1.0, _ev.leftButtonUp());
         }

         ret = true;
      }

      // Scroll <step_alignment> lines up or down
      if(_ev.wheelDown())
      {
         if(UI.GetKeyMod() == VMOD_LCTRL)
         {
            parent_editor.cmd_edit_zoomout();
         }
         else if((UI.GetKeyMod() == VMOD_LSHIFT) || _ev.isRightButtonDown())
         {
            moveCursorToNextTrackXClip();
         }
         else
         {
            pageDownAlign();
         }
         ret = true;
      }
      else if(_ev.wheelUp())
      {
         if(UI.GetKeyMod() == VMOD_LCTRL)
         {
            parent_editor.cmd_edit_zoomin();
         }
         else if((UI.GetKeyMod() == VMOD_LSHIFT) || _ev.isRightButtonDown())
         {
            moveCursorToPreviousTrackXClip(false/*bAlignRight*/);
         }
         else
         {
            pageUpAlign();
         }
         ret = true;
      }

      return ret;
   }

   // <method.png>
   public method getMouseRelYForRelSongPos(int relPos) : float {
      float r = calcCenterY() + relPos * char_height;
      return r;
   }

   // <method.png>
   protected method getPatPosAtMouseRelY(float mouseRelY, Float fHighlightRowY) : int {
      // Determine pattern position
      float centerY = calcCenterY(); // y pixel pos of uipatoffset
      float hlyShift = 0.0;

      boolean bDoubleCenter = useDoubleCenter();

      if(bDoubleCenter)
      {
         // center row has double height in zoom mode
         if(mouseRelY >= centerY)
         {
            if(mouseRelY >= (centerY + char_height) )
            {
               mouseRelY -= char_height;
               if(mouseRelY >= (centerY + char_height) )
                  hlyShift = char_height;
            }
         }
      }
      int patpos = (mouseRelY - centerY);
      int deltaPos;
      if(patpos < 0)
         deltaPos = - ((-patpos+char_height-1)/char_height);
      else
         deltaPos = (patpos / char_height);
      patpos = parent_node.getEditOffset() + deltaPos*step_resolution;
      if(null != fHighlightRowY)
         fHighlightRowY = centerY + hlyShift + deltaPos*char_height;

      return patpos;
   }

   // <method.png>
   public method highlightRowUnderMouseY(MouseEvent _ev, float incScale, boolean _bAllowSelectNone) {
      if((parent_node.tracks.numElements) > 0)
      {
         float mouseRelY = _ev.mouse_rel_y;
         Float fHighlightRowY;
         int patpos = getPatPosAtMouseRelY(mouseRelY, fHighlightRowY);
         if(patpos < 0)
            patpos = 0;

         // // trace "xxx PatternView::onMouse: track="+(pos>>16)+" cell="+(pos&0xFFFF)+" patpos="+patpos;

         if(_ev.isLeftButtonDown())
         {
            if(UI.GetKeyMod() == VMOD_LCTRL)
            {
               blockAncCancel();
               if(parent_node.haveSelection())
               {
                  blockSelectPatRange(parent_node.pv_block_start_pat_offset,
                                      parent_node.pv_block_start_cursor_track,
                                      parent_node.pv_block_start_cursor_x,
                                      patpos, getCurrentTrackNr(), cursor_x
                                      );
               }
               else
               {
                  blockSelectPatRange(block_swapback_start_pat_offset, block_swapback_start_cursor_track, block_swapback_start_cursor_x,
                                      patpos, getCurrentTrackNr(), cursor_x
                                      );
               }
            }
            else
            {
               if(_bAllowSelectNone && parent_node.haveSelection())
                  selectNone();

               ta_redraw_all.scheduleShort();
               // Jump to pattern position
            }
         } // isLeftButtonDown

         if(STConfig.b_node_tracker_highlight_mouseover_col)
         {
            incHighlightRowTimeout(HIGHLIGHT_MOUSEOVER_TIMEOUT * incScale);
            highlight_row_y = fHighlightRowY;

            ta_redraw_overlays.schedule();
         }
      } // if numTrack
   }

   // <ui_kbd.png>
   public method handleKeyDown(Key _k) : boolean {

      neighbour_hl_countdown = 0;

      next_keyjazz_note_ctl = -1;

      if(!(replay.b_playing && parent_node.doAutoScroll()))
      {
         if(_k.modCtrl())
         {
            if(_k.modShift())
            {
               if(parent_node.haveSelection())
               {
                  blockShiftDown();
                  return true;
               }
               else
               {
                  // handled by PageNode (select prev pipe)
                  return false;
               }
            }
            else if(VMOD_LCTRL == _k.mod)
            {
               pageDownFast();
               return true;
            }
         }
         else
         {
            if(_k.mod == VMOD_RSHIFT)
            {
               // (todo) never reached ? (rshift is record start)
               pageDown();
               return true;
            }
            else if( _k.modNone() || (VMOD_LSHIFT == _k.mod) )
            {
               blockAncTryBegin(_k);
               scrollDown();
               blockAncTryUpdate(_k);
               return true;
            }
         }
      }
      return false;
   }

   // <ui_kbd.png>
   public method handleKeyUp(Key _k) : boolean {

      neighbour_hl_countdown = 0;

      next_keyjazz_note_ctl = -1;

      if(!(replay.b_playing && parent_node.doAutoScroll()))
      {
         if(_k.modCtrl())
         {
            if(_k.modShift())
            {
               if(parent_node.haveSelection())
               {
                  blockShiftUp();
                  return true;
               }
               else
               {
                  // handled by PageNode (select prev pipe)
                  return false;
               }
            }
            else if(VMOD_LCTRL == _k.mod)
            {
               pageUpFast();
               return true;
            }
         }
         else
         {
            if(_k.mod == VMOD_RSHIFT)
            {
               pageUp();
               return true;
            }
            else if( _k.modNone() || (VMOD_LSHIFT == _k.mod) )
            {
               blockAncTryBegin(_k);
               scrollUp();
               blockAncTryUpdate(_k);
               return true;
            }
         }
      }
      return false;
   }

   // <ui_kbd.png>
   public method handleKeyLeft(Key _k) : boolean {

      neighbour_hl_countdown = HIGHLIGHT_NEIGHBOUR_TIMEOUT;
      ta_redraw_overlays.schedule();

      next_keyjazz_note_ctl = -1;

      if(_k.modCtrl())
      {
         if(_k.modShift())
         {
            if(!(replay.b_playing && parent_node.doAutoScroll()))
            {
               if(parent_node.haveSelection())
               {
                  blockShiftUpRes(1/*res*/, true/*bAllowScroll*/, false/*bQuiet*/);
                  return true;
               }
               else
               {
                  // Select previous node (in PageNode)
                  return false;
               }
            }
            return false;
         }
         else if(_k.modAlt())
         {
            moveCursorToPreviousColumnGroup();
            return true;
         }
         else
         {
            moveCursorToFirstColumnOrPreviousTrack();
            return true;
         }
      }
      else if( _k.modNone() || (VMOD_LSHIFT == _k.mod) )
      {
         blockAncTryBegin(_k);

         if(b_block_anc_active && (block_mode == BLOCK_MODE_TRACK))
            moveCursorToFirstColumnOrPreviousTrack();
         else
            moveCursorLeft();

         blockAncTryUpdate(_k);
         return true;
      }
      return false;
   }

   // <ui_kbd.png>
   public method handleKeyRight(Key _k) : boolean {

      neighbour_hl_countdown = HIGHLIGHT_NEIGHBOUR_TIMEOUT;
      ta_redraw_overlays.schedule();

      next_keyjazz_note_ctl = -1;

      if(_k.modCtrl())
      {
         if(_k.modShift())
         {
            if(!(replay.b_playing && parent_node.doAutoScroll()))
            {
               if(parent_node.haveSelection())
               {
                  blockShiftDownRes(1/*res*/, true/*bAllowScroll*/, false/*bQuiet*/);
                  return true;
               }
               else
               {
                  // Select next node (in PageNode)
                  return false;
               }
            }
            return false;
         }
         else if(_k.modAlt())
         {
            moveCursorToNextColumnGroup();
            return true;
         }
         else
         {
            moveCursorToLastColumnOrNextTrack();
            return true;
         }
      }
      else if( _k.modNone() || (VMOD_LSHIFT == _k.mod) )
      {
         blockAncTryBegin(_k);

         if(b_block_anc_active && (block_mode == BLOCK_MODE_TRACK))
            moveCursorToStartOfNextTrack();
         else
            moveCursorRight();

         blockAncTryUpdate(_k);

         return true;
      }
      return false;
   }

   // <ui_kbd.png>
   public method handleKeyPageUp(Key _k) : boolean {
      // Goto start of current/previous pattern

      next_keyjazz_note_ctl = -1;

      boolean bCtrl = _k.modCtrl();
      boolean bShift = _k.modShift();

      if(!_k.mod)
      {
         pageUpAlign();
         return = true;
      }
      else if(bShift && !bCtrl)
      {
         blockAncTryBegin(_k);
         pageUpAlign();
         blockAncTryUpdate(_k);
         return = true;
      }
      else if(bCtrl && !bShift)
      {
         if(!(replay.b_playing && parent_node.doAutoScroll()))
         {
            gotoPreviousEvent();
            return = true;
         }
      }
      // (note) lctrl - lshift seeks to next arranger clip start (see RootForm class)
   }

   // <ui_kbd.png>
   public method handleKeyPageDown(Key _k) : boolean {
      // Goto start of next pattern

      next_keyjazz_note_ctl = -1;

      boolean bCtrl = _k.modCtrl();
      boolean bShift = _k.modShift();

      if(!_k.mod)
      {
         pageDownAlign();
         return = true;
      }
      else if(bShift && !bCtrl)
      {
         blockAncTryBegin(_k);
         pageDownAlign();
         blockAncTryUpdate(_k);

         return = true;
      }
      else if(bCtrl && !bShift)
      {
         if(!(replay.b_playing && parent_node.doAutoScroll()))
         {
            gotoNextEvent();
            return = true;
         }
      }
      // (note) lctrl - lshift seeks to previous arranger clip start (see RootForm class)
   }

   // <ui_kbd.png>
   public method handleKeyRCtrl(boolean _bShift) {
      if(_bShift)
         parent_editor.cmd_edit_toggleshiftmode();
      else
         parent_editor.cmd_edit_togglemode(); // calls nextEditMode() and updates pulldown menu checkbox
   }

   // <ui_kbd.png>
   public method handleKeyTab(Key _k) : boolean {

      next_keyjazz_note_ctl = -1;

      if(_k.modShift())
      {
         if(!_k.modCtrl())
         {
            moveCursorToPreviousTrackX(false/*bAlignRight*/);
            return true;
         }
      }
      else if(_k.modNone())
      {
         moveCursorToNextTrackX();
         return true;
      }
      else if(VMOD_LCTRL == _k.mod)
      {
         // Also handled here in case patternview still has kbd focus but is not visible

         // workaround for InstrumentView parameter preselection
         parent_editor.instrument_view.selectKeyJazzInstr(true/*bCenter*/);

         parent_editor.toggleViews();
      }
      return false;
   }

   // <ui_kbd.png>
   public method handleKeyModShift(Key _k) : boolean {

      // trace "xxx handleKeyModShift: _k.code="+_k.code;

      switch(_k.pressed)
      {
         case VKEY_LEFTBRACKET/*91*/: // '[' (us), 'ü' (de)
            if(STConfig.b_node_tracker_reverse_zoom_keys)
               parent_editor.cmd_edit_zoomin();
            else
               parent_editor.cmd_edit_zoomout();
            return true;

         case VKEY_RIGHTBRACKET/*93*/: // ']' (us), 'ü' (de)
            if(STConfig.b_node_tracker_reverse_zoom_keys)
               parent_editor.cmd_edit_zoomout();
            else
               parent_editor.cmd_edit_zoomin();
            return true;

         case 'e':
         case 'E':
            parent_editor.cmd_track_reverse();
            return true;

         case 'o':
         case 'O':
            parent_editor.cmd_track_rotate_up();
            return true;

         case 'p':
         case 'P':
            parent_editor.cmd_track_rotate_down();
            return true;

         case 't':
         case 'T':
            parent_editor.cmd_pattern_trim_start_to_cursor();
            return true;
      }

      return false;
   }

   // <ui_kbd.png>
   public =replay= method handleKeyRShift(boolean _bCtrl) {
      if(replay.b_playing)
      {
         if(parent_node.b_rt_record)
            undoRecording();

         replay.stopReplay(!STConfig.b_node_tracker_swapstopbookmark, true/*bAllowPanic*/);
      }

      // Enable edit mode and realtime recording
      setEditMode(NodeTracker.PV_EDIT_STEP);
      parent_node.b_rt_record = true;

      if(_bCtrl)
      {
         // Continue recording from current step on
         startReplay();
      }
      else
      {
         // Record pattern
         loopCurrentPattern(false/*bFromCurOffset*/, true/*bStop*/);

         if(STConfig.b_node_tracker_precount)
            replay.startPreCount(STConfig.node_tracker_precount_num_bars);
      }

   }

   // <ui_kbd.png>
   public method handleKeySpace(boolean _bShift, _bCtrl) {

      // trace "xxx PV::handleKeySpace: bShift="+_bShift+" bCtrl="+_bCtrl;

      if(_bShift && _bCtrl)
      {
         parent_editor.cmd_replay_toggleignoreandfollow(maybe/*bForce=toggle*/);
         return;
      }

      if(parent_node.b_extclk)
      {
         if(!replay.b_playing)
         {
            current_song.seek(parent_node.nodeGetLastPatternStartSongOffset() + parent_node.getEditOffset());
         }
         root_form.handleToggleReplay(false/*bShift*/);
         return;
      }

      boolean bContinueBlockLoop = parent_node.b_block_loop;
      int oldBlockLoopStart = parent_node.block_loop_start;
      int oldBlockLoopLen = parent_node.block_loop_len;

      if(parent_node.haveSelection())
      {
         // Enable block-loop mode
         parent_node.setEnableBlockLoop(true);

         if( (oldBlockLoopStart == parent_node.block_loop_start) &&
             (oldBlockLoopLen   == parent_node.block_loop_len)
             )
         {
            // Stop block loop
            parent_node.setEnableBlockLoop(false);
            root_form.transportCycle(false);
            bContinueBlockLoop = false;
         }
         else if(!bContinueBlockLoop)
         {
            replay.setCycle(true/*bEnabled*/, true/*bQuiet*/);
            root_form.transportCycle(true);  // update icon
            Global.Print("Start block-loop  offAbs="+parent_node.block_loop_start+" offRel="+(parent_node.block_loop_start - parent_node.nodeGetLastPatternStartEditorSongOffset())+" len="+parent_node.block_loop_len);
         }
      }
      else if(parent_node.b_block_loop)
      {
         // Stop block loop
         parent_node.setEnableBlockLoop(false);
         root_form.transportCycle(false);
         bContinueBlockLoop = false;
      }

      if(replay.b_playing)
      {
         if(bContinueBlockLoop)
         {
            // Update Loop and continue playing
            current_song.queueNewLoop(parent_node.block_loop_start,  // start ticks
                                      parent_node.block_loop_start + parent_node.block_loop_len,  // end ticks
                                      false/*bQuiet*/
                                      );
            return true;
         }

         if(_bShift)
         {
            // // startReplay(); // Start song replay/switch from pattern to song replay
         }
         else
         {
            replay.stopReplay(!_bCtrl ^ STConfig.b_node_tracker_swapstopbookmark, true/*bAllowPanic*/); // allow jump-to-bookmark if lctrl is pressed

            current_song.seek(parent_node.getSongEditOffset());  // [17Jan2019] don't keyjazz-play first step
         }
      }
      else
      {
         if(_bCtrl)
         {
            // Start/Continue replay from current step
            loopCurrentPattern(true/*bFromCurOffset*/, true/*bStop*/);
         }
         else
         {
            if(_bShift)
               setPatternReplayOffsetToCursor();
            else
               loopCurrentPattern(false/*bFromCurOffset*/, true/*bStop*/);
         }
      }
   }

   // <ui_kbd.png>
   public =replay= method handleKeyReturn(boolean _bShift, boolean _bCtrl) : boolean {

      if(replay.b_playing && isEditable() && !_bShift && !_bCtrl)
      {
         Global.Debug2("PV: undo and restart pattern recording");

         parent_editor.cmd_edit_undo(); // undo and restart pattern
         return true;
      }

      parent_editor.cmd_replay_pat();

      if(_bCtrl)
      {
         // Set replay pattern to current edit pattern (handled in NodeTrackerEditor.cmd_replay_pat())
         return = true;
      }
      else
      {
         if(replay.b_playing)
         {
            if(!parent_node.doAutoScroll())
            {
               updatePatternLoop();
               return = true;
            }
            else
            {
               restartPattern();
               return = true;
            }
         }
         else
         {
            if(_bShift)
               playNoteAndCycle();
            else
               playStep();
            return = true;
         }
      }
      return;
   }

   // <ui_kbd.png>
   public method handleKeyDelete(boolean _bShift, boolean _bCtrl) : boolean {
      if(isEditable())
      {
         if(parent_node.haveSelection())
         {
            blockDelete(!_bShift, true/*bUndoStartEnd*/);
            selectNone();
            return = true;
         }
         else
         {
            if(_bShift ^ STConfig.b_node_tracker_swap_lshift)
            {
               if(b_insdel_shiftall_mode)
               {
                  parent_node.undoBeginNested("remove/clear track events");

                  // Remove note and other controller events
                  if(_bCtrl)
                  {
                     // Micro-move one tick
                     if(isPatternBlockMode())
                     {
                        // All tracks
                        removeAllTrackEventsAtEditOffsetRes(parent_node.getMicroShiftTicks()/*res*/);
                     }
                     else
                     {
                        // Current track
                        removeTrackEventRes(-1, parent_node.getMicroShiftTicks()/*res*/);
                     }

                     Global.Print("Delete tick (+"+getNextTrackEventStepOffset(-1)+")");
                  }
                  else
                  {
                     if(isPatternBlockMode())
                     {
                        // All tracks
                        removeAllTrackEventsAtEditOffset();
                     }
                     else
                     {
                        // Current track
                        removeTrackEvent(-1);
                     }
                  }

                  parent_node.undoEndNested("remove/clear track events");
               }
               else
               {
                  parent_node.undoBeginNested("relative remove track events");

                  // Only move next event (all ctl)
                  if(_bCtrl)
                  {
                     removeNextTrackEventRes(-1, parent_node.getMicroShiftTicks()/*res*/);

                     Global.Print("Delete tick (+"+getNextTrackEventStepOffset(-1)+")");
                  }
                  else
                  {
                     removeNextTrackEvent(-1);
                  }

                  parent_node.undoEndNested("relative remove track events");
               }

               return = true;
            }
            else
            {
               if(b_insdel_shiftall_mode)
               {
                  parent_node.undoBeginNested("remove/clear cel");

                  // Only remove current cel event(s)
                  if(_bCtrl)
                  {
                     removeTrackEventRes(getCurrentController(), parent_node.getMicroShiftTicks()/*res*/);

                     Global.Print("Delete tick (+"+getNextTrackEventStepOffset(getCurrentController())+")");
                  }
                  else
                  {
                     removeTrackEvent(getCurrentController());
                  }

                  parent_node.undoEndNested("remove/clear cel");
               }
               else
               {
                  parent_node.undoBeginNested("relative remove cel");

                  // Only move next event
                  if(_bCtrl)
                  {
                     removeNextTrackEventRes(getCurrentController(), parent_node.getMicroShiftTicks()/*res*/);

                     Global.Print("Delete tick(+"+getNextTrackEventStepOffset(getCurrentController())+")");
                  }
                  else
                  {
                     removeNextTrackEvent(getCurrentController());
                  }

                  parent_node.undoEndNested("relative remove cel");
               }

               return = true;
            }
         }

         redraw();

         ta_redraw_all.scheduleShort();
      }
      else
      {
         Global.Warning("delete failed: please change edit mode.");
      }
   }

   // <ui_kbd.png>
   public method handleKeyInsert(boolean _bShift, boolean _bCtrl) : boolean {
      if(isEditable())
      {
         selectNone();

         if(_bShift ^ STConfig.b_node_tracker_swap_lshift)
         {
            // Shift all controller events
            if(b_insdel_shiftall_mode)
            {
               parent_node.undoBeginNested("shift track events");

               // trace "xxx handleKeyInsert: bShift="+_bShift+" bCtrl="+_bCtrl;

               if(_bCtrl)
               {
                  if(isPatternBlockMode())
                  {
                     // All tracks
                     shiftAllTrackEventsAtEditOffsetRes(parent_node.getMicroShiftTicks()/*res*/);
                  }
                  else
                  {
                     // Current track
                     shiftTrackEventsRes(-1, parent_node.getMicroShiftTicks()/*res*/);
                  }

                  Global.Print("Insert tick (+"+getNextTrackEventStepOffset(-1)+")");
               }
               else
               {
                  if(isPatternBlockMode())
                  {
                     // All tracks
                     shiftAllTrackEventsAtEditOffset();
                  }
                  else
                  {
                     // Current track
                     shiftTrackEvents(-1);
                  }
               }

               parent_node.undoEndNested("shift track events");
            }
            else
            {
               parent_node.undoBeginNested("relative shift track events");

               if(_bCtrl)
               {
                  if(isPatternBlockMode())
                  {
                     // All tracks
                     shiftNextEventAllTracksRes(parent_node.getMicroShiftTicks()/*res*/);
                  }
                  else
                  {
                     // Current track
                     shiftNextTrackEventRes(-1/*allCtls*/, parent_node.getMicroShiftTicks()/*res*/);
                  }

                  Global.Print("Insert tick (+"+getNextTrackEventStepOffset(-1)+")");
               }
               else
               {
                  // trace "xxx shiftNextTrackEvent(-1)";
                  if(isPatternBlockMode())
                  {
                     // All tracks
                     shiftNextEventAllTracks();
                  }
                  else
                  {
                     // Current track
                     shiftNextTrackEvent(-1/*allCtls*/);
                  }
               }

               parent_node.undoEndNested("relative shift track events");
            }
         }
         else
         {
            // Shift current controller events
            if(b_insdel_shiftall_mode)
            {
               parent_node.undoBeginNested("shift cel");

               if(_bCtrl)
               {
                  shiftTrackEventsRes(getCurrentController(), parent_node.getMicroShiftTicks()/*res*/);

                  Global.Print("Insert tick (+"+getNextTrackEventStepOffset(getCurrentController())+")");
               }
               else
               {
                  shiftTrackEvents(getCurrentController());
               }

               parent_node.undoEndNested("shift cel");
            }
            else
            {
               parent_node.undoBeginNested("relative shift cel");

               if(_bCtrl)
               {
                  shiftNextTrackEventRes(getCurrentController(), parent_node.getMicroShiftTicks()/*res*/);

                  Global.Print("Insert tick (+"+getNextTrackEventStepOffset(getCurrentController())+")");
               }
               else
               {
                  shiftNextTrackEvent(getCurrentController());
               }

               parent_node.undoEndNested("relative shift cel");
            }
         }

         return = true;

         redrawAll();
      }
      else
      {
         Global.Warning("insert failed: please change edit mode.");
      }
   }

   // <ui_kbd.png>
   public method handleCtrlAcceleratorKey(Key _k) : boolean {
      // xxx Should use unicode but SDL reports unicode==1 for ctrl-a.. (which is perfectly correct, btw)
      switch(_k.pressed)
      {
         case 'd':
            // (note) popupmenu togglenodesolo
            return false;

        // case 'g':  // handled by PageNode (showPatternNumberDialog())

         case 'k':
            if(_k.modShift())
               splitPatternToClipboard(true/*bPasteNewPattern*/);
            else
               splitPatternToClipboard(false/*bPasteNewPattern*/);
            return true;

         case 'l':
            if(_k.modShift())
               parent_editor.cmd_pattern_lentocursor();
            else
               parent_editor.cmd_pattern_enterlen();
            return true;

         case 'o':
            parent_editor.cmd_events_copystate();
            return true;

         case 'n':
            parent_editor.cmd_pattern_alloc( (_k.modShift() ? true : false)/*bSub*/ );
            return true;

         case 's':
            // (note) popupmenu togglepipeolo
            return false;

         case 'r':
            parent_editor.cmd_pattern_clone( (_k.modShift() ? true : false)/*bSub*/ );
            return true;

         case 't':
            // // Global.cmd_midi_editmap_track();
            parent_editor.cmd_edit_collapse_and_tap();
            return true;

         case 'u':
            copyCurrentCtlToClipboard(_k.modShift()/*bClipboardB*/);
            return true;

         case 46: // . on ger kbd
            if(isEditable())
            {
               return true;
            }
            else
            {
               // // Global.Warning("decrease orderlist entry duration failed: please change edit mode.");
            }
            break;

         case 47: // '-' on ger kbd
            if(isEditable())
            {
               return true;
            }
            else
            {
               // // Global.Warning("increase orderlist entry duration failed: please change edit mode.");
            }
            break;

         case 'z': // 'y' on ger kbd
            if(isEditable())
            {
               toggleNoteOffAtCursorOrShowDetailEdit();
            }
            else
            {
               Global.Warning("toggle note off/show detail edit failed: please change edit mode.");
            }
            return true;

         case 'y': // 'z' on ger kbd
            if(_k.modShift())
               parent_editor.cmd_edit_redo();
            else
               parent_editor.cmd_edit_undo();
            return true;
      }
      return false;
   }

   // <ui_kbd.png>
   public =replay= method handleKeyJazzOrCelEditKey(Key _k, MIDIMapEvent _midiEv) : boolean {

      if(VKEY_EQUALS/*180*/ == _k.code)
         if(STConfig.b_node_tracker_reserve_equals_key_for_replay)
            return false;

      int note, instr, hex, patnr;
      NT_TEL *tel;
      NT_CEL *cel;

      boolean bKeyDown;
      boolean bKeyUp;
      int kjOctave;
      NT_Track *track;

      if(null == _midiEv)
      {
         bKeyDown = _k.pressed;
         bKeyUp = _k.released;

         kjOctave = parent_editor.keyJazzGetOctave();

         // Map keycode to MIDI note (offset)
         if(parent_editor.keyJazzIsEnabled())
         {
            note = Utils.KeycodeToMidiNote(_k.code);

            if(note >= 0)
            {
               // Track last played note
               track <= getCurrentTrack();
               if(null != track)
                  track.keyjazz_last_note = kjOctave + note;
            }
         }
         else
         {
            note = -1;
         }
      }
      else
      {
         bKeyDown = (MIDIMapDefs.TYPE_NOTE_ON == _midiEv.type);
         bKeyUp   = (MIDIMapDefs.TYPE_NOTE_OFF == _midiEv.type);

         kjOctave = 0;

         note = _midiEv.arg1;
      }

      tel <= getCurrentTrackLayout();

      if(null != tel)
      {
         int ctlMapId = tel.cursor_to_ctl_map[cursor_x];
         cel <= tel.ctl_layouts[ctlMapId&31]; // mask out MSB_FLAG

         int patOffset = getRecordPatOffsetEditor(true/*bMayQuantize*/);
         int recPatOffset = patOffset; // may be adjusted to existing event pos

         boolean bRTRecord = (replay.b_playing && parent_node.doAutoScroll());
         Integer recRaster = bRTRecord ? 1 : step_resolution;

         if(bKeyDown)
         {
            if(isEditable())
            {
               switch(cel.style)
               {
                  case NT_CEL.STYLE_NOTE:
                     if(note >= 0)
                     {
                        if(!_k.modShift())
                        {
                           if(_k.modCaps())
                           {
                              // Force Note-Off when capslock is turned on

                              parent_node.undoBeginNested("insert capslock noteoff");

                              selectNone();

                              if(!bRTRecord)
                                 recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                              parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, -(kjOctave + note), recPatOffset, recRaster);

                              if((NT_TrackPattern.CTL_NOTE1 == cel.ctl_id) && (null != parent_node.keyJazzGetInstrument())) // first note ctl?
                              {
                                 // Set instrument number + velocity + duration
                                 if(parent_node.isWriteInstrumentNrEnabled())
                                 {
                                    parent_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_INSTR,
                                                                             parent_node.keyJazzGetInstrumentNr(),
                                                                             recPatOffset,
                                                                             recRaster
                                                                             );
                                 }
                                 if(parent_node.isWriteOffVelocityEnabled())
                                 {
                                    parent_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_VEL1,
                                                                             parent_node.keyJazzGetNoteOffVelocity(),
                                                                             recPatOffset,
                                                                             recRaster
                                                                             );
                                 }
                              }

                              redrawRecordedPatPosition(patOffset);

                              if!(replay.b_playing && parent_node.doAutoScroll())
                              {
                                 scrollDownEventEntered();
                              }

                              parent_node.undoEndNested("insert capslock noteoff");

                              parent_node.queueStatusInfoChord();

                              return true;
                           }
                           else
                           {
                              parent_node.undoBeginNested("insert noteon");

                              selectNone();

                              if(!bRTRecord)
                                 recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                              // Note-On
                              parent_node.insertReplaceTrackEventAtRes(cel.ctl_id,
                                                                       kjOctave + note,
                                                                       recPatOffset,
                                                                       recRaster
                                                                       );

                              // Play note if replay is currently stopped
                              if(!replay.b_playing)
                                 parent_node.keyJazzNoteOn(kjOctave + note, -1/*vel*/);

                              if((NT_TrackPattern.CTL_NOTE1 == cel.ctl_id) && (null != parent_node.keyJazzGetInstrument())) // first note ctl?
                              {
                                 // Set instrument number + velocity + duration
                                 if(parent_node.isWriteInstrumentNrEnabled())
                                 {
                                    parent_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_INSTR,
                                                                             parent_node.keyJazzGetInstrumentNr(),
                                                                             recPatOffset,
                                                                             recRaster
                                                                             );
                                 }
                                 if(parent_node.isWriteVelocityEnabled())
                                 {
                                    parent_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_VEL1,
                                                                             parent_node.keyJazzGetNoteOnVelocity(),
                                                                             recPatOffset,
                                                                             recRaster
                                                                             );
                                 }
                                 if(parent_node.isWriteDurationEnabled())
                                 {
                                    parent_node.insertReplaceTrackEventAtRes(NT_TrackPattern.CTL_DUR1,
                                                                             parent_node.keyJazzGetDuration(),
                                                                             recPatOffset,
                                                                             recRaster
                                                                             );
                                 }
                              }

                              redrawRecordedPatPosition(patOffset);

                              if!(replay.b_playing && parent_node.doAutoScroll())
                                 scrollDownEventEntered();

                              parent_node.undoEndNested("insert noteon");

                              parent_node.queueStatusInfoChord();

                              return true;
                           }
                        } // !k.modShift
                     }
                     else if(_k.code == VKEY_BACKSLASH/*92*/) // \ on us kbd, # on ger kbd)
                     {

                        parent_node.undoBeginNested("insert all notes off");

                        selectNone();

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        if(_k.modShift())
                        {
                           // All channel notes off ("###")
                           parent_node.insertReplaceTrackEventAtRes(cel.ctl_id,
                                                                    NT_TrackPattern.MAGIC_NOTE_ALLCHANNELNOTESOFF/*-129*/,
                                                                    recPatOffset,
                                                                    recRaster
                                                                    );
                        }
                        else
                        {
                           // All track notes off ("===")
                           parent_node.insertReplaceTrackEventAtRes(cel.ctl_id,
                                                                    NT_TrackPattern.MAGIC_NOTE_ALLTRACKNOTESOFF/*-128*/,
                                                                    recPatOffset,
                                                                    recRaster
                                                                    );
                        }

                        redrawRecordedPatPosition(patOffset);

                        if!(replay.b_playing && parent_node.doAutoScroll())
                           scrollDownEventEntered();

                        parent_node.undoEndNested("insert all notes off");

                        return true;
                     }
                     break;

                  case NT_CEL.STYLE_LETTER:
                  case NT_CEL.STYLE_COLOR:
                     instr = Utils.KeycodeToInstrument(_k.unicode);
                     if(instr >= 0)
                     {
                        parent_node.undoBeginNested("insert letter cel");

                        if(NT_CEL.STYLE_COLOR == cel.style)
                           instr = instr % (STConfig.node_tracker_ctlcolor_palette.numElements);

                        selectNone();

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, instr, recPatOffset, recRaster);

                        redrawRecordedPatPosition(patOffset);

                        if!(replay.b_playing && parent_node.doAutoScroll())
                           scrollDownEventEntered();

                        parent_node.undoEndNested("insert letter cel");

                        return true;
                     }
                     else
                     {
                        // Play note if replay is currently stopped
                        if(!replay.b_playing)
                        {
                           if(!_k.modShift())
                           {
                              if(note >= 0)
                              {
                                 parent_node.keyJazzNoteOn(kjOctave + note, -1/*vel*/);
                                 return true;
                              }
                           }
                        }
                     }
                     break;

                  case NT_CEL.STYLE_HEX:
                     hex = Utils.KeycodeToHex(_k);
                     if(hex >= 0)
                     {
                        parent_node.undoBeginNested("insert hex cel");

                        selectNone();

                        if(!bRTRecord)
                        {
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                        }

                        if(ctlMapId & NT_TEL.MSB_FLAG)
                        {
                           insertReplaceTrackEventMSB4AtRes(cel.ctl_id, hex, recPatOffset, recRaster);

                           if(_k.modShiftOrCaps())
                              moveCursorRight();

                           b_minihex_last_auto_msb = true;
                        }
                        else
                        {
                           if(_k.modShiftOrCaps() && !b_minihex_last_auto_msb)
                           {
                              insertReplaceTrackEventMSB4AtRes(cel.ctl_id, hex, recPatOffset, recRaster);
                              b_minihex_last_auto_msb = true;
                           }
                           else
                           {
                              insertReplaceTrackEventLSB4AtRes(cel.ctl_id, hex, recPatOffset, recRaster);
                              b_minihex_last_auto_msb = false;
                           }
                        }

                        redrawRecordedPatPosition(patOffset);

                        if(_k.modNone())
                        {
                           if!(replay.b_playing && parent_node.doAutoScroll())
                              scrollDownEventEntered();
                        }

                        parent_node.undoEndNested("insert hex cel");

                        return true;
                     }
                     else
                     {
                        // Play note if replay is currently stopped
                        if(!replay.b_playing)
                        {
                           if(!_k.modShift())
                           {
                              if(note >= 0)
                              {
                                 parent_node.keyJazzNoteOn(kjOctave + note, -1/*vel*/);
                                 return true;
                              }
                           }
                        }
                     }
                     break;

                  case NT_CEL.STYLE_BAR4:
                  case NT_CEL.STYLE_BAR8:
                  case NT_CEL.STYLE_BAR16:
                  case NT_CEL.STYLE_BAR32:
                     hex = Utils.KeycodeToHex(_k);
                     if(hex >= 0)
                     {
                        parent_node.undoBeginNested("insert hex cel (bar)");

                        redrawRecordedPatPosition(patOffset);

                        Integer ioHex;

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        if(!b_minihex_lsb_save)
                        {
                           insertReplaceTrackEventMSB4AtRes(cel.ctl_id, hex, recPatOffset, recRaster);

                           ioHex = (parent_node.getTrackEventAt(cel.ctl_id, recPatOffset) & 0xF0) >> 4;
                           Global.PrintInteractive("minihex: 0x"+ioHex.printf("%1x")+"-");

                           b_minihex_lsb = true;

                           ta_minihex.schedule();
                        }
                        else
                        {
                           insertReplaceTrackEventLSB4AtRes(cel.ctl_id, hex, recPatOffset, recRaster);

                           ioHex = parent_node.getTrackEventAt(cel.ctl_id, recPatOffset);
                           Global.PrintShortInteractive("minihex: 0x"+ioHex.printf("%02x"));

                           ta_minihex.cancel();
                        }

                        parent_node.undoEndNested("insert hex cel (bar)");

                        selectNone();

                        return true;
                     }
                     else
                     {
                        // Play note if replay is currently stopped
                        if(!replay.b_playing)
                        {
                           if(!_k.modShift())
                           {
                              if(note >= 0)
                              {
                                 parent_node.keyJazzNoteOn(kjOctave + note, -1/*vel*/);
                                 return true;
                              }
                           }
                        }
                     }
                     break;

                  case NT_CEL.STYLE_PATNR3:
                     patnr = -1;

                     if(_k.pressed == '/')  // '-' on ger kbd
                     {
                        minipat3_last_auto = -1;
                        parent_node.undoBeginNested("insert patnr cel");

                        selectNone();

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, 255, recPatOffset, recRaster);
                        redrawRecordedPatPosition(patOffset);

                        if(_k.modNone())
                        {
                           if!(replay.b_playing && parent_node.doAutoScroll())
                              scrollDownEventEntered();
                        }

                        parent_node.undoEndNested("insert patnr cel");
                        return true;
                     }


                     if(_k.modShiftOrCaps())
                     {
                        if(-1 == minipat3_last_auto)
                        {
                           // Start mini-ed mode
                           minipat3_last_auto = 0;
                           minipat3_last_patnr = -1;

                           if(ctlMapId & NT_TEL.TSB_FLAG)
                           {
                           }
                           else if(ctlMapId & NT_TEL.MSB_FLAG)
                           {
                              moveCursorLeft();
                           }
                           else
                           {
                              moveCursorLeft();
                              moveCursorLeft();
                           }

                           ctlMapId = NT_TEL.TSB_FLAG;
                        }
                     }
                     else
                     {
                        minipat3_last_auto = -1;
                     }

                     String undoEndName = "";

                     if(ctlMapId & NT_TEL.TSB_FLAG)
                     {
                        switch(_k.pressed)
                        {
                           case '0': patnr = 0;  break;
                           case '1': patnr = 1;  break;
                           case '2': patnr = 2;  break;
                           case '3': patnr = 3;  break;
                           case '4': patnr = 4;  break; // for two-digit shortcut
                           case '5': patnr = 5;  break; // for two-digit shortcut
                           case '6': patnr = 6;  break; // for two-digit shortcut
                           case '7': patnr = 7;  break; // for two-digit shortcut
                           case '8': patnr = 8;  break; // for two-digit shortcut
                           case '9': patnr = 9;  break; // for two-digit shortcut
                        }

                        if(-1 == patnr)
                        {
                           minipat3_last_auto = -1;
                           break;
                        }

                        minipat3_last_patnr = patnr;

                        if(patnr > 3)
                        {
                           if(_k.modShiftOrCaps())
                           {
                              // On to second column
                              moveCursorRight();
                           }
                           break;
                        }

                        undoEndName = "insert patnr cel";
                        parent_node.undoBeginNested(undoEndName);
                        selectNone();

                        if(!bRTRecord)
                        {
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                        }

                        insertReplaceTrackEventPat1AtRes(cel.ctl_id, patnr, recPatOffset, recRaster);

                        if(_k.modShiftOrCaps())
                        {
                           // On to second column
                           moveCursorRight();
                        }

                     }
                     else if(ctlMapId & NT_TEL.MSB_FLAG)
                     {
                        switch(_k.pressed)
                        {
                           case '0': patnr = 0;  break;
                           case '1': patnr = 1;  break;
                           case '2': patnr = 2;  break;
                           case '3': patnr = 3;  break;
                           case '4': patnr = 4;  break;
                           case '5': patnr = 5;  break;
                           case '6': patnr = 6;  break;
                           case '7': patnr = 7;  break;
                           case '8': patnr = 8;  break;
                           case '9': patnr = 9;  break;
                        }

                        if(-1 == patnr)
                        {
                           if(_k.modShiftOrCaps())
                           {
                              patnr = Utils.KeycodeToHex(_k);
                              if(10 <= patnr <= 13) // 'a'..'d'
                              {
                                 patnr -= 10;

                                 // two-digit shortcut complete
                                 undoEndName = "insert patnr cel";
                                 parent_node.undoBeginNested(undoEndName);
                                 selectNone();

                                 if(!bRTRecord)
                                    recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                                 parent_node.insertReplaceTrackEventAtRes(cel.ctl_id,
                                                                          (minipat3_last_patnr - 1) * 4 + patnr,
                                                                          recPatOffset,
                                                                          recRaster
                                                                          );
                                 minipat3_last_auto = -1;
                              }
                              else
                              {
                                 break;
                              }
                           }
                           else
                           {
                              break;
                           }
                        }
                        else
                        {
                           undoEndName = "insert patnr cel";
                           parent_node.undoBeginNested(undoEndName);
                           selectNone();

                           if(!bRTRecord)
                              recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                           insertReplaceTrackEventPat2AtRes(cel.ctl_id, patnr, recPatOffset, recRaster);

                           if(_k.modShiftOrCaps())
                           {
                              // On to third column
                              moveCursorRight();
                           }
                        }
                     }
                     else
                     {
                        // Third column: ('a'..'d')

                        patnr = Utils.KeycodeToHex(_k);
                        if(10 <= patnr <= 13) // 'a'..'d'
                        {
                           patnr -= 10;
                        }
                        else
                        {
                           break;
                        }

                        undoEndName = "insert patnr cel";
                        parent_node.undoBeginNested(undoEndName);
                        selectNone();

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        insertReplaceTrackEventPat3AtRes(cel.ctl_id, patnr, recPatOffset, recRaster);

                        minipat3_last_auto = -1;
                     }

                     redrawRecordedPatPosition(patOffset);

                     if(_k.modNone())
                     {
                        if!(replay.b_playing && parent_node.doAutoScroll())
                           scrollDownEventEntered();
                     }

                     if(!undoEndName.isBlank())
                        parent_node.undoEndNested(undoEndName);

                     return true;

                  case NT_CEL.STYLE_PATNR2:
                     patnr = -1;

                     if(_k.pressed == '/')  // '-' on ger kbd
                     {
                        minipat3_last_auto = -1;
                        parent_node.undoBeginNested("insert patnr cel");

                        selectNone();

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        parent_node.insertReplaceTrackEventAtRes(cel.ctl_id, 255, recPatOffset, recRaster);

                        redrawRecordedPatPosition(patOffset);

                        if(_k.modNone())
                        {
                           if!(replay.b_playing && parent_node.doAutoScroll())
                              scrollDownEventEntered();
                        }

                        parent_node.undoEndNested("insert patnr cel");
                        return true;
                     }

                     if(_k.modShiftOrCaps())
                     {
                        if(-1 == minipat3_last_auto)
                        {
                           // Start mini-ed mode
                           minipat3_last_auto = 0;

                           if!(ctlMapId & NT_TEL.MSB_FLAG)
                              moveCursorLeft();

                           ctlMapId = NT_TEL.MSB_FLAG;
                        }
                     }
                     else
                     {
                        minipat3_last_auto = -1;
                     }

                     if(ctlMapId & NT_TEL.MSB_FLAG)
                     {
                        switch(_k.pressed)
                        {
                           case '0': patnr = 0;  break;
                           case '1': patnr = 1;  break;
                           case '2': patnr = 2;  break;
                           case '3': patnr = 3;  break;
                           case '4': patnr = 4;  break;
                           case '5': patnr = 5;  break;
                           case '6': patnr = 6;  break;
                           case '7': patnr = 7;  break;
                           case '8': patnr = 8;  break;
                           case '9': patnr = 9;  break;
                        }

                        if(-1 == patnr)
                        {
                           minipat3_last_auto = -1;
                           break;
                        }
                        else
                        {
                           parent_node.undoBeginNested("insert patnr cel");
                           selectNone();

                           if(!bRTRecord)
                           {
                              recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);
                           }

                           insertReplaceTrackEventPat1AtRes(cel.ctl_id, 0, recPatOffset, recRaster);
                           insertReplaceTrackEventPat2AtRes(cel.ctl_id, patnr, recPatOffset, recRaster);

                           if(_k.modShiftOrCaps())
                           {
                              // On to second column
                              moveCursorRight();
                           }
                        }
                     }
                     else
                     {
                        // Second column: ('a'..'d')

                        patnr = Utils.KeycodeToHex(_k);
                        if(10 <= patnr <= 13) // 'a'..'d'
                        {
                           patnr -= 10;
                        }
                        else
                        {
                           break;
                        }

                        parent_node.undoBeginNested("insert patnr cel");
                        selectNone();

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        insertReplaceTrackEventPat1AtRes(cel.ctl_id, 0, recPatOffset, recRaster);
                        insertReplaceTrackEventPat3AtRes(cel.ctl_id, patnr, recPatOffset, recRaster);

                        minipat3_last_auto = -1;
                     }

                     redrawRecordedPatPosition(patOffset);

                     if(_k.modNone())
                     {
                        if!(replay.b_playing && parent_node.doAutoScroll())
                           scrollDownEventEntered();
                     }

                     parent_node.undoEndNested("insert patnr cel");

                     return true;

                  case NT_CEL.STYLE_HI_NIBBLE:
                  case NT_CEL.STYLE_LO_NIBBLE:
                     instr = Utils.KeycodeToInstrument(_k.unicode);
                     if(instr >= 0)
                     {
                        parent_node.undoBeginNested("insert hi_nibble cel");

                        instr = mathClampi(instr, 0, 15);

                        selectNone();

                        if(!bRTRecord)
                           recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, recPatOffset, recRaster);

                        if(NT_CEL.STYLE_LO_NIBBLE == cel.style)
                        {
                           insertReplaceTrackEventLSB4AtRes(cel.ctl_id, instr, recPatOffset, recRaster);
                        }
                        else
                        {
                           insertReplaceTrackEventMSB4AtRes(cel.ctl_id, instr, recPatOffset, recRaster);
                        }

                        redrawRecordedPatPosition(patOffset);

                        if!(replay.b_playing && parent_node.doAutoScroll())
                           scrollDownEventEntered();

                        parent_node.undoEndNested("insert hi_nibble cel");

                        return true;
                     }
                     else
                     {
                        // Play note if replay is currently stopped
                        if(!replay.b_playing)
                        {
                           if(!_k.modShift())
                           {
                              if(note >= 0)
                              {
                                 parent_node.keyJazzNoteOn(kjOctave + note, -1/*vel*/);
                                 return true;
                              }
                           }
                        }
                     }
                     break;

               } // switch cel.style

               // '\' on UK kbd, '<' on ger kbd    events_deleteeventmove / events_deleteeventsmove
               // '/' on US kbd with UI.b_key_map_slash_to_less == true
               if(_k.code == VKEY_LESS/*60*/)
               {
                  ////trace "xxx clear event";

                  if(parent_node.haveSelection())
                  {
                     blockClear();
                     parent_node.queueStatusInfoChord();
                  }
                  else
                  {
                     parent_node.undoBeginNested("clear event(s)");

                     selectNone();

                     if(_k.modShift())
                     {
                        // All controllers
                        removeTrackEvent(-1);
                        shiftTrackEvents(-1);
                     }
                     else
                     {
                        // Current controller only
                        removeTrackEvent(cel.ctl_id);
                        shiftTrackEvents(cel.ctl_id);
                     }

                     redrawRecordedPatPosition(patOffset);

                     if!(replay.b_playing && parent_node.doAutoScroll())
                        scrollDownEventEntered();

                     parent_node.undoEndNested("clear event(s)");

                     parent_node.queueStatusInfoChord();
                  }

                  return true;
               }

               if(-1 != minipat3_last_auto)
               {
                  // Don't let default kbd handler handle this key in 'mini' mode
                  //  (e.g. when 'd' is typed in the wrong column)
                  return true;
               }

            } // if editable
            else
            {
               if(!_k.modShift() && !_k.modCaps())
               {
                  if(note >= 0)
                  {
                     parent_node.keyJazzNoteOn(kjOctave + note, -1/*vel*/);
                     return true;
                  }
               }
            }
         } // if bKeyDown
         else
         {
            if(!_k.modShift())
            {
               if(note >= 0)
               {
                  // Write note-off while recording
                  if(NodeTracker.DoRecordNoteOff())
                  {
                     if(bRTRecord)
                     {
                        if(isEditable())
                        {
                           switch(cel.style)
                           {
                              case NT_CEL.STYLE_NOTE:
                                 // (todo) implement duration recording via keyjazz
                                 if(!STConfig.b_node_tracker_recordnoteoff_dur)
                                 {
                                    parent_node.undoBeginNested("record noteoff");
                                    if(!bRTRecord)
                                       recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(cel.ctl_id, patOffset, recRaster);
                                    else
                                       recPatOffset = patOffset;

                                    parent_node.insertReplaceTrackEventAtRes(cel.ctl_id,
                                                                             -(kjOctave + note),
                                                                             //////patOffset,
                                                                             recPatOffset,
                                                                             recRaster
                                                                             );
                                    parent_node.undoEndNested("record noteoff");
                                    redrawRecordedPatPosition(patOffset);
                                 }
                                 return true;
                           }
                        }
                     }
                  }

                  parent_node.keyJazzNoteOff(kjOctave + note);
                  return true;
               } // if note >= 0
            }
         }
      } // if null != tel

      return false;
   }

   // <ui_handle.png>
   public method tryEditSound() : boolean {
      NT_Track track <= getCurrentTrack();
      if(null != track)
      {
         NT_Instrument ins <= parent_node.getCurrentTrackInstrument();
         if(null != ins)
         {
            STX_MIDIOutDevice outDev <= ins.out_device;
            if(null != outDev)
            {
               byte outCh = ins.midi_channel;

               // Audio pattern ?
               byte vstDevIdx = outDev.getVSTDevIdx();
               if(ins.b_audio && vstDevIdx >= 0)
               {
                  short smpUID = findSmpUID(null/*retDevIdxOrNull*/, null/*retMidiChOrNull*/);
                  if(smpUID >= 0)
                  {
                     float selStartMS;
                     float selLenMS;
                     if(parent_node.haveSelection())
                     {
                        int blockStart = mathMini(parent_node.getCurrentEditMetaPatternLength(), parent_node.getSortedBlockStartOffset());
                        selStartMS = current_song.ticksToMilliSeconds(blockStart);
                        int blockEnd = mathMini(parent_node.getCurrentEditMetaPatternLength(), parent_node.getSortedBlockEndOffset() + step_resolution);
                        selLenMS   = current_song.ticksToMilliSeconds(blockEnd) - selStartMS;
                     }
                     else
                     {
                        selStartMS = current_song.ticksToMilliSeconds(parent_node.pv_pat_offset);
                        selLenMS   = current_song.ticksToMilliSeconds(step_resolution);
                     }

                     parent_node.tryEditSampleInEureka(smpUID,
                                                       vstDevIdx,
                                                       outCh,
                                                       false/*bShowEurekaWindow*/,
                                                       selStartMS,
                                                       selLenMS
                                                       );
                     return true;
                  }
               }


               MIDISynthProfile msp <= outDev.getMIDISynthProfile(outCh/*midiCh*/);
               if(null != msp)
               {
                  int noteIdxHint = -1;
                  Global.Debug("NT_PatternView::tryEditSound: outDev=\""+outDev.getAliasOrDeviceName()+"\" ch="+(outCh+1)+" msp.id=\""+msp.midi_profile_id+"\" noteIdxHint="+noteIdxHint+"("+(MIDI.midi_notes.get(noteIdxHint))+")");

                  if(Global.TryEditSound(outDev, outCh, msp, noteIdxHint))
                     return true;

                  Global.Warning("tryEditSound: failed to find editor");
               }
               else
                  Global.Warning("tryEditSound: outDev msp is null");
            }
            else
               Global.Warning("tryEditSound: outDev is null");
         }
         else
            Global.Warning("tryEditSound: track instrument is null");
      }
      else
         Global.Warning("tryEditSound: track is null");
      return false;
   }

   // <ui_handle.png>
   public method tryEditInstrumentAudioSample() : boolean {
      NT_Instrument ins <= parent_node.getCurrentTrackInstrument();
      if(null != ins)
      {
         if(ins.smp_uid >= 0)
         {
            SysEx.QueueSendSmpEdit(ins.smp_uid, -1/*instanceIdHint*/, 0/*selStartMS*/, -1/*selLenMS*/, -1/*noteIdxHint*/);
         }
         else
         {
            Global.Warning("Edit instr. audio sample: invalid smp_uid="+ins.smp_uid);
         }
      }
      else
      {
         Global.Warning("Edit instr. audio sample: no instrument selected");
      }
   }

   // <ui_midi.png>
   public method mmlHandleEventUI(MIDIMapEvent _ev) : boolean {
      // Forwarded from NodeTrackerEditor
      //  (note) this is called from UI thread via Replay.processMidiMapUIEventQueue()

      // (note) 26Jul2015: event recording now handled in recordFrame() (via nodeProcessFrame())

      return false;
   }

   // <ui_kbd.png>
   public virtual wantKeyboardFocus() : boolean {
      return true;
   }

   // <ui_kbd.png>
   public virtual onKeyboardFocusLost(boolean _bQuiet) {
      //trace "xxx PatternView: onKeyboardFocusLost";
   }

   // <ui_kbd.png>
   public virtual wantKeyRepeat(Key _k) {

      if(_k.modNone())
      {
         // No key repeat for keyjazz when edit mode is active (som
         boolean bRepeat = true;

         if(replay.b_playing && parent_node.doAutoScroll())
         {
            bRepeat = (-1 == Utils.KeycodeToMidiNote(_k.code));
            return bRepeat;
         }
         else
         {
            if(NodeTracker.PV_EDIT_NONE == parent_node.pv_edit_mode)
            {
               bRepeat = (-1 == Utils.KeycodeToMidiNote(_k.code));
               return bRepeat;
            }
         }
      }
      return true;
   }

   // <ui_kbd.png>
   public virtual onBeginTriadKeyMode() : boolean {
      Global.Print("lctrl-x - ");
      return true;
   }

   // <ui_kbd.png>
   public virtual onEndTriadKeyMode(Key _k) : boolean {
      switch(_k.code)
      {
         case VKEY_LEFT:
         case VKEY_RIGHT:
         case VKEY_UP:
         case VKEY_DOWN:
            // trace "[dbg] PatternView::onEndTriadKeyMode: (inc/dec)  _k.code="+_k.code+" _k.mod="+_k.mod;
            parent_node.undoEndNested("ctl inc/dec");
            break;
      }

      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {
      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          0         :   Show Randomizer Dialog
          1         :   Select pipenode A (use lctrl-x z to switch between A and B)
          2         :   Select pipenode B
          9         :   Toggle echo-frame-rec-events-to-keyjazz-instrumnent-frameplay
          a         :   Select keyjazz instrument from current step OR show AudioDialog
          b         :   Change block selection mode (column,controller,track,pattern)
          c         :   Start output capture
          d         :   Toggle pattern manager
          e         :   Reverse pattern
          f         :   Calc delay ticks
          g         :   Toggle free-run loop
          h         :   Toggle recording latency
          i         :   Add cel (column)
          j         :   Collapse events
          k         :   Auto-colorize cels (preserves custom cel colors)
          l         :   Toggle KeyJazz lock
          m         :   Multiply delta-times by constant
          n         :   Quick add note cel
          o         :   Toggle chord-clear-step mode
          p         :   Toggle velocity+duration cel styles (bar+hi_nibble / hex)
          [         :   Toggle alternative cel styles ('ü' on german kbd)
          q         :   Toggle pattern autoscroll mode
          r         :   Toggle pattern wrap-around mode
          s         :   Edit current tracklayout
          t         :   Start/toggle tap mode
          u         :   Focus node name widget
          v         :   Paste output capture buffer to current pattern
          w         :   Swap (lctrl-)space behaviour (stop + goto-bookmark / stop at current position)
          z         :   Switch between pipenodes A/B ('y' on german kbd)
          F3        :   Free pattern
          TAB       :   Cycle pattern/play/arp views
          SPACE     :   Show column selection dialog / wizard
          RSHIFT    :   Toggle record note off events
          RCTRL     :   Toggle recording pre-count
          ,         :   Upload capture buffer to (Eureka) procedural track sample
          .         :   Toggle record-CTL_USR-at-note-on mode
          /         :   Toggle CTL_DUR recording ('-' on german kbd)
          RETURN    :   Toggle record quantization
       NUMPAD ENTER :   Toggle record quantization
                  = :   Toggle record quantization (` on german kbd)
 LEFT/RIGHT UP/DOWN :   Inc/Dec controller value fine/coarse (repeats)
          PAGEUP    :   Rotate pattern up
          PAGEDOWN  :   Rotate pattern down
          HOME      :   Global program change (master pipe, auto dev+ch A)
          END       :   Global program change (master pipe, auto dev+ch B)
          BACKSPACE :   Toggle ignore prgchg/mute mode
          INSERT    :   Toggle follow-replay edit mode
          DELETE    :   Swap lshift-DELETE (clear step) / DELETE (clear ctl) behaviour
          \\        :   Export pattern to output capture buffer ('<' on german kbd)
          `         :   Toggle Piano Widget (^ on german kbd)
"
          // // HOME      :   Show step alignment dialog
          // // END       :   Show tick highlight modulo dialog
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual wantTriadKeyRepeat(Key _k) : boolean {
      switch(_k.code)
      {
         case VKEY_LEFT:
         case VKEY_RIGHT:
         case VKEY_UP:
         case VKEY_DOWN:
         case VKEY_PAGEUP:
         case VKEY_PAGEDOWN:
         case 'n':  // add note cel
         case 'b':  // block mode
               return true;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      // trace "xxx pv::onTriadKey: _k.pressed="+_k.pressed+" _k.code="+_k.code;
      int key = _k.pressed;
      boolean r = false;

      loop(2) // first pass for raw keycode, second pass for unicode
      {
         // US (reference) keyboard layout (raw keycodes)
         switch(key)
         {
            case VKEY_LEFT:
               if(isEditable())
               {
                  parent_node.undoBeginNested("ctl inc/dec");  // ended in onEndTriadKeyMode()
                  if(parent_node.haveSelection())
                     blockIncDecCurrentCtl(-1, false/*bCoarse*/);
                  else
                     incDecCurrentCtl(-1, false/*bCoarse*/);
               }
               r = true; break;

            case VKEY_RIGHT:
               if(isEditable())
               {
                  parent_node.undoBeginNested("ctl inc/dec");  // ended in onEndTriadKeyMode()
                  if(parent_node.haveSelection())
                     blockIncDecCurrentCtl(1, false/*bCoarse*/);
                  else
                     incDecCurrentCtl(1, false/*bCoarse*/);
               }
               r = true; break;

            case VKEY_UP:
               if(isEditable())
               {
                  parent_node.undoBeginNested("ctl inc/dec");  // ended in onEndTriadKeyMode()
                  if(parent_node.haveSelection())
                     blockIncDecCurrentCtl(1, true/*bCoarse*/);
                  else
                     incDecCurrentCtl(1, true/*bCoarse*/);
               }
               r = true; break;

            case VKEY_DOWN:
               if(isEditable())
               {
                  parent_node.undoBeginNested("ctl inc/dec");  // ended in onEndTriadKeyMode()
                  if(parent_node.haveSelection())
                     blockIncDecCurrentCtl(-1, true/*bCoarse*/);
                  else
                     incDecCurrentCtl(-1, true/*bCoarse*/);
               }
               r = true; break;

            case '0':
               showRandomDialog();
               r = true; break;

            case '9':
               toggleKJInsFrameRecToPlay();
               r = true; break;

            case 'a':
               if(!selectInstrumentAtCurrentStep())
                  showAudioDialog();
               r = true; break;

            case 'b':
               nextBlockMode();
               r = true; break;

            case 'c':
               parent_editor.cmd_pattern_capture_begin();
               r = true; break;

            case 'e':
               parent_editor.cmd_pattern_reverse();
               r = true; break;

            case 'f':
               parent_editor.cmd_events_calcdelayticks();
               r = true; break;

            case 'g':
               parent_editor.cmd_replay_togglefreerun();
               r = true; break;

            case 'h':
               parent_editor.cmd_events_reclatency();
               r = true; break;

            case 'i':
               parent_editor.cmd_track_addcel_dlg();
               r = true; break;

            case 'j':
               parent_editor.cmd_events_collapse();
               r = true; break;

            case 'k':
               parent_editor.cmd_track_autocolorizecels();
               r = true; break;

            case 'l':
               parent_editor.cmd_track_lockkeyjazz();
               r = true; break;

            case 'm':
               parent_editor.cmd_events_timemulconst_dlg();
               r = true; break;

            case 'n':
               parent_editor.cmd_track_addnotecel();
               r = true; break;

            case 'o':
               parent_editor.cmd_edit_toggle_chordclearstep();
               r = true; break;

            case 'p':
               parent_editor.cmd_track_toggleveldurstyles();
               r = true; break;

            case '[':  // ü
               parent_editor.cmd_track_togglealtstyles();
               r = true; break;

            case VKEY_F3:
               parent_editor.cmd_pattern_free(true/*bFreeMeta*/, true/*bUndoBegin*/);
               return true;

            case 'q':
               parent_editor.cmd_cursor_autoscroll(); // calls toggleAutoScroll() and updates pulldown menu
               r = true; break;

            case 'r':
               parent_editor.cmd_cursor_wraparound(); // calls togglePatternWrapAroundMode() and updates pulldown menu
               r = true; break;

            case 's':
               parent_editor.cmd_track_editlayout();
               r = true; break;

            case 't':
               parent_editor.cmd_edit_tapmode();
               r = true; break;

            case 'v':
               parent_editor.cmd_pattern_capture_paste();
               r = true; break;

            case 'w':
               parent_editor.cmd_replay_invertspace();
               r = true; break;

            case ' ':
               parent_editor.cmd_cursor_jumptocolumn();
               r = true; break;

            case '/':
               parent_editor.cmd_events_recordnoteoff_dur();
               r = true; break;

            case '\\':
            case 60:
               parent_editor.cmd_pattern_exportmon();
               r = true; break;

            case ',':
               parent_editor.cmd_pattern_capture_upload_to_eureka();
               r = true; break;

            case '.':
               parent_editor.cmd_events_recordusrctlnoteon();
               r = true; break;

            case VKEY_RSHIFT:
               parent_editor.cmd_events_recordnoteoff();
               r = true; break;

            case VKEY_RCTRL:
               parent_editor.cmd_events_recordpre();
               r = true; break;

            case VKEY_RETURN:
            // // case VKEY_EQUALS: // = on us kbd, ´ on german kbd
               parent_editor.cmd_events_recordquantize();
               r = true; break;

            case VKEY_PAGEUP:
               parent_editor.cmd_pattern_rotate_up();
               r = true; break;

            case VKEY_PAGEDOWN:
               parent_editor.cmd_pattern_rotate_down();
               r = true; break;

            case 96: // '^' (ger) / '`' (us)
               if(parent_editor.isPatternViewActive())
               {
                  parent_editor.togglePianoWidget();
               }
               r = true; break;

            case VKEY_DELETE:
               parent_editor.cmd_edit_swaplshift();
               r = true; break;

            case VKEY_BACKSPACE:
               parent_editor.cmd_replay_toggleignorearr_node();
               r = true; break;

            case VKEY_INSERT:
               parent_editor.cmd_replay_togglefollowarr();
               r = true; break;

            default:
               r = maybe; break;
         }

         if(true == r)
            return true;
         else if(maybe == r)
            Global.Print("");

         // see above
         key = _k.unicode;
      }

      return false;
   }

   // <ui_kbd.png>
   protected method tryHandleDefaultKey(Key _k) : boolean {
      if(_k.modCtrl())
      {
         if(!_k.modAlt()) // workaround since SDL reports ctrl flag for alt-} keypress e.g..
         {
            if(handleCtrlAcceleratorKey(_k))
               return true;
         }
      }
      else if(!_k.modAlt())
      {
         if(handleKeyJazzOrCelEditKey(_k, null/*midiEv*/))
            return true;
      }
      return false;
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {
      // trace "xxx PatternView::onKey: k.name="+_k.name+" k.code="+_k.code+" k.mod="+_k.mod;

      if(_k.modNone())
      {
         switch(_k.pressed)
         {
            case 'a':
               if(parent_node.haveSelection())
               {
                  showBlockContextMenu(true/*bHaveSel*/, true/*bFocusFirst*/);
                  return true;
               }
               break;

            case 'k':
               tryEditSound();
               return true;
         }
      }

      if(!_k.modShiftOrCaps())
      {
         b_minihex_last_auto_msb = false;
         minipat3_last_auto = -1;
      }

      if(_k.pressed)
      {
         b_minihex_lsb_save = b_minihex_lsb;
         b_minihex_lsb = false;
      }

      if(VKEY_LESS/*60*/ == _k.pressed) // \(us), <(de)
      {
         if(_k.modCtrl())
         {
            if(_k.modShift())
            {
               parent_editor.cmd_edit_toggletimingview_movelock();
            }
            else
            {
               parent_editor.cmd_edit_toggletimingview();
            }
            return true;
         }
      }

      if(!isEditable())
      {
         // alternative shortcuts for Ctl.Keyboard copy (usually lctrl-u and lctrl-lshift-u)
         if(_k.modShiftOnly())
         {
            switch(_k.pressed)
            {
               case '1':
                  copyCurrentCtlToClipboard(false/*bClipboardB*/);
                  return true;

               case '2':
                  copyCurrentCtlToClipboard(true/*bClipboardB*/);
                  return true;
            }
         }
      }

      switch(_k.pressed)
      {
         default:
            if(tryHandleDefaultKey(_k))
               return true;

            // trace "xxx PatternView: unhandled key "+_k.name;
            break;

         case 'k':
            if(_k.modShiftOnly())
            {
               tryEditInstrumentAudioSample();
               return true;
            }
            break;

         case VKEY_HOME:
            if(VMOD_LSHIFT == _k.mod)
            {
               next_keyjazz_note_ctl = -1;
               cur_rotate_count = 0;
               moveCursorToStart();
               return true;
            }
            return false;

         case VKEY_END:
            if(VMOD_LSHIFT == _k.mod)
            {
               next_keyjazz_note_ctl = -1;
               cur_rotate_count = 0;
               moveCursorToEnd();
               return true;
            }
            return false;

         case VKEY_RCTRL:
            handleKeyRCtrl(_k.modShift());
            return true;

         case VKEY_ESCAPE:
            return false;

         case VKEY_TAB:
            cur_rotate_count = 0;
            return handleKeyTab(_k);

         case VKEY_BACKSPACE:
            if(VMOD_LSHIFT == _k.mod)
            {
               patternClear();
               return true;
            }
            else if(VMOD_LCTRL == _k.mod)
            {
               deleteCurrentTrackEnvelope();
               return true;
            }
            break;

         case VKEY_RSHIFT:
            cur_rotate_count = 0;
            handleKeyRShift(_k.modCtrl());
            return true;

         case VKEY_SPACE:
            cur_rotate_count = 0;
            next_keyjazz_note_ctl = -1;
            handleKeySpace(_k.modShift(), _k.modCtrl());
            return true;

         case VKEY_RETURN:
            cur_rotate_count = 0;
            return handleKeyReturn(_k.modShift(), _k.modCtrl());

         case VKEY_DELETE:
            cur_rotate_count = 0;
            next_keyjazz_note_ctl = -1;
            return handleKeyDelete(_k.modShift(), _k.modCtrl());

         case VKEY_INSERT:
            cur_rotate_count = 0;
            next_keyjazz_note_ctl = -1;
            return handleKeyInsert(_k.modShift(), _k.modCtrl());

         case VKEY_DOWN:
            cur_rotate_count = 0;
            return handleKeyDown(_k);

         case VKEY_UP:
            cur_rotate_count = 0;
            return handleKeyUp(_k);

         case VKEY_PAGEUP:
            cur_rotate_count = 0;
            return handleKeyPageUp(_k);

         case VKEY_PAGEDOWN:
            cur_rotate_count = 0;
            return handleKeyPageDown(_k);

         case VKEY_RIGHT:
            cur_rotate_count = 0;
            return handleKeyRight(_k);

         case VKEY_LEFT:
            cur_rotate_count = 0;
            return handleKeyLeft(_k);

         case 'f':
         case 'F':
            if(tryHandleDefaultKey(_k))
               return true;
            break;

         case 'g':
         case 'G':
            if(_k.modShift())
            {
               showJumpToStepDialog();
               return true;
            }
            if(tryHandleDefaultKey(_k))
               return true;
            break;

         case VKEY_QUOTE:  // ''' (us/en) / 'Ä' (de)
            parent_editor.cmd_edit_togglezoompreset();
            return true;
      }

      if(_k.modShift() && !_k.modCtrl())
      {
         if(handleKeyModShift(_k))
         {
            return true;
         }
      }

      return Control::onKey(_k);
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      IntAction *iac;
      ActionProvider ap <= _action.getActionProvider();
      String acName = _action.getActionName();

      int recPatOffset;
      Integer recRaster;

      StringAction sac;

      switch(@(ap))
      {
         case @(fp_detailedit):
            FloatAction *acFloat;
            switch(acName)
            {
               case FloatParamEditor.ACTION_VALUECHANGING:
               {
                  acFloat <= _action;

                  recRaster = step_resolution;
                  recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(detailedit_ctlid,
                                                                              detailedit_patpos,
                                                                              recRaster
                                                                              );

                  parent_node.insertReplaceTrackEventAtRes(detailedit_ctlid,
                                                           acFloat.getFloatValue(),
                                                           recPatOffset,
                                                           recRaster
                                                           );
                  replay.b_keyjazz_step = true;
               }
               return true;

               case FloatParamEditor.ACTION_VALUECHANGED:
               {
                  acFloat <= _action;

                  recRaster = step_resolution;
                  recPatOffset = parent_node.fixOffsetToExistingEventAtWindow(detailedit_ctlid,
                                                                              detailedit_patpos,
                                                                              recRaster
                                                                              );

                  parent_node.insertReplaceTrackEventAtRes(detailedit_ctlid,
                                                           acFloat.getFloatValue(),
                                                           recPatOffset,
                                                           recRaster
                                                           );

                  renderAndRedrawAll();
               }
               break;

               case FloatParamEditor.ACTION_VALUEUNCHANGED:
                  Global.Debug("PatternView: fp_detailedit VALUEUNCHANGED");
                  break;
            }

            UI.SetKeyboardFocus(this);

            parent_node.undoEndNested("detail edit cel");

            return true;

         case @(dlg_blockinterpol):
            if(acName == NT_BlockInterpolationDialog.ACTION_NAME)
            {
               blockInterpol(dlg_blockinterpol.getInterpolType());
            }
            return true;

         case @(this):
            switch(acName)
            {
               case TA_REDRAW_OVERLAYS:
               {
                  if(null != parent_node)
                  {
                     if(highlight_row_timeout > 0)
                     {
                        highlight_row_timeout--;
                        ////trace "xxx PatternView::redrawTimer expired. timeout="+highlight_row_timeout+" mousey="+highlight_row_y;
                        ta_redraw_overlays.schedule();
                     }
                     if(neighbour_hl_countdown > 0)
                     {
                        neighbour_hl_countdown--;
                        ta_redraw_overlays.schedule();
                     }
                     compositeAll();

                     if(parent_node.b_ui_piano && (replay.ticks_to_play > 0))
                     {
                        // When playing step via RETURN
                        parent_editor.piano.redraw();
                     }
                  }
               }
               return true;

               case TA_REDRAW:
               {
                  if(highlight_row_timeout > 0)
                  {
                     highlight_row_timeout--;
                     ////trace "xxx PatternView::redrawTimer expired. timeout="+highlight_row_timeout+" mousey="+highlight_row_y;
                     ta_redraw_overlays.schedule();
                  }
                  Control::redraw(); // this.redraw() might just schedule this timer!
               }
               return true;

               case TA_REDRAW_ALL:
               {
                  ////trace "xxx onRedrawAllTimer expired";
                  renderAndRedrawAll();
               }
               return true;

               case TA_AUTOSCROLL:
               {
                  if(-1 == autoscroll_dir)
                     scrollUp();
                  else
                     scrollDown();

                  onMouseDrag(autoscroll_ev, autoscroll_ev); // also schedules next timer event
               }
               return true;

               case TA_AUTOSCROLL_TRACKS:
                  if(-1 == autoscroll_tracks_dir)
                     moveCursorToPreviousTrackXClip(false/*bAlignRight*/);
                  else
                     moveCursorToNextTrackXClip();

                  ta_autoscroll_tracks.schedule();
                  return true;

               case TA_RECORDMIDIEND:
                  handleTARecordMIDIEndExpired();
                  return true;

               case TA_MINIHEX:
                  b_minihex_lsb = false;
                  Global.Warning("minihex: timeout");
                  return true;

               case TA_PIANO_WIDGET:
                  if(parent_node.b_ui_piano)
                  {
                     if(parent_node.uiGetLastNoteStateAndReset(parent_editor.piano.last_notes))
                        parent_editor.piano.redraw();

                     ta_piano_widget.reschedule();
                  }
                  return true;

            }
            return false;

         case @(pm_block):
            if(!PopupMenu.IsFocusAction(_action))
               parent_editor.refocusDefault();
            switch(acName)
            {
               case "block_copy":
                  blockCopy();
                  return true;

               case "block_pastereplace":
                  blockPaste(false, true/*bUndoStartEnd*/, true/*bScrollDown*/);
                  return true;

               case "block_pasteinsert":
                  blockPaste(true, true/*bUndoStartEnd*/, true/*bScrollDown*/);
                  return true;

               case "block_quantize_last":
                  blockQuantizeLastMethod();
                  return true;

               case "block_quantize_100":
                  blockQuantizeMethod(1);
                  return true;

               case "block_quantize_50":
                  blockQuantizeMethod(2);
                  return true;

               case "block_quantize_25":
                  blockQuantizeMethod(3);
                  return true;

               case "block_quantize_dialog":
                  blockQuantizeMethod(0);
                  return true;

               case "block_interpolate":
                  parent_editor.cmd_block_interpol();
                  return true;

               case "block_sortnotes":
                  blockSortNotes();
                  return true;

               case "block_selectnone":
                  selectNone();
                  return true;

               case "block_transposeup":
                  blockTranspose(1);
                  return true;

               case "block_transposedown":
                  blockTranspose(-1);
                  return true;
            }
            return true;

         case @(trackmenu):
            parent_editor.refocusDefault();
            switch(acName)
            {
               case "track_togglemute":
                  parent_editor.cmd_track_togglemute();
                  return true;

               case "track_togglesolo":
                  parent_editor.cmd_track_togglesolo();
                  return true;

               case "track_rename":
                  parent_editor.cmd_track_rename();
                  return true;

               case "track_delete":
                  parent_editor.cmd_track_delete_dlg();
                  return true;

               case "track_editlayout":
                  parent_editor.cmd_track_editlayout();
                  return true;

               case "track_addnotecel":
                  parent_editor.cmd_track_addnotecel();
                  return true;

               case "track_selectcel":
                  parent_editor.cmd_cursor_jumptocolumn();
                  return true;
            }
            return true;

         case @(dlg_trackname):
            sac <= _action;

            if(StringDialog.ACTION_CANCEL != acName)
            {
               dlg_trackname_track.name = sac.getStringValue();
               Global.Print("Track renamed to \""+dlg_trackname_track.name+"\".");
            }

            switch(acName)
            {
               case StringDialog.ACTION_PREVIOUS:
                  editTrackName(dlg_trackname_track.track_nr - 1);
                  return true;

               case StringDialog.ACTION_NEXT:
                  editTrackName(dlg_trackname_track.track_nr + 1);
                  return true;

               case StringDialog.ACTION_RETURN:
                  parent_editor.refocusDefault();
                  return true;

               case StringDialog.ACTION_CANCEL:
                  parent_editor.refocusDefault();
                  return true;
            }
            return true;

         case @(dlg_stepalignment):
            sac <= _action;

            if(TextInputDialog.ACTION_TEXTINPUTDIALOGCLOSED == acName)
               stepAlignmentDialog2(int(sac.getStringValue()));

            return true;

         case @(cmp_audiosampleselector):
            if(ComboBoxPopup.ACTION_OPTIONSELECTED == acName)
              // // case ComboBoxPopup.ACTION_CANCEL_OPTION_SELECTION:
            {
               iac <= _action;
               handleAudioSampleSelection(iac.getIntValue());
            }
            UI.SetKeyboardFocus(this);
            return true;

         default:
            // trace "[~~~] PatternView: unhandled Action provider="+#(ap)+" name="+acName;
            return false;
      }

      return false;
   }

   // <ui_xfm.png>
   public method beginXFMTag(AbstractXMLForm _form, HashTable _attributes) : boolean {
      if(Layer::beginXFMTag(_form, _attributes))
      {
         String atname, atval;
         StringArray atsplit;
         foreach atname in _attributes
         {
            atval <= _attributes[atname];
            switch(atname)
            {
            }
         }
      }
      return true;
   }

}
