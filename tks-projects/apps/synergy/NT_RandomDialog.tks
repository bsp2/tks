// ----
// ---- file   : NT_RandomDialog.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2017-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" sequencer.
// ----
// ---- created: 30Jan2017
// ---- changed: 07Oct2019, 16Apr2022, 17Apr2022, 18Apr2022, 19Apr2022, 22Apr2022, 23Apr2022
// ----          04Oct2023, 14Oct2023, 30Oct2023, 22Mar2024, 02Oct2024, 28Feb2025
// ----
// ----
// ----

module MNT_RandomDialog;

use namespace ui;
use namespace st2;


// <class.png>
class NT_RandomParamsLane {
   define int RAND_NUM_PRE = 8;

   define int MODE_EUCLIDEAN = 0;
   define int MODE_PRESET    = 1;

   define int PREPOST_MODE_NONE   = 0;
   define int PREPOST_MODE_INCDEC = 1;
   define int PREPOST_MODE_DECINC = 2;

   byte    scaling;    // 1..8
   byte    mode;

   short   num_trigs;  // 1..64
   short   num_steps;  // 0=use track length, 1..64
   byte    pre_mode;   // see MODE_xxx
   boolean b_reverse;
   byte    post_mode;  // see MODE_xxx
   short   rotation;   // -64..64
   boolean b_invert;

   define int PRESET_COMBINE_OFF            = 0;
   define int PRESET_COMBINE_FLIP_CONT      = 1;
   define int PRESET_COMBINE_FLIP_HOLD      = 2;
   define int PRESET_COMBINE_FLIP_NOTE_CONT = 3;
   define int PRESET_COMBINE_FLIP_NOTE_HOLD = 4;
   short preset_pat1;
   short preset_pat2;
   byte  preset_combine;
   short preset_len1;
   short preset_len2;
   short preset_rot1;
   short preset_rot2;
   IntArray preset_pat1_steps;
   IntArray preset_pat2_steps;

   float prob_seed;
   float prob_off;
   float prob;   // Even steps probability
   float prob2;  // Odd steps probability (was Subsequent probability (if previous step was written))
   float prob3;  // Subsequent probability multiplier (if previous step was written) probability

   float vel_seed;
   float vel_min;
   float vel_max;
   float vel_odd;  // odd-step velocity scaling

   float acc_seed;
   float acc_prob_off;
   float acc_prob;   // Even steps accent probability
   float acc_prob2;  // Odd steps accent probability
   float acc_prob3;  // Subsequent accent probability multiplier

   float dur_seed;
   int   dur_min;
   int   dur_max;

   float slide_seed;
   float slide_prob_off;
   float slide_prob;   // Even steps slide probability
   float slide_prob2;  // Odd steps slide probability
   float slide_prob3;  // Subsequent slide probability multiplier

   float   oct_seed;
   int     oct_min;
   int     oct_max;
   float   oct_prob;
   boolean b_oct_nr;

   float notes_seed;
   IntArray notes;
   byte notes_mode;  // 0=lin, 1=rnd, 2=rnd_nr
   byte  notes_min;
   byte  notes_max;
   boolean b_notes_advance;

   int post_rotation;
   float swing;

   define int ECHO_OFF   = 0;
   define int ECHO_EMPTY = 1;
   define int ECHO_MICRO = 2;
   int   echo_mode;  // 0=off, 1=empty step, 2=micro-delay
   int   echo_delay;
   int   echo_max;
   float echo_vel_decay;
   int   echo_note_decay;

   int num_pre;  // rand seed pre-warm count. initial versions used 0, v10+ uses 8.


   // <method_init.png>
   public method init() {

      scaling   = 1;

      num_trigs = 4;
      num_steps = 0;
      pre_mode  = PREPOST_MODE_NONE;
      post_mode = PREPOST_MODE_NONE;
      b_reverse = false;
      b_invert  = false;

      preset_pat1 = 0;
      preset_pat2 = 0;
      preset_combine = PRESET_COMBINE_OFF;
      preset_len1 = 1;
      preset_len2 = 1;
      preset_rot1 = 0;
      preset_rot2 = 0;
      preset_pat1_steps = [1];
      preset_pat2_steps = [1];

      rotation  = 0;

      prob_seed = 0.5;
      prob_off  = 0.0;
      prob      = 1.0;
      prob2     = 1.0;
      prob3     = 1.0;

      vel_seed = 0.5;
      vel_min  = 0.25;
      vel_max  = 0.75;
      vel_odd  = 1.0;

      acc_seed     = 0.5;
      acc_prob_off = 0.0;
      acc_prob     = 0.0;
      acc_prob2    = 0.0;
      acc_prob3    = 1.0;

      dur_seed = 0.5;
      dur_min  = 6;
      dur_max  = 6;

      slide_seed     = 0.5;
      slide_prob_off = 0.0;
      slide_prob     = 0.0;
      slide_prob2    = 0.0;
      slide_prob3    = 1.0;

      oct_seed = 0.5;
      oct_min  = 0;
      oct_max  = 0;
      oct_prob = 1;
      b_oct_nr = false;

      notes_seed = 0.5;
      notes = [ (5*12)+0,
                ];
      notes_mode = 2;
      notes_min  = 0;
      notes_max  = 127;
      b_notes_advance = false;

      post_rotation = 0;
      swing = 0;

      echo_mode       = ECHO_OFF;
      echo_delay      = 3;
      echo_max        = 3;
      echo_vel_decay  = 0.5;
      echo_note_decay = 0;
   }

   // <method_get.png>
   public method getNotesString() : String {
      StringArray midiNotes <= MIDI.midi_notes;
      local String r;
      int note;
      int i = 0;
      foreach note in notes
      {
         if(i++ > 0)
            r.append(" ");
         r.append(midiNotes.get(note));
      }
      return deref r;
   }

   // <method.png>
   public method parseNotesString(String _s) {
      _s.trim();
      local StringArray a <= _s.splitSpace(true);
      notes.empty();
      String *s;
      foreach s in a
      {
         s.toUpper();
         int idx = MIDI.base_note_names.indexOfObject(s, 0);
         if(-1 != idx)
         {
            // C, C#, D, ..
            notes.add(12*5 + idx);
         }
         else
         {
            idx = MIDI.midi_notes.indexOfObject(s, 0);
            if(-1 != idx)
            {
               // C-4, D#5, E-6, ..
               notes.add(idx);
            }
         }
      }

      if(notes.isEmpty())
         notes.add(12*5);
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 14;

      // Scaling (v3+)
      _ofs.i8 = scaling;

      // Mode (v11+)
      _ofs.i8 = mode;

      // Euclidean: Num trigs
      _ofs.i16 = num_trigs;

      // Euclidean: Num steps
      _ofs.i16 = num_steps;

      // Euclidean: Pre inc/dec mode
      _ofs.i8 = pre_mode;

      // Euclidean: Post inc/dec mode
      _ofs.i8 = post_mode;

      // Euclidean: Reverse
      _ofs.i8 = b_reverse;

      // Rotation
      _ofs.i16 = rotation;

      // Euclidean: Invert
      _ofs.i8 = b_invert;

      // // Always undo (removed in v14+)
      // _ofs.i8 = b_always_undo;

      // Preset: pat1 (v11+)
      _ofs.i16 = preset_pat1;

      // Preset: pat2 (v11+)
      _ofs.i16 = preset_pat2;

      // Preset: combine (v11+)
      _ofs.i8 = preset_combine;

      // Preset: len1 (v11+)
      _ofs.i16 = preset_len1;

      // Preset: len2 (v11+)
      _ofs.i16 = preset_len2;

      // Preset: rot1 (v12+)
      _ofs.i16 = preset_rot1;

      // Preset: rot2 (v12+)
      _ofs.i16 = preset_rot2;

      // Preset: pat1 steps (v11+)
      Utils.WriteByteArray(_ofs, preset_pat1_steps);

      // Preset: pat2 steps (v11+)
      Utils.WriteByteArray(_ofs, preset_pat2_steps);

      // Probability Seed
      _ofs.f32 = prob_seed;

      // Probability Offset
      _ofs.f32 = prob_off;

      // Probability
      _ofs.f32 = prob;

      // Probability 2
      _ofs.f32 = prob2;

      // Probability 3 (v2+)
      _ofs.f32 = prob3;

      // Velocity Seed
      _ofs.f32 = vel_seed;

      // Velocity Min
      _ofs.f32 = vel_min;

      // Velocity Max
      _ofs.f32 = vel_max;

      // Velocity Odd
      _ofs.f32 = vel_odd;

      // Accent Seed (v5+)
      _ofs.f32 = acc_seed;

      // Accent Probability Offset (v5+)
      _ofs.f32 = acc_prob_off;

      // Accent Probability (v5+)
      _ofs.f32 = acc_prob;

      // Accent Probability 2 (v5+)
      _ofs.f32 = acc_prob2;

      // Accent Probability 3 (v5+)
      _ofs.f32 = acc_prob3;

      // Duration Seed
      _ofs.f32 = dur_seed;

      // Duration Min
      _ofs.i16 = dur_min;

      // Duration Max
      _ofs.i16 = dur_max;

      // Slide Seed (v5+)
      _ofs.f32 = slide_seed;

      // Slide Probability Offset (v5+)
      _ofs.f32 = slide_prob_off;

      // Slide Probability (v5+)
      _ofs.f32 = slide_prob;

      // Slide Probability 2 (v5+)
      _ofs.f32 = slide_prob2;

      // Slide Probability 3 (v5+)
      _ofs.f32 = slide_prob3;

      // Octave Seed
      _ofs.f32 = oct_seed;

      // Octave Min
      _ofs.i8 = oct_min;

      // Octave Max
      _ofs.i8 = oct_max;

      // Octave Non-Repeating
      _ofs.i8 = b_oct_nr;

      // Octave probability (v7+)
      _ofs.f32 = oct_prob;

      // Notes Seed
      _ofs.f32 = notes_seed;

      // Notes Min (v8+)
      _ofs.i8 = notes_min;

      // Notes Max (v8+)
      _ofs.i8 = notes_max;

      // Notes Advance (v13+)
      _ofs.i8 = b_notes_advance;

      // Notes
      Utils.WriteByteArray(_ofs, notes);

      // Notes Mode
      _ofs.i8 = notes_mode;

      // Post Rotation (v4+)
      _ofs.i16 = post_rotation;

      // Swing (v4+)
      _ofs.f32 = swing;

      // Echo (v6+)
      _ofs.i8  = echo_mode;
      _ofs.i8  = echo_delay;
      _ofs.i8  = echo_max;
      _ofs.f32 = echo_vel_decay;
      _ofs.i8  = echo_note_decay;
   }

   // <load.png>
   public method loadState(Stream _ifs) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         if(ver >= 3)
         {
            // Scaling (v3+)
            scaling = _ifs.u8;
         }

         if(ver >= 11)
         {
            mode = _ifs.u8;
         }

         // Euclidean: Num trigs
         num_trigs = _ifs.u16;

         // Euclidean: Num steps
         num_steps = _ifs.u16;

         // Euclidean: Pre inc/dec mode
         pre_mode = _ifs.u8;

         // Euclidean: Post inc/dec mode
         post_mode = _ifs.u8;

         // Euclidean: Reverse
         b_reverse = _ifs.b8;

         // Rotation
         rotation = _ifs.s16;

         // Euclidean: Invert
         b_invert = _ifs.b8;

         if(ver < 14)
         {
            // Always undo (pre v14)
            boolean bAlwaysUndoDUMMY = _ifs.b8;
         }

         if(ver >= 11)
         {
            // Preset: pat1 (v11+)
            preset_pat1 = _ifs.u16;

            // Preset: pat2 (v11+)
            preset_pat2 = _ifs.u16;

            // Preset: combine (v11+)
            preset_combine = _ifs.u8;

            // Preset: len1 (v11+)
            preset_len1 = _ifs.u16;

            // Preset: len2 (v11+)
            preset_len2 = _ifs.u16;

            if(ver >= 12)
            {
               // Preset: rot1 (v12+)
               preset_rot1 = _ifs.s16;

               // Preset: rot2 (v12+)
               preset_rot2 = _ifs.s16;
            }

            // Preset: pat1 steps (v11+)
            Utils.ReadByteArray(_ifs, preset_pat1_steps);

            // Preset: pat2 steps (v11+)
            Utils.ReadByteArray(_ifs, preset_pat2_steps);
         }

         // Probability Seed
         prob_seed = _ifs.f32;

         // Probability Offset
         prob_off = _ifs.f32;

         // Probability
         prob = _ifs.f32;

         // Probability 2
         prob2 = _ifs.f32;

         if(ver >= 2)
         {
            // Probability 3 (v2+)
            prob3 = _ifs.f32;
         }

         // Velocity Seed
         vel_seed = _ifs.f32;

         // Velocity Min
         vel_min = _ifs.f32;

         // Velocity Max
         vel_max = _ifs.f32;

         // Velocity Odd
         vel_odd = _ifs.f32;

         if(ver >= 5)
         {
            // Accent Seed (v5+)
            acc_seed = _ifs.f32;

            // Accent Probability Offset (v5+)
            acc_prob_off = _ifs.f32;

            // Accent Probability (v5+)
            acc_prob = _ifs.f32;

            // Accent Probability 2 (v5+)
            acc_prob2 = _ifs.f32;

            // Accent Probability 3 (v5+)
            acc_prob3 = _ifs.f32;
         }

         // Duration Seed
         dur_seed = _ifs.f32;

         // Duration Min
         dur_min = _ifs.u16;

         // Duration Max
         dur_max = _ifs.u16;

         if(ver >= 9)
         {
            // Slide Seed (v5+)
            slide_seed = _ifs.f32;

            // Slide Probability Offset (v5+)
            slide_prob_off = _ifs.f32;

            // Slide Probability (v5+)
            slide_prob = _ifs.f32;

            // Slide Probability 2 (v5+)
            slide_prob2 = _ifs.f32;

            // Slide Probability 3 (v5+)
            slide_prob3 = _ifs.f32;
         }

         // Octave Seed
         oct_seed = _ifs.f32;

         // Octave Min
         oct_min = _ifs.s8;

         // Octave Max
         oct_max = _ifs.s8;

         // Octave Non-Repeating
         b_oct_nr = _ifs.b8;

         if(ver >= 7)
         {
            // Octave probability (v7+)
            oct_prob = _ifs.f32;
         }

         // Notes Seed
         notes_seed = _ifs.f32;

         if(ver >= 8)
         {
            // Notes Min (v8+)
            notes_min = _ifs.u8;

            // Notes Max (v8+)
            notes_max = _ifs.u8;
         }

         if(ver >= 13)
         {
            // Notes Advance (v13+)
            b_notes_advance = _ifs.b8;
         }

         // Notes
         Utils.ReadByteArray(_ifs, notes);

         // Notes Mode
         notes_mode = _ifs.u8;

         if(ver >= 4)
         {
            // Post Rotation (v4+)
            post_rotation = _ifs.s16;
         }

         if(ver >= 4)
         {
            // Swing (v4+)
            swing = _ifs.f32;
         }

         if(ver >= 6)
         {
            // Echo (v6+)
            echo_mode       = _ifs.u8;
            echo_delay      = _ifs.u8;
            echo_max        = _ifs.u8;
            echo_vel_decay  = _ifs.f32;
            echo_note_decay = _ifs.s8;
         }

         return true;
      }
      else
      {
         trace "[---] NT_RandomParamsLane::loadState: invalid ver="+ver;
      }

      return false;
   }

   // <method.png>
   public method copyFrom(NT_RandomParamsLane _o) {
      local DummyStream ds;
      ds.offset = 0;
      ds.size = 0;
      _o.saveState(ds);

      local Buffer cb;
      cb.size = ds.offset;
      cb.offset = 0;
      _o.saveState(cb);

      cb.offset = 0;
      loadState(cb);
   }
}


// <class.png>
class NT_RandomParams {
   int lane_idx;  // 0..4 => NOTE1..NOTE5
   NT_RandomParam *[] lanes;

   public method init() {
      lanes.free();
      loop(5)
      {
         NT_RandomParamsLane lane <= new NT_RandomParamsLane;
         lane.init();
         lanes.add(#(deref lane));
      }
   }

   // <method_get.png>
   public method getLane(int _laneIdx) : NT_RandomParamsLane {
      return lanes.get(_laneIdx);
   }

   // <save.png>
   public method saveState(Stream _ofs) {

      // Version
      _ofs.i16 = 1;

      // Lane
      _ofs.i8 = lane_idx;

      // Lanes
      NT_RandomParamsLane *lane;
      foreach lane in lanes
      {
         lane.saveState(_ofs);
      }
   }

   // <load.png>
   public method loadState(Stream _ifs) : boolean {

      short ver = _ifs.u16;

      if(ver >= 1)
      {
         // Lane
         lane_idx = _ifs.u8;

         // Lanes
         NT_RandomParamsLane *lane;
         int laneNr = 1;
         foreach lane in lanes
         {
            if(!lane.loadState(_ifs))
            {
               trace "[---] NT_RandomParams::loadState: failed to load lane "+laneNr+"/5";
               return false;
            }
            laneNr++;
         }

         return true;
      }
      else
      {
         trace "[---] NT_RandomParams::loadState: invalid ver="+ver;
      }

      return false;
   }

   // <method.png>
   public method copyFrom(NT_RandomParams _o) {
      local DummyStream ds;
      ds.offset = 0;
      ds.size = 0;
      _o.saveState(ds);

      local Buffer cb;
      cb.size = ds.offset;
      cb.offset = 0;
      _o.saveState(cb);

      cb.offset = 0;
      loadState(cb);
      // trace "xxx NT_RandomParams: end copyFrom: ds.offset="+ds.offset+" cb.offset="+cb.offset;
   }
}


// <class.png>
class NT_RandomStep {
   int     note;  // -1 = not set
   float   vel;
   int     dur;
   boolean b_slide;

   NT_RandomStep *[] delayed_steps;

   public method addDelayedStep(int _note, float _vel, int _dur) {
      NT_RandomStep st <= new NT_RandomStep;
      st.note = _note;
      st.vel  = _vel;
      st.dur  = _dur;
      delayed_steps.add(#(deref st));
   }
}


// <class.png>
class NT_RandomDelay {
   int   delay;
   int   delay_countdown;
   int   echo_idx;
   int   note;
   float vel;
   int   dur;
   float vel_decay;
   int   note_decay;
   int   max_echoes;
   boolean b_emit;

   public method step() {
      b_emit = false;

      if(note >= 0)
      {
         if(0 == --delay_countdown)
         {
            if(++echo_idx > max_echoes)
            {
               // Terminate delay line
               note = -1;
            }
            else
            {
               int dlyNote = note + note_decay;
               if(0 <= dlyNote <= 127)
               {
                  vel = vel * vel_decay;
                  if(int(vel) >= 1)
                  {
                     vel = mathClampf(vel, 1, 127);
                     note = dlyNote;
                     delay_countdown = delay;
                     b_emit = true;
                  }
                  else
                  {
                     // Velocity too low, terminate delay line
                     note = -1;
                  }
               }
               else
               {
                  // Note out of range, terminate delay line
                  note = -1;
               }
            }
         }
      }
   }
}

// <class.png>
class NT_RandomDelayProc {
   NT_RandomDelay *[] delays;

   protected method allocDelay() : NT_RandomDelay {
      NT_RandomDelay *dly;
      foreach dly in delays
      {
         if(dly.note < 0)
            return dly;
      }
      dly <= new NT_RandomDelay;
      delays.add(#(deref dly));
      return dly;
   }

   public method noteOn(int _note, float _vel, int _dur, int _delay, float _velDecay, int _noteDecay, int _maxEchoes) {
      NT_RandomDelay dly <= allocDelay();
      dly.delay           = _delay;
      dly.delay_countdown = _delay;
      dly.echo_idx        = 0;
      dly.note            = _note;
      dly.vel             = mathClampf(_vel, 1, 127);
      dly.dur             = _dur;
      dly.vel_decay       = _velDecay;
      dly.note_decay      = _noteDecay;
      dly.max_echoes      = _maxEchoes;
   }

   public method step() {
      NT_RandomDelay *dly;
      foreach dly in delays
      {
         dly.step();
      }
   }

}


// <class.png>
class NT_RandomizerPattern {
   String name;
   IntArray steps;
}

// <class.png>
class NT_RandomDialog extends Dialog {

   define String TA_GENERATE;
   protected TimerAction *ta_generate;

   protected NodeTrackerEditor *editor;
   protected NT_PatternView *pattern_view;
   protected NodeTracker *parent_node;
   NT_MetaPattern *mpat;
   NT_Track *track;
   int pat_nr;
   NT_TrackPattern *track_pat;

   protected NT_RandomParams *params;
   protected NT_RandomParamsLane *lane;

   protected XMLForm *xfm;

   protected Button *bt_close;

   protected ComboBox *cm_lane;
   protected Button   *bt_copy;
   protected Button   *bt_paste;
   protected ComboBox *cm_scaling;

   protected ComboBox    *cm_mode;
   protected LayerSwitch *ls_mode;

   // Euclidean:
   protected FloatParam *fp_num_trigs;
   protected FloatParam *fp_num_steps;
   protected ComboBox   *cm_pre_mode;
   protected ComboBox   *cm_post_mode;
   protected CheckBox   *cb_reverse;
   protected CheckBox   *cb_invert;

   // Preset:
   protected ComboBox   *cm_preset_pat1;
   protected ComboBox   *cm_preset_pat2;
   protected Button     *bt_preset_add;
   protected ComboBox   *cm_preset_combine;
   protected FloatParam *fp_preset_len1;
   protected FloatParam *fp_preset_len2;
   protected FloatParam *fp_preset_rot1;
   protected FloatParam *fp_preset_rot2;


   protected FloatParam *fp_rotation;

   protected FloatParam *fp_prob_seed;
   protected Button     *bt_prob_seed_rand;
   protected FloatParam *fp_prob_off;
   protected FloatParam *fp_prob;
   protected FloatParam *fp_prob2;
   protected FloatParam *fp_prob3;

   protected FloatParam *fp_vel_seed;
   protected Button     *bt_vel_seed_rand;
   protected FloatParam *fp_vel_min;
   protected FloatParam *fp_vel_max;
   protected FloatParam *fp_vel_odd;

   protected FloatParam *fp_acc_seed;
   protected Button     *bt_acc_seed_rand;
   protected FloatParam *fp_acc_prob_off;
   protected FloatParam *fp_acc_prob;
   protected FloatParam *fp_acc_prob2;
   protected FloatParam *fp_acc_prob3;

   protected FloatParam *fp_dur_seed;
   protected Button     *bt_dur_seed_rand;
   protected FloatParam *fp_dur_min;
   protected FloatParam *fp_dur_max;

   protected FloatParam *fp_oct_seed;
   protected Button     *bt_oct_seed_rand;
   protected FloatParam *fp_oct_min;
   protected FloatParam *fp_oct_max;
   protected FloatParam *fp_oct_prob;
   protected CheckBox   *cb_oct_nr;

   protected FloatParam *fp_slide_seed;
   protected Button     *bt_slide_seed_rand;
   protected FloatParam *fp_slide_prob_off;
   protected FloatParam *fp_slide_prob;
   protected FloatParam *fp_slide_prob2;
   protected FloatParam *fp_slide_prob3;

   protected FloatParam *fp_notes_seed;
   protected Button     *bt_notes_seed_rand;
   protected TextField  *tf_notes;
   protected ComboBox   *cm_notes_mode;
   protected Button     *bt_notes_learn;
   protected ComboBox   *cm_notes_min;
   protected ComboBox   *cm_notes_max;
   protected CheckBox   *cb_notes_advance;

   protected FloatParam *fp_post_rotation;
   protected FloatParam *fp_swing;

   protected ComboBox   *cm_echo_mode;
   protected FloatParam *fp_echo_delay;
   protected FloatParam *fp_echo_max;
   protected FloatParam *fp_echo_vel_decay;
   protected FloatParam *fp_echo_note_decay;

   protected Button   *bt_clear;
   protected Button   *bt_undo;
   protected Button   *bt_rand;

   boolean b_have_undo;

   define int LEARN_NONE   = 0;
   define int LEARN_NOTES  = 6;
   int learn_mode;

   define String TA_MIDI_LEARN;
   protected TimerAction *ta_midi_learn;

   static StringArray learn_mode_names = ["None",
                                          "Notes",
                                          ];
   protected boolean b_learning; // true while scanning MIDI input for bank select/program change
   define int LEARN_TIMEOUT = 49;  // number of ta_midi_learn timeouts (=> 50*200 = 10 sec)
   define int TINT32_LEARN = #58ef6467;
   protected int learn_timeout;
   protected int num_notes_learnt;

   static NT_RandomParamsLane *lane_clipboard;

   static NT_RandomizerPattern *[] preset_patterns;

   protected TextInputDialog *dlg_new_name;


   // <ui_init.png>
   public method init() : boolean {

      initDialog();

      xfm <= XMLForm.New_PakFile("NT_RandomDialog.xfm");
      if(null == xfm)
      {
         return false;
      }

      xfm.autoResolveIds(this);

      initWindow(xfm,
                 "Note Randomizer",
                 100, 100,
                 640, 240
                 );

      resizeToMinimum();

      initTimers();

      return true;
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_generate   <= TimerAction.New(TA_GENERATE,   this, 1000.0/10);
      ta_midi_learn <= TimerAction.New(TA_MIDI_LEARN, this, 200);
   }

   public virtual isPopup() : boolean {
      return true;
   }

   public virtual isModal():boolean {
      return true;
   }

   public virtual isResizable() : boolean {
      return false;
   }

   // <ui_show.png>
   public method run(NodeTrackerEditor _editor, NT_PatternView _patternView, NodeTracker _parentNode) {
      editor <= _editor;
      pattern_view <= _patternView;
      parent_node <= _parentNode;

      mpat <= parent_node.getCurrentEditMetaPattern();

      if(!mpat.patIsEmpty())
      {
         track <= pattern_view.getCurrentTrack();
         if(null != track)
         {
            pat_nr = mpat.pat_nr;
            track_pat <= track.getPattern(mpat.pat_nr);
            if(null != track_pat)
            {
               params <= track_pat.getOrCreateRandomParams();
               lane <= params.getLane(params.lane_idx);

               cm_lane.setSelectedOption(params.lane_idx);

               scanPresetPatterns();

               showLane();

               b_have_undo = false;
               bt_undo.setEditable(false);

               showCentered();
            }
            else
            {
               Global.Warning("No track pattern (?!!)");
            }
         }
         else
         {
            Global.Warning("No current track");
         }
      }
      else
      {
         Global.Warning("Pattern not allocated");
      }
   }

   // <method.png>
   protected method scanPresetPatterns() {
      local String pathName <= Utils.ToNativePathName(STConfig.randomizer_pattern_pathname);
      local String buf;
      if(buf.loadLocal(pathName, true/*bRemoveCR*/))
      {
         local StringArray lines <= buf.splitChar('\n');
         String *line;
         int lineNr = 1;
         boolean bAdd = false;
         local String name;
         local StringArray optNames;
         local StringArray optNamesLong;
         preset_patterns.free();
         int patIdx = 0;
         foreach line in lines
         {
            if(!line.isBlank() && !(line <= "#"))
            {
               if(line <= "[")
               {
                  int idxEnd = line.indexOf("]", 1);
                  if(-1 != idxEnd)
                  {
                     name = line.substring(1, idxEnd - 1);
                     name.trim();
                     bAdd = !name.isBlank();
                  }
                  else
                  {
                     trace "[~~~] NT_RandomDialog::scanPresetPatterns: malformed line "+lineNr+" (missing \']\')";
                  }
               }
               else if(bAdd)
               {
                  NT_RandomizerPattern pat <= new NT_RandomizerPattern;
                  preset_patterns.add(#(deref pat));
                  pat.name = name;
                  IntArray steps <= pat.steps;
                  line.trim();
                  // trace "xxx add pattern \""+line+"\"";
                  int charIdx = 0;
                  int numTrigs = 0;
                  loop(line.numChars)
                  {
                     byte c = line.getc(charIdx++);
                     boolean bTrig = ('x' == c);
                     if(bTrig)
                        numTrigs++;
                     steps.add(bTrig);
                  }
                  optNames.add(patIdx+": "+name.abbrev(20));
                  optNamesLong.add(patIdx+": "+name.abbrev(50)+" (len="+steps.numElements+" #trigs="+numTrigs+")");
                  patIdx++;
               }
            }
            lineNr++;
         }

         cm_preset_pat1.setOptions(optNames);
         cm_preset_pat1.setOptionsLong(optNamesLong);

         cm_preset_pat2.setOptions(optNames);
         cm_preset_pat2.setOptionsLong(optNamesLong);
      }
      else
      {
         Global.Error("Failed to load \""+pathName+"\"");
      }
   }

   // <method.png>
   protected method savePresetPatterns() {
      local String pathName <= Utils.ToNativePathName(STConfig.randomizer_pattern_pathname);
      local String buf;
      buf.append("# this file is read each time the Randomizer dialog is opened\n");
      int numPat;
      if(preset_patterns.numElements > 0)
      {
         NT_RandomizerPattern *pat;
         foreach pat in preset_patterns
         {
            buf.append("\n");
            buf.append("["+pat.name+"]\n");
            IntArray steps <= pat.steps;
            int stepIdx = 0;
            loop(steps.numElements)
            {
               buf.append( (0 != steps[stepIdx++]) ? "x" : "-" );
            }
            buf.append("\n");
         }
         numPat = preset_patterns.numElements;
      }
      else
      {
         buf.append("\n[All]\nx\n");
         numPat = 1;
      }

      if(pathName >= ".ini")  // paranoia
      {
         if(buf.saveLocal(pathName))
         {
            Global.Debug("NT_RandomDialog::savePresetPatterns: wrote \""+pathName+"\"");
            Global.Print(numPat+" preset pattern"+Utils.GetPluralString(numPat)+" saved to \""+pathName+"\"");
         }
         else
         {
            Global.Error("Failed to write preset patterns to \""+pathName+"\"");
         }
      }
   }

   // <ui_handle.png>
   protected method handlePresetAdd1() {
      local String newName;
      NT_RandomizerPattern pat <= preset_patterns.get(lane.preset_pat2);
      if(null != pat)
         newName = pat.name;
      else
         newName = "new";

      dlg_new_name <= TextInputDialog.NewHold("Enter preset name",
                                              " Enter new preset name",
                                              "Add", "Cancel",
                                              newName, 32, 16, this
                                              );

      dlg_new_name.setButtonFontByName("big3");
      dlg_new_name.setMessageFontByName("big5");
      dlg_new_name.setTextFontByName("big4");
      dlg_new_name.setButtonIcons(UI.GetIcon("add"), UI.GetIcon("cancel"));
      dlg_new_name.invalidateSizeCaches();
      dlg_new_name.resizeToMinimum();
      dlg_new_name.showCentered();
   }

   // <method.png>
   protected method addPresetPatternFromNoteCel(String _name) {

      int noteCtl = NT_TrackPattern.CTL_NOTE1;
      int stepRes = parent_node.pv_step_resolution;
      int mpatNumSteps = mpat.num_ticks;

      NT_RandomizerPattern *pat;
      boolean bNew = true;
      int patIdx = 0;
      foreach pat in preset_patterns
      {
         if(pat.name == _name)
         {
            // Replace existing pattern
            bNew = false;
            break;
         }
         patIdx++;
      }

      if(bNew)
      {
         pat <= new NT_RandomizerPattern;
         pat.name = _name;
      }

      IntArray steps <= pat.steps;

      int offset = 0;
      int numTrigs = 0;
      while(offset < mpat.num_ticks)
      {
         var noteVal = parent_node.getTrackEventAt(noteCtl, offset);
         if(typeid(noteVal) == YAC_TYPE_FLOAT)
         {
            steps.add(1);
            numTrigs++;
         }
         else
         {
            steps.add(0);
         }

         // Next step
         offset += stepRes;
      }

      if(numTrigs > 0)
      {
         StringArray optNames = cm_preset_pat1.getOptions();
         StringArray optNamesLong = cm_preset_pat1.getOptionsLong();
         optNames[patIdx]     = patIdx+": "+_name.abbrev(20);
         optNamesLong[patIdx] = patIdx+": "+_name.abbrev(50)+" (len="+steps.numElements+" #trigs="+numTrigs+")";
         cm_preset_pat1.setOptions(optNames);
         cm_preset_pat1.setOptionsLong(optNamesLong);
         cm_preset_pat2.setOptions(optNames);
         cm_preset_pat2.setOptionsLong(optNamesLong);
         cm_preset_pat1.setSelectedOption(patIdx);
         cm_preset_pat2.setSelectedOption(patIdx);
         lane.preset_pat1 = patIdx;
         lane.preset_pat2 = patIdx;
         lane.preset_pat1_steps = steps;
         lane.preset_pat2_steps = steps;
         lane.preset_len1 = steps.numElements;
         lane.preset_len2 = steps.numElements;
         updatePresetPatLenAndRot();

         preset_patterns.add(#(deref pat));

         savePresetPatterns();

         if(0 == lane.mode)
         {
            cm_mode.setSelectedOption(1);
            handleModeChanged();
         }

         Global.Print( (bNew ? "Add" : "Replace")+" preset pattern \""+_name+"\" len="+steps.numElements+" #trigs="+numTrigs);
      }
      else
      {
         Global.Warning("add: note cel is empty");
      }
   }

   // <ui_handle.png>
   protected method handlePresetAdd2(String _name) {
      addPresetPatternFromNoteCel(_name.trim());
   }

   // <ui_handle.png>
   protected method handlePresetRemove() {
   }

   // <ui_show.png>
   protected method showLane() {
      int stepRes = parent_node.pv_step_resolution;
      int mpatNumSteps = mpat.num_ticks / stepRes;

      cm_scaling.setSelectedOption(lane.scaling - 1);
      cm_mode.setSelectedOption(lane.mode);
      ls_mode.switchToLayerNr(lane.mode);

      // Euclidean:
      fp_num_trigs.setMinMaxValues(1, mpatNumSteps);
      fp_num_steps.setMinMaxValues(0, mpatNumSteps);

      fp_num_trigs.setValue(lane.num_trigs);
      fp_num_steps.setValue(lane.num_steps);
      cm_pre_mode.setSelectedOption(lane.pre_mode);
      cm_post_mode.setSelectedOption(lane.pre_mode);
      cb_reverse.setSelected(lane.b_reverse);
      cb_invert.setSelected(lane.b_invert);

      // Preset:
      cm_preset_pat1.setSelectedOption(mathMini(preset_patterns.numElements-1, lane.preset_pat1));
      cm_preset_pat2.setSelectedOption(mathMini(preset_patterns.numElements-1, lane.preset_pat2));
      cm_preset_combine.setSelectedOption(lane.preset_combine);
      updatePresetPatLenAndRot();

      fp_rotation.setMinMaxValues(-mpatNumSteps, mpatNumSteps);
      fp_rotation.setValue(lane.rotation);

      fp_prob_seed.setValue(lane.prob_seed);
      fp_prob_off .setValue(lane.prob_off);
      fp_prob     .setValue(lane.prob);
      fp_prob2    .setValue(lane.prob2);
      fp_prob3    .setValue(lane.prob3);

      fp_vel_seed.setValue(lane.vel_seed);
      fp_vel_min .setValue(lane.vel_min);
      fp_vel_max .setValue(lane.vel_max);
      fp_vel_odd .setValue(lane.vel_odd);

      fp_acc_seed    .setValue(lane.acc_seed);
      fp_acc_prob_off.setValue(lane.acc_prob_off);
      fp_acc_prob    .setValue(lane.acc_prob);
      fp_acc_prob2   .setValue(lane.acc_prob2);
      fp_acc_prob3   .setValue(lane.acc_prob3);

      fp_dur_seed.setValue(lane.dur_seed);
      fp_dur_min .setValue(lane.dur_min);
      fp_dur_max .setValue(lane.dur_max);

      fp_slide_seed    .setValue(lane.slide_seed);
      fp_slide_prob_off.setValue(lane.slide_prob_off);
      fp_slide_prob    .setValue(lane.slide_prob);
      fp_slide_prob2   .setValue(lane.slide_prob2);
      fp_slide_prob3   .setValue(lane.slide_prob3);

      fp_oct_seed.setValue(lane.oct_seed);
      fp_oct_min .setValue(lane.oct_min);
      fp_oct_max .setValue(lane.oct_max);
      fp_oct_prob.setValue(lane.oct_prob);
      cb_oct_nr  .setSelected(lane.b_oct_nr);

      fp_notes_seed.setValue(lane.notes_seed);
      tf_notes     .setText(lane.getNotesString());
      cm_notes_mode.setSelectedOption(lane.notes_mode);
      cm_notes_min .setOptions(MIDI.midi_notes);
      cm_notes_max .setOptions(MIDI.midi_notes);
      cm_notes_min .setSelectedOption(lane.notes_min);
      cm_notes_max .setSelectedOption(lane.notes_max);
      cb_notes_advance.setSelected(lane.b_notes_advance);

      fp_post_rotation.setMinMaxValues(-mpatNumSteps, mpatNumSteps);
      fp_post_rotation.setValue(lane.post_rotation);
      fp_swing.setValue(lane.swing);

      cm_echo_mode      .setSelectedOption(lane.echo_mode);
      fp_echo_delay     .setValue(lane.echo_delay);
      fp_echo_max       .setValue(lane.echo_max);
      fp_echo_vel_decay .setValue(lane.echo_vel_decay);
      fp_echo_note_decay.setValue(lane.echo_note_decay);
   }

   // <ui_show.png>
   public virtual postShow() {
      Dialog::postShow();

      UI.SetKeyboardFocus(bt_close);

      relayout();
      resizeToMinimum();
      resizeToMinimum();

      setLearnMode(LEARN_NONE, true/*bQuiet*/);
   }

   // <ui_hide.png>
   public virtual hide() {
      ta_generate.cancel();

      setLearnMode(LEARN_NONE, true/*bQuiet*/);
      ta_midi_learn.cancel();

      Dialog::hide();
   }

   // <ui_update.png>
   protected method updatePresetPatLenAndRot() {
      int pat1Len = lane.preset_pat1_steps.numElements;
      int pat2Len = lane.preset_pat2_steps.numElements;
      lane.preset_len1 = mathMini(lane.preset_len1, pat1Len+1);
      lane.preset_len2 = mathMini(lane.preset_len2, pat2Len+1);
      fp_preset_len1.setMaxValue(pat1Len);
      fp_preset_len2.setMaxValue(pat2Len);
      fp_preset_len1.setResetValue(pat1Len);
      fp_preset_len2.setResetValue(pat2Len);
      fp_preset_len1.setValue(lane.preset_len1);
      fp_preset_len2.setValue(lane.preset_len2);
      lane.preset_rot1 = mathWrapi(lane.preset_rot1, -pat1Len, pat1Len);
      lane.preset_rot2 = mathWrapi(lane.preset_rot2, -pat2Len, pat2Len);
      fp_preset_rot1.setMinMaxValues(-pat1Len, pat1Len);
      fp_preset_rot2.setMinMaxValues(-pat2Len, pat2Len);
      fp_preset_rot1.setValue(lane.preset_rot1);
      fp_preset_rot2.setValue(lane.preset_rot2);
   }

   // <ui_handle.png>
   protected method copyLaneToClipboard() {
      if(null == lane_clipboard)
      {
         lane_clipboard <= new NT_RandomParamsLane;
         lane_clipboard.init();
      }
      lane_clipboard.copyFrom(lane);
   }

   // <ui_handle.png>
   protected method pasteClipboardToLane() {
      if(null != lane_clipboard)
      {
         lane.copyFrom(lane_clipboard);
         showLane();
      }
   }

   // <ui_handle.png>
   protected method handleModeChanged() {
      lane.mode = cm_mode.getSelectedOption();
      Global.Print("Mode is "+cm_mode.getSelectedOptionName());
      ls_mode.switchToLayerNr(lane.mode);
      resizeToMinimum();
      ta_generate.reschedule();
   }

   // <ui_handle.png>
   protected method handleNumTrigsChanged() {
      lane.num_trigs = fp_num_trigs.getFloatValue();

      ta_generate.reschedule();

      Global.Print("Num trigs is "+lane.num_trigs);
   }

   // <ui_handle.png>
   protected method handleNumStepsChanged() {
      lane.num_steps = fp_num_steps.getFloatValue();

      ta_generate.reschedule();

      Global.Print("Num steps is "+lane.num_steps+((0 == lane.num_steps)?" (use track length)+":""));
   }

   // <ui_handle.png>
   protected method handlePreModeChanged() {
      lane.pre_mode = cm_pre_mode.getSelectedOption();

      ta_generate.reschedule();

      Global.Print("Pre inc/dec mode is "+cm_pre_mode.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePostModeChanged() {
      lane.post_mode = cm_post_mode.getSelectedOption();

      ta_generate.reschedule();

      Global.Print("Post inc/dec mode is "+cm_post_mode.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handleReverseChanged() {
      lane.b_reverse = cb_reverse.isSelected();

      ta_generate.reschedule();

      Global.Print("Reverse is "+Utils.GetEnableString(lane.b_reverse));
   }

   // <ui_handle.png>
   protected method handleInvertChanged() {
      lane.b_invert = cb_invert.isSelected();

      ta_generate.reschedule();

      Global.Print("Invert is "+Utils.GetEnableString(lane.b_invert));
   }

   // <ui_handle.png>
   protected method handleRotationChanged() {
      lane.rotation = fp_rotation.getFloatValue();

      ta_generate.reschedule();

      Global.Print("Rotation is "+lane.rotation);
   }

   // <method.png>
   protected =replay= method clear() {

      boolean bUndoBegin = !b_have_undo;
      if(bUndoBegin)
      {
         parent_node.undoBeginNested("clear lane");
         parent_node.undoTouchPattern(pat_nr);
      }

      Envelope *envNote;
      Envelope *envVel;
      Envelope *envDur;

      // Clear note1 + vel1 + dur1
      float tOrig;
      envNote <= track_pat.getCreateEnvelope(NT_TrackPattern.CTL_NOTE1 + params.lane_idx);
      envVel  <= track_pat.getCreateEnvelope(NT_TrackPattern.CTL_VEL1  + params.lane_idx);
      envDur  <= track_pat.getCreateEnvelope(NT_TrackPattern.CTL_DUR1  + params.lane_idx);

      tOrig = envNote.time;
      envNote.empty();
      envVel.empty();
      envDur.empty();

      envNote.time = tOrig;
      envVel.time  = tOrig;
      envDur.time  = tOrig;

      if(bUndoBegin)
         parent_node.undoEndNested("clear lane");

      b_have_undo = true;
      bt_undo.setEditable(true);

      pattern_view.queueRedrawAll();

      Global.Print("Clear lane "+(params.lane_idx+1));
   }

   // <method.png>
   protected method generate() {

      int stepRes = parent_node.pv_step_resolution;
      int mpatNumSteps = mpat.num_ticks / stepRes;
      Global.Debug("NT_RandomDialog::generate: BEGIN mpatNumSteps="+mpatNumSteps);

      local Euclid e;

      int len;
      IntArray *presetSteps1;
      IntArray *presetSteps2;
      int pat1Len;
      int pat2Len;
      int pat1Off;
      int pat2Off;
      int srcIdx1;
      int srcIdx2;
      boolean bInc1 = true;
      boolean bInc2 = true;
      int activePatIdx = 0;
      boolean bPatFlip = (lane.preset_combine >= NT_RandomParamsLane.PRESET_COMBINE_FLIP_CONT);
      int laneRot1;
      int laneRot2;

      if(NT_RandomParamsLane.MODE_EUCLIDEAN == lane.mode)
      {
         len = lane.num_steps;
         if(0 == len)
            len = mpatNumSteps;

         e.generate(lane.num_trigs, len);
         e.calcPatAndIntervalVec((1 == lane.pre_mode)/*bIncDecPre*/,
                                 (2 == lane.pre_mode)/*bDecIncPre*/,
                                 lane.b_reverse,
                                 (1 == lane.post_mode)/*bIncDecPost*/,
                                 (2 == lane.post_mode)/*bDecIncPost*/,
                                 lane.rotation
                                 );
      }
      else
      {
         if((NT_RandomParamsLane.PRESET_COMBINE_FLIP_HOLD      == lane.preset_combine) ||
            (NT_RandomParamsLane.PRESET_COMBINE_FLIP_NOTE_HOLD == lane.preset_combine)
            )
            bInc2 = false;

         presetSteps1 <= lane.preset_pat1_steps;
         presetSteps2 <= lane.preset_pat2_steps;
         pat1Len = presetSteps1.numElements;
         pat2Len = presetSteps2.numElements;
         pat1Off = mathWrapi(lane.preset_rot1, 0, pat1Len);
         pat2Off = mathWrapi(lane.preset_rot2, 0, pat2Len);
         srcIdx1 = 0;
         srcIdx2 = 0;

         if(pat1Len > 0)
         {
            laneRot1 = lane.rotation;
            while(laneRot1 < 0)
               laneRot1 += pat1Len;
            while(laneRot1 >= pat1Len)
               laneRot1 -= pat1Len;
         }
         else
            laneRot1 = 0;

         if(pat2Len > 0)
         {
            laneRot2 = lane.rotation;
            while(laneRot2 < 0)
               laneRot2 += pat2Len;
            while(laneRot2 >= pat2Len)
               laneRot2 -= pat2Len;
         }
         else
            laneRot2 = 0;
      }

      int stepIdx = 0;
      int srcIdx = 0;

      // Trig Probability
      local LFSR lfsrProb;
      lfsrProb.init(lane.prob_seed * 0x7ffffff, NT_RandomParamsLane.RAND_NUM_PRE);
      float probOff = lane.prob_off;
      float prob    = lane.prob;
      float prob2   = lane.prob2;
      float prob3   = lane.prob3;

      // Velocity
      local LFSR lfsrVel;
      lfsrVel.init(lane.vel_seed * 0x7ffffff, NT_RandomParamsLane.RAND_NUM_PRE);
      float velMin = mathMinf(lane.vel_min, lane.vel_max);
      float velMax = mathMaxf(lane.vel_min, lane.vel_max);
      // // float velOdd = lane.vel_odd;

      // Accent
      local LFSR lfsrAcc;
      lfsrAcc.init(lane.acc_seed * 0x7ffffff, NT_RandomParamsLane.RAND_NUM_PRE);
      float accProbOff = lane.acc_prob_off;
      float accProb    = lane.acc_prob;
      float accProb2   = lane.acc_prob2;
      float accProb3   = lane.acc_prob3;

      // Duration
      local LFSR lfsrDur;
      lfsrDur.init(lane.dur_seed * 0x7ffffff, NT_RandomParamsLane.RAND_NUM_PRE);
      float durMin = mathMinf(lane.dur_min, lane.dur_max);
      float durMax = mathMaxf(lane.dur_min, lane.dur_max);

      // Slide
      local LFSR lfsrSlide;
      lfsrSlide.init(lane.slide_seed * 0x7ffffff, NT_RandomParamsLane.RAND_NUM_PRE);
      float slideProbOff = lane.slide_prob_off;
      float slideProb    = lane.slide_prob;
      float slideProb2   = lane.slide_prob2;
      float slideProb3   = lane.slide_prob3;

      // Octave
      float octMin = mathMinf(lane.oct_min, lane.oct_max);
      float octMax = mathMaxf(lane.oct_min, lane.oct_max);
      local IntArray octTbl;
      int i = octMin;
      loop(octMax - octMin + 1)
         octTbl.add(i++);
      int octProb = (1.0 - lane.oct_prob) * 255;

      local LFSR lfsrOct;
      lfsrOct.init(lane.oct_seed * 0x7ffffff, NT_RandomParamsLane.RAND_NUM_PRE);
      local LFSR_NR lfsrOctNR;
      lfsrOctNR.init(lane.oct_seed * 0x7ffffff, octTbl.numElements, NT_RandomParamsLane.RAND_NUM_PRE);

      local LFSR lfsrNotes;
      lfsrNotes.init(lane.notes_seed * 0x7ffffff, NT_RandomParamsLane.RAND_NUM_PRE);
      local LFSR_NR lfsrNotesNR;
      IntArray notes <= lane.notes;
      lfsrNotesNR.init(lane.notes_seed * 0x7ffffff, notes.numElements, NT_RandomParamsLane.RAND_NUM_PRE);

      // trace "xxx notes="+#(notes);

      boolean bSetPrev = false;
      boolean bSlidePrev = false;
      boolean bAccentPrev = false;
      int trigIdx = 0;
      int scaling = lane.scaling;

      local PointerArray steps;
      loop(mpatNumSteps)
         steps.add(#(new NT_RandomStep));
      NT_RandomStep *st;
      foreach st in steps
         st.note = -1;
      int stIdx = 0;

      loop(mpatNumSteps / scaling)
      {
         boolean bSet = false;

         if(NT_RandomParamsLane.MODE_EUCLIDEAN == lane.mode)
            bSet = ('X' == (e.pat.getc(srcIdx)));
         else
         {
            // trace "xxx stepIdx="+stepIdx+" activePatIdx="+activePatIdx;
            // trace "xxx stepIdx="+stepIdx+" pat1Off="+pat1Off+" srcIdx1="+srcIdx1+" laneRot1="+laneRot1+" wrapSum="+mathWrapi(pat1Off + srcIdx1 + laneRot1, 0, pat1Len);
            if(0 == activePatIdx)
               bSet = presetSteps1.get( mathWrapi(pat1Off + srcIdx1 + laneRot1, 0, pat1Len) );
            else
               bSet = presetSteps2.get( mathWrapi(pat2Off + srcIdx2 + laneRot2, 0, pat2Len) );
         }
         boolean bAccent = false;
         boolean bSlide = false;

         if(lane.b_invert)
            bSet = !bSet;

         boolean bNextInc1 = bInc1;
         boolean bNextInc2 = bInc2;
         int nextActivePatIdx = activePatIdx;

         if(bSet)
         {
            float probRnd = mathClampf(lfsrProb.randf(1.0) + probOff, 0.0, 1.0);
            float probAmt = (stepIdx&1) ? prob2 : prob;
            if(bSetPrev)
               probAmt *= prob3;
            if(probRnd < (1.0 - probAmt))
               bSet = false;

            if(bSet)
            {
               float accProbRnd = mathClampf(lfsrAcc.randf(1.0) + accProbOff, 0.0, 1.0);
               float accProbAmt = (stepIdx&1) ? accProb2 : accProb;
               if(bAccentPrev)
                  accProbAmt *= accProb3;
               bAccent = !(accProbRnd < (1.0 - accProbAmt));

               float slideProbRnd = mathClampf(lfsrSlide.randf(1.0) + slideProbOff, 0.0, 1.0);
               float slideProbAmt = (stepIdx&1) ? slideProb2 : slideProb;
               if(bSlidePrev)
                  slideProbAmt *= slideProb3;
               bSlide = !(slideProbRnd < (1.0 - slideProbAmt));
               // trace "xxx stepIdx="+stepIdx+" slideProbRnd="+slideProbRnd+" bSlide="+bSlide+" bSlidePrev="+bSlidePrev;

               bSlidePrev = bSlide;
               bAccentPrev = bAccent;

               if(lane.preset_combine >= NT_RandomParamsLane.PRESET_COMBINE_FLIP_NOTE_CONT)
               {
                  nextActivePatIdx = activePatIdx ^ 1;
                  if(lane.preset_combine == NT_RandomParamsLane.PRESET_COMBINE_FLIP_NOTE_HOLD)
                  {
                     if(1 == nextActivePatIdx)
                     {
                        bNextInc1 = false;
                        bNextInc2 = true;
                     }
                     else
                     {
                        bNextInc1 = true;
                        bNextInc2 = false;
                     }
                  }
               }
            }
         }

         if(bSet)
         {
            // Note
            int note;
            if(notes.numElements > 1)
            {
               if(0 == lane.notes_mode)
                  note = notes.get(trigIdx % notes.numElements);
               else if(1 == lane.notes_mode)
                  note = notes.get(lfsrNotes.randu() % notes.numElements);
               else
                  note = notes.get(lfsrNotesNR.next);
            }
            else if(notes.numElements > 0)
            {
               note = notes.get(0);
            }
            else
               note = 5*12; // C-5

            // Octave
            int oct;
            int octRand = lfsrOct.randu();
            if(lane.b_oct_nr)
               oct = (octTbl.numElements > 1) ? octTbl.get(lfsrOctNR.next) : 0;
            else
               oct = octTbl.get(octRand % octTbl.numElements);
            if( (octRand&255) < octProb )
               oct = 0;

            note = mathClampi(note + oct*12, 0, 127);

            // Velocity
            float vel = lfsrVel.randf(velMax - velMin) + velMin;
            // // if(stepIdx & 1)
            // //    vel *= velOdd;
            vel = bAccent ? 65536 : (vel * 127.0);

            // Duration
            float dur = lfsrDur.randf(durMax - durMin) + durMin;
            dur = mathClampi(dur, 1, 6144);

            st <= steps[stIdx];
            st.note = note;
            st.vel  = vel;
            st.dur  = dur;
            st.b_slide = bSlide;

            trigIdx++;
         }
         else if(lane.b_notes_advance)
         {
            if(notes.numElements > 1)
            {
               if(0 == lane.notes_mode)
                  notes.get(trigIdx % notes.numElements);
               else if(1 == lane.notes_mode)
                  notes.get(lfsrNotes.randu() % notes.numElements);
               else
                  notes.get(lfsrNotesNR.next);
               trigIdx++;
            }
         }

         // Next step
         stepIdx++;
         srcIdx = (srcIdx + 1) % len;

         if(bInc1)
         {
            srcIdx1 = (srcIdx1 + 1) % lane.preset_len1;
            if((0 == srcIdx1) && bPatFlip)
            {
               if(lane.preset_combine < NT_RandomParamsLane.PRESET_COMBINE_FLIP_NOTE_CONT)
               {
                  if(0 == activePatIdx)
                     nextActivePatIdx = 1;
                  if(NT_RandomParamsLane.PRESET_COMBINE_FLIP_HOLD == lane.preset_combine)
                  {
                     bNextInc1 = false;
                     bNextInc2 = true;
                  }
               }
            }
         }
         if(bInc2)
         {
            srcIdx2 = (srcIdx2 + 1) % lane.preset_len2;
            if((0 == srcIdx2) && bPatFlip)
            {
               if(lane.preset_combine < NT_RandomParamsLane.PRESET_COMBINE_FLIP_NOTE_CONT)
               {
                  if(1 == activePatIdx)
                     nextActivePatIdx = 0;
                  if(NT_RandomParamsLane.PRESET_COMBINE_FLIP_HOLD == lane.preset_combine)
                  {
                     bNextInc1 = true;
                     bNextInc2 = false;
                  }
               }
            }
         }

         bInc1 = bNextInc1;
         bInc2 = bNextInc2;
         activePatIdx = nextActivePatIdx;

         stIdx += scaling;

         bSetPrev = bSet;
      }

      if(1.0 != lane.vel_odd)
      {
         applyVelocitySwing(steps);
      }

      if(NT_RandomParamsLane.ECHO_OFF != lane.echo_mode)
      {
         processEcho(steps);
      }

      applySlide(steps);

      if( (0 != lane.notes_min) || (127 != lane.notes_max) )
      {
         applyNoteFilter(steps);
      }

      emitStepsToEnvelopes(steps, mpatNumSteps, stepRes);

      pattern_view.queueRedrawAll();

      Global.Debug("NT_RandomDialog::generate: END");
   }


   // <method.png>
   protected method applyVelocitySwing(PointerArray steps) {
      float velOdd = lane.vel_odd;
      int swingPostEvenOdd = lane.post_rotation & 1;

      int stIdx = 0;
      NT_RandomStep *st;
      foreach st in steps
      {
         if( (stIdx & 1) ^ swingPostEvenOdd )
         {
            st.vel = st.vel * velOdd;
         }

         stIdx++;
      }
   }

   // <method.png>
   protected method processEcho(PointerArray _steps) : PointerArray {
      NT_RandomStep *st;
      NT_RandomStep *stn;

      // Duplicate steps
      local PointerArray steps;
      loop(2)
      {
         foreach st in _steps
         {
            stn <= new NT_RandomStep;
            stn = st;
            steps.add(#(deref stn));
         }
      }

      // Create echoes
      local NT_RandomDelayProc proc;
      int stepIdx = 0;
      foreach st in steps
      {
         proc.step();
         boolean bProcNote = (st.note >= 0);

         // trace "xxx echo stepIdx="+stepIdx+" note="+st.note;
         NT_RandomDelay *dly;
         foreach dly in proc.delays
         {
            if(dly.b_emit)
            {
               // trace "xxx     note="+dly.note+" vel="+dly.vel+" echo_idx="+dly.echo_idx;
               if(-1 == st.note)
               {
                  st.note = dly.note;
                  st.vel  = dly.vel;
                  st.dur  = dly.dur;
               }
               else
                  st.addDelayedStep(dly.note, dly.vel, dly.dur);
            }
         }

         if(bProcNote)
         {
            proc.noteOn(st.note, st.vel, st.dur, lane.echo_delay, lane.echo_vel_decay, lane.echo_note_decay, lane.echo_max);
         }

         stepIdx++;
      }

      // Return second half of steps
      _steps.free();
      stepIdx = steps.numElements / 2;
      loop(stepIdx)
         _steps.add(#(steps.getDeref(stepIdx++)));
   }

   // <method.png>
   protected method applySlide(PointerArray steps) {

      int stepRes = parent_node.pv_step_resolution;
      float durTicks = parent_node.dur_ticks_resetval;

      int numSteps = steps.numElements;
      int stIdx = 0;
      loop(numSteps)
      {
         NT_RandomStep st <= steps[stIdx];
         // trace "xxx applySlide: stIdx="+stIdx+" note="+st.note+" st.b_slide="+st.b_slide;
         if(st.note >= 0)
         {
            if(st.b_slide)
            {
               // Increase duration of previous trig so it overlaps with current trig
               int pstIdx = (stIdx + numSteps - 1) % numSteps;
               int tickDist = stepRes;
               loop(numSteps)
               {
                  NT_RandomStep pst <= steps[pstIdx];
                  // trace "xxx    find slide pstIdx="+pstIdx+" pst.note="+pst.note;
                  if(pst.note >= 0)
                  {
                     if(@(pst) != @(st))
                     {
                        int pstDurTicks = durTicks * pst.dur;
                        // trace "xxx    find slide pstIdx="+pstIdx+" tickDist="+tickDist+" pstDurTicks="+pstDurTicks;
                        if(pstDurTicks <= tickDist)
                        {
                           pstDurTicks = tickDist + 1;
                           pstDurTicks = int((pstDurTicks + durTicks - 1) / durTicks) * durTicks;
                           pst.dur = pstDurTicks / durTicks;
                           // trace "xxx set pst["+pstIdx+"].dur="+pst.dur;
                           break;
                        }
                     }
                  }
                  pstIdx = (pstIdx + numSteps - 1) % numSteps;
                  tickDist += stepRes;
               }
            }
         }
         stIdx++;
      }
   }

   // <method.png>
   protected method applyNoteFilter(PointerArray steps) {
      int noteMin = lane.notes_min;
      int noteMax = lane.notes_max;

      NT_RandomStep *st;
      foreach st in steps
      {
         if!(noteMin <= st.note <= noteMax)
            st.note = -1;

         NT_RandomStep *dst;
         int dlyStepIdx = 0;
         PointerArray dlySteps <= st.delayed_steps;
         while(dlyStepIdx < dlySteps.numElements)
         {
            dst <= dlySteps.get(dlyStepIdx);
            if!(noteMin <= dst.note <= noteMax)
               dlySteps.delete(dlyStepIdx);
            else
               dlyStepIdx++;
         }
      }
   }

   // <method.png>
   protected =replay= method emitStepsToEnvelopes(PointerArray steps, int mpatNumSteps, int stepRes) {

      boolean bUndoBegin = !b_have_undo;
      if(bUndoBegin)
      {
         parent_node.undoBeginNested("randomize pattern");
         parent_node.undoTouchPattern(pat_nr);
      }

      // Clear note1 + vel1 + dur1
      Envelope *envNote;
      Envelope *envVel;
      Envelope *envDur;

      envNote <= track_pat.getCreateEnvelope(NT_TrackPattern.CTL_NOTE1 + params.lane_idx);
      envVel  <= track_pat.getCreateEnvelope(NT_TrackPattern.CTL_VEL1  + params.lane_idx);
      envDur  <= track_pat.getCreateEnvelope(NT_TrackPattern.CTL_DUR1  + params.lane_idx);

      int tOrig = envNote.time;
      envNote.empty();
      envVel.empty();
      envDur.empty();

      // Copy steps to envelopes
      int stIdx = mathWrapi(lane.post_rotation, 0, mpatNumSteps);
      int swingPostEvenOdd = lane.post_rotation & 1;
      // // int tickOff = 0;
      int delta = 0;
      local FloatArray velOrderValues;
      local IntArray velOrderSorted;

      loop(mpatNumSteps)
      {
         NT_RandomStep st <= steps[stIdx];
         NT_RandomStep *stDly;
         int stDlyIdx;

         int swingDelta;
         if( (stIdx & 1) ^ swingPostEvenOdd )
         {
            swingDelta = (stepRes * lane.swing);
         }
         else
            swingDelta = 0;

         if(st.note >= 0)
         {
            delta = delta + swingDelta;

            envNote.add(delta);
            envNote.add(st.note);

            envVel.add(delta);
            envVel.add(mathClampf(st.vel, 1, 127));

            envDur.add(delta);
            envDur.add(st.dur);

            delta = -swingDelta;
         }
         else if(NT_RandomParamsLane.ECHO_EMPTY == lane.echo_mode)
         {
            stDlyIdx = 0;
            float echoMaxVel = 0;
            int echoBestIdx = -1;

            // Find loudest delay
            foreach stDly in st.delayed_steps
            {
               if(stDly.vel > echoMaxVel)
               {
                  echoMaxVel = stDly.vel;
                  echoBestIdx = stDlyIdx;
               }

               stDlyIdx++;
            }

            if(echoBestIdx >= 0)
            {
               stDly <= st.delayed_steps.get(echoBestIdx);
               delta = delta + swingDelta;

               envNote.add(delta);
               envNote.add(stDly.note);

               envVel.add(delta);
               envVel.add(mathClampf(stDly.vel, 1, 127));

               envDur.add(delta);
               envDur.add(stDly.dur);

               delta = -swingDelta;
            }
         }

         if(NT_RandomParamsLane.ECHO_MICRO == lane.echo_mode)
         {
            if(st.delayed_steps.numElements > 0)
            {
               if(st.note >= 0)
               {
                  delta = 1;
               }
               else
               {
                  delta = delta + swingDelta;
                  swingDelta--;
               }

               // Order delayed steps by velocity
               //  (note) so that loudest echo has display and note priority
               velOrderValues.empty();
               foreach stDly in st.delayed_steps
                  velOrderValues.add(stDly.vel);
               velOrderValues.sortByValue(velOrderSorted);

               stDlyIdx = velOrderSorted.numElements;

               loop(velOrderSorted.numElements)
               {
                  stDly <= st.delayed_steps.get(velOrderSorted[--stDlyIdx]);

                  envNote.add(delta);
                  envNote.add(stDly.note);

                  envVel.add(delta);
                  envVel.add(mathClampf(stDly.vel, 1, 127));

                  envDur.add(delta);
                  envDur.add(stDly.dur);

                  swingDelta++;
                  delta = 1;
               }

               delta = -swingDelta;
            }
         }

         // // tickOff += stepRes;
         delta += stepRes;
         stIdx = (stIdx + 1) % mpatNumSteps;
      }

      envNote.time = tOrig;
      envVel.time  = tOrig;
      envDur.time  = tOrig;

      if(bUndoBegin)
         parent_node.undoEndNested("randomize pattern");

      b_have_undo = true;
      bt_undo.setEditable(true);
   }

   // <ui_handle.png>
   protected method handleUndo() {

      if(b_have_undo)
      {
         local NT_RandomParams paramsOrig;
         paramsOrig.init();
         paramsOrig.copyFrom(params);
         editor.cmd_edit_undo();
         NT_RandomParams paramsNew <= track_pat.getOrCreateRandomParams();
         paramsNew.copyFrom(paramsOrig);
         params <= track_pat.getOrCreateRandomParams();
         lane <= params.getLane(params.lane_idx);
         showLane();
         b_have_undo = false;
         bt_undo.setEditable(false);
      }

      // // NT_RandomParams curParams = params;
      // // editor.undoRedo(true/*bForceUndo*/);
      // // cursor_track <= editor.grid.getCursorTrack();
      // // params <= cursor_track.euclid_params;
      // // params = curParams;
   }

   // <ui_handle.png>
   protected method handleRand() {

      lane.prob_seed = rand(1.0);
      fp_prob_seed.setValue(lane.prob_seed);

      lane.vel_seed = rand(1.0);
      fp_vel_seed.setValue(lane.vel_seed);

      lane.acc_seed = rand(1.0);
      fp_acc_seed.setValue(lane.acc_seed);

      lane.dur_seed = rand(1.0);
      fp_dur_seed.setValue(lane.dur_seed);

      lane.slide_seed = rand(1.0);
      fp_slide_seed.setValue(lane.slide_seed);

      lane.oct_seed = rand(1.0);
      fp_oct_seed.setValue(lane.oct_seed);

      lane.notes_seed = rand(1.0);
      fp_notes_seed.setValue(lane.notes_seed);

      Global.Print("Randomize all seeds");
      ta_generate.reschedule();
   }

   // <ui_handle.png>
   protected method handlePresetPat1Changed() {
      int patIdx = cm_preset_pat1.getSelectedOption();

      NT_RandomizerPattern pat <= preset_patterns.get(patIdx);
      if(null != pat)  // should not be null
      {
         lane.preset_pat1 = patIdx;
         lane.preset_pat1_steps = pat.steps;
         lane.preset_len1 = mathMini(lane.preset_len1, pat.steps.numElements);

         updatePresetPatLenAndRot();

         Global.Print("Pattern 1 preset is "+patIdx);
      }

   }

   // <ui_handle.png>
   protected method handlePresetPat2Changed() {
      int patIdx = cm_preset_pat2.getSelectedOption();

      NT_RandomizerPattern pat <= preset_patterns.get(patIdx);
      if(null != pat)  // should not be null
      {
         lane.preset_pat2 = patIdx;
         lane.preset_pat2_steps = pat.steps;
         lane.preset_len2 = mathMini(lane.preset_len2, pat.steps.numElements);

         updatePresetPatLenAndRot();

         Global.Print("Pattern 2 preset is "+patIdx);
      }
   }

   // <ui_handle.png>
   protected method handleGenerate() {

      // trace "xxx NT_RandomDialog::generate";

      generate();

      // editor.handlePatternChanged(false/*bFromUI*/);
   }

   // <ui_handle.png>
   protected method handleLaneChanged() {
      params.lane_idx = cm_lane.getSelectedOption();
      lane <= params.getLane(params.lane_idx);
      showLane();
      Global.Print("Lane is NOTE/VEL/DUR "+(1+params.lane_idx));
   }

   // <ui_midi.png>
   protected method mmlHandleEventNotes(MIDIMapEvent _ev) : boolean {
      if(MIDIMapDefs.TYPE_NOTE_ON == _ev.type)
      {
         Global.Debug("NT_RandomDialog: learn note="+_ev.arg1);
         IntArray notes <= lane.notes;
         if(0 == num_notes_learnt++)
            notes.empty();
         notes.add(_ev.arg1);
         tf_notes.setText(lane.getNotesString());
         ta_generate.reschedule();
      }
      return true;
   }

   // <method.png>
   protected method importNotesFromEnvelope() {
      Envelope envNote <= track_pat.getCreateEnvelope(NT_TrackPattern.CTL_NOTE1 + params.lane_idx);
      IntArray notes <= lane.notes;
      notes.empty();
      int envIdx = 1;
      loop(envNote.numElements / 2)
      {
         int note = envNote[envIdx];
         if(note >= 0)
         {
            notes.add(note);
         }

         envIdx += 2;
      }

      tf_notes.setText(lane.getNotesString());
      ta_generate.reschedule();

      Global.Print("Import notes from envelope");
   }

   // <method_get.png>
   protected method getLearnButton() : Button {
      Button *bt;

      switch(learn_mode)
      {
         default:
         case LEARN_NONE:
            bt <= null;
            break;

         case LEARN_NOTES:
            bt <= bt_notes_learn;
            break;
      }

      return bt;
   }

   // <method_set.png>
   protected method setLearnMode(int _mode, boolean _bQuiet) {

         IntArray notes <= lane.notes;

      if(learn_mode == _mode)
      {
         // Toggle off
         if(!_bQuiet)
         {
            Global.Print("Stop learn <"+learn_mode_names.get(learn_mode)+">");
         }

         if(LEARN_NOTES == learn_mode)
         {
            Global.Print("Learnt "+notes.numElements+" note"+Utils.GetPluralString(notes.numElements));
            ta_generate.reschedule();
         }

         learn_mode = LEARN_NONE;
      }
      else
      {
         if(learn_mode != LEARN_NONE)
         {
            if(LEARN_NONE == _mode)
            {
               if(!_bQuiet)
               {
                  Global.Print("Stop learn <"+learn_mode_names.get(learn_mode)+">");
               }
            }

            if(LEARN_NOTES == learn_mode)
            {
               Global.Print("Learnt "+notes.numElements+" note"+Utils.GetPluralString(notes.numElements));
               ta_generate.reschedule();
            }
         }

         learn_mode = _mode;

         if(LEARN_NONE != _mode)
         {
            if(!_bQuiet)
            {
               Global.Print("Start learn <"+learn_mode_names.get(learn_mode)+">");
            }

            if(LEARN_NOTES == learn_mode)
            {
               num_notes_learnt = 0;
            }
         }

      }

      String caption = " Learn ";

      bt_notes_learn    .setBackgroundTint(0);
      bt_notes_learn    .setCaption(caption);
      bt_notes_learn    .redraw();

      Button bt <= getLearnButton();

      if(null != bt)
      {
         bt.setCaption(" Stop ");
         bt.setBackgroundTint(TINT32_LEARN);
         bt.redraw();
         learn_timeout = LEARN_TIMEOUT;
         ta_midi_learn.schedule();
      }
      else
      {
         ta_midi_learn.cancel();
         learn_timeout = -1;
      }
   }

   // <ui_midi.png>
   public method mmlHandleEventUI(MIDIMapEvent _ev) : boolean {
      // Called by NodeTrackerEditor.mmlHandleEventUI()

      MIDIMapEvent evXForm = _ev;

      MIDIMorphScene.TransformEvent(evXForm);
      if(evXForm.isValid())
      {
         evXForm.echoTransformForced();

         boolean bHandled = false;

         switch(learn_mode)
         {
            case LEARN_NOTES:
               bHandled = mmlHandleEventNotes(evXForm);
               break;
         }

         if(bHandled)
         {
            learn_timeout = LEARN_TIMEOUT;
         }
      }

      return false;
   }

   // <ui_timer.png>
   protected method handleMIDILearnTimer() {

      // trace "xxx handleMIDILearnTimer: learn_timeout="+learn_timeout+" mode="+learn_mode;

      if(LEARN_NONE != learn_mode)
      {
         learn_timeout--;

         if(learn_timeout <= 0)
         {
            setLearnMode(LEARN_NONE, false/*bQuiet*/);
         }
         else
         {
            Button bt <= getLearnButton();

            if(learn_timeout & 1)
               bt.setBackgroundTint(TINT32_LEARN);
            else
               bt.setBackgroundTint(0);

            if(0 == (learn_timeout & 1))
            {
               if(0 != (learn_timeout & 2))
                  bt.setCaption(" "+(learn_timeout/2)+" ");
               else
                  bt.setCaption(" Stop ");
            }

            bt.redraw();

            ta_midi_learn.schedule();
         }
      }
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray layers) {
      layers.joinRR(layers,
                    [
                       cm_lane,
                       bt_copy,
                       bt_paste,
                       cm_scaling,
                       cm_mode,
                       ]
                    );

      if(0 == lane.mode)
      {
         layers.joinRR(layers,
                       [
                          fp_num_trigs,
                          fp_num_steps,
                          cm_pre_mode,
                          cm_post_mode,
                          cb_reverse,
                          cb_invert,
                        ]
                       );
      }
      else
      {
         layers.joinRR(layers,
                       [
                          cm_preset_pat1,
                          cm_preset_pat2,
                          // bt_preset_add,
                          cm_preset_combine,
                          fp_preset_len1,
                          fp_preset_len2,
                          fp_preset_rot1,
                          fp_preset_rot2,
                        ]
                       );
      }


      layers.joinRR(layers,
                    [
                       fp_rotation,
                       bt_clear,
                       bt_undo,
                       bt_rand,
                       bt_preset_add,

                       fp_prob_seed,
                       bt_prob_seed_rand,
                       fp_prob_off,
                       fp_prob,
                       fp_prob2,
                       fp_prob3,

                       fp_vel_seed,
                       bt_vel_seed_rand,
                       fp_vel_min,
                       fp_vel_max,
                       fp_vel_odd,

                       fp_acc_seed,
                       bt_acc_seed_rand,
                       fp_acc_prob_off,
                       fp_acc_prob,
                       fp_acc_prob2,
                       fp_acc_prob3,

                       fp_dur_seed,
                       bt_dur_seed_rand,
                       fp_dur_min,
                       fp_dur_max,

                       fp_slide_seed,
                       bt_slide_seed_rand,
                       fp_slide_prob_off,
                       fp_slide_prob,
                       fp_slide_prob2,
                       fp_slide_prob3,

                       fp_oct_seed,
                       bt_oct_seed_rand,
                       fp_oct_min,
                       fp_oct_max,
                       fp_oct_prob,
                       cb_oct_nr,

                       fp_notes_seed,
                       bt_notes_seed_rand,
                       cm_notes_mode,
                       cm_notes_min,
                       cm_notes_max,
                       tf_notes,
                       bt_notes_learn,

                       fp_post_rotation,
                       fp_swing,
                       cb_notes_advance,

                       cm_echo_mode,
                       fp_echo_delay,
                       fp_echo_max,
                       fp_echo_vel_decay,
                       fp_echo_note_decay,

                       bt_close
                     ]
                    );
   }

   // <ui_kbd.png>
   protected method refocusDefault() {
      UI.SetKeyboardFocus(bt_close);
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {

      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          0
          c         :   Close dialog
"
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      int key = _k.pressed;
      boolean r = false;
      loop(2) // first pass for raw keycode, second pass for unicode
      {
         // US (reference) keyboard layout (raw keycodes)
         switch(key)
         {
            case '0':
            case 'c':
               hide();
               r = true; break;

            default:
               r = maybe; break;
         }

         if(true == r)
         {
            return true;
         }
         else if(maybe == r)
         {
            Global.Print("");
         }

         // see above
         key = _k.unicode;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {

      // trace "xxx _k.pressed="+_k.pressed;

      switch(_k.pressed)
      {
         case VKEY_ESCAPE:
            hide();
            return true;

         case '1':
            cm_lane.setSelectedOption(0);
            handleLaneChanged();
            return true;

         case '2':
            cm_lane.setSelectedOption(1);
            handleLaneChanged();
            return true;

         case '3':
            cm_lane.setSelectedOption(2);
            handleLaneChanged();
            return true;

         case '4':
            cm_lane.setSelectedOption(3);
            handleLaneChanged();
            return true;

         case '5':
            cm_lane.setSelectedOption(4);
            handleLaneChanged();
            return true;

         case 'n':
            UI.SetKeyboardFocus(tf_notes);
            return true;

         case 'r':
            UI.SetKeyboardFocus(fp_rotation);
            return true;

         case 'p':
            UI.SetKeyboardFocus(fp_prob_seed);
            return true;

         case 'v':
            UI.SetKeyboardFocus(fp_vel_seed);
            return true;

         case 'c':
            UI.SetKeyboardFocus(fp_acc_seed);
            return true;

         case 'd':
            UI.SetKeyboardFocus(fp_dur_seed);
            return true;

         case 'l':
            UI.SetKeyboardFocus(fp_slide_seed);
            return true;

         case 'o':
            UI.SetKeyboardFocus(fp_oct_seed);
            return true;

         case 't':
            if(NT_RandomParamsLane.MODE_EUCLIDEAN == lane.mode)
            {
               UI.SetKeyboardFocus(fp_num_trigs);
            }
            return true;
      }

      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {

      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();
      StringAction *sac;

      if(TA_GENERATE == acName)
      {
         handleGenerate();
         return;
      }
      else if(TA_MIDI_LEARN == acName)
      {
         handleMIDILearnTimer();
         return;
      }

      switch(@(ap))
      {
         case @(dlg_new_name):
            if((TextInputDialog.ACTION_TEXTINPUTDIALOGCLOSED == acName) ||
               (TextInputDialog.ACTION_TEXTINPUTDIALOGCLOSED_HOLD == acName)
               )
            {
               sac <= _action;
               handlePresetAdd2(sac.getStringValue());
               dlg_new_name <= null;
            }
            else if(TextInputDialog.ACTION_TEXTINPUTDIALOGCANCELED == acName)
            {
               dlg_new_name <= null;
            }
            return true;

         case @(cm_lane):
            handleLaneChanged();
            return true;

         case @(bt_copy):
            copyLaneToClipboard();
            Global.Print("Copy lane to clipboard");
            return true;

         case @(bt_paste):
            pasteClipboardToLane();
            Global.Print("Paste clipboard to lane");
            return true;

         case @(cm_scaling):
            lane.scaling = cm_scaling.getSelectedOption() + 1;
            Global.Print("Time scaling is "+cm_scaling.getSelectedOptionName());
            ta_generate.reschedule();
            return true;

         case @(cm_mode):
            handleModeChanged();
            return true;

            // Euclidean:
         case @(fp_num_trigs):
            handleNumTrigsChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_num_steps):
            handleNumStepsChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cm_pre_mode):
            handlePreModeChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cm_post_mode):
            handlePostModeChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cb_reverse):
            handleReverseChanged();
            return true;

         case @(cb_invert):
            handleInvertChanged();
            return true;

            // Preset:
         case @(cm_preset_pat1):
            handlePresetPat1Changed();
            ta_generate.reschedule();
            return true;

         case @(cm_preset_pat2):
            handlePresetPat2Changed();
            ta_generate.reschedule();
            return true;

         case @(bt_preset_add):
            handlePresetAdd1();
            return true;

         case @(cm_preset_combine):
            lane.preset_combine = cm_preset_combine.getSelectedOption();
            Global.Print("Preset Combine Mode is "+cm_preset_combine.getSelectedOptionName());
            ta_generate.reschedule();
            return true;

         case @(fp_preset_len1):
            lane.preset_len1 = fp_preset_len1.getFloatValue();
            Global.Print("Preset Pattern 1 Length is "+lane.preset_len1);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_preset_len2):
            lane.preset_len2 = fp_preset_len2.getFloatValue();
            Global.Print("Preset Pattern 2 Length is "+lane.preset_len2);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_preset_rot1):
            lane.preset_rot1 = fp_preset_rot1.getFloatValue();
            Global.Print("Preset Pattern 1 Rotation is "+lane.preset_rot1);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_preset_rot2):
            lane.preset_rot2 = fp_preset_rot2.getFloatValue();
            Global.Print("Preset Pattern 2 Rotation is "+lane.preset_rot2);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_rotation):
            handleRotationChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_clear):
            clear();
            return true;

         case @(bt_undo):
            handleUndo();
            return true;

         case @(bt_rand):
            handleRand();
            return true;

         case @(fp_prob_seed):
            lane.prob_seed = fp_prob_seed.getFloatValue();
            Global.Print("Probability seed is "+lane.prob_seed);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_prob_seed_rand):
            lane.prob_seed = rand(1.0);
            fp_prob_seed.setValue(lane.prob_seed);
            Global.Print("Randomize Probability Seed");
            ta_generate.reschedule();
            return true;

         case @(fp_prob_off):
            lane.prob_off = fp_prob_off.getFloatValue();
            Global.Print("Probability offset is "+lane.prob_off);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_prob):
            lane.prob = fp_prob.getFloatValue();
            Global.Print("Even-Step Probability is "+lane.prob);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_prob2):
            lane.prob2 = fp_prob2.getFloatValue();
            Global.Print("Odd-Step Probability is "+lane.prob2);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_prob3):
            lane.prob3 = fp_prob3.getFloatValue();
            Global.Print("Subsequent Probability is "+lane.prob3);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_vel_seed):
            lane.vel_seed = fp_vel_seed.getFloatValue();
            Global.Print("Velocity seed is "+lane.vel_seed);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_vel_seed_rand):
            lane.vel_seed = rand(1.0);
            fp_vel_seed.setValue(lane.vel_seed);
            Global.Print("Randomize Velocity Seed");
            ta_generate.reschedule();
            return true;

         case @(fp_vel_min):
            lane.vel_min = fp_vel_min.getFloatValue();
            Global.Print("Velocity min is "+lane.vel_min);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_vel_max):
            lane.vel_max = fp_vel_max.getFloatValue();
            Global.Print("Velocity max is "+lane.vel_max);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_vel_odd):
            lane.vel_odd = fp_vel_odd.getFloatValue();
            Global.Print("Velocity odd-step multiplier is "+lane.vel_odd);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_acc_seed_rand):
            lane.acc_seed = rand(1.0);
            fp_acc_seed.setValue(lane.acc_seed);
            Global.Print("Randomize Accent Seed");
            ta_generate.reschedule();
            return true;

         case @(fp_acc_seed):
            lane.acc_seed = fp_acc_seed.getFloatValue();
            Global.Print("Accent probability seed is "+lane.acc_seed);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_acc_prob_off):
            lane.acc_prob_off = fp_acc_prob_off.getFloatValue();
            Global.Print("Accent probability offset is "+lane.acc_prob_off);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_acc_prob):
            lane.acc_prob = fp_acc_prob.getFloatValue();
            Global.Print("Accent Even-Step Probability is "+lane.acc_prob);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_acc_prob2):
            lane.acc_prob2 = fp_acc_prob2.getFloatValue();
            Global.Print("Accent Odd-Step Probability is "+lane.acc_prob2);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_acc_prob3):
            lane.acc_prob3 = fp_acc_prob3.getFloatValue();
            Global.Print("Accent Subsequent Probability is "+lane.acc_prob3);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_dur_seed):
            lane.dur_seed = fp_dur_seed.getFloatValue();
            Global.Print("Duration seed is "+lane.dur_seed);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_dur_seed_rand):
            lane.dur_seed = rand(1.0);
            fp_dur_seed.setValue(lane.dur_seed);
            Global.Print("Randomize Duration Seed");
            ta_generate.reschedule();
            return true;

         case @(fp_dur_min):
            lane.dur_min = fp_dur_min.getFloatValue();
            Global.Print("Duration min is "+lane.dur_min);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_dur_max):
            lane.dur_max = fp_dur_max.getFloatValue();
            Global.Print("Duration max is "+lane.dur_max);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_slide_seed):
            lane.slide_seed = fp_slide_seed.getFloatValue();
            Global.Print("Slide probability seed is "+lane.slide_seed);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_slide_seed_rand):
            lane.slide_seed = rand(1.0);
            fp_slide_seed.setValue(lane.slide_seed);
            Global.Print("Randomize Slide Seed");
            ta_generate.reschedule();
            return true;

         case @(fp_slide_prob_off):
            lane.slide_prob_off = fp_slide_prob_off.getFloatValue();
            Global.Print("Slide probability offset is "+lane.slide_prob_off);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_slide_prob):
            lane.slide_prob = fp_slide_prob.getFloatValue();
            Global.Print("Slide Even-Step Probability is "+lane.slide_prob);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_slide_prob2):
            lane.slide_prob2 = fp_slide_prob2.getFloatValue();
            Global.Print("Slide Odd-Step Probability is "+lane.slide_prob2);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_slide_prob3):
            lane.slide_prob3 = fp_slide_prob3.getFloatValue();
            Global.Print("Slide Subsequent Probability is "+lane.slide_prob3);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_oct_seed):
            lane.oct_seed = fp_oct_seed.getFloatValue();
            Global.Print("Octave seed is "+lane.oct_seed);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_oct_seed_rand):
            lane.oct_seed = rand(1.0);
            fp_oct_seed.setValue(lane.oct_seed);
            Global.Print("Randomize Octave Seed");
            ta_generate.reschedule();
            return true;

         case @(fp_oct_min):
            lane.oct_min = fp_oct_min.getFloatValue();
            Global.Print("Octave min is "+lane.oct_min);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_oct_max):
            lane.oct_max = fp_oct_max.getFloatValue();
            Global.Print("Octave max is "+lane.oct_max);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_oct_prob):
            lane.oct_prob = fp_oct_prob.getFloatValue();
            Global.Print("Octave probability is "+lane.oct_prob);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cb_oct_nr):
            lane.b_oct_nr = cb_oct_nr.isSelected();
            Global.Print("Octave non-repeating mode is "+lane.b_oct_nr);
            ta_generate.reschedule();
            return true;

         case @(fp_notes_seed):
            lane.notes_seed = fp_notes_seed.getFloatValue();
            Global.Print("Notes seed is "+lane.notes_seed);
            ta_generate.reschedule();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_notes_seed_rand):
            lane.notes_seed = rand(1.0);
            fp_notes_seed.setValue(lane.notes_seed);
            Global.Print("Randomize Note Seed");
            ta_generate.reschedule();
            return true;

         case @(tf_notes):
            if(TextField.ACTION_TEXTENTERED == acName)
            {
               lane.parseNotesString(tf_notes.getText());
               tf_notes.setText(lane.getNotesString());
               Global.Print("Update "+(lane.notes.numElements)+" note(s)");
               ta_generate.reschedule();
               refocusDefault();
            }
            return true;

         case @(cm_notes_mode):
            lane.notes_mode = cm_notes_mode.getSelectedOption();
            Global.Print("Notes mode is "+cm_notes_mode.getSelectedOptionName());
            ta_generate.reschedule();
            return true;

         case @(cm_notes_min):
            lane.notes_min = cm_notes_min.getSelectedOption();
            Global.Print("Notes range Min is "+cm_notes_min.getSelectedOptionName());
            ta_generate.reschedule();
            return true;

         case @(cm_notes_max):
            lane.notes_max = cm_notes_max.getSelectedOption();
            Global.Print("Notes range Max is "+cm_notes_max.getSelectedOptionName());
            ta_generate.reschedule();
            return true;

         case @(cb_notes_advance):
            lane.b_notes_advance = cb_notes_advance.isSelected();
            Global.Print("Advance notes each "+(lane.b_notes_advance ? "step" : "trig"));
            ta_generate.reschedule();
            return true;

         case @(bt_notes_learn):
            if(Button.ACTION_HOLD_CLICK == acName)
            {
               setLearnMode(LEARN_NONE, false/*bQuiet*/);
               importNotesFromEnvelope();
            }
            else
            {
               setLearnMode(LEARN_NOTES, false/*bQuiet*/);
            }
            return true;

         case @(fp_post_rotation):
            lane.post_rotation = fp_post_rotation.getFloatValue();
            Global.Print("Post Rotation is "+lane.post_rotation);
            ta_generate.reschedule();
            return true;

         case @(fp_swing):
            lane.swing = fp_swing.getFloatValue();
            Float fo = lane.swing * 100;
            Global.Print("Swing is "+fo.printf("%3.2f%"));
            ta_generate.reschedule();
            return true;

         case @(cm_echo_mode):
            lane.echo_mode = cm_echo_mode.getSelectedOption();
            Global.Print("Echo mode is "+cm_echo_mode.getSelectedOptionName());
            ta_generate.reschedule();
            return true;

         case @(fp_echo_delay):
            lane.echo_delay = fp_echo_delay.getFloatValue();
            Global.Print("Echo delay is "+lane.echo_delay);
            ta_generate.reschedule();
            return true;

         case @(fp_echo_max):
            lane.echo_max = fp_echo_max.getFloatValue();
            Global.Print("Max. number of echoes is "+lane.echo_max);
            ta_generate.reschedule();
            return true;

         case @(fp_echo_vel_decay):
            lane.echo_vel_decay = fp_echo_vel_decay.getFloatValue();
            Global.Print("Echo velocity decay is "+lane.echo_vel_decay);
            ta_generate.reschedule();
            return true;

         case @(fp_echo_note_decay):
            lane.echo_note_decay = fp_echo_note_decay.getFloatValue();
            Global.Print("Echo note decay is "+lane.echo_note_decay);
            ta_generate.reschedule();
            return true;

         case @(bt_close):
            hide();
            return true;
      }

      return Dialog::consumeAction(_action);
   }
}
