// ----
// ---- file   : FMMatrix.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2022-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : Yamaha FS1R & Montage/MODX FM matrix editor
// ----
// ---- created: 27Sep2022
// ---- changed: 28Sep2022, 29Sep2022, 30Sep2022, 01Oct2022, 02Oct2022, 03Oct2022, 04Oct2022
// ----          05Oct2022, 07Oct2022, 10Oct2022, 11Oct2022, 21Oct2022, 22Oct2022, 06Nov2022
// ----          10Nov2022, 11Nov2022, 12Nov2022, 18Nov2022, 01Apr2023, 21Sep2023, 24Sep2023
// ----          03Oct2023, 08Oct2023, 20Oct2023, 21Oct2023, 22Oct2023, 29Oct2023, 10Nov2023
// ----          22Mar2024, 29Mar2024, 02Apr2025
// ----
// ----
// ----

// (note) initial (cmdline) version: fm_matrix_widget/fm_matrix.tks (until 29Sep2022)

// (ignr) keep algorithm when new cell is unique (e.g. carrier and not also a modulator)
// (done) fix consumeAction() re-entrance (in TA_SORT ??)
// (dont) select algorithm by clicking into alg display and typing two numbers (==> add floatparam instead)
// (done) highlight outputs that are outputs in active algorithm
// (done) use getAlgorithm, setAlgorithm, getOpLevel instead of direct patch_data access
// (done) prefer algorithm that is most similar to current one (e.g. when activating out 4 in alg 9)
// (done) fix op swap
// (done) alg grid (4x2)
// (idea) op level spline
// (done) level delta  (e.g. 25, 50 or 100 to quickly enable/disable ops)
// (done) randomize: alg (lctrl-e), oplevel (lctrl-lshift-r), oplevel>0 (lctrl-r)  (also: right-click algorithm table to randomize alg)
// (done) cycle (active) operator levels (\'c'\)
// (done) shuffle (active) operator levels (hold-click cycle or lshift-z)
// (done) update fm matrix only when tab is visible (queue pending flag otherwise)
// (done) cycle all operator settings
// (done) cycle operator freq
// (done) cycle operator envelopes
// (done) cycle operator wave
// (done) shuffle all operator settings
// (done) shuffle operator freq
// (done) shuffle operator envelopes
// (done) shuffle operator wave
// (done) opv+opn mute mask checkboxes
// (done) show simplified editor for all 8 voiced ops (below matrix)
// (done) click "V" / "N" label buttons to mute/unmute all ops
// (done) click "O"/"F"/"L"/"T" label buttons to randomize op parameter set (hold-click to allow ratio/fixed, attack time/level)
// (idea) hold LALT to modify all op parameters (already have multi-edit mode, though)
// (done) [x] Multi-Edit mode (mirror parameter edits, randomize/init all ops) ('x')
// (done) click "1"..."8" labels to randomize all op parameter sets (hold-click to allow ratio/fixed, attack time/level)
// (dont) [x] lock algorithm  (==> not necessary)
// (ignr) copy'n'paste ops (already possible: lshift-c on op tab)
// (done) align mute checkboxes with floatparam grid
// (done) min/max decay/release times (randomization)
// (done) op context menu (copy/paste/rand/rand_all/init)
// (done) add feedback widget (above alg grid)
// (done) copy/paste last mouse-focused Op via lshift-c/v
// (done) cycle through level delta presets with 'v'
// (done) add option to keep carrier freq at 1 during randomization
// (done) mix'n'match layered patch creator (up to 4 patch select comboboxes, copy patches on selection, level+transpose)
// (done) select fundamental/transient/harmonics/noise layers with 'p' (Cxxx, Dxxx, Exxx, Fxxx)
// (done) tab-cycle + move throw op params via cursor keys
// (done) init consecutive patch names via hold-click (basename + p1...p4)
// (done) toggle opn/opv mute mask by hold-clicking checkbox
// (done) add algorithm floatparam
// (test) highlight feedback operator in fp matrix
// (test) focus algorithm widget with lshift-a
// (test) inc/dec floatparam with cursor keys loses focus (=> send valuechanging instead of valuechanged. side effects?)
// (test) "auto-select algorithm" checkbox
// (todo) rotate op left/right

module MFMMatrix;
use namespace st2;
use namespace ui;

int debug = Configuration.debugLevel;  // 0=off, 1=sparse, 2=verbose
// debug=2;
boolean b_exact = 1;
boolean b_incremental = b_exact && 1;
boolean b_small_mat = 1;
boolean b_small_alg = 1;
boolean b_debug_perf = 0;
boolean b_autoselect_alg = 0;


// <class.png>
class FMMatrixWindowCacheEntry {
   byte     w;      // compacted algorithm matrix size
   byte     h;
   byte     alg_idx;
   byte     raw_x;  // offset into original algorithm matrix
   byte     raw_y;
   byte     raw_w;  // size of original algorithm matrix window
   byte     raw_h;
   IntArray ia_mat; // w*h ints. 0=unused, >0: relative modulator op idx, <0: relative output op idx *-1
   IntArray op_map;  // maps x pos to op idx

   // <save.png>
   public method saveState(Stream ofs) {
      ofs.i8 = w;
      ofs.i8 = h;
      ofs.i8 = alg_idx;
      ofs.i8 = raw_x;
      ofs.i8 = raw_y;
      ofs.i8 = raw_w;
      ofs.i8 = raw_h;
      int idx = 0;
      loop(w * h)
         ofs.i8 = ia_mat[idx++];
      idx = 0;
      loop(w)
         ofs.i8 = op_map[idx++];
   }

   // <load.png>
   public method loadState(Stream ifs) {
      w       = ifs.u8;
      h       = ifs.u8;
      alg_idx = ifs.u8;
      raw_x   = ifs.u8;
      raw_y   = ifs.u8;
      raw_w   = ifs.u8;
      raw_h   = ifs.u8;
      int idx = 0;
      ia_mat.empty();
      loop(w * h)
         ia_mat[idx++] = ifs.s8;
      op_map.empty();
      idx = 0;
      loop(w)
         op_map[idx++] = ifs.u8;
   }
}

// <class.png>
class FMMatrixAlg : Control {

   static int grid_w;
   static int grid_h;

   static int req_w;
   static int req_h;

   FMMatrix *parent_fm_matrix;
   Font *font;

   int grid_idx;


   // <ui_init.png>
   public method initFMMatrixAlg(FMMatrix _parentFMMatrix, int _gridIdx) {
      initControl();

      parent_fm_matrix <= _parentFMMatrix;

      setRequiredSize2f(calcSizeX(), calcSizeY());

      grid_idx = _gridIdx;

      if(b_small_alg)
      {
         grid_w = 9;
         grid_h = 14;
      }
      else
      {
         grid_w = 11;
         grid_h = 17;
      }

      grid_w *= UI.font_scaling;
      grid_h *= UI.font_scaling;

      req_w = (16*grid_w);
      req_h = ((grid_h*8)+2);

      setToolTipCaption("Algorithms\n\n (note) LMB-click selects algorithm\n (note) RMB-click or lctrl-e randomizes algorithm\n (note) wheel up/down selects algorithm +-8\n (note) wheel click selects next algorithm");
   }

   // <ui.png>
   protected virtual calcSizeX() : float {
      // return (9*parent_fm_matrix.col_spread*8);
      return req_w;
   }

   // <ui.png>
   protected virtual calcSizeY() : float {
      return req_h;
   }

   // <method_get.png>
   public method getAlgorithm() : byte {
      int algorithmCur = parent_fm_matrix.getAlgorithm();
      int algorithm = ((algorithmCur /8)*8) + grid_idx;
      return algorithm;
   }

   // <ui_render.png>
   public virtual onDraw() {

      // trace "xxx draw alg size="+getSizeString();

      int algorithmCur = parent_fm_matrix.getAlgorithm();
      // // int algorithm = ((algorithmCur/12)*12) + grid_idx;
      int algorithm = ((algorithmCur/8)*8) + grid_idx;
      String sAlg <= FMMatrix.alg_ops.get(algorithm);

      if(null == font)
      {
         if(b_small_alg)
            font <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED);
         else
            font <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED_LARGE);
      }

      float aFg     = (algorithm == algorithmCur) ? 1.0 : 0.4;
      float aBg     = (algorithm == algorithmCur) ? 1.0 : 0.1;
      float aBorder = (algorithm == algorithmCur) ? 1.0 : 0.2;
      int winBg = lnf.getColor(LookAndFeel.COLOR_WINDOW_BG);

      int c32Fg = lnf.getTintedColor(LookAndFeel.COLOR_TEXT_EDIT_FG, app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_ALG_FG_TINT));
      c32Fg = UI.MixColor32(winBg, c32Fg, aFg);

      int c32FgFb = lnf.getTintedColor(LookAndFeel.COLOR_TEXT_EDIT_FG, app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_ALG_FB_FG_TINT));
      c32FgFb = UI.MixColor32(winBg, c32FgFb, aFg);

      int c32Bg = lnf.getTintedColor(LookAndFeel.COLOR_WINDOW_BG, app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_ALG_BG_TINT));
      c32Bg = UI.MixColor32(winBg, c32Bg, aBg);
      UIRenderer.DrawFilledRectangle(0, 0, getSizeX(), getSizeY(), c32Bg);

      if(algorithm < 88)
      {
         UIRenderer.EnableBlending();

         int y = 0;
         loop(8)
         {
            int x = 0;
            loop(8 * parent_fm_matrix.col_spread)
            {
               char c = sAlg.getc(y*8*parent_fm_matrix.col_spread + x);
               // trace "xxx p=("+x+";"+y+") c="+tcchar(c);
               if(-1 == " .".indexOfChar(c, 0))
               {
                  UIRenderer.DrawText(tcchar(c & 127), font, (c >= 128)?c32FgFb:c32Fg, (c>=128)?c32FgFb:c32Fg, x*grid_w + 4, y*grid_h, 0/*availW*/, 0/*align*/);
               }
               x++;
            }
            y++;
         }

         // Draw algorithm number
         Integer io = algorithm + 1;
         UIRenderer.DrawText(io.printf("%02d"), font, c32Fg, c32Fg, size_x - 22*UI.font_scaling, 1, 0/*availW*/, 0/*align*/);

         UIRenderer.DisableBlending();

         int c32Border = UI.MixColor32(winBg, (algorithm == algorithmCur) ? #a0009f00 : #a0000000, aBorder);
         UIRenderer.DrawDefaultFlatBorderTint(0, 0, getSizeX(), getSizeY(), c32Border);
      }
   }

}


// <class.png>
class FMMatrixAlgGrid : Control {
   define int GRID_W = 4;
   define int GRID_H = 2;

   FMMatrix *parent_fm_matrix;


   // <ui_init.png>
   public method initFMMatrixAlgGrid(FMMatrix _parentFMMatrix) {
      initControl();

      parent_fm_matrix <= _parentFMMatrix;

      int gridIdx = 0;
      setLayout(SuperBorderLayout);
      loop(GRID_H)
      {
         Panel p <= Panel.New();
         loop(GRID_W)
         {
            FMMatrixAlg alg <= new FMMatrixAlg;
            alg.initFMMatrixAlg(_parentFMMatrix, gridIdx++);
            p.addLayer(deref alg, Layout.RIGHT);
         }
         addLayer(deref p, Layout.BOTTOM);
      }

      setRequiredSize2f(GRID_W*FMMatrixAlg.req_w, GRID_H*FMMatrixAlg.req_h);
   }

   // <ui_mouse.png>
   public virtual onMouse(MouseEvent _ev) : boolean {

      if(_ev.wheelUp())
      {
         parent_fm_matrix.changeAlgorithmDelta(-8);
         return true;
      }

      if(_ev.wheelDown())
      {
         parent_fm_matrix.changeAlgorithmDelta(8);
         return true;
      }

      if(_ev.middleButtonDown())
      {
         parent_fm_matrix.changeAlgorithmDelta(1);
         return true;
      }

      int algorithm;

      if(_ev.leftButtonDown())
      {
         FMMatrixAlg alg <= layerAt2f(_ev.mouse_rel_x, _ev.mouse_rel_y);
         if(alg instanceof FMMatrixAlg)
         {
            algorithm = alg.getAlgorithm();
            parent_fm_matrix.changeAlgorithmAbs(algorithm);
            redraw();
            Global.Print("Select algorithm "+(algorithm+1));
         }
         return true;
      }

      if(_ev.rightButtonDown())
      {
         parent_fm_matrix.randomizeAlgorithm();
         return true;
      }

      return Layer::onMouse(_ev);
   }

}

// <class.png>
class FMMatrixOp : Control {

   FMMatrix *parent_fm_matrix;

   EditMIDISynthFormFS1R    *parent_synth_form_fs1r;
   EditMIDISynthFormMontage *parent_synth_form_montage;

   int op_idx;

   Font *font_bold;

   Button *bt_rand_all;

   // osc:
   Button *bt_rand_osc;
   FloatParam *fp_spectral_form;
   CheckBox   *cb_key_sync;
   FloatParam *fp_band_width;  // Montage: R1/R2 res
   FloatParam *fp_skirt;

   // freq:
   Button *bt_rand_freq;
   CheckBox   *cb_fixed;
   FloatParam *fp_coarse;
   FloatParam *fp_fine;
   FloatParam *fp_detune;
   FloatParam *fp_fmt_transpose;

   // aeg:
   Button *bt_rand_aeg_level;
   FloatParam *fp_amp_vel;
   FloatParam *fp_level_1;
   FloatParam *fp_level_2;
   FloatParam *fp_level_3;
   FloatParam *fp_level_4;
   Button *bt_rand_aeg_time;
   FloatParam *fp_time_1;
   FloatParam *fp_time_2;
   FloatParam *fp_time_3;
   FloatParam *fp_time_4;

   Layer *[] all_widgets;

   static StringArray alias_ids_osc = [
      "spectral_form",
      "keysync",
      "frmt_bw",
      "frmt_skirt"
                                       ];
   static StringArray alias_ids_freq = [
      "mode",
      "freq_coarse",
      "freq_fine",
      "detune",
      "fmt_transpose"
                                       ];
   static StringArray alias_ids_peg = [
      "feg_init_val",
      "feg_atk_val",
      "feg_atk_time",
      "feg_dcy_time"
                                       ];
   static StringArray alias_ids_aeg_level = [
      "amp_vel_sense",
      "eg_l1",
      "eg_l2",
      "eg_l3",
      "eg_l4",
                                       ];
   static StringArray alias_ids_aeg_time = [
      "eg_t1",
      "eg_t2",
      "eg_t3",
      "eg_t4"
                                       ];

   protected PopupMenu *pm_context;


   // <method_new.png>
   protected method newFP(int _min, int _max, String _toolTipCaption, String _aliasId) : FloatParam {
      FloatParam fp <= FloatParam.New();
      fp.setPadding4f(1,0,0,1);
      fp.setStepFine(1);
      fp.setStepCoarse(1);
      fp.setMinMaxValues(_min, _max);
      fp.setPrecision(0);
      fp.setMousePrecision(0);
      fp.setEnableBorders(false);
      fp.setValue(0);
      fp.setVisibleTextLength(2);
      fp.setRequiredSize2fScaled(23, 17);
      fp.setToolTipCaption(_toolTipCaption);
      fp.setAlignment(Layout.CENTERY);
      fp.setUserData(deref _aliasId);
      all_widgets.add(fp);
      addLayer(fp, Layout.RIGHT);
      return deref fp;
   }

   // <method_new.png>
   protected method newCB(String _toolTipCaption, String _aliasId) : CheckBox {
      CheckBox cb <= CheckBox.New(false/*bSelected*/, "");
      cb.setCaption("");
      cb.setPadding4f(0,0,0,0);
      cb.setEnableKbdFocusOnMouse(false);
      cb.setToolTipCaption(_toolTipCaption);
      // cb.setRequiredSize2f(23, 21);
      cb.setAlignment(Layout.CENTERY);
      cb.setUserData(deref _aliasId);
      all_widgets.add(cb);
      addLayer(cb, Layout.RIGHT);
      return deref cb;
   }

   // <method_new.png>
   protected method newLB(String _caption) : Label {
      Label lb <= Label.New();
      lb.setCaption(_caption);
      lb.setPadding4f(0,6,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.LEFT | Layout.CENTERY);
      lb.setAlignment(Layout.CENTERY);
      addLayer(deref lb, Layout.RIGHT);
      return lb;
   }

   // <method_new.png>
   protected method newLBt(String _caption) : Button {
      Button bt <= Button.New();
      bt.setEnableLabelButton(true);
      bt.setCaption(_caption);
      bt.setPadding4f(0,2,0,0);
      bt.setInnerPadding4f(0,0,0,0);
      bt.setTextPlacement(Layout.LEFT | Layout.CENTERY);
      bt.setAlignment(Layout.CENTERY);
      addLayer(deref bt, Layout.RIGHT);
      return bt;
   }

   // <ui_init.png>
   public method initFMMatrixOp(int _opIdx, FMMatrix _parentFMMatrix) {

      initControl();
      setLayout(SuperBorderLayout);

      parent_fm_matrix <= _parentFMMatrix;

      parent_synth_form_fs1r    <= parent_fm_matrix.parent_synth_form_fs1r;
      parent_synth_form_montage <= parent_fm_matrix.parent_synth_form_montage;

      boolean bFS1R = (null != parent_synth_form_fs1r);

      op_idx = _opIdx;
      int opNr = op_idx + 1;
      local String sOp <= "Op "+opNr+"  ";
      local String id <= "d_op"+opNr+"v_";

      bt_rand_all <= newLBt(opNr+":");
      bt_rand_all.setToolTipCaption("LMB-click selects operator\n\nLMB-hold-click randomizes all Op "+opNr+" parameter sets\n\n (note) lctrl-LMB-hold-click to allow fixed/ratio mode and attack level/time randomization\n\n (note) RMB-click shows Op context menu\n\n (note) hold lctrl while editing param to randomize it");
      bt_rand_all.setEnableHold(true);
      font_bold <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL_BOLD);
      // trace "xxx lb="+#(lb)+" fontBold="+#(fontBold);
      bt_rand_all.setFont(font_bold);
      if(op_idx < 4)
         bt_rand_all.setPadding4f(0,0,2,0);
      else
         bt_rand_all.setPadding4f(0,6,2,0);
      bt_rand_all.setAlignment(Layout.BASELINE);

      // osc:
      bt_rand_osc <= newLBt("O");
      bt_rand_osc.setToolTipCaption("Randomize Op "+opNr+" oscillator parameters");
      bt_rand_osc.setAlignment(Layout.BASELINE);

      fp_spectral_form <= newFP(0, bFS1R?7:6, sOp+"Spectral Form", id+"spectral_form");
      fp_spectral_form.setDisplayType(FloatParam.DISPLAY_USER);
      if(bFS1R)
         fp_spectral_form.setUserTable(["Sin", "A1", "A2", "O1", "O2", "R1", "R2", "For"]);
      else
         fp_spectral_form.setUserTable(["Sin", "A1", "A2", "O1", "O2", "R1", "R2"]);
      fp_spectral_form.setValue(0);
      fp_spectral_form.setStepCoarse(-1);  // invert mousewheel to resemble ComboBox behaviour
      if(bFS1R)
         fp_spectral_form.setPresetOptions([0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f],
                                           ["Sine", "All 1", "All 2", "Odd 1", "Odd 2", "Res 1", "Res 2", "Formant"]
                                           );
      else
         fp_spectral_form.setPresetOptions([0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f],
                                           ["Sine", "All 1", "All 2", "Odd 1", "Odd 2", "Res 1", "Res 2"]
                                           );
      fp_spectral_form.setAlignment(Layout.BASELINE);

      cb_key_sync <= newCB(sOp+"Key Sync", id+"keysync");
      cb_key_sync.setAlignment(Layout.BASELINE);

      if(bFS1R)
         fp_band_width <= newFP(0, 99, sOp+"Spectral Bandwidth", id+"frmt_bw");
      else
         fp_band_width <= newFP(0, 99, sOp+"R1/R2 Resonance", id+"frmt_bw");
      // // fp_band_width.setEditable(bFS1R);
      fp_band_width.setAlignment(Layout.BASELINE);

      fp_skirt <= newFP(0, 7, sOp+"Spectral Skirt", id+"frmt_skirt");
      fp_skirt.setAlignment(Layout.BASELINE);

      // freq:
      bt_rand_freq <= newLBt("F");
      bt_rand_freq.setEnableHold(true);
      bt_rand_freq.setToolTipCaption("Randomize Op "+opNr+" frequency parameters\n\n (note) hold-click to allow fixed/ratio mode randomization");
      bt_rand_freq.setPadRight(UI.IsHiDPI() ? 2 : 1);
      bt_rand_freq.setAlignment(Layout.BASELINE);

      cb_fixed <= newCB(sOp+"Fixed Frequency", id+"mode");
      cb_fixed.setAlignment(Layout.BASELINE);

      fp_coarse <= newFP(0, 31, sOp+"Coarse Tune", id+"freq_coarse");
      fp_coarse.setAlignment(Layout.BASELINE);

      fp_fine <= newFP(0, 99, sOp+"Fine Tune (ratio *1..*1.99)", id+"freq_fine");
      fp_fine.setAlignment(Layout.BASELINE);

      fp_detune <= newFP(-15, 15, sOp+"Detune", id+"detune");
      fp_detune.setAlignment(Layout.BASELINE);

      fp_fmt_transpose <= newFP(0, 48, sOp+"Formant Transpose", id+"fmt_transpose");
      fp_fmt_transpose.setEditable(bFS1R);
      fp_fmt_transpose.setAlignment(Layout.BASELINE);

      // aeg:
      bt_rand_aeg_level <= newLBt("L");
      bt_rand_aeg_level.setEnableHold(true);
      bt_rand_aeg_level.setToolTipCaption("Randomize Op "+opNr+" AEG level parameters\n\n (note) hold-click to allow attack level randomization");
      bt_rand_aeg_level.setAlignment(Layout.BASELINE);

      fp_amp_vel <= newFP(-7, 7, sOp+"Amp Velocity Sensitivity", id+"amp_vel_sense");
      fp_amp_vel.setAlignment(Layout.BASELINE);
      fp_amp_vel.setResetValues([0.0f, 7.0f, -7.0f]);

      fp_level_1 <= newFP(0, 99, sOp+"AEG Level 1", id+"eg_l1");
      fp_level_1.setResetValues([99.0f, 0.0f]);
      fp_level_2 <= newFP(0, 99, sOp+"AEG Level 2", id+"eg_l2");
      fp_level_2.setResetValues([99.0f, 0.0f]);
      fp_level_3 <= newFP(0, 99, sOp+"AEG Level 3", id+"eg_l3");
      fp_level_3.setResetValues([0.0f, 99.0f]);
      fp_level_4 <= newFP(0, 99, sOp+"AEG Level 4", id+"eg_l4");
      fp_level_1.setAlignment(Layout.BASELINE);
      fp_level_2.setAlignment(Layout.BASELINE);
      fp_level_3.setAlignment(Layout.BASELINE);
      fp_level_4.setAlignment(Layout.BASELINE);

      bt_rand_aeg_time <= newLBt("T");
      bt_rand_aeg_time.setEnableHold(true);
      bt_rand_aeg_time.setToolTipCaption("Randomize Op "+opNr+" AEG level parameters\n\n (note) hold-click to allow attack time randomization");
      bt_rand_aeg_time.setBackgroundTint(#24ff8d00);
      bt_rand_aeg_time.setAlignment(Layout.BASELINE);

      fp_time_1 <= newFP(0, 99, sOp+"AEG Time 1", id+"eg_t1");
      fp_time_1.setResetValues([0.0f, 50.0f, 99.0f]);
      fp_time_2 <= newFP(0, 99, sOp+"AEG Time 2", id+"eg_t2");
      fp_time_2.setResetValues([0.0f, 50.0f, 99.0f]);
      fp_time_3 <= newFP(0, 99, sOp+"AEG Time 3", id+"eg_t3");
      fp_time_3.setResetValues([0.0f, 50.0f, 99.0f]);
      fp_time_4 <= newFP(0, 99, sOp+"AEG Time 4", id+"eg_t4");
      fp_time_4.setResetValues([0.0f, 50.0f, 99.0f]);
      fp_time_1.setAlignment(Layout.BASELINE);
      fp_time_2.setAlignment(Layout.BASELINE);
      fp_time_3.setAlignment(Layout.BASELINE);
      fp_time_4.setAlignment(Layout.BASELINE);
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray layers) {
      layers.add(bt_rand_all);
      layers.joinRR(layers, all_widgets);
   }

   // <ui_update.png>
   public method setCurrentOpFlag(boolean _bCurrent) {
      int c32Cur = _bCurrent ? #2000ff00 : 0;
      bt_rand_all.setBackgroundTint(c32Cur);
      bt_rand_all.redraw();
   }

   // <ui_update.png>
   public method updateFromPatch() {
      Layer      *l;
      Layer      *lEditor;
      FloatParam *fp;
      FloatParam *fpEditor;
      CheckBox   *cb;
      CheckBox   *cbEditor;
      ComboBox   *cmEditor;

      if(null != parent_synth_form_montage)
      {
         foreach l in all_widgets
         {
            byte c = parent_fm_matrix.getValueById(l.getUserData());
            if(l instanceof FloatParam)
            {
               fp <= l;
               // trace "xxx ud="+l.getUserData()+" c="+c+" minVal="+fp.getMinValue();
               fp.setValue(c);
            }
            else if(l instanceof CheckBox)
            {
               cb <= l;
               cb.setSelected(c);
            }
         }
      }
      else
      {
         foreach l in all_widgets
         {
            lEditor <= parent_fm_matrix.findParamWidgetByAliasId(l.getUserData());

            // trace "xxx l="+#(l)+" lEditor="+#(lEditor)+" aliasId="+l.getUserData();

            if(l instanceof FloatParam)
            {
               fp <= l;
               if(lEditor instanceof FloatParam)
               {
                  fpEditor <= lEditor;
                  fp.setValue(fpEditor.getFloatValue());
               }
               else if(lEditor instanceof ComboBox)
               {
                  cmEditor <= lEditor;
                  fp.setValue(cmEditor.getSelectedOption());
               }
            }
            else if(l instanceof CheckBox)
            {
               cb <= l;

               if(lEditor instanceof CheckBox)
               {
                  cbEditor <= lEditor;
                  cb.setSelected(cbEditor.isSelected());
               }
               else if(lEditor instanceof ComboBox)
               {
                  cmEditor <= lEditor;
                  cb.setSelected(cmEditor.getSelectedOption());
               }
            }
         }
      }

   }

   // <method_get.png>
   public method isCarrier() : boolean {
      String sMat <= parent_fm_matrix.getAlgorithmMatrix();
      return ('.' != sMat[op_idx*8+op_idx]);
   }

   // <method_find.png>
   public method findOpParamWidgetByAliasId(String _id) : Layer {
      // called by Montage editor
      byte r = 0;
      Layer *l;
      foreach l in all_widgets
      {
         if(l.getUserData() == _id)
            return l;
      }
      return null;
   }

   // <method.png>
   protected method randWidget(String _id, int _overrideMin, int _overrideMax) : byte {
      int r = -999999;

      Layer *lEditor;
      if(null != parent_synth_form_montage)
         lEditor <= findOpParamWidgetByAliasId(_id);
      else
         lEditor <= parent_fm_matrix.findParamWidgetByAliasId(_id);

      int overrideMin = mathMini(_overrideMin, _overrideMax);
      int overrideMax = mathMaxi(_overrideMin, _overrideMax);
      if(lEditor instanceof FloatParam)
      {
         FloatParam fp <= lEditor;
         if(-100 == _overrideMin)  // use full param range ?
            r = fp.getMinValue() + rand(int(fp.getMaxValue() - fp.getMinValue() + 1));
         else
            r = overrideMin + rand(overrideMax - overrideMin + 1);
         fp.setValue(r);
      }
      else if(lEditor instanceof CheckBox)
      {
         CheckBox cb <= lEditor;
         r = rand(2);
         cb.setSelected(r);
      }
      else if(lEditor instanceof ComboBox)
      {
         ComboBox cm <= lEditor;
         r = rand(cm.getOptions().getNumElements());
         cm.setSelectedOption(r);
      }

      if(r > -999999)
      {
         if(null != parent_synth_form_fs1r)
         {
            parent_fm_matrix.handleParamWidgetChanged(lEditor, false/*bUpdateFMMatrix*/, true/*bQuiet*/);
         }
         else
         {
            parent_fm_matrix.editOpByAliasId(_id, r);
         }
      }

      return r;
   }

   // <ui_handle.png>
   public method handleRandOsc() {
      local String id <= "d_op"+(op_idx+1)+"v_";
      String *aliasId;
      foreach aliasId in alias_ids_osc
         randWidget(id+aliasId, -100, 0);
      updateFromPatch();
      Global.Print("Randomize Op "+(op_idx+1)+" oscillator parameters");
   }

   // <ui_handle.png>
   public method handleRandFreq(boolean _bAllowFixed) {
      local String id <= "d_op"+(op_idx+1)+"v_";
      String *aliasId;
      int fMin = parent_fm_matrix.fp_freq_min.getFloatValue();
      int fMax = parent_fm_matrix.fp_freq_max.getFloatValue();
      boolean bCarrier1 = (parent_fm_matrix.cb_freq_carrier1.isSelected()) && isCarrier();
      foreach aliasId in alias_ids_freq
      {
         if(_bAllowFixed || ("mode" != aliasId))
         {
            if("freq_coarse" == aliasId)
            {
               if(bCarrier1)
                  randWidget(id+aliasId, 1, 1);
               else
                  randWidget(id+aliasId, fMin, fMax);
            }
            else if("freq_fine" == aliasId)
            {
               if(bCarrier1)
               {
                  randWidget(id+aliasId, 0, 0);  // force fine tune 0
               }
               else if(parent_fm_matrix.cb_freq_fine.isSelected())
               {
                  randWidget(id+aliasId, -100, 0);
               }
               else
               {
                  // skip / keep
               }
            }
            else
            {
               randWidget(id+aliasId, -100, 0);
            }
         }
      }
      updateFromPatch();
      Global.Print("Randomize Op "+(op_idx+1)+" frequency parameters ("+(_bAllowFixed?"allow":"skip")+" fixed/ratio mode changes)");
   }

   // <ui_handle.png>
   public method handleRandAEGLevel(boolean _bAllowAttack) {
      local String id <= "d_op"+(op_idx+1)+"v_";
      String *aliasId;
      boolean bL3Less = parent_fm_matrix.cb_aeg_l3less.isSelected();
      byte l2Lvl;
      foreach aliasId in alias_ids_aeg_level
      {
         if(bL3Less && ("eg_l3" == aliasId))
         {
            byte l3Lvl = randWidget(id+aliasId, 0, l2Lvl);
            // trace "xxx l3less: l2Lvl="+l2Lvl+" l3Lvl="+l3Lvl;
         }
         else if(_bAllowAttack || (("eg_l1" != aliasId) && ("eg_l4" != aliasId)))
         {
            byte r = randWidget(id+aliasId, -100, 0);
            if("eg_l2" == aliasId)
               l2Lvl = r;
         }
      }
      updateFromPatch();
      Global.Print("Randomize Op "+(op_idx+1)+" AEG level parameters ("+(_bAllowAttack?"allow":"skip")+" attack level changes)");
   }

   // <ui_handle.png>
   public method handleRandAEGTime(boolean _bAllowAttack) {
      local String id <= "d_op"+(op_idx+1)+"v_";
      int tMin = parent_fm_matrix.fp_aeg_tmin.getFloatValue();
      int tMax = parent_fm_matrix.fp_aeg_tmax.getFloatValue();
      String *aliasId;
      foreach aliasId in alias_ids_aeg_time
      {
         if(_bAllowAttack || ("eg_t1" != aliasId))
            randWidget(id+aliasId, tMin, tMax);
      }
      updateFromPatch();
      Global.Print("Randomize Op "+(op_idx+1)+" AEG level parameters ("+(_bAllowAttack?"allow":"skip")+" attack time changes)");
   }

   // <ui_handle.png>
   public method handleRand(boolean _bAllowFixedAndAttack) {
      int mask = parent_fm_matrix.getSelectedOpParameterSetMask();

      if(mask & EditMIDISynthFormFS1R.PARAMSET_OP_OSC)
         handleRandOsc();

      if(mask & EditMIDISynthFormFS1R.PARAMSET_OP_FREQ)
         handleRandFreq(_bAllowFixedAndAttack/*bAllowFixed*/);

      if(mask & EditMIDISynthFormFS1R.PARAMSET_OP_AEG_LEVEL)
         handleRandAEGLevel(_bAllowFixedAndAttack/*bAllowAttack*/);

      if(mask & EditMIDISynthFormFS1R.PARAMSET_OP_AEG_TIME)
         handleRandAEGTime(_bAllowFixedAndAttack/*bAllowAttack*/);

      Global.Print("Randomize all Op "+(op_idx+1)+" parameters ("+(_bAllowFixedAndAttack?"allow":"skip")+" fixed/ratio mode and attack time/level changes)");
   }

   // <ui_handle.png>
   public method handleCopy() {
      if(null != parent_synth_form_fs1r)
         parent_synth_form_fs1r.copyOpVToClipboard(op_idx);
      else if(null != parent_synth_form_montage)
         parent_synth_form_montage.copyOpVToClipboard(op_idx);
   }

   // <ui_handle.png>
   public method handlePaste() {
      if(null != parent_synth_form_fs1r)
         parent_synth_form_fs1r.pasteOpVClipboard(op_idx);
      else if(null != parent_synth_form_montage)
         parent_synth_form_montage.pasteOpVClipboard(op_idx);
      updateFromPatch();
   }

   // <method_get.png>
   public method getMontageOp(): MontagePartFMOperator {
      return parent_synth_form_montage.getOpByIdx(op_idx);
   }

   // <method_set.png>
   public method setValueById(String _aliasId, byte _val) {
      Layer *lEditor;
      FloatParam *fpEditor;
      CheckBox *cbEditor;
      ComboBox *cmEditor;

      lEditor <= parent_fm_matrix.findParamWidgetByAliasId(_aliasId);
      if(lEditor instanceof FloatParam)
      {
         fpEditor <= lEditor;
         fpEditor.setValue(_val);
      }
      else if(lEditor instanceof CheckBox)
      {
         cbEditor <= lEditor;
         cbEditor.setSelected(_val);
      }
      else if(lEditor instanceof ComboBox)
      {
         cmEditor <= lEditor;
         cmEditor.setSelectedOption(_val);
      }

      parent_fm_matrix.handleParamWidgetChanged(lEditor, false/*bUpdateFMMatrix*/, true/*bQuiet*/);
   }

   // <ui_handle.png>
   public method handleInit() {
      local String id <= "d_op"+(op_idx+1)+"v_";

      // osc:
      setValueById(id + "spectral_form", 0);
      setValueById(id + "keysync", 1);
      setValueById(id + "frmt_bw", 10);
      setValueById(id + "frmt_skirt", 7);

      // freq:
      setValueById(id + "mode", 0);
      setValueById(id + "freq_coarse", 1);
      setValueById(id + "freq_fine", 0);
      setValueById(id + "freq_detune", 0);
      setValueById(id + "fmt_transpose", 12);

      // peg:
      setValueById(id + "feg_init_val", 0);
      setValueById(id + "feg_atk_val",  0);
      setValueById(id + "feg_atk_time", 0);
      setValueById(id + "feg_dcy_time", 0);

      // aeg_level:
      setValueById(id + "amp_vel_sense", 0);
      setValueById(id + "eg_l1", 99);
      setValueById(id + "eg_l2", 79);
      setValueById(id + "eg_l3", 69);
      setValueById(id + "eg_l4",  0);

      // aeg_time:
      setValueById(id + "eg_t1", 1);
      setValueById(id + "eg_t2", 60);
      setValueById(id + "eg_t3", 50);
      setValueById(id + "eg_t4", 45);

      updateFromPatch();

      Global.Print("Initialize Op "+(op_idx+1));
   }

   // <method.png>
   public method saveOpToPreset(FMMatrix_OpPreset_Op _op) {
      _op.shape         = fp_spectral_form.getFloatValue();
      _op.b_keysync     = cb_key_sync.isSelected();
      _op.skirt         = fp_skirt.getFloatValue();
      _op.res           = fp_band_width.getFloatValue();
      _op.level         = parent_fm_matrix.getOpLevel(op_idx);
      _op.b_fixed_ratio = cb_fixed.isSelected();
      _op.freq_coarse   = fp_coarse.getFloatValue();
      _op.freq_fine     = fp_fine.getFloatValue();
      _op.detune        = fp_detune.getFloatValue();
      _op.detune        = fp_detune.getFloatValue();
      _op.fmt_transpose = fp_fmt_transpose.getFloatValue();

      // AEG scl:
      _op.aeg_l_1 = fp_level_1.getFloatValue();
      _op.aeg_l_2 = fp_level_2.getFloatValue();
      _op.aeg_l_3 = fp_level_3.getFloatValue();
      _op.aeg_l_4 = fp_level_4.getFloatValue();

      _op.aeg_t_1 = fp_time_1.getFloatValue();
      _op.aeg_t_2 = fp_time_2.getFloatValue();
      _op.aeg_t_3 = fp_time_3.getFloatValue();
      _op.aeg_t_4 = fp_time_4.getFloatValue();
   }

   // <ui_focus.png>
   public method refocusDefault() {
      UI.SetKeyboardFocus(this);
   }

   // <ui_show.png>
   protected method showContextMenu() {

      pm_context <= PopupMenu.New(this);
      PopupMenuButton *pmb;
      PopupMenu pm <= pm_context;

      pmb <= pm.addDefaultButton("Copy", "copy");
      pmb.setToolTipCaption("Copy Op to clipboard\n\n (note) lshift-c when Op tab is selected\n\n (note) OR lshift-c when mouse is over Op param row");
      // pmb.setAccelerators("lctrl-n", "");

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Paste", "paste");
      pmb.setToolTipCaption("Paste clipboard to Op\n\n (note) lshift-v when Op tab is selected\n\n (note) OR lshift-c when mouse is over Op param row");
      // pmb.setAccelerators("lctrl-n", "");

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Init", "init");
      // pmb.setAccelerators("lctrl-n", "");
      pmb.setToolTipCaption("Initialize / Reset all Op parameters\n\n (note) lshift-x when mouse is over Op param row");

      pm.addSeparator();
      pmb <= pm.addDefaultButton("Rand", "rand");
      // pmb.setAccelerators("lctrl-n", "");
      pmb.setToolTipCaption("Randomize all Op parameters but skip fixed/ratio mode and attack time/level\n\n (note) can also click Op nr LabelButton");

      pmb <= pm.addDefaultButton("Rand All", "rand_all");
      // pmb.setAccelerators("lctrl-n", "");
      pmb.setToolTipCaption("Randomize all Op parameters, including fixed/ratio mode and attack time/level\n\n (note) can also hold-click Op nr LabelButton");

      pm.resizeToMinimum();
      pm.showNearMouse(-30, 0);

      Global.Print("Show Op"+(op_idx+1)+" context menu.");
   }

   // <ui_mouse.png>
   public virtual onMouseClick(MouseEvent _ev) : boolean {
      if(_ev.isRightButton())
      {
         parent_fm_matrix.setCurrentOpIdx(op_idx);
         showContextMenu();
         return true;
      }
      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      parent_fm_matrix.setCurrentOpIdx(op_idx);

      if(parent_fm_matrix.handleMultiEditOpParam(this, ap))
      {
         if( (ap instanceof FloatParam) && (FloatParam.ACTION_VALUECHANGED == acName) )
            parent_fm_matrix.refocusDefault();
         return true;
      }

      switch(@(ap))
      {
         case @(pm_context):
            Global.Debug2("FMMatrixOp: pm_context acName="+acName);
            switch(acName)
            {
               case PopupMenu.ACTION_CANCEL:
               case "":
                  Global.Print("Close context menu.");
                  refocusDefault();
                  return true;

               default:
                  Global.Print("Select: "+acName);
                  return true;

               case "copy":
                  handleCopy();
                  refocusDefault();
                  return true;

               case "paste":
                  parent_fm_matrix.handleMultiEditPaste(this);
                  refocusDefault();
                  return true;

               case "rand":
                  parent_fm_matrix.handleMultiEditRand(this, false/*bAllowFixedAndAttack*/);
                  return true;

               case "rand_all":
                  parent_fm_matrix.handleMultiEditRand(this, true/*bAllowFixedAndAttack*/);
                  return true;

               case "init":
                  parent_fm_matrix.handleMultiEditInit(this);
                  return true;
            }
            return true;

         case @(bt_rand_all):
            if(Button.ACTION_HOLD_CLICK == acName)
               parent_fm_matrix.handleMultiEditRand(this, (VMOD_LCTRL == UI.GetKeyMod())/*bAllowFixedAndAttack*/);
            else
               parent_fm_matrix.setCurrentOpIdx(op_idx);
            return true;

         case @(bt_rand_osc):
            parent_fm_matrix.handleMultiEditRandOsc(this);
            return true;

         case @(bt_rand_freq):
            parent_fm_matrix.handleMultiEditRandFreq(this, (Button.ACTION_HOLD_CLICK == acName)/*bAllowFixed*/);
            return true;

         case @(bt_rand_aeg_level):
            parent_fm_matrix.handleMultiEditRandAEGLevel(this, (Button.ACTION_HOLD_CLICK == acName)/*bAllowAttack*/);
            return true;

         case @(bt_rand_aeg_time):
            parent_fm_matrix.handleMultiEditRandAEGTime(this, (Button.ACTION_HOLD_CLICK == acName)/*bAllowAttack*/);
            return true;
      }

      return false;
   }

}


// <class.png>
class FMMatrix : Control, Montage_EGPresetListener {

   define String TA_SORT;
   protected TimerAction *ta_sort;

   define String TA_MATPOSSIBLE;
   protected TimerAction *ta_matpossible;

   define String TA_UPDATEALL;
   protected TimerAction *ta_updateall;

   define String TA_UPDATEMUTE;
   protected TimerAction *ta_updatemute;  // periodic

   int col_spread = 3;

   StringArray *alg_matrices;  // see Yamaha8OpFM.tks

   static StringArray alg_ops;

   static FMMatrixWindowCacheEntry *[] alg_window_cache;

   FloatParam *[] fp_matrix;

   FloatParam      *fp_alg;
   CheckBox        *cb_autoalg;
   FloatParam      *fp_fb;
   Button *[]       part_buttons;
   FMMatrixAlgGrid *fm_matrix_alg_grid;
   ComboBox        *cm_var;  // Montage only

   FMMatrixOp *[] op_controls;

   int current_op_idx;  // last selected/edited op idx

   FloatArray fa_matrix;  // values 0..127
   IntArray   op_map_fp_to_op;
   IntArray   op_map_op_to_fp;

   Button *bt_op_cycle_left;
   Button *bt_op_cycle_right;

   FloatParam *fp_op_preset_type;
   ComboField *cf_op_preset;
   StringArray op_preset_names;
   CheckBox   *cb_op_preset_autoload;

   Button *bt_rand_op;
   Button *bt_rand_op_gz;
   Button *bt_cycle;
   Button *bt_reset;

   Label *[] top_labels;
   Label *[] left_labels;

   SizeGroupX   *sgx_op_mute;
   Button       *bt_opv_mute;
   CheckBox *[]  opv_mute_checkboxes;
   Button       *bt_opn_mute;
   CheckBox *[]  opn_mute_checkboxes;

   FloatParam *fp_lvl_delta;
   CheckBox   *cb_multiedit;

   Button     *bt_op_cycle;
   Button     *bt_op_shuffle;
   CheckBox   *cb_sel_osc;
   CheckBox   *cb_sel_freq;
   CheckBox   *cb_sel_aeg;
   CheckBox   *cb_sel_peg;
   CheckBox   *cb_sel_levelscl;
   CheckBox   *cb_sel_sense;
   FloatParam *fp_freq_min;
   FloatParam *fp_freq_max;
   CheckBox   *cb_freq_fine;
   CheckBox   *cb_freq_carrier1;
   FloatParam *fp_aeg_tmin;
   FloatParam *fp_aeg_tmax;
   CheckBox   *cb_aeg_l3less;

   FloatParam *fp_aeg_scl;
   FloatParam *fp_aeg_scl_exp;
   FMMatrix_OpPreset_Op *[] aeg_scl_ops;  // original Op state when aeg_scl editing starts

   EditMIDISynthFormFS1R    *parent_synth_form_fs1r;
   EditMIDISynthFormMontage *parent_synth_form_montage;

   Font *font;
   Font *font_fixed;

   boolean b_zero_valid = 1;  // set possible (valid) but currently unused routings to 0

   String  s_mat_possible_fast;
   String  s_mat_used;
   String  s_mat_possible_exact;
   int     mat_possible_idx;
   boolean b_mat_possible_exact_valid;

   boolean b_queued_sort_pending;
   boolean b_updatefrompatchdata_editor_pending;

   ComboBox *[] cm_mix_parts;
   FloatParam *[] fp_mix_parts_level;
   FloatParam *[] fp_mix_parts_noteshift;


   // <method_init.png>
   public method initFMMatrix(EditMIDISynthFormFS1R    _parentSynthFormFS1R,
                              EditMIDISynthFormMontage _parentSynthFormMontage
                              ) {
      initControl();

      parent_synth_form_fs1r    <= _parentSynthFormFS1R;
      parent_synth_form_montage <= _parentSynthFormMontage;

      alg_matrices <= Yamaha8OpFM.alg_matrices;

      if(1)
      {
         // Yamaha8OpFM.SanitizeOutputModulators();
         // e.g. "mm." => "m.."
         //      " m8"    " m8"
         String *sMat;
         foreach sMat in alg_matrices
         {
            int opIdx = 0;
            loop(8)
            {
               if('m' == sMat.getc(8*opIdx + opIdx))
                  sMat[8*opIdx + opIdx] = '.';
               opIdx++;
            }
         }
      }

      if(0 == alg_window_cache.numElements)
      {
         int tStart;
         int tDelta;

         local String pathName = Utils.ToNativePathName(STConfig.rootpath+"/fm8_matrix_cache.dat");

         tStart = milliSeconds();
         if(!loadAlgWindowCache(pathName))
         {
            buildAlgWindowCache();
            tDelta = milliSeconds() - tStart;
            trace "[dbg] FMMatrix::initFMMatrix: buildAlgWindowCache() took "+tDelta+" ms";
            saveAlgWindowCache(pathName);
         }
         else
         {
            tDelta = milliSeconds() - tStart;
            if(STConfig.b_debug_profile)
               trace "[pro] FMMatrix::initFMMatrix: loadAlgWindowCache() took "+tDelta+" ms";
         }

         calcAlgOps();
         sanitizeAlgOps();
         calcAllMatMask();
      }

      fa_matrix.allocAndFill(8*8, 0);
      op_map_fp_to_op.identity(8);
      op_map_op_to_fp.identity(8);
      calcOpMapOpToFP();

      initWidgets();
      initTimers();
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_sort        <= TimerAction.New(TA_SORT,        this, 2300);
      ta_matpossible <= TimerAction.New(TA_MATPOSSIBLE, this, 1);
      ta_updateall   <= TimerAction.New(TA_UPDATEALL,   this, 500);
      ta_updatemute  <= TimerAction.New(TA_UPDATEMUTE,  this, 300);
   }

   // <method.png>
   public method enter() {
      // called when synth editor page is entered
      ta_updatemute.reschedule();
      updateMixPartPatches(true/*bUpdatePatchNr*/);
      updateCurrentOpFlags();
      FMMatrix_OpPreset.LoadPresets();
      updateOpPresetOptions();
   }

   // <method.png>
   public method setVisible(boolean _bVisible) {
      // called when tab becomes (in-)visible
      if(_bVisible)
      {
         UI.SetKeyboardFocus(this);
         updateMixPartPatches(false/*bUpdatePatchNr*/);
      }
      // // refocusDefault();
   }

   // <method.png>
   public method leave() {
      ta_sort.cancel();
      ta_matpossible.cancel();
      ta_updateall.cancel();
      ta_updatemute.cancel();
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray layers) {

      layers.joinRR(layers,
                    [
                       bt_rand_op,
                       bt_rand_op_gz,
                       bt_cycle,
                       bt_reset,

                       fp_alg,
                       cb_autoalg,
                       fp_fb,
                       part_buttons.get(0),
                       part_buttons.get(1),
                       part_buttons.get(2),
                       part_buttons.get(3),
                       ]
                    );

      if(null != parent_synth_form_montage)
         layers.add(cm_var);

      layers.joinRR(layers, fp_matrix);

      layers.joinRR(layers,
                    [
                       fp_lvl_delta,
                       cb_multiedit,

                       bt_op_cycle_left,
                       bt_op_cycle_right,

                       bt_op_cycle,
                       bt_op_shuffle,
                       cb_sel_osc,
                       cb_sel_freq,
                       cb_sel_aeg,
                       cb_sel_peg,
                       cb_sel_levelscl,
                       cb_sel_sense,
                       fp_freq_min,
                       fp_freq_max,
                       cb_freq_fine,
                       cb_freq_carrier1,
                       fp_aeg_tmin,
                       fp_aeg_tmax,
                       cb_aeg_l3less
                     ]
                    );

      FMMatrixOp *op;
      foreach op in op_controls
         op.addTabCycleOverrides(layers);

      int mixPartIdx = 0;
      loop(4)
      {
         layers.add(cm_mix_parts[mixPartIdx]);
         layers.add(fp_mix_parts_level[mixPartIdx]);
         layers.add(fp_mix_parts_noteshift[mixPartIdx]);
         mixPartIdx++;
      }
   }

   // <ui_update.png>
   public method updateCurrentOpFlags() {
      FMMatrixOp *op;
      int opIdx = 0;
      foreach op in op_controls
      {
         op.setCurrentOpFlag(opIdx == current_op_idx);
         opIdx++;
      }
   }

   // <method_set.png>
   public method setCurrentOpIdx(int _opIdx) {
      if(_opIdx != current_op_idx)
      {
         current_op_idx = _opIdx;
         updateCurrentOpFlags();
         redraw();
      }
   }

   // <ui_update.png>
   protected method updateOpPresetOptions() {
      int numOps = fp_op_preset_type.getFloatValue();
      op_preset_names.empty();
      FMMatrix_OpPreset.FilterPresetsByNumOps(numOps, op_preset_names);
      cf_op_preset.setOptionsSorted(op_preset_names);
   }

   // <ui_handle.png>
   protected method handleOpPresetTypeChanged() {
      updateOpPresetOptions();
      cf_op_preset.setSelectedOption(0);
      Global.Print("Op Preset type is <"+fp_op_preset_type.getFloatValue()+" ops>");
   }

   // <ui_handle.png>
   protected method handleOpPresetChanged() {
      FMMatrix_OpPreset p <= FMMatrix_OpPreset.FindPresetByNameAndNumOps(cf_op_preset.getSelectedOptionName(), fp_op_preset_type.getFloatValue());
      if(null != p)
      {
         int opIdxRel = 0;
         int currentOpIdxOrig = current_op_idx;
         int opIdx = current_op_idx;
         int numOps = p.getNumOps();
         loop(numOps)
         {
            FMMatrix_OpPreset_Op op <= p.getOpByIdx(opIdxRel++);
            FMMatrixOp fOp <= op_controls.get(opIdx);
            local String id <= "d_op"+(opIdx+1)+"v_";

            editOpByAliasId(id+"spectral_form", op.shape);
            editOpByAliasId(id+"keysync",       op.b_keysync);
            editOpByAliasId(id+"frmt_skirt",    op.skirt);
            editOpByAliasId(id+"frmt_bw",       op.res);
            editOpByAliasId(id+"mode",          op.b_fixed_ratio);
            editOpByAliasId(id+"freq_coarse",   op.freq_coarse);
            editOpByAliasId(id+"freq_fine",     op.freq_fine);
            editOpByAliasId(id+"detune",        op.detune);
            editOpByAliasId(id+"fmt_transpose", op.fmt_transpose);
            if(op.level > 0)
               setOpLevel(opIdx, op.level);

            opIdx = (opIdx + 1) & 7;
         }

         updateOperatorParams();
         updateFromPatchData_Editor(true/*bTabVisible*/);
         cf_op_preset.setSelectedOptionByName(p.name);
         setCurrentOpIdx(currentOpIdxOrig);

         Global.Print("Select Op Preset \""+p.name+"\" ("+numOps+" op"+Utils.GetPluralString(numOps)+")");
      }
   }

   // <ui_handle.png>
   protected method handleOpPresetSave(boolean _bAdd) {
      FMMatrix_OpPreset *p;
      int numOps = fp_op_preset_type.getFloatValue();
      if(_bAdd)
      {
         // trace "xxx bAdd: cf_op_preset.getSelectedOptionName()="+#(cf_op_preset.getSelectedOptionName());
         p <= FMMatrix_OpPreset.AddPreset(cf_op_preset.getSelectedOptionName());
      }
      else
      {
         p <= FMMatrix_OpPreset.FindPresetByNameAndNumOps(cf_op_preset.getSelectedOptionName(), numOps);
      }

      if(null != p)
      {
         p.clearOps();
         int opIdx = current_op_idx;
         loop(numOps)
         {
            FMMatrixOp fOp <= op_controls.get(opIdx);
            FMMatrix_OpPreset_Op op <= p.addOp();
            fOp.saveOpToPreset(op);
            opIdx = (opIdx + 1) & 7;
         }

         if(_bAdd)
         {
            updateOpPresetOptions();
            cf_op_preset.setSelectedOptionByName(p.name);
         }

         Global.Print((_bAdd?"Add":"Update")+" Op Preset \""+p.name+"\" ("+numOps+" op"+Utils.GetPluralString(numOps)+")");

         FMMatrix_OpPreset.SavePresets();
      }
   }

   // <ui_handle.png>
   protected method handleOpPresetRemove(String _presetName) {
   }

   // <method.png>
   protected method calcOpMapOpToFP() {
      int idx = 0;
      loop(op_map_fp_to_op.numElements)
         op_map_op_to_fp[op_map_fp_to_op[idx]] = idx++;
   }

   // <ui_init.png>
   protected method initWidgets() {

      boolean bFS1R = (null != parent_synth_form_fs1r);

      setLayout(SuperBorderLayout);
      Panel pOuter <= Panel.New();

      Panel pMat <= Panel.New();

      Panel pTopLabels <= Panel.New();
      Panel pLeftLabels <= Panel.New();
      pTopLabels.setPadding4f(0,0,0,0);
      pLeftLabels.setPadding4f(0,0,0,0);
      int opNr = 1;
      Label *lb;

      int c32Fg = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_LABEL);

      float w = 23 * UI.font_scaling;
      float h = 23 * UI.font_scaling;

      if(b_small_mat)
         font <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_LABEL_BOLD);//UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED);
      else
         font <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED_LARGE);

      font_fixed <= UI.GetFontByName(UIConstants.DEFAULT_FONT_NAME_FIXED);

      // Top/left corner (empty)
      lb <= Label.New();
      lb.setCaption(" ");
      lb.setFont(font);
      lb.setRequiredSize2f(w, h);
      lb.setPadding4f(0,0,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.LEFT | Layout.CENTERY);
      lb.setForegroundColor(c32Fg);
      pTopLabels.addLayer(deref lb, Layout.RIGHT);

      loop(8)
      {
         lb <= Label.New();
         lb.setFont(font);
         lb.setCaption(String(opNr));
         lb.setRequiredSize2f(w, h);
         lb.setPadding4f(0,0,0,0);
         lb.setTextPlacement(Layout.LEFT | Layout.CENTERY);
         lb.setForegroundColor(c32Fg);
         lb.setInnerPadding4f(0,7,0,0);
         lb.setInnerPadTop(1);
         if(UI.IsHiDPI())
            lb.setCaptionOffsetY(6);
         top_labels.add(#(deref lb));
         pTopLabels.addLayer(lb, Layout.RIGHT);

         lb <= Label.New();
         lb.setFont(font);
         lb.setCaption(String(opNr));
         lb.setRequiredSize2f(w, h-1);
         lb.setPadding4fUnscaled(0,0,1,0);
         lb.setInnerPadding4f(0,0,0,0);
         lb.setForegroundColor(c32Fg);
         left_labels.add(#(deref lb));
         pLeftLabels.addLayer(lb, Layout.BOTTOM);

         opNr++;
      }

      // FloatParam grid
      Panel pGrid <= Panel.New();

      FloatParam *fp;
      int carrierIdx = 0;
      loop(8)
      {
         Panel p <= Panel.New();

         int modIdx = 0;
         loop(8)
         {
            fp <= FloatParam.New();
            fp.setStepFine(1);
            fp.setStepCoarse(1);
            fp.setMinMaxValues(0, 99);
            fp.setPresetOptions([0.0f, 25.0f, 50.0f, 75.0f, 84.0f, 90.0f, 95.0f, 99.0f], null/*presetNamesOrNull*/);
            fp.setResetValues([0.0f, 99.0f]);
            fp.setPrecision(0);
            fp.setMousePrecision(0);
            fp.setEnableBorders(false);
            fp.setValue(0);
            fp.setVisibleTextLength(2);
            fp.setRequiredSize2f(w, h);
            fp.setPadding4fUnscaled(1,0,0,1);
            fp.setFont(font);
            fp.setEnableDisplayZeroAsBlank(true);
            fp.setEnableProvideStart(true);

            if(carrierIdx == modIdx)
               fp.setBackgroundTint(#20000000);

            fp_matrix.add(#(deref fp));

            p.addLayer(fp, Layout.RIGHT);
            modIdx++;
         }

         pGrid.addLayer(deref p, Layout.BOTTOM);
         carrierIdx++;
      }

      Panel pBt <= Panel.New();
      pBt.setAlignment(Layout.EXPANDX);

      // Utility buttons
      bt_cycle <= Button.New();
      bt_cycle.setCaption("Cycle");
      bt_cycle.setEnableLabelButton(true);
      bt_cycle.setPadLeft(8);
      bt_cycle.setToolTipCaption("Cycle (active) operator levels\n\n (note) \'z\'\n\n (note) hold-click to shuffle levels (lctrl-z)\n (note) \'y\' on german kbds");
      bt_cycle.setEnableHold(true);
      bt_cycle.setAlignment(Layout.CENTERY);
      pBt.addLayer(bt_cycle, Layout.LEFT);

      bt_rand_op <= Button.New();
      bt_rand_op.setCaption("Rand");
      bt_rand_op.setEnableLabelButton(true);
      bt_rand_op.setPadLeft(8);
      bt_rand_op.setToolTipCaption("Randomize operator levels\n\n (note) lctrl-lshift-r");
      bt_rand_op.setAlignment(Layout.CENTERY);
      pBt.addLayer(bt_rand_op, Layout.LEFT);

      bt_rand_op_gz <= Button.New();
      bt_rand_op_gz.setCaption("Rand>0");
      bt_rand_op_gz.setEnableLabelButton(true);
      bt_rand_op_gz.setPadLeft(23);
      bt_rand_op_gz.setToolTipCaption("Randomize operator levels > 0\n\n (note) lctrl-r");
      bt_rand_op_gz.setAlignment(Layout.CENTERY);
      pBt.addLayer(bt_rand_op_gz, Layout.LEFT);

      bt_reset <= Button.New();
      bt_reset.setCaption("Reset");
      bt_reset.setToolTipCaption("Reset all operator levels and revert to algorithm 1\n\n (note) hold-click to reset op-levels but keep algorithm selection");
      bt_reset.setEnableHold(true);
      bt_reset.setEnableLabelButton(true);
      bt_reset.setAlignment(Layout.CENTERY);
      pBt.addLayer(bt_reset, Layout.RIGHT);

      // Operator mute checkboxes
      Panel pMuteV <= Panel.New();
      // if(UI.IsLoDPI())
         pMuteV.setPadTopUnscaled(4);
      Panel pMuteN <= Panel.New();

      sgx_op_mute <= new SizeGroupX;
      pMat.addSizeGroup("sgx_op_mute", sgx_op_mute);

      bt_opv_mute <= Button.New();
      bt_opv_mute.setCaption("V:");
      bt_opv_mute.setFont(font);
      bt_opv_mute.setAlignment(Layout.CENTERY);
      bt_opv_mute.setPadding4f(0,8,0,0);
      bt_opv_mute.setInnerPadding4f(0,0,0,0);
      bt_opv_mute.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
      bt_opv_mute.setSizeGroup(sgx_op_mute);
      bt_opv_mute.setEnableLabelButton(true);
      bt_opv_mute.setEnableHold(true);
      bt_opv_mute.setToolTipCaption("Mute or unmute all voiced operators\n\n (note) hold-click to invert mute states");
      bt_opv_mute.setForegroundColor(c32Fg);
      pMuteV.addLayer(bt_opv_mute, Layout.LEFT);

      if(bFS1R)
      {
         bt_opn_mute <= Button.New();
         bt_opn_mute.setCaption("N:");
         bt_opn_mute.setFont(font);
         bt_opn_mute.setAlignment(Layout.CENTERY);
         bt_opn_mute.setPadding4f(0,8,0,0);
         bt_opn_mute.setInnerPadding4f(0,0,0,0);
         bt_opn_mute.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
         bt_opn_mute.setSizeGroup(sgx_op_mute);
         bt_opn_mute.setEnableLabelButton(true);
         bt_opn_mute.setEnableHold(true);
         bt_opn_mute.setToolTipCaption("Mute or unmute all unvoiced operators\n\n (note) hold-click to invert mute states");
         bt_opn_mute.setForegroundColor(c32Fg);
         pMuteN.addLayer(bt_opn_mute, Layout.LEFT);
      }

      CheckBox *cb;
      opNr = 1;
      int cbMutePadL = UI.IsHiDPI() ? 8 : 3;
      int cbMutePadR = UI.IsHiDPI() ? 9 : 6;
      loop(8)
      {
         cb <= CheckBox.New(false/*bSelected*/, "");
         cb.setAlignment(Layout.CENTERY);
         cb.setPadding4fUnscaled(0, cbMutePadL, 0, cbMutePadR);
         cb.setInnerPadding4f(0, 0, 0, 0);
         cb.setEnableKbdFocusOnMouse(false);
         cb.setToolTipCaption("Voiced Operator "+opNr+"\n\n (note) lshift-"+tcchar('0'+opNr)+"\n\n (note) hold-click to toggle (un-)mute all");
         cb.setEnableHold(true);
         pMuteV.addLayer(deref cb, Layout.RIGHT);
         opv_mute_checkboxes.add(cb);

         if(bFS1R)
         {
            cb <= CheckBox.New(false/*bSelected*/, "");
            cb.setAlignment(Layout.CENTERY);
            cb.setPadding4fUnscaled(0, cbMutePadL, 0, cbMutePadR);
            cb.setInnerPadding4f(0, 0, 0, 0);
            cb.setEnableKbdFocusOnMouse(false);
            cb.setToolTipCaption("Unvoiced Operator "+opNr+"\n\n (note) lshift-"+("qwertyui".getc(opNr-1))+"\n\n (note) hold-click to toggle (un-)mute all");
            cb.setEnableHold(true);
            pMuteN.addLayer(deref cb, Layout.RIGHT);
            opn_mute_checkboxes.add(cb);
         }

         opNr++;
      }

      Panel pDelta <= Panel.New();
      pDelta.setPadTop(6);
      pDelta.setAlignment(Layout.EXPANDX | Layout.CENTERY);

      // Multi-Edit
      cb_multiedit <= CheckBox.New(false/*bSelected*/, "");
      cb_multiedit.setCaption("Multi-Edit");
      cb_multiedit.setAlignment(Layout.CENTERY);
      cb_multiedit.setPadding4f(0,4, UI.IsHiDPI() ? 0 : 5, 0);
      cb_multiedit.setEnableKbdFocusOnMouse(false);
      cb_multiedit.setToolTipCaption("When checked, mirror parameter edits to all operators\n\n (note) \'x\'\n\n (note) also applies to init / rand functions");
      pDelta.addLayer(cb_multiedit, Layout.RIGHT);

      // Level delta
      fp_lvl_delta <= FloatParam.New();
      fp_lvl_delta.setAlignment(Layout.CENTERY);
      fp_lvl_delta.setStepFine(1);
      fp_lvl_delta.setStepCoarse(1);
      fp_lvl_delta.setMinMaxValues(1, 99);
      fp_lvl_delta.setPrecision(0);
      fp_lvl_delta.setMousePrecision(0);
      fp_lvl_delta.setValue(1);
      fp_lvl_delta.setVisibleTextLength(2);
      fp_lvl_delta.setPadding4f(0,4,0,0);
      fp_lvl_delta.setToolTipCaption("Operator level inc / dec delta\n\n (note) op matrix mouse wheel or cursor key up/down\n\n (note) \'v\' cycles through level delta presets");
      fp_lvl_delta.setPresetOptions([1.0f, 5.0f, 10.0f, 25.0f, 33.0f, 50.0f, 99.0f],
                                    ["Precise", "Fine", "Coarse", "Quarter", "Third", "Half", "Full" ]
                                    );
      pDelta.addLayer(fp_lvl_delta, Layout.LEFT);

      lb <= Label.New();
      lb.setCaption("Level Delta:");
      lb.setAlignment(Layout.CENTERY);
      lb.setPadding4f(0,28,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
      pDelta.addLayer(deref lb, Layout.LEFT);

      // Util: Op Cycle Left / Right, Op Preset
      Panel pOpCycle <= Panel.New();
      pOpCycle.setPadTop(5);
      pOpCycle.setAlignment(Layout.CENTERY);
      pDelta.addLayer(deref pOpCycle, Layout.BOTTOM);

      cb_op_preset_autoload <= CheckBox.New(true/*bSelected*/, "");
      cb_op_preset_autoload.setAlignment(Layout.CENTERY);
      cb_op_preset_autoload.setEnableKbdFocusOnMouse(false);
      cb_op_preset_autoload.setEnableCaption(false);
      cb_op_preset_autoload.setToolTipCaption("Auto-load Op Preset");
      pOpCycle.addLayer(deref cb_op_preset_autoload, Layout.LEFT);

      cf_op_preset <= ComboField.New();
      cf_op_preset.setPadding4f(0,4,0,0);
      cf_op_preset.setAlignment(Layout.CENTERY);
      cf_op_preset.setVisibleTextLength(8);
      cf_op_preset.setMaxTextLength(10);
      cf_op_preset.setEnableAddDelete(true);
      cf_op_preset.setEnableCursorKeyPopup(false);
      cf_op_preset.setToolTipCaption("Operator Preset\n\n (note) Replaces <n> op settings starting with the current (highlighted) operator\n\n (note) add preset: enter name + RETURN\n (note) overwrite existing preset: keep name + RETURN\n (note) delete last selected preset: clear name + RETURN");
      pOpCycle.addLayer(deref cf_op_preset, Layout.LEFT);

      fp_op_preset_type <= FloatParam.New();
      fp_op_preset_type.setPadding4f(0,16,0,0);
      fp_op_preset_type.setMinMaxValues(1, 8);
      fp_op_preset_type.setValue(1);
      fp_op_preset_type.setAlignment(Layout.CENTERY);
      fp_op_preset_type.setEnableRightAlign(true);
      fp_op_preset_type.setStep(1);
      fp_op_preset_type.setVisibleTextLength(1);
      fp_op_preset_type.setToolTipCaption("Preset: Num Operators");
      pOpCycle.addLayer(deref fp_op_preset_type, Layout.LEFT);

      bt_op_cycle_right <= Button.New();
      bt_op_cycle_right.setEnableLabelButton(true);
      bt_op_cycle_right.setCaption(">>");
      bt_op_cycle_right.setToolTipCaption("Move current Op right\n\n (note) hold-click to keep Op Levels");
      bt_op_cycle_right.setPadding4f(0,12,0,0);
      bt_op_cycle_right.setInnerPadding4f(0,0,0,0);
      bt_op_cycle_right.setTextPlacement(Layout.LEFT | Layout.CENTERY);
      bt_op_cycle_right.setAlignment(Layout.CENTERY);
      bt_op_cycle_right.setEnableHold(true);
      pOpCycle.addLayer(deref bt_op_cycle_right, Layout.LEFT);

      bt_op_cycle_left <= Button.New();
      bt_op_cycle_left.setEnableLabelButton(true);
      bt_op_cycle_left.setCaption("<<");
      bt_op_cycle_left.setToolTipCaption("Move current Op left\n\n (note) hold-click to keep Op Levels");
      bt_op_cycle_left.setPadding4f(0,14,0,0);
      bt_op_cycle_left.setInnerPadding4f(0,0,0,0);
      bt_op_cycle_left.setTextPlacement(Layout.LEFT | Layout.CENTERY);
      bt_op_cycle_left.setAlignment(Layout.CENTERY);
      bt_op_cycle_left.setEnableHold(true);
      pOpCycle.addLayer(deref bt_op_cycle_left, Layout.LEFT);

      // Util: Cycle / Shuffle op parameters
      Panel pCycle <= Panel.New();
      pCycle.setPadding4f(UI.IsHiDPI() ? 7 : 12,
                          0, 0, 0
                          );
      pCycle.setAlignment(Layout.BASELINE);
      pCycle.setLayerId("pCycle"); // debug

      // Util: Cycle
      bt_op_cycle <= Button.New();
      bt_op_cycle.setCaption("Cycle");
      bt_op_cycle.setEnableLabelButton(true);
      bt_op_cycle.setToolTipCaption("Cycle selected parameterset of (active) operators\n\n (note) lctrl-o (active ops)\n\n (note) lctrl-lshift-o (all ops)");
      bt_op_cycle.setAlignment(Layout.BASELINE);
      bt_op_cycle.setPadLeft(11);
      // // bt_op_cycle.setPadBottom(1);
      pCycle.addLayer(bt_op_cycle, Layout.RIGHT);

      // Util: Cycle
      bt_op_shuffle <= Button.New();
      bt_op_shuffle.setCaption("Shuffle");
      bt_op_shuffle.setEnableLabelButton(true);
      bt_op_shuffle.setPadLeft(8);
      bt_op_shuffle.setToolTipCaption("Shuffle selected parameterset of (active) operators\n\n (note) lctrl-p (active ops)\n\n (note) lctrl-lshift-p (all ops)");
      bt_op_shuffle.setAlignment(Layout.BASELINE);
      // // bt_op_shuffle.setPadBottom(1);
      pCycle.addLayer(bt_op_shuffle, Layout.RIGHT);

      // Util: Select Osc
      int padB = UI.IsLoDPI() ? 5 : 4;
      // // int padB = 6 * UI.font_scaling;
      padB = 0;
      cb_sel_osc <= CheckBox.New(true/*bSelected*/, "");
      cb_sel_osc.setCaption("Osc");
      cb_sel_osc.setPadding4f(0,0,padB,0);
      cb_sel_osc.setEnableKbdFocusOnMouse(false);
      cb_sel_osc.setToolTipCaption("Select Oscillator parameters for Cycle / Shuffle");
      cb_sel_osc.setAlignment(Layout.BASELINE);
      cb_sel_osc.setPadLeft(10);
      pCycle.addLayer(cb_sel_osc, Layout.RIGHT);

      // Util: Select Freq
      cb_sel_freq <= CheckBox.New(true/*bSelected*/, "");
      cb_sel_freq.setCaption("Freq");
      cb_sel_freq.setPadding4f(0,0,padB,0);
      cb_sel_freq.setEnableKbdFocusOnMouse(false);
      cb_sel_freq.setToolTipCaption("Select Frequency parameters for Cycle / Shuffle");
      cb_sel_freq.setAlignment(Layout.BASELINE);
      cb_sel_freq.setPadLeft(4);
      pCycle.addLayer(cb_sel_freq, Layout.RIGHT);

      // Util: Select AEG
      cb_sel_aeg <= CheckBox.New(true/*bSelected*/, "");
      cb_sel_aeg.setCaption("AEG");
      cb_sel_aeg.setPadding4f(0,0,padB,0);
      cb_sel_aeg.setEnableKbdFocusOnMouse(false);
      cb_sel_aeg.setToolTipCaption("Select Amplite Envelope Generator parameters for Cycle / Shuffle");
      cb_sel_aeg.setAlignment(Layout.BASELINE);
      cb_sel_aeg.setPadLeft(4);
      pCycle.addLayer(cb_sel_aeg, Layout.RIGHT);

      // Util: Select PEG
      cb_sel_peg <= CheckBox.New(true/*bSelected*/, "");
      cb_sel_peg.setCaption("PEG");
      cb_sel_peg.setPadding4f(0,0,padB,0);
      cb_sel_peg.setEnableKbdFocusOnMouse(false);
      cb_sel_peg.setToolTipCaption("Select Pitch Envelope Generator parameters for Cycle / Shuffle");
      cb_sel_peg.setAlignment(Layout.BASELINE);
      cb_sel_peg.setPadLeft(4);
      pCycle.addLayer(cb_sel_peg, Layout.RIGHT);

      // Util: Select LevelScale
      cb_sel_levelscl <= CheckBox.New(true/*bSelected*/, "");
      cb_sel_levelscl.setCaption("LevelScl");
      cb_sel_levelscl.setPadding4f(0,0,padB,0);
      cb_sel_levelscl.setEnableKbdFocusOnMouse(false);
      cb_sel_levelscl.setToolTipCaption("Select Level Scale parameters for Cycle / Shuffle");
      cb_sel_levelscl.setAlignment(Layout.BASELINE);
      cb_sel_levelscl.setPadLeft(4);
      pCycle.addLayer(cb_sel_levelscl, Layout.RIGHT);

      // Util: Select Sense
      cb_sel_sense <= CheckBox.New(true/*bSelected*/, "");
      cb_sel_sense.setCaption("Sens");
      cb_sel_sense.setPadding4f(0,0,padB,0);
      cb_sel_sense.setEnableKbdFocusOnMouse(false);
      cb_sel_sense.setToolTipCaption("Select Sensitivity parameters for Cycle / Shuffle");
      cb_sel_sense.setAlignment(Layout.BASELINE);
      cb_sel_sense.setPadLeft(4);
      pCycle.addLayer(cb_sel_sense, Layout.RIGHT);

      // Util: Freq randomization range
      lb <= Label.New();
      lb.setCaption("F:");
      lb.setAlignment(Layout.BASELINE);
      lb.setPadding4f(0,10,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
      pCycle.addLayer(deref lb, Layout.RIGHT);

      fp_freq_min <= FloatParam.New();
      fp_freq_min.setPadding4f(0,2,0,0);
      fp_freq_min.setStepFine(1);
      fp_freq_min.setStepCoarse(1);
      fp_freq_min.setMinMaxValues(0, 31);
      fp_freq_min.setValue(0);
      fp_freq_min.setPrecision(0);
      fp_freq_min.setMousePrecision(0);
      fp_freq_min.setVisibleTextLength(2);
      fp_freq_min.setToolTipCaption("Randomization: Minimum Freq");
      fp_freq_min.setAlignment(Layout.BASELINE);
      pCycle.addLayer(fp_freq_min, Layout.RIGHT);

      fp_freq_max <= FloatParam.New();
      fp_freq_max.setPadding4f(0,0,0,0);
      fp_freq_max.setStepFine(1);
      fp_freq_max.setStepCoarse(1);
      fp_freq_max.setMinMaxValues(0, 31);
      fp_freq_max.setPrecision(0);
      fp_freq_max.setMousePrecision(0);
      fp_freq_max.setValue(7);
      fp_freq_max.setVisibleTextLength(2);
      fp_freq_max.setToolTipCaption("Randomization: Maximum Freq");
      fp_freq_max.setAlignment(Layout.BASELINE);
      pCycle.addLayer(fp_freq_max, Layout.RIGHT);

      cb_freq_fine <= CheckBox.New(true/*bSelected*/, "");
      // // if(UI.IsLoDPI())
      // //    cb_freq_fine.setPadding4f(0,0,5,0);
      cb_freq_fine.setEnableKbdFocusOnMouse(false);
      cb_freq_fine.setToolTipCaption("Randomization: Fine Frequency (Ratio)");
      cb_freq_fine.setAlignment(Layout.BASELINE);
      pCycle.addLayer(cb_freq_fine, Layout.RIGHT);

      cb_freq_carrier1 <= CheckBox.New(true/*bSelected*/, "");
      // // if(UI.IsLoDPI())
      // //    cb_freq_carrier1.setPadding4f(0,0,5,0);
      cb_freq_carrier1.setEnableKbdFocusOnMouse(false);
      cb_freq_carrier1.setToolTipCaption("Randomization: When checked, force carrier frequency ratio to 1");
      cb_freq_carrier1.setAlignment(Layout.BASELINE);
      pCycle.addLayer(cb_freq_carrier1, Layout.RIGHT);

      // Util: AEG decay/release time randomization range
      lb <= Label.New();
      lb.setCaption("T:");
      lb.setAlignment(Layout.BASELINE);
      lb.setPadding4f(0,10,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
      lb.setEnableFillBackground(true);
      pCycle.addLayer(deref lb, Layout.RIGHT);

      fp_aeg_tmin <= FloatParam.New();
      fp_aeg_tmin.setPadding4f(0,2,0,0);
      fp_aeg_tmin.setStepFine(1);
      fp_aeg_tmin.setStepCoarse(1);
      fp_aeg_tmin.setMinMaxValues(0, 99);
      fp_aeg_tmin.setValue(10);
      fp_aeg_tmin.setPrecision(0);
      fp_aeg_tmin.setMousePrecision(0);
      fp_aeg_tmin.setVisibleTextLength(2);
      fp_aeg_tmin.setToolTipCaption("Randomization: Minimum AEG time");
      fp_aeg_tmin.setAlignment(Layout.BASELINE);
      pCycle.addLayer(fp_aeg_tmin, Layout.RIGHT);

      fp_aeg_tmax <= FloatParam.New();
      fp_aeg_tmax.setPadding4f(0,0,0,0);
      fp_aeg_tmax.setStepFine(1);
      fp_aeg_tmax.setStepCoarse(1);
      fp_aeg_tmax.setMinMaxValues(0, 99);
      fp_aeg_tmax.setPrecision(0);
      fp_aeg_tmax.setMousePrecision(0);
      fp_aeg_tmax.setValue(70);
      fp_aeg_tmax.setVisibleTextLength(2);
      fp_aeg_tmax.setToolTipCaption("Randomization: Maximum AEG time");
      fp_aeg_tmax.setAlignment(Layout.BASELINE);
      pCycle.addLayer(fp_aeg_tmax, Layout.RIGHT);

      cb_aeg_l3less <= CheckBox.New(true/*bSelected*/, "");
      // // if(UI.IsLoDPI())
      // //    cb_aeg_l3less.setPadding4f(0,0,5,0);
      cb_aeg_l3less.setEnableKbdFocusOnMouse(false);
      cb_aeg_l3less.setToolTipCaption("Randomization: When checked, AEG level 3 will be less than or equal level 2");
      cb_aeg_l3less.setAlignment(Layout.BASELINE);
      pCycle.addLayer(cb_aeg_l3less, Layout.RIGHT);

      // Op controls
      FMMatrixOp *op;
      Panel pOp <= Panel.New();
      pOp.setPadding4f(2,0,2,0);
      Panel pOpUp <= Panel.New();
      pOpUp.setAlignment(Layout.EXPANDY);
      pOpUp.addLayer(deref pOp, Layout.TOP);
      Panel pOpL <= Panel.New();
      Panel pOpR <= Panel.New();
      pOpR.setPadLeft(8);
      int opIdx = 0;
      loop(8)
      {
         op <= new FMMatrixOp();
         op.initFMMatrixOp(opIdx, this);
         if(opIdx < 4)
            pOpL.addLayer(op, Layout.BOTTOM);
         else
            pOpR.addLayer(op, Layout.BOTTOM);
         op_controls.add(#(deref op));

         opIdx++;
      }
      pOp.addLayer(deref pOpL, Layout.LEFT);
      pOp.addLayer(deref pOpR, Layout.RIGHT);

      // Arrange panels
      pMat.addLayer(deref pTopLabels,  Layout.TOP);
      pMat.addLayer(deref pBt,         Layout.TOP);
      pMat.addLayer(deref pGrid,       Layout.LEFT);
      pMat.addLayer(deref pLeftLabels, Layout.LEFT);
      pMat.addLayer(deref pMuteV,      Layout.BOTTOM);
      if(bFS1R)
         pMat.addLayer(deref pMuteN,      Layout.BOTTOM);
      pMat.addLayer(deref pDelta,     Layout.BOTTOM);

      // Algorithm panel
      Panel pAlg <= Panel.New();
      pAlg.setPadTop(44 - 21 - 6);
      pAlg.setAlignment(Layout.EXPANDX);

      Panel pAlgInner <= Panel.New();

      fm_matrix_alg_grid <= new FMMatrixAlgGrid;
      fm_matrix_alg_grid.initFMMatrixAlgGrid(this);
      fm_matrix_alg_grid.setPadLeft(8);
      pAlgInner.addLayer(fm_matrix_alg_grid, Layout.TOP);

      // Feedback (panel above alg)
      Panel pFB <= Panel.New();
      pFB.setPadding4f(0,0, UI.IsLoDPI()?6:4, 0);
      pFB.setAlignment(Layout.EXPANDX|Layout.CENTERY);

      fp_fb <= FloatParam.New();
      fp_fb.setPadding4f(0,4,0,0);
      fp_fb.setStepFine(1);
      fp_fb.setStepCoarse(1);
      fp_fb.setMinMaxValues(0, 7);
      fp_fb.setPrecision(0);
      fp_fb.setMousePrecision(0);
      fp_fb.setEnableBorders(false);
      fp_fb.setValue(0);
      fp_fb.setVisibleTextLength(2);
      fp_fb.setToolTipCaption("Feedback");
      fp_fb.setAlignment(Layout.BASELINE);
      fp_fb.setFont(font_fixed);
      pFB.addLayer(fp_fb, Layout.LEFT);

      lb <= Label.New();
      lb.setCaption("Feedback:");
      lb.setPadding4f(0,20,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
      lb.setAlignment(Layout.BASELINE);
      pFB.addLayer(deref lb, Layout.LEFT);

      // FB: Auto-select Algorithm
      cb_autoalg <= CheckBox.New(true/*bSelected*/, "");
      cb_autoalg.setCaption("Auto-select");
      // // if(!UI.IsHiDPI())
      // //    cb_autoalg.setPadding4f(0,0,padB-2,0);
      // // else
      // //    cb_autoalg.setCaptionOffsetY(-2);
      cb_autoalg.setEnableKbdFocusOnMouse(false);
      cb_autoalg.setToolTipCaption("Auto-select algorithm when op-level changes\n\nWhen enabled, calculate possible algorithm selections\n\n (note) may auto-swap ops when algorithm changes");
      cb_autoalg.setAlignment(Layout.BASELINE);
      cb_autoalg.setPadLeft(4);
      pFB.addLayer(cb_autoalg, Layout.LEFT);

      fp_alg <= FloatParam.New();
      fp_alg.setPadding4f(0,2,0,0);
      fp_alg.setStepFine(1);
      fp_alg.setStepCoarse(1);
      fp_alg.setMinMaxValues(0, 87);
      fp_alg.setFloatDisplayBias(1);
      fp_alg.setPrecision(0);
      fp_alg.setMousePrecision(0);
      fp_alg.setEnableBorders(false);
      fp_alg.setValue(0);
      fp_alg.setVisibleTextLength(2);
      fp_alg.setToolTipCaption("Algorithm\n\n (note) lshift-a");
      fp_alg.setAlignment(Layout.BASELINE);
      fp_alg.setFont(font_fixed);
      fp_alg.setDragRateLimit(150/*ms*/);
      pFB.addLayer(fp_alg, Layout.LEFT);

      lb <= Label.New();
      lb.setCaption("Algorithm:");
      lb.setPadding4f(0,9,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
      lb.setAlignment(Layout.BASELINE);
      pFB.addLayer(deref lb, Layout.LEFT);

      // Part
      Panel pPart <= Panel.New();
      Panel pPartInner <= Panel.New();
      pPart.setAlignment(Layout.EXPANDX|Layout.EXPANDY);
      pPart.setLayoutWeight2f(1.0f, 1.0f);
      pPart.addLayer(deref pPartInner, Layout.LEFT);
      // // pPart.setPadRight(17);
      int partIdx = 0;
      Button *bt;
      int numParts = (null != parent_synth_form_montage) ? 16 : 4;
      Panel *pPartCur;
      loop(numParts)
      {
         if(0 == (partIdx&3))
         {
            pPartCur <= Panel.New();
            pPartInner.addLayer(deref pPartCur, Layout.BOTTOM);
            if(0 == partIdx)
               pPartCur.setPadTop(54);
            else
               pPartCur.setPadTop(9);
         }

         bt <= Button.New();
         bt.setPadding4f(0,2,0,2);
         if(0 == (partIdx&3))
            bt.setPadLeft(bFS1R ? 17 : 23);
         bt.setEnableToggle(true);
         bt.setCaption(" "+String(++partIdx)+" ");
         bt.setInnerPadding4f(2,2,2,2);
         bt.setTextPlacement(Layout.CENTER);
         bt.setAlignment(Layout.CENTERY);
         if(partIdx <= 8)
            bt.setToolTipCaption("Part "+partIdx+" switch\n\n (note) lctrl-"+partIdx+"\n\n (note) click twice to toggle part solo");
         else
            bt.setToolTipCaption("Part "+partIdx+" switch\n\n (note) lctrl-lshift-"+(((partIdx-1)&7)+1)+"\n\n (note) click twice to toggle part solo");
         bt.setEnableKbdFocusOnMouse(false);
         bt.setRequiredSize2fScaled(25, 21);
         part_buttons.add(#(deref bt));
         pPartCur.addLayer(bt, Layout.RIGHT);
      }

      // AEG Scaling
      Panel pPartAEGScl <= Panel.New();
      pPartAEGScl.setAlignment(Layout.EXPANDX | Layout.BASELINEY);
      pPart.addLayer(deref pPartAEGScl, Layout.BOTTOM);
      pPartAEGScl.setPadding4f(0,0,0,0);

      lb <= Label.New();
      lb.setCaption("AEG Scl:");
      lb.setPadding4f(0,4,0,0);
      lb.setInnerPadding4f(0,0,0,0);
      lb.setTextPlacement(Layout.RIGHT | Layout.CENTERY);
      lb.setAlignment(Layout.BASELINE);
      pPartAEGScl.addLayer(lb, Layout.RIGHT);

      fp_aeg_scl <= FloatParam.New();
      fp_aeg_scl.setPadding4f(0,4,0,0);
      fp_aeg_scl.setStepFine(0.01);
      fp_aeg_scl.setStepCoarse(0.01);
      fp_aeg_scl.setMinMaxValues(-9, 9);
      fp_aeg_scl.setValue(0);
      fp_aeg_scl.setPrecision(4);
      fp_aeg_scl.setMousePrecision(4);
      fp_aeg_scl.setVisibleTextLength(4);
      fp_aeg_scl.setToolTipCaption("AEG Scale\n\n (note) WARNING: permanently alters patch when edited\n\n (note) non-destructive, realtime AEG scaling is available via Proxy Input Device RPN#1000");
      fp_aeg_scl.setAlignment(Layout.BASELINE);
      fp_aeg_scl.setEnableProvideStart(true);
      fp_aeg_scl.setDragRateLimit(150/*ms*/);
      pPartAEGScl.addLayer(fp_aeg_scl, Layout.RIGHT);

      fp_aeg_scl_exp <= FloatParam.New();
      fp_aeg_scl_exp.setPadding4f(0,2,0,8);
      fp_aeg_scl_exp.setStepFine(1);
      fp_aeg_scl_exp.setStepCoarse(1);
      fp_aeg_scl_exp.setMinMaxValues(0, 99);
      fp_aeg_scl_exp.setValue(40);
      fp_aeg_scl_exp.setResetValue(20);
      fp_aeg_scl_exp.setPrecision(0);
      fp_aeg_scl_exp.setMousePrecision(0);
      fp_aeg_scl_exp.setVisibleTextLength(2);
      fp_aeg_scl_exp.setToolTipCaption("AEG Scale Exponent\n\n (note) the higher the value, the less scaling affects long AEG times\n\n (note) also affects realtime AEG scaling (via Proxy Input Device RPN#1000)");
      fp_aeg_scl_exp.setAlignment(Layout.BASELINE);
      fp_aeg_scl_exp.setEnableProvideStart(true);
      pPartAEGScl.addLayer(fp_aeg_scl_exp, Layout.RIGHT);

      if(null != parent_synth_form_montage)
      {
         cm_var <= ComboBox.New();
         cm_var.setPadding4f(0,4,0,0);
         cm_var.setToolTipCaption("Patch Variation\n\n (note) hold LALT to switch variations on all parts");
         cm_var.setAlignment(Layout.CENTERY);
         cm_var.setOptions(["Main", "Var 1", "Var 2", "Var 3", "Var 4", "Var 5", "Var 6", "Var 7", "Var 8", "Var 9", "Var 10", "Var 11", "Var 12", "Var 13", "Var 14", "Var 15"]);
         cm_var.setOptionSizeReserve("  Var 10  ");
         pFB.addLayer(cm_var, Layout.RIGHT);
      }

      // // Mix'n'match part patch selection (copy on select)
      // // TitledPanel pMix <= new TitledPanel;
      // // pMix.initTitledPanel();
      // // pMix.setCaption("Mix / Copy");
      // // pMix.setPadTop(2);
      Panel pMix <= Panel.New();
      pMix.setPadTop(10);
      pMix.setAlignment(Layout.EXPANDX);
      // // Layer pMixInner <= pMix.getLayoutFirstChild();  // get inner_layer
      // // pMixInner.setLayout(SuperBorderLayout);
      Panel pMixInner <= pMix;
      Panel pMixL <= Panel.New();
      pMixInner.addLayer(deref pMixL, Layout.LEFT);

      int mixPartIdx = 0;
      ComboBox *cm;
      loop(4)
      {
         cm <= ComboBox.New();
         cm.setOptionSizeReserve("MMMMMMMMMMMMMMMM");
         cm.setToolTipCaption("Mix\'n\'match: Part "+(mixPartIdx+1)+" patch (copy on select)"+((mixPartIdx>0)?"\n\n (note) only editable when part patches are consecutive, e.g. part1=#101, part2=#102, part3=#103, part4=#104":""));
         cm.setAlignment(Layout.CENTERY);
         cm.setPadding4f(0,(0 == mixPartIdx) ? 24:6,0,0);
         cm_mix_parts.add(#(deref cm));
         pMixL.addLayer(cm, Layout.RIGHT);

         fp <= FloatParam.New();
         fp.setPadding4f(1,0,0,2);
         fp.setInnerPadRight(4);
         fp.setStepFine(1);
         fp.setStepCoarse(1);
         fp.setMinMaxValues(0, 127);
         fp.setEnableBorders(false);
         fp.setPrecision(0);
         fp.setMousePrecision(0);
         fp.setValue(127);
         fp.setVisibleTextLength(2);
         fp.setToolTipCaption("Part "+(mixPartIdx+1)+" Level"+((mixPartIdx>0)?"\n\n (note) only editable when part patches are consecutive, e.g. part1=#101, part2=#102, part3=#103, part4=#104":""));
         fp.setAlignment(Layout.CENTERY);
         fp.setFont(font);
         fp_mix_parts_level.add(#(deref fp));
         pMixL.addLayer(fp, Layout.RIGHT);

         fp <= FloatParam.New();
         fp.setPadding4f(1,0,0,2);
         fp.setInnerPadRight(4);
         fp.setStepFine(1);
         fp.setStepCoarse(1);
         fp.setMinMaxValues(-24, 24);
         fp.setEnableBorders(false);
         fp.setPrecision(0);
         fp.setMousePrecision(0);
         fp.setValue(0);
         fp.setVisibleTextLength(2);
         fp.setToolTipCaption("Part "+(mixPartIdx+1)+" Note Shift"+((mixPartIdx>0)?"\n\n (note) only editable when part patches are consecutive, e.g. part1=#101, part2=#102, part3=#103, part4=#104":""));
         fp.setAlignment(Layout.CENTERY);
         fp.setFont(font);
         fp_mix_parts_noteshift.add(#(deref fp));
         pMixL.addLayer(fp, Layout.RIGHT);

         mixPartIdx++;
      }

      // Arrange panels
      // // Panel pCycleTop <= Panel.New();
      // // pCycleTop.addLayer(deref pCycle, Layout.TOP);
      // // pAlgInner.addLayer(deref pCycleTop, Layout.BOTTOM);
      pAlgInner.addLayer(deref pCycle, Layout.BOTTOM);
      pAlgInner.addLayer(deref pFB,    Layout.TOP);
      pAlg.addLayer(deref pAlgInner,  Layout.LEFT);

      // // pAlg.setDebug(1);
      // // pPart.setDebug(1);

      pOuter.addLayer(deref pAlg,  Layout.CENTER);
      pOuter.addLayer(deref pPart, Layout.RIGHT);
      pOuter.addLayer(deref pMat,  Layout.LEFT);
      pOuter.addLayer(deref pOpUp, Layout.BOTTOM);
      pOuter.addLayer(deref pMix,  Layout.BOTTOM);
      // // pOuter.setDebug(1);
      addLayer(deref pOuter, Layout.TOP);
   }

   // <ui_update.png>
   protected method updateMixPartPatches(boolean _bUpdatePatchNr) {
      ComboBox *cm;
      FloatParam *fp;
      int mixPartIdx;
      int c32Cur = #2000ff00;
      int c32CurNoFM = #40ff0000;

      if(null != parent_synth_form_fs1r)
      {
         MIDISynthProfileDataFS1R dataFS1R <= parent_synth_form_fs1r.data;

         cm <= parent_synth_form_fs1r.cm_patch_nr_part2;
         local StringArray opt = cm.getOptions();
         opt.delete(1); // delete option '-', keep option 0="keep"

         FS1R_Patch pMain <= parent_synth_form_fs1r.getMainPatch();

         int partPatchIdx0;
         int partPatchIdx;

         // Part 1
         cm <= cm_mix_parts[0];
         partPatchIdx = dataFS1R.patches.indexOfPointer(pMain, 0);
         partPatchIdx0 = partPatchIdx;  // 0..n
         cm.setOptions(opt);
         if(_bUpdatePatchNr)
            cm.setSelectedOption(partPatchIdx + 1);
         cm.redraw();
         fp <= fp_mix_parts_level[0];
         fp.setValue(getPartLevel(0));
         if(dataFS1R.current_part_idx == 0)
         {
            cm.setBackgroundTint(c32Cur);
         }
         else
         {
            cm.setBackgroundTint(0);
         }

         // Parts 2..4
         mixPartIdx = 1;
         loop(4-1)
         {
            cm <= cm_mix_parts[mixPartIdx];
            if(1 == mixPartIdx)
               partPatchIdx = pMain.patch_idx_part2;
            else if(2 == mixPartIdx)
               partPatchIdx = pMain.patch_idx_part3;
            else if(3 == mixPartIdx)
               partPatchIdx = pMain.patch_idx_part4;
            // trace "xxx mixPartIdx="+mixPartIdx+" partPatchIdx="+partPatchIdx;
            if(partPatchIdx < -1)
               partPatchIdx = -1;  // keep
            cm.setOptions(opt);
            if(_bUpdatePatchNr)
               cm.setSelectedOption(partPatchIdx + 1);
            cm.setEditable(partPatchIdx == (partPatchIdx0 + mixPartIdx));  // consecutive ?
            cm.redraw();

            fp <= fp_mix_parts_level[mixPartIdx];
            fp.setValue(getPartLevel(mixPartIdx));
            fp.setEditable(partPatchIdx == (partPatchIdx0 + mixPartIdx));  // consecutive ?

            fp <= fp_mix_parts_noteshift[mixPartIdx];
            fp.setValue(getPartNoteShift(mixPartIdx));
            fp.setEditable(partPatchIdx == (partPatchIdx0 + mixPartIdx));  // consecutive ?

            if(dataFS1R.current_part_idx == mixPartIdx)
            {
               cm.setBackgroundTint(c32Cur);
               // // fp.setBackgroundTint(c32Cur);
            }
            else
            {
               cm.setBackgroundTint(0);
               // // fp.setBackgroundTint(0);
            }

            mixPartIdx++;
         }
      }
      else if(null != parent_synth_form_montage)
      {
         MIDISynthProfileDataMontage dataMontage <= parent_synth_form_montage.data;
         // Parts 1..4
         mixPartIdx = dataMontage.current_part_idx & ~3;
         int mixPartIdxWidget = 0;
         loop(4)
         {
            cm <= cm_mix_parts[mixPartIdxWidget];

            fp <= fp_mix_parts_level[mixPartIdxWidget];
            fp.setValue(getPartLevel(mixPartIdx));

            fp <= fp_mix_parts_noteshift[mixPartIdxWidget];
            fp.setValue(getPartNoteShift(mixPartIdx));

            if(dataMontage.current_part_idx == mixPartIdx)
               cm.setBackgroundTint(parent_synth_form_montage.isEditPartFM() ? c32Cur : c32CurNoFM);
            else
               cm.setBackgroundTint(0);

            mixPartIdx++;
            mixPartIdxWidget++;
         }
      }

   }

   // <ui_handle.png>
   public method handleParamWidgetChanged(Layer _l, boolean _bUpdateFMMatrix, boolean _bQuiet) {
      if(null != parent_synth_form_fs1r)
         parent_synth_form_fs1r.handleParamWidgetChanged(_l, _bUpdateFMMatrix, _bQuiet);
      else if(null != parent_synth_form_montage)
         parent_synth_form_montage.handleParamWidgetChanged(_l, _bUpdateFMMatrix, _bQuiet);
   }

   // <method_get.png>
   public method getPartLevel(byte _partIdx) : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         Buffer pd <= parent_synth_form_fs1r.getPatchDataByPartIdx(_partIdx);
         if(null != pd)
            return pd.peekI8(0x0B);
         else
            return 0;
      }
      else
      {
         // Montage
         return parent_synth_form_montage.getPartVolume(_partIdx);
      }
   }

   // <method_get.png>
   public =replay= method setPartLevel(byte _partIdx, byte _lvl/*0..127*/) : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         Buffer pd <= parent_synth_form_fs1r.getPatchDataByPartIdx(_partIdx);
         pd.pokeI8(0x0B, _lvl);

         MIDISynthProfileDataFS1R dataFS1R <= parent_synth_form_fs1r.data;
         if(dataFS1R.b_autosend)
            parent_synth_form_fs1r.scheduleMIDISendPatch();
      }
      else
      {
         // Montage
         parent_synth_form_montage.setPartVolume(_partIdx, _lvl);

         MIDISynthProfileDataMontage dataMontage <= parent_synth_form_montage.data;
         if(dataMontage.b_autosend)
            parent_synth_form_montage.scheduleMIDISendPatch();
      }
   }

   // <method_get.png>
   public method getPartNoteShift(byte _partIdx) : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         Buffer pd <= parent_synth_form_fs1r.getPatchDataByPartIdx(_partIdx);
         if(null != pd)
            return pd.peekI8(0x08) - 24;
         else
            return 0;
      }
      else
      {
         // Montage
         return parent_synth_form_montage.getPartNoteShift(_partIdx);
      }
   }

   // <method_get.png>
   public =replay= method setPartNoteShift(byte _partIdx, byte _noteShift/*-24..24*/) : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         Buffer pd <= parent_synth_form_fs1r.getPatchDataByPartIdx(_partIdx);
         pd.pokeI8(0x08, _noteShift + 24);

         MIDISynthProfileDataFS1R dataFS1R <= parent_synth_form_fs1r.data;
         if(dataFS1R.b_autosend)
            parent_synth_form_fs1r.scheduleMIDISendPatch();
      }
      else
      {
         // Montage
         parent_synth_form_montage.setPartNoteShift(_partIdx, _noteShift);

         MIDISynthProfileDataMontage dataMontage <= parent_synth_form_montage.data;
         if(dataMontage.b_autosend)
            parent_synth_form_montage.scheduleMIDISendPatch();
      }
   }

   // <method_get.png>
   public method getOpLevel(int _opIdx) : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         Buffer pd <= parent_synth_form_fs1r.patch.patch_data;
         int syxOff = 164 + (226 - 164)/*bytesPerOp*/ * _opIdx;
         byte lvl = pd.peekI8(syxOff + 0x16);
         return lvl;
      }
      else
      {
         // Montage:
         return parent_synth_form_montage.getOpLevel(_opIdx);
      }
   }

   // <method_find.png>
   public method findParamWidgetByAliasId(String _aliasId) : Layer {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R
         return parent_synth_form_fs1r.findParamWidgetByAliasId(_aliasId);
      }
      else
      {
         // Montage
         return parent_synth_form_montage.findParamWidgetByAliasId(_aliasId);
      }
   }

   // <method_set.png>
   public method setOpLevel(int _opIdx, byte _lvl) {
      FloatParam *fpEditor;
      if(null != parent_synth_form_fs1r)
      {
         // FS1R
         fpEditor <= parent_synth_form_fs1r.findParamWidgetByAliasId("d_op"+(_opIdx+1)+"v_lvlscl_total");
         fpEditor.setValue(_lvl);
         handleParamWidgetChanged(fpEditor, false/*bUpdateFMMatrix*/, true/*bQuiet*/);
      }
      else
      {
         // Montage
         parent_synth_form_montage.setOpLevel(_opIdx, _lvl);
      }

      setCurrentOpIdx(_opIdx);
   }

   // <method_get.png>
   public method getAlgorithm() : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         Buffer pd <= parent_synth_form_fs1r.patch.patch_data;
         int algorithm = mathClampi(pd.peekI8(52/*voice*/ + 0x2C/*d_vcom_alg*/), 0, 87);
         return algorithm;
      }
      else
      {
         // Montage:
         return parent_synth_form_montage.getAlgorithm();
      }
   }

   // <method_get.png>
   public method setAlgorithm(byte algorithm) {
      ComboBox *cmEditor;
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         cmEditor <= parent_synth_form_fs1r.findParamWidgetByAliasId("d_vcom_alg");
         cmEditor.setSelectedOption(algorithm);
         handleParamWidgetChanged(cmEditor, false/*bUpdateFMMatrix*/, true/*bQuiet*/);
      }
      else
      {
         parent_synth_form_montage.setAlgorithm(algorithm);
      }
   }

   // <method_get.png>
   public method getAlgorithmMatrix() : String {
      int algorithm = getAlgorithm();
      return alg_matrices[algorithm];
   }

   // <method_get.png>
   public method getFeedback() : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         Buffer pd <= parent_synth_form_fs1r.patch.patch_data;
         return pd.peekI8(52 + 0x3D/*d_vcom_voiced_fb*/);
      }
      else
      {
         // Montage:
         return parent_synth_form_montage.getFeedback();
      }
   }

   // <method_get.png>
   public method setFeedback(byte _fb) {
      FloatParam *fpEditor;
      if(null != parent_synth_form_fs1r)
      {
         // FS1R:
         fpEditor <= parent_synth_form_fs1r.findParamWidgetByAliasId("d_vcom_voiced_fb");
         fpEditor.setValue(_fb);
         handleParamWidgetChanged(fpEditor, true/*bUpdateFMMatrix*/, true/*bQuiet*/);
      }
      else
      {
         // Montage:
         parent_synth_form_montage.setFeedback(_fb);
      }
   }

   // <method.png>
   protected method buildActiveMatrix(String sMat, String sMatUsed, boolean _bFeedback) {
      sMatUsed = sMat;
      int carrierIdx = 0;
      loop(8)
      {
         int modIdx = 0;
         loop(8)
         {
            byte lvl = getOpLevel(modIdx);
            if(b_autoselect_alg && (0 == lvl))
               sMatUsed[carrierIdx*8 + modIdx] = '.';
            else if( ('f' == sMatUsed[carrierIdx*8 + modIdx]) && !_bFeedback )
               sMatUsed[carrierIdx*8 + modIdx] = (modIdx == carrierIdx) ? ('1'+carrierIdx) : 'm';

            modIdx++;
         }
         carrierIdx++;
      }

      // Sanitize modulators (remove single 'm' line on carrier=mod diagonal)
      if(1)
      {
         int opIdx = 0;
         loop(8)
         {
            if('m' == sMatUsed.getc(8*opIdx + opIdx))
               sMatUsed[8*opIdx + opIdx] = '.';
            opIdx++;
         }
      }

      // trace "[dbg] buildActiveMatrix: sMatUsed:";
      // debugPrintMat(sMatUsed);
   }

   // <method.png>
   protected method buildMatPossible_v1(String sMatUsed, String sMatPossible/*ret*/) {

      sMatPossible = sMatUsed;

      local IntArray algIndices;
      local PointerArray opMaps;
      local IntArray opMapUsed;
      byte lvl;

      // // findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, true/*bExactMatch*/);
      // // if(0 == algIndices.numElements)
      // //    findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, false/*bExactMatch*/);

      opMaps <= findMatchingAlgsSorted(sMatUsed, 8, algIndices, opMapUsed);

      if(debug >= 2)
         trace "[dbg] FMMatrix::buildMatPossible_v1: matching algIndices="+algIndices;

      // Create matrix that includes all possible modulations
      int possibleIdx = 0;
      loop(algIndices.numElements)
      {
         int algIdxOther = algIndices[possibleIdx];
         String sMatOther <= alg_matrices[algIdxOther];
         // // IntArray opMapOther <= opMaps[possibleIdx];

         // if(-1 != sMatOther.indexOf(" ", 0))
         //    trace "xxx sMatOther=\""+sMatOther+"\"";

         int carrierIdx = 0;
         loop(8)
         {
            int modIdx = 0;
            loop(8)
            {
               char c      = sMatPossible.getc(carrierIdx*8 + modIdx);
               char cOther = sMatOther  .getc(carrierIdx*8 + modIdx);

               if( ('.' == c) && (cOther != '.') )
               {
                  boolean bAllowOther = (modIdx <= carrierIdx);
                  if(carrierIdx == modIdx)
                  {
                     lvl = getOpLevel(modIdx);
                     if(1 && (lvl > 0))
                     {
                        // Op cannot be output in possible mat when it's already a modulator in currently active mat
                        int carrierIdx2 = 0;
                        loop(8)
                        {
                           if('.' != sMatPossible.getc(carrierIdx2*8+modIdx))
                           {
                              bAllowOther = false;
                              break;
                           }
                           carrierIdx2++;
                        }
                     }
                  }
                  else
                  {
                     lvl = getOpLevel(modIdx);

                     // // if(0 == algIndices[possibleIdx])
                     // // {
                     // trace "xxx possibleAlg="+(algIndices[possibleIdx]+1)+" p=("+modIdx+";"+carrierIdx+") lvl="+lvl+" cPossibleCarrier="+tcchar(sMatPossible.getc(carrierIdx*8 + carrierIdx));
                     // // }

                     if(1 && (lvl > 0))
                     {
                        // if('.' != sMatPossible.getc(carrierIdx*8 + carrierIdx))
                        if('.' != sMatPossible.getc(modIdx*8 + modIdx))
                        {
                           // Op cannot be modulator in possible mat when it's already an output in currently active mat
                           // if('.' != sMatPossible.getc(carrierIdx2*8+modIdx))
                           bAllowOther = false;
                        }
                     }
                  }

                  if(bAllowOther)
                     sMatPossible[carrierIdx*8 + modIdx] = cOther;
               }

               modIdx++;
            }
            carrierIdx++;
         }

         possibleIdx++;
      }
   }

   // <method.png>
   protected method buildMatPossible_v2(String sMatUsed, String sMatPossible/*ret*/, int _fltCarrierIdx, int _fltModIdx) {

      if(-1 == _fltCarrierIdx && -1 == _fltModIdx)
         sMatPossible = sMatUsed;

      local IntArray     algIndices;
      local PointerArray opMaps;
      local IntArray     opMapUsed;
      byte lvl;

      // // findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, true/*bExactMatch*/);
      // // if(0 == algIndices.numElements)
      // //    findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, false/*bExactMatch*/);

      int cOff = 0;
      int carrierIdx = 0;
      loop(8)
      {
         if( (-1 == _fltCarrierIdx) || (_fltCarrierIdx == carrierIdx) )
         {
            int modIdx = 0;
            loop(8)
            {
               if( (-1 == _fltModIdx) || (_fltModIdx == modIdx) )
               {
                  if(modIdx <= carrierIdx)
                  {
                     if('.' == sMatUsed.getc(cOff))
                     {
                        local String sMatReq = sMatUsed;
                        char c = (carrierIdx == modIdx) ? ('1' + carrierIdx) : 'm';
                        sMatReq[cOff] = c;

                        opMaps <= findMatchingAlgsSorted(sMatReq, 8, algIndices, opMapUsed);
                        if(algIndices.numElements > 0)
                           sMatPossible[cOff] = c;
                     }
                  }
               }
               modIdx++;
               cOff++;
            }
         }
         else
            cOff += 8;
         carrierIdx++;
      }

   }

   // <ui_update.png>
   public method updateFromPatchData_Internal() {

      if(0 == fp_matrix.numElements)
         return;

      int algorithm = getAlgorithm();
      if(debug >= 1)
         trace "[dbg] FMMatrix::updateFromPatchData_Internal: algorithm="+(algorithm+1);

      int c32Out             = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_TINT);
      int c32OutFb           = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_FB_TINT);
      int c32OutLvl0         = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_LVL0_TINT);
      int c32OutLvl0Fb       = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_LVL0_FB_TINT);
      int c32OutValid        = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_VALID_TINT);
      int c32OutValidFb      = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_VALID_FB_TINT);
      int c32OutInvalid      = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_INVALID_TINT);
      int c32OutInvalidIsMod = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_INVALID_IS_MOD_TINT);
      int c32OutActive       = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_ACTIVE_TINT);
      int c32OutInactive     = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_OUT_INACTIVE_TINT);
      int c32Mod             = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_MOD_TINT);
      int c32ModFb           = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_MOD_FB_TINT);
      int c32ModLvl0         = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_MOD_LVL0_TINT);
      int c32ModLvl0Fb       = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_MOD_LVL0_FB_TINT);
      int c32ModValid        = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_MOD_VALID_TINT);
      int c32ModValidFb      = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_MOD_VALID_FB_TINT);
      int c32ModInvalid      = app_lnf.getColor(AppLookAndFeel.COLOR_FMMATRIX_MAT_MOD_INVALID_TINT);

      int carrierIdx;
      int modIdx;
      int carrierIdxFP;
      int modIdxFP;
      byte lvl;
      char c;
      char cOther;

      // Update labels
      int opIdx = 0;
      loop(8)
      {
         Label lb <= top_labels[opIdx];
         lb.setCaption(String(op_map_fp_to_op[opIdx] + 1));

         lb <= left_labels[opIdx];
         lb.setCaption(String(op_map_fp_to_op[opIdx] + 1));

         opIdx++;
      }

      String sMat <= alg_matrices.get(algorithm);
      local String sMatPossible;

      // Create matrix that only includes active operators
      if(b_incremental && b_mat_possible_exact_valid && b_autoselect_alg)
      {
         sMatPossible = s_mat_possible_exact;
      }
      else
      {
         boolean bFeedback = (getFeedback() > 0);
         local String sMatUsed;
         buildActiveMatrix(sMat, sMatUsed, bFeedback);
         if(debug >= 1)
            debugPrintMat(sMatUsed, "updateFromPatch sMatUsed");

         if(b_autoselect_alg)
         {
            if(!b_incremental && b_exact)
               buildMatPossible_v2(sMatUsed, sMatPossible, -1/*fltCarrierIdx*/, -1/*fltModIdx*/);
            else
            {
               int tStart;
               if(b_debug_perf)
                  tStart = milliSeconds();
               buildMatPossible_v1(sMatUsed, sMatPossible);
               if(b_debug_perf)
                  trace "[pro] buildMatPossible_v1() took "+(milliSeconds()-tStart)+"ms";
               s_mat_possible_fast = sMatPossible;
            }
         }
         else
         {
            sMatPossible = sMatUsed;
         }
      }

      // (note) there _are_ differences
      // if(sMatPossiblev1 != sMatPossible)
      //    trace "xxx sMatPossiblev1<>v2 differs: v1=\""+sMatPossiblev1+"\" v2=\""+sMatPossible+"\"";

      if(debug >= 1)
         debugPrintMat(sMatPossible, "sMatPossible");

      if(debug >= 2)
      {
         trace "[trc] FMMatrix::updateFromPatchData_Internal: op_map_op_to_fp="+op_map_op_to_fp;
         trace "[trc] FMMatrix::updateFromPatchData_Internal: op_map_fp_to_op="+op_map_fp_to_op;
      }

      // Update levels and colorize FloatParams
      // syxOff = 164;  // Operator 1 voiced
      carrierIdx = 0;
      loop(8)
      {
         modIdx = 0;
         loop(8)
         {
            carrierIdxFP = op_map_op_to_fp[carrierIdx];
            modIdxFP     = op_map_op_to_fp[modIdx];
            FloatParam fp <= fp_matrix.get(carrierIdxFP*8 + modIdxFP);
            lvl = getOpLevel(modIdx);
            fp.setValue(lvl);
            fp.setEditable(true);
            fp.setEnableOutline(false);

            c = sMat.getc(carrierIdx*8 + modIdx);
            char cPossible = sMatPossible.getc(carrierIdx*8 + modIdx);

            int c32Bg = 0;

            // trace "xxx p=("+modIdx+";"+carrierIdx+") c="+tcchar(c)+" lvl="+lvl+" cPossible="+tcchar(cPossible);

            if( ('.' == c) || (0 == lvl) )
            {
               // not possible or unused in current alg

               if( (0 == lvl) && (carrierIdx==modIdx) && (-1 != "123456789f".indexOfChar(c, 0)) )
               {
                  // Unused output in current alg
                  c32Bg = ('f'==c)?c32OutLvl0Fb:c32OutLvl0;
                  fp.setEnableOutline(true);
               }
               else if( (0 == lvl) && (carrierIdx!=modIdx) && (-1 != "mf".indexOfChar(c, 0)) )
               {
                  // Unused modulator in current alg
                  c32Bg = ('f'==c)?c32ModLvl0Fb:c32ModLvl0;
                  fp.setEnableOutline(true);
               }
               else if('.' != cPossible)
               {
                  if(b_zero_valid)
                     fp.setValue(0);

                  if( (-1 != "123456789".indexOfChar(cPossible, 0)) || ((carrierIdx==modIdx) && 'f'==cPossible) )  // is possible output cell ?
                     c32Bg = ('f'==cPossible)?c32OutValidFb:c32OutValid;
                  else
                     c32Bg = ('f'==cPossible)?c32ModValidFb:c32ModValid;
               }
               else if('.' == c)
               {
                  // Not possible in current alg and matching algs
                  if(carrierIdx == modIdx)
                  {
                     c32Bg = c32OutInvalid;
                     if(b_zero_valid)
                        fp.setValue(0);
                     fp.setEditable(false);
                  }
                  else
                  {
                     c32Bg = c32ModInvalid;
                     if(b_zero_valid)
                        fp.setValue(0);
                     fp.setEditable(false);
                  }
               }
               else if(0)
               {
                  // Possible in current alg but not other algs (unreachable)
                  // trace "[~~~] FMMatrix::updateFromPatchData_FS1R: internal error (possible in current alg but not matching algs)";
                  // // c32Bg = #ffff0000;
                  if(b_zero_valid)
                     fp.setValue(0);
                  c32Bg = c32OutInvalidIsMod;
                  fp.setEditable(false);
               }
            }

            if(0 == c32Bg)
            {
               if( ('m' == c) || ((carrierIdx != modIdx) && 'f'==c) )  // is modulator cell ?
               {
                  if(carrierIdx == modIdx)
                  {
                     c32Bg = c32OutInvalid;
                     fp.setEditable(false);
                     if(b_zero_valid)
                        fp.setValue(0);
                  }
                  else
                  {
                     if(0 == lvl)
                     {
                        c32Bg = ('f'==c)?c32ModValidFb:c32ModValid;
                     }
                     else
                     {
                        c32Bg = ('f'==c) ? c32ModFb : c32Mod;
                        fp.setEnableOutline(true);
                     }
                  }
               }
               else if( (-1 != "123456789".indexOfChar(c, 0)) || ((carrierIdx==modIdx) && 'f'==c) )  // is output cell ?
                  c32Bg = (0 == lvl) ? (('f'==c)?c32OutValidFb:c32OutValid) : ((carrierIdx==modIdx) && 'f'==c) ? c32OutFb : c32Out;
            }

            if(0 == c32Bg)
            {
               // Possible in current alg but not other algs (unreachable)
               // trace "[~~~] FMMatrix::updateFromPatchData_Internal: internal error (possible in current alg but not matching algs)";
               // // c32Bg = #ffff0000;
               if(b_zero_valid)
                  fp.setValue(0);
               c32Bg = c32OutInvalidIsMod;
               fp.setEditable(false);
            }

            if(carrierIdx == modIdx)
            {
               if(fp.isEditable())
               {
                  c32Bg = UI.TintColor32(c32Bg, c32OutActive);
                  fp.setEnableOutline(true);
               }
               else
               {
                  c32Bg = UI.TintColor32(c32Bg, c32OutInactive);
               }
            }
            fp.setBackgroundTint(c32Bg);

            // Next column
            modIdx++;
         }

         // Next row
         carrierIdx++;
      }

      updateOperatorParams();

      fp_alg.setValue(getAlgorithm());
      cb_autoalg.setSelected(b_autoselect_alg);
      fp_fb.setValue(getFeedback());

      if(null != parent_synth_form_montage)
      {
         ComboField cf <= parent_synth_form_montage.cf_part_var;
         cm_var.setOptionsLong(cf.getOptions());
         cm_var.setSelectedOption(cf.getSelectedOption());
         cm_var.setEditable(true);
      }

      redraw();
      fm_matrix_alg_grid.redraw();
   }

   // <ui_update.png>
   public method updateFromPerformance_Montage_Internal(MontagePerformance perf) {
   }

   // <ui_update.png>
   protected method updateOperatorParams() {
      FMMatrixOp *op;
      foreach op in op_controls
         op.updateFromPatch();
   }

   // <ui_update.png>
   public method updateFromPatchData_Editor(boolean _bTabVisible) {
      if(!_bTabVisible)
      {
         b_updatefrompatchdata_editor_pending = true;
         return true;
      }

      if(debug >= 1)
         trace "[dbg] updateFromPatchData_Editor";

      if(b_incremental)
      {
         int algorithm = getAlgorithm();
         String sMat <= alg_matrices.get(algorithm);
         boolean bFeedback = (getFeedback() > 0);
         local String sMatUsed;
         buildActiveMatrix(sMat, s_mat_used, bFeedback);
         s_mat_possible_exact = s_mat_used;

         // if(debug >= 1)
         //    debugPrintMat(sMatUsed, "updateFromPatch sMatUsed");

         b_mat_possible_exact_valid = false;
         mat_possible_idx = 0;
         ta_matpossible.reschedule();
      }

      updateFromPatchData_Internal();

      updateMixPartPatches(false/*bUpdatePatchNr*/);

      if(null != parent_synth_form_montage)
         fp_aeg_scl_exp.setValue(parent_synth_form_montage.getAEGSclExp());
   }

   // <method_update.png>
   protected method calcMatPossibleIncremental_Internal() : boolean {
      // returns true if all calculations are done

      if(mat_possible_idx < (8*8))
      {
         buildMatPossible_v2(s_mat_used, s_mat_possible_exact, mat_possible_idx/8, mat_possible_idx&7);
         mat_possible_idx++;
         b_mat_possible_exact_valid = ((8*8) == mat_possible_idx);

         if(b_mat_possible_exact_valid)
         {
            if(0 || debug >= 1)
            {
               trace "[dbg] FMMatrix: incremental update finished: fast<>exact difference: "+(s_mat_possible_exact != s_mat_possible_fast);
               trace "xxx s_mat_possible_exact: \""+s_mat_possible_exact+"\"";
               trace "xxx s_mat_possible_fast : \""+s_mat_possible_fast+"\"";
            }
            updateFromPatchData_Internal();
         }

         return b_mat_possible_exact_valid;
      }
      return true;
   }

   // <method_update.png>
   public method calcMatPossibleIncremental() : boolean {
      return
         // // calcMatPossibleIncremental_Internal() ||
         // // calcMatPossibleIncremental_Internal() ||
         // // calcMatPossibleIncremental_Internal() ||
         // // calcMatPossibleIncremental_Internal() ||
         calcMatPossibleIncremental_Internal() ||
         calcMatPossibleIncremental_Internal() ||
         calcMatPossibleIncremental_Internal() ||
         calcMatPossibleIncremental_Internal() ;
   }

   // <method.png>
   protected method debugPrintMat(String _sMat, String _name) {
      trace "[dbg] ~~~~~~~~~~~~~~~~~~~~~~~~ MAT<"+_name+">";
      int opIdx = 0;
      loop(8)
      {
         trace "  \""+_sMat.substring(opIdx*8, 8)+"\"";
         opIdx++;
      }
   }

   // <method.png>
   protected method debugPrintAlg(int _algIdx, String _s) {
      trace "[dbg] ~~~~~~~~~~~~~~~~~~~~~~~~ algNr="+(_algIdx+1);
      int opIdx = 0;
      loop(8)
      {
         trace "  \""+_s.substring(opIdx*8*col_spread, 8*col_spread)+"\"";
         opIdx++;
      }
   }

   // <method.png>
   protected method debugPrintIntMat(IntArray _iaMat, int _w, IntArray _iaOpMap, String _name) {
      int h = _iaMat.numElements / _w;
      trace "[dbg] ~~~~~~~~~~~~~~~~~~~~~~~~ iaMat<"+_name+"> sz=("+_w+";"+h+")";
      int ry = 0;
      loop(h)
      {
         int rx = 0;
         stdout "   \"";
         loop(_w)
         {
            Integer io = _iaMat.get(ry*_w + rx);
            if(0 != io)
               io = (io < 0) ? (-_iaOpMap.get(-io - 1) - 1) : (_iaOpMap.get(io - 1) + 1);
            stdout io.printf("%3d ");
            rx++;
         }
         trace "\"";
         ry++;
      }
   }

   // <method.png>
   protected method fixOneToMany(String _s) {
      // e.g. "3..3" => "3___"
      int opIdx = 0;
      loop(8)
      {
         String sLine;
         _s.substring(opIdx*8*col_spread, 8*col_spread) => sLine;

         int modNr = 1;
         loop(7)
         {
            int num = 6;
            loop(6)
            {
               String s; s.empty();
               s.append(String(modNr));
               String r; r.empty();
               r.append(String(modNr));
               loop(num)
               {
                  s.append(".."+modNr);
                  r.append("___");
               }

               // trace "s=\""+s+"\" r=\""+r+"\"";

               sLine.replace(s, r);

               int fbIdx = 0;
               loop(8)
               {
                  sLine.replace(s.replace(tcchar('1'+fbIdx), tcchar('1'+fbIdx+128)),
                                r.replace(tcchar('1'+fbIdx), tcchar('1'+fbIdx+128))
                                );
                  fbIdx++;
               }

               num--;
            }

            modNr++;
         }

         sLine.replace("3-43-43-43-4", "3-4_________");
         sLine.replace("1-21-21-21-21-21-2", "1-2_______________");

         sLine.replace("3-43-43-43-4".replace("3", tcchar('3'+128)),
                       "3-4_________".replace("3", tcchar('3'+128))
                       );
         sLine.replace("1-21-21-21-21-21-2".replace("1", tcchar('1'+128)),
                       "1-2_______________".replace("1", tcchar('1'+128))
                       );

         _s.replaceRegion(opIdx*8*col_spread, (opIdx+1)*8*col_spread, sLine);

         opIdx++;
      }
   }

   // <method.png>
   protected method isColEmpty(String _sAlg, int _colIdx) : boolean {
      int opIdx = 0;
      loop(8)
      {
         char c = _sAlg[opIdx*8*col_spread + _colIdx];

         if( ('.' != c) && ('_' != c) )
            return false;
         opIdx++;
      }
      return true;
   }

   // <method.png>
   protected method shiftColLeft(String _sAlg, int _colIdx) {
      int opIdx = 0;
      loop(8)
      {
         int numCols = 8*col_spread - _colIdx - 1;
         int dstIdx = opIdx*8*col_spread + _colIdx;
         int srcIdx = opIdx*8*col_spread + _colIdx + 1;
         // trace "xxx shiftColLeft: colIdx="+_colIdx+" opIdx="+opIdx+" dstIdx="+dstIdx+" srcIdx="+srcIdx;

         loop(numCols)
            _sAlg[dstIdx++] = _sAlg[srcIdx++];

         _sAlg[srcIdx - 1] = '.';

         opIdx++;
      }
   }

   // <method.png>
   protected method fixEmptyCols(String _sAlg) {
      // (note) align left
      int colIdx = 0;
      loop(8*col_spread - 1)
      {
         if(isColEmpty(_sAlg, colIdx) && ((0 == colIdx) || isColEmpty(_sAlg, colIdx+1)))
         {
            // trace "xxx empty cols "+(colIdx+1)+";"+(colIdx+1+1);
            shiftColLeft(_sAlg, colIdx);
            if((0 == colIdx) && isColEmpty(_sAlg, colIdx))
               shiftColLeft(_sAlg, colIdx);
         }
         else
            colIdx++;
      }
      _sAlg.replace(".", " ");
   }

   // <method.png>
   protected method debugPrintMatAll(IntArray _iaMat) {
      trace "[dbg] ~~~~~~~~~~~~~~~~~~~~~~~~ MAT<all>";
      int opIdx = 0;
      loop(8)
      {
         stdout "  \"";
         int modIdx = 0;
         loop(8)
         {
            Integer ioCount = _iaMat.get(opIdx*8 + modIdx);
            stdout ioCount.printf("%03d ");
            modIdx++;
         }
         trace "\"";
         opIdx++;
      }
   }

   // <method.png>
   public method calcAllMatMask() {
      // ==> a triangle that fills half the 8x8 matrix area
      //      "-53 000 000 000 000 000 000 000"
      //      "023 -64 000 000 000 000 000 000"
      //      "013 020 -26 000 000 000 000 000"
      //      "006 006 039 -31 000 000 000 000"
      //      "002 002 016 036 -34 000 000 000"
      //      "001 002 008 010 035 -32 000 000"
      //      "001 002 006 008 004 036 -26 000"
      //      "002 003 008 012 015 024 062 -88"
      //        (- is output operator)
      IntArray iaAll;
      iaAll.allocAndFill(8*8, 0);

      int algIdx = 0;

      loop(alg_matrices.numElements)
      {
         String sMat <= alg_matrices[algIdx];
         int carrierIdx = 0;
         loop(8)
         {
            int modIdx = 0;
            loop(8)
            {
               char c = sMat.getc(carrierIdx*8 + modIdx);
               int cCount = iaAll[carrierIdx*8 + modIdx];
               if(carrierIdx == modIdx)
               {
                  if(-1 != "f12345678".indexOfChar(c, 0))
                  {
                     // output operator
                     iaAll[carrierIdx*8 + modIdx] = -(abs(cCount) + 1);
                  }
               }
               else if(-1 != "f12345678m".indexOfChar(c, 0))
               {
                  // modulation operator
                  iaAll[carrierIdx*8 + modIdx] = cCount + 1;
               }

               modIdx++;
            }

            carrierIdx++;
         }

         // Next alg
         algIdx++;
      }

      if(debug >= 1)
         debugPrintMatAll(iaAll);
   }

   // <method.png>
   public method sanitizeAlgOps() {
      // Remove empty columns, left-align, pretty-print 1:n routings
      int algIdx = 0;

      loop(alg_matrices.numElements)
      {
         String sAlg <= alg_ops[algIdx];

         fixOneToMany(sAlg);
         // // debugPrintAlg(algIdx, sAlg);
         fixEmptyCols(sAlg);
         // debugPrintAlg(algIdx, sAlg);

         algIdx++;
      }
   }

   // <method.png>
   public method calcAlgOps() {
      // Convert matrix-style alg description into Yamaha-style FS1R/Montage/MODX algorithm diagram
      int algIdx = 0;
      alg_ops.alloc(alg_matrices.numElements);
      String *sAlg;

      loop(alg_matrices.numElements)
      {
         String sMat  <= alg_matrices[algIdx];
         sAlg <= alg_ops.nextFree;
         loop(8)
            sAlg.appendRepeat(".", 8*col_spread);
         String s;

         IntArray lastCarrierModCol;
         lastCarrierModCol.allocAndFill(8, -1);
         IntArray lastCarrierModRow;
         lastCarrierModRow.allocAndFill(8, 6);
         int carrierIdx = 7;
         loop(8)
         {
            sMat.substring(carrierIdx*8, 8) => s;

            int modIdx = 7;
            int numMod = 0;
            loop(8)
            {
               // trace "................. carrier="+(carrierIdx+1)+" mod="+(modIdx+1);
               char c = s[modIdx];
               // trace "xxx modIdx="+modIdx+" c="+tcchar(c);

               int modRow = lastCarrierModRow[carrierIdx];

               if('1' <= c <= '8')
               {
                  // Bottom row (output op)
                  sAlg[7*8*col_spread + modIdx*col_spread + col_spread-1] = c;
                  // trace "xxx out carrier="+(carrierIdx+1)+" mod="+(modIdx+1)+" coff="+(7*16 + modIdx*2);
               }
               else if('f' == c)
               {
                  if(carrierIdx != modIdx)
                  {
                     c = 'm' + 128;
                  }
                  else
                  {
                     // Bottom row (output op)
                     sAlg[7*8*col_spread + carrierIdx*col_spread + col_spread-1] = '1'+carrierIdx + 128;
                  }
               }
               if('m' == (c&127))
               {
                  if(carrierIdx != modIdx)
                  {
                     // <carrierIdx> is modulated by <modIdx>
                     int modCol = lastCarrierModCol[carrierIdx];
                     // trace "xxx raw read modCol="+(modCol+1)+" for carrier="+(carrierIdx+1);
                     if(-1 == modCol)
                     {
                        // First modulator
                        modCol = carrierIdx*col_spread + col_spread-1;
                     }
                     else
                     {
                        // Next modulator
                        modCol -= 2;
                        // trace "xxx read modCol="+(modCol+1)+" for carrier="+(carrierIdx+1);
                        if(modCol < 0)
                           die "modCol < 0";
                     }
                     // trace "yyy old lastCarrierModCol["+carrierIdx+"]="+lastCarrierModCol[carrierIdx]+" new="+modCol;
                     lastCarrierModCol[carrierIdx] = modCol;

                     // Set column for next modulator modulating the current modulator
                     int modColN = lastCarrierModCol[modIdx];
                     int modColNNew = modCol + 2;
                     if( (-1 == modColN) || (modColNNew < modColN) )
                     {
                        // trace "xxx yyy carrier="+(carrierIdx+1)+" set next col for mod="+(modIdx+1)+" to "+(modCol+1+2-2);
                        lastCarrierModCol[modIdx] = modColNNew;  // def=stack on top. will be pre-decremented in next iteration.
                        lastCarrierModRow[modIdx] = modRow - 1;
                     }
                     // trace "xxx carrier="+(carrierIdx+1)+" mod="+(modIdx+1)+" modColN="+(lastCarrierModCol[modIdx]+1)+" modCol="+(modCol+1)+" modRow="+(modRow+1);

                     while('.' != sAlg[modRow*8*col_spread + modCol])
                        modRow--;
                     // trace "xxx sAlg[modRow*8 + modCol]="+tcchar(sAlg[modRow*8 + modCol]);

                     if(numMod > 0)
                        sAlg[modRow*8*col_spread + modCol + 1] = '-';

                     sAlg[modRow*8*col_spread + modCol] = '1' + modIdx + (c&128);

                     numMod++;
                  }
                  // else
                  //    sAlg[modIdx*8 + carrierIdx] = tcchar(modIdx+1);
               }

               lastCarrierModRow[carrierIdx] = modRow;

               // Next modulator
               modIdx--;
            } // loop 8

            carrierIdx--;
         }

         // Next algorithm
         algIdx++;
      }

   }

   // <method.png>
   public method buildWindowedMat(String sMat, int matW, int matH, int x, int y, int w, int h, IntArray retMat, IntArray retOpMap) : int {
      // returns new mat width
      //  (note) new height is (retMat.numElements/new_width)

      retMat.empty();
      retOpMap.empty();

      // e.g. "f.m4" => "abC"
      //
      //  or  "fmm." => "abc."
      //      "..m4"    "..cD"
      //
      //  or  "f2......" => "aB.."
      //      "f.3....."    "a.C."
      //      "f..4...."    "a..D"
      //
      //  or  "........"
      //      "...mm..." => ".ab."
      //      ".f..mm.."    "c.bD"
      //      "........"

      // Find vertical extents
      int firstY = y;
      int lastY = y;
      boolean bEmpty = true;
      String sRow;
      int cy = y;
      loop(matH - y)
      {
         sRow = sMat.substring(cy*matW + x, w);
         sRow.replace(".", " ");
         // trace "xxx cy="+cy+" sRow=\""+sRow+"\"";
         if(sRow.isBlank())
         {
            if(bEmpty)
               firstY = cy + 1;
         }
         else
         {
            bEmpty = false;
            lastY = cy;
         }
         cy++;
      }

      if(bEmpty)
      {
         // trace "xxx all rows empty";
         return 0;
      }

      int newH = (lastY - firstY) + 1;

      // Find horizontal extents
      bEmpty = true;
      int firstX = x;
      int lastX = x;
      int cx = x;
      boolean bColEmpty;
      loop(w)
      {
         // Is column empty ?
         bColEmpty = true;
         cy = y;
         loop(matH - y)
         {
            if('.' != sMat.getc(cy*matW + cx))
            {
               bColEmpty = false;
               break;
            }
            cy++;
         }

         // trace "cx="+cx+" bColEmpty="+bColEmpty;

         if(bEmpty)
         {
            if(bColEmpty)
            {
               firstX = cx + 1;
            }
            else
            {
               lastX = cx;
               bEmpty = false;
            }
         }
         else
         {
            if(!bColEmpty)
               lastX = mathMaxi(cx, lastX);
         }

         cx++;
      }

      int newW = (lastX - firstX) + 1;
      // trace "xxx buildWindowedMat: first=("+firstX+";"+firstY+") last=("+lastX+";"+lastY+") => newSz=("+newW+";"+newH+")";

      // build 'retMat'
      int finalW = 0;
      int finalH = 0;
      retMat.empty();
      cy = firstY;
      int ry = 0;
      int rx;
      loop(newH)
      {
         sRow = sMat.substring(cy*matW + x, w);
         sRow.replace(".", " ");
         // trace "xxx cy="+cy+" sRow=\""+sRow+"\"";
         if(!sRow.isBlank())
         {
            cx = firstX;
            rx = 0;
            loop(newW)
            {
               // Is column empty ?
               bColEmpty = true;
               int iy = y;
               loop(matH - y)
               {
                  if('.' != sMat.getc(iy*matW + cx))
                  {
                     bColEmpty = false;
                     break;
                  }
                  iy++;
               }

               // trace "xxx c=("+cx+";"+cy+") bColEmpty="+bColEmpty;

               if(!bColEmpty)
               {
                  char c = sMat.getc(cy*matW + cx);
                  int iMat;
                  if('.' == c)
                     iMat = 0;  // unused
                  else if( (-1 != "12345678".indexOfChar(c, 0)) || (cx==cy && 'f'==c) )
                     iMat = -(rx+1);  // output op
                  else
                     iMat = rx+1;  // modulator op

                  retMat.add(iMat);
                  if(0 == ry)
                     retOpMap.add(cx);
                  rx++;
               }

               cx++;
            }

            ry++;
         }

         cy++;
      }

      finalH = ry;
      finalW = retMat.numElements / finalH;

      // trace "xxx buildWindowedMat: finalSz=("+finalW+";"+finalH+")";

      return finalW;
   }

   // <method.png>
   public method buildAlgWindowCache() {

      int maskH = 1;
      loop(8) // maskH
      {
         int maskW = 1;
         loop(8) // maskW
         {
            int algIdx = 0;
            loop(alg_matrices.numElements/*88*/)
            {
               String sMatRaw <= alg_matrices[algIdx];

               int rawMatH = 8;
               while(rawMatH >= maskH)
               {
                  int rawMatW = 8;
                  while(rawMatW >= maskW)
                  {
                     int rawMatY = 0;
                     loop(8 - rawMatH + 1)
                     {
                        int rawMatX = 0;
                        loop(8 - rawMatW + 1)
                        {
                           IntArray iaWindow;
                           IntArray iaOpMap;
                           int windowW = buildWindowedMat(sMatRaw, 8, 8, rawMatX, rawMatY, rawMatW, rawMatH, iaWindow, iaOpMap);
                           int windowH = iaWindow.numElements / windowW;

                           if(windowW == maskW && windowH == maskH)
                           {
                              FMMatrixWindowCacheEntry en <= new FMMatrixWindowCacheEntry;
                              en.w       = windowW;
                              en.h       = windowH;
                              en.alg_idx = algIdx;
                              en.raw_x   = rawMatX;
                              en.raw_y   = rawMatY;
                              en.raw_w   = rawMatW;
                              en.raw_h   = rawMatH;
                              en.ia_mat  = iaWindow;
                              en.op_map  = iaOpMap;
                              // trace "xxx buildAlgWindowCache: maskSz=("+maskW+";"+maskH+") ia_mat="+iaWindow;
                              alg_window_cache.add(#(deref en));
                           }

                           rawMatX++;
                        }
                        rawMatY++;
                     }
                     rawMatW--;
                  } // loop rawMatW
                  rawMatH--;
               } // loop rawMatH
               algIdx++;
            } // loop alg
            maskW++;
         } // loop maskW
         maskH++;
      } // loop maskH

      trace "[dbg] FM matrix window cache has "+alg_window_cache.numElements+" entries";
   }

   // <save.png>
   public method saveAlgWindowCache(String _pathName) {
      local File f;
      if(f.openLocal(_pathName, IOS_OUT))
      {
         FMMatrixWindowCacheEntry *en;
         if(1)
         {
            local Buffer bRaw;
            bRaw.size = 1300*1024;
            bRaw.i32 = alg_window_cache.numElements;
            foreach en in alg_window_cache
            {
               en.saveState(bRaw);
            }
            local Buffer bComp;
            bComp.gzip(bRaw, 0, bRaw.offset, 9);
            f.i32 = bRaw.offset;
            f.writeBuffer(bComp, 0, bComp.size);
         }
         else
         {
            f.i32 = alg_window_cache.numElements;
            foreach en in alg_window_cache
            {
               en.saveState(f);
            }
         }

         trace "[dbg] wrote FM 8op matrix cache to \""+_pathName+"\" rawSize="+bRaw.offset+" compSize="+f.offset+" ("+(int(100*f.offset/1024)/100.0)+"kB)";

         f.close();
      }
   }

   // <load.png>
   public method loadAlgWindowCache(String _pathName) : boolean {
      local File f;
      if(f.openLocal(_pathName, IOS_IN))
      {
         Stream *ifs;
         if(1)
         {
            int rawSize = f.i32;
            // trace "xxx rawSize="+rawSize;
            local Buffer bComp;
            local Buffer bRaw;
            f.readBuffer(bComp, 0, f.size - 4, true/*bResize*/);
            bRaw.gunzip(bComp, 0, bComp.size, rawSize);
            // trace "xxx bComp.offset="+bComp.offset;
            // trace "xxx bRaw.size="+bRaw.size;

            bRaw.offset = 0;
            ifs <= bRaw;
         }
         else
            ifs <= f;

         int numCacheEntries = ifs.i32;
         alg_window_cache.free();
         loop(numCacheEntries)
         {
            FMMatrixWindowCacheEntry en <= new FMMatrixWindowCacheEntry;
            en.loadState(ifs);
            alg_window_cache.add(#(deref en));
         }
         f.close();
         return true;
      }
      return false;
   }

   // <method_find.png>
   public method findMatchingAlgs_cached(String  _sMask, int _maskW,
                                         IntArray _retAlgIndices, PointerArray _retOpMaps, IntArray _retOpMapUsed,
                                         boolean _bExactMatch
                                         ) {
      // mask values: 0=unused, 1=modulator op, 2=output op
      _retAlgIndices.empty();
      _retOpMaps.free();
      IntArray *retOpMap;
      int maskH = (_sMask.numChars)/_maskW;
      if(debug >= 1)
         trace "[dbg] FMMatrix::findMatchingAlgs: initial maskSz=("+_maskW+";"+maskH+")";// sMask.numChars="+_sMask.numChars;

      IntArray iaMaskWindowed;
      IntArray iaMaskOpMap;
      int maskW = buildWindowedMat(_sMask, _maskW, maskH, 0, 0, _maskW, maskH, iaMaskWindowed, iaMaskOpMap);
      if(debug >= 1)
         debugPrintIntMat(iaMaskWindowed, maskW, iaMaskOpMap, "windowed mask");
      if(0 == maskW)
      {
         // all levels 0 => all possible
         _retAlgIndices.identity(alg_matrices.numElements);
         loop(alg_matrices.numElements)
         {
            retOpMap <= new IntArray;
            retOpMap.identity(8);
            _retOpMaps.add(#(deref retOpMap));
         }
         return;
      }
      maskH = iaMaskWindowed.numElements / maskW;
      _retOpMapUsed = iaMaskOpMap;

      // Compare cache entries that match (compacted) mask size
      FMMatrixWindowCacheEntry *en;
      foreach en in alg_window_cache
      {
         if(en.w == maskW && en.h == maskH)
         {
            if(debug >= 2)
            {
               // trace "xxx findMatchingAlgs_cached: en.alg="+(en.alg_idx+1)+" maskSz=("+maskW+";"+maskH+")";
               debugPrintIntMat(en.ia_mat, maskW, en.op_map, "findMatchingAlgs_cached: en.alg="+(en.alg_idx+1)+" maskSz=("+maskW+";"+maskH+")");
            }
            IntArray iaAlgWindowed <= en.ia_mat;

            // if(0 == en.alg_idx)
            // {
               // trace "xxx cmp en.ia_mat="+en.ia_mat;
               // debugPrintIntMat(iaAlgWindowed, maskW, en.op_map, "cmp alg="+(en.alg_idx+1));
            // }

            boolean bMatch = true;
            int maskY = 0;
            loop(maskH)
            {
               int maskX = 0;
               loop(maskW)
               {
                  int iMat  = iaAlgWindowed [maskY*maskW + maskX];
                  int iMask = iaMaskWindowed[maskY*maskW + maskX];
                  // if( (iMask != iMat) )
                  // if( (0 != iMask) && (iMask != iMat) )
                  if( (_bExactMatch && (iMask != iMat)) || (!_bExactMatch && (0 != iMask) && (iMask != iMat)) )
                  {
                     bMatch = false;
                     break;
                  }
                  maskX++;
               }

               if(!bMatch)
                  break;

               maskY++;
            }

            if(bMatch)
            {
               // (note) there may be multiple matches (with different x/y offsets) for the same algorithm
               // // if(!_retAlgIndices.contains(en.alg_idx))
               // // {
                  _retAlgIndices.add(en.alg_idx);
                  retOpMap <= new IntArray;
                  retOpMap = en.op_map;
                  _retOpMaps.add(#(deref retOpMap));

                  if(debug >= 2)
                  {
                     trace "[dbg] FMMatrix::buildWindowedMat: bMatch=true alg="+(en.alg_idx+1)+" rawMatPos=("+en.raw_x+";"+en.raw_y+") maskSz=("+maskW+";"+maskH+")";
                     debugPrintIntMat(iaMaskWindowed, maskW, iaMaskOpMap, "mask");
                     debugPrintIntMat(iaAlgWindowed,  maskW, en.op_map,   "alg");
                  }
               // // }
            }

         } // if windowed sizes match
      } // foreach cache entry
   }

   // <method.png>
   protected method countCommonOps(IntArray opMap, IntArray opMapUsed) : int {
      if(opMap.numElements == opMapUsed.numElements)
      {
         int r = 0;
         int idx = opMap.numElements;
         while(--idx >= 0)
         {
            if(opMap[idx] == opMapUsed[idx])
               r++;
            else
               break;
         }
         return r;
      }
      else if(debug >= 2)
      {
         // reached when opMapUsed is empty
         trace "\n\n\n\n countCommonOps: numElements differs, opMap="+opMap+" opMapUsed="+opMapUsed+"\n\n\n\n";
      }
      return 0;
   }

   // <method_find.png>
   protected method findMatchingAlgsSorted(String _sMask, int _maskW, IntArray retAlgIndices, IntArray retOpMapUsed) : PointerArray {
      // IntArray     algIndices <= retAlgIndices;
      // PointerArray opMaps     <= retOpMaps.objectValue;
      IntArray     opMapUsed  <= retOpMapUsed;

      local IntArray     algIndicesExact;
      local PointerArray opMapsExact;
      local IntArray     algIndicesFuzzy;
      local PointerArray opMapsFuzzy;
      findMatchingAlgs_cached(_sMask, 8, algIndicesExact, opMapsExact, opMapUsed, true/*bExactMatch*/);
      findMatchingAlgs_cached(_sMask, 8, algIndicesFuzzy, opMapsFuzzy, opMapUsed, false/*bExactMatch*/);
      local IntArray iaCommonOpCountsExact;
      local IntArray iaCommonPossibleIndicesExact;
      local IntArray iaCommonOpCountsFuzzy;
      local IntArray iaCommonPossibleIndicesFuzzy;
      local IntArray iaCommonSortExact;
      local IntArray iaCommonSortFuzzy;

      int possibleIdx;
      int algorithmNew;
      IntArray *opMap;

      possibleIdx = 0;
      loop(algIndicesExact.numElements)
      {
         algorithmNew = algIndicesExact[possibleIdx];
         opMap <= opMapsExact[possibleIdx];
         if(debug >= 2)
         {
            // trace "xxx exact other p=("+modIdx+";"+carrierIdx+") possibleIdx="+possibleIdx+" algorithmNew="+(algorithmNew+1)+" bAllowUpdate="+bAllowUpdate+" opMap="+opMap+" opMapUsed="+opMapUsed;
            trace "xxx exact possibleIdx="+possibleIdx+" algorithmNew="+(algorithmNew+1)+" opMap="+opMap+" opMapUsed="+opMapUsed;
         }
         iaCommonPossibleIndicesExact.add(possibleIdx);
         iaCommonOpCountsExact.add(countCommonOps(opMap, opMapUsed));
         possibleIdx++;
      }

      possibleIdx = 0;
      loop(algIndicesFuzzy.numElements)
      {
         algorithmNew = algIndicesFuzzy[possibleIdx];
         opMap <= opMapsFuzzy[possibleIdx];
         if(debug >= 2)
         {
            // trace "xxx fuzzy other p=("+modIdx+";"+carrierIdx+") possibleIdx="+possibleIdx+" algorithmNew="+(algorithmNew+1)+" bAllowUpdate="+bAllowUpdate+" opMap="+opMap+" opMapUsed="+opMapUsed;
            trace "xxx fuzzy possibleIdx="+possibleIdx+" algorithmNew="+(algorithmNew+1)+" opMap="+opMap+" opMapUsed="+opMapUsed;
         }
         iaCommonPossibleIndicesFuzzy.add(possibleIdx);
         iaCommonOpCountsFuzzy.add(countCommonOps(opMap, opMapUsed));
         possibleIdx++;
      }

      iaCommonOpCountsExact.sortByValue(iaCommonSortExact);
      iaCommonSortExact.reverse();
      iaCommonOpCountsExact.rearrange(iaCommonSortExact);
      algIndicesExact      .rearrange(iaCommonSortExact);
      opMapsExact          .rearrange(iaCommonSortExact);

      iaCommonOpCountsFuzzy.sortByValue(iaCommonSortFuzzy);
      iaCommonSortFuzzy.reverse();
      iaCommonOpCountsFuzzy.rearrange(iaCommonSortFuzzy);
      algIndicesFuzzy      .rearrange(iaCommonSortFuzzy);
      opMapsFuzzy          .rearrange(iaCommonSortFuzzy);

      if(debug >= 2)
      {
         trace "xxx iaCommonOpCountsExact="+iaCommonOpCountsExact;
         trace "xxx iaCommonOpCountsFuzzy="+iaCommonOpCountsFuzzy;
      }

      if(algIndicesExact.numElements > 0)
      {
         if(algIndicesFuzzy.numElements > 0)
         {
            if(iaCommonOpCountsFuzzy[0] > iaCommonOpCountsExact[0])
            {
               retAlgIndices = deref algIndicesFuzzy;
               return deref opMapsFuzzy;
            }
            else
            {
               retAlgIndices = deref algIndicesExact;
               return deref opMapsExact;
            }
         }
         else
         {
            retAlgIndices = deref algIndicesExact;
            return deref opMapsExact;
         }
      }
      else
      {
         retAlgIndices = deref algIndicesFuzzy;
         return deref opMapsFuzzy;
      }
   }

   // <method_find.png>
   protected method findAlgorithmForEditedCell(int carrierIdx, int modIdx, String sMat, boolean bFeedback, boolean bAllowUpdate) : int {
      local String sMatUsed;
      buildActiveMatrix(sMat, sMatUsed, bFeedback);

      // Mark new cell as used
      if(carrierIdx == modIdx)
         sMatUsed[carrierIdx*8 + modIdx] = '1' + carrierIdx;
      else
         sMatUsed[carrierIdx*8 + modIdx] = 'm';

      if(debug >= 1)
         debugPrintMat(sMatUsed, "required sMatUsed");

      local IntArray      algIndices;
      local PointerArray *opMaps;
      local IntArray      opMapUsed;
      int possibleIdx;
      IntArray *opMap;
      int algorithmNew;

      // findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, true/*bExactMatch*/);
      // if(0 == algIndices.numElements)
      //    findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, false/*bExactMatch*/);

      opMaps <= findMatchingAlgsSorted(sMatUsed, 8, algIndices, opMapUsed);

      // // // // original:
      // // // findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, true/*bExactMatch*/);
      // // // if(0 == algIndices.numElements)
      // // //    findMatchingAlgs_cached(sMatUsed, 8, algIndices, opMaps, opMapUsed, false/*bExactMatch*/);

      if(algIndices.numElements > 0)
      {
         possibleIdx = 0;
         if(1)
         {
            // Try to find alternative alg that does not require operator swapping
            loop(algIndices.numElements)
            {
               opMap <= opMaps[possibleIdx];
               if(opMapUsed == opMap)
               {
                  algorithmNew = algIndices[possibleIdx];
                  if(debug >= 1)
                     trace "[dbg] FMMatrix::handleMatrixFloatParamChanged: switch to alg="+(algorithmNew+1)+" w/o op swap. bAllowUpdate="+bAllowUpdate;
                  break; // found
               }

               possibleIdx++;
            }
         }
         else
            possibleIdx = algIndices.numElements;

         // // if(possibleIdx == algIndices.numElements)
         // // {
         // //    // Try to find alternative alg that does not require operator swapping
         // //    possibleIdx = 0;
         // //    loop(algIndices.numElements)
         // //    {
         // //       opMap <= opMaps[possibleIdx];
         // //       if(opMapUsed == opMap)
         // //       {
         // //          algorithmNew = algIndices[possibleIdx];
         // //          trace "[dbg] FMMatrix::handleMatrixFloatParamChanged: switch to alg="+(algorithmNew+1)+" w/o op swap. bAllowUpdate="+bAllowUpdate;
         // //          break; // found
         // //       }

         // //       possibleIdx++;
         // //    }
         // // }

         if(possibleIdx == algIndices.numElements)
         {
            possibleIdx = 0;
            loop(algIndices.numElements)
            {
               algorithmNew = algIndices[possibleIdx];
               String sMatOther <= alg_matrices.get(algorithmNew);
               // // if('.' != sMatOther[carrierIdx*8 + modIdx])
               // // {
                  opMap <= opMaps[possibleIdx];
                  if(debug >= 1)
                     trace "xxx other p=("+modIdx+";"+carrierIdx+") possibleIdx="+possibleIdx+" algorithmNew="+(algorithmNew+1)+" bAllowUpdate="+bAllowUpdate+" opMap="+opMap+" opMapUsed="+opMapUsed;
                  break;
               // // }

               possibleIdx++;
            }

            if(possibleIdx != algIndices.numElements)
            {
               if(bAllowUpdate)
               {
                  // Fallback: switch to first matching alg and swap operators
                  opMap <= opMaps[possibleIdx];

                  if(debug >= 1)
                     trace "[dbg] FMMatrix::handleMatrixFloatParamChanged: switch to alg="+(algorithmNew+1)+" and swap ops, opMap="+opMap;

                  if(debug >= 2)
                  {
                     trace "xxx opMap<cur>="+opMapUsed;
                     trace "xxx opMap<new>="+opMap;
                  }

                  // (todo) swap modulation targets
                  if(null != parent_synth_form_fs1r)
                  {
                     parent_synth_form_fs1r.swapVoicedOpsByArray(opMapUsed, opMap,
                                                                 op_map_fp_to_op,
                                                                 EditMIDISynthFormFS1R.PARAMSET_OP_ALL,
                                                                 true/*bSwapOpLevel*/
                                                                 );
                     calcOpMapOpToFP();
                     parent_synth_form_fs1r.updateUIFromPatchEx(false/*bFX*/, false/*bFMMatrix*/);
                  }
                  else
                  {
                     parent_synth_form_montage.swapVoicedOpsByArray(opMapUsed, opMap,
                                                                    op_map_fp_to_op,
                                                                    EditMIDISynthFormFS1R.PARAMSET_OP_ALL,
                                                                    true/*bSwapOpLevel*/
                                                                    );
                     calcOpMapOpToFP();
                     parent_synth_form_montage.updateUIFromPatchEx(false/*bPatchNames*/, false/*bFMMatrix*/, false/*bPartMixCopyOptions*/);
                  }

               }
            }
            else
            {
               trace "[~~~] FMMatrix::handleMatrixFloatParamChanged: internal error: no matching alg found for fp_xy=("+modIdx+";"+carrierIdx+")";
               return -1;
            }
         }

         if(bAllowUpdate)
         {
            // Store new algorithm in patch data + send update to synth
            setAlgorithm(algorithmNew);
         }

         return algorithmNew;
      }
      else
      {
         if(debug >= 1)
            trace "[~~~] FMMatrix::handleMatrixFloatParamChanged: internal error: no matching algs";
         return -1;
      }
   }

   // <ui_handle.png>
   protected =replay= method handleAlgorithmChanged() {
      byte alg = fp_alg.getFloatValue();
      setAlgorithm(alg);
      ta_updateall.reschedule();
      fm_matrix_alg_grid.redraw();

      if(null != parent_synth_form_fs1r)
      {
         // workaround for synth? issue: resending "Filter SW" fixes/works-around occasional silence-after-alg-change issue
         parent_synth_form_fs1r.handleAlgorithmChangedPost();
      }

      Global.PrintFast("Algorithm is "+(alg+1));
   }

   // <ui_handle.png>
   protected =replay= method handleAutoSelectAlgorithmChanged() {
      b_autoselect_alg = cb_autoalg.isSelected();
      Global.PrintFast("Auto-select algorithm is "+Utils.GetEnableString(b_autoselect_alg));

      updateFromPatchData_Internal();
   }

   // <ui_handle.png>
   protected =replay= method handleFeedbackChanged() {
      byte fb = fp_fb.getFloatValue();
      setFeedback(fb);
      Global.PrintFast("Feedback is "+fb);
   }

   // <ui_handle.png>
   protected =replay= method handlePartChanged(int _partIdx) {
      if(null != parent_synth_form_fs1r)
         parent_synth_form_fs1r.selectPart(_partIdx, true/*bAllowSolo*/, false/*bQuiet*/);
      else if(null != parent_synth_form_montage)
         parent_synth_form_montage.selectPart(_partIdx, true/*bAllowSolo*/, false/*bQuiet*/);
   }

   // <ui_handle.png>
   protected =replay= method handleMatrixFloatParamChanged(FloatParam fp, int fpIdx) {

      int tStart;
      if(b_debug_perf)
         tStart = milliSeconds();

      byte lvl = fp.getFloatValue();
      if(debug >= 1)
         trace "[dbg] -------------------------- handleMatrixFloatParamChanged: fpIdx="+fpIdx+" lvl="+lvl;

      int opIdx;

      boolean bFeedback = (getFeedback() > 0);

      int carrierIdx = op_map_fp_to_op[fpIdx / 8];
      int modIdx     = op_map_fp_to_op[fpIdx & 7];

      byte lvlOld = getOpLevel(modIdx);

      // Switch algorithm if required
      //  (todo) check if old lvl was >0  BUT: lvl may be equal but new routing necessary (1:n modulation)
      // if( (0 == lvlOld) && (lvl > 0) )
      if( (lvl > 0) )
      {
         int algorithmCur = getAlgorithm();
         String sMat <= alg_matrices.get(algorithmCur);

         char c = sMat[carrierIdx*8 + modIdx];

         if( ('.' == c) || ( (carrierIdx == modIdx) && (-1 == "123456789f".indexOfChar(c, 0)) ) )
         {
            // routing not possible in current algorithm => pick other, matching alg
            if(debug >= 1)
               trace "[dbg] FMMatrix::handleMatrixFloatParamChanged: routing not possible in current alg="+(algorithmCur+1)+" => change alg";
            findAlgorithmForEditedCell(carrierIdx, modIdx, sMat, bFeedback, true/*bAllowUpdate*/);
         } // if routing not possible with current alg
         else
         {
            // routing is possible but try to find ideal algorithm
            //  (note) e.g. for alg 7/8 corner case
            if(0)
            {
               int algorithmNew = findAlgorithmForEditedCell(carrierIdx, modIdx, sMat, bFeedback, false/*bAllowUpdate*/);
               if(algorithmNew != algorithmCur)
               {
                  if(debug >= 1)
                     trace "[dbg] FMMatrix::handleMatrixFloatParamChanged: routing OK, switch from alg="+(algorithmCur+1)+" to ideal algorithmNew="+(algorithmNew+1)+" ??";
                  // String sMatIdeal <= alg_matrices.get(algorithmNew);
                  // when activation of op causes side-effects like multiple modulation, switch to exact-match algorithm
                  //  if it doesn't, keep the current algorithm
                  boolean bUnique = true;
                  // // if(carrierIdx != modIdx)  // activating a modulator ?
                  // // {
                  // //    int carrierIdx2 = 0;
                  // //    loop(8)
                  // //    {
                  // //       // if(carrierIdx2 != carrierIdx)
                  // //       // {
                  // //          if('.' != sMat[carrierIdx2*8 + modIdx])
                  // //          {
                  // //             bUnique = false;
                  // //             break;
                  // //          }
                  // //       // }
                  // //       carrierIdx2++;
                  // //    }
                  // // }
                  // // bUnique = 0; // xxxxxxxxxxxxxxxxxx

                  if(!bUnique)
                  {
                     // Switch to ideal algorithm (e.g. 8 preferable to 7 when op1 modulates only op2)
                     if(debug >= 1)
                        trace "[dbg] FMMatrix::handleMatrixFloatParamChanged: switch from alg="+(algorithmCur+1)+" to ideal algorithmNew="+(algorithmNew+1);
                     findAlgorithmForEditedCell(carrierIdx, modIdx, sMat, bFeedback, true/*bAllowUpdate*/);
                  }
               }
            }
         }

         algorithmCur = getAlgorithm();
         sMat <= alg_matrices.get(algorithmCur);
         carrierIdx = op_map_fp_to_op[fpIdx / 8];
         modIdx     = op_map_fp_to_op[fpIdx & 7];

         if('.' != sMat[carrierIdx*8+modIdx])
         {
            if(modIdx == carrierIdx)
               Global.PrintFast("Op "+(modIdx+1)+" output level is "+lvl);
            else
               Global.PrintFast("Op "+(modIdx+1)+" modulates Op "+(carrierIdx+1)+" by "+lvl);
         }
         else
         {
            Global.PrintFast("Fix invalid routing: carrier="+(carrierIdx+1)+" modulator="+(modIdx+1));
         }

      } // if lvl > 0
      else
      {
         // // if('.' != sMat[carrierIdx*8+modIdx])
         // // {
            if(modIdx == carrierIdx)
               Global.PrintFast("Op "+(modIdx+1)+" output level is 0");
            else
               Global.PrintFast("Op "+(modIdx+1)+" stops modulating Op "+(carrierIdx+1));
         // // }
         // // else
         // // {
         // //    Global.PrintFast("Fix invalid routing: carrier="+(carrierIdx+1)+" modulator="+(modIdx+1));
         // // }
      }

      // Store new level in patch data
      opIdx = op_map_fp_to_op[fpIdx & 7];
      setOpLevel(opIdx, lvl);
      // Global.PrintFast("Op "+(opIdx+1)+" level is "+lvl);

      if(b_debug_perf)
         trace "[pro] handleMatrixFloatParamChanged() took "+(milliSeconds()-tStart)+"ms until updateFromPatchData_FS1R_*()";

      // Update matrix widgets
      if( b_autoselect_alg && ( (0 == lvlOld) ^ (0 == lvl) ) )
      {
         updateFromPatchData_Editor(true/*bTabVisible*/);
      }
      else
         updateFromPatchData_Internal();
   }

   // <ui_handle.png>
   protected method handleSort() {
      op_map_fp_to_op.identity(8);
      op_map_op_to_fp.identity(8);

      // Update matrix widgets
      updateFromPatchData_Internal();

      ta_sort.cancel();

      Global.Print("Sort operators");
   }

   // <ui_handle.png>
   protected method handleClear(boolean _bResetAlgorithm) {
      op_map_fp_to_op.identity(8);
      op_map_op_to_fp.identity(8);

      int opIdx = 0;
      loop(8)
         setOpLevel(opIdx++, 0);

      if(_bResetAlgorithm)
         setAlgorithm(0);

      // Update matrix widgets
      updateFromPatchData_Editor(true/*bTabVisible*/);

      Global.Print("Reset operator levels"+(_bResetAlgorithm?" and select algorithm 1":""));
   }

   // <ui_handle.png>
   public =replay= method changeAlgorithmDelta(int _delta) {

      int algorithm = getAlgorithm();
      algorithm = mathWrapi(algorithm + _delta, 0, 88);
      // // algorithm = mathClampi(algorithm + _delta, 0, 88);
      setAlgorithm(algorithm);

      // Update matrix widgets
      redraw();
      ta_updateall.reschedule();
   }

   // <ui_handle.png>
   public =replay= method changeAlgorithmAbs(int _alg) {
      setAlgorithm(_alg);

      // Update matrix widgets
      redraw();
      ta_updateall.reschedule();
   }

   // <ui_handle.png>
   public =replay= method randomizeAlgorithm() {
      int algorithm = mathClampi(rand(100), 0, 87);
      changeAlgorithmAbs(algorithm);
      redraw();
      Global.Print("Randomize algorithm ("+(algorithm+1)+")");
   }

   // <ui_handle.png>
   public =replay= method randomizeOpLevels(boolean _bGreaterZero) {

      int opIdx = 0;
      loop(8)
      {
         byte lvl = getOpLevel(opIdx);

         if(_bGreaterZero)
         {
            if(lvl > 0)
               lvl = mathClampi(rand(100), 1, 100);
         }
         else
         {
            lvl = mathClampi(rand(100), 0, 100);
         }

         setOpLevel(opIdx++, lvl);
      }

      updateFromPatchData_Internal();
      redraw();

      Global.Print("Randomize Op levels"+(_bGreaterZero?" > 0":""));
   }

   // <ui_handle.png>
   public =replay= method cycleOpLevels() {

      byte lvlFirst = -1;
      byte idxFirst = -1;
      byte idxPrev  = -1;

      int opIdx = 0;
      loop(8)
      {
         byte lvl = getOpLevel(opIdx);

         if(lvl > 0)
         {
            if(-1 == idxFirst)
            {
               idxFirst = opIdx;
               lvlFirst = lvl;
            }

            if(-1 != idxPrev)
            {
               setOpLevel(idxPrev, lvl);
            }

            idxPrev = opIdx;
         }

         opIdx++;
      }

      if(-1 != idxFirst)
      {
         if(-1 != idxPrev)
            setOpLevel(idxPrev, lvlFirst);
      }

      updateFromPatchData_Internal();
      redraw();

      Global.Print("Cycle (active) Op levels");
   }

   // <ui_handle.png>
   public =replay= method shuffleOpLevels() {

      byte lvlFirst = -1;
      byte idxFirst = -1;
      byte idxPrev  = -1;

      local IntArray iaActiveOps;
      local IntArray iaOpLevels;
      iaOpLevels.allocAndFill(8, 0);

      byte lvl;
      int opIdx = 0;
      loop(8)
      {
         lvl = getOpLevel(opIdx);

         if(lvl > 0)
         {
            iaActiveOps.add(opIdx);
            iaOpLevels[opIdx] = lvl;
         }

         opIdx++;
      }

      if(!iaActiveOps.isEmpty())
      {
         int idx;
         local IntArray iaShuffledOps;
         loop(iaActiveOps.numElements)
         {
            for(;;)
            {
               idx = rand(iaActiveOps.numElements);
               opIdx = iaActiveOps[idx];
               if(!iaShuffledOps.contains(opIdx))
               {
                  iaShuffledOps.add(opIdx);
                  break;
               }
            }
         }
         // Global.Debug("FMMatrix::shuffleOpLevels: iaShuffledOps="+iaShuffledOps);

         opIdx = 0;
         idx = 0;
         loop(8)
         {
            lvl = iaOpLevels[opIdx];
            if(lvl > 0)
               setOpLevel(iaShuffledOps[idx++], lvl);
            opIdx++;
         }
      }

      updateFromPatchData_Internal();
      redraw();

      Global.Print("Shuffle "+iaActiveOps.numElements+" (active) Op level"+Utils.GetPluralString(iaActiveOps.numElements));
   }

   // <method_get.png>
   public method getOpVMuteMask() : byte {
      if(null != parent_synth_form_fs1r)
      {
         MIDISynthProfileDataFS1R dataFS1R <= parent_synth_form_fs1r.data;
         return dataFS1R.opv_mute_mask;
      }
      else
      {
         MIDISynthProfileDataMontage dataMontage <= parent_synth_form_montage.data;
         return dataMontage.opv_mute_mask;
      }
   }

   // <method_get.png>
   public method getOpNMuteMask() : byte {
      if(null != parent_synth_form_fs1r)
      {
         MIDISynthProfileDataFS1R dataFS1R <= parent_synth_form_fs1r.data;
         return dataFS1R.opn_mute_mask;
      }
      else
      {
         // (note) Montage has no unvoiced operators
         return 0;
      }
   }

   // <method.png>
   public toggleOpVMute(byte _opIdx) {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R
         parent_synth_form_fs1r.toggleOpVMute(_opIdx);
      }
      else
      {
         // Montage
         parent_synth_form_montage.toggleOpVMute(_opIdx);
      }
   }

   // <method.png>
   public toggleOpNMute(byte _opIdx) {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R
         parent_synth_form_fs1r.toggleOpNMute(_opIdx);
      }
      else
      {
         // (note) Montage has no unvoiced operators
      }
   }

   // <ui_handle.png>
   protected =replay= method handleOpVMuteChanged(int _opIdx) {
      CheckBox cb <= opv_mute_checkboxes.get(_opIdx);

      int opMask = ( (false == cb.isSelected()) << _opIdx);
      if( (getOpVMuteMask() & (1 << _opIdx)) ^ opMask )
      {
         toggleOpVMute(_opIdx);
      }
   }

   // <ui_handle.png>
   protected =replay= method handleOpNMuteChanged(int _opIdx) {
      CheckBox cb <= opn_mute_checkboxes.get(_opIdx);
      int opMask = ( (false == cb.isSelected()) << _opIdx);
      if( (getOpNMuteMask() & (1 << _opIdx)) ^ opMask )
         toggleOpNMute(_opIdx);
   }

   // <ui_handle.png>
   protected =replay= method toggleMuteAllOpV(boolean _bInvert) {
      CheckBox *cb;
      int opVMuteMask = getOpVMuteMask();
      int opIdx;
      int numChanged = 0;
      if(_bInvert)
      {
         opIdx = 0;
         loop(8)
         {
            toggleOpVMute(opIdx++);
            numChanged++;
         }
      }
      else
      {
         if(0 == opVMuteMask)
         {
            // Mute all
            opIdx = 0;
            loop(8)
            {
               toggleOpVMute(opIdx++);
               numChanged++;
            }
         }
         else
         {
            // Unmute all
            opIdx = 0;
            loop(8)
            {
               if(opVMuteMask & (1 << opIdx))
               {
                  toggleOpVMute(opIdx);
                  numChanged++;
               }
               opIdx++;
            }
         }
      }

      Global.Print("Update "+numChanged+" voiced operator mute state"+Utils.GetPluralString(numChanged));
   }

   // <ui_handle.png>
   protected =replay= method toggleMuteAllOpN(boolean _bInvert) {
      if(null != parent_synth_form_fs1r)
      {
         CheckBox *cb;
         int opNMuteMask = getOpNMuteMask();
         int opIdx;
         int numChanged = 0;
         if(_bInvert)
         {
            opIdx = 0;
            loop(8)
            {
               toggleOpNMute(opIdx++);
               numChanged++;
            }
         }
         else
         {
            if(0 == opNMuteMask)
            {
               // Mute all
               opIdx = 0;
               loop(8)
               {
                  toggleOpNMute(opIdx++);
                  numChanged++;
               }
            }
            else
            {
               // Unmute all
               opIdx = 0;
               loop(8)
               {
                  if(opNMuteMask & (1 << opIdx))
                  {
                     toggleOpNMute(opIdx);
                     numChanged++;
                  }
                  opIdx++;
               }
            }
         }

         Global.Print("Update "+numChanged+" unvoiced operator mute state"+Utils.GetPluralString(numChanged));
      }
   }

   // <ui_handle.png>
   protected method lazyUpdateOpMuteCheckBoxes() {
      int opVMuteMask = getOpVMuteMask();
      int opNMuteMask = getOpNMuteMask();
      int opIdx = 0;
      loop(8)
      {
         // (note) CheckBox redraws when state changed
         CheckBox cb <= opv_mute_checkboxes.get(opIdx);
         cb.setSelected(0 == (opVMuteMask & (1 << opIdx)));

         if(null != parent_synth_form_fs1r)
         {
            cb <= opn_mute_checkboxes.get(opIdx);
            cb.setSelected(0 == (opNMuteMask & (1 << opIdx)));
         }

         opIdx++;
      }

      updatePartButtons();
   }

   // <method_get.png>
   public method getCurrentPartIdx() : byte {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R
         MIDISynthProfileDataFS1R dataFS1R <= parent_synth_form_fs1r.data;
         return dataFS1R.current_part_idx;
      }
      else
      {
         // Montage
         MIDISynthProfileDataMontage dataMontage <= parent_synth_form_montage.data;
         return dataMontage.current_part_idx;
      }
   }

   // <method_get.png>
   public method getSoloPart() : boolean {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R
         MIDISynthProfileDataFS1R dataFS1R <= parent_synth_form_fs1r.data;
         return dataFS1R.b_solo_part;
      }
      else
      {
         // Montage
         MIDISynthProfileDataMontage dataMontage <= parent_synth_form_montage.data;
         return dataMontage.b_solo_part;
      }
   }

   // <ui_update.png>
   protected method updatePartButtons() {
      int partIdx = 0;
      Button *bt;
      int currentPartIdx = getCurrentPartIdx();
      boolean bMulti = (null != parent_synth_form_montage) || (null != parent_synth_form_fs1r.multi_patch);
      boolean bSolo = getSoloPart();
      foreach bt in part_buttons
      {
         bt.setEditable( (0 == partIdx) || bMulti );

         if(partIdx++ == currentPartIdx)
         {
            bt.setToggleState(true);
            if(bSolo)
               bt.setBackgroundTint(#b0ffff00);
            else
               bt.setBackgroundTint(#1800ff00);
         }
         else
         {
            bt.setToggleState(false);
            bt.setBackgroundTint(0);
         }
         bt.redraw();
      }
   }

   // <ui_handle.png>
   protected method handleLevelDeltaChanged() {
      byte delta = fp_lvl_delta.getFloatValue();
      FloatParam *fp;
      foreach fp in fp_matrix
      {
         fp.setStepCoarse(delta);
      }
      Global.PrintFast("Level delta is "+delta);
   }

   // <method_get.png>
   public method getSelectedOpParameterSetMask() : int {
      int r = 0;

      if(cb_sel_osc.isSelected())
         r |= EditMIDISynthFormFS1R.PARAMSET_OP_OSC;

      if(cb_sel_freq.isSelected())
         r |= EditMIDISynthFormFS1R.PARAMSET_OP_FREQ;

      if(cb_sel_peg.isSelected())
         r |= EditMIDISynthFormFS1R.PARAMSET_OP_PEG;

      if(cb_sel_aeg.isSelected())
         r |= EditMIDISynthFormFS1R.PARAMSET_OP_AEG_LEVEL | EditMIDISynthFormFS1R.PARAMSET_OP_AEG_TIME;

      if(cb_sel_levelscl.isSelected())
         r |= EditMIDISynthFormFS1R.PARAMSET_OP_LEVELSCL;

      if(cb_sel_sense.isSelected())
         r |= EditMIDISynthFormFS1R.PARAMSET_OP_SENSE;

      return r;
   }

   // <ui_update.png>
   public method updateUIFromPatchEx(boolean _bFX, boolean _bFMMatrix) {
      if(null != parent_synth_form_fs1r)
      {
         // FS1R
         parent_synth_form_fs1r.updateUIFromPatchEx(_bFX, _bFMMatrix);
      }
      else
      {
         // Montage
         parent_synth_form_montage.updateUIFromPatchEx(false/*bPatchNames*/, _bFMMatrix, false/*bPartMixCopyOptions*/);
      }
   }

   // <ui_handle.png>
   protected method handleCycleOps(boolean _bGreaterZero) {
      local IntArray iaActiveOps;
      byte lvl;
      int opIdx = 0;
      loop(8)
      {
         lvl = getOpLevel(opIdx);

         if(!_bGreaterZero || (lvl > 0))
            iaActiveOps.add(opIdx);

         opIdx++;
      }

      if(iaActiveOps.numElements > 1)
      {
         local IntArray iaOpsOld = iaActiveOps;
         opIdx = iaActiveOps[0];
         iaActiveOps.delete(0);
         iaActiveOps.add(opIdx);
         // trace "xx iaOpsOld="+iaOpsOld;
         // trace "xx iaOpsNew="+iaActiveOps;

         if(null != parent_synth_form_fs1r)
         {
            // FS1R
            parent_synth_form_fs1r.swapVoicedOpsByArray(iaOpsOld, iaActiveOps,
                                                        null/*opMapFPToOp*/,
                                                        getSelectedOpParameterSetMask(),
                                                        false/*bSwapOpLevel*/
                                                        );
         }
         else
         {
            // Montage
            parent_synth_form_montage.swapVoicedOpsByArray(iaOpsOld, iaActiveOps,
                                                           null/*opMapFPToOp*/,
                                                           getSelectedOpParameterSetMask(),
                                                           false/*bSwapOpLevel*/
                                                           );
         }

         updateUIFromPatchEx(false/*bFX*/, false/*bFMMatrix*/);
         updateFromPatchData_Editor(true/*bTabVisible*/);
         Global.Print("Cycle "+iaActiveOps.numElements+" (active) Ops");
      }
   }

   // <ui_handle.png>
   protected method handleShuffleOps(boolean _bGreaterZero) {
      local IntArray iaActiveOps;
      byte lvl;
      int opIdx = 0;
      loop(8)
      {
         lvl = getOpLevel(opIdx);

         if(!_bGreaterZero || (lvl > 0))
            iaActiveOps.add(opIdx);

         opIdx++;
      }

      if(iaActiveOps.numElements > 1)
      {
         local IntArray iaShuffledOps;

         loop(iaActiveOps.numElements)
         {
            for(;;)
            {
               byte idx = rand(iaActiveOps.numElements);
               opIdx = iaActiveOps[idx];
               if(!iaShuffledOps.contains(opIdx))
               {
                  iaShuffledOps.add(opIdx);
                  break;
               }
            }
         }

         // trace "xx iaOpsOld="+iaActiveOps;
         // trace "xx iaOpsNew="+iaShuffledOps;
         if(null != parent_synth_form_fs1r)
         {
            // FS1R
            parent_synth_form_fs1r.swapVoicedOpsByArray(iaActiveOps, iaShuffledOps,
                                                        null/*opMapFPToOp*/,
                                                        getSelectedOpParameterSetMask(),
                                                        false/*bSwapOpLevel*/
                                                        );
         }
         else
         {
            // Montage
            parent_synth_form_montage.swapVoicedOpsByArray(iaActiveOps, iaShuffledOps,
                                                           null/*opMapFPToOp*/,
                                                           getSelectedOpParameterSetMask(),
                                                           false/*bSwapOpLevel*/
                                                           );
         }

         updateUIFromPatchEx(false/*bFX*/, false/*bFMMatrix*/);
         updateFromPatchData_Editor(true/*bTabVisible*/);
         Global.Print("Shuffle "+iaActiveOps.numElements+" (active) Ops");
      }
   }

   // <method_get.png>
   protected method getFocusedOp() : FMMatrixOp {
      // trace "xxx getFocusedOp: mouse_layer="+#(UI.mouse_layer)+" mousefocus_layer="+#(UI.mousefocus_layer);
      FMMatrixOp *op;
      foreach op in op_controls
      {
         // trace "xxx getFocusedOp: op_idx="+op.op_idx+" op.isMouseOverWithin()="+op.isMouseOverWithin();
         if(op.isMouseOverWithin())
         {
            // trace "xxx getFocusedOp: op_idx="+op.op_idx;
            return op;
         }
      }
      return null;
   }

   // <ui_handle.png>
   public method copyFocusedOp() {
      FMMatrixOp op <= getFocusedOp();
      if(null != op)
      {
         op.handleCopy();
      }
   }

   // <ui_handle.png>
   public method pasteFocusedOp() {
      FMMatrixOp op <= getFocusedOp();
      if(null != op)
      {
         op.handlePaste();
      }
   }

   // <ui_handle.png>
   public method initFocusedOp() {
      FMMatrixOp op <= getFocusedOp();
      if(null != op)
         op.handleInit();
   }

   // <ui_handle.png>
   public method nextLevelDeltaPreset() {
      local IntArray levelDeltaPresets = [1, 5, 10, 25, 33, 50, 99];
      int c = fp_lvl_delta.getFloatValue();
      int idx = 0;
      loop(levelDeltaPresets.numElements)
      {
         if(c < levelDeltaPresets[idx])
         {
            c = levelDeltaPresets[idx];
            break;
         }
         idx++;
      }
      if(idx == levelDeltaPresets.numElements)
         c = 1; // 99=>1
      fp_lvl_delta.setValue(c);
      Global.PrintFast("Level Delta is "+c);
   }

   // <method_set.png>
   public method getValueById(String _aliasId) : byte {
      // called by Montage editor
      byte r = 0;
      if(null != parent_synth_form_montage)
      {
         int opIdx = 0;
         if(_aliasId <= "d_op1v_")
            opIdx = 0;
         if(_aliasId <= "d_op2v_")
            opIdx = 1;
         if(_aliasId <= "d_op3v_")
            opIdx = 2;
         if(_aliasId <= "d_op4v_")
            opIdx = 3;
         if(_aliasId <= "d_op5v_")
            opIdx = 4;
         if(_aliasId <= "d_op6v_")
            opIdx = 5;
         if(_aliasId <= "d_op7v_")
            opIdx = 6;
         if(_aliasId <= "d_op8v_")
            opIdx = 7;
         MontagePartFMOperator op <= parent_synth_form_montage.getOpByIdx(opIdx);
         // trace "xxx getValueById: aliasId="+_aliasId+" opIdx="+opIdx+" op="+#(op);
         if(null != op)
         {
            String id;
            _aliasId.substring(7, 99) => id;
            int off = op.getDataOffById(id);
            // trace "xxx FMMatrix::getValueById: id=\""+id+"\" off="+off;
            if(off >= 0)
            {
               r = op.getDataByte(off);
               if($06/*detune*/ == off)
                  r -= 15;
               else if($20/*amp_vel_sense*/ == off)
                  r -= 7;
            }
         }
      }
      return r;
   }

   // <method_set.png>
   public method setValueById(String _aliasId, byte _val) {
      // called by Montage editor
      byte r = 0;
      if(null != parent_synth_form_montage)
      {
         int opIdx = 0;
         if(_aliasId <= "d_op1v_")
            opIdx = 0;
         if(_aliasId <= "d_op2v_")
            opIdx = 1;
         if(_aliasId <= "d_op3v_")
            opIdx = 2;
         if(_aliasId <= "d_op4v_")
            opIdx = 3;
         if(_aliasId <= "d_op5v_")
            opIdx = 4;
         if(_aliasId <= "d_op6v_")
            opIdx = 5;
         if(_aliasId <= "d_op7v_")
            opIdx = 6;
         if(_aliasId <= "d_op8v_")
            opIdx = 7;
         MontagePartFMOperator op <= parent_synth_form_montage.getOpByIdx(opIdx);
         // trace "xxx getValueById: aliasId="+_aliasId+" opIdx="+opIdx+" op="+#(op);
         if(null != op)
         {
            String id;
            _aliasId.substring(7, 99) => id;
            int off = op.getDataOffById(id);
            // trace "xxx FMMatrix::setValueById: id=\""+id+"\" off="+off+" val="+_val;
            if(off >= 0)
            {
               // detune-15, ampvelsens-7
               if($06/*detune*/ == off)
                  op.setDataByte(off, _val + 15);
               else if($20/*amp_vel_sense*/ == off)
                  op.setDataByte(off, _val + 7);
               else
                  op.setDataByte(off, _val);
            }
         }
      }
   }

   // <method.png>
   public method editOpByAliasId(String _aliasId, byte _val) {

      if(null != parent_synth_form_montage)
      {
         setValueById(_aliasId, _val);
         parent_synth_form_montage.scheduleMIDISendParam();
      }
      else
      {
         Layer lEditor <= findParamWidgetByAliasId(_aliasId);
         if(lEditor instanceof FloatParam)
         {
            FloatParam fpEditor <= lEditor;
            fpEditor.setValue(_val);
         }
         else if(lEditor instanceof CheckBox)
         {
            CheckBox cbEditor <= lEditor;
            cbEditor.setSelected(_val);
         }
         else if(lEditor instanceof ComboBox)
         {
            ComboBox cmEditor <= lEditor;
            cmEditor.setSelectedOption(_val);
         }
         handleParamWidgetChanged(lEditor, false/*bUpdateFMMatrix*/, false/*bQuiet*/);
      }
   }

   // <method.png>
   protected method multiEditOpByAliasId(FMMatrixOp _op, String _aliasId, byte _val, byte _randMin, byte _randMax) {
      if(cb_multiedit.isSelected())
      {
         // All ops
         local String aliasIdAny = _aliasId;
         int opNr = 1;
         loop(8)
            aliasIdAny.replace("_op"+(opNr++)+"v_", "_op$v_");
         opNr = 1;
         local String aliasIdOp;
         int opIdx = 0;
         loop(8)
         {
            aliasIdAny.replace("$", String(opNr++)) => aliasIdOp;
            if(VMOD_LCTRL == UI.GetKeyMod()) // randomize ?
            {
               _val = _randMin + rand(int(_randMax - _randMin + 1));
            }
            editOpByAliasId(aliasIdOp, _val);
            FMMatrixOp op <= op_controls.get(opIdx++);
            if(@(op) != @(_op))
               op.updateFromPatch();
         }
      }
      else
      {
         // Single op
         if(VMOD_LCTRL == UI.GetKeyMod()) // randomize ?
            _val = _randMin + rand(int(_randMax - _randMin + 1));
         editOpByAliasId(_aliasId, _val);
         _op.updateFromPatch();
      }
   }

   // <ui_handle.png>
   public method handleMultiEditOpParam(FMMatrixOp op, Layer l) {
      FloatParam *fp;
      CheckBox *cb;
      CheckBox *cbEditor;
      ComboBox *cmEditor;

      if(l instanceof FloatParam)
      {
         fp <= l;
         multiEditOpByAliasId(op, fp.getUserData()/*aliasId*/, fp.getFloatValue(), fp.getMinValue(), fp.getMaxValue());
         return true;
      }
      else if(l instanceof CheckBox)
      {
         cb <= l;
         multiEditOpByAliasId(op, cb.getUserData()/*aliasId*/, cb.isSelected(), 0, 1);
         return true;
      }

      return false;
   }

   // <ui_handle.png>
   public method handleMultiEditPaste(FMMatrixOp _op) {
      if(cb_multiedit.isSelected())
      {
         FMMatrixOp *op;
         foreach op in op_controls
            op.handlePaste();
         Global.Print("Multi-edit Paste clipboard to all Ops");
      }
      else
      {
         _op.handlePaste();
      }
   }

   // <ui_handle.png>
   public method handleMultiEditInit(FMMatrixOp _op) {
      if(cb_multiedit.isSelected())
      {
         FMMatrixOp *op;
         foreach op in op_controls
            op.handleInit();
         Global.Print("Multi-edit Init all Ops");
      }
      else
      {
         _op.handleInit();
      }
   }

   // <ui_handle.png>
   public method handleMultiEditRand(FMMatrixOp _op, boolean _bAllowFixedAndAttack) {
      if(cb_multiedit.isSelected())
      {
         FMMatrixOp *op;
         foreach op in op_controls
            op.handleRand(_bAllowFixedAndAttack);
         Global.Print("Multi-edit Randomize all Ops");
      }
      else
      {
         _op.handleRand(_bAllowFixedAndAttack);
      }
   }

   // <ui_handle.png>
   public method handleMultiEditRandOsc(FMMatrixOp _op) {
      if(cb_multiedit.isSelected())
      {
         FMMatrixOp *op;
         foreach op in op_controls
            op.handleRandOsc();
         Global.Print("Multi-edit Randomize all Op Oscillators");
      }
      else
      {
         _op.handleRandOsc();
      }
   }

   // <ui_handle.png>
   public method handleMultiEditRandFreq(FMMatrixOp _op, boolean _bAllowFixed) {
      if(cb_multiedit.isSelected())
      {
         FMMatrixOp *op;
         foreach op in op_controls
            op.handleRandFreq(_bAllowFixed);
         Global.Print("Multi-edit Randomize all Op Frequencies");
      }
      else
      {
         _op.handleRandFreq(_bAllowFixed);
      }
   }

   // <ui_handle.png>
   public method handleMultiEditRandAEGLevel(FMMatrixOp _op, boolean _bAllowAttack) {
      if(cb_multiedit.isSelected())
      {
         FMMatrixOp *op;
         foreach op in op_controls
            op.handleRandAEGLevel(_bAllowAttack);
         Global.Print("Multi-edit Randomize all Op AEG Levels");
      }
      else
      {
         _op.handleRandAEGLevel(_bAllowAttack);
      }
   }

   // <ui_handle.png>
   public method handleMultiEditRandAEGTime(FMMatrixOp _op, boolean _bAllowAttack) {
      if(cb_multiedit.isSelected())
      {
         FMMatrixOp *op;
         foreach op in op_controls
            op.handleRandAEGTime(_bAllowAttack);
         Global.Print("Multi-edit Randomize all Op AEG Times");
      }
      else
      {
         _op.handleRandAEGTime(_bAllowAttack);
      }
   }

   // <ui_handle.png>
   public =replay= method handleCopyPartFromPatch(byte _partIdx, int _patchIdxOpt) {
      if(_patchIdxOpt > 0/*keep*/)
      {
         if(null != parent_synth_form_fs1r)
         {
            // FS1R
            Buffer pdSrc <= parent_synth_form_fs1r.getPatchDataByPatchIdx(_patchIdxOpt - 1);
            if(null != pdSrc)
            {
               Buffer pdDst <= parent_synth_form_fs1r.getPatchDataByPartIdx(_partIdx);
               if(null != pdDst)
               {
                  pdDst = pdSrc;
                  parent_synth_form_fs1r.updateUIFromPatch();

                  MIDISynthProfileDataFS1R data <= parent_synth_form_fs1r.data;

                  if(data.b_autosend)
                     parent_synth_form_fs1r.scheduleMIDISendPatch();

                  Global.Print("Copy part "+(_partIdx+1)+" from patch "+_patchIdxOpt);
               }
            }
         }
         else
         {
            // (todo) Montage
         }
      }
   }

   // <ui_handle.png>
   public method selectPercussionMixPartPatches() {
      // C001: fun 1, D001: tra 1, E001: hrm 1, F001: nos 1
      ComboBox cm <= cm_mix_parts.get(0);
      cm.setSelectedOption(1 + 2*128); // C001

      cm <= cm_mix_parts.get(1);
      cm.setSelectedOption(1 + 3*128); // D001

      cm <= cm_mix_parts.get(2);
      cm.setSelectedOption(1 + 4*128); // E001

      cm <= cm_mix_parts.get(3);
      cm.setSelectedOption(1 + 5*128); // F001

      Global.Print("Select percussion mix part patches");
   }

   // <ui_handle.png>
   protected method handleMoveOpLeft(boolean _bSwapOpLevel) {
      if(null != parent_synth_form_fs1r)
      {
         parent_synth_form_fs1r.swapVoicedOps(current_op_idx, (current_op_idx-1)&7, EditMIDISynthFormMontage.PARAMSET_OP_ALL, _bSwapOpLevel);
         parent_synth_form_fs1r.updateUIFromPatchEx(false/*bFX*/, true/*bFMMatrix*/);
      }
      else if(null != parent_synth_form_montage)
      {
         parent_synth_form_montage.swapVoicedOps(current_op_idx, (current_op_idx-1)&7, EditMIDISynthFormMontage.PARAMSET_OP_ALL, _bSwapOpLevel);
         parent_synth_form_montage.updateUIFromPatchEx(false/*bPatchNames*/, true/*bFMMatrix*/, false/*bPartMixCopyOptions*/);
      }
      setCurrentOpIdx((current_op_idx - 1)&7);
      Global.Print("Move Op"+(_bSwapOpLevel?" + Level":"")+" Left");
   }

   // <ui_handle.png>
   protected method handleMoveOpRight(boolean _bSwapOpLevel) {
      if(null != parent_synth_form_fs1r)
      {
         parent_synth_form_fs1r.swapVoicedOps(current_op_idx, (current_op_idx+1)&7, EditMIDISynthFormMontage.PARAMSET_OP_ALL, _bSwapOpLevel);
         parent_synth_form_fs1r.updateUIFromPatchEx(false/*bFX*/, true/*bFMMatrix*/);
      }
      else if(null != parent_synth_form_montage)
      {
         parent_synth_form_montage.swapVoicedOps(current_op_idx, (current_op_idx+1)&7, EditMIDISynthFormMontage.PARAMSET_OP_ALL, _bSwapOpLevel);
         parent_synth_form_montage.updateUIFromPatchEx(false/*bPatchNames*/, true/*bFMMatrix*/, false/*bPartMixCopyOptions*/);
      }
      setCurrentOpIdx((current_op_idx + 1)&7);
      Global.Print("Move Op"+(_bSwapOpLevel?" + Level":"")+" Right");
   }

   // <ui_handle.png>
   protected method handleAEGSclStartEditing() {
      // trace "xxx handleAEGSclStartEditing";
      FMMatrix_OpPreset_Op *op;

      if(aeg_scl_ops.isEmpty())
      {
         loop(8)
         {
            op <= new FMMatrix_OpPreset_Op;
            aeg_scl_ops.add(#(deref op));
         }
      }

      // Save initial / undo state
      int opIdx = 0;
      loop(8)
      {
         op <= aeg_scl_ops[opIdx];
         FMMatrixOp fOp <= op_controls.get(opIdx);
         fOp.saveOpToPreset(op);
         opIdx++;
      }
   }

   // <ui_handle.png>
   protected method handleAEGSclChanged(float _v, float _exp) {
      // trace "xxx handleAEGSclChanged: v="+_v+" exp="+_exp;

      float v;
      if(_v < 0.0)
         v = 1.0 / (-_v + 1.0);
      else
         v = _v + 1.0;

      _exp /= 20.0f;

      FMMatrix_OpPreset_Op *op;
      int opIdx = 0;
      FloatParam *fp;
      foreach op in aeg_scl_ops
      {
         FMMatrixOp fOp <= op_controls[opIdx];
         local PointerArray aFP = [fOp.fp_time_1,
                                   fOp.fp_time_2,
                                   fOp.fp_time_3,
                                   fOp.fp_time_4
                                   ];
         local IntArray aT = [op.aeg_t_1,
                              op.aeg_t_2,
                              op.aeg_t_3,
                              op.aeg_t_4
                              ];

         int egIdx = 0;
         foreach fp in aFP
         {
            short c = aT[egIdx];
            short n = aT[egIdx] * v;
            short d = n - c;
            n = c + mathPowerf(1.0 - (c/99.0f), _exp) * d;
            fp.setValue( mathClampi(n, 0, 99) );

             // // if(null != parent_synth_form_fs1r)
             // //    handleParamWidgetChanged(fp, false/*bUpdateFMMatrix*/, true/*bQuiet*/);
             // // else
               editOpByAliasId("d_op"+(opIdx+1)+"v_eg_t"+(egIdx+1), fp.getFloatValue());

            egIdx++;
         }

         opIdx++;
      }

      Global.Print("AEG Scaling Factor is "+((_v<0.0)?("1/"+((-_v)+1)):(_v+1))+" (exp="+_exp+")" );
   }

   // <method.png>
   public method dumpEGSettings(PointerArray _currentEGSettings) {
      MontagePartFM pFM <= parent_synth_form_montage.getEditPartFM();

      if(null != pFM)
      {
         // "FM op <n> peg"
         // "FM op <n> aeg"
         pFM.dumpEGSettings(_currentEGSettings, -1/*opFilter*/);
      }
   }

   // <ui_handle.png>
   public virtual =replay= loadEGPreset(Montage_EGPreset _preset, String _typeName) {
      Global.Debug("Montage_ElementForm::loadEGPreset: typeName="+_typeName+" preset.name="+_preset.name);
      MontagePartFM pFM <= parent_synth_form_montage.getEditPartFM();
      if(null != pFM)
      {
         MontagePartFMOperator *op;
         switch(_typeName)
         {
            case "FM op 1 peg":
               op <= pFM.getOpByIdx(0);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 1 aeg":
               op <= pFM.getOpByIdx(0);
               op.loadAEGPreset(_preset);
               break;

            case "FM op 2 peg":
               op <= pFM.getOpByIdx(1);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 2 aeg":
               op <= pFM.getOpByIdx(1);
               op.loadAEGPreset(_preset);
               break;

            case "FM op 3 peg":
               op <= pFM.getOpByIdx(2);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 3 aeg":
               op <= pFM.getOpByIdx(2);
               op.loadAEGPreset(_preset);
               break;

            case "FM op 4 peg":
               op <= pFM.getOpByIdx(3);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 4 aeg":
               op <= pFM.getOpByIdx(3);
               op.loadAEGPreset(_preset);
               break;

            case "FM op 5 peg":
               op <= pFM.getOpByIdx(4);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 5 aeg":
               op <= pFM.getOpByIdx(4);
               op.loadAEGPreset(_preset);
               break;

            case "FM op 6 peg":
               op <= pFM.getOpByIdx(5);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 6 aeg":
               op <= pFM.getOpByIdx(5);
               op.loadAEGPreset(_preset);
               break;

            case "FM op 7 peg":
               op <= pFM.getOpByIdx(6);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 7 aeg":
               op <= pFM.getOpByIdx(6);
               op.loadAEGPreset(_preset);
               break;

            case "FM op 8 peg":
               op <= pFM.getOpByIdx(7);
               op.loadPEGPreset(_preset);
               break;

            case "FM op 8 aeg":
               op <= pFM.getOpByIdx(7);
               op.loadAEGPreset(_preset);
               break;

            // // case "feg":
            // //    pFM.loadFEGPreset(_preset);
            // //    break;
         }

         updateFromPatchData_Editor(true/*bTabVisible*/);
         parent_synth_form_montage.handleParamEdited();
         Global.Print("Load EG Preset \""+_typeName+"\"");
      }
   }

   // <ui_mouse.png>
   public virtual onMouseClick(MouseEvent _ev) : boolean {
      if(_ev.isRightButton())
      {
         if(null != parent_synth_form_montage)
         {
            if(null != parent_synth_form_montage.getEditPartFM())
            {
               local PointerArray currentEGPresets;
               dumpEGSettings(currentEGPresets);
               Montage_EGPresetDialog.ShowEGPresetDialog(this, deref currentEGPresets);
            }
         }
         return true;
      }
      return false;
   }

   // <ui_render.png>
   public virtual onDraw() {
      if(b_updatefrompatchdata_editor_pending)
      {
         b_updatefrompatchdata_editor_pending = false;
         updateFromPatchData_Editor(true/*bTabVisible*/);
      }
      UIRenderer.DrawDefaultBackground(0, 0, getSizeX(), getSizeY());
   }

   // <ui_focus.png>
   public method refocusDefault() {
      UI.SetKeyboardFocus(this);
   }

   // <method_get.png>
   public virtual getDefaultKeyboardFocusLayer() : Layer {
      return this;
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {
      // trace "[>>>] FMMatrix::onKey: code="+_k.code+" pressed="+_k.pressed+" mod="+_k.mod;

      switch(_k.pressed)
      {
         case 'a':
            if(_k.modShiftOnly())
            {
               UI.SetKeyboardFocus(fp_alg);
               return true;
            }
            break;

         case 'c':
            if(_k.modShiftOnly())
            {
               copyFocusedOp();
               return true;
            }
            break;

         case 'e':
            // (note) 'e' without modifiers selects OpN3
            if(_k.modCtrlOnly())
            {
               randomizeAlgorithm();
               return true;
            }
            break;

         case 'o':
            if(_k.modCtrl())
            {
               handleCycleOps(!_k.modShift()/*bGreaterZero*/);
               return true;
            }
            break;

         case 'p':
            if(_k.modCtrlOnly())
            {
               handleShuffleOps(!_k.modShift()/*bGreaterZero*/);
               return true;
            }
            else if(_k.modNone())
            {
               selectPercussionMixPartPatches();  // C001: fun 1, D001: tra 1, E001: hrm 1, F001: nos 1
               return true;
            }
            break;

         case 'r':
            // (note) 'r' without modifiers selects OpN4
            if(_k.modCtrlOnly())
            {
               randomizeOpLevels(true/*bGreaterZero*/);
               return true;
            }
            else if(_k.modCtrl() && _k.modShift())
            {
               randomizeOpLevels(false/*bGreaterZero*/);
               return true;
            }
            break;

         case 'v':
            if(_k.modShiftOnly())
            {
               pasteFocusedOp();
               return true;
            }
            else if(_k.modNone())
            {
               nextLevelDeltaPreset();
               return true;
            }
            break;

         case 'x':
            if(_k.modShiftOnly())
            {
               initFocusedOp();
               return true;
            }
            else if(_k.modNone())
            {
               cb_multiedit.toggleSelectionAction();
               return true;
            }
            break;

         case 'z': // 'y' on german kbds
            if(_k.modNone())
            {
               cycleOpLevels();
               return true;
            }
            else if(_k.modShiftOnly())
            {
               shuffleOpLevels();
               return true;
            }
            break;

      }

      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      if(debug >= 2)
         trace "xxx FMMatrix::consumeAction: acName="+acName+" ap="+#(ap);

      // trace "xxx acName="+acName;

      if(TA_SORT == acName)
      {
         handleSort();
         return true;
      }
      else if(TA_MATPOSSIBLE == acName)
      {
         if(b_autoselect_alg)
         {
            if(debug >= 2)
               trace "xxx TA_MATPOSSIBLE idx="+mat_possible_idx;
            if(!calcMatPossibleIncremental())
               ta_matpossible.reschedule();
         }
         return true;
      }
      else if(TA_UPDATEALL == acName)
      {
         updateFromPatchData_Editor(true/*bTabVisible*/);
         return true;
      }
      else if(TA_UPDATEMUTE == acName)
      {
         lazyUpdateOpMuteCheckBoxes();
         ta_updatemute.reschedule();
         return true;
      }

      if(null != parent_synth_form_montage)
      {
         if(@(ap) == @(cm_var))
         {
            parent_synth_form_montage.selectVariation(cm_var.getSelectedOption(), (VMOD_LALT == UI.GetKeyMod())/*bAllParts*/);
            return true;
         }
      }

      int fpIdx = fp_matrix.indexOfPointer(ap, 0);
      if(-1 != fpIdx)
      {
         if(debug >= 1)
         {
            trace "xxx";
            trace "xxx";
            trace "xxx";
            trace "xxx";
            trace "xxx";
            trace "xxx";
            trace "xxx";
            trace "xxx";
            trace "xxx";
         }

         if(TextField.ACTION_STARTEDITING == acName)
         {
            setCurrentOpIdx(fpIdx & 7);
            return true;
         }

         local IntArray opMapOld = op_map_fp_to_op;

         int tStart;
         if(b_debug_perf)
            tStart = milliSeconds();
         handleMatrixFloatParamChanged(ap, fpIdx);
         if(b_debug_perf)
            trace "[pro] handleMatrixFloatParamChanged() took "+(milliSeconds()-tStart)+"ms";
         b_queued_sort_pending |= (opMapOld != op_map_fp_to_op);

         if(b_queued_sort_pending)
         {
            // // if(FloatParam.ACTION_VALUECHANGED == acName)
            // // {
               // Mouse released, schedule revert-to-ascending-operator-order
               b_queued_sort_pending = false;
               ta_sort.reschedule();
               refocusDefault();
            // // }
            // // else
            // //    ta_sort.cancel();
         }
         else
         {
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
         }

         return true;
      }

      // Toggle voiced operator mute
      int cbIdx = opv_mute_checkboxes.indexOfPointer(ap, 0);
      if(-1 != cbIdx)
      {
         if(CheckBox.ACTION_HOLD_CLICK == acName)
            toggleMuteAllOpV(false/*bInvert*/);
         else
            handleOpVMuteChanged(cbIdx);
         return true;
      }

      // Toggle voiced operator mute
      cbIdx = opn_mute_checkboxes.indexOfPointer(ap, 0);
      if(-1 != cbIdx)
      {
         if(CheckBox.ACTION_HOLD_CLICK == acName)
            toggleMuteAllOpN(false/*bInvert*/);
         else
            handleOpNMuteChanged(cbIdx);
         return true;
      }

      int btIdx = part_buttons.indexOfPointer(ap, 0);
      if(-1 != btIdx)
      {
         handlePartChanged(btIdx);
         return true;
      }

      int mixPartIdx = fp_mix_parts_level.indexOfPointer(ap, 0);
      int mixPartIdxDst;
      MIDISynthProfileDataMontage *dataMontage;
      if(-1 != mixPartIdx)
      {
         if(null != parent_synth_form_montage)
         {
            dataMontage <= parent_synth_form_montage.data;
            mixPartIdxDst = mixPartIdx + (dataMontage.current_part_idx & ~3);
         }
         else
         {
            mixPartIdxDst = mixPartIdx;
         }
         FloatParam fpMixLevel <= fp_mix_parts_level.get(mixPartIdx);
         setPartLevel(mixPartIdxDst, fpMixLevel.getFloatValue());
         Global.Print("Part "+(mixPartIdxDst+1)+" volume is "+fpMixLevel.getFloatValue());
         if(FloatParam.ACTION_VALUECHANGED == acName)
            refocusDefault();
         return true;
      }

      mixPartIdx = fp_mix_parts_noteshift.indexOfPointer(ap, 0);
      if(-1 != mixPartIdx)
      {
         if(null != parent_synth_form_montage)
         {
            dataMontage <= parent_synth_form_montage.data;
            mixPartIdxDst = mixPartIdx + (dataMontage.current_part_idx & ~3);
         }
         else
         {
            mixPartIdxDst = mixPartIdx;
         }
         FloatParam fpMixNoteShift <= fp_mix_parts_noteshift.get(mixPartIdx);
         setPartNoteShift(mixPartIdxDst, fpMixNoteShift.getFloatValue());
         Global.Print("Part "+(mixPartIdxDst+1)+" note shift is "+fpMixNoteShift.getFloatValue());
         if(FloatParam.ACTION_VALUECHANGED == acName)
            refocusDefault();
         return true;
      }

      mixPartIdx = cm_mix_parts.indexOfPointer(ap, 0);
      if(-1 != mixPartIdx)
      {
         // FS1R only
         ComboBox cmMix <= cm_mix_parts.get(mixPartIdx);
         handleCopyPartFromPatch(mixPartIdx, cmMix.getSelectedOption()/*0==keep*/);
         return true;
      }

      switch(@(ap))
      {
         case @(bt_op_cycle_left):
            handleMoveOpLeft((Button.ACTION_HOLD_CLICK != acName)/*bSwapOpLevel*/);
            return true;

         case @(bt_op_cycle_right):
            handleMoveOpRight((Button.ACTION_HOLD_CLICK != acName)/*bSwapOpLevel*/);
            return true;

         case @(fp_op_preset_type):
            handleOpPresetTypeChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cf_op_preset):
            // trace "xxx cf_op_preset: acName="+acName;
            if(ComboField.ACTION_OPTIONADDED == acName)
            {
               handleOpPresetSave(true/*bAdd*/);
            }
            else if(ComboField.ACTION_OPTIONSELECTED == acName)
            {
               if(cb_op_preset_autoload.isSelected())
                  handleOpPresetChanged();
               else
                  Global.Print("Select Op Preset \""+cf_op_preset.getSelectedOptionName()+"\"");
            }
            else if(ComboField.ACTION_OPTIONRESELECTED == acName)
            {
               // RETURN pressed while option already exists
               handleOpPresetSave(false/*bAdd*/);
            }
            else if(ComboField.ACTION_OPTIONREMOVED == acName)
            {
               handleOpPresetRemove(cf_op_preset.getLastRemovedOptionName());
            }
            else
            {
               // // handleUserFltChanged(false/*bChangeFocus*/, (ComboField.ACTION_OPTIONEDITED == acName)/*bQuiet*/);
            }
            return true;

         case @(bt_cycle):
            if(Button.ACTION_HOLD_CLICK == acName)
               shuffleOpLevels();
            else
               cycleOpLevels();
            return true;

         case @(bt_rand_op):
            randomizeOpLevels(false/*bGreaterZero*/);
            return true;

         case @(bt_rand_op_gz):
            randomizeOpLevels(true/*bGreaterZero*/);
            return true;

         case @(fp_freq_min):
            Global.PrintFast("Randomization Freq min is "+fp_freq_min.getFloatValue());
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_freq_max):
            Global.PrintFast("Randomization Freq max is "+fp_freq_max.getFloatValue());
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cb_freq_fine):
            Global.PrintFast("Randomization Freq Fine is "+Utils.GetEnableString(cb_freq_fine.isSelected()));
            return true;

         case @(fp_aeg_tmin):
            Global.PrintFast("Randomization AEG min time is "+fp_aeg_tmin.getFloatValue());
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_aeg_tmax):
            Global.PrintFast("Randomization AEG max time is "+fp_aeg_tmax.getFloatValue());
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cb_aeg_l3less):
            Global.PrintFast("Randomization AEG l3<=l2 level is "+Utils.GetEnableString(cb_aeg_l3less.isSelected()));
            return true;

         case @(cb_freq_carrier1):
            Global.PrintFast("Randomization Carrier Freq is "+(cb_freq_carrier1.isSelected()?" forced to 1":" random") );
            return true;

         case @(bt_reset):
            if(Button.ACTION_HOLD_CLICK == acName)
               handleClear(false/*bResetAlgorithm*/);
            else
               handleClear(true/*bResetAlgorithm*/);
            return true;

         case @(fp_lvl_delta):
            handleLevelDeltaChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(bt_opv_mute):
            toggleMuteAllOpV((Button.ACTION_HOLD_CLICK == acName)/*bInvert*/);
            return true;

         case @(bt_opn_mute):
            toggleMuteAllOpN((Button.ACTION_HOLD_CLICK == acName)/*bInvert*/);
            return true;

         case @(bt_op_cycle):
            handleCycleOps((Button.ACTION_HOLD_CLICK != acName)/*bGreaterZero*/);
            return true;

         case @(bt_op_shuffle):
            handleShuffleOps((Button.ACTION_HOLD_CLICK != acName)/*bGreaterZero*/);
            return true;

         case @(fp_alg):
            handleAlgorithmChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(cb_autoalg):
            handleAutoSelectAlgorithmChanged();
            return true;

         case @(fp_fb):
            handleFeedbackChanged();
            if(FloatParam.ACTION_VALUECHANGED == acName)
               refocusDefault();
            return true;

         case @(fp_aeg_scl):
            if(TextField.ACTION_STARTEDITING == acName)
            {
               handleAEGSclStartEditing();
               return true;
            }
            handleAEGSclChanged(fp_aeg_scl.getFloatValue(), fp_aeg_scl_exp.getFloatValue());
            if(FloatParam.ACTION_VALUECHANGED == acName)
               fp_aeg_scl.setValue(0.0f);
            return true;

         case @(fp_aeg_scl_exp):
            Global.PrintFast("AEG Scl Exponent is "+fp_aeg_scl_exp.getFloatValue());
            if(null != parent_synth_form_montage)
               parent_synth_form_montage.setAEGSclExp(fp_aeg_scl_exp.getFloatValue());
            return true;
      }

      return false;
   }

}
