// ----
// ---- file   : SongFileWriter.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2007-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "FLUX" midi sequencer.
// ----
// ---- changed: 04Nov2007, 05Nov2007, 08Nov2007, 09Nov2007, 10Nov2007, 12Nov2007, 13Jan2008
// ----          15Jan2008, 21Jan2008, 27Jan2008, 01Aug2008, 07Aug2008, 10Aug2008, 11Aug2008
// ----          13Aug2008, 21Sep2009, 23Sep2009, 27Dec2009, 28Dec2009, 02Jan2010, 07Jan2010
// ----          13Jan2010, 15Jan2010, 07Feb2010, 08Feb2010, 09Feb2010, 15Feb2010, 20Feb2010
// ----          21Feb2010, 25Feb2010, 01Mar2010, 29Apr2010, 13Jun2010, 29Jun2010, 01Jul2010
// ----          02Jul2010, 07Jul2010, 12Jul2010, 13Jul2010, 19Jul2010, 03Sep2010, 04Sep2010
// ----          05Sep2010, 08Sep2010, 14Sep2010, 15Sep2010, 21Sep2010, 27Sep2010, 10Oct2010
// ----          13Oct2010, 16Oct2010, 17Oct2010, 24Oct2010, 21Nov2010, 03Feb2011, 17Feb2011
// ----          18Feb2011, 24Feb2011, 26Feb2011, 09Mar2011, 17Mar2011, 18Mar2011, 20Mar2011
// ----          28Mar2011, 04Apr2011, 06Apr2011, 22Apr2011, 23Apr2011, 26Jun2011, 05Jan2012
// ----          07Jan2012, 15Jan2012, 07Feb2012, 13Feb2012, 19Feb2012, 26Jun2012, 06Dec2012
// ----          08Jan2013, 09Jan2013, 11Jan2013, 25Mar2013, 01Apr2013, 02Apr2013, 06Apr2013
// ----          08Apr2013, 14Apr2013, 22Apr2013, 08May2013, 09May2013, 10May2013, 14May2013
// ----          20May2013, 23May2013, 24May2013, 27May2013, 05Jun2013, 02Feb2014, 20Apr2014
// ----          28Jul2014, 09Aug2014, 11Aug2014, 15Aug2014, 19Aug2014, 20Aug2014, 21Aug2014
// ----          09Sep2014, 13Sep2014, 14Sep2014, 19Sep2014, 21Sep2014, 29Sep2014, 17Oct2014
// ----          16Nov2014, 11Feb2015, 17Feb2015, 18Feb2015, 21Feb2015, 23Feb2015, 17May2015
// ----          26Sep2015, 27Sep2015, 03Oct2015, 14Nov2015, 15Nov2015, 23Dec2015, 19Mar2016
// ----          12Mar2017, 09May2017, 04Jan2018, 07Mar2018, 22May2018, 06Jun2018, 08Dec2018
// ----          15Dec2018, 02Mar2019, 18May2019, 29Aug2019, 10Feb2021, 19Jul2021, 13Dec2021
// ----          17Dec2021, 18Dec2021, 20Dec2021, 12Aug2022, 24Nov2022, 25Nov2022, 22Apr2023
// ----          24Sep2023, 25Sep2023, 13Oct2023, 14Mar2025
// ----
// ----
// ----
module MSongFileWriter;

use namespace st2;
use namespace ui;


// <class.png>
class SongFileWriter : SongFile {

   // <method.png>
   static protected method FixChunkSize(Stream _out, int _chunkStartOff) {
      ////trace "xxx 1 fixchunksize: out.offset="+_out.offset;
      int coff = _out.offset;
      int chunkSize = coff - _chunkStartOff;
      _out.seek(_chunkStartOff+4, SEEK_SET);
      _out.i32 = chunkSize;
      _out.seek(coff, SEEK_SET);
   }

   // <method_write.png>
   static protected method WriteChunkHeader(Stream _out, int _code, int _dataSize) {
      ////trace "xxx 1 writechunkheader: out.offset="+_out.offset;
      _out.i32 = _code; // Four-CC code
      _out.i32 = _dataSize + 4 + 4; // Chunk size (data size + header size)
   }

   // <method_write.png>
   static protected method WriteI8(Stream _out, int _fourCC, byte _i8) {
      WriteChunkHeader(_out, _fourCC, 1);
      _out.i8 = _i8;
   }

   // <method_write.png>
   static protected method WriteBoolean(Stream _out, int _fourCC, boolean _bEnabled) {
      WriteChunkHeader(_out, _fourCC, 1);
      _out.i8 = _bEnabled ? true : false;
   }

   // <method_write.png>
   static protected method WriteI16(Stream _out, int _fourCC, short _i16) {
      WriteChunkHeader(_out, _fourCC, 2);
      _out.i16 = _i16;
   }

   // <method_write.png>
   static protected method WriteI32(Stream _out, int _fourCC, int _i32) {
      WriteChunkHeader(_out, _fourCC, 4);
      _out.i32 = _i32;
   }

   // <method_write.png>
   static protected method WriteF32(Stream _out, int _fourCC, float _f32) {
      WriteChunkHeader(_out, _fourCC, 4);
      _out.f32 = _f32;
   }

   // <method_write.png>
   static protected method WriteString(Stream _out, int _fourCC, String _s) {
      int coff = _out.offset;
      WriteChunkHeader(_out, _fourCC, 0);
      _out.serialize(_s, false);
      FixChunkSize(_out, coff);
   }

   // <method_write.png>
   static protected method WriteScriptObject(Stream _out, int _fourCC, Object _o) {
      int coff = _out.offset;
      WriteChunkHeader(_out, _fourCC, 0);
      _out.serialize(_o, true);
      FixChunkSize(_out, coff);
   }

   // <method_write.png>
   static protected method WriteEnvelope(Stream _out, int _fourCC, Envelope _env, int _envId) {
      int i;
      ////trace "xxx WriteEnvelope 4CC="+_fourCC+" env="+#(_env)+" out.offset="+_out.offset;
      WriteChunkHeader(_out, _fourCC, 4 + 4 + _env.numElements*4 + ((_envId>=0)?1:0));
      if(_envId >= 0)
      {
         _out.i8 = _envId; // ctlId in TRACK_PATTERN_CTL chunks
      }
      _out.i32 = 0; // Element type (reserved), 0=float
      _out.i32 = _env.interpolation;
      i = 0;
      loop(_env.numElements)
      {
         _out.f32 = _env[i];
         i++;
      }
   }

   // <method_write.png>
   static protected method WriteFloatArray(Stream _out, int _fourCC, FloatArray _fa) {
      int i;
      ////trace "xxx WriteFloatArray 4CC="+_fourCC+" fa="+#(_fa)+" out.offset="+_out.offset;
      WriteChunkHeader(_out, _fourCC, _fa.numElements*4);
      i = 0;
      loop(_fa.numElements)
      {
         _out.f32 = _fa[i];
         i++;
      }
   }

   // <method_write.png>
   static protected method WriteIntArray(Stream _out, int _fourCC, IntArray _ia) {
      int i;
      ////trace "xxx WriteIntArray 4CC="+_fourCC+" ia="+#(_ia)+" out.offset="+_out.offset;
      WriteChunkHeader(_out, _fourCC, _ia.numElements*4);
      i = 0;
      loop(_ia.numElements)
      {
         _out.i32 = _ia[i];
         i++;
      }
   }

   // <method_write.png>
   static protected method WriteStringArray(Stream _out, int _fourCC, StringArray _sa) {
      int i;
      ////trace "xxx WriteStringArray 4CC="+_fourCC+" sa="+#(_sa)+" out.offset="+_out.offset;
      int startOff = _out.offset;
      WriteChunkHeader(_out, _fourCC, 0);
      i = 0;
      _out.i32 = _sa.numElements;
      loop(_sa.numElements)
      {
         String s <= _sa.get(i);
         _out.serialize(s, false);
         i++;
      }
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WritePipeRootDevMap(Stream _out) {
      // (note) all piperoots have the same MIDI out device map

      int mapOff = _out.offset;

      WriteChunkHeader(_out, FOURCC_PIPEROOTDEVMAP, 0);

      STX_MIDIOutDevice *outDev;

      foreach outDev in MIDI.out_devices
      {
         ////String xxx <= outDev.getAliasOrDeviceName();
         ////trace "xxx WritePipeRootDevMap: outDev="+#(outDev)+" outDev.getAliasOrDeviceName()=\""+#(xxx)+"\"";
         String devName <= outDev.getAliasOrDeviceName();
         // // if(STConfig.sysex_out_devicename != devName) // "remote_audio" by default
         // // {
            WriteString(_out, FOURCC_PIPEROOTDEVMAP_DEVNAME, devName);
         // // }
      }

      // Finish PIPEROOTDEVMAP chunk
      FixChunkSize(_out, mapOff);
   }

   // <method_write.png>
   static protected method WriteMIDIDevCfgs(Stream _out, boolean _bOut) {

      int allStartOff = _out.offset;

      WriteChunkHeader(_out, _bOut ? FOURCC_MIDIOUTDEVCFGS : FOURCC_MIDIINDEVCFGS, 0);

      STX_MIDIDevice *dev;
      PointerArray *devs;

      if(_bOut)
      {
         devs <= MIDI.out_devices;
      }
      else
      {
         devs <= MIDI.in_devices;
      }

      foreach dev in devs
      {
         if(dev.isProjectSpecific())
         {
            int cfgStartOff = _out.offset;
            WriteChunkHeader(_out, FOURCC_MIDIDEVCFG, 0);

            // Write device name
            WriteString(_out, FOURCC_MIDIDEVCFG_DEVNAME, dev.getGlobalAliasOrDeviceName());

            String alias <= dev.getAlias();
            if(null != alias)
            {
               // Write alias
               WriteString(_out, FOURCC_MIDIDEVCFG_ALIAS, alias);
            }

            // Write profiles
            byte midiCh = 0;
            loop(16)
            {
               String profileId <= dev.getProfileId(midiCh);

               if(null != profileId)
               {
                  if(!profileId.isBlank())
                  {
                     // Write MIDI channel
                     WriteI8(_out, FOURCC_MIDIDEVCFG_PROFILE_CH, midiCh);

                     // Write profile id
                     WriteString(_out, FOURCC_MIDIDEVCFG_PROFILE_ID, profileId);
                  }
               }

               // Next channel profile
               midiCh++;
            } // loop midi ch

            // Finish FOURCC_MIDIDEVCFG chunk
            FixChunkSize(_out, cfgStartOff);
         } // isProjectSpecific()
      } // foreach dev

      // Finish FOURCC_MIDIDEVCFGS chunk
      FixChunkSize(_out, allStartOff);
   }

   // // <method_write.png>
   // static protected method WriteWaveform(Stream _out, StWaveform wf) {
   //    int waveOff = _out.offset;
   //    WriteChunkHeader(_out, FOURCC_WAVEFORM, 0);
   //    if(null != wf)
   //    {
   //       // Write waveform type
   //       WriteI8(_out, FOURCC_WAVEFORM_TYPE, wf.uiGetType());

   //       // trace "xxx write waveform name=\""+wf.name+"\" type="+wf.uiGetType();

   //       // Write waveform name
   //       WriteString(_out, FOURCC_WAVEFORM_NAME, wf.name);

   //       // Write #channels
   //       WriteI8(_out, FOURCC_WAVEFORM_NUMCHANNELS, wf.numChannels);

   //       // Write default loop offset
   //       WriteI32(_out, FOURCC_WAVEFORM_LOOPOFF, wf.loopOffset);

   //       // Write default loop length
   //       WriteI32(_out, FOURCC_WAVEFORM_LOOPLEN, wf.loopLen);

   //       // Write base frequency
   //       WriteF32(_out, FOURCC_WAVEFORM_BASEFREQ, wf.baseFrequency);

   //       // Write sample rate
   //       WriteF32(_out, FOURCC_WAVEFORM_SAMPLERATE, wf.sampleRate);

   //       // Write sample data
   //       if(Waveforms.TYPE_PROCEDURAL == wf.uiGetType())
   //       {
   //          // Write size of (initially empty) sample (num sample frames)
   //          WriteI32(_out, FOURCC_WAVEFORM_PROCSIZE, wf.numFrames);
   //       }
   //       else if(Waveforms.TYPE_EMBEDDED == wf.uiGetType())
   //       {
   //          // Write persistent sample data
   //          if(wf.sampleData instanceof FloatArray)
   //          {
   //             WriteFloatArray(_out, FOURCC_WAVEFORM_DATA, wf.sampleData);
   //          }
   //          else
   //          {
   //             trace "[~~~] SongFileWriter::WriteWaveform: sampleData is NULL (wf.name=\""+wf.name+"\")";
   //          }
   //       }
   //       else if(Waveforms.IsExternal(wf))
   //       {
   //          // Write UI pathname
   //          WriteString(_out, FOURCC_WAVEFORM_UIPATHNAME, wf.uiGetPathName());
   //       }

   //       // Write UI offset
   //       WriteF32(_out, FOURCC_WAVEFORM_UIOFFSET, wf.uiGetOffset());

   //       // Write UI zoom
   //       WriteF32(_out, FOURCC_WAVEFORM_UIZOOM, wf.uiGetZoom());


   //    } // if null != wf

   //    // Finish waveform chunk
   //    FixChunkSize(_out, waveOff);
   // }

   // // <method_write.png>
   // static protected method WriteWaveforms(Stream _out) {
   //    int startOff = _out.offset;

   //    // Write waveforms header
   //    WriteChunkHeader(_out, FOURCC_WAVEFORMS, 0);

   //    int i = 0;
   //    loop(Waveforms.GetNum())
   //    {
   //       StWaveform wf <= Waveforms.GetByIdx(i);
   //       WriteWaveform(_out, wf);
   //       i++;
   //    } // for i..Waveforms.GetNum()

   //    // Finish waveforms chunk
   //    FixChunkSize(_out, startOff);
   // }

   // <method_write.png>
   static protected method WriteSongCtlTagsState(Stream _out) {

      // Write (other) state (encoder mapping)
      int startOff = _out.offset;

      WriteChunkHeader(_out, FOURCC_SONG_CTLTAGS_STATE, 0);

      root_form.pg_ctltag.saveState(_out);

      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteSongCtlTags(Stream _out) {

      int startOff = _out.offset;

      // Write MIDIMap context header
      WriteChunkHeader(_out, FOURCC_SONG_CTLTAGS, 0);

      // Write entries
      CtlTagEntry *e;

      foreach e in current_song.ctltag_entries
      {
         // Write entry header
         int entryStartOff = _out.offset;
         WriteChunkHeader(_out, FOURCC_SONG_CTLTAG_ENTRY, 0);

         // Write tag name
         WriteString(_out, FOURCC_SONG_CTLTAG_ENTRY_NAME, e.tag_name);

         // Write tag name edit flag
         WriteI8(_out, FOURCC_SONG_CTLTAG_ENTRY_NAME_EDITED, e.b_name_edited);

         // Write tag group
         WriteI8(_out, FOURCC_SONG_CTLTAG_ENTRY_GROUP, e.group_idx);

         // Write push pad idx
         WriteI8(_out, FOURCC_SONG_CTLTAG_ENTRY_PUSH_PAD, e.push_pad_idx);

         // Write push pad color
         WriteI8(_out, FOURCC_SONG_CTLTAG_ENTRY_PUSH_COLOR, e.push_color);

         // Write push pad type
         WriteI8(_out, FOURCC_SONG_CTLTAG_ENTRY_PUSH_TYPE, e.push_type);

         // Write push pad value a
         WriteI16(_out, FOURCC_SONG_CTLTAG_ENTRY_PUSH_VAL_A, e.val_a);

         // Write push pad value b
         WriteI16(_out, FOURCC_SONG_CTLTAG_ENTRY_PUSH_VAL_B, e.val_b);

         // Write push pad state
         WriteI8(_out, FOURCC_SONG_CTLTAG_ENTRY_PUSH_PAD_STATE, e.pad_state);

         // Write push last sent value
         WriteI16(_out, FOURCC_SONG_CTLTAG_ENTRY_PUSH_LAST_SENT, e.last_sent_val);

         // Write send reset flag
         WriteI8(_out, FOURCC_SONG_CTLTAG_ENTRY_SEND_RESET, e.b_send_reset);

         // Write reset value
         WriteI16(_out, FOURCC_SONG_CTLTAG_ENTRY_RESET_VALUE, e.reset_value);

         WriteMIDIMapEventAttribs(_out, e.mm_event, false/*bMorph*/, false/*bMorphSrc*/);

         // Fix entry header
         FixChunkSize(_out, entryStartOff);

         // Next entry
      }

      // Finish CtlTag chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteSongCursorPos(Stream _out) {
      int startOff = _out.offset;

      WriteChunkHeader(_out, FOURCC_SONG_CURSORPOS, 0);

      _out.i8 = 1; // version

      // _out.i32 = current_song.ui_song_offset;
      _out.i32 = current_song.song_offset;

      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteSongAttributes(Stream _out) {
      int startOff = _out.offset;
      int coff;
      ST_Song song <= current_song;

      // Write song chunk header
      WriteChunkHeader(_out, FOURCC_SONG, 0);

      // Write song name
      WriteString(_out, FOURCC_SONG_NAME, song.song_name);

      // Write sub-song name
      WriteString(_out, FOURCC_SONG_SUBNAME, song.sub_name);

      // Write song author
      WriteString(_out, FOURCC_SONG_AUTHOR, song.author_name);

      // Write song comment
      WriteString(_out, FOURCC_SONG_COMMENT, song.author_comment);

      // Write SMF export path name
      WriteString(_out, FOURCC_SONG_SMFEXPORTPATH, song.smf_export_pathname);

      // Write song BPM
      WriteF32(_out, FOURCC_SONG_BPM, song.bpm);

      // Write song PPQ
      WriteI32(_out, FOURCC_SONG_PPQ, song.ppq);

      // Write song time signature #beats
      WriteI8(_out, FOURCC_SONG_SIG_BEATS, song.sig_beats);

      // Write song time signature notelen
      WriteI8(_out, FOURCC_SONG_SIG_NOTELEN, song.sig_notelen);

      // Write markers
      if((song.song_markers.numElements) > 0)
      {
         WriteIntArray(_out, FOURCC_SONG_MARKERS, song.song_markers);
      }

      // Write marker labels
      WriteStringArray(_out, FOURCC_SONG_MARKER_LABELS, song.song_marker_labels);

      // Write cursor position
      WriteSongCursorPos(_out);

      // Write cycle length
      WriteI16(_out, FOURCC_SONG_CYCLELENGTH, song.cycle_length);

      // Write cycle enable
      WriteI8(_out, FOURCC_SONG_CYCLEENABLE, song.b_cycle);

      // Write pipenode A/B
      int abOff = _out.offset;
      WriteChunkHeader(_out, FOURCC_SONG_PIPENODE_AB, 0);
      root_form.pg_node.savePipeNodeAB(_out);
      FixChunkSize(_out, abOff);

      // Write pipenode max GID
      WriteI32(_out, FOURCC_SONG_PIPENODE_GID_MAX, song.nodeGetMaxGID());

      // Write pipe root
      int pipeRootOff = _out.offset;
      WriteChunkHeader(_out, FOURCC_SONG_PIPEROOT, 0);
      PipeIO.PipeRoot_SaveState(_out);
      FixChunkSize(_out, pipeRootOff);

      // Write (AudioRecordDialog) sample name prefixes
      int recOff = _out.offset;
      WriteChunkHeader(_out, FOURCC_SONG_SAMPLE_PREFIXES, 0);
      _out << AudioRecordDialog.name_prefix_history;
      FixChunkSize(_out, recOff);

      // Write (AudioLiveRecForm) sample filters
      int fltOff = _out.offset;
      WriteChunkHeader(_out, FOURCC_SONG_SAMPLE_FILTERS, 0);
      _out << AudioLiveRecForm.sample_filters;
      FixChunkSize(_out, fltOff);

      // Write ctl tag entries
      WriteSongCtlTags(_out);

      // Write ctl tag state (encoder mapping)
      WriteSongCtlTagsState(_out);

      // Finish song chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteMIDIMapEventTypeAttribs(Stream _out, MIDIMapEventType e) {
      // Write type
      WriteI8(_out, FOURCC_MMC_ENTRY_TYPE, e.type);

      // Write ext_type (note/cc/rpn/nrpn)
      WriteI16(_out, FOURCC_MMC_ENTRY_EXT_TYPE, e.ext_type);

      // Write class_type
      WriteI8(_out, FOURCC_MMC_ENTRY_CLASS_TYPE, e.class_type);

      // Write syn_type
      WriteI8(_out, FOURCC_MMC_ENTRY_SYN_TYPE, e.syn_type);
   }

   // <method_write.png>
   static protected WriteMIDIMapEventAttribs(Stream _out, MIDIMapEvent e, boolean _bMorph, boolean _bMorphSrc) {

      WriteMIDIMapEventTypeAttribs(_out, e);

      // Write device alias or name
      WriteString(_out, FOURCC_MMC_ENTRY_DEV, e.getAliasOrDeviceName());

      // Write midi channel
      WriteI8(_out, FOURCC_MMC_ENTRY_CH, e.dev_ch);

      if(_bMorph)
      {
         // Write b_morph_all_ch
         WriteI8(_out, FOURCC_MMS_ENTRY_MORPH_ALL_CH, e.b_morph_all_ch);

         // Write b_morph_all_types
         WriteI8(_out, FOURCC_MMS_ENTRY_MORPH_ALL_TYPES, e.b_morph_all_types);

         // Write b_morph_all_subtypes
         WriteI8(_out, FOURCC_MMS_ENTRY_MORPH_ALL_SUBTYPES, e.b_morph_all_subtypes);

         // Write morph_type
         WriteI16(_out, FOURCC_MMS_ENTRY_MORPH_TYPE, e.morph_type);

         // Write morph_arg1
         WriteI16(_out, FOURCC_MMS_ENTRY_MORPH_ARG1, e.morph_arg1);

         // Write morph_arg2
         WriteI16(_out, FOURCC_MMS_ENTRY_MORPH_ARG2, e.morph_arg2);

         // Write b_morph_note_onoff
         WriteI8(_out, FOURCC_MMS_ENTRY_MORPH_NOTE_ONOFF, e.b_morph_note_onoff);

         // Write morph label
         if(null != e.morph_label)
         {
            WriteString(_out, FOURCC_MMS_ENTRY_MORPH_LABEL, e.morph_label);
         }

         // Write last assigned morph auto label
         if(null != e.morph_auto_label)
         {
            WriteString(_out, FOURCC_MMS_ENTRY_MORPH_AUTO_LABEL, e.morph_auto_label);
         }

         if(_bMorphSrc)
         {
            // Write morph last arg1 (FaderPort scene recall)
            WriteI16(_out, FOURCC_MMS_ENTRY_MORPH_LASTARG1, e.last_morph_src_arg1);
         }
      }
   }

   // <method_write.png>
   static protected method WriteMMC(Stream _out, MIDIMapContext ctx) {
      int startOff = _out.offset;

      // Write MIDIMap context header
      WriteChunkHeader(_out, FOURCC_MMC, 0);

      // Write context name
      WriteString(_out, FOURCC_MMC_NAME, ctx.mmc_name);

      // Write push background/inactive colors
      WriteIntArray(_out, FOURCC_MMC_PUSH_BGCOLS, ctx.push_pad_colors_inactive);

      // Write push foreground/active colors
      WriteIntArray(_out, FOURCC_MMC_PUSH_FGCOLS, ctx.push_pad_colors_active);

      // Write MIDI morph group and scene indices
      if(-1 != ctx.midimorph_group_idx)
      {
         WriteI8(_out, FOURCC_MMC_MIDIMORPH_GROUP, ctx.midimorph_group_idx);
         WriteI8(_out, FOURCC_MMC_MIDIMORPH_SCENE, ctx.midimorph_scene_idx);
      }

      // Write entries
      MIDIMapEvent *e;

      foreach e in ctx.mmc_entries
      {
         // Write entry header
         int entryStartOff = _out.offset;
         WriteChunkHeader(_out, FOURCC_MMC_ENTRY, 0);

         // Write target name
         WriteString(_out, FOURCC_MMC_ENTRY_TARGET, (e.bound_target.target_name));

         WriteMIDIMapEventAttribs(_out, e, false/*bMorph*/, false/*bMorphSrc*/);

         // Fix entry header
         FixChunkSize(_out, entryStartOff);

         // Next entry
      }

      // Finish MMC chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteMIDIMap(Stream _out, int _fourCC, MIDIMapContext _mmc) {
      int startOff = _out.offset;

      // Write MIDIMap header
      WriteChunkHeader(_out, _fourCC, 0);

      // Write MIDIMap context
      WriteMMC(_out, _mmc);

      // MMC sub-views
      byte numViews = _mmc.mmcViewGetNum();

      if(numViews > 0)
      {
         byte viewId = 0;

         loop(numViews)
         {
            MIDIMapContext subMMC <= _mmc.mmcViewGetById(viewId);

            if(null != subMMC)
            {
               // Write MMC view id
               WriteI8(_out, FOURCC_MIDIMAP_VIEWID, viewId);

               // Write sub-view
               WriteMMC(_out, subMMC);
            }

            // Next sub-view
            viewId++;
         }
      }

      // Finish MIDIMAP chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteMIDIMaps(Stream _out) {
      int startOff = _out.offset;

      // Write header
      WriteChunkHeader(_out, FOURCC_MIDIMAPS, 0);

      WriteMIDIMap(_out, FOURCC_MIDIMAP_GLOBAL,     root_form);
      WriteMIDIMap(_out, FOURCC_MIDIMAP_PGSTART,    root_form.pg_start);
      WriteMIDIMap(_out, FOURCC_MIDIMAP_PGMORPH,    root_form.pg_editmidimorph);
      WriteMIDIMap(_out, FOURCC_MIDIMAP_PGPIPEROOT, root_form.pg_piperoot);
      WriteMIDIMap(_out, FOURCC_MIDIMAP_PGPIPE,     root_form.pg_pipe);
      WriteMIDIMap(_out, FOURCC_MIDIMAP_PGPIPEMAP,  root_form.pg_pipemap);
      WriteMIDIMap(_out, FOURCC_MIDIMAP_PGPROJECT,  root_form.pg_project);
      WriteMIDIMap(_out, FOURCC_MIDIMAP_PGCTLTAG,   root_form.pg_ctltag);

      // Write MIDI map for each node class
      PointerArray classes <= TKS.findClassesByPrefix(null/*nsp*/, "Node");
      Object clazz;
      MIDIMapContext *mmc;
      foreach clazz in classes
      {
         if(clazz instanceof Node)
         {
            Value ret;
            if(TKS.evalMethodByName(clazz, "nodeGetEditor", null/*args*/, ret))
            {
               mmc <= ret.objectValue;

               if(mmc instanceof MIDIMapContext)
               {
                  WriteString(_out, FOURCC_MIDIMAP_NODEEDITOR_CLASSNAME, clazz.yacMetaClassName());
                  WriteMIDIMap(_out, FOURCC_MIDIMAP_NODEEDITOR_DATA, mmc);
               }
            }
         }
      }

      // Write previously stashed MIDI maps for currently unloaded node classes
      String *nodeClassName;
      foreach nodeClassName in g_stashed_raw_project_node_mmc_data
      {
         Buffer bufStash <= g_stashed_raw_project_node_mmc_data.get(nodeClassName);
         if(null != bufStash)
         {
            Global.Debug2("SongFileWriter::WriteMIDIMaps: write stashed MMC for node class \""+nodeClassName+"\"");
            WriteString(_out, FOURCC_MIDIMAP_NODEEDITOR_CLASSNAME, nodeClassName);
            int off = _out.offset;
            WriteChunkHeader(_out, FOURCC_MIDIMAP_NODEEDITOR_DATA, 0);
            bufStash.offset = 0;
            _out.writeBuffer(bufStash, 0/*off*/, bufStash.size);
            FixChunkSize(_out, off);
            // (note) keep stash for next save
         }
      }

      // Finish MIDIMAPS chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteMMS(Stream _out, MIDIMorphScene mms, int groupId, int mmsId) {
      int startOff = _out.offset;

      // Write MORPHSCENE context header
      WriteChunkHeader(_out, FOURCC_MMS, 0);

      if(groupId >= 0)
      {
         // Write scene id
         WriteI16(_out, FOURCC_MMS_ID, mmsId | (groupId << 8));
      }
      // else: saving MIDIMorphScene preset file

      // Write scene name
      WriteString(_out, FOURCC_MMS_NAME, mms.mms_name);

      // Write last selected row
      WriteI16(_out, FOURCC_MMS_LASTROW, mms.last_selected_row_idx);

      // Write entries
      MIDIMapEvent *e;

      foreach e in mms.mms_entries
      {
         // Write entry header
         int entryStartOff = _out.offset;
         WriteChunkHeader(_out, FOURCC_MMS_ENTRY, 0);

         // Write src attribs
         WriteMIDIMapEventAttribs(_out, e, true/*bMorph*/, true/*bMorphSrc*/);

         // Write morph target (dst) attribs
         int morphStartOff = _out.offset;
         WriteChunkHeader(_out, FOURCC_MMS_ENTRY_MORPH_TARGET, 0);
         WriteMIDIMapEventAttribs(_out, e.morph_target, true/*bMorph*/, false/*bMorphSrc*/);
         FixChunkSize(_out, morphStartOff);

         // Write morph enable
         WriteBoolean(_out, FOURCC_MMS_ENTRY_MORPH_ENABLE, e.b_morph_enable);

         // Fix entry header
         FixChunkSize(_out, entryStartOff);

         // Next entry
      }

      // Finish MMS chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteMIDIMorphScenes(Stream _out) {
      int startOff = _out.offset;

      // Write header
      WriteChunkHeader(_out, FOURCC_MORPHSCENES, 0);

      MIDIMorphScene *mms;

      int groupIdx = 0;

      loop(MIDIMorphScene.NUM_GROUPS)
      {
         int mmsId = 0;

         PointerArray scenes <= MIDIMorphScene.GetSceneArray(groupIdx);

         foreach mms in scenes
         {
            if((mms.mms_entries.numElements) > 0)
            {
               WriteMMS(_out, mms, groupIdx, mmsId);
            }

            // Next scene
            mmsId++;
         }

         // Next group
         groupIdx++;
      } // loop groups

      // Write current scene indices
      WriteChunkHeader(_out, FOURCC_MORPHSCENES_CURRENT, (8+1)*1);
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(0);  // A
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(1);  // B
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(2);  // C
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(3);  // D
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(4);  // E
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(5);  // F
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(6);  // G
      _out.i8 = MIDIMorphScene.GetCurrentSceneIdx(7);  // H
      _out.i8 = MIDIMorphScene.last_changed_group;

      // Write multi presets
      int startOffMultis = _out.offset;
      WriteChunkHeader(_out, FOURCC_MORPHSCENES_MULTIS, 0);
      MIDIMorphScene.SaveStateMultis(_out);
      FixChunkSize(_out, startOffMultis);

      // Finish MORPHSCENES chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteSubSongs(Stream _out) {

      int startOff = _out.offset;

      int cSubSongIdx = Global.GetSubSongIdx();

      // Write SubSongs header
      WriteChunkHeader(_out, FOURCC_SUBSONGS, 0);

      // Write default subsong idx
      WriteI16(_out, FOURCC_SUBSONGS_DEFAULT, cSubSongIdx);

      ST_Song *song;

      int idx = 0;
      foreach song in all_songs
      {
         Global.SelectSubSongByIdx(idx, false, false/*bViaUI*/);

         // Write song length, author, comment, piperoot, ..
         WriteSongAttributes(_out);

         // Next sub-song
         idx++;
      }

      Global.SelectSubSongByIdx(cSubSongIdx, false, false/*bViaUI*/);

      // Finish subsongs chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteFaderPort(Stream _out) {
      int startOff = _out.offset;

      // Write header
      WriteChunkHeader(_out, FOURCC_FADERPORT, 0);

      faderport.saveState(_out);

      // Finish FADERPORT chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteConsole1(Stream _out) {
      int startOff = _out.offset;

      // Write header
      WriteChunkHeader(_out, FOURCC_CONSOLE1, 0);

      console1.saveState(_out);

      // Finish CONSOLE1 chunk
      FixChunkSize(_out, startOff);
   }

   // <method_write.png>
   static protected method WriteProfileData(Stream _out) {
      int startOff = _out.offset;

      // Write header
      WriteChunkHeader(_out, FOURCC_PROFILEDATA, 0);

      MIDISynthProfile *profile;
      MIDISynthProfileData *data;

      foreach profile in MIDI.midi_synth_profiles
      {
         // Write header
         if(profile.hasDataClass())
         {
            int entryOff = _out.offset;

            Buffer bufStash <= g_stashed_raw_project_midiprofiledata.get(profile.midi_profile_id);
            if(null != bufStash)
            {
               Global.Debug2("SongFileWriter::WriteProfileData: write stashed profile_id=\""+profile.midi_profile_id+"\"");
               // Data from last project-load, synth editor (or NodeProxy) hasn't been used since
               WriteChunkHeader(_out, FOURCC_PROFILEDATA_ENTRY, 0);
               Utils.WriteString(_out, profile.midi_profile_id);

               // Write profile data
               bufStash.offset = 0;
               _out.writeBuffer(bufStash, 0/*off*/, bufStash.size);

               // Finish PROFILEDATA_ENTRY chunk
               FixChunkSize(_out, entryOff);

               // (note) keep stash for next save
            }
            else
            {
               data <= MIDI.GetMIDISynthProfileData(profile.midi_profile_id);
               if(null != data)
               {
                  WriteChunkHeader(_out, FOURCC_PROFILEDATA_ENTRY, 0);
                  Utils.WriteString(_out, profile.midi_profile_id);

                  // Write profile data
                  //  (note) some editors (e.g. Prophet12) require the EditForm to be initialized
                  MIDI.LazyInitSynthEditorProjectProfileDataByProfileId(profile.midi_profile_id);
                  data.saveProjectMIDIProfileData(_out);

                  // Finish PROFILEDATA_ENTRY chunk
                  FixChunkSize(_out, entryOff);
               }
            }
         }
      }

      // Finish PROFILEDATA chunk
      FixChunkSize(_out, startOff);
   }

   // <save.png>
   static =replay= public method Save(String _fileName) : boolean {
      local File f;

      if(f.openLocal(_fileName, IOS_OUT))
      {
         f.byteOrder = LITTLE_ENDIAN;

         // Write header
         WriteChunkHeader(f, FOURCC_SONG_FILEHEADER, 0);

         // Write project-specific MIDI device configs (aliases, profile ids)
         WriteMIDIDevCfgs(f, false/*bIn*/);
         WriteMIDIDevCfgs(f, true/*bOut*/);

         // Write out device table (for MIDIPipeRoot)
         WritePipeRootDevMap(f);

         // // // Write waveforms
         // // WriteWaveforms(f);

         // Write sub-songs
         WriteSubSongs(f);

         // Write MIDI maps
         WriteMIDIMaps(f);

         // Write morph scenes
         WriteMIDIMorphScenes(f);

         // Write FaderPort state
         WriteFaderPort(f);

         // Write Console1 state
         WriteConsole1(f);

         // Write per-project MIDI profile data
         WriteProfileData(f);

         // Finish SONG_FILEHEADER chunk
         FixChunkSize(f, 0);

         f.close();
         return true;
      }
      else
      {
         trace "[---] SongFileWriter::Save: failed to open file \""+_fileName+"\".";
         return false;
      }
   }

   // <save.png>
   static =replay= public method SaveSubSongStream(Stream _ofs, ST_Song _song) : boolean {

      _ofs.byteOrder = LITTLE_ENDIAN;

      // Write header
      WriteChunkHeader(_ofs, FOURCC_SUBSONG_FILEHEADER, 0);

      // Write project-specific MIDI device configs (aliases, profile ids)
      WriteMIDIDevCfgs(_ofs, false/*bIn*/);
      WriteMIDIDevCfgs(_ofs, true/*bOut*/);

      // Write out device table (for MIDIPipeRoot)
      WritePipeRootDevMap(_ofs);

      int cSubSongIdx = Global.GetSubSongIdx();
      int idx = all_songs.indexOfPointer(_song, 0);
      Global.SelectSubSongByIdx(idx, false/*bSaveUI*/, false/*bViaUI*/);

      // Write song length, author, comment, piperoot, ..
      WriteSongAttributes(_ofs);

      Global.SelectSubSongByIdx(cSubSongIdx, false/*bSaveUI*/, false/*bViaUI*/);

      // Finish SUBSONG_FILEHEADER chunk
      FixChunkSize(_ofs, 0);

      return true;
   }

   // <save.png>
   static public =replay= method SaveSubSongFile(String _fileName, ST_Song _song) : boolean {
      boolean bRet = false;

      Global.Debug("SongFileWriter::SaveSubSongFile: fileName=\""+_fileName+"\".");
      local String nativePathName <= Utils.ToNativePathName(_fileName);

      local File f;
      if(f.openLocal(nativePathName, IOS_OUT))
      {
         if(SaveSubSongStream(f, _song))
         {
            bRet = true;
         }

         f.close();
      }
      else
      {
         trace "[---] SongFileWriter::SaveSubSongFile: failed to open file \""+nativePathName+"\".";
      }

      return bRet;
   }

   // <save.png>
   static =replay= public method SavePipeStream(Stream _ofs, MIDIPipe _p) : boolean {

      _ofs.byteOrder = LITTLE_ENDIAN;

      // Write header
      WriteChunkHeader(_ofs, FOURCC_PIPE_FILEHEADER, 0);

      // Write project-specific MIDI device configs (aliases, profile ids)
      WriteMIDIDevCfgs(_ofs, false/*bIn*/);
      WriteMIDIDevCfgs(_ofs, true/*bOut*/);

      // Write out device table (for MIDIPipeRoot)
      WritePipeRootDevMap(_ofs);

      // Write pipe
      int pipeStartOff = _ofs.offset;

      // Write Pipe header
      WriteChunkHeader(_ofs, FOURCC_PSTREAM_PIPE, 0);

      PipeIO.Pipe_SaveState(_p, _ofs);

      // Finish PSTREAM_PIPE chunk
      FixChunkSize(_ofs, pipeStartOff);

      // Finish PIPE_FILEHEADER chunk
      FixChunkSize(_ofs, 0);

      return true;
   }

   // <save.png>
   static public =replay= method SavePipeFile(String _fileName, MIDIPipe _p) : boolean {
      boolean bRet = false;

      Global.Debug("SongFileWriter::SavePipeFile: fileName=\""+_fileName+"\".");
      local String nativePathName <= Utils.ToNativePathName(_fileName);

      local File f;
      if(f.openLocal(nativePathName, IOS_OUT))
      {
         if(SavePipeStream(f, _p))
         {
            bRet = true;
         }

         f.close();
      }
      else
      {
         trace "[---] SongFileWriter::SavePipeFile: failed to open file \""+nativePathName+"\".";
      }

      return bRet;
   }

   // <save.png>
   static =replay= public method SaveNodeStream(Stream _ofs, MIDIPipeNode _n) : boolean {

      _ofs.byteOrder = LITTLE_ENDIAN;

      // Write header
      WriteChunkHeader(_ofs, FOURCC_NODE_FILEHEADER, 0);

      // Write project-specific MIDI device configs (aliases, profile ids)
      WriteMIDIDevCfgs(_ofs, false/*bIn*/);
      WriteMIDIDevCfgs(_ofs, true/*bOut*/);

      // Write out device table (for MIDIPipeRoot)
      WritePipeRootDevMap(_ofs);

      // Write node
      int nodeStartOff = _ofs.offset;

      // Write Pipe header
      WriteChunkHeader(_ofs, FOURCC_NSTREAM_NODE, 0);

      PipeIO.PipeNode_SaveState(_n, _ofs);

      // Finish NSTREAM_NODE chunk
      FixChunkSize(_ofs, nodeStartOff);

      // Finish NODE_FILEHEADER chunk
      FixChunkSize(_ofs, 0);

      return true;
   }

   // <save.png>
   static public =replay= method SaveNodeFile(String _fileName, MIDIPipeNode _n) : boolean {
      boolean bRet = false;

      Global.Debug("SongFileWriter::SaveNodeFile: fileName=\""+_fileName+"\".");
      local String nativePathName <= Utils.ToNativePathName(_fileName);

      local File f;
      if(f.openLocal(nativePathName, IOS_OUT))
      {
         if(SaveNodeStream(f, _n))
         {
            bRet = true;
         }

         f.close();
      }
      else
      {
         trace "[---] SongFileWriter::SaveNodeFile: failed to open file \""+nativePathName+"\".";
      }

      return bRet;
   }

   // <save.png>
   static =replay= public method SaveMIDIMorphSceneStream(Stream _ofs, MIDIMorphScene _mms) : boolean {

      _ofs.byteOrder = LITTLE_ENDIAN;

      // Write header
      WriteChunkHeader(_ofs, FOURCC_MMS_FILEHEADER, 0);

      // Write project-specific MIDI device configs (aliases, profile ids)
      WriteMIDIDevCfgs(_ofs, false/*bIn*/);
      WriteMIDIDevCfgs(_ofs, true/*bOut*/);

      // Write out device table (for MIDIPipeRoot)
      WritePipeRootDevMap(_ofs);

      // Write pipe
      int mmsStartOff = _ofs.offset;
      Global.Debug("SongFileWriter::SaveMIDIMorphSceneStream: STREAM_MMS chunk start @mmsStartOff="+mmsStartOff);

      // Write MIDIMorphScene
      //   (note) groupId / mmsId will be ignored when scene is loaded (replaced by target group/id)
      WriteMMS(_ofs, _mms, -1/*groupId=skip*/, -1/*mmsId=skip*/);

      // Finish MMS_FILEHEADER chunk
      FixChunkSize(_ofs, 0);

      return true;
   }

   // <save.png>
   static public =replay= method SaveMIDIMorphSceneFile(String _fileName, MIDIMorphScene _mms) : boolean {
      boolean bRet = false;

      Global.Debug("SongFileWriter::SaveMIDIMorphSceneFile: fileName=\""+_fileName+"\".");
      local String nativePathName <= Utils.ToNativePathName(_fileName);

      local File f;
      if(f.openLocal(nativePathName, IOS_OUT))
      {
         if(SaveMIDIMorphSceneStream(f, _mms))
         {
            bRet = true;
         }

         f.close();
      }
      else
      {
         trace "[---] SongFileWriter::SaveMIDIMorphSceneFile: failed to open file \""+nativePathName+"\".";
      }

      return bRet;
   }

}
