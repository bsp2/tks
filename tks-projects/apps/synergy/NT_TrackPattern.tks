// ----
// ---- file   : NT_TrackPattern.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2006-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: ??Sep2006
// ----
// ---- changed: ?????????, 13Jan2010, 15Jan2010, 17Jan2010, 18Jan2010, 21Feb2010, 23Feb2010
// ----          01Mar2010, 29Apr2010, 15Apr2010, 31Jul2010, 01Aug2010, 21Sep2010, 24Sep2010
// ----          20Oct2010, 23Oct2010, 28Feb2011, 10Mar2011, 26Mar2011, 02Apr2011, 05Jan2012
// ----          07Jan2012, 08Jan2012, 31Jan2012, 05Feb2012, 26Jun2012, 03Nov2012, 22Dec2012
// ----          05Jan2013, 25Mar2013, 09May2013, 10May2013, 11May2013, 12May2013, 17Jun2013
// ----          10Jan2015, 11Jan2015, 12Jan2015, 17Jan2015, 28Jan2015, 06Feb2015, 08Feb2015
// ----          09Feb2015, 11Feb2015, 15Feb2015, 22Feb2015, 28Feb2015, 08Mar2015, 19Apr2015
// ----          26Apr2015, 27Apr2015, 29Apr2015, 29Apr2015, 02Jul2015, 28Jul2015, 04Dec2015
// ----          21Dec2015, 29Jan2016, 19May2016, 12Sep2016, 02Oct2016, 20Jan2017, 04Feb2017
// ----          05Mar2017, 06Jun2017, 01Jul2017, 04Oct2017, 04Jan2018, 03Mar2018, 07Mar2018
// ----          01Jun2018, 12Jan2019, 25Jun2019, 02Aug2019, 22Sep2019, 24Oct2019, 06Mar2020
// ----          25Apr2020, 28Apr2020, 01Sep2020, 24Sep2020, 31Jan2021, 04Jan2022, 16Apr2022
// ----          13Jun2025
// ----
// ----
// ----

module MNT_TrackPattern;

use namespace ui;
use namespace st2;


class NT_TrackPattern : NT_Defs {

   define int PIANO_DUR_INF = 9999999;  // for PianoWidget

   int pat_nr;

   NodeTracker *parent_node;
   NT_Track *parent_track;
   NT_MetaPattern *meta_pattern;

   static StringArray ctl_infos = [
      // CTL_NOTE1:
      "CTL_NOTE1 (#0)\n\n"
      " 0x00..0x7F (=> C-0 .. B-B)\n\n"
      "  - Note 1 on/off"
      ,

      // CTL_NOTE2:
      "CTL_NOTE2 (#1)\n\n"
      " 0x00..0x7F (=> C-0 .. B-B)\n\n"
      "  - Note 2 on/off"
      ,

      // CTL_NOTE3:
      "CTL_NOTE3 (#2)\n\n"
      " 0x00..0x7F (=> C-0 .. B-B)\n\n"
      "  - Note 3 on/off"
      ,

      // CTL_NOTE4:
      "CTL_NOTE4 (#3)\n\n"
      " 0x00..0x7F (=> C-0 .. B-B)\n\n"
      "  - Note 4 on/off"
      ,

      // CTL_NOTE5:
      "CTL_NOTE5 (#4)\n\n"
      " 0x00..0x7F (=> C-0 .. B-B)\n\n"
      "  - Note 5 on/off"
      ,

      // CTL_VEL1:
      "CTL_VEL1 (#5)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 1 on/off velocity"
      ,

      // CTL_VEL2:
      "CTL_VEL2 (#6)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 2 on/off velocity\n\n"
      "   (note) in case of a CTL_NOTE2 event without a CTL_VEL2 event on the same tick, CTL_VEL1 is used"
      ,

      // CTL_VEL3:
      "CTL_VEL3 (#7)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 3 on/off velocity\n\n"
      "   (note) in case of a CTL_NOTE3 event without a CTL_VEL3 event on the same tick, CTL_VEL1 is used"
      ,

      // CTL_VEL4:
      "CTL_VEL4 (#8)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 4 on/off velocity\n\n"
      "   (note) in case of a CTL_NOTE4 event without a CTL_VEL4 event on the same tick, CTL_VEL1 is used"
      ,

      // CTL_VEL5:
      "CTL_VEL5 (#9)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 5 on/off velocity\n\n"
      "   (note) in case of a CTL_NOTE5 event without a CTL_VEL5 event on the same tick, CTL_VEL1 is used"
      ,

      // CTL_DUR1:
      "CTL_DUR1 (#10)\n\n"
      " 0x00..0xFF (=> 0 .. 255)\n\n"
      "  - Note 1 duration (ticks)\n"
      "  - 0=manual note off\n"
      ,

      // CTL_DUR2:
      "CTL_DUR2 (#11)\n\n"
      " 0x00..0xFF (=> 0 .. 255)\n\n"
      "  - Note 2 duration (ticks)\n"
      "  - 0=manual note off\n"
      "   (note) in case of a CTL_NOTE2 event without a CTL_DUR2 event on the same tick, CTL_DUR1 is used"
      ,

      // CTL_DUR3:
      "CTL_DUR3 (#12)\n\n"
      " 0x00..0xFF (=> 0 .. 255)\n\n"
      "  - Note 3 duration (ticks)\n"
      "  - 0=manual note off\n"
      "   (note) in case of a CTL_NOTE3 event without a CTL_DUR3 event on the same tick, CTL_DUR1 is used"
      ,

      // CTL_DUR4:
      "CTL_DUR4 (#13)\n\n"
      " 0x00..0xFF (=> 0 .. 255)\n\n"
      "  - Note 4 duration (ticks)\n"
      "  - 0=manual note off\n"
      "   (note) in case of a CTL_NOTE4 event without a CTL_DUR4 event on the same tick, CTL_DUR1 is used"
      ,

      // CTL_DUR5:
      "CTL_DUR5 (#14)\n\n"
      " 0x00..0xFF (=> 0 .. 255)\n\n"
      "  - Note 5 duration (ticks)\n"
      "  - 0=manual note off\n"
      "   (note) in case of a CTL_NOTE5 event without a CTL_DUR5 event on the same tick, CTL_DUR1 is used"
      ,

      // CTL_POLYAT1:
      "CTL_POLYAT1 (#15)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 1 polyphonic aftertouch (key pressure)\n"
      ,

      // CTL_POLYAT2:
      "CTL_POLYAT2 (#16)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 2 polyphonic aftertouch (key pressure)\n"
      ,

      // CTL_POLYAT3:
      "CTL_POLYAT3 (#17)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 3 polyphonic aftertouch (key pressure)\n"
      ,

      // CTL_POLYAT4:
      "CTL_POLYAT4 (#18)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 4 polyphonic aftertouch (key pressure)\n"
      ,

      // CTL_POLYAT5:
      "CTL_POLYAT5 (#19)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Note 5 polyphonic aftertouch (key pressure)\n"
      ,

      // CTL_INSTR:
      "CTL_INSTR (#20)\n\n"
      " 0x00..0x3D (=> 0..9, A..Z, a..z)\n\n"
      "  - Instrument selection\n"
      "  - When sliding, (re-)selecting the instrument will retrigger the current voice(s)\n"
      "  - Selecting the instrument will send a MIDI bank/program select (if enabled)"
      ,

      // CTL_PC:
      "CTL_PC (#21)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Program change\n"
      "  (note) user controllers can be used to send bank selects, if required."
      ,

      // CTL_AT:
      "CTL_AT (#22)\n\n"
      " 0x00..0x7F (=> 0 .. 127)\n\n"
      "  - Channel after touch (pressure)"
      ,

      // CTL_PB:
      "CTL_PB (#23)\n\n"
      " 0x00..0x7F (=> -64 .. 63)\n\n"
      "  - Pitch bend modulation\n"
      "  (note) controller values will be scaled to the actual 14bit pitchbend range."
      ,

      // CTL_SLIDE:
      "CTL_SLIDE (#24)\n\n"
      " 0x00..0xFF (=> 0 .. 4.0)\n\n"
      "  - Note slide speed\n"
      "  - Modulates channel pitchbend\n"
      "  - 0=off\n"
      "  - 0xFF/255=immediately set new note frequency\n"
      ,

      // CTL_DELAY:
      "CTL_DELAY (#25)\n\n"
      " 0x00..0xFF (=> 0 .. 255)\n\n"
      "  - Track delay (#ticks)\n"
      ,

      // CTL_RETRIG:
      "CTL_RETRIG (#26)\n\n"
      " 0x00 .. 0xFF (=> $xy)\n\n"
      "  - Note retrig ($xy: x=tick delta (eighthnote / (x + 1)) y=#repeats. CTL_DURn determines note duration)\n"
      "      (todo) implement customizable tick table ?"
      ,


      // CTL_BPM:
      "CTL_BPM (#27)\n\n"
      " 0x20..0xFF (=> 32 .. 255)\n\n"
      "  - Beats per minute\n"
      "  (note) this will permanently change the tempo globally"
      ,

      // CTL_MUTE:
      "CTL_MUTE (#28)\n\n"
      " 0,>0 (=> 32 .. 255)\n\n"
      "  - Mute(>0) / unmute(0) track\n"
      ,

      // 29:
      "CTL_SEEK (#29)\n\n"
      " 0x00..0xFe (=> 0..255), 0xFF (255) = stop pattern\n"
      "  - Seek to step (queue until next step is reached) or stop pattern (0xFF)\n"
      ,

      // CTL_BPM_MUL:
      "CTL_BPM_MUL (#30)\n\n"
      " 0x00..0xFF (=> /2 .. *2), 0x00=/2, 0x80=*1, 0x100=*2\n\n"
      "  - Beats per minute multiplier\n"
      "  (note) this will temporarily change the tempo globally (BPM * mul)"
      ,

      // CTL_GROOVE:
      "CTL_GROOVE (#31)\n\n"
      " 0..63\n\n"
      "  - Pipe delay (#ticks)\n"
      "\n"
      "    (note) also affects recording latency"


   ];


   // "magic" note numbers
   define float MAGIC_NOTE_ALLTRACKNOTESOFF     = -128;  // "==="
   define float MAGIC_NOTE_ALLCHANNELNOTESOFF   = -129;  // "###"

   define float MAGIC_SEEK_STOP = 255;


   public int           offset;            // Current play offset (ticks)
   public PointerArray  controllers;       // (deletable) Envelope pointers

   IntArray usrctl_zeroreset_pending;

   public NT_RandomParams *random_params;  // or null. see NT_RandomDialog

   public byte keyjazz_instr_nr;  // when NodeTracker::b_per_pattern_kj_instr option is enabled


   // <init.png>
   public method init(NT_Track _parentTrack, int _patNr) {

      pat_nr = _patNr;

      parent_track <= _parentTrack;

      parent_node <= parent_track.parent_node;

      meta_pattern <= parent_node.getOrCreateMetaPattern(pat_nr);

      // // trace "xxx NT_TrackPattern::init: patNr="+_patNr+" meta_pattern="+#(meta_pattern);

      offset = 0;

      controllers.alloc(CTL_NUM);
      controllers.useAll();

      usrctl_zeroreset_pending.allocAndFill(CTL_NUMUSR, false);

      random_params <= null;
   }

   // <method_get.png>
   public method getOrCreateRandomParams() : NT_RandomParams {
      if(null == random_params)
      {
         random_params <= new NT_RandomParams;
         random_params.init();
      }
      // trace "xxx getOrCreateRandomParams: #lanes="+(random_params.lanes.numElements);
      return random_params;
   }

   // <method_get.png>
   public method getEnvelope(local int _ctlIdx) : Envelope {
      return controllers[_ctlIdx];
   }

   // <method_get.png>
   public method getUserEnvelope(local int _ctlIdx) : Envelope {
      return controllers[CTL_USR+_ctlIdx];
   }

   // <method_get.png>
   public method isEnvelopeEmpty(local int _ctlIdx) : boolean {
      Envelope env <= controllers.get(_ctlIdx);
      if(null != env)
      {
         return (0 == env.numElements);
      }
      return true;
   }

   // <method_get.png>
   public method isPatternEmpty() : boolean {
      Envelope *env;
      foreach env in controllers
      {
         if(null != env)
         {
            if(env.numElements > 0)
            {
               return false;
            }
         }
      }
      return true;
   }

   // // // <method_get.png>
   // // public method getControllerValueOrZero(local int _ctlIdx) : float {
   // //    explain "Return current ctl. value or 0";

   // //    Envelope env <= controllers[_ctlIdx];
   // //    if(null != env)
   // //    {
   // //       return env.get();
   // //    }
   // //    else
   // //    {
   // //       return 0.0f;
   // //    }
   // // }

   // // // <method_get.png>
   // // public method getControllerValueOrInv(local int _ctlIdx) : float {
   // //    explain "Return current ctl. value or 0";

   // //    Envelope env <= controllers[_ctlIdx];
   // //    if(null != env)
   // //    {
   // //       if(env.numElements)
   // //       {
   // //          return env.get();
   // //       }
   // //    }
   // //    return INVALID_VALUE;
   // // }

   // <method_get.png>
   public method haveNewEvent(int _ctlIdx) : boolean {
      Envelope env <= controllers[_ctlIdx];

      if(parent_track.injected_ctl_states[_ctlIdx])
         return true;

      if(null != env)
      {
         return env.isNewEvent();
      }

      return false;
   }

   // <method_get.png>
   public method getNewEvent(int _ctlIdx, boolean _bResetNew) : float {
      // Called when either the injected or the envelope value is new

      if(parent_track.injected_ctl_states[_ctlIdx])
      {
         return parent_track.injected_ctl_values[_ctlIdx];
      }

      Envelope env <= controllers[_ctlIdx];
      return env.getAndResetNew(_bResetNew);
   }

   // <method_get.png>
   public method getMostRecentEventOrZero(int _ctlIdx, boolean _bResetNew) : float {

      // CTL_VELn, CTL_INSTR

      FloatArray injectedCtlValues <= parent_track.injected_ctl_values;

      if(parent_track.injected_ctl_states[_ctlIdx])
      {
         return injectedCtlValues[_ctlIdx];
      }

      Envelope env <= controllers[_ctlIdx];

      if(null != env)
      {
         if(env.isNewEvent())
         {
            float val = env.getAndResetNew(_bResetNew);
            injectedCtlValues[_ctlIdx] = val; // do not revert to previously injected value on next tick
            return val;
         }
         else
         {
            if(INVALID_VALUE != injectedCtlValues[_ctlIdx])
            {
               // Reuse either the last env value or the last injected value
               return injectedCtlValues[_ctlIdx];
            }
            else
            {
               return env.getAndResetNew(_bResetNew); // Returns 0 when there are no events
            }
         }
      }
      else
      {
         if(INVALID_VALUE != injectedCtlValues[_ctlIdx])
         {
            return injectedCtlValues[_ctlIdx];
         }
      }

      return 0.0f;
   }

   // <method_get.png>
   public method getMostRecentEventOrInv(int _ctlIdx, boolean _bResetNew) : float {

      // CTL_DURn

      FloatArray injectedCtlValues <= parent_track.injected_ctl_values;

      if(parent_track.injected_ctl_states[_ctlIdx])
      {
         return injectedCtlValues[_ctlIdx];
      }

      Envelope env <= controllers[_ctlIdx];

      if(null != env)
      {
         if((env.numElements > 0) && env.isNewEvent())
         {
            float val = env.getAndResetNew(_bResetNew);
            injectedCtlValues[_ctlIdx] = val; // do not revert to previously injected value on next tick
            return val;
         }
         else
         {
            if(INVALID_VALUE != injectedCtlValues[_ctlIdx])
            {
               // Reuse either the last env value or the last injected value
               return injectedCtlValues[_ctlIdx];
            }
            else if(env.numElements > 0)
            {
               return env.getAndResetNew(_bResetNew);
            }
         }
      }
      else
      {
         if(INVALID_VALUE != injectedCtlValues[_ctlIdx])
         {
            return injectedCtlValues[_ctlIdx];
         }
      }

      return INVALID_VALUE;
   }

   // <method_get.png>
   public method getCreateEnvelope(int _ctlIdx) : Envelope {
      explain "Return reference to controller envelope. Create envelope if it does not already exist.";

      Envelope env <= controllers[_ctlIdx];
      if(null == env)
      {
         env <= new Envelope();

         switch(_ctlIdx)
         {
            case CTL_INSTR:
            case CTL_NOTE1:
            case CTL_NOTE2:
            case CTL_NOTE3:
            case CTL_NOTE4:
            case CTL_NOTE5:
            case CTL_POLYAT1:
            case CTL_POLYAT2:
            case CTL_POLYAT3:
            case CTL_POLYAT4:
            case CTL_POLYAT5:
            case CTL_PC:
            case CTL_DELAY:
            case CTL_RETRIG:
            case CTL_SEEK:
               // (note) CTL_BPM is SHRESET via isNewEvent() check
               // (note) CTL_BPM_MUL is SHRESET via isNewEvent() check
               // (note) CTL_SLIDE is SHRESET via isNewEvent() check
               // (note) CTL_PB is SHRESET via isNewEvent() check
               // (note) CTL_AT is SHRESET via isNewEvent() check
               // (note) CTL_USRn are SH via isNewEvent() check
               env.interpolation = ENV_SHRESET;
               break;
            default:
               // CTL_VELn
               // CTL_DURn
               // CTL_GROOVE
               // CTL_MUTE
               env.interpolation = ENV_SH;
               break;
         }

         env.time = offset;

         controllers[_ctlIdx] = deref env;
      }
      return env;
   }

   // <method.png>
   public method deleteEnvelope(int _ctlIdx) {
      controllers[_ctlIdx] = null;
   }

   // <method.png>
   public method clearAllEnvelopes() {
      int ctlNr = 0;
      loop(CTL_NUM)
      {
         Envelope env <= controllers.get(ctlNr);
         if(null != env)
         {
            env.empty();
         }
         ctlNr++;
      }
   }

   // <method_find.png>
   public =replay= method findActiveNotesAt(int _ticks, int _stepResolution, IntArray _retActiveNotes) {
      int tickNr = _ticks;

      // (todo) optimize, don't iterate each tick, iterate events only
      if(_stepResolution <= 384)
      {
         loop(_stepResolution)
         {
            int noteIdx = 0;

            loop(NUM_NOTESLOTS)
            {
               Envelope env <= controllers[CTL_NOTE1 + noteIdx];

               if(null != env)
               {
                  var v = env.valueAtTimeRaster(tickNr, 1/*res*/);

                  if(YAC_TYPE_FLOAT == typeid(v))
                  {
                     if(v >= 0)
                        _retActiveNotes.add(v);
                  }
               }

               noteIdx++;
            }

            tickNr++;
         }
      }
   }

   // <save.png>
   public method saveState(Stream ofs, byte _forcePatNr) {
      // Write version
      ofs.i8 = 3;

      // Write pattern nr
      ofs.i8 = (-1 != _forcePatNr) ? _forcePatNr : pat_nr;

      // Write instrument nr (v3+)
      ofs.i8 = keyjazz_instr_nr;

      int allCtlStartOffset = ofs.offset;
      ofs.i32 = 0;

      int ctlNr = 0;
      loop(CTL_NUM)
      {
         Envelope env <= controllers.get(ctlNr);

         if(null != env)
         {
            int envStartOff = ofs.offset;
            ofs.i32 = 0;

            ofs.i8 = ctlNr;

            Utils.WriteEnvelope(ofs, env);

            Utils.FixChunkSize(ofs, envStartOff);
         }

         // Next controller envelope
         ctlNr++;
      }

      Utils.FixChunkSize(ofs, allCtlStartOffset);

      // Random params (v2+)
      if(null != random_params)
      {
         ofs.i8 = 1;
         random_params.saveState(ofs);
      }
      else
      {
         ofs.i8 = 0;
      }
   }

   // <load.png>
   public method loadState(Stream ifs) : boolean {
      // Read version
      byte ver = ifs.i8;

      if(ver >= 1)
      {
         // Read pattern nr
         pat_nr = ifs.i8 & 127;

         if(ver >= 3)
         {
            // Read instrument nr (v3+)
            keyjazz_instr_nr = ifs.u8;
         }

         int allCtlStartOff = ifs.offset;
         int allCtlBytes = ifs.i32;
         int allCtlBytesLeft = allCtlBytes - 4;

         while(allCtlBytesLeft > 0)
         {
            int envStartOff = ifs.offset;
            int envBytes = ifs.i32;

            if(envBytes > 0)
            {
               int ctlNr = ifs.i8;

               if(0 <= ctlNr < CTL_NUM)
               {
                  Envelope env <= new Envelope;
                  Utils.ReadEnvelope(ifs, envBytes-4-1, env);

                  if((ifs.offset - envStartOff) != envBytes)
                  {
                     trace "[---] NT_TrackPattern::loadState: wrong env read size. expected "+envBytes+", have "+(ifs.offset - envStartOff);
                     break;
                  }

                  controllers[ctlNr] = deref env;

                  allCtlBytesLeft -= envBytes;
               }
               else
               {
                  trace "[---] NT_TrackPattern::loadState: invalid ctlNr "+ctlNr;
                  break;
               }
            }
            else
            {
               trace "[---] NT_TrackPattern::loadState: invalid #envBytes="+envBytes;
               break;
            }
         }

         if(0 == allCtlBytesLeft)
         {
            if(ver >= 2)
            {
               // Random Params (v2+)
               byte verRandomParams = ifs.u8;
               // trace "xxx NT_TrackPattern::patLoadState: verRandomParams="+verRandomParams;
               if(verRandomParams > 0)
               {
                  getOrCreateRandomParams();
                  if(!random_params.loadState(ifs))
                  {
                     trace "[---] NT_TrackPattern::patLoadState: failed to load random params state (ver="+ver+")";
                     return false;
                  }
               }
               else
               {
                  random_params <= null;
               }
            }

            // Succeeded
            return true;
         }
         else
         {
            trace "[---] NT_TrackPattern::loadState: wrong read size. expected "+allCtlBytes+", have "+(ifs.offset - allCtlStartOff);
         }
      }
      else
      {
         trace "[---] NT_TrackPattern::loadState: invalid version "+ver;
      }
      return false;
   }

   // <replay.png>
   public method seek(int _time) {
      ///trace "xxx ST_Pattern::seek: time="+_time+" offset="+offset+" length="+length;

      Envelope *env;
      foreach env in controllers
      {
         if(null != env)
         {
            env.setTime(_time);
         }
      }
      offset = _time;
   }

   // <replay.png>
   public method tick(MIDIPipeFrame _framePlay,
                      MIDIPipeFrame _frameRec,
                      boolean _bMuted,
                      boolean _bPlaySeq,   // read events, send noteons+ctls
                      boolean _bAdvSeq,    // advance to next event
                      boolean _bAllowDelayBegin
                      ) {

      int noteIdx;
      Envelope *env;
      float val;
      int i;
      int j;
      float f;
      int ctl;
      boolean bSelInstr = parent_track.checkResetQueuedInstrumentSelected();
      local STX_MIDIOutDevice *instrOutDev;

      // // boolean bPlayNote = false;

      // trace "xxx NT_TrackPattern::tick: offset="+offset+" this="+#(this);

      // if(parent_node.b_extclk && replay.b_playing && !_bMuted)
      // {
      //    trace "xxx pat.tick: ticks="+parent_node.jam_current_ticks+" bMuted="+_bMuted+" bPlaySeq="+_bPlaySeq+" _bAdvSeq="+_bAdvSeq;
      // }

      // if(!_bMuted)
      //    trace "xxx TrackPat: this="+#(this)+" track_nr="+parent_track.track_nr+" bMuted="+_bMuted+" _bPlaySeq="+_bPlaySeq;

      // trace "xxx TrackPat: tick track_nr="+parent_track.track_nr;

      IntArray   retrigNotes <= parent_track.retrig_notes;
      // // FloatArray retrigVel   <= parent_track.retrig_vel;
      // // IntArray   retrigDur   <= parent_track.retrig_dur;
      IntArray   curNotes    <= parent_track.play_current_notes;

      IntArray newNotes <= parent_track.new_notes;
      newNotes.fill(-1);

      boolean bNewPB = false;

      IntArray uiLastNoteState <= parent_node.ui_last_note_state;


      //
      // Process CTL_DELAY
      //
      if(_bPlaySeq)
      {
         if(_bAllowDelayBegin)
         {
            val = parent_node.tick_ext_delay;  // (todo) remove this, superceded by injected_ctl

            if(-1 == val)
            {
               val = INVALID_VALUE;
               if(haveNewEvent(CTL_DELAY))
               {
                  val = getNewEvent(CTL_DELAY, _bAdvSeq);
                  // trace "xxx read CTL_DELAY val="+val+" @offset="+offset+" this="+#(this);
                  // Utils.Backtrace();
               }
            }

            // (todo) handle delay midi msg
            if(val > 0)
            {
               if(parent_track.beginDelay(val))
               {
                  return;
               }
            }
         }

         // Handle CTL_SEEK
         val = INVALID_VALUE;
         if(haveNewEvent(CTL_SEEK))
         {
            val = getNewEvent(CTL_SEEK, _bAdvSeq);
            // trace "xxx read CTL_SEEK val="+val+" @offset="+offset+" this="+#(this);
            if(MAGIC_SEEK_STOP != int(val)) // 255
            {
               parent_node.jam_queued_offset_ticks = ((parent_node.jam_current_ticks + parent_node.jam_scale_ticks) % meta_pattern.num_ticks);
               int ctlSeekTarget = val;
               // trace "xxx CTL_SEEK: jam_queued_offset_ticks="+parent_node.jam_queued_offset_ticks+" patLen="+meta_pattern.num_ticks+" mpat="+#(meta_pattern)+" target="+ctlSeekTarget;
               parent_node.nodeSetQueuedSeekOff(ctlSeekTarget);
            }
            else
            {
               // Stop pattern
               parent_node.b_jam_done = true;
               return;
            }
         }


         //
         // Handle BPM changes
         //
         boolean bBPMChanged = false;

         // CTL_BPM:
         val = INVALID_VALUE;
         if(haveNewEvent(CTL_BPM))
         {
            val = getNewEvent(CTL_BPM, _bAdvSeq);
            ////trace "xxx ctl_bpm val="+val+" env.time="+env.time;
         }

         // (todo) handle bpm midi msg
         if(!_bMuted &&
            (val > 0) &&
            (val != current_song.bpm)
            )
         {
            bBPMChanged = true;
            // trace "xxx set bpm to "+val;
            current_song.setBPM(val);
         }

         // CTL_BPM_MUL:
         val = INVALID_VALUE;
         if(haveNewEvent(CTL_BPM_MUL))
         {
            val = getNewEvent(CTL_BPM_MUL, _bAdvSeq);
            ////trace "xxx ctl_bpm_mul val="+val+" env.time="+env.time;
         }

         if(!_bMuted && (val >= 0))
         {
            val = Utils.Bipolar8ToScale(val, 2, 2);
            if(val != current_song.bpm_mul)
            {
               // trace "xxx set bpm_mul to "+val;
               current_song.setBPMMul(val);
               bBPMChanged = true;
            }
         }

         if(bBPMChanged)
         {
            MIDI.UpdateMIDITimer();
            Events.SendBPMChanged();
         }

         // CTL_GROOVE:
         val = INVALID_VALUE;
         if(haveNewEvent(CTL_GROOVE))
         {
            val = getNewEvent(CTL_GROOVE, _bAdvSeq);
            ////trace "xxx ctl_groove val="+val+" env.time="+env.time;
            if(!_bMuted)
               current_pipe_root.pipeDelay = int(val);
         }


         // Handle mute/unmute self
         if(haveNewEvent(CTL_MUTE))
         {
            val = getNewEvent(CTL_MUTE, _bAdvSeq);

            if(val > 0)
            {
               parent_track.ctl_mute_timeout = val * parent_node.dur_ticks * 4;
            }
            else
            {
               parent_track.ctl_mute_timeout = 0;
            }
         }

         if(parent_track.ctl_mute_timeout > 0)
         {
            _bMuted = true;

            parent_track.ctl_mute_timeout--;
         }

         if(parent_track.track_nr < 16)
         {
            _bMuted |= !(Utils.RollTheDice(100 * ((parent_node.rpn_com_prob_track.get(parent_track.track_nr)) + parent_node.rpn_com_prob_all_rel)));
         }
         else
         {
            _bMuted |= !(Utils.RollTheDice(100 * (1.0 + parent_node.rpn_com_prob_all_rel)));
         }


      } // if bPlaySeq



      //
      // Process CTL_INSTR
      //
      if(_bAdvSeq)
      {
         val = getMostRecentEventOrZero(CTL_INSTR, true/*bResetNew*/);///_bAdvSeq);

         // (todo) handle instr midi msg

         if(val > 0) /// velocity=0 is interpreted as note off by all (tested) synths :/
         {
            // if(!_bMuted)
            // trace "xxx nt: select instr "+val;
            parent_track.current_instrument_nr = val;

            bSelInstr = true;
         }
      }

      NT_Instrument instr <=
         parent_node.instruments.get(parent_track.current_instrument_nr);

      // // FloatArray resetUsrCtl <= null;

      // Handle audio-track start (instrument selection)
      if(null != instr)
      {
         if(instr.b_audio && !_bMuted)
         {
            if(parent_node.initial_sample_offset_ms >= 0)
            {
               // Select most recently selected instrument (e.g. after pattern change)
               env <= controllers[CTL_INSTR];
               if(null != env)
               {
                  var lastInstrBeforeSmpStart = env.valueAtTimeSH(offset);
                  if(lastInstrBeforeSmpStart > 0)
                  {
                     NT_Instrument instrSmp <= parent_node.instruments.get(lastInstrBeforeSmpStart);
                     if(null != instrSmp)
                     {
                        if(instrSmp.b_audio)
                        {
                           instr <= instrSmp;
                           parent_track.current_instrument_nr = lastInstrBeforeSmpStart;
                        }
                     }
                  }
               }
               bSelInstr = true;
            }
         }
      }

      if(bSelInstr)
      {
         // Instrument was selected during this tick
         if(null != instr)
         {
            if(!_bMuted && _bPlaySeq)
            {
               instr.handleSelect(_framePlay);

               if(maybe == instr.b_audio)  // select smp_uid instead of program change ?
               {
                  env <= controllers[CTL_PC];
                  if(null != env)
                  {
                     var lastPCBeforeSmpStart = env.valueAtTimeSH(offset);
                     if(lastPCBeforeSmpStart > 0)
                     {
                        instrOutDev <= instr.out_device;
                        instrOutDev.clearMIDICacheForCh(instr.midi_channel);
                        _framePlay.rpn(true/*bSet*/,
                                       instr.out_device.dev_idx, instr.midi_channel,
                                       90/*ModSample.RPN_SMP_UID*/,
                                       lastPCBeforeSmpStart/*smp_uid*/
                                       );
                     }
                  }
               }
            }

            // // resetUsrCtl <= instr.reset_usrctl;

            // Reset pitchbend
            bNewPB = instr.b_pitchbend_reset;////true;
            parent_track.current_pb = 0;
         }
      }


      //
      // Process CTL_VELn
      //
      float defVelocity = parent_node.def_velocity;

      FloatArray vel; // current note 1..5 velocity

      noteIdx = 0;
      ctl = CTL_VEL1;

      loop(NUM_NOTESLOTS)
      {
         val = getMostRecentEventOrZero(ctl, _bAdvSeq);
         // // val = getMostRecentEventOrInv(ctl, _bAdvSeq);  // [15Oct2017] allow zero velocity

         // // if(val != INVALID_VALUE)
         if(val > 0)
         {
            defVelocity = val;
         }

         defVelocity = mathClampf(defVelocity * parent_node.rpn_com_vel_scl * (parent_node.rpn_com_vel_scl_track.get(parent_track.track_nr)) + parent_node.rpn_com_vel_off,
                                  0,
                                  127
                                  );

         vel[noteIdx] = defVelocity;

         noteIdx++;
         ctl++;
      }


      //
      // Process CTL_DURn
      //
      IntArray dur; // current note 1..5 duration (ticks)
      int defDuration = parent_node.def_duration * parent_node.dur_ticks;

      noteIdx = 0;
      ctl = CTL_DUR1;

      loop(NUM_NOTESLOTS)
      {
         val = getMostRecentEventOrInv(ctl, _bAdvSeq);

         if(INVALID_VALUE != val)
         {
            // trace "xxx CTL_DUR: val="+val+" parent_node.dur_ticks="+parent_node.dur_ticks;

            if(val > 0)
            {
               defDuration = val * parent_node.dur_ticks;
               // if(!_bMuted)
               //    trace "xxx defDuration="+defDuration;
               if(defDuration < 1)
                  defDuration = 1;
            }
            else
               defDuration = 0;

            // trace "xxx this="+#(this)+" defDur="+defDuration;

            if(defDuration > 0)
            {
               defDuration = defDuration * parent_node.rpn_com_dur_scl * (parent_node.rpn_com_dur_scl_track.get(parent_track.track_nr)) + parent_node.rpn_com_dur_off;

               // trace "xxx  => defDuration="+defDuration;

               if(defDuration < 1)
                  defDuration = 1;
            }
            ////trace "xxx CTL_DUR: val="+val+" dur_ticks="+parent_node.dur_ticks;
         }

         dur[noteIdx] = defDuration;

         noteIdx++;
         ctl++;
      }


      //
      // Process CTL_SLIDE
      //
      ctl = CTL_SLIDE;

      boolean bNewSlide = false;

      if(haveNewEvent(CTL_SLIDE))
      {
         val = getNewEvent(CTL_SLIDE, _bAdvSeq);

         parent_track.slide_speed = val;

         bNewSlide = true;

         // if(!_bMuted)
         //    trace "xxx set bNewSlide=true";
      }

      if(_bPlaySeq && !_bMuted)
      {
         //
         // Process CTL_PC (program change)
         //
         if(haveNewEvent(CTL_PC))
         {
            val = getNewEvent(CTL_PC, _bAdvSeq);

            // trace "xxx TrackPat: send prgchg val="+val;
            if(null != instr)
            {
               if(maybe == instr.b_audio)
               {
                  // Select sample by unique_id (0..16382)
                  _framePlay.rpn(true/*bSet*/,
                                 instr.out_device.dev_idx, instr.midi_channel,
                                 90/*ModSample.RPN_SMP_UID*/,
                                 val/*smp_uid*/
                                 );
               }
               else
               {
                  // Send default bank / program
                  instr.emitProgramChangeExt(_framePlay, val);
               }
            }
         }
      }


      //
      // Process keyjazz queue
      //
      KeyJazzQueueEntry *kjEntry;
      noteIdx = 0;
      ctl = CTL_NOTE1;
      boolean bKeyJazzNoteOn = false;
      NT_Instrument instrKJ <= null;

      // trace "xxx kjQueue.numElements="+(parent_node.keyjazz_queue.numElements);
      foreach kjEntry in parent_node.keyjazz_queue
      {
         if(kjEntry.track_nr == parent_track.track_nr)
         {
            val = kjEntry.note;
            // trace "[>>>] NT: kjEntry: note="+val+" vel="+kjEntry.velocity+" durTicks="+kjEntry.dur_ticks+" instrNr="+kjEntry.instr_nr;
            instrKJ <= parent_node.instruments.get(kjEntry.instr_nr);

            if(null != instrKJ)
            {
               if(parent_node.b_arp)
                  val = parent_node.mapArpNote(val);

               if(INVALID_VALUE != val)
               {
                  if(val >= 0)
                  {
                     parent_track.slide_to_note = val;

                     bKeyJazzNoteOn = true;

                     if(bNewSlide && (-1 != parent_track.slide_base_note))
                     {
                        // Continue sliding

                        if(bSelInstr)
                        {
                           // Continue sliding but trigger note
                           instrKJ.emitNoteOn(_framePlay, val, kjEntry.velocity, kjEntry.dur_ticks);

                           uiLastNoteState[val] = current_song.tick_nr + ((0 == kjEntry.dur_ticks) ? PIANO_DUR_INF : kjEntry.dur_ticks);
                           parent_node.b_ui_last_note_state_changed = true;

                           retrigNotes[noteIdx] = val;
                           curNotes[noteIdx] = val;

                           // Now sliding from current slide note to triggered note
                           parent_track.slide_base_note = val;

                           parent_track.retrigEQ();
                        }
                        //else: Slide to new note (no trig)
                     }
                     else
                     {
                        // Note on (no sliding)
                        instrKJ.emitNoteOn(_framePlay, val, kjEntry.velocity, kjEntry.dur_ticks);

                        uiLastNoteState[val] = current_song.tick_nr + ((0 == kjEntry.dur_ticks) ? PIANO_DUR_INF : kjEntry.dur_ticks);
                        parent_node.b_ui_last_note_state_changed = true;

                        // trace "xxx emitNoteOn val="+val;

                        retrigNotes[noteIdx] = val;
                        curNotes[noteIdx] = val;

                        // Disable sliding
                        parent_track.slide_base_note = val;
                        parent_track.slide_note = val;

                        // // if(0 != parent_track.current_pb)
                        // // {
                        bNewPB = instrKJ.b_pitchbend_reset;////true; // reset pitchbend
                        // // }

                        if(!bNewSlide)
                           parent_track.slide_speed = -1;

                        parent_track.retrigEQ();

                        parent_track.slide_to_note = -1;
                     }
                  }
                  else
                  {
                     // Note off
                     instrKJ.emitNoteOff(_framePlay, -val, kjEntry.velocity/*vel*/, false/*bPre*/);

                     uiLastNoteState[-val] = false;
                     parent_node.b_ui_last_note_state_changed = true;

                     // Mark the noteslot(s) that play the given note as unused
                     curNotes.replace(-val, -1);
                  }
               } // !INVALID_VALUE
            } // if instrKJ
         } // if track nr
      } // foreach

      if(_bPlaySeq)
      {
         //
         // Process CTL_NOTEn
         //
         noteIdx = 0;
         ctl = CTL_NOTE1;

         // // if(parent_node.b_extclk) // xxx
         // // {
         // //    trace "xxx instr="+#(instr);
         // // }

         if(null != instr)
         {
            if(parent_node.b_slide_note_off)
            {
               if(-1 != parent_track.slide_base_note)
               {
                  // trace "xxx nt: b_slide_note_off, slide_base_note="+parent_track.slide_base_note;

                  if(!_bMuted)
                  {
                     instr.emitNoteOff(_framePlay,
                                       parent_track.slide_base_note,// + parent_node.rpn_com_transpose,
                                       64/*vel*/,
                                       false/*bPre*/
                                       );

                     uiLastNoteState[parent_track.slide_base_note] = false;
                     parent_node.b_ui_last_note_state_changed = true;
                  }

                  // Mark the noteslot(s) that play the given note as unused
                  curNotes.replace(val, -1);
               }
            }


            // Handle audio-track start (note on)
            if(instr.b_audio && !_bMuted)
            {
               if(parent_node.initial_sample_offset_ms >= 0)
               {
                  // trace "xxx parent_node.initial_sample_offset_ms="+parent_node.initial_sample_offset_ms+" this="+#(this)+" node="+#(parent_node);

                  if(parent_node.current_audiotrack_note >= 0)
                  {
                     instr.emitNoteOff(_framePlay, parent_node.current_audiotrack_note, 64/*vel*/, true/*bPre*/);

                     uiLastNoteState[parent_node.current_audiotrack_note] = false;
                     parent_node.b_ui_last_note_state_changed = true;
                  }

                  if(null != instr.out_device)
                  {
                     instrOutDev <= instr.out_device;
                     instrOutDev.clearMIDICacheForCh(instr.midi_channel);
                     _framePlay.rpn(true/*bSet*/, instrOutDev.dev_idx, instr.midi_channel,
                                    Node.RPN_SMPOFFMS_LO/*88*/,
                                    int(parent_node.initial_sample_offset_ms * 64) & 16383
                                    );
                     _framePlay.rpn(true/*bSet*/, instrOutDev.dev_idx, instr.midi_channel,
                                    Node.RPN_SMPOFFMS_HI/*89*/,
                                    (int(parent_node.initial_sample_offset_ms) >> 8) & 16383
                                    );
                  }

                  instr.emitNoteOn(_framePlay,
                                   STConfig.node_tracker_audioclip_note/*C-5*/,
                                   127/*vel*/,
                                   0/*dur*/
                                   );

                  uiLastNoteState[STConfig.node_tracker_audioclip_note] = current_song.tick_nr + PIANO_DUR_INF;
                  parent_node.b_ui_last_note_state_changed = true;

                  parent_node.current_audiotrack_note = STConfig.node_tracker_audioclip_note;
                  parent_node.initial_sample_offset_ms = -1;
               }
            }


            // Process sequence note-ons and offs
            loop(NUM_NOTESLOTS)
            {
               // // env <= controllers[ctl];

               // // if(parent_node.b_extclk)
               // //    trace "xxx ctl="+ctl+" note env="+#(env);

               if(haveNewEvent(ctl))
               {
                  val = getNewEvent(ctl, _bAdvSeq);

                  if(parent_node.b_arp)
                  {
                     val = parent_node.mapArpNote(val);
                  }

                  if(INVALID_VALUE != val)
                  {
                     if(val >= 0)
                     {
                        val = val + parent_node.rpn_com_transpose;

                        if(0 <= val <= 127)
                        {
                           if(vel[noteIdx] > 0)  // [15Oct2017] allow zero velocity (xxx filtered by synth!)
                           {
                              // Remember note parameters for e.g. retrig

                              // trace "xxx NT noteEvent: val="+val+" ctl="+ctl;

                              if(!_bMuted)
                              {
                                 parent_track.slide_to_note = val;
                                 // trace "xxx slide_to_note="+val;

                                 if(bNewSlide && (-1 != parent_track.slide_base_note))
                                 {
                                    // Continue sliding

                                    if(bSelInstr)
                                    {
                                       // Continue sliding but trigger note
                                       instr.emitNoteOn(_framePlay,
                                                        val + parent_node.rpn_com_transpose,
                                                        vel[noteIdx],
                                                        dur[noteIdx]
                                                        );

                                       uiLastNoteState[val + parent_node.rpn_com_transpose] = current_song.tick_nr + ((0 == dur[noteIdx]) ? PIANO_DUR_INF : dur[noteIdx]);
                                       parent_node.b_ui_last_note_state_changed = true;

                                       retrigNotes[noteIdx] = val;
                                       curNotes[noteIdx] = val;

                                       // Now sliding from current slide note to triggered note
                                       parent_track.slide_base_note = val;  // +parent_node.rpn_com_transpose ???

                                       parent_track.retrigEQ();

                                       // trace "xxx continue slide to new note "+val+" (retrig)";
                                    }
                                    else
                                    {
                                       // Slide to new note (no trig)
                                       // trace "xxx slide to note "+val+" (no retrig)";
                                    }
                                 }
                                 else
                                 {
                                    // Note on (no sliding)
                                    // trace "xxx noteon: note="+val+" jam_current_ticks="+parent_node.jam_current_ticks+" dur="+dur[noteIdx];
                                    // trace "xxx noteon:    slide_base_note="+parent_track.slide_base_note+" bNewSlide="+bNewSlide;
                                    instr.emitNoteOn(_framePlay,
                                                     val,
                                                     vel[noteIdx],
                                                     dur[noteIdx]
                                                     );

                                    uiLastNoteState[val] = current_song.tick_nr + ((0 == dur[noteIdx]) ? PIANO_DUR_INF : dur[noteIdx]);
                                    parent_node.b_ui_last_note_state_changed = true;

                                    retrigNotes[noteIdx] = val;
                                    curNotes[noteIdx] = val;

                                    // trace "xxx note on, no slide. note="+val;

                                    // // retrigVel  [noteIdx] = vel[noteIdx];
                                    // // retrigDur  [noteIdx] = dur[noteIdx];

                                    // Disable sliding
                                    parent_track.slide_base_note = val;
                                    parent_track.slide_note = val;

                                    bNewPB = instr.b_pitchbend_reset;////true;

                                    if(!bNewSlide)
                                    {
                                       parent_track.slide_speed = -1;
                                    }

                                    parent_track.slide_to_note = -1;

                                    parent_track.retrigEQ();
                                 }
                              } // if !bMuted
                           }
                           else
                           {
                              // Note off (via note on zero velocity)
                              if(!_bMuted)
                              {
                                 instr.emitNoteOff(_framePlay,
                                                   val + parent_node.rpn_com_transpose,
                                                   64/*vel*/,
                                                   false/*bPre*/
                                                   );

                                 uiLastNoteState[val + parent_node.rpn_com_transpose] = false;
                                 parent_node.b_ui_last_note_state_changed = true;
                              }

                              // Mark the noteslot(s) that play the given note as unused
                              curNotes.replace(val, -1);
                           }
                        } // if val 0..127
                     }
                     else
                     {
                        if(MAGIC_NOTE_ALLTRACKNOTESOFF == val)
                        {
                           if(!_bMuted)
                           {
                              j = 0;
                              foreach i in curNotes
                              {
                                 if(-1 != i)
                                 {
                                    // trace "xxx ALLTRACKNOTESOFF: note="+i+" vel="+vel[j];
                                    instr.emitNoteOff(_framePlay, i, vel[j], false/*bPre*/);
                                 }
                                 j++;
                              }
                           }

                           // Mark all noteslots as unused
                           curNotes.fill(-1);
                        }
                        else if(MAGIC_NOTE_ALLCHANNELNOTESOFF == val)
                        {
                           if(!_bMuted)
                           {
                              instr.emitAllNotesOff(_framePlay);
                              uiLastNoteState.fill(0);
                           }

                           // Mark all noteslots as unused
                           curNotes.fill(-1);
                        }
                        else
                        {
                           // Single Note off
                           val -= parent_node.rpn_com_transpose;

                           if(-127 <= val <= 0)
                           {
                              if(!_bMuted)
                              {
                                 instr.emitNoteOff(_framePlay, -val, vel[noteIdx], false/*bPre*/);

                                 uiLastNoteState[-val] = false;
                                 parent_node.b_ui_last_note_state_changed = true;
                              }

                              // Mark the noteslot(s) that play the given note as unused
                              curNotes.replace(-val, -1);
                           }
                        }
                     }
                  } // !INVALID_VALUE
               } // if haveNewEvent

               noteIdx++;
               ctl++;
            } // loop NUM_NOTESLOTS
         } // if instr
      } // if playSeq

      if(null != instr)
      {
         //
         // Process CTL_RETRIG
         //
         val = parent_node.tick_ext_retrig;
         if(-1 == val)
         {
            val = INVALID_VALUE;
            if(haveNewEvent(CTL_RETRIG))
            {
               val = getNewEvent(CTL_RETRIG, _bAdvSeq);
            }
         }

         if(val >= 0)
         {
            // do not start retrig in keyjazz mode when it is already running
            if(! (_bPlaySeq && parent_track.retrig_dtcountdown))
            {
               parent_track.beginRetrig(val);
            }
         }

         parent_track.tickRetrig(_framePlay, instr, vel, dur, _bMuted || !_bPlaySeq);


         // Hack to enable keyjazz controller emit even in stopped state
         _bPlaySeq |= (-1 != (parent_track.injected_ctl_states.indexOf(true, 0)));


         if(!_bMuted && (_bPlaySeq || bKeyJazzNoteOn))
         {
            //
            // Process CTL_AT (channel key pressure)
            //   (todo) only process if not muted ?
            //
            if(haveNewEvent(CTL_AT))
            {
               // trace "xxx injected CTL_AT parent_track.injected_ctl_states[CTL_AT]="+parent_track.injected_ctl_states[CTL_AT];

               val = getNewEvent(CTL_AT, _bAdvSeq);

               instr.emitChannelPressure(_framePlay, val);
            }


            //
            // Process CTL_POLYATn (polyphonic key pressure)
            //   (todo) only process if not muted ?
            //
            ctl = CTL_POLYAT1;
            noteIdx = 0;
            loop(NUM_NOTESLOTS)
            {
               if(-1 != curNotes[noteIdx])
               {
                  if(haveNewEvent(ctl))
                  {
                     val = getNewEvent(ctl, _bAdvSeq);

                     instr.emitPolyPressure(_framePlay, curNotes[noteIdx], val);
                  }
               }

               // Next note slot
               noteIdx++;
               ctl++;
            }


            //
            // Process user defined controllers
            //
            //  (note) CCs/(N)RPNs/PC will always be emitted _before_ note-ons (see MIDIPipeFrame::emit())
            //
            ctl = CTL_USR;
            i = 0;
            loop(CTL_NUMUSR)
            {
               val = INVALID_VALUE;

               if(haveNewEvent(ctl))
               {
                  val = getNewEvent(ctl, _bAdvSeq);

                  // trace "xxx NT_TrackPattern::emitUsrCtl: ctl="+ctl+" val="+val;
                  instr.emitUsrCtl(_framePlay, i, val);
                  usrctl_zeroreset_pending[i] = true;
               }
               else if(usrctl_zeroreset_pending[i])
               {
                  usrctl_zeroreset_pending[i] = false;
                  // hack for Eureka/TinySynergyReplay ModSeq retrig (auto-reset to 0)
                  //   (note) can be activated/toggled via 'env_shreset' page command
                  env <= controllers[ctl];
                  if(null != env)
                  {
                     if(ENV_SHRESET == env.interpolation)
                     {
                        // trace "xxx emitUsrCTL zero-reset";
                        instr.emitUsrCtl(_framePlay, i, 0/*val*/);
                     }
                  }
               }

               // // if(INVALID_VALUE == val)
               // // {
               // //    if(bSelInstr)
               // //    {
               // //       // Emit usrctl reset value
               // //       //  (todo) isn't this already handled by handleSelect() and handleNoteOn() ???
               // //       if(null != resetUsrCtl)
               // //       {
               // //          val = resetUsrCtl[i];

               // //          if(INVALID_VALUE != val)
               // //          {
               // //             instr.emitUsrCtl(_framePlay, i, val);
               // //          }
               // //       }
               // //    }
               // // }

               i++;
               ctl++;
            }
         } // if !_bMuted && bPlaySeq


         //
         // Process CTL_PB
         //
         ctl = CTL_PB;

         // (todo) handle pitchbend midi msg
         val = parent_track.current_pb;

         if(haveNewEvent(ctl))
         {
            val = getNewEvent(ctl, _bAdvSeq);
            // trace "xxx have new PB val="+val;

            val = (val - 64.0) / 64.0f;

            bNewPB = true;
         }

         parent_track.current_pb = val;

         float cpb;

         if(-1 != parent_track.slide_to_note)
         {
            if(parent_track.slide_speed >= 255)
            {
               // Special case: Slide immediately
               parent_track.slide_note = parent_track.slide_to_note;
            }

            cpb = ((parent_track.slide_note - parent_track.slide_base_note) / instr.pitchbend_range);

            // trace "xxx slide: slnt="+parent_track.slide_note+" slbnt="+parent_track.slide_base_note+" pbrng="+instr.pitchbend_range+" cpb="+cpb;

            float cslidespd = parent_track.slide_speed * ((1.0 * (192.0 / current_song.ppq)) / 255);

            cpb += parent_track.current_pb;

            if(!_bMuted && _bPlaySeq)
            {
               instr.emitPitchbend(_framePlay, cpb);
            }

            if(parent_track.slide_note < parent_track.slide_to_note)
            {
               parent_track.slide_note += cslidespd;

               if(parent_track.slide_note > parent_track.slide_to_note)
               {
                  parent_track.slide_note = parent_track.slide_to_note;
               }
            }
            else
            {
               parent_track.slide_note -= cslidespd;

               if(parent_track.slide_note < parent_track.slide_to_note)
               {
                  parent_track.slide_note = parent_track.slide_to_note;
               }
            }
         }
         else
         {
            // Manual pitchbend only
            if(bNewPB)
            {
               // trace "xxx parent_track.current_pb="+parent_track.current_pb;
               if(!_bMuted && _bPlaySeq)
               {
                  instr.emitPitchbend(_framePlay, parent_track.current_pb);
               }
            }
         }


         if(instr.b_audio)
         {
            if(!_bPlaySeq || _bMuted)
            {
               // Stop audio-track
               if(parent_node.current_audiotrack_note >= 0)
               {
                  // trace "xxx stop audio track note "+parent_node.current_audiotrack_note;

                  instr.emitNoteOff(_framePlay, parent_node.current_audiotrack_note, 64/*vel*/, false/*bPre*/);

                  parent_node.current_audiotrack_note = -1;
                  parent_node.initial_sample_offset_ms = -1;
               }
            }
         }


      } // if instr ****************


      // Increase envelope play offsets
      if(_bAdvSeq)
      {
         foreach env in controllers
         {
            if(null != env)
            {
               env.tickPrecise(1.0f);
            }
         }

         // Increase pattern play offset
         offset++;
      }

      // [05Oct2024] reset injected_ctl_status at end of replay tick (after polystep replay)
      // // if(_bAdvSeq)
      // // {
      // //    // (note) don't reset inject state when playing polysteps
      // //    parent_track.injected_ctl_states.fill(false);
      // // }

      parent_track.injected_ctl_values.set(CTL_INSTR, INVALID_VALUE);
   }

}
