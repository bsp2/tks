// ----
// ---- file   : ManageMIDIDevicesTM
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2012-2024 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- changed: 13May2012, 21Nov2012, 15Jun2014, 31Aug2014, 17Feb2015, 19Jan2016, 13Apr2016
// ----          24Jul2016, 02Nov2017, 04Jan2018, 18Sep2018, 01Nov2020, 31May2021, 14Jun2021
// ----          08May2022, 03Aug2024
// ----
// ----
// ----

module MManageMIDIDevicesTM;

use namespace ui;
use namespace st2;


class ManageMIDIDevicesTM : TableModel {

   define int COL_ID      =  0;
   define int COL_PRESENT =  1;
   define int COL_OPEN    =  2;
   define int COL_OPENED  =  3;
   define int COL_ECHO    =  4;
   define int COL_CLK     =  5;
   define int COL_MMCREC  =  6;
   define int COL_MMCPLAY =  7;
   define int COL_MTC     =  8;
   define int COL_SPP     =  9;
   define int COL_ALIAS   = 10;
   define int COL_NAME    = 11;

   ManageMIDIDevicesEntry *[] devs;

   protected CheckBox cb_active_render;
   protected CheckBox cb_active_edit;

   protected CheckBox cb_echo_render;
   protected CheckBox cb_echo_edit;

   protected CheckBox cb_clk_render;
   protected CheckBox cb_clk_edit;

   protected CheckBox cb_mmcrec_render;
   protected CheckBox cb_mmcrec_edit;

   protected CheckBox cb_mmcplay_render;
   protected CheckBox cb_mmcplay_edit;

   protected CheckBox cb_mtc_render;
   protected CheckBox cb_mtc_edit;

   protected CheckBox cb_spp_render;
   protected CheckBox cb_spp_edit;


   public virtual getNumColumns() : int {
      return 12;
   }

   public virtual getColumnCaption(int _col) : String {
      return ["Id", "Present", "Use", "Opened", "Echo", "Clock", "Rec", "Play", "MTC", "SPP", "Alias", "Name"][_col];
   }

   public virtual getNumRows() : int {
      return devs.numElements;
   }

   public virtual getCellCaption(int _col, _row) : String {
      ManageMIDIDevicesEntry e <= devs.get(_row);
      switch(_col)
      {
         case COL_ID:
            return _row;

         case COL_PRESENT:
            return (e.b_present ? "*" : "  -");

         case COL_OPENED:
            return (e.b_opened ? "*" : "  -");

         case COL_ECHO:
            return (e.b_echo ? "*" : "  -");

         case COL_CLK:
            return (e.b_clk ? "*" : "  -");

         case COL_MMCREC:
            return (e.b_mmcrec ? "*" : "  -");

         case COL_MMCPLAY:
            return (e.b_mmcplay ? "*" : "  -");

         case COL_MTC:
            return (e.b_mtc ? "*" : "  -");

         case COL_SPP:
            return (e.b_spp ? "*" : "  -");

         case COL_ALIAS:
            return (null != e.alias) ? e.alias : "-";

         case COL_NAME:
            // trace "xxx row="+_row+" e.name="+e.name;
            return e.name;
      }
   }

   public virtual getCellRenderer(int _col, int _row, int _visibleRow) : Layer {
      ManageMIDIDevicesEntry e <= devs.get(_row);
      CheckBox *cb;

      if(COL_OPEN == _col)
      {
         if(_row != cursor_index)
         {
            cb <= cb_active_render;
            cb.setSelected(e.b_open);
         }
         else
         {
            // Row is possibly being edited (at least it is selected..)
            cb <= cb_active_edit;
         }
         cb.setInnerPadTop(1.0f);
         cb.setPositionX(4.0f);
         return cb;
      }
      if(COL_ECHO == _col)
      {
         if(_row != cursor_index)
         {
            cb <= cb_echo_render;
            cb.setSelected(e.b_echo);
         }
         else
         {
            // Row is possibly being edited (at least it is selected..)
            cb <= cb_echo_edit;
         }
         cb.setEditable(!e.b_out);
         cb.setInnerPadTop(1.0f);
         cb.setPositionX(4.0f);
         return cb;
      }
      else if(COL_CLK == _col)
      {
         if(_row != cursor_index)
         {
            cb <= cb_clk_render;
            cb.setSelected(e.b_clk);
         }
         else
         {
            // Row is possibly being edited (at least it is selected..)
            cb <= cb_clk_edit;
         }
         cb.setEditable(e.b_out);
         cb.setInnerPadTop(1.0f);
         cb.setPositionX(4.0f);
         return cb;
      }
      else if(COL_MMCREC == _col)
      {
         if(_row != cursor_index)
         {
            cb <= cb_mmcrec_render;
            cb.setSelected(e.b_mmcrec);
         }
         else
         {
            // Row is possibly being edited (at least it is selected..)
            cb <= cb_mmcrec_edit;
         }
         cb.setEditable(e.b_out);
         cb.setInnerPadTop(1.0f);
         cb.setPositionX(4.0f);
         return cb;
      }
      else if(COL_MMCPLAY == _col)
      {
         if(_row != cursor_index)
         {
            cb <= cb_mmcplay_render;
            cb.setSelected(e.b_mmcplay);
         }
         else
         {
            // Row is possibly being edited (at least it is selected..)
            cb <= cb_mmcplay_edit;
         }
         cb.setEditable(e.b_out);
         cb.setInnerPadTop(1.0f);
         cb.setPositionX(4.0f);
         return cb;
      }
      else if(COL_MTC == _col)
      {
         if(_row != cursor_index)
         {
            cb <= cb_mtc_render;
            cb.setSelected(e.b_mtc);
         }
         else
         {
            // Row is possibly being edited (at least it is selected..)
            cb <= cb_mtc_edit;
         }
         cb.setEditable(e.b_out);
         cb.setInnerPadTop(1.0f);
         cb.setPositionX(4.0f);
         return cb;
      }
      else if(COL_SPP == _col)
      {
         if(_row != cursor_index)
         {
            cb <= cb_spp_render;
            cb.setSelected(e.b_spp);
         }
         else
         {
            // Row is possibly being edited (at least it is selected..)
            cb <= cb_spp_edit;
         }
         cb.setEditable(e.b_out);
         cb.setInnerPadTop(1.0f);
         cb.setPositionX(4.0f);
         return cb;
      }
      else
      {
         Label lb <= TableModel::getCellRenderer(_col, _row, _visibleRow);
         lb.setPositionX(0);
         lb.setFontByName("big7");

         if(COL_OPENED == _col)
         {
            if(e.b_opened)
            {
               lb.setIcon(UI.GetIcon("mgrctl_celvis_2x"));
               lb.setCaption("");
               lb.setPositionX(5);
            }
            else
            {
               lb.setIcon(null);
            }
         }
         else if(COL_ECHO == _col)
         {
            if(e.b_echo)
            {
               lb.setIcon(UI.GetIcon("mgrctl_celvis_2x"));
               lb.setCaption("");
            }
            else
            {
               lb.setIcon(null);
            }
         }
         else if(COL_PRESENT == _col)
         {
            if(e.b_present)
            {
               lb.setIcon(UI.GetIcon("mgrctl_celvis_2x"));
               lb.setCaption("");
            }
            else
            {
               lb.setIcon(null);
               // lb.setCaption("");
            }
         }
         else if(COL_ALIAS == _col)
         {
            lb.setPositionX(0);
            lb.setFontByName("big6");
         }
         else if(COL_NAME == _col)
         {
            lb.setFontByName("big8");
         }
         return lb;


      }
   }

   public virtual updateCellRendererColors(Layer l, int _col, int _row, int _visibleRow) {

      TableModel::updateCellRendererColors(l, _col, _row, _visibleRow);

      ManageMIDIDevicesEntry e <= devs.get(_row);

      if(!e.b_present)
      {
         // Not available, shade row
         int c32bg = UI.lnf.getColor(LookAndFeel.COLOR_WINDOW_BG);
         l.setForegroundColor(UI.MixColor32(l.getForegroundColor(), c32bg, 0.6));
         l.setBackgroundColor(UI.MixColor32(l.getBackgroundColor(), c32bg, 0.6));
      }

      if(COL_NAME == _col)
      {
         if(e.b_virtual)
         {
            l.setBackgroundColor(UI.MixColor32(l.getBackgroundColor(), #ffffff00, 0.075));
         }
         else
         {
            if(e.b_opened)
            {
               l.setBackgroundColor(UI.MixColor32(l.getBackgroundColor(), #ff00ff00, 0.075));
            }
            else if(e.b_open)
            {
               l.setBackgroundColor(UI.MixColor32(l.getBackgroundColor(), #ffff0000, 0.075));
            }
         }
      }

   }

   public virtual handleCursorIndexChanged() {
      if(-1 != cursor_index)
      {
         ManageMIDIDevicesEntry e <= devs.get(cursor_index);
         cb_active_edit .setSelected(e.b_open);
         cb_echo_edit   .setSelected(e.b_echo);
         cb_clk_edit    .setSelected(e.b_clk);
         cb_mmcrec_edit .setSelected(e.b_mmcrec);
         cb_mmcplay_edit.setSelected(e.b_mmcplay);
         cb_mtc_edit    .setSelected(e.b_mtc);
         cb_spp_edit    .setSelected(e.b_spp);
      }
   }

   protected =replay= method handleToggleOpen(ManageMIDIDevicesEntry e) {

      StringArray *inDeviceNames;
      StringArray *outDeviceNames;
      int devNameIdx;
      Boolean bInitOK;

      PointerArray outDevices <= MIDI.out_devices;

      // if(!e.b_virtual)
      // {
         if(e.b_out)
         {
            Global.Debug2("ManageMIDIDevicesTM::handleToggleOpen<out>: e.name=\""+e.name+"\" e.alias=\""+e.alias+"\""+" e.b_open="+e.b_open);

            Global.Debug2("ManageMIDIDevicesTM::handleToggleOpen<out>: MIDI.out_device_names="+#(MIDI.out_device_names));

            // STX_MIDIOutDevice outDev <= MIDI.GetMIDIOutDeviceByDeviceName(e.name);////, true/*bQuiet*/);
            STX_MIDIOutDevice outDev <= MIDI.GetMIDIOutDeviceByAliasOrName(e.name);

            Global.Debug2("ManageMIDIDevicesTM::handleToggleOpen<out>: outDev="+#(outDev));

            if(null != outDev)
            {
               if(e.b_open)
               {
                  // Was closed, open, and start it
                  outDeviceNames <= STConfig.midi_out_devicenames;

                  STX_MIDIOutDevice outDevOld <= null;

                  if(outDev instanceof STX_VirtualMIDIOutDevice)
                  {
                     // Replace virtual device by actual device
                     outDevOld <= outDevices.getDeref(outDev.dev_idx);

                     // // STX_MIDIOutDevice outDevNew <= new STX_MIDIOutDevice;
                     // // outDevices[outDev.dev_idx] = deref outDevNew;
                     // // outDev <= outDevNew;
                  }

                  if(!outDeviceNames.containsObject(e.name))
                  {
                     outDeviceNames.add(e.name);  // is this reachable? it should not!
                  }

                  Global.Debug2("ManageMIDIDevicesTM::handleToggleOpen<out>: (b4 InitMIDIOutDevice) outDev="+#(outDev)+" e.name=\""+e.name+"\"");

                  int outDevIdx = outDev.dev_idx;
                  outDev <= MIDI.InitMIDIOutDevice(e.name, outDev.dev_idx, bInitOK);

                  if(bInitOK)
                  {
                     if(null != outDevOld)
                     {
                        outDev.copyFromVirtualProfileIds(outDevOld);
                        outDevOld <= null;
                     }
                     else
                     {
                        outDev.rescanProfileIds();
                     }
                     outDev.buildCtlNames();

                     Global.Success("Open output device \""+e.name+"\"");
                  }
                  else
                  {
                     Global.Error("Output device \""+e.name+"\" is unavailable.");
                  }

                  outDevices[outDevIdx] = deref outDev;
               }
               else
               {
                  // Was open, stop it, and close
                  if(e.b_opened)
                  {
                     outDeviceNames <= STConfig.midi_out_devicenames;
                     devNameIdx = outDeviceNames.indexOfObject(e.name, 0);
                     if(-1 != devNameIdx)
                     {
                        outDeviceNames.delete(devNameIdx);
                     }

                     if(null != outDev.midiout)
                     {
                        outDev.exit(); // Wait for writer thread
                        outDev.midiout <= null;
                     }

                     outDev.initUnavail(e.name, MIDI.GetGlobalOutDeviceAlias(e.name));

                     Global.Print("Close output device \""+e.name+"\"");
                  }
                  else
                  {
                     Global.Print("Deselect output device \""+e.name+"\"");
                  }
               }
            }
            else
            {
               // Device was initially closed, create new device instance and assign deviceIdx
               if(e.b_open)
               {
                  outDeviceNames <= STConfig.midi_out_devicenames;

                  if(!outDeviceNames.containsObject(e.name))
                  {
                     outDeviceNames.add(e.name);
                  }

                  outDevices.add(null);
                  outDev <= MIDI.InitMIDIOutDevice(e.name, (outDevices.numElements - 1), bInitOK);

                  if(bInitOK)
                  {
                     outDev.rescanProfileIds();
                     outDev.buildCtlNames();

                     Global.Success("Open new output device \""+e.name+"\"");
                  }
                  else
                  {
                     Global.Error("Output device \""+e.name+"\" is unavailable.");
                  }

                  outDevices[outDevices.numElements - 1] = deref outDev;

                  Global.Debug("handleToggleOpen: added new out device (idx="+(outDevices.numElements-1)+"), name=\""+e.name+"\"");
               }
               else
               {
                  trace "[!!!] internal error: handleToggleOpen: outDev does not exist but device is now closed (e.name=\""+e.name+"\")";
               }
            }

            MIDI.UpdateOutDeviceNames();

            root_form.pg_mididevs.updateOutDevsTM();
            root_form.pg_mididevs.redraw();
         }
         else
         {
            Global.Debug2("ManageMIDIDevicesTM::handleToggleOpen<in>: e.name=\""+e.name+"\" e.alias=\""+e.alias+"\"");
            Global.Debug2("ManageMIDIDevicesTM::handleToggleOpen<in>: MIDI.in_device_names="+#(MIDI.in_device_names));

            //STX_MIDIInDevice inDev <= MIDI.GetMIDIInDeviceByDeviceName(e.name, true/*bQuiet*/);
            STX_MIDIInDevice inDev <= MIDI.GetMIDIInDeviceByAliasOrName(e.name);

            // trace "[trc] inDev="+#(inDev);

            if(null != inDev)
            {
               if(e.b_open)
               {
                  // Was closed, open, and start it

                  inDeviceNames <= STConfig.midi_in_devicenames;

                  if(!inDeviceNames.containsObject(e.name))
                  {
                     inDeviceNames.add(e.name);
                  }

                  Global.Debug2("ManageMIDIDevicesTM::handleToggleOpen<in>: call InitMIDIInDevice (was closed, open and start it)");

                  if(MIDI.InitMIDIInDevice(inDev, e.name, inDev.dev_idx))
                  {
                     // trace "xxx InitMIDIInDevice returned OK";
                     if(null != inDev.midiin)
                     {
                        inDev.start();

                        Global.Success("Open input device \""+e.name+"\"");
                     }
                  }
                  else
                  {
                     Global.Error("Failed to open input device \""+e.name+"\"");
                  }
               }
               else
               {
                  // Was open, stop it, and close
                  if(e.b_opened)
                  {
                     inDeviceNames <= STConfig.midi_in_devicenames;
                     devNameIdx = inDeviceNames.indexOfObject(e.name, 0);
                     if(-1 != devNameIdx)
                     {
                        inDeviceNames.delete(devNameIdx);
                     }

                     if(null != inDev.midiin)
                     {
                        inDev.close();
                        inDev.midiin <= null;
                     }

                     // trace "xxx inDev.midiin="+#(inDev.midiin);

                     inDev.initUnavail(e.name, MIDI.GetGlobalInDeviceAlias(e.name));

                     Global.Print("Close input device \""+e.name+"\"");
                  }
                  else
                  {
                     Global.Print("Deselect input device \""+e.name+"\"");
                  }
               }
            }
            else
            {
               // Device was initially closed, create new device instance and assign deviceIdx
               if(e.b_open)
               {
                  inDev <= new STX_MIDIInDevice;

                  inDeviceNames <= STConfig.midi_in_devicenames;

                  if(!inDeviceNames.containsObject(e.name))
                  {
                     inDeviceNames.add(e.name);
                  }

                  PointerArray inDevices <= MIDI.in_devices;
                  inDevices.add(null);
                  MIDI.InitMIDIInDevice(inDev, e.name, (inDevices.numElements - 1));
                  inDevices[inDevices.numElements - 1] = deref inDev;

                  // trace "[trc] inDevices="+#(inDevices)+" inDev="+#(inDev);

                  Global.Debug("handleToggleOpen: added new in device (idx="+(inDevices.numElements-1)+"), name=\""+e.name+"\"");

                  if(null != inDev.midiin)
                  {
                     inDev.start();

                     Global.Success("Open new input device \""+e.name+"\"");
                  }
                  else
                  {
                     Global.Error("Failed to open input device \""+e.name+"\"");
                  }
               }
               else
               {
                  trace "[!!!] internal error: handleToggleOpen: inDev does not exist but device is now closed (e.name=\""+e.name+"\")";
               }
            }

            MIDI.UpdateInDeviceNames();

            root_form.pg_mididevs.updateInDevsTM();
            root_form.pg_mididevs.redraw();
         }

      // } // if!virtual
   }

   public virtual handleCellOnMouse(int _col, int _row, MouseEvent _ev) : boolean {
      boolean bChanged;
      boolean bOldState;
      ManageMIDIDevicesEntry *e;

      if(COL_OPEN == _col)
      {
         e <= devs.get(_row);
         // trace "xxx handleCellOnMouse: 1"+" _ev.current_state="+_ev.current_state+" _ev.changed_state="+_ev.changed_state;
         bOldState = cb_active_edit.isSelected();
         if(cb_active_edit.onMouse(_ev))
         {
            // trace "xxx handleCellOnMouse: 2";
            bChanged = cb_active_edit.isSelected();
            // // trace "xxx handleCellOnMouse: 3 bChanged="+bChanged+" e.b_open="+e.b_open;
            // // if(bChanged ^ e.b_open)
            // // {
            if(bOldState ^ bChanged)
            {
               e.b_open = cb_active_edit.isSelected();

               // trace "xxx before handleToggleOpen: e.b_out="+e.b_out+" e.b_open="+e.b_open;
               // trace "xxx e.b_present="+e.b_present+" e.b_open="+e.b_open+" e.b_virtual="+e.b_virtual+" e.b_unavail="+e.b_unavail;

               if(!e.b_present)
               {
                  StringArray devNames <= e.b_out ? STConfig.midi_out_devicenames : STConfig.midi_in_devicenames;
                  if(!e.b_open)
                  {
                     int devNameIdx = devNames.indexOfObject(e.name, 0);
                     if(-1 != devNameIdx)
                     {
                        devNames.delete(devNameIdx);
                        Global.Print("Deselect non-present "+(e.b_out ? "output" : "input")+" device \""+e.name+"\"");
                     }
                  }
                  else
                  {
                     devNames.add(e.name);
                     Global.Print("Select non-present "+(e.b_out ? "output" : "input")+" device \""+e.name+"\"");
                  }
               }
               else if(!(e.b_virtual && !e.b_unavail))
               {
                  handleToggleOpen(e);
               }
               else
               {
                  Global.Print((e.b_open?"Select":"Deselect")+" virtual device \""+e.name+"\"");
               }
               // ...
            }
            return true;
         }
      }
      else if(COL_ECHO == _col)
      {
         e <= devs.get(_row);
         // trace "xxx handleCellOnMouse: 1"+" _ev.current_state="+_ev.current_state+" _ev.changed_state="+_ev.changed_state;
         if(cb_echo_edit.onMouse(_ev))
         {
            bChanged = cb_echo_edit.isSelected();
            if(bChanged ^ e.b_echo)
            {
               e.b_echo = cb_echo_edit.isSelected();
               MIDI.SetMIDIEchoEnabled(e.getAliasOrDeviceName(), e.b_echo);
               // ...
            }
            return true;
         }
      }
      else if(COL_CLK == _col)
      {
         e <= devs.get(_row);
         if(cb_clk_edit.onMouse(_ev))
         {
            bChanged = cb_clk_edit.isSelected();
            if(bChanged ^ e.b_clk)
            {
               e.b_clk = cb_clk_edit.isSelected();
               MIDI.SetMIDIClockEnabled(e.getAliasOrDeviceName(), e.b_clk);
               // ...
            }
            return true;
         }
      }
      else if(COL_MMCREC == _col)
      {
         e <= devs.get(_row);
         if(cb_mmcrec_edit.onMouse(_ev))
         {
            bChanged = cb_mmcrec_edit.isSelected();
            if(bChanged ^ e.b_mmcrec)
            {
               e.b_mmcrec = cb_mmcrec_edit.isSelected();
               MIDI.SetMIDIMMCRecEnabled(e.getAliasOrDeviceName(), e.b_mmcrec);
               // ...
            }
            return true;
         }
      }
      else if(COL_MMCPLAY == _col)
      {
         e <= devs.get(_row);
         if(cb_mmcplay_edit.onMouse(_ev))
         {
            bChanged = cb_mmcplay_edit.isSelected();
            if(bChanged ^ e.b_mmcplay)
            {
               e.b_mmcplay = cb_mmcplay_edit.isSelected();
               MIDI.SetMIDIMMCPlayEnabled(e.getAliasOrDeviceName(), e.b_mmcplay);
               // ...
            }
            return true;
         }
      }
      else if(COL_MTC == _col)
      {
         e <= devs.get(_row);
         if(cb_mtc_edit.onMouse(_ev))
         {
            bChanged = cb_mtc_edit.isSelected();
            if(bChanged ^ e.b_mtc)
            {
               e.b_mtc = cb_mtc_edit.isSelected();
               MIDI.SetMIDIMTCEnabled(e.getAliasOrDeviceName(), e.b_mtc);
               // ...
            }
            return true;
         }
      }
      else if(COL_SPP == _col)
      {
         e <= devs.get(_row);
         if(cb_spp_edit.onMouse(_ev))
         {
            bChanged = cb_spp_edit.isSelected();
            if(bChanged ^ e.b_spp)
            {
               e.b_spp = cb_spp_edit.isSelected();
               MIDI.SetMIDISPPEnabled(e.getAliasOrDeviceName(), e.b_spp);
               // ...
            }
            return true;
         }
      }

      return false;
   }

   public virtual initTableModel() {
      initCheckBox(cb_active_render);
      initCheckBox(cb_active_edit);
      initCheckBox(cb_echo_render);
      initCheckBox(cb_echo_edit);
      initCheckBox(cb_clk_render);
      initCheckBox(cb_clk_edit);
      initCheckBox(cb_mmcrec_render);
      initCheckBox(cb_mmcrec_edit);
      initCheckBox(cb_mmcplay_render);
      initCheckBox(cb_mmcplay_edit);
      initCheckBox(cb_mtc_render);
      initCheckBox(cb_mtc_edit);
      initCheckBox(cb_spp_render);
      initCheckBox(cb_spp_edit);

      TableModel::initTableModel();
   }

   public virtual getMinimumColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_ID:
            return 24;

         case COL_PRESENT:
            return 42;

         case COL_OPEN:
            return 32;

         case COL_OPENED:
            return 42;

         case COL_ECHO:
            return 32;

         case COL_CLK:
            return 32;

         case COL_MMCREC:
            return 32;

         case COL_MMCPLAY:
            return 36;

         case COL_MTC:
            return 36;

         case COL_SPP:
            return 36;

         case COL_ALIAS:
            return 110;

         case COL_NAME:
            return 200;
      }
   }

   public virtual getPreferredColumnWidth(int _col) : int {
      switch(_col)
      {
         case COL_ID:
            return 24;

         case COL_PRESENT:
            return 37;

         case COL_OPEN:
            return 20;

         case COL_OPENED:
            return 34;

         case COL_ECHO:
            return 32;

         case COL_CLK:
            return 32;

         case COL_MMCREC:
            return 32;

         case COL_MMCPLAY:
            return 36;

         case COL_MTC:
            return 36;

         case COL_SPP:
            return 36;

         case COL_ALIAS:
            return 320;

         case COL_NAME:
            return 800;
      }
   }
}
