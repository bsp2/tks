// ----
// ---- file   : NT_ImportMonitorDialog.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- license: (c) 2019-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   :
// ----
// ---- created: 20Oct2019
// ---- changed: 28Apr2020, 02Sep2023, 04Oct2023, 06Oct2023, 30Oct2023, 04Jan2025
// ----
// ----
// ----

module MNT_ImportMonitorDialog;

use namespace ui;
use namespace st2;


// <class.png>
class NT_ImportMonitorDialog extends Dialog, ActionProvider, MMTListener {

   define String ACTION_MONITOR_IMPORT;
   define String ACTION_MONITOR_CANCEL;

   protected XMLForm *xfm;

   protected ActionConsumer *recipient;

   protected CheckBox *cb_reinit;
   protected CheckBox *cb_multi;
   protected CheckBox *cb_ins_params;
   protected CheckBox *cb_convrpnpc;
   protected CheckBox *cb_copypatname;
   protected CheckBox *cb_resetrec;
   protected CheckBox *cb_alignbars;

   protected Button *bt_import;
   protected Button *bt_cancel;


   // <ui_init.png>
   public method init() : boolean {

      initDialog();

      xfm <= XMLForm.New_PakFile("NT_ImportMonitorDialog.xfm");
      if(null == xfm)
         return false;

      xfm.autoResolveIds(this);

      initWindow(xfm,
                 "Import Monitor Pattern",
                 100, 100,
                 640, 240
                 );

      return true;
   }

   public method setRecipient(ActionConsumer _ac) {
      recipient <= _ac;
   }

   public virtual getProvidedActionNames() : StringArray {
      return [ACTION_MONITOR_IMPORT, ACTION_MONITOR_CANCEL];
   }

   public virtual isPopup() : boolean {
      return true;
   }

   public virtual isModal():boolean {
      return true;
   }

   public virtual isResizable() : boolean {
      return false;
   }

   // <ui_show.png>
   protected virtual preShow() {

      setWindowTitle("Import Monitor Pattern");

      if(!b_layer_postinit_done)
         resizeToMinimum();

      Dialog::preShow();
   }

   // <ui_show.png>
   protected virtual postShow() {
      Dialog::postShow();
      UI.SetKeyboardFocus(bt_import);
   }

   // <ui_handle.png>
   protected method handleCancel() {
      hide();

      if(recipient instanceof ActionConsumer)
      {
         Action ac <= Action.New(getProvidedActionAlias(ACTION_MONITOR_CANCEL), this);
         recipient.consumeAction(ac);
         // Note: Do not add code below this line since the dialog instance may have been deleted by the recipient!
      }
   }

   // <ui_handle.png>
   protected method handleImport() {
      hide();

      if(recipient instanceof ActionConsumer)
      {
         Action ac <= Action.New(getProvidedActionAlias(ACTION_MONITOR_IMPORT), this);
         recipient.consumeAction(ac);
         // Note: Do not add code below this line since the dialog instance may have been deleted by the recipient!
      }
   }

   // <method_get.png>
   public method doReInit() : boolean {
      return cb_reinit.isSelected();
   }

   // <method_get.png>
   public method doMulti() : boolean {
      return cb_multi.isSelected();
   }

   // <method_get.png>
   public method doInstrumentsAndParams() : boolean {
      return cb_ins_params.isSelected();
   }

   // <method_get.png>
   public method doConvRPNPC() : boolean {
      return cb_convrpnpc.isSelected();
   }

   // <method_get.png>
   public method doPreferCTLPC() : boolean {
      // [20Oct2019] atm, param PCs will not be recorded correctly => always record CTL_PC
      return true;
   }

   // <method_get.png>
   public method doCopyPatName() : boolean {
      return cb_copypatname.isSelected();
   }

   // <method_get.png>
   public method doResetRec() : boolean {
      return cb_resetrec.isSelected();
   }

   // <method_get.png>
   public method doAlignBars() : boolean {
      return cb_alignbars.isSelected();
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {

      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          c         :   Close dialog
"
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      int key = _k.pressed;
      boolean r = false;
      loop(2) // first pass for raw keycode, second pass for unicode
      {
         // US (reference) keyboard layout (raw keycodes)
         switch(key)
         {
            case 'c':
               hide();
               r = true; break;

            default:
               r = maybe; break;
         }

         if(true == r)
         {
            return true;
         }
         else if(maybe == r)
         {
            Global.Print("");
         }

         // see above
         key = _k.unicode;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {
      switch(_k.pressed)
      {
         case VKEY_ESCAPE:
            handleCancel();
            return true;

         case VKEY_F9:
            if(_k.modShiftOnly())
            {
               handleCancel();
               return true;
            }
            break;

         case VKEY_RETURN:
         case VKEY_SPACE:
            handleImport();
            return true;

         default:
            break;
      }
      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _ac) : boolean {
      String name=_ac.getActionName();

      ////trace "xxx NT_ImportMonitorDialog: got action name="+name;

      switch(name)
      {
         case "ok":
            handleImport();
            break;

         case "cancel":
            handleCancel();
            break;
      }

      switch(@(_ac.getActionProvider()))
      {
         case @(bt_import):
             handleImport();
             return true;

         case @(bt_cancel):
             handleCancel();
             return true;
      }

      return true;
   }

}
