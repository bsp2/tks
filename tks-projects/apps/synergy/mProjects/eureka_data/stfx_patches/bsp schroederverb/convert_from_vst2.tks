// 21Apr2023

// $ for d in *.fxp; do tks ../../stfx_patches/bsp\ schroederverb/convert_from_vst2.tks "$d" "../../stfx_patches/bsp schroederverb/${d:s/.fxp/.stfx}"; done

class Utils {
   // <method_write.png>
   static public method WriteString(Stream _out, String _s) {
      // // int coff = _out.offset;

      if(null != _s)
      {
         // (note) first 32bit int of data is string length
         _out.serialize(_s, false);

         // // FixChunkSize(_out, coff);
      }
      else
      {
         _out.i32 = 0;
      }
   }
}

if(Arguments.numElements < 2)
   die "convert <vstpatch.fxp> <stfxpatch.stfx>";

File fIn;
String sIn <= Arguments[0];
if(!(sIn >= ".fxp"))
   die "[---] input must be .fxp file";

String sOut <= Arguments[1];
if(!(sOut >= ".stfx"))
   die "[---] output must be .stfx file";

if(fIn.openLocal(sIn, IOS_IN))
{
   fIn.byteOrder = BIG_ENDIAN;

   File fOut;
   if(fOut.openLocal(sOut, IOS_OUT))
   {
      trace "[...] convert \""+Arguments[0]+"\" to \""+Arguments[1]+"\"";

      fOut.byteOrder = LITTLE_ENDIAN;

      // ver
      fOut.i16 = 1;

      // plugin id
      Utils.WriteString(fOut, "bsp schroederverb");

      fIn.offset = 24;
      int numParams = fIn.i32;
      trace "[dbg] numParams="+numParams;

      // num params
      fOut.i16 = numParams;

      fIn.offset = 28 + 28; // skip program name

      loop(numParams)
      {
         fOut.f32 = fIn.f32;
      }

      fOut.close();

      trace "[...] wrote \""+sOut+"\"";
   }
   fIn.close();
}
