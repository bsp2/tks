// ----
// ---- file   : MIDIMapEventType.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2012-2023 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 29Feb2012
// ----
// ---- changed: 09Nov2012, 13Nov2012, 04Jan2013, 25Mar2013, 09Apr2013, 14Apr2013, 11Aug2014
// ----          13Aug2014, 14Aug2014, 15Aug2014, 19Aug2014, 21Aug2014, 20Apr2015, 14Nov2015
// ----          12Feb2016, 03Oct2019, 04Oct2019, 08Oct2019, 13Apr2021, 01Jun2021, 03Jun2021
// ----          25Apr2022, 20Oct2023
// ----
// ----
// ----

module MMIDIMapEventType;

use namespace st2;


// <class.png>
class MIDIMapEventType : MIDIMapDefs {

   static StringArray type_names = [
      "Note off",
      "Note on",
      "Poly pressure",
      "CC",
      "Program change",
      "Channel pressure",
      "Pitchbend",
      "SysEx",
      "SysCom quarter timecode",
      "SysCom song position",
      "SysCom song select",
      "SysCom 0xF4",
      "SysCom 0xF5",  // Bus Select ?
      "SysCom tune request",
      "SysRT timing clock",
      "SysRT 0xF9",
      "SysRT start",
      "SysRT continue",
      "SysRT stop",
      "SysRT 0xFD",
      "SysRt active sensing",
      "SysRT system reset",
      "RPN",
      "NRPN"
                                    ];

   static StringArray type_names_short = [
      "Note Off",
      "Note On",
      "PolyPressure",
      "CC",
      "Prog.Chg",
      "Ch.Pressure",
      "Pitchbend",
      "SysEx",
      "SysTimeCode",
      "Sys.SongPos",
      "Sys.SongSel",
      "Sys 0xF4",
      "Sys 0xF5",
      "Sys.TuneReq",
      "SysRT.Clock",
      "SysRT 0xF9",
      "SysRT.Start",
      "SysRT.Continue",
      "SysRT.Stop",
      "SysRT 0xFD",
      "SysRT.ActSens",
      "SysRT.Reset",
      "RPN",
      "NRPN"
                                    ];

   static StringArray type_names_short2 = [
      "Note Off",
      "Note On",
      "Poly AT",
      "CC",
      "PrgChg",
      "Ch AT",
      "Pitchbend",
      "SysEx",
      "Sys Time",
      "Sys SongPos",
      "Sys SongSel",
      "Sys F4",
      "Sys F5",
      "Sys TuneRq",
      "Sys Clock",
      "Sys F9",
      "Sys Start",
      "Sys Cont",
      "Sys Stop",
      "Sys FD",
      "Sys Active",
      "Sys Reset",
      "RPN",
      "NRPN"
                                    ];

   public byte  type;      // one of MIDIMapDefs.TYPE_xxx. -1 if input filter type is set to '*'
   public short ext_type;  // Note number, continuous controller or (N)RPN id. -1 if unused.

   static StringArray flt_names = [ "off", "==", "!=", ">=", "> ", "<=", "< " ];

   // See class_xxx
   public byte class_type;

   // see SYN_xxx
   public byte syn_type;


   public method initEventType() {
      type       = -1;
      ext_type   = -1;
      class_type = CLASS_UNKNOWN;
      syn_type   = SYN_NONE;
   }

   public method copyFrom(MIDIMapEventType _o) {
      type       = _o.type;
      ext_type   = _o.ext_type;
      class_type = _o.class_type;
      syn_type   = _o.syn_type;
   }


   public method getTypeName() : String {
      if(SYN_NONE != syn_type)
      {
         return type_names.get(type)+"<syn>";
      }
      else
      {
         return type_names.get(type);
      }
   }

   public method getExtTypeName() : String {
      Integer io;

      // trace "xxx getExtTypeName(): ext_type="+ext_type+" type="+type;

      if(-1 != ext_type)
      {
         switch(type)
         {
            case TYPE_NOTE_ON:
               return "-";

            case TYPE_NOTE_OFF:
               return "-";

            case TYPE_CC:
               return MIDI.cc_names.get(ext_type);

            case TYPE_RPN:
               // RPN
               io = ext_type;
               return "RPN#"+io.printf("%05d");

            case TYPE_NRPN:
               // (N)RPN
               io = ext_type;
               return "NRPN#"+io.printf("%05d");
         }
      }

      return getTypeName();
   }

   public method getDefaultShortNameForCtlTagLabel() : String {
      // called when no MIDISynthProfileCtlAlias is available
      Integer io;
      switch(type)
      {
         case TYPE_CC:
            return MIDI.cc_ctltag_shortnames.get(ext_type);

         case TYPE_RPN:
            // RPN
            io = ext_type;
            return "RPN "+io.printf("%05d");

         case TYPE_NRPN:
            // (N)RPN
            io = ext_type;
            return "NRPN "+io.printf("%05d");
      }
      return null;
   }

   public method hasExtType() : boolean {
      switch(type)
      {
         case TYPE_CC:
         case TYPE_RPN:
         case TYPE_NRPN:
            return true;
      }
      return false;
   }

   public method usesArg1() : boolean {
      if([
            TYPE_NOTE_OFF,
            TYPE_NOTE_ON,
            TYPE_POLY_PRESSURE,
            TYPE_PROGRAM_CHANGE,
            TYPE_CHANNEL_PRESSURE,
            TYPE_PITCHBEND,
            TYPE_CC,
            TYPE_RPN,
            TYPE_NRPN
            ]
         .contains(type))
      {
         return true;
      }

      return false;
   }

   public method usesArg2() : boolean {
      if([
            TYPE_NOTE_OFF,
            TYPE_NOTE_ON,
            TYPE_POLY_PRESSURE
            ]
         .contains(type))
      {
         return true;
      }

      return false;
   }

   public =replay= method setType(int _type) {
      type = _type;
   }

   public =replay= method setExtType(int _extType) {
      ext_type = _extType;
   }

   public method isNoteEvent() : boolean {
      return (TYPE_NOTE_ON == type) || (TYPE_NOTE_OFF == type);
   }

   public method isNoteOn() : boolean {
      return (TYPE_NOTE_ON == type);
   }

   public method isNoteOff() : boolean {
      return (TYPE_NOTE_OFF == type);
   }

   public method isPitchbend() : boolean {
      return (TYPE_PITCHBEND == type);
   }

   public method isCC() : boolean {
      return (TYPE_CC == type);
   }

   public method getMaxValue() : float {
      switch(type)
      {
         case TYPE_NOTE_OFF:
         case TYPE_NOTE_ON:
         case TYPE_POLY_PRESSURE:
         case TYPE_CC:
         case TYPE_PROGRAM_CHANGE:
         case TYPE_CHANNEL_PRESSURE:
            return 127.0f;

         case TYPE_PITCHBEND:
            return 16383.0f;

         case TYPE_SYSEX:
         case TYPE_SYSCOM_TIMECODE:
         case TYPE_SYSCOM_SONG_POSITION:
         case TYPE_SYSCOM_SONG_SELECT:
         case TYPE_SYSCOM_F4:
         case TYPE_SYSCOM_F5:
         case TYPE_SYSCOM_TUNE_REQUEST:
         case TYPE_SYSRT_TIMING_CLOCK:
         case TYPE_SYSRT_F9:
         case TYPE_SYSRT_START:
         case TYPE_SYSRT_CONTINUE:
         case TYPE_SYSRT_STOP:
         case TYPE_SYSRT_FD:
         case TYPE_SYSRT_ACTIVE_SENSING:
         case TYPE_SYSRT_SYSTEM_RESET:
            break;

         case TYPE_RPN:
         case TYPE_NRPN:
            return 16383.0f;
      }
      return 0.0f;
   }

   public method matchPipeEventType(MIDIPipeEvent _pev) : boolean {
      switch(type)
      {
         case TYPE_NOTE_OFF:
            return (MIDIPIPE_EVENT_TYPE_NOTE_OFF == _pev.type);

         case TYPE_NOTE_ON:
            return (MIDIPIPE_EVENT_TYPE_NOTE_ON == _pev.type);

         case TYPE_POLY_PRESSURE:
            return (MIDIPIPE_EVENT_TYPE_POLYPRESSURE == _pev.type);

         case TYPE_CC:
            return
               (MIDIPIPE_EVENT_TYPE_CC == _pev.type) &&
               (ext_type == _pev.ccId)               ;

         case TYPE_PROGRAM_CHANGE:
            return (MIDIPIPE_EVENT_TYPE_PRGCHG == _pev.type);

         case TYPE_CHANNEL_PRESSURE:
            return (MIDIPIPE_EVENT_TYPE_CHPRESSURE == _pev.type);

         case TYPE_PITCHBEND:
            return (MIDIPIPE_EVENT_TYPE_PITCHBEND == _pev.type);

         case TYPE_SYSEX:
            return (MIDIPIPE_EVENT_TYPE_SYSEX == _pev.type);

         case TYPE_SYSCOM_TIMECODE:
         case TYPE_SYSCOM_SONG_POSITION:
         case TYPE_SYSCOM_SONG_SELECT:
         case TYPE_SYSCOM_F4:
         case TYPE_SYSCOM_F5:
         case TYPE_SYSCOM_TUNE_REQUEST:
         case TYPE_SYSRT_TIMING_CLOCK:
         case TYPE_SYSRT_F9:
         case TYPE_SYSRT_START:
         case TYPE_SYSRT_CONTINUE:
         case TYPE_SYSRT_STOP:
         case TYPE_SYSRT_FD:
         case TYPE_SYSRT_ACTIVE_SENSING:
         case TYPE_SYSRT_SYSTEM_RESET:
            return false;

         case TYPE_RPN:
            return
               (MIDIPIPE_EVENT_TYPE_RPN == _pev.type) &&
               (ext_type == _pev.rpn)                 ;

         case TYPE_NRPN:
            return
               (MIDIPIPE_EVENT_TYPE_NRPN == _pev.type) &&
               (ext_type == _pev.nrpn)                 ;
      }
      return false;
   }

   public method matchMIDIMapEventType(MIDIMapEventType _o) : boolean {
      if(_o.type == type)
      {
         if(_o.ext_type == _o.ext_type)
         {
            return true;
         }
      }
      return false;
   }

   public method emitNormalizedValue(MIDIPipeFrame _frOut, int _dev, int _ch, float _val, int _forcedType) {
      // called by NodeModular
      if(-1 == _forcedType)
         _forcedType = type;

      switch(type)
      {
         case TYPE_PITCHBEND:
            _frOut.pitchbend(true/*bSet*/, _dev, _ch, (_val >= 0.0) ? (8192 + _val*8191) : (8192 + _val*8192));
            break;

         case TYPE_CC:
            _frOut.cc(true/*bSet*/, _dev, _ch, ext_type, mathMaxf(0.0f, _val * 127.0));
            break;

         case TYPE_RPN:
            _frOut.rpn(true/*bSet*/, _dev, _ch, ext_type, mathMaxf(0.0f, _val * 16383.0));
            break;

         case TYPE_NRPN:
            _frOut.nrpn(true/*bSet*/, _dev, _ch, ext_type, mathMaxf(0.0f, _val * 16383.0));
            break;

         case TYPE_CHANNEL_PRESSURE:
            _frOut.chPressure(true/*bSet*/, _dev, _ch, mathMaxf(0.0f, _val * 127.0));
            break;
      }
   }

   public method emitNormalizedValueBipolar(MIDIPipeFrame _frOut, int _dev, int _ch, int _nr, float _val, int _forcedType) {
      // called by NodeModular
      //  (note) _nr >= 0 overrides default ext_type (CC#, (N)RPN)
      if(-1 == _forcedType)
         _forcedType = type;

      switch(_forcedType)
      {
         case TYPE_PITCHBEND:
            _frOut.pitchbend(true/*bSet*/, _dev, _ch, (_val >= 0.0) ? (8192 + _val*8191) : (8192 + _val*8192));
            break;

         case TYPE_CC:
            if(_val >= 0.0)
               _val = 64.0 + _val * 63.0;
            else
               _val = 64.0 + _val * 64.0;
            _frOut.cc(true/*bSet*/, _dev, _ch, (_nr >= 0) ? _nr : ext_type, mathClampf(_val, 0.0f, 127.0f));
            break;

         case TYPE_RPN:
            if(_val >= 0.0)
               _val = 8192.0 + _val * 8191.0;
            else
               _val = 8192.0 + _val * 8192.0;
            _frOut.rpn(true/*bSet*/, _dev, _ch, (_nr >= 0) ? _nr : ext_type, mathClampf(_val, 0.0f, 16383.0f));
            // trace "xxx frOut.rpn(val="+_val+")";
            break;

         case TYPE_NRPN:
            if(_val >= 0.0)
               _val = 8192.0 + _val * 8191.0;
            else
               _val = 8192.0 + _val * 8192.0;
            _frOut.nrpn(true/*bSet*/, _dev, _ch, (_nr >= 0) ? _nr : ext_type, mathClampf(_val, 0.0f, 16383.0f));
            break;

         case TYPE_CHANNEL_PRESSURE:
            if(_val >= 0.0)
               _val = 64.0 + _val * 63.0;
            else
               _val = 64.0 + _val * 64.0;
            _frOut.chPressure(true/*bSet*/, _dev, _ch, mathClampf(_val, 0.0f, 127.0));
            break;
      }
   }

   public method emitTrig(MIDIPipeFrame _frOut, int _dev, int _ch, boolean _bTrig) {
      // called by NodeModular
      switch(type)
      {
         case TYPE_PITCHBEND:
            _frOut.pitchbend(true/*bSet*/, _dev, _ch, _bTrig ? 16383 : 0);
            break;

         case TYPE_CC:
            _frOut.cc(true/*bSet*/, _dev, _ch, ext_type, _bTrig ? 16383 : 0);
            break;

         case TYPE_RPN:
            _frOut.rpn(true/*bSet*/, _dev, _ch, ext_type, _bTrig ? 16383 : 0);
            break;

         case TYPE_NRPN:
            _frOut.nrpn(true/*bSet*/, _dev, _ch, ext_type, _bTrig ? 16383 : 0);
            break;

         case TYPE_CHANNEL_PRESSURE:
            _frOut.chPressure(true/*bSet*/, _dev, _ch, _bTrig ? 127 : 0);
            break;
      }
   }

   public method initFromMIDISynthProfileCtlAlias(MIDISynthProfileCtlAlias _alias) {
      type = _alias.type;

      switch(_alias.type)
      {
         case MIDIMapDefs.TYPE_CC:
            ext_type = _alias.nr;
            break;

         case MIDIMapDefs.TYPE_RPN:
         case MIDIMapDefs.TYPE_NRPN:
            ext_type = _alias.nr;
            break;
      }
   }

}
