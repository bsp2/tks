// ----
// ---- file   : NodeSeqEditor.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2020-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- created: 06Apr2020
// ---- changed: 07Apr2020, 08Apr2020, 09Apr2020, 11Apr2020, 12Apr2020, 13Apr2020, 14Apr2020
// ----          15Apr2020, 16Apr2020, 17Apr2020, 18Apr2020, 21Apr2020, 24Apr2020, 25Apr2020
// ----          26Apr2020, 28Apr2020, 06May2020, 07May2020, 09May2020, 10May2020, 13May2020
// ----          24Oct2020, 26Oct2020, 30Oct2020, 06Nov2020, 08Nov2020, 10Nov2020, 14Nov2020
// ----          15Nov2020, 27Nov2020, 30Jan2021, 13May2021, 14May2021, 23May2021, 02Jun2021
// ----          03Jun2021, 14Jun2021, 17Jun2021, 18Jun2021, 21Jun2021, 24Feb2022, 07May2022
// ----          24Jun2022, 03Nov2022, 11Feb2023, 19Feb2023, 03Apr2023, 11Jun2023, 23Jun2023
// ----          24Jun2023, 02Sep2023, 03Sep2023, 20Sep2023, 21Sep2023, 03Oct2023, 05Oct2023
// ----          14Oct2023, 03Feb2024, 06Oct2024, 04Jan2025, 26Jan2025, 28Feb2025, 09May2025
// ----          28May2025, 07Jun2025
// ----
// ----
// ----

module MNodeSeqEditor;

use namespace ui;
use namespace st2;


// <class.png>
class NodeSeqEditor extends NodeEditor, ActionProvider, MIDIMapEventListener, MIDIMapDefs {

   define String MMT_UNDO;
   define String MMT_REDO;
   define String MMT_TOGGLE_PRECOUNT;
   define String MMT_START_STOP_REPLAY;
   define String MMT_START_STOP_REPLAY_MMC;
   define String MMT_START_STOP_RECORD;
   define String MMT_START_STOP_RECORD_MMC;
   define String MMT_QUEUE_RECORD_RESTART;
   define String MMT_FORCE_STEP_RECORD;
   define String MMT_TOGGLE_STEP_RECORD;
   define String MMT_TOGGLE_ARM_NODE;
   define String MMT_TOGGLE_ARM_TRACK;
   define String MMT_TOGGLE_FOCUS_TRACK;
   define String MMT_TOGGLE_MUTE_TRACK;
   define String MMT_TOGGLE_SOLO_TRACK;
   define String MMT_CURSOR_SELECT_MOD;
   define String MMT_CURSOR_BAR_PREV;
   define String MMT_CURSOR_BAR_NEXT;
   define String MMT_CURSOR_HOME;
   define String MMT_CURSOR_END;
   define String MMT_CURSOR_TRACK_PREV;
   define String MMT_CURSOR_TRACK_NEXT;
   define String MMT_CURSOR_TRACK_DELTA;
   define String MMT_CURSOR_TRACK_1;
   define String MMT_CURSOR_TRACK_2;
   define String MMT_CURSOR_TRACK_3;
   define String MMT_CURSOR_TRACK_4;
   define String MMT_CURSOR_TRACK_5;
   define String MMT_CURSOR_TRACK_6;
   define String MMT_CURSOR_TRACK_7;
   define String MMT_CURSOR_TRACK_8;
   define String MMT_CURSOR_TRACK_9;
   define String MMT_CURSOR_TRACK_10;
   define String MMT_CURSOR_TRACK_11;
   define String MMT_CURSOR_TRACK_12;
   define String MMT_PUNCH_IN;
   define String MMT_PUNCH_OUT;
   define String MMT_LOOP_L;
   define String MMT_LOOP_R;
   define String MMT_LOOP_MOVE;
   define String MMT_LOOP_SELECTION;
   define String MMT_LOOP_1;
   define String MMT_LOOP_2;
   define String MMT_LOOP_4;
   define String MMT_LOOP_8;
   define String MMT_INSERT_BARS;
   define String MMT_INSERT_BARS_TEMPO;
   define String MMT_DELETE_BARS;
   define String MMT_DELETE_BARS_TEMPO;
   define String MMT_CLEAR_BARS;
   define String MMT_OUTPUT_STATE_CLEAR;
   define String MMT_OUTPUT_STATE_PASTE;
   define String MMT_CLEAR_TRACK_OR_PATTERN_LOOP_RANGE;
   define String MMT_CLEAR_TRACK_1;
   define String MMT_CLEAR_TRACK_2;
   define String MMT_CLEAR_TRACK_3;
   define String MMT_CLEAR_TRACK_4;
   define String MMT_CLEAR_TRACK_5;
   define String MMT_CLEAR_TRACK_6;
   define String MMT_CLEAR_TRACK_7;
   define String MMT_CLEAR_TRACK_8;
   define String MMT_CLEAR_TRACK_9;
   define String MMT_CLEAR_TRACK_10;
   define String MMT_CLEAR_TRACK_11;
   define String MMT_CLEAR_TRACK_12;
   define String MMT_PATTERN_CLONE;
   define String MMT_PATTERN_CLONE_SUB;
   define String MMT_PATTERN_COPY;
   define String MMT_PATTERN_PASTE;

   protected boolean b_mmt_select_mod;

   define String TA_CHECKREDRAW;
   module TimerAction *ta_checkredraw;

   define String TA_MINIUNDO;
   module TimerAction *ta_miniundo;

   define int TAB_PORTS     = 0;
   define int TAB_PATTERN   = 1;
   define int TAB_SEQUENCE  = 2;
   define int TAB_PLAY      = 3;
   define int NUM_TABS      = 4;

   public NodeSeq *seq;

   protected Panel     *pn_groups;
   protected TabSwitch *ts_groups;
   protected TextField *tf_pat_name2;


   // Ports:
   protected DevioceIOForm *[] io_forms;     // DeviceIOForm refs
   protected Button *bt_ports_clear;
   protected Button *bt_ports_def;
   protected Button *bt_ports_nr;


   // Pattern:
   protected ComboBox   *cm_pattern_nr;
   protected Label      *lb_pat_nr;
   protected TextField  *tf_pat_name;
   protected Button     *bt_clear;

   protected Button    *bt_pat_alloc;
   protected Button    *bt_pat_tools;
   protected PopupMenu *pm_pat_tools;
   protected Button    *bt_pat_free;

   protected PointerArray track_forms;  // NSQ_TrackForm refs

   // Sequence:
   NSQ_Arranger *arr;
   NSQ_Tempo    *tempo;
   NSQ_Events   *evt;

   protected LayerSwitch *ls_help;

   protected LayerSwitch *ls_tempo;

   protected CheckBox   *cb_seq_rec;
   protected CheckBox   *cb_seq_rec_bg;
   protected CheckBox   *cb_seq_rec_prev;
   protected CheckBox   *cb_seq_master;

   protected CheckBox   *cb_rec_replace;
   protected CheckBox   *cb_seq_metro;
   protected CheckBox   *cb_seq_pre;
   protected CheckBox   *cb_seq_autoscroll;

   protected CheckBox   *cb_fast_clear;
   protected CheckBox   *cb_tempo_snap;
   protected CheckBox   *cb_step;
   protected CheckBox   *cb_seq_autorf;

   protected ComboBox   *cm_seq_q;

   protected FloatParam *fp_sig_beats;
   protected FloatParam *fp_sig_notelen;

   protected FloatParam *fp_visbars;

   protected Button *bt_undo;
   protected Button *bt_redo;
   protected Button *bt_undo_clear;

   protected Button *bt_record;
   protected Button *bt_view;

   // Play:
   protected ComboBox *cm_node_class;
   protected CheckBox *cb_node_class_show;
   // (note) cm_node_class_show_in is declared in NodeEditor base class

   protected NSQ_FilterDialog  *dlg_filter;
   protected NSQ_ExplodeDialog *dlg_explode;

   public NodeTracker *tracker_node;  // temporary tracker editor (or null)


   // <init.png>
   public virtual init() : boolean {

      if(initPakFile("NodeSeqEditor.xfm"))
      {
         if(autoResolveIds(this))
         {
            // Move pattern name textfield into TabSwitch
            tf_pat_name2 <= pn_groups.unlinkChildLayer(tf_pat_name2);
            pn_groups.removeChildLayer(tf_pat_name2);
            Panel pnLabels <= ts_groups.getPnLabels();
            pnLabels.addLayer(tf_pat_name2, Layout.RIGHT);

            f_autodev.initAutoDeviceForm();

            cm_pattern_nr.setOptions(Node.patnr_options);

            // Resolve output port DeviceIOForms
            int trackNr = 1;
            loop(NodeSeq.NUM_TRACKS)
            {
               DeviceIOForm ioForm <= findLayerById("out_"+trackNr);
               if(!ioForm.init(this/*listener*/,
                               true/*bAllowAllCh*/,
                               false/*bShowVarName*/,
                               false/*bShowEnable*/,
                               null/*nameLabelOrNull*/
                               )
                  )
                  return false;
               io_forms.add(ioForm);
               ioForm.setFormArray(io_forms);
               trackNr++;
            }

            // Resolve track forms
            trackNr = 1;
            loop(NodeSeq.NUM_TRACKS)
            {
               NSQ_TrackForm tf <= findLayerById("tf_"+trackNr);
               if(!tf.init(this, trackNr))
                  return false;
               track_forms.add(tf);
               trackNr++;
            }

            arr  .init(this);
            tempo.init(this);
            evt.  init(this);

            initMMC();

            initTimers();

            if(!initFilterDialog())
               return false;

            if(!initExplodeDialog())
               return false;

            return true;
         }
      }

      return false;
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_checkredraw  <= TimerAction.New(TA_CHECKREDRAW, this, 1000.0/20);
      ta_miniundo     <= TimerAction.New(TA_MINIUNDO,    this, NodeSeq.UNDO_MINIEDIT_TIMEOUT_MS/*1sec*/);
   }

   // <ui_init.png>
   protected method initFilterDialog() : boolean {
      dlg_filter <= new NSQ_FilterDialog;
      if(!dlg_filter.init(this))
      {
         Global.Error("NSQ_FilterDialog::init() failed");
         return false;
      }
      return true;
   }

   // <ui_init.png>
   protected method initExplodeDialog() : boolean {
      dlg_explode <= new NSQ_ExplodeDialog;
      if(!dlg_explode.init(this))
      {
         Global.Error("NSQ_ExplodeDialog::init() failed");
         return false;
      }
      return true;
   }

   // <midi_mmc.png>
   protected method initMMC() {

      mmcInit("NodeSeqEditor");

      // From PageNode: (so these show up in the map editor)
      root_form.pg_node.addBaseMMCTargets(this);

      mmcAddTarget(MMT_UNDO,                         CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_REDO,                         CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TOGGLE_PRECOUNT,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_START_STOP_REPLAY,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_START_STOP_REPLAY_MMC,        CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_START_STOP_RECORD,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_START_STOP_RECORD_MMC,        CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_QUEUE_RECORD_RESTART,         CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_FORCE_STEP_RECORD,            CLASS_BUTTON, SYN_BUTTON_MOD);
      mmcAddTarget(MMT_TOGGLE_STEP_RECORD,           CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TOGGLE_ARM_NODE,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TOGGLE_ARM_TRACK,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TOGGLE_FOCUS_TRACK,           CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TOGGLE_MUTE_TRACK,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TOGGLE_SOLO_TRACK,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CURSOR_SELECT_MOD,            CLASS_BUTTON, SYN_BUTTON_MOD);
      mmcAddTarget(MMT_CURSOR_BAR_PREV,              CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_CURSOR_BAR_NEXT,              CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_CURSOR_HOME,                  CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_CURSOR_END,                   CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_CURSOR_TRACK_PREV,            CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_CURSOR_TRACK_NEXT,            CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_CURSOR_TRACK_DELTA,           CLASS_DELTA,  8);
      mmcAddTarget(MMT_CURSOR_TRACK_1,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_2,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_3,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_4,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_5,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_6,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_7,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_8,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_9,               CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_10,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_11,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_CURSOR_TRACK_12,              CLASS_BUTTON, SYN_BUTTON_SELECT);
      mmcAddTarget(MMT_PUNCH_IN,                     CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PUNCH_OUT,                    CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_LOOP_L,                       CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_LOOP_R,                       CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_LOOP_MOVE,                    CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_LOOP_1,                       CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_LOOP_2,                       CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_LOOP_4,                       CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_LOOP_8,                       CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_INSERT_BARS,                  CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_INSERT_BARS_TEMPO,            CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_DELETE_BARS,                  CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_DELETE_BARS_TEMPO,            CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_CLEAR_BARS,                   CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_OUTPUT_STATE_CLEAR,           CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_OUTPUT_STATE_PASTE,           CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_OR_PATTERN_LOOP_RANGE, CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_1,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_2,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_3,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_4,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_5,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_6,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_7,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_8,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_9,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_10,               CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_11,               CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_CLEAR_TRACK_12,               CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_CLONE,                CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_CLONE_SUB,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_COPY,                 CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PATTERN_PASTE,                CLASS_BUTTON, SYN_BUTTON_CLICK);
   }

   // <midi_mmc.png>
   public virtual mmcHandleEvent(MIDIMapEvent _ev) : boolean {

      if(!mmcIsBindableEvent(_ev))
         return false;

      MIDIMapEvent boundEv <= mmcGetBindingByEvent(_ev);

      NSQ_Pattern pat <= getEditPattern();

      if(null != boundEv)
      {
         String tgtName <= boundEv.bound_target.target_name;

         switch(tgtName)
         {
            default:
               return root_form.pg_node.mmcHandleNodeTarget(boundEv.bound_target.target_name);

            case MMT_UNDO:
               undo();
               return true;

            case MMT_REDO:
               redo();
               return true;

            case MMT_TOGGLE_PRECOUNT:
               togglePreCount();
               return true;

            case MMT_START_STOP_REPLAY:
               toggleReplayEx(true/*bAllowBookmark*/,
                              false/*bSendMMC*/
                              );
               return true;

            case MMT_START_STOP_REPLAY_MMC:
               toggleReplayEx(true/*bAllowBookmark*/,
                              true/*bSendMMC*/
                              );
               return true;

            case MMT_START_STOP_RECORD:
               startOrStopRecording(false/*bMMC*/);
               return true;

            case MMT_START_STOP_RECORD_MMC:
               startOrStopRecording(true/*bMMC*/);
               return true;

            case MMT_QUEUE_RECORD_RESTART:
               arr.tryQueueRecordRestart();
               return true;

            case MMT_FORCE_STEP_RECORD:
               if(_ev.class_type_ext)
                  stepRecBegin();
               else
                  stepRecEnd();
               return true;

            case MMT_TOGGLE_STEP_RECORD:
               stepRecToggle();
               return true;

            case MMT_TOGGLE_ARM_NODE:
               toggleRec();
               return true;

            case MMT_TOGGLE_ARM_TRACK:
               toggleRecordTrackByIdx(seq.cursor_y);
               return true;

            case MMT_TOGGLE_FOCUS_TRACK:
               toggleFocusTrackByIdx(seq.cursor_y);
               return true;

            case MMT_TOGGLE_MUTE_TRACK:
               toggleMuteTrackByIdx(seq.cursor_y);
               return true;

            case MMT_TOGGLE_SOLO_TRACK:
               toggleSoloTrackByIdx(seq.cursor_y);
               return true;

            case MMT_CURSOR_SELECT_MOD:
               b_mmt_select_mod = (0 != _ev.class_type_ext);
               return true;

            case MMT_CURSOR_BAR_PREV:
               arr.moveCursorLeft(b_mmt_select_mod);
               return true;

            case MMT_CURSOR_BAR_NEXT:
               arr.moveCursorRight(b_mmt_select_mod);
               return true;

            case MMT_CURSOR_HOME:
               arr.moveCursorHome(b_mmt_select_mod);
               return true;

            case MMT_CURSOR_END:
               arr.moveCursorEnd(b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_PREV:
               arr.moveCursorUp(b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_NEXT:
               arr.moveCursorDown(b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_DELTA:
               arr.moveCursorDelta(_ev.getDeltaValue(), b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_1:
               arr.moveCursorToTrack(0, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_2:
               arr.moveCursorToTrack(1, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_3:
               arr.moveCursorToTrack(2, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_4:
               arr.moveCursorToTrack(3, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_5:
               arr.moveCursorToTrack(4, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_6:
               arr.moveCursorToTrack(5, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_7:
               arr.moveCursorToTrack(6, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_8:
               arr.moveCursorToTrack(7, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_9:
               arr.moveCursorToTrack(8, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_10:
               arr.moveCursorToTrack(9, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_11:
               arr.moveCursorToTrack(10, b_mmt_select_mod);
               return true;

            case MMT_CURSOR_TRACK_12:
               arr.moveCursorToTrack(11, b_mmt_select_mod);
               return true;

            case MMT_PUNCH_IN:
               arr.setPunchInToCursor();
               return true;

            case MMT_PUNCH_OUT:
               arr.setPunchOutToCursor();
               return true;

            case MMT_LOOP_L:
               arr.setLeftLoopLocatorToCursor();
               return true;

            case MMT_LOOP_R:
               arr.setRightLoopLocatorToCursor();
               return true;

            case MMT_LOOP_MOVE:
               arr.moveLoopToCursor();
               return true;

            case MMT_LOOP_SELECTION:
               arr.loopSelection();
               return true;

            case MMT_LOOP_1:
               arr.loopBars(1);
               return true;

            case MMT_LOOP_2:
               arr.loopBars(2);
               return true;

            case MMT_LOOP_4:
               arr.loopBars(4);
               return true;

            case MMT_LOOP_8:
               arr.loopBars(8);
               return true;

            case MMT_INSERT_BARS:
               arr.handleInsertBars(false/*bTempo*/);
               return true;

            case MMT_INSERT_BARS_TEMPO:
               arr.handleInsertBars(true/*bTempo*/);
               return true;

            case MMT_DELETE_BARS:
               arr.handleDeleteSelection(false/*bTempo*/);
               return true;

            case MMT_DELETE_BARS_TEMPO:
               arr.handleDeleteSelection(true/*bTempo*/);
               return true;

            case MMT_CLEAR_BARS:
               arr.handleClearSelection(true/*bUndoBegin*/);
               return true;

            case MMT_OUTPUT_STATE_CLEAR:
               handleClearOutputStates();
               return true;

            case MMT_OUTPUT_STATE_PASTE:
               handleCopyOutputStates();
               return true;

            case MMT_CLEAR_TRACK_OR_PATTERN_LOOP_RANGE:
               arr.handleFastClearTrackOrPatternLoopRange(seq.cursor_y, true/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_1:
               arr.handleFastClearTrackOrPatternLoopRange(0, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_2:
               arr.handleFastClearTrackOrPatternLoopRange(1, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_3:
               arr.handleFastClearTrackOrPatternLoopRange(2, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_4:
               arr.handleFastClearTrackOrPatternLoopRange(3, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_5:
               arr.handleFastClearTrackOrPatternLoopRange(4, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_6:
               arr.handleFastClearTrackOrPatternLoopRange(5, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_7:
               arr.handleFastClearTrackOrPatternLoopRange(6, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_8:
               arr.handleFastClearTrackOrPatternLoopRange(7, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_9:
               arr.handleFastClearTrackOrPatternLoopRange(8, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_10:
               arr.handleFastClearTrackOrPatternLoopRange(9, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_11:
               arr.handleFastClearTrackOrPatternLoopRange(10, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_CLEAR_TRACK_12:
               arr.handleFastClearTrackOrPatternLoopRange(11, false/*bAllowLazyClearPattern*/);
               return true;

            case MMT_PATTERN_CLONE:
               handlePatternClone(false/*bSub*/);
               return true;

            case MMT_PATTERN_CLONE_SUB:
               handlePatternClone(true/*bSub*/);
               return true;

            case MMT_PATTERN_COPY:
               handlePatternCopy();
               return true;

            case MMT_PATTERN_PASTE:
               handlePatternPaste();
               return true;
         }
      }

      // trace "xxx NodeSeqEditor::mmcHandleEvent: unhandled";
      return false;
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray layers) {
      DeviceIOForm *ioForm;
      NSQ_TrackForm *tf;

      switch(ts_groups.getActiveTabIndex())
      {
         case TAB_PORTS:
            layers.joinRR(layers,
                          [
                             ts_groups,
                             tf_pat_name2,
                           ]
                          );

            foreach ioForm in io_forms
            {
               ioForm.addTabCycleOverrides(layers);
            }

            layers.joinRR(layers,
                          [
                             bt_ports_clear,
                             bt_ports_def,
                             bt_ports_nr
                           ]
                          );
            return layers;


         case TAB_PATTERN:
            layers.joinRR(layers,
                          [
                             ts_groups,
                             tf_pat_name2,

                             cm_pattern_nr,
                             tf_pat_name,
                             bt_pat_alloc,
                             bt_pat_tools,
                             bt_pat_free
                           ]
                          );
            return layers;

         case TAB_SEQUENCE:
            layers.joinRR(layers,
                          [
                             ts_groups,
                             tf_pat_name2,
                           ]
                          );

            foreach tf in track_forms
            {
               tf.addTabCycleOverrides(layers);
            }

            layers.add(arr);

            if(isTempoViewVisible())
               layers.add(tempo);
            else
               layers.add(evt);

            layers.joinRR(layers,
                          [
                             cb_seq_rec,
                             cb_seq_rec_bg,
                             cb_seq_rec_prev,
                             cb_seq_master,

                             cb_rec_replace,
                             cb_seq_metro,
                             cb_seq_pre,
                             cb_seq_autoscroll,

                             cb_fast_clear,
                             cb_tempo_snap,
                             cb_step,
                             cb_seq_autorf,

                             cm_seq_q,
                             fp_sig_beats,
                             fp_sig_notelen,
                             fp_visbars,
                             ]
                          );

            return layers;

         case TAB_PLAY:
            layers.joinRR(layers,
                          [
                             ts_groups,

                             cm_node_class,
                             cb_node_class_show,
                             cm_node_class_show_in,
                           ]
                          );
            f_autodev.addTabCycleOverrides(layers);
            return layers;
      }
   }

   // <ui_show.png>
   public virtual showNode(Node _node) {
      seq <= _node;

      updatePatternNrComboBox();
      cm_pattern_nr.setSelectedOption(seq.nodeGetCurrentEditPatternNr());

      StringArray devAll;
      devAll.join(["*"], MIDI.out_device_names_sorted);
      IntArray bgcolorsAll;
      bgcolorsAll.join([0], MIDI.out_device_bgcolors_sorted);

      f_autodev.showNode(seq, devAll, bgcolorsAll);

      boolean bEditable = (null != seq);

      cb_seq_rec       .setEditable(bEditable);
      cb_seq_rec_bg    .setEditable(bEditable);
      cb_seq_rec_prev  .setEditable(bEditable);
      cb_seq_master    .setEditable(bEditable);

      cb_rec_replace   .setEditable(bEditable);
      cb_seq_pre       .setEditable(bEditable);
      cb_seq_autoscroll.setEditable(bEditable);

      cb_fast_clear    .setEditable(bEditable);
      cb_tempo_snap    .setEditable(bEditable);
      cb_step          .setEditable(bEditable);
      cb_seq_autorf    .setEditable(bEditable);

      cm_seq_q         .setEditable(bEditable);

      if(bEditable)
      {
         cb_seq_rec       .setSelected(seq.b_rec);
         cb_seq_rec_bg    .setSelected(seq.b_rec_bg);
         cb_seq_rec_prev  .setSelected(seq.b_rec_prev);
         cb_seq_master    .setSelected(seq.b_master);

         cb_rec_replace   .setSelected(seq.b_rec_replace);
         cb_seq_pre       .setSelected(seq.b_pre);
         cb_seq_autoscroll.setSelected(seq.b_autoscroll);

         cb_fast_clear    .setSelected(seq.ui_b_fast_clear);
         cb_tempo_snap    .setSelected(seq.ui_b_tempo_snap_to_frame);
         cb_step          .setSelected(seq.b_step_rec);
         cb_seq_autorf    .setSelected(seq.ui_b_auto_rec_focus);

         cm_seq_q         .setSelectedOption(seq.q_mode);

         seq.force_mute_temp_track_mask = 0;  // after Tracker temp edit
      }
      else
      {
         cb_seq_rec       .setSelected(false);
         cb_seq_rec_bg    .setSelected(false);
         cb_seq_rec_prev  .setSelected(false);
         cb_seq_master    .setSelected(false);

         cb_rec_replace   .setSelected(false);
         cb_seq_pre       .setSelected(false);
         cb_seq_autoscroll.setSelected(false);

         cb_fast_clear    .setSelected(false);
         cb_tempo_snap    .setSelected(false);
         cb_step          .setSelected(false);
         cb_seq_autorf    .setSelected(false);

         cm_seq_q         .setSelectedOption(-1);
      }

      cb_seq_metro     .setSelected(STConfig.b_midi_metronome);

      showPorts();

      arr.  showNode(seq);
      tempo.showNode(seq);
      evt.  showNode(seq);

      // Play:
      cm_node_class.setOptions(STConfig.node_class_names);
      updateNodeClass();
      updateNodeClassShowIn(seq);

      MIDI.AddMIDIMapEventListener(this);

      b_mmt_select_mod = false;

      if(!NodeEditor.b_lock_kbdfocus)
      {
         refocusDefault();
      }
   }

   // <method.png>
   public virtual showNodePost() {
      Global.Debug("NodeSeqEditor::showNodePost");

      handlePatternChanged();

      // (todo) proper-fix HOME/END handling (MMTHandleLayerInc()) when node is first shown
      int tabIdx = 0;
      loop(NUM_TABS)
         ts_groups.setActiveTabIndex(tabIdx++);

      ts_groups.setActiveTabIndex(TAB_SEQUENCE); // layout fix (/workaround)

      if(UI.b_fbo)
      {
         root_form.addOverlay(arr);
         if(isTempoViewVisible())
            root_form.addOverlay(tempo);
         else
            root_form.addOverlay(evt);
      }

      refocusDefault();
      handleViewEnter();

      ta_checkredraw.reschedule();
   }

   // <method.png>
   public method undoBegin() {
      undoEndMini();
      seq.undoAdd();
   }

   // <method.png>
   public method undoEnd() : boolean {
      ta_miniundo.cancel();
      return seq.undoEnd();
   }

   // <method.png>
   public method undoBeginMini() : boolean {
      if(!ta_miniundo.isScheduled())
      {
         seq.undoAddMini();
         ta_miniundo.reschedule();
         return true;
      }
      return false;
   }

   // <method.png>
   public method undoEndMini() : boolean {
      if(ta_miniundo.isScheduled())
      {
         ta_miniundo.cancel();
         return seq.undoEnd();
      }
      return false;
   }

   // <ui_hide.png>
   public virtual leaveNode() {

      replay.setPatternNode(null);

      if(null != seq)
      {
         seq.setEnableStepRec(false);
      }

      ta_checkredraw.cancel();

      undoEndMini();

      MIDI.RemoveMIDIMapEventListener(this);
      stopAllMIDILearnExcept(null);

      if(UI.b_fbo)
      {
         root_form.removeOverlay(tempo);
         root_form.removeOverlay(evt);
         root_form.removeOverlay(arr);
      }
   }

   // <ui_handle.png>
   protected method handleViewEnter() {

      if(UI.b_fbo)
      {
         root_form.removeOverlay(tempo);
         root_form.removeOverlay(evt);
         root_form.removeOverlay(arr);
      }

      if(TAB_SEQUENCE == ts_groups.getActiveTabIndex())
      {
         if(UI.b_fbo)
         {
            root_form.addOverlay(arr);
            if(isTempoViewVisible())
               root_form.addOverlay(tempo);
            else
               root_form.addOverlay(evt);
         }

         redrawSeq();
      }
   }

   // // <ui_handle.png>
   // protected method handleViewLeave() {
   //    if(TAB_SEQUENCE == ts_groups.getActiveTabIndex())
   //    {
   //       if(UI.b_fbo)
   //       {
   //          root_form.removeOverlay(arr);
   //       }
   //    }
   // }

   // <ui_show.png>
   protected method showPorts() {
      int trackIdx = 0;
      loop(NodeSeq.NUM_TRACKS)
      {
         updatePortNameByIdx(trackIdx++);
      }
   }

   // <ui_show.png>
   public method updatePortNameByIdx(int _trackIdx) {
      DeviceIOForm ioForm <= io_forms.get(_trackIdx);
      DeviceIOPort op <= (null != seq) ? (seq.out_ports.get(_trackIdx)) : null;
      ioForm.showPort(op);
   }

   // <ui_focus.png>
   public virtual refocusDefault() {
      if(!NodeEditor.b_lock_kbdfocus)
      {
         // trace "xxx NodeSeqEditor::refocusDefault: ts_groups.getActiveTabIndex()="+ts_groups.getActiveTabIndex();
         switch(ts_groups.getActiveTabIndex())
         {
            case TAB_PORTS:
               UI.SetKeyboardFocus(ts_groups);
               break;

            case TAB_PATTERN:
               UI.SetKeyboardFocus(ts_groups);
               break;

            case TAB_SEQUENCE:
               // UI.SetKeyboardFocus(ts_groups);
               UI.SetKeyboardFocus(arr);
               break;

            case TAB_PLAY:
               UI.SetKeyboardFocus(ts_groups);
               break;
         }

      }
   }

   // <ui_focus.png>
   public method refocusArr() {
      UI.SetKeyboardFocus(arr);
   }

   // <ui_update.png>
   protected method updatePatternNrComboBox() {
      local StringArray patNrOptionsShort;
      local StringArray patNrOptionsLong;
      local IntArray patNrColors;
      Node.CalcPatNrOptions(seq, patNrOptionsShort, patNrOptionsLong, patNrColors);
      cm_pattern_nr.setOptions(patNrOptionsShort);
      cm_pattern_nr.setOptionsLong(patNrOptionsLong);
      cm_pattern_nr.setOptionBGColors(patNrColors);
   }

   // <method_get.png>
   public method getEditPattern() : NSQ_Pattern {
      NSQ_Pattern pat <= seq.nodeGetCurrentEditPattern();
      return pat;
   }

   // <method_get.png>
   public method getEditTrack() : NSQ_Track {
      NSQ_Pattern pat <= seq.nodeGetCurrentEditPattern();
      if(null != pat)
      {
         return pat.getCursorTrack();
      }
      return null;
   }

   // <method.png>
   protected method stopAllMIDILearnExcept(DeviceIOForm _cur) {
      DeviceIOForm *ioForm;
      foreach ioForm in io_forms
      {
         if(@(_cur) != @(ioForm))
            ioForm.setLearnMode(DeviceIOForm.LEARN_NONE, true/*bQuiet*/);
      }
   }

   // <ui_hide.png>
   public virtual isNodeEditorLocked() : boolean {
      return false;
   }

   // <ui_hide.png>
   public virtual unsetNode() {
      seq <= null;
   }

   // <midi_mmt.png>
   public virtual mmtHandleGlobalValue(float _val) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();

      return false;
   }

   // <midi_mmt.png>
   public virtual mmtHandleGlobalValueDelta(int _delta) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();

      return false;
   }

   // <midi_mml.png>
   public virtual mmlHandleEventUI(MIDIMapEvent _ev) : boolean {

      if(_ev.isReservedEvent())
         return false;

      MIDIMapEvent evXForm = _ev;
      MIDIMorphScene.TransformEvent(evXForm);
      if(evXForm.isValid())
      {
         evXForm.echoTransformForced();

         if(STConfig.b_show_ctl_info)
         {
            if(STConfig.b_show_ctl_info_hifreq || !evXForm.isHiFreqEvent())
            {
               Global.PrintFast(evXForm.getInfoStringForPipeMap());
            }
         }

         DeviceIOForm *ioForm;
         foreach ioForm in io_forms
         {
            if(ioForm.mmlHandleEventUI(evXForm))
               return true;
         }
      }

      return false;
   }

   // <ui_handle.png>
   public virtual nodeHandleEditPatternChanged() {
      handlePatternChanged();
   }

   // <ui_handle.png>
   protected method handlePatternChanged() {
      NSQ_Pattern pat <= getEditPattern();

      updatePatNrLabel();

      boolean bEditable = (null != pat);

      tf_pat_name .setEditable(bEditable);
      tf_pat_name2.setEditable(bEditable);
      bt_pat_free .setEditable(bEditable);

      fp_sig_beats     .setEditable(bEditable);
      fp_sig_notelen   .setEditable(bEditable);

      if(bEditable)
      {
         tf_pat_name .setText(pat.pat_name);
         tf_pat_name2.setText(pat.pat_name);

         fp_sig_beats     .setValue(pat.sig_beats);
         fp_sig_notelen   .setValue(pat.sig_notelen);

         if(!replay.b_playing)
         {
            seq.cur_loop_start_ticks = pat.loop_start_ticks;
            seq.cur_loop_len_ticks   = pat.loop_len_ticks;
         }
      }
      else
      {
         tf_pat_name .setText("");
         tf_pat_name2.setText("");

         fp_sig_beats     .setValue(1);
         fp_sig_notelen   .setValue(1);
      }

      fp_visbars.setValue(seq.ui_num_visible_bars);

      updateTrackForms(pat);
      updateMuteSoloStates();
      updateFocusStates();
      updateRecIcons();

      redrawSeq();

      root_form.pg_node.handleEditPatternChanged();
   }

   // <ui_update.png>
   public method updateTrackForms(NSQ_Pattern pat) {
      int trackIdx = 0;
      loop(NodeSeq.NUM_TRACKS)
      {
         NSQ_TrackForm tf <= track_forms.get(trackIdx);
         if(null != pat)
         {
            NSQ_Track track <= pat.tracks.get(trackIdx);
            tf.showTrack(seq, track);
         }
         else
         {
            tf.showTrack(seq, null);
         }
         trackIdx++;
      }
   }

   // <ui_update.png>
   public method updateMuteSoloStates() {
      NSQ_TrackForm *tf;
      foreach tf in track_forms
      {
         tf.updateMuteSoloState();
      }
   }

   // <ui_update.png>
   public method updateFocusStates() {
      NSQ_TrackForm *tf;
      foreach tf in track_forms
      {
         tf.updateFocusState();
      }
   }

   // <ui_update.png>
   public method updateRecIcons() {
      NSQ_TrackForm *tf;
      foreach tf in track_forms
      {
         tf.updateRecIcon();
      }
   }

   // <ui_update.png>
   public method updateRecStatesAndIcons() {
      NSQ_TrackForm *tf;
      foreach tf in track_forms
      {
         tf.updateRecStateAndIcon();
      }
   }

   // <ui_update.png>
   public method updateTrackNames() {
      NSQ_TrackForm *tf;
      foreach tf in track_forms
      {
         tf.updateTrackName();
      }
   }

   // <method.png>
   public method autoRecFocus(boolean _bFromFocus, int _preferTrackIdx) {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         // Global.Debug("autoRecFocus: bFromFocus="+_bFromFocus+" preferTrackIdx="+_preferTrackIdx);
         NSQ_Track *track;
         int trackIdx = 0;
         foreach track in pat.tracks
         {
            if(_bFromFocus)
            {
               // Auto-arm focus track
               if(trackIdx == seq.input_focus_idx)
                  track.setEnableRec(true);
               else
                  track.setEnableRec(false);
            }
            else
            {
               // Auto-focus rec-enabled track
               if((track.b_rec && (-1 == _preferTrackIdx)) || (track.track_idx == _preferTrackIdx))
               {
                  seq.input_focus_idx = trackIdx;
               }
               else
               {
                  track.setEnableRec(false);
               }
            }
            trackIdx++;
         }
         updateFocusStates();
         updateRecStatesAndIcons();
      }
   }

   // <method.png>
   public method toggleMuteTrackByIdx(int _trackIdx) {
      NSQ_TrackForm tf <= track_forms.get(_trackIdx);
      tf.handleToggleMute();
   }

   // <method.png>
   public method toggleSoloTrackByIdx(int _trackIdx) {
      NSQ_TrackForm tf <= track_forms.get(_trackIdx);
      tf.handleToggleSolo();
   }

   // <method.png>
   public method toggleFocusTrackByIdx(int _trackIdx) {
      NSQ_TrackForm tf <= track_forms.get(_trackIdx);
      tf.handleToggleFocus();
      if(seq.ui_b_auto_rec_focus)
         autoRecFocus(true/*bFromFocus*/, _trackIdx);
   }

   // <method.png>
   public method toggleRecordTrackByIdx(int _trackIdx) {
      NSQ_TrackForm tf <= track_forms.get(_trackIdx);
      tf.handleToggleRec();
      if(seq.ui_b_auto_rec_focus)
         autoRecFocus(false/*bFromFocus*/, _trackIdx);
   }

   // <method.png>
   public method focusTrackQAmountByIdx(int _trackIdx) {
      NSQ_TrackForm tf <= track_forms.get(_trackIdx);
      FloatParam fp <= tf.fp_quant_amount;
      UI.SetKeyboardFocus(fp);
      // fp.onTabFocus();
      fp.selectNone();
      fp.moveCursorEnd();
      fp.expandSelectionToHome();  // left-align selection (otherwise % char has prio over numbers)
      fp.moveCursorHome();
   }

   // <ui_update.png>
   protected method updatePatNrLabel() {
      Integer io = seq.nodeGetCurrentEditPatternNr();
      lb_pat_nr.setCaption("Pattern:\n  ("+io.printf("0x%02x")+")");
      lb_pat_nr.redraw();
   }

   // <ui_handle.png>
   protected method handleClearPortNames() {
      seq.clearPortNames();
      showPorts();
      updateTrackNames();
      Global.Print("Clear output port names");
   }

   // <ui_handle.png>
   protected method handleLoadDefaultPortNames() {
      seq.loadDefaultPortNames();
      showPorts();
      updateTrackNames();
      Global.Print("Load default output port names");
   }

   // <ui_handle.png>
   protected method handleLoadNrPortNames() {
      seq.loadNrPortNames();
      showPorts();
      updateTrackNames();
      Global.Print("Load enumerated output port names");
   }

   // <ui_handle.png>
   protected method handlePatternAlloc(boolean _bSub) : NSQ_Pattern {
      local NSQ_Pattern p;

      p.patInit(seq, 0/*patNr placeholder*/);

      int patIdx;

      NSQ_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         if(true == _bSub)
         {
            // Find unused A..D sub pattern
            patIdx = seq.nodeFindFirstUnusedPatternSub(seq.nodeGetCurrentEditPatternNr());
         }
         else
         {
            // Find unused 1..32 pattern group
            patIdx = seq.nodeFindFirstUnusedPatternGroup(seq.nodeGetCurrentEditPatternNr());
         }

         if(-1 == patIdx)
         {
            patIdx = seq.findFirstUnusedPattern(0);
         }
      }
      else
      {
         patIdx = seq.nodeGetCurrentEditPatternNr();
      }

      if(-1 != patIdx)
      {
         p.pat_nr = patIdx;
         seq.nodeSetPattern(patIdx, deref p);

         seq.nodeSetCurrentEditPatternNr(patIdx);
         seq.nodeSetCurrentPlayPatternNr(patIdx);

         cm_pattern_nr.setSelectedOption(patIdx);

         selectPatternByIdx(patIdx);

         handlePatternChanged();

         updatePatternNrComboBox();

         Global.SuccessShort("New: Allocated pattern "+cm_pattern_nr.getSelectedOptionName()+" ("+(patIdx+1)+").");
         return p;
      }
      else
      {
         Global.Error("New: All patterns in use.");
         return null;
      }
   }

   // <ui_show.png>
   protected method showPatternToolsMenu(boolean _bFocusFirst) {

      pm_pat_tools <= PopupMenu.New(this);
      PopupMenu pm <= pm_pat_tools;
      PopupMenuButton *pmb;

      NSQ_Pattern pat <= seq.nodeGetCurrentEditPattern();
      boolean bHavePat = (null != pat);

      pmb <= pm.addDefaultButton("Copy pattern", "copy");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lctrl-c", "");

      pmb <= pm.addDefaultButton("Paste pattern", "paste");
      pmb.setFontByName("big6");
      pmb.setAccelerators("lctrl-v", "");

      if(bHavePat)
      {
         pmb.setActive(null != pat.patGetClipboard());
      }
      else
      {
         pmb.setActive(false);
      }

      pmb <= pm.addDefaultButton("Clone pattern", "clone");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lctrl-r", "");

      pmb <= pm.addDefaultButton("Clone pattern (sub)", "clone_sub");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lshift-lctrl-r", "");

      pmb <= pm.addDefaultButton("New pattern (sub)", "new_sub");
      pmb.setFontByName("big6");
      pmb.setAccelerators("lshift-lctrl-n", "");

      // pm.addSeparator();

      pm.resizeToMinimum();
      pm.showAboveLayer(bt_pat_tools);
      if(_bFocusFirst)
         pm.focusNextMenuItem();

      Global.Print("Show pattern tools menu.");
   }

   // <ui_handle.png>
   protected method handlePatternCopy() {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         pat.patCopyToClipboard();

         Global.Print("Pattern copied to clipboard.");
      }
   }

   // <ui_handle.png>
   protected method handlePatternPaste() {
      NSQ_Pattern pat <= getEditPattern();

      int curTickNr = seq.nodeGetLastPatternStartSongOffset() + seq.tick_nr;

      undoBegin();

      if(null == pat)
      {
         handlePatternNew(false/*bSub*/);
         pat <= getEditPattern();
      }

      if(null != pat)
      {
         if(pat.patCopyFromClipboard())
         {
            handlePatternChanged();

            updatePatternNrComboBox();

            seq.queueLoop(pat.loop_start_ticks, pat.loop_len_ticks);
            seq.forceQueuedLoop();
            int newTickNr = pat.loop_start_ticks + ((curTickNr-pat.loop_start_ticks) % pat.loop_len_ticks);
            // // trace "xxx newTickNr="+newTickNr;
            seq.nodeSeek(mathMaxi(0, newTickNr));

            Global.SuccessShort("Clipboard pasted to pattern.");
         }
      }

      undoEnd();
   }

   // <ui_handle.png>
   protected =replay= method handlePatternNew(boolean _bSub) {

      undoBegin();

      NSQ_Pattern pat <= handlePatternAlloc(_bSub);

      undoEnd();
   }

   // <ui_handle.png>
   protected =replay= method handlePatternClone(boolean _bSub) {
      NSQ_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         int curTickNr = seq.nodeGetLastPatternStartSongOffset() + seq.tick_nr;
         // trace "xxx curTickNr="+curTickNr+" (rel="+seq.tick_nr+") new_loop_start="+pat.loop_start_ticks+" len="+pat.loop_len_ticks;

         undoBegin();

         local NSQ_Pattern tmp;

         tmp.patInit(seq, 0);

         tmp.patCopyFrom(pat, false/*bClear*/);

         if(null != handlePatternAlloc(_bSub))
         {
            pat <= getEditPattern();

            pat.patCopyFrom(tmp, false/*bClear*/);
            pat.patHandleSongSpeedChanged(true/*bPPQ*/, true/*bBPM*/);

            handlePatternChanged();

            seq.queueLoop(pat.loop_start_ticks, pat.loop_len_ticks);
            seq.forceQueuedLoop();
            int newTickNr = pat.loop_start_ticks + ((curTickNr-pat.loop_start_ticks) % pat.loop_len_ticks);
            seq.nodeSeek(mathMaxi(0, newTickNr));

            Global.SuccessShort("Pattern cloned to "+cm_pattern_nr.getSelectedOptionName()+".");
         }

         undoEnd();
      }
   }

   // <ui_handle.png>
   protected method handlePatternFree() {

      NSQ_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         undoBegin();

         seq.nodeSetPattern(seq.edit_pattern_nr, null);

         pat <= null;

         undoEnd();

         handlePatternChanged();

         updatePatternNrComboBox();

         Global.Print("Delete pattern");
      }
   }

   // <ui_handle.png>
   protected method handleSelectPattern() {

      int patNr = cm_pattern_nr.getSelectedOption();

      seq.nodeSetCurrentEditPatternNr(patNr);
      seq.nodeSetCurrentPlayPatternNr(patNr);

      seq.nodeQueuePrgChgOut(patNr);
      // // replay.handleNodeStateChangedUI(node, -1/*active*/, patNr/*pat*/);

      handlePatternChanged();

      NSQ_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         Global.Print("Select pattern "+cm_pattern_nr.getSelectedOptionName()+" \""+pat.pat_name+"\".");
      }
      else
      {
         Global.Print("Select pattern "+cm_pattern_nr.getSelectedOptionName()+" <empty>.");
      }
   }

   // <method.png>
   public virtual selectPatternByIdx(int _idx) {

      cm_pattern_nr.setSelectedOption(_idx);

      handleSelectPattern();
   }

   // <ui_handle.png>
   protected method handleSelectPreviousUsedPattern() {
      int patIdx = seq.nodeGetCurrentEditPatternNr();
      patIdx = seq.nodeFindPreviousPatternNrByUsedIdxWithOffset(patIdx-1, 0);

      if(patIdx >= 0)
      {
         selectPatternByIdx(patIdx);
      }
   }

   // <ui_handle.png>
   protected method handleSelectNextUsedPattern() {
      int patIdx = seq.nodeGetCurrentEditPatternNr();
      patIdx = seq.nodeFindNextPatternNrByUsedIdxWithOffset(patIdx+1, 0);

      if(patIdx >= 0)
      {
         selectPatternByIdx(patIdx);
      }
   }

   // <method.png>
   public virtual selectPatternByUsedIdx(int _idx) {
      if(_idx >= 0)
      {
         int patNr = seq.nodeGetPatternNrByUsedIdx(_idx);

         if(-1 != patNr)
         {
            selectPatternByIdx(patNr);
         }
      }
      else
      {
         selectPatternByIdx(127); // --/
      }
   }

   // <method.png>
   protected method playPatternByIdx(int _idx) {

      selectPatternByIdx(_idx);

      NSQ_Pattern pat <= getEditPattern();

      seq.nodeSetCurrentPlayPatternNr(_idx);

      Global.Print("Play pattern "+cm_pattern_nr.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handlePatternNameChanged() {
      NSQ_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.pat_name = tf_pat_name.getText();
         tf_pat_name2.setText(pat.pat_name);

         Global.Print("Pattern name is \""+pat.pat_name+"\".");
      }
   }

   // <ui_handle.png>
   protected method handlePatternName2Changed() {
      NSQ_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.pat_name = tf_pat_name2.getText();
         tf_pat_name.setText(pat.pat_name);

         Global.Print("Pattern name is \""+pat.pat_name+"\".");
      }
   }

   // <method.png>
   public =replay= method exportSelectionToMonitorClipboard(ST_Song _song,
                                                            boolean _bQuiet,
                                                            boolean _bTickTimebase,
                                                            boolean _bIgnorePlayState,
                                                            boolean _bTrackerImportRPN,
                                                            boolean _bOutputCapture
                                                            ) : NM_Pattern {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         if(!replay.b_playing)
         {
            int startX;
            int startY;
            int endX;
            int endY;

            if(arr.haveSelection())
            {
               startX = seq.sorted_sel_start_x;
               endX   = seq.sorted_sel_end_x;
               startY = seq.sorted_sel_start_y;
               endY   = seq.sorted_sel_end_y;
            }
            else
            {
               startX = seq.cursor_x;
               startY = seq.cursor_y;
               endX   = seq.cursor_x;
               endY   = seq.cursor_y;
            }

            int oldSongOffset = _song.song_offset;

            int ticksPerBar = pat.getNumTicksPerBar();
            int ticksStart = startX * ticksPerBar;
            int numTicks = (endX - startX + 1) * ticksPerBar;
            // Global.Debug("exportSelectionToMonitorClipboard: numTicks="+numTicks);

            _song.seek(seq.nodeGetLastPatternStartSongOffset() + ticksStart);

            local MIDIPipeFrame frInPlay;
            local MIDIPipeFrame frInRec;
            local MIDIPipeFrame frOut;
            local MIDIPipeFrame *fr;
            int tickIdx = 0;
            seq.b_export = true;

            int numEvents = 0;
            local NM_Pattern monPat;

            if(_bOutputCapture)
            {
               // Start output capture
               boolean bOrigTimebase = STConfig.b_node_monitor_capture_tick_timebase;
               STConfig.b_node_monitor_capture_tick_timebase = _bTickTimebase;
               mon_capture.captureBegin();
               STConfig.b_node_monitor_capture_tick_timebase = bOrigTimebase;

               monPat <= mon_capture.nodeGetCurrentPlayPattern();
               // monPat.record_timestamp_offset = 0;
               // monPat.deleteAllFrames();

               // Create start frame (may remain empty, except for marker)
               local MIDIPipeFrame frEmpty;
               mon_capture.captureAdd(frEmpty, false/*bAdvance*/);
            }
            else
            {
               // Use monitor clipboard
               monPat.patFreeClipboard();
               monPat <= monPat.patGetOrCreateClipboard();
            }

            monPat.b_tick_timebase = _bTickTimebase;

            // Pattern length hint
            monPat.num_ticks_hint = (endX - startX + 1) * ticksPerBar;

            // Mute tracks outside of selection
            seq.node_mute_temp_track_mask = 0;
            int trackIdx = 0;
            while(trackIdx < startY)
            {
               seq.node_mute_temp_track_mask = seq.node_mute_temp_track_mask | (1 << trackIdx);
               trackIdx++;
            }
            trackIdx = endY + 1;
            while(trackIdx < NodeSeq.NUM_TRACKS)
            {
               seq.node_mute_temp_track_mask = seq.node_mute_temp_track_mask | (1 << trackIdx);
               trackIdx++;
            }

            // trace "xxx seq.node_mute_temp_track_mask="+seq.node_mute_temp_track_mask;

            float ticksToMilliSeconds = _song.ticksToMilliSeconds(1.0);

            // trace "xxx export start: seq.tick_nr="+seq.tick_nr;
            seq.b_ignore_play_state = _bIgnorePlayState;

            seq.rpn_com_speed_scl = 1.0;
            seq.rpn_com_speed_sync_rate = 0.0;
            seq.tick_frac = 0;

            loop(numTicks)
            {
               seq.nodeProcessFrame(frOut, frInRec, false/*bMuted*/, true/*bPlaySeq*/);

               if(_bTrackerImportRPN && (0 == tickIdx))
               {
                  // Insert dummy RPN event (RPN_IMPORT_DUMMY=16383) to force instrument creation in tracker node
                  //  (fixes "re-import tracker pattern after importing empty sequence" issue)
                  trackIdx = 0;
                  loop(NodeSeq.NUM_TRACKS)
                  {
                     if(0 == (seq.node_mute_temp_track_mask & (1 << trackIdx)))
                     {
                        DeviceIOPort port <= seq.out_ports.get(trackIdx);
                        frOut.rpn(true/*bSet*/, port.dev_idx, mathMaxi(0, port.dev_ch), Node.RPN_IMPORT_DUMMY/*16383*/, 0);
                     }
                     trackIdx++;
                  }
               }

               if(frOut.hasEvents())
               {
                  Global.Debug3("export_seq_to_mon: frame["+monPat.getNumFrames()+"] has "+frOut.numEvents+" event(s)");

                  if(_bOutputCapture)
                  {
                     mon_capture.captureSeek(tickIdx);
                     mon_capture.captureAdd(frOut, false/*bAdvance*/);
                  }
                  else
                  {
                     // Export to Monitor clipboard
                     // // // if(0 != tickIdx)
                     // // if(0 == tickIdx)
                     // // {
                     // //    fr <= monPat.addFrame();
                     // //    fr.timeStamp = 0;
                     // // }
                     // // else
                        fr <= monPat.addFrame();
                     if(null != fr)
                     {
                        fr = frOut;
                        if(_bTickTimebase)
                           fr.timeStamp = tickIdx;
                        else
                           fr.timeStamp = tickIdx * ticksToMilliSeconds;
                     }
                     // else: max num frames exceeded
                  }

                  numEvents += frOut.numEvents;
                  frOut.empty();
               }

               // Next replay tick
               tickIdx++;
            }

            seq.b_ignore_play_state = false;

            if(_bOutputCapture)
               mon_capture.tick_nr = monPat.num_ticks_hint;

            if(!_bQuiet)
               Global.Print("Export "+monPat.getNumFrames()+" frame"+Utils.GetPluralString(monPat.getNumFrames())+" ("+numEvents+" event"+Utils.GetPluralString(numEvents)+") to "+(_bOutputCapture?"output capture" : "Monitor clipboard"));

            Global.Debug("exportSelectionToMonitorClipboard: ticksPerBar="+ticksPerBar+" ticksStart="+ticksStart+" numTicks="+numTicks+" numEvents="+numEvents);

            // Restore song offset
            _song.seek(oldSongOffset);
            seq.b_export = false;
            seq.node_mute_temp_track_mask = 0;

            return deref monPat;
         }
         else
         {
            if(!_bQuiet)
               Global.Warning("Export to Monitor Clipboard: please stop replay first");
         }
      }
      else
      {
         if(!_bQuiet)
            Global.Warning("Export to Monitor Clipboard: no pattern");
      }
      return null;
   }

   // <method.png>
   public =replay= method explode(boolean _bSubSong,
                                  boolean _bUniquePatterns,
                                  boolean _bArranger
                                  ) {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         int numTracksExplode = 0;
         int trackIdx;
         NSQ_Track *track;
         foreach track in pat.tracks
         {
            if(track.b_explode)
               numTracksExplode++;
         }

         if(numTracksExplode > 0)
         {
            MIDI.b_skip_rebuild_all_ctl_names = true;  // skip MIDI.RebuildAllCtlNames()  (takes some time)
            MIDI.LockUpdateOutDeviceNames();

            MIDIPipe *pipe;
            MIDIPipeNode *pipenode;
            MIDIPipeNodeScriptProxy *psp;
            NodeArranger      *arr;
            NodeTracker       *tracker;
            NodeTrackerEditor *trackerEditor;
            NodeTrigSeq       *trigseq;
            NodeTrigSeqEditor *trigseqEditor;
            PagePipeMap  pgPipeMap  <= root_form.pg_pipemap;
            PagePipeRoot pgPipeRoot <= root_form.pg_piperoot;
            PagePipe     pgPipe     <= root_form.pg_pipe;
            NewTrackDialog dlgNewTrack <= pgPipeMap.dlg_new_track;

            dlgNewTrack.prepareNewTrackDialog();  // category names, auto device names+ch

            int oldPPQ          = current_song.ppq;
            int oldBPM          = current_song.bpm;
            int oldSigBeats     = current_song.sig_beats;
            int oldSigNoteLen   = current_song.sig_notelen;
            ST_Song oldSong    <= current_song;
            String oldSongName <= oldSong.song_name;

            if(_bSubSong)
            {
               int subSongIdx = Global.NewSubSong();
               Global.SelectSubSongByIdx(subSongIdx, true/*bSaveUI*/, true/*bViaUI*/);

               current_song.sig_beats = oldSigBeats;
               current_song.sig_notelen = oldSigNoteLen;
               current_song.setPPQ(oldPPQ);
               current_song.setBPM(oldBPM);
               current_song.song_name = oldSongName;
               current_song.sub_name = "nsq explode "+Utils.GetCurrentDateTimeStringNumeric();

               // Create "master" pipe
               pgPipeRoot.selectPipeByIdx(0);
               pipe <= pgPipeRoot.handleAdd2("master", false/*bEdit*/, false/*bUpdatePipeMap*/);
               pgPipeRoot.selectPipeByIdx(pipe.pipeIdx);
            }

            // Create arranger node
            if(_bArranger)
            {
               pgPipeRoot.selectPipeByIdx(0);
               psp <= pgPipe.handleAdd3(NodeArranger/*newClazz*/, "main", false/*bEdit*/);
               arr <= psp.sci;
               trace "[>>>] NodeSeqEditor::explode: arr="+#(arr);
            }

            // Convert tracks to pipes+nodes
            STX_MIDIOutDevice *autoDev;
            byte autoChPref = 8;
            int barIdx;
            int numBars;
            IntArray *patBarStarts;
            local PointerArray barStartArrays;
            local IntArray nodeGIDs;
            // // local IntArray patIdxAdvArray;
            local PointerArray patIdxArrays;
            IntArray *patIndices;
            String *catName;
            int nodeGID;
            local NM_Pattern *patMon;

            trackIdx = 0;
            foreach track in pat.tracks
            {
               int numPatCreated = 0;
               if(track.b_explode)
               {
                  catName <= dlgNewTrack.track_categories.get(track.explode_node_cat);
                  if(null != catName)
                  {
                     autoDev   <= MIDI.GetMIDIOutDeviceByAliasOrName(dlgNewTrack.track_device_names.get(track.explode_node_cat));
                     autoChPref = dlgNewTrack.track_midi_channels.get(track.explode_node_cat);

                     if(null == autoDev)
                     {
                        trace "[---] explode: failed to resolve autoDev (catName=\""+catName+"\" catIdx="+track.explode_node_cat+")";
                     }

                     numBars = track.explode_bars_per_pattern;

                     // Find non-empty target patterns
                     patBarStarts <= new IntArray;
                     patBarStarts.empty();
                     barStartArrays.add(#(deref patBarStarts));

                     barIdx = 0;
                     while((barIdx + numBars) <= NSQ_Track.MAX_BARS)
                     {
                        seq.setSelection(barIdx, trackIdx, barIdx+numBars-1, trackIdx);
                        if(!pat.isSelectionEmpty())
                        {
                           patBarStarts.add(barIdx);
                        }
                        barIdx += numBars;
                     }

                     int numPat = patBarStarts.numElements;

                     if(numPat > Node.SCRATCH_PAT_NR)
                     {
                        trace "[~~~] explode: num target patterns ("+numPat+") exceeds 125, clipping..";
                        numPat = Node.SCRATCH_PAT_NR/*125*/;
                     }

                     int barStartIdx;
                     int patIdx;
                     int patIdxUnique;
                     int patIdxAdv = (numPat >= 64) ? 1/*A,B,C,D,..*/ : (numPat >= 32) ? 2/*A,C,..*/ : 4/*A,A,..*/;
                     boolean bPatAdv;
                     // // patIdxAdvArray.add(patIdxAdv);
                     patIndices <= new IntArray;
                     patIdxArrays.add(#(deref patIndices));

                     if(NSQ_Track.EXPLODE_TYPE_TRACKER == track.explode_node_type)
                     {
                        if(pgPipeMap.createNewTrack3(catName/*pipeName*/,
                                                     track.getPortName(),
                                                     null/*presetPathOrNull*/,
                                                     NodeTracker,
                                                     (null != autoDev)/*bAutoAssign*/,
                                                     autoDev,
                                                     autoChPref,
                                                     false/*bEdit*/
                                                     )
                           )
                        {
                           tracker <= pgPipe.getSelectedScriptNode();
                           trackerEditor <= tracker.nodeGetEditor();
                           Global.Debug2("explode: trackIdx="+trackIdx+" tracker="+#(tracker)+" editor="+#(trackerEditor));

                           nodeGIDs.add(tracker.getNodeGID());

                           tracker.b_rec_bg = true;

                           if(numPat > 0)
                           {
                              trackerEditor.showNodeQuiet(tracker);

                              // Import everything into one pattern to set up all tracks+cels+instruments
                              // (todo) optimize me
                              barIdx = patBarStarts.get(0);
                              seq.setSelection(barIdx, trackIdx, patBarStarts.last+numBars-1, trackIdx);
                              Global.Debug2("explode: trackIdx="+trackIdx+" allX=("+seq.sel_start_x+";"+seq.sel_end_x+")");
                              patMon <= exportSelectionToMonitorClipboard(oldSong,
                                                                          true/*bQuiet*/,
                                                                          true/*bTickTimebase*/,
                                                                          false/*bIgnorePlayState*/,
                                                                          true/*bTrackerImportRPN*/,
                                                                          false/*bOutputCapture*/
                                                                          );
                              trackerEditor.cmd_pattern_import_monitor_handle_ok(
                                 patMon,//NodePattern.PatGetClipboardForClass("NM_Pattern"),
                                 true/*bForceReInit*/,
                                 true/*bForceMulti*/,
                                 true/*bCreateInstrumentsAndParams*/,
                                 true/*bConvRPNPC*/,
                                 true/*bPreferCTLPC*/,
                                 false/*bCopyPatName*/,
                                 !patMon.hasPolyPressureEvents()/*bResetRec*/,
                                 false/*bAlignBars*/,
                                 true/*bExplode*/,
                                 false/*bUndo*/
                                                                                 );

                              trackerEditor.cmd_pattern_free_no_undo(true/*bFreeMeta*/);

                              // Import individual bars / patterns
                              patIdx = 0;
                              barStartIdx = 0;
                              loop(numPat)
                              {
                                 barIdx = patBarStarts.get(barStartIdx);
                                 seq.setSelection(barIdx, trackIdx, barIdx+numBars-1, trackIdx);
                                 Global.Debug2("explode: export trackIdx="+trackIdx+" barIdx="+barIdx+" #bars="+numBars);

                                 // Create Monitor clipboard
                                 patMon <= exportSelectionToMonitorClipboard(oldSong,
                                                                             true/*bQuiet*/,
                                                                             true/*bTickTimebase*/,
                                                                             false/*bIgnorePlayState*/,
                                                                             true/*_bTrackerImportRPN*/,
                                                                             false/*bOutputCapture*/
                                                                             );

                                 // Import Monitor clipboard
                                 tracker.nodeSetCurrentEditPatternNr(patIdx);
                                 trackerEditor.cmd_pattern_alloc(false/*bSub*/);
                                 trackerEditor.cmd_pattern_import_monitor_handle_ok(
                                    patMon,//NodePattern.PatGetClipboardForClass("NM_Pattern"),
                                    false/*bForceReInit*/,
                                    true/*bForceMulti*/,
                                    true/*bCreateInstrumentsAndParams*/,
                                    true/*bConvRPNPC*/,
                                    true/*bPreferCTLPC*/,
                                    false/*bCopyPatName*/,
                                    !patMon.hasPolyPressureEvents()/*bResetRec*/,
                                    false/*bAlignBars*/,
                                    true/*bExplode*/,
                                    false/*bUndo*/
                                                                                    );

                                 bPatAdv = true;

                                 if(_bUniquePatterns)
                                 {
                                    patIdxUnique = tracker.nodeFindPatternByEvents(tracker.nodeGetCurrentEditPattern());
                                    trace "[>>>] NodeSeqEditor::explode: patIdxUnique="+patIdxUnique+" patIdx="+patIdx;
                                    if(-1 != patIdxUnique)
                                    {
                                       if(patIdx != patIdxUnique)
                                       {
                                          // Re-Use previously added pattern
                                          trackerEditor.cmd_pattern_free_no_undo(true/*bFreeMeta*/);
                                          patIdx = patIdxUnique;
                                          bPatAdv = false;
                                          Global.Debug2("explode: trackIdx="+trackIdx+" barIdx="+barIdx+" re-use patIdx="+patIdx+" ("+(Node.patnr_options.get(patIdx))+")");
                                       }
                                    }
                                 }

                                 patIndices.add(patIdx);

                                 // Next pattern
                                 barStartIdx++;
                                 barIdx += numBars;
                                 if(bPatAdv)
                                 {
                                    patIdx += patIdxAdv;
                                    numPatCreated++;
                                 }
                              }

                              tracker.nodeSetCurrentEditPatternNr(0);

                           } // if numPat > 0

                           Global.Debug("explode: trackIdx="+trackIdx+" type=Tracker numPatCreated="+numPatCreated);

                           trackerEditor.cancelAllTimers();

                           tracker.b_rec_bg = false;
                        }
                        else
                        {
                           trace "[---] explode: failed to create Tracker node (trackIdx="+trackIdx+")";
                           nodeGIDs.add(-1);
                        }
                     } // /EXPLODE_TYPE_TRACKER
                     else if(NSQ_Track.EXPLODE_TYPE_TRIGSEQ == track.explode_node_type)
                     {
                        if(pgPipeMap.createNewTrack3(catName/*pipeName*/,
                                                     track.getPortName(),
                                                     null/*presetPathOrNull*/,
                                                     NodeTrigSeq,
                                                     (null != autoDev)/*bAutoAssign*/,
                                                     autoDev,
                                                     autoChPref,
                                                     false/*bEdit*/
                                                     )
                           )
                        {
                           trigseq <= pgPipe.getSelectedScriptNode();
                           trigseqEditor <= trigseq.nodeGetEditor();
                           Global.Debug2("explode: trackIdx="+trackIdx+" trigseq="+#(trigseq)+" editor="+#(trigseqEditor));

                           nodeGIDs.add(trigseq.getNodeGID());

                           if(numPat > 0)
                           {
                              trigseqEditor.showNodeQuiet(trigseq);

                              // Import individual bars / patterns
                              patIdx = 0;
                              barStartIdx = 0;
                              loop(numPat)
                              {
                                 barIdx = patBarStarts.get(barStartIdx);
                                 seq.setSelection(barIdx, trackIdx, barIdx+numBars-1, trackIdx);
                                 Global.Debug2("explode: export trackIdx="+trackIdx+" barIdx="+barIdx+" #bars="+numBars);

                                 // Create Monitor clipboard
                                 patMon <= exportSelectionToMonitorClipboard(oldSong,
                                                                             true/*bQuiet*/,
                                                                             true/*bTickTimebase*/,
                                                                             false/*bIgnorePlayState*/,
                                                                             false/*bTrackerImportRPN*/,
                                                                             false/*bOutputCapture*/
                                                                             );

                                 // Import Monitor clipboard
                                 trigseq.nodeSetCurrentEditPatternNr(patIdx);
                                 if(patIdx > 0)
                                    trigseqEditor.handlePatternAlloc(false/*bSub*/);
                                 trigseqEditor.importMonPattern(patMon,
                                                                true/*bGuessNoteNameProfile*/,
                                                                true/*bPreferGlobalOutput*/
                                                                );

                                 bPatAdv = true;

                                 if(_bUniquePatterns)
                                 {
                                    patIdxUnique = tracker.nodeFindPatternByEvents(tracker.nodeGetCurrentEditPattern());
                                    if(-1 != patIdxUnique)
                                    {
                                       if(patIdx != patIdxUnique)
                                       {
                                          // Re-Use previously added pattern
                                          trackerEditor.cmd_pattern_free_no_undo(true/*bFreeMeta*/);
                                          patIdx = patIdxUnique;
                                          bPatAdv = false;
                                          Global.Debug2("explode: trackIdx="+trackIdx+" barIdx="+barIdx+" re-use patIdx="+patIdx+" ("+(Node.patnr_options.get(patIdx))+")");
                                       }
                                    }
                                 }

                                 patIndices.add(patIdx);

                                 // Next pattern
                                 barStartIdx++;
                                 barIdx += numBars;
                                 if(bPatAdv)
                                 {
                                    patIdx += patIdxAdv;
                                    numPatCreated++;
                                 }
                              }

                              trigseq.nodeSetCurrentEditPatternNr(0);

                           } // if numPat > 0

                           Global.Debug("explode: trackIdx="+trackIdx+" type=TrigSeq numPatCreated="+numPatCreated);

                           trigseqEditor.cancelAllTimers();
                        }
                        else
                        {
                           trace "[---] explode: failed to create TrigSeq node (trackIdx="+trackIdx+")";
                           nodeGIDs.add(-1);
                        }
                     } // /EXPLODE_TYPE_TRIGSEQ
                  }
                  else
                     trace "[---] explode: trackIdx="+trackIdx+" failed to resolve category name catIdx="+track.explode_node_cat;
               }

               // Next track
               trackIdx++;
            } // foreach track

            if(_bArranger)
            {
               // Initialize Arranger
               trackIdx = 0;
               NodeArrangerEditor arrEditor <= arr.nodeGetEditor();
               arrEditor.showNodeQuiet(arr); // calls scanPipeNodes()
               int ticksPerBar = pat.getNumTicksPerBar();
               int maxClipEndTicks = 0;
               foreach track in pat.tracks
               {
                  if(track.b_explode)
                  {
                     catName <= dlgNewTrack.track_categories.get(track.explode_node_cat);
                     if(null != catName)
                     {
                        nodeGID = nodeGIDs.get(trackIdx);
                        patIndices <= patIdxArrays[trackIdx];

                        if(-1 != nodeGID)
                        {
                           NA_Track arrTrack <= arr.timeline.findTrackByGID(nodeGID);
                           if(null != arrTrack)
                           {
                              patBarStarts <= barStartArrays.get(trackIdx);
                              numBars = track.explode_bars_per_pattern;
                              numPat = patBarStarts.numElements;
                              // // patIdxAdv = patIdxAdvArray.get(trackIdx);
                              barStartIdx = 0;
                              Global.Debug2("explode: init Arranger track nodeGID="+nodeGID+" numPat="+numPat+" numBars/pat="+numBars);
                              loop(numPat)
                              {
                                 barIdx = patBarStarts.get(barStartIdx);
                                 int clipStartTicks = barIdx * ticksPerBar;
                                 int clipEndTicks   = (barIdx + numBars) * ticksPerBar;
                                 patIdx = patIndices[barStartIdx];

                                 if(clipEndTicks > maxClipEndTicks)
                                    maxClipEndTicks = clipEndTicks;

                                 NA_Clip clip <= arrTrack.newClip(clipStartTicks, clipEndTicks, false/*bSort*/);
                                 clip.pattern_nr = patIdx;

                                 // // patIdx += patIdxAdv;
                                 barStartIdx++;
                              }
                           }
                        }

                        trackIdx++;
                     }
                  }
               }

               arr.timeline.setLoopRange(0, maxClipEndTicks);
            }

            current_song.seek(0);

            MIDI.UnlockUpdateOutDeviceNames();
            MIDI.b_skip_rebuild_all_ctl_names = false;

            // (note) new sub-song does not initially have any ctltags
            // // if(current_song.hasCtlTags())
            // // {
            // //    MIDI.RebuildAllCtlNames();
            // // }

            Global.Print("Explode "+numTracksExplode+" track"+Utils.GetPluralString(numTracksExplode)+" to new sub-song");
            root_form.showPage(RootForm.PAGE_PIPEMAP, false/*bAllowHistory*/);

            return true;
         }
         else
            Global.Warning("Explode: No tracks selected");
      }
   }

   // <ui_handle.png>
   protected =replay= method handleRecChanged() {
      seq.setEnableRec(cb_seq_rec.isSelected());
      if(seq.b_rec)
         undoBegin();
      else
         undoEnd();
      updateRecIcons();
      UI.CompositeAll();
      Global.Print("Rec is "+Utils.GetEnableString(seq.b_rec));
   }

   // <ui_handle.png>
   protected =replay= method handleRecBGChanged() {
      seq.setEnableRecBG(cb_seq_rec_bg.isSelected());
      Global.Print("Rec BG is "+Utils.GetEnableString(seq.b_rec_bg));
   }

   // <ui_handle.png>
   public =replay= method toggleRec() {
      seq.setEnableRec(!seq.b_rec);
      if(seq.b_rec)
         undoBegin();
      else
         undoEnd();
      cb_seq_rec.setSelected(seq.b_rec);
      updateRecIcons();
      UI.CompositeAll();
      Global.Print("Rec is "+Utils.GetEnableString(seq.b_rec));
   }

   // <ui_handle.png>
   public =replay= method toggleRecReplace() {
      cb_rec_replace.toggleSelectionAction();
   }

   // <ui_handle.png>
   protected method handleRecPrevChanged() {
      seq.setEnableRecPrev(cb_seq_rec_prev.isSelected());
      Global.Print("Rec Prev is "+Utils.GetEnableString(seq.b_rec_prev));
   }

   // <ui_handle.png>
   protected method handleMasterChanged() {
      seq.setEnableMaster(cb_seq_master.isSelected());

      Global.Print("Master is "+Utils.GetEnableStringMixed(seq.b_master,
                                                           "disabled",
                                                           "enabled (follow song-offset + change tempo)",
                                                           "disabled (change tempo only)"
                                                           )
                   );
   }

   // <ui_handle.png>
   protected method handleRecReplaceChanged() {
      seq.setEnableRecReplace(cb_rec_replace.isSelected());
      Global.Print("Rec-Replace is "+Utils.GetEnableString(seq.b_rec_replace));
   }

   // <ui_handle.png>
   protected method handlePreChanged() {
      seq.setEnablePre(cb_seq_pre.isSelected());
      Global.Print("Pre-Count is "+Utils.GetEnableString(seq.b_pre)+(seq.b_pre?(" ("+STConfig.pipemap_precount_num_bars+" bar"+Utils.GetPluralStringFloat(STConfig.pipemap_precount_num_bars)+")"):""));
   }

   // <ui_handle.png>
   protected method handleAutoscrollChanged() {
      seq.b_autoscroll = cb_seq_autoscroll.isSelected();
      Global.Print("Autoscroll is "+Utils.GetEnableStringMixed(seq.b_autoscroll, "disabled", "enabled (paging)", "enabled (smooth scroll)"));
   }

   // <ui_handle.png>
   protected method handleFastClearChanged() {
      seq.ui_b_fast_clear = cb_fast_clear.isSelected();
      Global.Print("Fast-clear-mode is "+Utils.GetEnableString(seq.ui_b_fast_clear));
      arr.redraw();
   }

   // <ui_handle.png>
   protected method handleTempoSnapChanged() {
      seq.ui_b_tempo_snap_to_frame = cb_tempo_snap.isSelected();
      Global.Print("Snap-tempo-bar-handle-to-frame is "+Utils.GetEnableString(seq.ui_b_tempo_snap_to_frame));
   }

   // <ui_handle.png>
   protected method handleStepRecChanged() {
      if(cb_step.isSelected())
      {
         stepRecBegin();
      }
      else
      {
         stepRecEnd();
      }
      Global.Print("Step-Record is "+Utils.GetEnableString(seq.b_step_rec));
   }

   // <ui_handle.png>
   protected method handleAutoRecFocusChanged() {
      seq.ui_b_auto_rec_focus = cb_seq_autorf.isSelected();
      Global.Print("Auto Rec / Focus is "+Utils.GetEnableStringMixed(seq.ui_b_auto_rec_focus,
                                                                     "disabled",
                                                                     "enabled",
                                                                     "enabled (select)"
                                                                     ));
   }

   // <ui_handle.png>
   public method toggleAutoRecFocus() {
      cb_seq_autorf.toggleSelectionAction();
   }

   // <ui_handle.png>
   protected method handleQChanged() {
      seq.setQMode(cm_seq_q.getSelectedOption());
      Global.Print("Q Mode is "+cm_seq_q.getSelectedOptionName());
   }

   // <ui_handle.png>
   protected method handleSigBeatsChanged() {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         pat.setSigBeats(fp_sig_beats.getFloatValue());
         redrawSeq();
         arr.doAutoScroll(true/*bForce*/);
         Global.Print("Time Signature Num Beats is "+pat.sig_beats);
      }
   }

   // <ui_handle.png>
   protected method handleSigNoteLenChanged() {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         pat.setSigNoteLen(fp_sig_notelen.getFloatValue());
         redrawSeq();
         arr.doAutoScroll(true/*bForce*/);
         Global.Print("Time Signature Note Length is 1/"+pat.sig_notelen);
      }
   }

   // <ui_handle.png>
   public method doubleNoteLen() {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         if(pat.sig_notelen*2 <= 16)
         {
            undoBegin();
            fp_sig_notelen.setValue(pat.sig_notelen*2);
            pat.setSigNoteLen(pat.sig_notelen*2);
            redrawSeq();
            arr.doAutoScroll(true/*bForce*/);
            undoEnd();
            Global.Print("Time Signature: Double Note Length (zoom in)");
         }
      }
   }

   // <ui_handle.png>
   public method halfNoteLen() {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         if((pat.sig_notelen > 1) && (0 == (pat.sig_notelen&1)))
         {
            undoBegin();
            fp_sig_notelen.setValue(pat.sig_notelen/2);
            pat.setSigNoteLen(pat.sig_notelen/2);
            redrawSeq();
            arr.doAutoScroll(true/*bForce*/);
            undoEnd();
            Global.Print("Time Signature: Half Note Length (zoom out)");
         }
      }
   }

   // <ui_handle.png>
   protected method handleVisBarsChanged() {
      seq.ui_num_visible_bars = fp_visbars.getFloatValue();
      redrawSeq();
      arr.doAutoScroll(true/*bForce*/);
      Global.Print("Number of visible bars is "+seq.ui_num_visible_bars);
   }

   // <ui_handle.png>
   public method toggleTempoSnapBarHandleToFrame() {
      seq.ui_b_tempo_snap_to_frame = !seq.ui_b_tempo_snap_to_frame;
      cb_tempo_snap.setSelected(seq.ui_b_tempo_snap_to_frame);
      Global.Print("Snap-tempo-bar-handle-to-frame is "+Utils.GetEnableString(seq.ui_b_tempo_snap_to_frame));
   }

   // <ui_handle.png>
   public method toggleTempoAndEventViews(boolean _bFromButton) {
      int viewIdx = ls_tempo.getCurrentChildNr();
      if(_bFromButton)
         viewIdx = bt_view.getToggleState();
      else
      {
         viewIdx = viewIdx ^ 1;
         bt_view.setToggleState(viewIdx);
      }
      ls_tempo.switchToLayerNr(viewIdx);
      ls_help.switchToLayerNr(viewIdx);
      handleViewEnter();
   }

   // <method_get.png>
   public method isTempoViewVisible() : boolean {
      return (0 == ls_tempo.getCurrentChildNr());
   }

   // <method_get.png>
   public method isEventViewVisible() : boolean {
      return (1 == ls_tempo.getCurrentChildNr());
   }

   // <method.png>
   public method toggleAutoResetSmoothScroll() {
      STConfig.b_node_seq_autoreset_smooth_scroll = !STConfig.b_node_seq_autoreset_smooth_scroll;
      Global.Print("Auto-reset Smooth Scroll is "+Utils.GetEnableString(STConfig.b_node_seq_autoreset_smooth_scroll));
   }

   // <ui_show.png>
   public method showExplodeDialog() {
      if(0 == UI.GetNumModalFloatingLayers())
      {
         if(Global.NotPlaying("Explode"))
         {
            NSQ_Pattern pat <= getEditPattern();
            if(null != pat)
            {
               dlg_explode.showPattern(pat);
            }
         }
      }
   }

   // <ui_update.png>
   protected method updateNodeClass() {
      cm_node_class.setSelectedOption(seq.getNodeClassId());
      cb_node_class_show.setSelected(seq.getEnableNodeClassShow());
   }

   // <ui_handle.png>
   protected method handleNodeClassChanged() {
      seq.setNodeClassId(cm_node_class.getSelectedOption());

      f_autodev.handleNodeClassChanged();

      Global.Print("Node class is \""+seq.getNodeClassString()+"\"");
   }

   // <ui_handle.png>
   protected method handleNodeClassShowChanged() {
      seq.setEnableNodeClassShow(cb_node_class_show.isSelected());

      f_autodev.handleNodeClassShowChanged();

      Global.Print("Node class show is "+Utils.GetEnableString(seq.getEnableNodeClassShow()));
   }

   // <method.png>
   public method undo() {
      seq.undo();
      showNode(seq);
      handlePatternChanged();
      seq.resetCurrentLoopAfterUndoRedo();
      redrawSeq();
      Global.Print("Undo");
      seq.ui_wheel_tick_move_count = 0;
   }

   // <method.png>
   public method redo() {
      seq.redo();
      showNode(seq);
      handlePatternChanged();
      seq.resetCurrentLoopAfterUndoRedo();
      redrawSeq();
      Global.Print("Redo");
      seq.ui_wheel_tick_move_count = 0;
   }

   // <method.png>
   public method clearUndoRedoStates() {
      seq.clearUndoRedo();
      Global.Print("Clear undo / redo history");
      seq.ui_wheel_tick_move_count = 0;
   }

   // <method_handle.png>
   public virtual handleStartPlaying() {

      Global.Debug3("NodeSeqEditor::handleStartPlaying");
   }

   // <method_handle.png>
   public virtual handleStopPlaying(boolean _bAllowBookmark) {
      // called from replay thread

      NSQ_Pattern pat <= getEditPattern();

      if(seq.b_rec)
      {
         if(seq.b_rec_replace)
            if(null != pat)
               pat.lazyMergeAndRemoveEmptyFrames();  // purge empty frames
         undoEnd();///seq.undoEnd();
      }

      // trace "xxx handleStopPlaying: seq.tick_nr="+seq.tick_nr+" bAllowBookmark="+_bAllowBookmark;

      if(seq.b_autoscroll)
      {
         if(_bAllowBookmark)
         {
            arr.setCursorX(seq.replay_start_cursor_x);
            arr.doAutoScroll(false/*bForce*/);
         }
         else
         {
            if(null != pat)
            {
               current_song.setSongOffset(seq.nodeGetLastPatternStartSongOffset() + (seq.cursor_x * pat.getNumTicksPerBar()));
            }
         }
      }

      Global.Debug3("NodeSeqEditor::handleStopPlaying: bAllowBookmark="+_bAllowBookmark);
   }

   // <method_handle.png>
   public virtual handleSongPosSelected() {
      // called from UI thread while =replay= is locked

      Global.Debug3("NodeSeqEditor::handleSongPosSelected");
      // trace "xxx NodeSeqEditor::handleSongPosSelected: current_song.song_offset="+current_song.song_offset;

      // called from UI thread while =replay= is locked
      NSQ_Pattern pat <= getEditPattern();
      int patTicksPerBar = 0;
      if(null != pat)
         patTicksPerBar = pat.getNumTicksPerBar();
      seq.nodeSetLastPatternStartEditorSongOffset(current_song.song_offset - (seq.cursor_x * patTicksPerBar));

      arr.handleSongPosSelected();
      redrawSeq();

      // trace "xxx NodeSeqEditor::handleSongPosSelected: nodeGetLastPatternStartEditorSongOffset="+seq.nodeGetLastPatternStartEditorSongOffset();
   }

   // <method_handle.png>
   public virtual handlePlayPatChanged() {
      Global.Debug3("NodeSeqEditor::handlePlayPatChanged");
   }

   // <method.png>
   public =replay= method toggleReplayEx(boolean _bAllowBookmark, boolean _bSendMMC) {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         if(!replay.b_playing)
         {
            seq.nodeCopyLastPatternStartSongOffsetFromEditor();

            // trace "xxx toggleReplayEx: seq.nodeGetLastPatternStartSongOffset()="+seq.nodeGetLastPatternStartSongOffset();
            if(true != seq.b_master)
               current_song.setSongOffset(seq.nodeGetLastPatternStartSongOffset() + (seq.cursor_x * pat.getNumTicksPerBar()));

            // // // current_song.seek(seq.nodeGetLastPatternStartSongOffset() + (seq.cursor_x * pat.getNumTicksPerBar()));

            seq.nodeSetCurrentPlayPatternNr(seq.nodeGetCurrentEditPatternNr());
         }

         if(replay.b_playing && !seq.b_autoscroll && !_bAllowBookmark)
         {
            arr.doAutoScroll(true/*bForce*/);
         }

         root_form.handleToggleReplayEx(_bAllowBookmark, _bSendMMC);

         if(!replay.b_playing && !seq.b_autoscroll && !_bAllowBookmark)
         {
            if(true == seq.b_master)
               arr.setMasterSongPosToCursor();
            else
               current_song.setSongOffset(seq.nodeGetLastPatternStartSongOffset() + (seq.cursor_x * pat.getNumTicksPerBar()));
         }

         replay.setPatternNode(seq);  // ignore prgchg+seek+mute
      }
   }

   // <method.png>
   public =replay= method startOrStopRecording(boolean _bMMC) {
      if(replay.b_playing)
      {
         if(seq.b_rec)
         {
            seq.setEnableRec(false);
            undoEnd();
         }
         cb_seq_rec.setSelected(false);
         toggleReplayEx(true/*bAllowBookmark*/, _bMMC/*bSendMMC*/);
         Global.Print("Stop Recording");
      }
      else
      {
         if(!seq.b_rec)
         {
            seq.setEnableRec(true);
            undoBegin();
         }
         cb_seq_rec.setSelected(true);
         toggleReplayEx(true/*bAllowBookmark*/, false/*bSendMMC*/);
         if(seq.b_pre)
         {
            replay.startPreCount(STConfig.pipemap_precount_num_bars);
            Global.Print("Start Recording (pre-count "+STConfig.pipemap_precount_num_bars+" bar"+Utils.GetPluralStringFloat(STConfig.pipemap_precount_num_bars)+")");
         }
         else
         {
            Global.Print("Start Recording");
         }
      }
      UI.CompositeAll();
   }

   // <ui_timer.png>
   public virtual handleReplayTimer() {

      if(replay.b_playing)
      {
         if(seq.checkResetNodePatternChanged())
         {
            cm_pattern_nr.setSelectedOption(seq.nodeGetCurrentEditPatternNr());
            handlePatternChanged();
         }
      }
   }

   // <replay.png>
   public virtual handleReplayTick() {
      Events.SendNodeEditorReplayTick();
   }

   // <ui_timer.png>
   public virtual handleReplayTickUI() {
      // called from UI thread
      arr.handleReplayTickUI();
   }

   // <ui_handle.png>
   protected method handleActiveTabChanged() {

      if(TAB_PORTS == ts_groups.getActiveTabIndex())
      {
         showPorts();
      }
      else if(TAB_SEQUENCE == ts_groups.getActiveTabIndex())
      {
         // // relayout();
      }

      refocusDefault();
      handleViewEnter();
   }

   // <ui_show.png>
   public method showFilterDialog() {
      dlg_filter.showCenteredFirst();
   }

   // <ui_handle.png>
   public method handleFilterEvents() {
      Global.Debug("NodeSeqEditor::handleFilterEvents");

      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         int startX;
         int startY;
         int endX;
         int numBars;
         int numTracks;
         int ticksPerBar = pat.getNumTicksPerBar();
         Integer numDelete = 0;
         Integer numKeep = 0;

         undoBegin();

         if(tempo.haveSelection())
         {
            startX    = seq.sorted_tempo_sel_start_x;
            endX      = seq.sorted_tempo_sel_end_x;
            startY    = seq.sorted_tempo_sel_start_y;
            numTracks = seq.sorted_tempo_sel_end_y - seq.sorted_tempo_sel_start_y + 1;
         }
         else if(arr.haveSelection())
         {
            startX    = seq.sorted_sel_start_x * ticksPerBar;
            numBars   = seq.sorted_sel_end_x - seq.sorted_sel_start_x + 1;
            endX      = startX + numBars * ticksPerBar;
            startY    = seq.sorted_sel_start_y;
            numTracks = seq.sorted_sel_end_y - seq.sorted_sel_start_y + 1;
         }
         else
         {
            startX = seq.cursor_x * ticksPerBar;
            endX   = startX + ticksPerBar;
            startY = seq.cursor_y * ticksPerBar;
            numBars = 1;
            numTracks = 1;
         }

         startX *= ticksPerBar;
         int trackIdx = startY;
         loop(numTracks)
         {
            NSQ_Track track <= pat.tracks.get(trackIdx);
            track.applyEventFilter(startX,
                                   endX,
                                   dlg_filter.doNotes(),
                                   dlg_filter.doCC(),
                                   dlg_filter.doRPN(),
                                   dlg_filter.doNRPN(),
                                   dlg_filter.doPitchbend(),
                                   dlg_filter.doPolyPressure(),
                                   dlg_filter.doChPressure(),
                                   dlg_filter.doPrgChg(),
                                   dlg_filter.doSysEx(),
                                   numDelete,
                                   numKeep
                                   );
            trackIdx++;
         }

         undoEnd();

         redrawSeq();
         Global.Print("Apply Event Filter (delete "+numDelete+", keep "+numKeep+" event(s))");

      } // if pat
   }

   // <ui_handle.png>
   public =replay= method handleCopyOutputStates() {
      Global.Debug("NodeSeqEditor::handleCopyOutputStates");

      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         int startX;
         int startY;
         int numTracks;
         int totalNumEv = 0;

         if(arr.haveSelection())
         {
            startX    = seq.sorted_sel_start_x;
            startY    = seq.sorted_sel_start_y;
            numTracks = seq.sorted_sel_end_y - seq.sorted_sel_start_y + 1;
         }
         else
         {
            startX = seq.cursor_x;
            startY = seq.cursor_y;
            numTracks = 1;
         }

         int ticksPerBar = pat.getNumTicksPerBar();
         int ticks = startX * ticksPerBar;

         local MIDIPipeFrame fr;
         int trackIdx = startY;

         undoBegin();

         loop(numTracks)
         {
            DeviceIOPort op <= seq.out_ports.get(trackIdx);
            STX_MIDIOutDevice dev <= MIDI.GetMIDIOutDeviceByIndex(op.dev_idx);

            if(null != dev)
            {
               NSQ_Track track <= pat.tracks.get(trackIdx);
               MIDIPipeDevice pipeDev <= dev.getMIDIPipeDevice();
               int ch;
               int val;
               int nr;
               int devIdx = op.dev_idx;

               int firstCh;
               int numCh;
               if(-1 == op.dev_ch)
               {
                  firstCh = 0;
                  numCh = 16;
               }
               else
               {
                  firstCh = op.dev_ch;
                  numCh = 1;
               }

               fr.empty();

               // CC
               ch = firstCh;
               loop(numCh)
               {
                  nr = 0;
                  loop(128)
                  {
                     val = pipeDev.getCCState(ch, nr++);
                     if(-1 != val)
                     {
                        fr.cc(true/*bSet*/, devIdx, ch, nr, val);
                     }
                  }
                  ch++;
               }

               // RPN
               ch = firstCh;
               loop(numCh)
               {
                  nr = 0;
                  loop(16384)
                  {
                     val = pipeDev.getRPNState(ch, nr++);
                     if(-1 != val)
                     {
                        fr.rpn(true/*bSet*/, devIdx, ch, nr, val);
                     }
                  }
                  ch++;
               }

               // NRPN
               ch = firstCh;
               loop(numCh)
               {
                  nr = 0;
                  loop(16384)
                  {
                     val = pipeDev.getNRPNState(ch, nr++);
                     if(-1 != val)
                     {
                        fr.nrpn(true/*bSet*/, devIdx, ch, nr, val);
                     }
                  }
                  ch++;
               }

               // Pitchbend
               ch = firstCh;
               loop(numCh)
               {
                  val = pipeDev.getPitchbend(ch);
                  if(-1 != val)
                  {
                     fr.pitchbend(true/*bSet*/, devIdx, ch, val);
                  }
                  ch++;
               }

               // Poly Pressure
               ch = firstCh;
               loop(numCh)
               {
                  nr = 0;
                  loop(128)
                  {
                     val = pipeDev.getPolyPressure(ch, nr/*note*/);
                     if(-1 != val)
                     {
                        fr.polyPressure(true/*bSet*/, devIdx, ch, nr/*note*/, val);
                     }
                  }
                  ch++;
               }

               // Channel Pressure
               ch = firstCh;
               loop(numCh)
               {
                  val = pipeDev.getChPressure(ch);
                  if(-1 != val)
                  {
                     fr.chPressure(true/*bSet*/, devIdx, ch, val);
                  }
                  ch++;
               }

               // Program Change
               ch = firstCh;
               loop(numCh)
               {
                  val = pipeDev.getPrg(ch);
                  if(-1 != val)
                  {
                     fr.prgChg(true/*bSet*/, devIdx, ch, val);
                  }
                  ch++;
               }

               // Create/merge new frame
               int numEv = fr.numEvents;
               if(numEv > 0)
               {
                  track.recordFrame(ticks,
                                    fr,
                                    false/*bTrackActiveNotes*/,
                                    false/*bMarkPlayed*/,
                                    false/*bNoteOffOnly*/,
                                    false/*bQuantize*/,
                                    false/*bAllowQLoop*/,
                                    false/*bRecLatency*/
                                    );
                  totalNumEv += numEv;
               }
            } // if dev

            // Next track
            trackIdx++;

         } // loop tracks

         undoEnd();

         if(totalNumEv > 0)
         {
            redrawSeq();
         }
         Global.Print("Copy Output State: Insert "+totalNumEv+" event"+Utils.GetPluralString(totalNumEv)+" at bar "+(startX+1));
      } // if pat
   }

   // <ui_handle.png>
   public =replay= method handleClearOutputStates() {
      Global.Debug("NodeSeqEditor::handleClearOutputStates");

      int startY;
      int numTracks;
      int numCleared = 0;

      if(arr.haveSelection())
      {
         startY    = seq.sorted_sel_start_y;
         numTracks = seq.sorted_sel_end_y - seq.sorted_sel_start_y + 1;
      }
      else
      {
         startY = seq.cursor_y;
         numTracks = 1;
      }

      int trackIdx = startY;

      loop(numTracks)
      {
         DeviceIOPort op <= seq.out_ports.get(trackIdx);
         STX_MIDIOutDevice dev <= MIDI.GetMIDIOutDeviceByIndex(op.dev_idx);

         if(null != dev)
         {
            MIDIPipeDevice pipeDev <= dev.getMIDIPipeDevice();

            int firstCh;
            int numCh;
            if(-1 == op.dev_ch)
            {
               firstCh = 0;
               numCh = 16;
            }
            else
            {
               firstCh = op.dev_ch;
               numCh = 1;
            }

            int ch = firstCh;
            loop(numCh)
            {
               pipeDev.clearMIDICacheForCh(ch++);
            }

            numCleared += numCh;

         } // if dev

         // Next track
         trackIdx++;

      } // loop tracks

      if(numCleared > 0)
      {
         Global.Print("Clear "+numCleared+" MIDI Port Output States");
      }
   }

   // <ui_handle.png>
   public =replay= method handleMergePerfCtlsToBarStarts(boolean _bStartUntilEndOfLoop) {
      Global.Debug("NodeSeqEditor::handleMergePerfCtlsToBarStarts()");

      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         int startX;
         int startY;
         int endX;
         int numTracks;
         int totalNumEv = 0;
         int ticksPerBar = pat.getNumTicksPerBar();

         if(arr.haveSelection())
         {
            startX    = seq.sorted_sel_start_x;
            endX      = seq.sorted_sel_end_x;
            startY    = seq.sorted_sel_start_y;
            numTracks = seq.sorted_sel_end_y - seq.sorted_sel_start_y + 1;
         }
         else
         {
            // Update just one bar (by looking at the previous one)
            startX = seq.cursor_x;
            endX   = startX;
            startY = seq.cursor_y;
            numTracks = 1;
         }

         if(_bStartUntilEndOfLoop)
         {
            startX = 0;
            endX = (pat.loop_start_ticks + pat.loop_len_ticks + ticksPerBar/2) / ticksPerBar;
            if(endX > startX)
               endX--;
         }

         int ticks = startX * ticksPerBar;

         local MIDIPipeFrame fr;
         int trackIdx = startY;

         undoBegin();

         int totalNumBarsUpdated = 0;

         loop(numTracks)
         {
            NSQ_Track track <= pat.tracks.get(trackIdx);
            if(null != track)  // cannot be null ?!
            {
               totalNumBarsUpdated += track.mergePerfCtlsToBarStarts(startX/*barIdxStart*/, endX/*barIdxEnd*/);
            }

            // Next track
            trackIdx++;

         } // loop tracks

         undoEnd();

         if(totalNumBarsUpdated > 0)
         {
            redrawSeq();
         }
         Global.Print("MergePerfCtlToBarStarts: Update "+totalNumBarsUpdated+" bar"+Utils.GetPluralString(totalNumBarsUpdated));
      } // if pat
   }

   // <ui_handle.png>
   public method togglePreCount() {
      cb_seq_pre.toggleSelectionAction();
   }

   // <ui_handle.png>
   public method toggleIgnoreSeekPrgChgMute() {
      STConfig.b_node_seq_ignore_seek_prgchg_mute_during_pattern_replay = !STConfig.b_node_seq_ignore_seek_prgchg_mute_during_pattern_replay;
      Global.Print("Ignore seek-prgchg-mute (global) is "+Utils.GetEnableString(STConfig.b_node_seq_ignore_seek_prgchg_mute_during_pattern_replay));
   }

   // <ui_handle.png>
   public method toggleIgnoreSeekPrgChgMute_Node() {
      seq.nodeToggleIgnoreSeekPrgChgMute();
      Global.Print("Ignore seek-prgchg-mute is "+Utils.GetEnableString(seq.b_node_ignore_seek_prgchg_mute));
   }

   // <method.png>
   public method stepRecBegin() {
      NSQ_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         current_song.seek(seq.nodeGetLastPatternStartSongOffset() + (seq.cursor_x * pat.getNumTicksPerBar()));
         undoBegin();
         seq.setEnableStepRec(true);
         cb_step.setSelected(true);
         Global.Debug("NodeSeqEditor: begin step record");
         arr.redraw();
      }
   }

   // <method.png>
   public method stepRecEnd() {
      NSQ_Pattern pat <= getEditPattern();
      seq.setEnableStepRec(false);
      cb_step.setSelected(false);
      if(null != pat)
      {
         Global.Debug("NodeSeqEditor: end step record");
         undoEnd();
         arr.redraw();
      }
   }

   // <method.png>
   public method stepRecToggle() {
      cb_step.toggleSelectionAction();
   }

   // <method.png>
   public method stepRecMoveCursor(int _num) {
      // trace "xxx stepRecMoveCursor("+_num+")";
      // num: 8=8th, 16=16th, ..
      if(!replay.b_playing && seq.b_step_rec)
      {
         // Adjust step recording position
         int startTicks = seq.nodeGetLastPatternStartSongOffset();
         int ticks = current_song.song_offset - startTicks;
         float tickDelta = (current_song.ppq * 4) / abs(float(_num));
         // trace "xxx tickDelta="+tickDelta+" ppq="+current_song.ppq+" startTicks="+startTicks+" ticks="+ticks;
         if(_num < 0)
         {
            ticks = (int(ticks / tickDelta) - 1) * tickDelta;
            if(ticks < 0)
               ticks = 0;
         }
         else
         {
            ticks = (int(ticks / tickDelta) + 1) * tickDelta;
         }
         // trace "xxx => rel ticks="+ticks;

         NSQ_Pattern pat <= getEditPattern();
         if(null != pat)
         {
            int ticksPerBar = pat.getNumTicksPerBar();
            arr.setCursorX(ticks / ticksPerBar);
         }

         current_song.seek(startTicks + ticks);
         arr.selectNoneAtAll();
         ///UI.CompositeAll();
         redrawSeq();

      }
   }

   // <method.png>
   public =replay= method beginOutputCapture() {
      // (note) capture stops when replay is stopped
      mon_capture.captureBegin();
      seq.b_capture = true;
      Global.Print("Start output capture");
   }

   // <method.png>
   public =replay= method pasteOutputCapture(boolean _bLazySelectBar, boolean _bUndoBegin) {
      // Lazy-stop replay
      if(replay.b_playing)
         root_form.handleToggleReplay(false/*bSendMMC*/);

      NM_Pattern patMon <= mon_capture.nodeGetCurrentEditPattern();
      patMon.noteOffsToDuration();
      importMonPattern(patMon, _bLazySelectBar, _bUndoBegin);
   }

   // <method.png>
   public method toggleOutputCaptureTicks() {
      STConfig.b_node_monitor_capture_tick_timebase = !STConfig.b_node_monitor_capture_tick_timebase;
      Global.Print("Output-Capture time base is "+(STConfig.b_node_monitor_capture_tick_timebase?"ticks":"milliseconds"));
   }

   // <method.png>
   public =replay= method importMonPattern(NM_Pattern patMon,
                                           boolean _bLazySelectBar,
                                           boolean _bUndoBegin
                                           ) {
      // (note) match track port dev/ch

      Global.Debug("-------------------------------------- NodeSeqEditor::importMonPattern");

      NSQ_Pattern pat <= getEditPattern();

      if(_bUndoBegin)
         undoBegin();

      if(null == pat)
      {
         handlePatternNew(false/*bSub*/);
         pat <= getEditPattern();
      }

      if(null != pat)
      {
         boolean bHaveSel = arr.haveSelection();
         int startX;
         int startY;
         int numBars;
         int numTracks;

         if(bHaveSel)
         {
            startX    = seq.sorted_sel_start_x;
            numBars   = seq.sorted_sel_end_x - seq.sorted_sel_start_x + 1;
            startY    = seq.sorted_sel_start_y;
            numTracks = seq.sorted_sel_end_y - seq.sorted_sel_start_y + 1;

            arr.handleClearSelection(false/*bUndoBegin*/);
         }
         else if(_bLazySelectBar)
         {
            // Select bar
            startX    = seq.cursor_x;
            numBars   = 1;
            startY    = seq.cursor_y;
            numTracks = 1;
         }
         else
         {
            // Select all
            startX    = 0;
            numBars   = NSQ_Track.MAX_BARS;
            startY    = 0;
            numTracks = NodeSeq.NUM_TRACKS;

            pat.clearPattern();
         }

         int origLockedKeyjazzNodeGID = current_song.locked_keyjazz_node_gid;
         current_song.locked_keyjazz_node_gid = -1;

         int ticksPerBar = pat.getNumTicksPerBar();
         int startTicks  = startX * ticksPerBar;
         int endTicks    = startTicks + numBars * ticksPerBar;

         int frIdx = 0;
         int numFrames = patMon.getNumFrames();
         int tickStart = -1;
         int evOff = 0;  // ticks

         local MIDIPipeFrame frDummy;

         int oldSeqTickNr = seq.tick_nr;

         trace "[trc] NodeSeqEditor::importMonPattern: monNumFrames="+numFrames+" selNumBars="+numBars;

         loop(numFrames)
         {
            MIDIPipeFrame frMon = patMon.getReplayFrameByIdx(frIdx);
            // trace "xxx NodeSeqEditor::importMonPattern: frIdx="+frIdx+" frMon.timestamp="+frMon.timeStamp;

            if(patMon.b_tick_timebase)  // used (only) by output capture mode
               evOff = frMon.timeStamp/*ticks*/;
            else // to ticks
               evOff = int( ( (frMon.timeStamp/*milliseconds*/ + patMon.replay_shift_ms) * current_song.bpm * current_song.ppq) / (1000.0 * 60) +0.5);

            if(-1 == tickStart)
            {
               tickStart = evOff;
               evOff = 0;
            }
            else
            {
               evOff -= tickStart;
            }

            seq.tick_nr = evOff + startTicks;
            Global.Debug3("NodeSeqEditor::importMonPattern: evOff="+evOff+" fr.numEv="+frMon.numEvents+" seq.tick_nr="+seq.tick_nr+" endTicks="+endTicks);

            if(seq.tick_nr >= endTicks)
               break;

            pat.processFrame(false/*bPlaySeq*/,
                             frDummy/*frameOut*/,
                             frMon/*frameIn*/,
                             false/*bFrameIn*/,
                             true/*bAllowRec*/,
                             false/*bAllowRedirect*/,
                             true/*bForceRec*/,
                             startY/*startTrackIdx*/,
                             numTracks,
                             true/*bAllowReplay*/,
                             false/*bIgnoreRecDev*/
                             );

            // Next frame
            frIdx++;
         }

         current_song.locked_keyjazz_node_gid = origLockedKeyjazzNodeGID;

         seq.tick_nr = oldSeqTickNr;

         Global.Print("Import "+numFrames+" frame"+Utils.GetPluralString(numFrames));
      }

      if(_bUndoBegin)
         undoEnd();

      redrawSeq();
   }

   // <method.png>
   public method importMonitorClipboard() {
      // Lazy-stop replay
      if(replay.b_playing)
         root_form.handleToggleReplay(false/*bSendMMC*/);

      NM_Pattern patMon <= NodePattern.PatGetClipboardForClass("NM_Pattern");
      if(null != patMon)
      {
         patMon.noteOffsToDuration();
         importMonPattern(patMon, false/*bLazySelectBar*/, true/*bUndoBegin*/);
      }
      else
         Global.Warning("No Monitor Clipboard Pattern");
   }

   // <method.png>
   public =replay= method endTrackerEdit() {
      // called when temporary tracker pattern has been modified

      boolean bWasPlaying = replay.b_playing;
      int oldSongOffset = current_song.song_offset;
      if(bWasPlaying)
      {
         replay.b_playing = false;
      }

      undoBegin();
      arr.handleClearSelection(false/*bUndoBegin*/);
      pasteOutputCapture(true/*bLazySelectBar*/, false/*bUndoBegin*/);
      undoEnd();

      if(bWasPlaying)
      {
         // Continue replay
         current_song.song_offset = oldSongOffset;
         replay.b_playing = true;
      }
   }

   // <ui_handle.png>
   public method copyPort() {
      DeviceIOForm f <= io_forms.get(seq.cursor_y);
      f.handleCopy();
   }

   // <ui_handle.png>
   public method pastePort() {
      DeviceIOForm f <= io_forms.get(seq.cursor_y);
      f.handlePaste();
   }

   // <ui_kbd.png>
   public method trackFormFocusPreviousTrackName(NSQ_TrackForm _cur) {
      int idx = track_forms.indexOfPointer(_cur, 0);
      if(idx >= 1)
      {
         NSQ_TrackForm tf <= track_forms.get(idx - 1);
         tf.focusTrackName();
      }
   }

   // <ui_kbd.png>
   public method trackFormFocusNextTrackName(NSQ_TrackForm _cur) {
      int idx = track_forms.indexOfPointer(_cur, 0);
      if(0 <= idx < (track_forms.numElements-1))
      {
         NSQ_TrackForm tf <= track_forms.get(idx + 1);
         tf.focusTrackName();
      }
   }

   // <method.png>
   protected =replay= method importSMF(MIDIFile _smf) {

      if(!replay.b_playing)
      {
         NSQ_Pattern pat <= getEditPattern();
         if(null != pat)
         {
            undoBegin();

            pat.lazyResetPlayedBarFrames(true/*bForce*/);

            replay.b_playing = true;

            // handleStartPlaying();

            int origTickNr     = seq.tick_nr;
            int origTickNrRel  = seq.tick_nr_rel;
            int origTickNrMono = seq.tick_nr_mono;
            // int origEditOffset = parent_node.getEditOffset();
            int origSongOffset = current_song.song_offset;
            int origSongTickNr = current_song.tick_nr;

            boolean bOrigRecLatency = STConfig.b_node_tracker_rec_latency;
            STConfig.b_node_tracker_rec_latency = false;

            int maxLen = 0;
            int trackIdx = 0;
            int ticksPerBar = pat.getNumTicksPerBar();

            local MIDIPipeFrame frDummy;

            int smfNumTracks = _smf.getNumTracks();
            boolean bHaveFocusRedirect = (-1 != seq.input_focus_idx);

            boolean bAllowRedirect = bHaveFocusRedirect;////(1 == smfNumTracks);
            boolean bForceRec      = !bHaveFocusRedirect;////(smfNumTracks > 1);

            loop(smfNumTracks)
            {
               MIDIFileTrack smfTrack <= _smf.getTrackByIdx(trackIdx);

               Integer evAbsTime;

               if(smfTrack.replayStart(current_song.ppq))
               {
                  for(;;)
                  {
                     MIDIPipeFrame fr <= smfTrack.replayGetNextEvent(evAbsTime);

                     if(null != fr)
                     {
                        MIDIPipeFrame frRec = fr;

                        // // frRec.setDevIdxAndMidiCh(0, kjMidiCh);

                        // trace "xxx importSMF: frRec.numEvents="+frRec.numEvents+" numNoteOn="+frRec.numEventsNoteOn+" numNoteOff="+frRec.numEventsNoteOff+" evAbsTime="+evAbsTime;

                        // parent_node.setEditOffset(evAbsTime);
                        seq.tick_nr      = evAbsTime;  // for recordMIDICtl()
                        seq.tick_nr_rel  = evAbsTime;
                        seq.tick_nr_mono = evAbsTime;
                        current_song.tick_nr     = evAbsTime;
                        current_song.song_offset = evAbsTime + seq.nodeGetLastPatternStartEditorSongOffset();

                        // parent_node.recordFrame(frRec, false/*bFramePlay*/, true/*bMuted*/, false/*bForceEditable*/, null/*frOut*/);

                        pat.processFrame(true/*bPlaySeq*/,
                                         frDummy/*frameOut*/,
                                         frRec/*frameIn*/,
                                         false/*bFramePlay*/,
                                         true/*bAllowRec*/,
                                         bAllowRedirect/*bAllowRedirect*/,
                                         bForceRec/*bForceRec*/,
                                         0/*startTrackIdx*/,
                                         pat.tracks.numElements,
                                         false/*bAllowReplay*/,
                                         true/*bIgnoreRecDev*/
                                         );


                        float bpmChange = fr.getFilteredRPN(0/*devIdx*/, 0/*midich*/, NodeTracker.RPN_TRACKER_INJECT_CTL0+NT_TrackPattern.CTL_BPM);
                        if(bpmChange > 0)
                        {
                           float bpmMul = bpmChange / current_song.bpm;
                           int bpmBarIdx = (evAbsTime + ticksPerBar/2) / ticksPerBar;
                           trace "xxx change BPM to "+bpmChange+" (bpmMul="+bpmMul+") evAbsTime="+evAbsTime+" (barIdx="+bpmBarIdx+")";
                           pat.updateBarTempo(bpmBarIdx, bpmMul);  // quantize to nearest bar start
                        }
                     }
                     else
                     {
                        int trackLen = smfTrack.replayGetTrackLength();
                        if(trackLen > maxLen)
                           maxLen = trackLen;
                        break;
                     }
                  }
               }

               // Next track
               trackIdx++;
            }

            replay.b_playing = false;

            // parent_node.setEditOffset(origEditOffset);
            current_song.song_offset = origSongOffset;
            current_song.tick_nr     = origSongTickNr;

            seq.tick_nr      = origTickNr;
            seq.tick_nr_rel  = origTickNrRel;
            seq.tick_nr_mono = origTickNrMono;

            STConfig.b_node_tracker_rec_latency = bOrigRecLatency;

            if(0 != maxLen)
            {
               // Align to bar
               maxLen = ((maxLen + ticksPerBar-1) / ticksPerBar) * ticksPerBar;
               // setPatternLength(maxLen);
            }
            // else
            // {
            //    setPatternLength(origPatLen);
            // }

            // // parent_editor.updatePatLen();

            undoEnd();

            Global.Success("ImportSMF: recorded "+smfNumTracks+" track"+Utils.GetPluralString(smfNumTracks)+" ("+maxLen+" ticks)");

            redraw();
         }
         else
         {
            Global.Warning("ImportSMF: No pattern");
         }
      }
      else
      {
         Global.Warning("ImportSMF: Please stop replay first");
      }
   }

   // <load.png>
   public method importSMFFromLocalFile(String _pathName) {
      local MIDIFile smf;

      if(smf.loadLocal(_pathName))
      {
         importSMF(smf);
      }
   }

   // <method.png>
   public method importSMFFileDialog() {
      local String suggestedPath, suggestedFile;
      Utils.SplitPathname(NodeTrackerEditor.import_smf_open_suggested_file, suggestedPath, suggestedFile);

      local String fileName <= UI.OpenFileDialog(suggestedPath,
                                                 suggestedFile,
                                                 "Import Standard MIDI File",
                                                 NodeTrackerEditor.import_smf_file_filter_names,
                                                 NodeTrackerEditor.import_smf_file_filter_strings,
                                                 false, false
                                                 );

      if(fileName != null)
      {
         NodeTrackerEditor.import_smf_open_suggested_file = fileName;

         importSMFFromLocalFile(fileName);
      }
   }

   // <method.png>
   protected =replay= method handleResetLastPatternStartOffset() {
      // workaround for corner-case issue:
      //   - edit node via Arranger (updates last pattern start (editor) song offset)
      //   - remove node from arranger
      //   - edit it
      //   - tracker-detail-edit region  => may result in negative step/songpos display
      int oldOff = seq.nodeGetLastPatternStartSongOffset();
      seq.nodeSetLastPatternStartSongOffset(0);
      seq.nodeSetLastPatternStartEditorSongOffset(0);
      Global.Print("Reset last pattern start off (was "+oldOff+")");
   }

   // <ui_handler.png>
   public virtual onDropFiles(StringArray _fileNames) : boolean {
      Global.Debug("NodeSeqEditor::onDropFiles: fileNames="+#(_fileNames));

      if(1 == _fileNames.numElements)
      {
         importSMFFromLocalFile(_fileNames.get(0));
         return true;
      }

      return false;
   }

   // <ui_render.png>
   public method redrawSeq() {
      redraw();
      ls_tempo.redraw();
   }

   // <ui_render.png>
   public method redrawActivityLEDs() {
      NSQ_TrackForm *tf;
      foreach tf in track_forms
      {
         tf.redrawActivityLEDs();
      }
   }

   // <ui_init.png>
   public virtual onOpen() {
      arr.onOpen();
   }

   // <ui_render.png>
   public virtual onDraw() {
      if(seq.uiCheckResetReshow())
      {
         handlePatternChanged();
      }
      NodeEditor::onDraw();
   }

   // <ui_mouse.png>
   public virtual onMouse(MouseEvent _ev) : boolean {
      //trace "xxx onMouse: _ev.changed_state="+_ev.changed_state+" _ev.current_state="+_ev.current_state;

      if(_ev.leftButtonUp())
      {
         UI.SetKeyboardFocus(arr);
         return true;
      }

      if(_ev.middleButtonDown())
         stepRecBegin();
      else if(_ev.middleButtonUp())
         stepRecEnd();

      return NodeEditor::onMouse(_ev);
   }

   // <ui_kbd.png>
   public virtual onBeginTriadKeyMode() : boolean {
      Global.Print("lctrl-x - ");
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {
      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          d         :   Toggle pattern manager
          z         :   Switch between pipenodes A/B
          F3        :   Delete current pattern

          c         :   Begin output capture (stops when replay is stopped)
          e         :   Explode to new sub-song (+split into separate nodes)
          f         :   Toggle Auto Rec / Focus
          k         :   Toggle KeyJazz lock
          l         :   Set left loop locator to cursor
          r         :   Set right loop locator to cursor
          h         :   Clear undo / redo history
          v         :   Paste output capture buffer
          \\        :   Export selection to Monitor clipboard ('<' on german kbd)
          RCTRL     :   Toggle Pre-Count
          RALT      :   Toggle Step-Rec
          BACKSPACE :   Toggle ignore-seek-prgchg-mute (per-node setting)
          RETURN    :   Reset node last pattern start offset to 0
          TAB       :   Focus \"Play\" tab
"
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      int key = _k.pressed;
      loop(2) // first pass for raw keycode, second pass for unicode
      {
         // US (reference) keyboard layout (raw keycodes)
         switch(key)
         {
            case VKEY_F3:
               handlePatternFree();
               return true;

            case VKEY_RCTRL:
               togglePreCount();
               return true;

            case VKEY_RALT:
               stepRecToggle();
               return true;

            case VKEY_BACKSPACE:
               toggleIgnoreSeekPrgChgMute_Node();
               return true;

            case VKEY_TAB:
               ts_groups.setActiveTabIndex(TAB_PLAY);
               handleActiveTabChanged();
               return true;

            case VKEY_RETURN:
               handleResetLastPatternStartOffset();
               return true;

            case 'c':
               beginOutputCapture();
               return true;

            case 'v':
               pasteOutputCapture(false/*bLazySelectBar*/, true/*bUndoBegin*/);
               return true;

            case '\\':
            case 60:
               exportSelectionToMonitorClipboard(current_song,
                                                 false/*bQuiet*/,
                                                 true/*bTickTimebase*/,
                                                 false/*bIgnorePlayState*/,
                                                 false/*bTrackerImportRPN*/,
                                                 true/*bOutputCapture*/
                                                 );
               return true;

            case 'e':
               showExplodeDialog();
               return true;

            case 'f':
               toggleAutoRecFocus();
               return true;

            case 'k':
               // this is usually lctrl-x l but the shortcut is already taken
               PagePipeMap pgPipeMap <= root_form.pg_pipemap;
               pgPipeMap.toggleKeyJazzLock(true/*bAlwaysVerbose*/);
               return true;

            case 'l':
               arr.setLeftLoopLocatorToCursor();
               Global.Print("Set left loop locator to cursor");
               return true;

            case 'r':
               arr.setRightLoopLocatorToCursor();
               Global.Print("Set right loop locator to cursor");
               return true;

            case 'h':
               clearUndoRedoStates();
               return true;
         }

         // see above
         key = _k.unicode;
      }

      return false;
   }

   // <ui_kbd.png>
   protected method handlePatternKeyHome(int _kMod) {
      if((VMOD_LSHIFT|VMOD_LCTRL) == _kMod)
      {
         handleSelectNextUsedPattern();
      }
      else
      {
         if(VMOD_LCTRL == _kMod)
         {
            MMTListener.MMTHandleLayerInc(cm_pattern_nr);
            MMTListener.MMTHandleLayerInc(cm_pattern_nr);
            MMTListener.MMTHandleLayerInc(cm_pattern_nr);
         }
         MMTListener.MMTHandleLayerInc(cm_pattern_nr); //selectNextPattern();
      }
   }

   // <ui_kbd.png>
   protected method handlePatternKeyEnd(int _kMod) {
      if((VMOD_LSHIFT|VMOD_LCTRL) == _kMod)
      {
         handleSelectPreviousUsedPattern();
      }
      else
      {
         if(VMOD_LCTRL == _kMod)
         {
            MMTListener.MMTHandleLayerDec(cm_pattern_nr);
            MMTListener.MMTHandleLayerDec(cm_pattern_nr);
            MMTListener.MMTHandleLayerDec(cm_pattern_nr);
         }
         MMTListener.MMTHandleLayerDec(cm_pattern_nr); //selectPrevPattern();
      }
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {

      // trace "xxx NodeSeqEditor::onKey: pressed="+_k.pressed+" mod="+_k.mod;

      if(VKEY_CAPSLOCK == _k.code)  // (note) k.mod==0 : release
      {
         if( _k.modNone() ^ !seq.b_step_rec )
            stepRecToggle();
         return true;
      }

      switch(_k.released)
      {
         case VKEY_RALT:
            stepRecEnd();
            return true;
      }

      switch(_k.pressed)
      {
         case VKEY_ESCAPE:
            if(TAB_SEQUENCE != ts_groups.getActiveTabIndex())
            {
               ts_groups.setActiveTabIndex(TAB_SEQUENCE);
               handleActiveTabChanged();
               return true;
            }
            // let PageNode handle it
            break;

         case VKEY_SPACE:
            toggleReplayEx(!_k.modCtrl() /*^ STConfig.b_node_tracker_swapstopbookmark*//*bAllowBookmark*/,
                           _k.modShift()/*bSendMMC*/
                           );
            return true;

         case VKEY_RCTRL:
            if(_k.modShift())
            {
               toggleRecReplace();
            }
            else
            {
               toggleRec();
            }
            return true;

         case VKEY_RALT:
            stepRecBegin();
            return true;

         case VKEY_RSHIFT:
            startOrStopRecording(false/*bMMC*/);
            return true;

         case VKEY_HOME:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyEnd(_k.mod);
            else
               handlePatternKeyHome(_k.mod);
            return true;

         case VKEY_END:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyHome(_k.mod);
            else
               handlePatternKeyEnd(_k.mod);
            return true;

         case VKEY_TAB:
            if(_k.modCtrlOnly())
            {
               toggleTempoAndEventViews(false/*bFromButton*/);
               return true;
            }
            break;

         case 'a':
            if(_k.modNone())
            {
               showPatternToolsMenu(true/*bFocusFirst*/);
               return true;
            }
            break;

         case 'b':
            if(isTempoViewVisible())
               tempo.showBPMFloatParamDialog(-1, -1);
            return true;

         case 'c':
            if( (_k.modCtrl() || (_k.modCmd() && UI.b_key_cmd_copy_paste)) && _k.modShift())
            {
               handlePatternCopy();
               return true;
            }
            else if(_k.modShiftOnly())
            {
               copyPort();
               return true;
            }
            break;

         case 'e':
            if(_k.modCtrlOnly())
            {
               exportSelectionToMonitorClipboard(current_song,
                                                 false/*bQuiet*/,
                                                 true/*bTickTimebase*/,
                                                 false/*bIgnorePlayState*/,
                                                 false/*bTrackerImportRPN*/,
                                                 false/*bOutputCapture*/
                                                 );
               return true;
            }
            else if(_k.modCtrl() && _k.modShift())
            {
               arr.beginTrackerEdit(false/*bTemp*/);
               return true;
            }
            break;

         case 'f':
            if(_k.modCtrl())
            {
               if(_k.modShift())
                  cb_seq_autoscroll.toggleSelectionAction();
               else
                  arr.doAutoScroll(true/*bForce*/);
               return true;
            }
            break;

         case 'g':
            arr.doAutoScroll(true/*bForce*/);
            return true;

         case 'h':
            if(_k.modNone())
            {
               toggleTempoSnapBarHandleToFrame();
               return true;
            }
            break;

         case 'v':
            if(_k.modCtrl() || (_k.modCmd() && UI.b_key_cmd_copy_paste))
            {
               handlePatternPaste();
               return true;
            }
            else if(_k.modNone())
            {
               cb_fast_clear.toggleSelectionAction();
               return true;
            }
            break;

         case 'n':
            if(_k.modCtrl())
            {
               if(_k.modShift())
               {
                  handlePatternAlloc(true/*bSub*/);
               }
               else
               {
                  handlePatternAlloc(false/*bSub*/);
               }
               return true;
            }
            else if(_k.modShift())
            {
               if(TAB_PATTERN == ts_groups.getActiveTabIndex())
               {
                  tf_pat_name.onTabFocus();
               }
               else
               {
                  ts_groups.setActiveTabIndex(TAB_SEQUENCE);
                  handleViewEnter();
                  tf_pat_name2.onTabFocus();
               }
               return true;
            }
            break;

         case 'o':
            if(_k.modCtrl())
            {
               if(_k.modShift())
               {
                  handleClearOutputStates();
               }
               else
               {
                  handleCopyOutputStates();
               }
               return true;
            }
            break;

         case 'r':
            if(_k.modCtrl())
            {
               if(_k.modShift())
               {
                  handlePatternClone(true/*bSub*/);
               }
               else
               {
                  handlePatternClone(false/*bSub*/);
               }
               return true;
            }
            break;

         case 't':
            if(_k.modShiftOnly())
            {
               pastePort();
               return true;
            }
            break;

         case '1':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_PORTS);
               handleActiveTabChanged();
               return true;
            }
            break;

         case '2':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               handleActiveTabChanged();
               return true;
            }
            break;

         case '3':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_SEQUENCE);
               handleActiveTabChanged();
               return true;
            }
            break;

         case '4':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_PLAY);
               handleActiveTabChanged();
               return true;
            }
            break;

         case 'y': // 'z' on german kbd
            if(_k.modCtrl())
            {
               if(_k.modShift())
                  redo();
               else
                  undo();
            }
            return true;

         case 'z':  // 'y' on german kbd
         case 'k':
            if(_k.modNone())
            {
               stepRecToggle();
               return true;
            }
            break;

         case 60:  // '\' on us kbd, '<' on ger kbd
            if(_k.modNone())
            {
               handleCopyOutputStates();
               return true;
            }
            else if(_k.modShift())
            {
               handleClearOutputStates();
               return true;
            }
            break;

         case 91: // '[' (us), '' (de)
            halfNoteLen();
            return true;

         case 93: // ']' (us), '' (de)
            doubleNoteLen();
            return true;

         case VKEY_F9:
            if(_k.modShift())
            {
               if(_k.modCtrl())
               {
                  importSMFFileDialog();
               }
               else
               {
                  importMonitorClipboard();
               }
            }
            return true;
      }

      switch(ts_groups.getActiveTabIndex())
      {
         case TAB_PORTS:
            break;

         case TAB_PATTERN:
            switch(_k.pressed)
            {
            }
            break;

         case TAB_SEQUENCE:
            break;

         case TAB_PLAY:
            break;
      }

      if(trySelectPatternByUsedIdx(_k))
         return true;

      if(_k.modShift())
      {
         switch(_k.pressed)
         {
         }
      }

      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      StringAction *sac;

      if(DeviceIOForm.ACTION_MIDI_LEARN_START == acName)
      {
         // New MIDI learn started, stop all others
         stopAllMIDILearnExcept(ap);
         return true;
      }
      else if(DeviceIOForm.ACTION_PORT_CHANGED == acName)
      {
         // trace "xxx handle PORT_CHANGED";
         updateTrackNames();
         return true;
      }
      else if(DeviceIOForm.ACTION_REFOCUS_DEFAULT == acName)
      {
         // trace "xxx handle DeviceIOForm.ACTION_REFOCUS_DEFAULT";
         refocusDefault();
         return true;
      }

      if(TA_CHECKREDRAW == acName)
      {
         if(seq.uiCheckResetRedraw())
         {
            redrawSeq();
         }

         if(seq.uiCheckResetActivity())
         {
            redrawActivityLEDs();
         }

         if(STConfig.b_midi_metronome != cb_seq_metro.isSelected())
            cb_seq_metro.setSelected(STConfig.b_midi_metronome);

         bt_undo.setEditable(seq.hasUndoHistory());
         bt_redo.setEditable(seq.hasRedoHistory());

         bt_record.setToggleState(seq.b_rec && replay.b_playing);

         ta_checkredraw.reschedule();
         return true;
      }
      else if(TA_MINIUNDO == acName)
      {
         seq.undoEnd();
         return true;
      }

      switch(@(ap))
      {
         default:
            break;

         case @(ts_groups):
            Global.Print("Active tab is \""+ts_groups.getActiveViewCaption()+"\".");
            handleActiveTabChanged();
            return true;


            // Ports:
         case @(bt_ports_clear):
            handleClearPortNames();
            return true;

         case @(bt_ports_def):
            handleLoadDefaultPortNames();
            return true;

         case @(bt_ports_nr):
            handleLoadNrPortNames();
            return true;


            // Pattern:
         case @(bt_pat_alloc):
            if(Button.ACTION_HOLD_CLICK == acName)
            {
               handlePatternClone(false/*bSub*/);
            }
            else
            {
               handlePatternAlloc(false/*bSub*/);
            }
            return true;

         case @(bt_pat_tools):
            showPatternToolsMenu(false/*bFocusFirst*/);
            return true;

         case @(pm_pat_tools):
            Global.Debug2("seq: pm_pat_tools acName="+acName);
            if(!PopupMenu.IsFocusAction(_action))
               refocusDefault();
            switch(acName)
            {
               case PopupMenu.ACTION_CANCEL:
               case "":
                  Global.Print("Close pattern tools menu.");
                  return true;

               default:
                  Global.Print("Select: "+acName);
                  return true;

               case "copy":
                  handlePatternCopy();
                  return true;

               case "paste":
                  handlePatternPaste();
                  return true;

               case "clone":
                  handlePatternClone(false/*bSub*/);
                  return true;

               case "clone_sub":
                  handlePatternClone(true/*bSub*/);
                  return true;

               case "new_sub":
                  handlePatternAlloc(true/*bSub*/);
                  return true;
            }
            return true;

         case @(bt_pat_free):
            handlePatternFree();
            return true;

            // Pattern:
         case @(cm_pattern_nr):
            handleSelectPattern();
            return true;

         case @(tf_pat_name):
            handlePatternNameChanged();
            updatePatternNrComboBox();
            if(TextField.ACTION_TEXTENTERED == acName)
            {
               refocusDefault();
            }
            return true;

         case @(tf_pat_name2):
            handlePatternName2Changed();
            updatePatternNrComboBox();
            if(TextField.ACTION_TEXTENTERED == acName)
            {
               refocusDefault();
            }
            return true;


            // Sequence:
         case @(cb_seq_rec):
            handleRecChanged();
            return true;

         case @(cb_seq_rec_bg):
            handleRecBGChanged();
            return true;

         case @(cb_seq_rec_prev):
            handleRecPrevChanged();
            return true;

         case @(cb_seq_master):
            handleMasterChanged();
            return true;

         case @(cb_seq_metro):
            root_form.toggleMetronome();
            return true;

         case @(cb_rec_replace):
            handleRecReplaceChanged();
            return true;

         case @(cb_seq_pre):
            handlePreChanged();
            return true;

         case @(cb_seq_autoscroll):
            handleAutoscrollChanged();
            return true;

         case @(cb_fast_clear):
            handleFastClearChanged();
            return true;

         case @(cb_tempo_snap):
            handleTempoSnapChanged();
            return true;

         case @(cb_step):
            handleStepRecChanged();
            return true;

         case @(cb_seq_autorf):
            handleAutoRecFocusChanged();
            return true;

         case @(cm_seq_q):
            handleQChanged();
            return true;

         case @(fp_sig_beats):
            handleSigBeatsChanged();
            if(FloatParam.ACTION_VALUEENTERED == acName)
               refocusDefault();
            return true;

         case @(fp_sig_notelen):
            handleSigNoteLenChanged();
            if(FloatParam.ACTION_VALUEENTERED == acName)
               refocusDefault();
            return true;

         case @(fp_visbars):
            handleVisBarsChanged();
            if(FloatParam.ACTION_VALUEENTERED == acName)
               refocusDefault();
            return true;

         case @(bt_undo):
            undo();
            return true;

         case @(bt_redo):
            redo();
            return true;

         case @(bt_undo_clear):
            clearUndoRedoStates();
            return true;

         case @(bt_record):
            startOrStopRecording(false/*bMMC*/);
            return true;

         case @(bt_view):
            toggleTempoAndEventViews(true/*bFromButton*/);
            return true;

         case @(dlg_explode):
            if(NSQ_ExplodeDialog.ACTION_EXPLODE == acName)
            {
               explode(dlg_explode.doSubSong(),
                       dlg_explode.doUniquePatterns(),
                       dlg_explode.doArranger()
                       );
            }
            return true;


            // Play:
         case @(cm_node_class):
            handleNodeClassChanged();
            return true;

         case @(cb_node_class_show):
            handleNodeClassShowChanged();
            return true;

         case @(cm_node_class_show_in):
            handleNodeClassShowInChanged(seq);
            f_autodev.handleNodeClassShowChanged();
            return true;
      }

      return XMLForm::consumeAction(_action);
   }

}
