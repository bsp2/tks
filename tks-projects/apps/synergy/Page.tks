// ----
// ---- file   : Page.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2012-2023 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- changed: 13Nov2012, 04Jan2013, 06Jan2013, 25Mar2013, 19Apr2013, 11Aug2014, 12Aug2014
// ----          15Aug2014, 18Aug2014, 20Aug2014, 09Sep2014, 14Sep2014, 19Sep2014, 21Sep2014
// ----          27Sep2014, 29Sep2014, 21Feb2015, 23Feb2015, 06Mar2015, 29Sep2015, 12Oct2015
// ----          12Nov2015, 09Feb2017, 30Jul2017, 02Dec2018, 11Jan2019, 02Mar2019, 29Aug2019
// ----          28Jul2023, 18Nov2023
// ----
// ----
// ----

module MPage;

use namespace ui;
use namespace st2;


// <class.png>
abstract class Page : XMLForm, ActionProvider, MMTListener, CmdProvider {

   public method pageGetName() : String {
      String n <= (this).yacMetaClassName();
      return n.replace("Page", "");
   }

   public method pageIsSub() : boolean {
      // Return true if current page should only be left temporarily.
      //  When this page is left, editing continues on the current page.
      return false;
   }

   public method pageEnter() {

      pagePushColorizePads();

      if(this instanceof MIDIMapContext)
      {
         MIDIMapContext mmcThis <= this;
         MIDIMapContext m <= mmcThis.mmcProxyGet();
         if(null != m)
            m.mmcHandleAutoSelectMorphScene();
         else
            mmcThis.mmcHandleAutoSelectMorphScene();
      }
   }

   public method isPageLocked() : boolean {
      return false;
   }

   public method pageLeave() {
   }

   public method pageLeaveSub() {
      // Leave temporarily (e.g. to edit MMC), editing continues when sub page returns
      pageLeave();
   }

   public method pageGetParent() : int {
      return -1;
   }

   public method pageIsModal() : boolean {
      return false;
   }

   public method pageFocusDefault() {
   }

   public method pageForceKbdFocusSelMode() : boolean {
      // true=temporarily enabled kbdfocus selection mode for cursor keys
      return false;
   }

   public method pageHandleAutoFocusKey(Key _k) : boolean {
      return false;
   }

   public method pageSceneChanged(int _groupIdx, boolean _bMulti) : boolean {
      return false;
   }

   // <ui_timer.png>
   public method pageHandleReplayTimer() {
      // Periodic callback (~30 times per sec). Called from UI thread.
   }

   public method pageHandleMuteSoloChanged() {
   }

   public method pageIsCurrent() {
      return (@(root_form.getCurrentPage()) == @(this));
   }

   // <midi_push.png>
   public method pagePushColorizePads() {

      // trace "xxx pagePushColorizePads";

      if(STConfig.b_push)
      {
         push.padUpdateBegin();

         // root_form.mmcPushColorizePads();
         // // root_form.pushActivePadByPage();

         if((this instanceof MIDIMapContext) && !b_mmc_force_global)
         {
            MIDIMapContext mmcThis <= this;
            MIDIMapContext m <= mmcThis.mmcProxyGet();
            if(null == m)
            {
               m <= mmcThis;
            }
            m.mmcPushColorizePads();
            // // m.mmcPushUpdateEncoderLabels();
            // // m.mmcPushUpdateEncoderValues();
         }
         else
         {
            root_form.mmcPushColorizePads();
            // // root_form.mmcPushUpdateEncoderLabels();
            // // root_form.mmcPushUpdateEncoderValues();
         }

         push.padUpdateEnd();

      }
   }

   // <ui_kbd.png>
   public virtual getTabCycleOverrides() : PointerArray {
      return getTabCycleOverridesDef();
   }

   // <ui_midi.png>
   public virtual mmtGetFocusLayers() : PointerArray {
      return getTabCycleOverrides();
   }

   // <ui_kbd.png>
   public virtual wantKeyRepeat(Key _k) : boolean {
      switch(_k.code)
      {
         // // case 'b':
         // // case 'n':
         // // case 'q':
         // // case 'm':
         // // case 'p':
         // // case 'g':
         case VKEY_ESCAPE:
            return false;
      }
      return XMLForm::wantKeyRepeat(_k);
   }

}
