// ----
// ---- file   : NodeModMatrixEditor.tks
// ---- author : Bastian Spiegel <bs@tkscript.de>
// ---- legal  : (c) 2015-2025 by Bastian Spiegel.
// ----          Distributed under terms of the GNU LESSER GENERAL PUBLIC LICENSE (LGPL). See
// ----          http://www.gnu.org/licenses/licenses.html#LGPL or COPYING for further information.
// ----
// ---- info   : This is part of the "syntracker" midi sequencer.
// ----
// ---- changed: 30Oct2015, 31Oct2015, 01Nov2015, 04Nov2015, 07Nov2015, 08Nov2015, 15Nov2015
// ----          21Dec2015, 08Jul2016, 12Jul2016, 08Sep2016, 15Oct2016, 25Nov2016, 16Jan2017
// ----          04Feb2017, 09Feb2017, 06Mar2017, 09Mar2017, 10Mar2017, 11Mar2017, 12Mar2017
// ----          14Mar2017, 18Mar2017, 24Mar2017, 16Jun2017, 14Jul2017, 25Aug2017, 01Sep2017
// ----          03Sep2017, 12Oct2017, 04Jan2018, 05Apr2018, 17Jun2018, 22Feb2019, 18May2019
// ----          19May2019, 08Jun2019, 09Jun2019, 10Jun2019, 25Jun2019, 29Aug2019, 08Sep2019
// ----          10Sep2019, 20Sep2019, 03Oct2019, 08Nov2019, 07Jul2020, 26Oct2020, 26Jan2021
// ----          27Jan2021, 13May2021, 21Jul2021, 11Feb2023, 19Feb2023, 24Mar2023, 23Jun2023
// ----          27Jul2023, 21Sep2023, 03Oct2023, 14Oct2023, 19Oct2023, 21Oct2023, 31Oct2023
// ----          22Mar2024, 06Oct2024, 07Oct2024, 28Feb2025
// ----
// ----
// ----

module MNodeModMatrixEditor;

use namespace ui;
use namespace st2;


// <class.png>
class NodeModMatrixEditor extends NodeEditor, ActionProvider, MIDIMapEventListener, MIDIMapDefs {

   static boolean b_script_debug = false;

   define String TA_UPDATE_ARGS;
   protected TimerAction *ta_update_args;

   define int UPDATE_ARGS_NOTAP_MS = 350;
   define int UPDATE_ARGS_TAP_MS   = 50;

   define String TA_CAPTURE_ARGS;
   protected TimerAction *ta_capture_args;

   define int TAB_PATTERN   = 0;
   define int TAB_MACROCTL  = 1;
   define int TAB_ENTRIES   = 2;
   define int TAB_CURVES    = 3;
   define int TAB_PLAY      = 4;

   define String MMT_TAB_PREV;
   define String MMT_TAB_NEXT;
   define String MMT_TAB_PATTERN;
   define String MMT_TAB_MACROCTL;
   define String MMT_TAB_ENTRIES;
   define String MMT_TAB_PLAY;

   define String MMT_PAT_NR;
   define String MMT_PAT_NR_INV;
   define String MMT_PAT_NR_DELTA;
   define String MMT_PAT_NR_INC;
   define String MMT_PAT_NR_DEC;

   define String MMT_PAT_NR_1;
   define String MMT_PAT_NR_2;
   define String MMT_PAT_NR_3;
   define String MMT_PAT_NR_4;
   define String MMT_PAT_NR_5;
   define String MMT_PAT_NR_6;
   define String MMT_PAT_NR_7;
   define String MMT_PAT_NR_8;
   define String MMT_PAT_NR_9;
   define String MMT_PAT_NR_10;
   define String MMT_PAT_NR_11;
   define String MMT_PAT_NR_12;
   define String MMT_PAT_NR_13;
   define String MMT_PAT_NR_14;
   define String MMT_PAT_NR_15;
   define String MMT_PAT_NR_16;
   define String MMT_PAT_NR_17;
   define String MMT_PAT_NR_18;
   define String MMT_PAT_NR_19;

   define String MMT_PAT_NR_20;
   define String MMT_PAT_NR_21;
   define String MMT_PAT_NR_22;
   define String MMT_PAT_NR_23;
   define String MMT_PAT_NR_24;
   define String MMT_PAT_NR_25;
   define String MMT_PAT_NR_26;
   define String MMT_PAT_NR_27;
   define String MMT_PAT_NR_28;
   define String MMT_PAT_NR_29;
   define String MMT_PAT_NR_30;
   define String MMT_PAT_NR_31;
   define String MMT_PAT_NR_32;
   define String MMT_PAT_NR_33;
   define String MMT_PAT_NR_34;
   define String MMT_PAT_NR_35;

   define String MMT_PAT_NEW;
   define String MMT_PAT_COPY;
   define String MMT_PAT_PASTE;
   define String MMT_PAT_CLONE;
   define String MMT_PAT_FREE;


   public NodeModMatrix *modmatrix;

   protected TabSwitch *ts_groups;


   // Pattern:
   protected ComboBox   *cm_pattern_nr;
   protected Label      *lb_pat_nr;
   protected TextField  *tf_pat_name;
   protected Button     *bt_clear;

   protected Button    *bt_pat_alloc;
   protected Button    *bt_pat_tools;
   protected PopupMenu *pm_pat_tools;
   protected Button    *bt_pat_free;

   protected ComboBox *cm_preset;
   protected Button   *bt_preset_load;
   protected Button   *bt_preset_save;
   static StringArray preset_names;
   public String last_preset_name = "new preset";
   protected NMM_SavePresetDialog *dlg_preset_save;

   // Macro Ctl:
   protected TextField   *tf_m1_name;
   protected NMM_ArgForm *af_m1;

   protected TextField   *tf_m2_name;
   protected NMM_ArgForm *af_m2;

   protected TextField   *tf_m3_name;
   protected NMM_ArgForm *af_m3;

   protected TextField   *tf_m4_name;
   protected NMM_ArgForm *af_m4;


   // Entries:
   protected TableView     *tv_entries;
   protected NMM_EntriesTM *tm_entries;

   protected Button *bt_new;
   protected Button *bt_delete;
   protected Button *bt_moveup;
   protected Button *bt_movedown;
   protected Button *bt_copy;
   protected Button *bt_paste;
   protected PopupMenu *pm_paste;
   protected Button *bt_script;
   protected CheckBox *cb_show_all_args;
   protected CheckBox *cb_poly;
   protected CheckBox *cb_event;
   protected FloatParamTicks *fp_tickmodulo;

   protected TextField *tf_en_name;
   protected CheckBox *cb_op;
   protected ComboBox *cm_op;
   protected LayerSwitch *ls_op;

   // 0:Op:Copy
   protected ComboBox *cm_op_copy_src;

   // 1:Op:Test
   protected ComboBox *cm_op_test_src;

   // 2:Op:Not
   protected ComboBox *cm_op_not_src;

   // 3:Op:Add
   protected ComboBox *cm_op_add_src1;
   protected ComboBox *cm_op_add_src2;

   // 4:Op:Sub
   protected ComboBox *cm_op_sub_src1;
   protected ComboBox *cm_op_sub_src2;

   // 5:Op:Mix
   protected ComboBox *cm_op_mix_src1;
   protected ComboBox *cm_op_mix_src2;
   protected ComboBox *cm_op_mix_src3;
   protected ComboBox *cm_op_mix_src4;

   // 6:Op:Mul
   protected ComboBox *cm_op_mul_src;
   protected ComboBox *cm_op_mul_mul1;
   protected ComboBox *cm_op_mul_mul2;

   // 7:Op:Mul/Div
   protected ComboBox *cm_op_muldiv_src;
   protected ComboBox *cm_op_muldiv_mul;
   protected ComboBox *cm_op_muldiv_div;

   // 8:Op:Blend
   protected ComboBox *cm_op_blend_src1;
   protected ComboBox *cm_op_blend_src2;
   protected ComboBox *cm_op_blend_src3;
   protected ComboBox *cm_op_blend_src4;

   // 9:Op:Scale From
   protected ComboBox *cm_op_scalefrom_src;
   protected ComboBox *cm_op_scalefrom_lo;
   protected ComboBox *cm_op_scalefrom_hi;

   // 10:Op:Scale To
   protected ComboBox *cm_op_scaleto_src;
   protected ComboBox *cm_op_scaleto_lo;
   protected ComboBox *cm_op_scaleto_hi;

   // 11:Op:And
   protected ComboBox *cm_op_and_src1;
   protected ComboBox *cm_op_and_src2;

   // 12:Op:Or
   protected ComboBox *cm_op_or_src1;
   protected ComboBox *cm_op_or_src2;

   // 13:Op:Eor
   protected ComboBox *cm_op_eor_src1;
   protected ComboBox *cm_op_eor_src2;

   // 14:Op:Mod
   protected ComboBox *cm_op_mod_src1;
   protected ComboBox *cm_op_mod_src2;

   // 15:Op:Mod/Div
   protected ComboBox *cm_op_moddiv_src1;
   protected ComboBox *cm_op_moddiv_src2;
   protected ComboBox *cm_op_moddiv_src3;

   // 16:Op:Step
   protected ComboBox *cm_op_step_src;
   protected ComboBox *cm_op_step_num;

   // 17:Op:Sin
   protected ComboBox *cm_op_sin_ang1;
   protected ComboBox *cm_op_sin_ang2;
   protected ComboBox *cm_op_sin_scl;
   protected ComboBox *cm_op_sin_off;

   // 18:Op:Tri
   protected ComboBox *cm_op_tri_ang1;
   protected ComboBox *cm_op_tri_ang2;
   protected ComboBox *cm_op_tri_scl;
   protected ComboBox *cm_op_tri_off;

   // 19:Op:Clamp
   protected ComboBox *cm_op_clamp_src;
   protected ComboBox *cm_op_clamp_lo;
   protected ComboBox *cm_op_clamp_hi;

   // 20:Op:Clamp
   protected ComboBox *cm_op_wrap_src;
   protected ComboBox *cm_op_wrap_lo;
   protected ComboBox *cm_op_wrap_hi;

   // 21:Op:Select ==
   protected ComboBox *cm_op_selecteq_src1;
   protected ComboBox *cm_op_selecteq_src2;
   protected ComboBox *cm_op_selecteq_pass;
   protected ComboBox *cm_op_selecteq_fail;

   // 22:Op:Select !=
   protected ComboBox *cm_op_selectne_src1;
   protected ComboBox *cm_op_selectne_src2;
   protected ComboBox *cm_op_selectne_pass;
   protected ComboBox *cm_op_selectne_fail;

   // 23:Op:Select <
   protected ComboBox *cm_op_selectlt_src1;
   protected ComboBox *cm_op_selectlt_src2;
   protected ComboBox *cm_op_selectlt_pass;
   protected ComboBox *cm_op_selectlt_fail;

   // 24:Op:Select <=
   protected ComboBox *cm_op_selectle_src1;
   protected ComboBox *cm_op_selectle_src2;
   protected ComboBox *cm_op_selectle_pass;
   protected ComboBox *cm_op_selectle_fail;

   // 25:Op:Select >
   protected ComboBox *cm_op_selectgt_src1;
   protected ComboBox *cm_op_selectgt_src2;
   protected ComboBox *cm_op_selectgt_pass;
   protected ComboBox *cm_op_selectgt_fail;

   // 26:Op:Select >=
   protected ComboBox *cm_op_selectge_src1;
   protected ComboBox *cm_op_selectge_src2;
   protected ComboBox *cm_op_selectge_pass;
   protected ComboBox *cm_op_selectge_fail;

   // 27:Op:Select &&
   protected ComboBox *cm_op_selectand_src1;
   protected ComboBox *cm_op_selectand_src2;
   protected ComboBox *cm_op_selectand_pass;
   protected ComboBox *cm_op_selectand_fail;

   // 28:Op:Select ||
   protected ComboBox *cm_op_selector_src1;
   protected ComboBox *cm_op_selector_src2;
   protected ComboBox *cm_op_selector_pass;
   protected ComboBox *cm_op_selector_fail;

   // 29:Op:Select ^^
   protected ComboBox *cm_op_selecteor_src1;
   protected ComboBox *cm_op_selecteor_src2;
   protected ComboBox *cm_op_selecteor_pass;
   protected ComboBox *cm_op_selecteor_fail;

   // 30:Op:Pow
   protected ComboBox *cm_op_pow_src1;
   protected ComboBox *cm_op_pow_src2;

   // 31:Op:Sqrt
   protected ComboBox *cm_op_sqrt_src1;

   // 32:Op:Log
   protected ComboBox *cm_op_log_src1;
   protected ComboBox *cm_op_log_src2;

   // 33:Op:Range Out
   protected ComboBox *cm_op_rangeout_min;
   protected ComboBox *cm_op_rangeout_in;
   protected ComboBox *cm_op_rangeout_max;
   protected ComboBox *cm_op_rangeout_fail;

   // 34:Op:Range In
   protected ComboBox *cm_op_rangein_min;
   protected ComboBox *cm_op_rangein_in;
   protected ComboBox *cm_op_rangein_max;
   protected ComboBox *cm_op_rangein_fail;

   // 35:Op:IDiv/Mul
   protected ComboBox *cm_op_idivmul_src;
   protected ComboBox *cm_op_idivmul_div;
   protected ComboBox *cm_op_idivmul_mul;

   // 36:Op:ScaleIdxOct
   protected ComboBox *cm_op_scaleidxoct_idx;
   protected ComboBox *cm_op_scaleidxoct_key;
   protected ComboBox *cm_op_scaleidxoct_mode;

   // 37:Op:WhiteToIdx
   protected ComboBox *cm_op_whitetoidx_note;
   protected ComboBox *cm_op_whitetoidx_base;

   // 38:Op:ScaleIdxRep
   protected ComboBox *cm_op_scaleidxrep_idx;
   protected ComboBox *cm_op_scaleidxrep_key;
   protected ComboBox *cm_op_scaleidxrep_mode;

   // 39:Op:ScaleNoteUp
   protected ComboBox *cm_op_scalenoteup_idx;
   protected ComboBox *cm_op_scalenoteup_key;
   protected ComboBox *cm_op_scalenoteup_mode;

   // 40:Op:ScaleNoteDown
   protected ComboBox *cm_op_scalenotedown_idx;
   protected ComboBox *cm_op_scalenotedown_key;
   protected ComboBox *cm_op_scalenotedown_mode;

   // 41:Op:ScaleNoteDrop
   protected ComboBox *cm_op_scalenotedrop_idx;
   protected ComboBox *cm_op_scalenotedrop_key;
   protected ComboBox *cm_op_scalenotedrop_mode;

   // 42:Op:PanLinear_L
   protected ComboBox *cm_op_panlinearl_min;
   protected ComboBox *cm_op_panlinearl_max;
   protected ComboBox *cm_op_panlinearl_pan;

   // 43:Op:PanLinear_R
   protected ComboBox *cm_op_panlinearr_min;
   protected ComboBox *cm_op_panlinearr_max;
   protected ComboBox *cm_op_panlinearr_pan;

   // 44:Op:PanLerp_L
   protected ComboBox *cm_op_panlerpl_min;
   protected ComboBox *cm_op_panlerpl_max;
   protected ComboBox *cm_op_panlerpl_pan;

   // 45:Op:PanLerp_R
   protected ComboBox *cm_op_panlerpr_min;
   protected ComboBox *cm_op_panlerpr_max;
   protected ComboBox *cm_op_panlerpr_pan;

   // 46:Op:PanSqrt_L
   protected ComboBox *cm_op_pansqrtl_min;
   protected ComboBox *cm_op_pansqrtl_max;
   protected ComboBox *cm_op_pansqrtl_pan;

   // 47:Op:PanSqrt_R
   protected ComboBox *cm_op_pansqrtr_min;
   protected ComboBox *cm_op_pansqrtr_max;
   protected ComboBox *cm_op_pansqrtr_pan;

   // 48:Op:PanCos_L
   protected ComboBox *cm_op_pancosl_min;
   protected ComboBox *cm_op_pancosl_max;
   protected ComboBox *cm_op_pancosl_pan;

   // 49:Op:PanCos_R
   protected ComboBox *cm_op_pancosr_min;
   protected ComboBox *cm_op_pancosr_max;
   protected ComboBox *cm_op_pancosr_pan;

   // 50:Op:PanPow_L
   protected ComboBox *cm_op_panpowl_min;
   protected ComboBox *cm_op_panpowl_max;
   protected ComboBox *cm_op_panpowl_pan;

   // 51:Op:PanPow_R
   protected ComboBox *cm_op_panpowr_min;
   protected ComboBox *cm_op_panpowr_max;
   protected ComboBox *cm_op_panpowr_pan;

   // 52:Op:NegHarmony
   protected ComboBox *cm_op_negharmony_note;
   protected ComboBox *cm_op_negharmony_key;

   // 53:Op:Curve
   protected ComboBox *cm_op_curve_mode;
   protected ComboBox *cm_op_curve_idx;
   protected ComboBox *cm_op_curve_x;

   // 54:Op:Slew
   protected ComboBox *cm_op_slew_dval;
   protected ComboBox *cm_op_slew_amtup;
   protected ComboBox *cm_op_slew_amtdn;


   protected ComboBox *cm_op_arg1; // ref to cm_op_*_*
   protected ComboBox *cm_op_arg2; // ref to cm_op_*_*
   protected ComboBox *cm_op_arg3; // ref to cm_op_*_*
   protected ComboBox *cm_op_arg4; // ref to cm_op_*_*


   protected NMM_ArgForm *af_dst;
   protected LayerSwitch *ls_arg_1;
   protected NMM_ArgForm *af_arg_1;
   protected LayerSwitch *ls_arg_2;
   protected NMM_ArgForm *af_arg_2;
   protected LayerSwitch *ls_arg_3;
   protected NMM_ArgForm *af_arg_3;
   protected LayerSwitch *ls_arg_4;
   protected NMM_ArgForm *af_arg_4;

   // Curves
   protected Panel *p_curves;
   protected CurveForm *[] f_curves;   // CurveForm refs
   protected LayerSwitch *[] ls_curves;  // LayerSwitch refs

   // Play:
   protected ComboBox *cm_node_class;
   protected CheckBox *cb_node_class_show;
   // (note) cm_node_class_show_in is declared in NodeEditor base class

   protected NMM_ScriptDialog *dlg_script;

   static NMM_Entry *en_clipboard;

   protected NMM_ScriptEntryDialog *dlg_entry_script;
   protected String last_script;

   // temporary, while parsing script:
   StringArray script_words;
   int script_word_idx;
   int script_word_last_idx;
   int script_line_idx;
   int script_error_line_idx;

   protected boolean b_signal_tap;  // true when any arg/dst has a signal tap


   // <init.png>
   public virtual init() : boolean {

      if(initPakFile("NodeModMatrixEditor.xfm"))
      {
         if(autoResolveIds(this))
         {
            f_autodev.initAutoDeviceForm();

            // Pattern:
            cm_pattern_nr.setOptions(Node.patnr_options);

            // Entries:
            tm_entries <= new NMM_EntriesTM;
            tm_entries.parent_editor <= this;
            tm_entries.initTableModel();
            tv_entries.setTableModel(tm_entries);

            cm_op.setOptions(NMM_Entry.op_names);
            cm_op.setToolTipCaptions(NMM_Entry.op_tooltips);

            if(!af_m1.init(this, false/*bDst*/, true/*bMacro*/))
               return false;

            if(!af_m2.init(this, false/*bDst*/, true/*bMacro*/))
               return false;

            if(!af_m3.init(this, false/*bDst*/, true/*bMacro*/))
               return false;

            if(!af_m4.init(this, false/*bDst*/, true/*bMacro*/))
               return false;

            if(!af_dst.init(this, true/*bDst*/, false/*bMacro*/))
               return false;

            if(!af_arg_1.init(this, false/*bDst*/, false/*bMacro*/))
               return false;

            if(!af_arg_2.init(this, false/*bDst*/, false/*bMacro*/))
               return false;

            if(!af_arg_3.init(this, false/*bDst*/, false/*bMacro*/))
               return false;

            if(!af_arg_4.init(this, false/*bDst*/, false/*bMacro*/))
               return false;

            Label lbEnLBC1 <= findLayerById("lb_en_lbc1");
            int lbW = lbEnLBC1.getPreferredSizeX();
            af_m1.setSignalTapSizeX(lbW);
            af_m2.setSignalTapSizeX(lbW);
            af_m3.setSignalTapSizeX(lbW);
            af_m4.setSignalTapSizeX(lbW);

            // Curves:
            int curveIdx = 0;
            loop(NMM_Pattern.NUM_CURVES)
            {
               CurveForm curveForm <= findLayerById("f_curve_"+curveIdx);
               if(!curveForm.initCurveForm())
               {
                  trace "[---] NodeModMatrixEditor::init: initCurveForm() failed";
                  return false;
               }
               curveForm.setEnableCopyPasteKeys(false);  // leave lctrl-c/v to node editor (c'n'p patterns)
               f_curves.add(curveForm);
               LayerSwitch lsCurve <= findLayerById("ls_curve_"+curveIdx);
               ls_curves.add(lsCurve);
               curveIdx++;
            }

            // Play:

            ts_groups.setActiveTabIndex(TAB_ENTRIES);

            RescanPresets();
            cm_preset.setOptions(preset_names);

            en_clipboard <= new NMM_Entry;
            en_clipboard.init(null/*parentPat*/);

            if(initDialogs())
            {
               initMMC();

               initTimers();

               return true;
            }
         }
      }

      return false;
   }

   // <ui_timer.png>
   protected method initTimers() {
      ta_update_args   <= TimerAction.New(TA_UPDATE_ARGS,   this, UPDATE_ARGS_NOTAP_MS);
      ta_capture_args  <= TimerAction.New(TA_CAPTURE_ARGS,  this, 5);
   }

   // <ui_init.png>
   protected method initDialogs() : boolean {

      if(!initScriptDialog())
      {
         return false;
      }

      return true;
   }

   // <ui_init.png>
   protected method initScriptDialog() : boolean {
      dlg_script <= new NMM_ScriptDialog();
      if(!dlg_script.init(this))
      {
         Global.Error("NMM_ScriptDialog::init() failed");
         return false;
      }
      return true;
   }

   // <midi_mmc.png>
   protected method initMMC() {

      mmcInit("NodeModMatrixEditor");

      // From PageNode: (so these show up in the map editor)
      root_form.pg_node.addBaseMMCTargets(this);

      mmcAddTarget(MMT_TAB_PREV,       CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_TAB_NEXT,       CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_TAB_PATTERN,    CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TAB_MACROCTL,   CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TAB_ENTRIES,    CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_TAB_PLAY,       CLASS_BUTTON, SYN_BUTTON_CLICK);

      mmcAddTargetExO(MMT_PAT_NR,                  CLASS_VALUE,  SYN_NONE,
                      "Pattern", "Pattern Number", DPY_DEFAULT, cm_pattern_nr
                      );
      mmcAddTargetExO(MMT_PAT_NR_INV,              CLASS_VALUE,  SYN_NONE,
                      "Pattern", "Pattern Number", DPY_DEFAULT, cm_pattern_nr
                      );
      mmcAddTargetExO(MMT_PAT_NR_DELTA,            CLASS_DELTA,  4,
                      "Pattern", "Pattern Number", DPY_DEFAULT, cm_pattern_nr
                      );
      mmcAddTarget(MMT_PAT_NR_INC,            CLASS_BUTTON, SYN_BUTTON_REPEAT);
      mmcAddTarget(MMT_PAT_NR_DEC,            CLASS_BUTTON, SYN_BUTTON_REPEAT);

      mmcAddTarget(MMT_PAT_NR_1,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_2,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_3,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_4,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_5,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_6,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_7,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_8,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_9,              CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_10,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_11,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_12,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_13,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_14,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_15,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_16,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_17,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_18,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_19,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_20,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_21,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_22,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_23,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_24,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_25,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_26,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_27,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_28,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_29,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_30,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_31,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_32,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_33,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_34,             CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_NR_35,             CLASS_BUTTON, SYN_BUTTON_CLICK);

      // New/Copy/Paste/Clone/Free (pat_tools)
      mmcAddTarget(MMT_PAT_NEW,            CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_COPY,           CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_PASTE,          CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_CLONE,          CLASS_BUTTON, SYN_BUTTON_CLICK);
      mmcAddTarget(MMT_PAT_FREE,           CLASS_BUTTON, SYN_BUTTON_CLICK);


      // Play

   }

   // <midi_mmc.png>
   public virtual mmcHandleEvent(MIDIMapEvent _ev) : boolean {

      ///trace "xxx NodeModMatrixEditor::mmcHandleEvent";

      if(!mmcIsBindableEvent(_ev))
         return false;

      MIDIMapEvent boundEv <= mmcGetBindingByEvent(_ev);

      NMM_Pattern pat <= getEditPattern();

      if(null != boundEv)
      {
         String tgtName <= boundEv.bound_target.target_name;

         switch(tgtName)
         {
            default:
               return root_form.pg_node.mmcHandleNodeTarget(boundEv.bound_target.target_name);

            case MMT_TAB_PREV:
               ts_groups.previousTab();
               return true;

            case MMT_TAB_NEXT:
               ts_groups.nextTab();
               return true;

            case MMT_TAB_PATTERN:
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               if(null != pat)
               {
                  Global.Print("Show tab \"Pattern\" ("+cm_pattern_nr.getSelectedOptionName()+") \""+pat.pat_name+"\"");
               }
               else
               {
                  Global.Print("Show tab \"Pattern\" ("+cm_pattern_nr.getSelectedOptionName()+") <empty>");
               }
               return true;

            case MMT_TAB_MACROCTL:
               ts_groups.setActiveTabIndex(TAB_MACROCTL);
               Global.Print("Show tab \"Macro Ctl\"");
               return true;

            case MMT_TAB_ENTRIES:
               ts_groups.setActiveTabIndex(TAB_ENTRIES);
               Global.Print("Show tab \"Entries\"");
               return true;

            case MMT_TAB_PLAY:
               ts_groups.setActiveTabIndex(TAB_PLAY);
               Global.Print("Show tab \"Play\"");
               return true;

            case MMT_PAT_NR:
            case MMT_PAT_NR_DELTA:
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               MMTListener.MMTHandleLayerEvent(cm_pattern_nr, _ev, false/*bInv*/);
               return true;

            case MMT_PAT_NR_INV:
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               MMTListener.MMTHandleLayerEvent(cm_pattern_nr, _ev, true/*bInv*/);
               return true;

            case MMT_PAT_NR_INC:
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               MMTListener.MMTHandleLayerInc(cm_pattern_nr);
               return true;

            case MMT_PAT_NR_DEC:
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               MMTListener.MMTHandleLayerDec(cm_pattern_nr);
               return true;

            case MMT_PAT_NR_1:
            case MMT_PAT_NR_2:
            case MMT_PAT_NR_3:
            case MMT_PAT_NR_4:
            case MMT_PAT_NR_5:
            case MMT_PAT_NR_6:
            case MMT_PAT_NR_7:
            case MMT_PAT_NR_8:
            case MMT_PAT_NR_9:
            case MMT_PAT_NR_10:
            case MMT_PAT_NR_11:
            case MMT_PAT_NR_12:
            case MMT_PAT_NR_13:
            case MMT_PAT_NR_14:
            case MMT_PAT_NR_15:
            case MMT_PAT_NR_16:
            case MMT_PAT_NR_17:
            case MMT_PAT_NR_18:
            case MMT_PAT_NR_19:
            case MMT_PAT_NR_20:
            case MMT_PAT_NR_21:
            case MMT_PAT_NR_22:
            case MMT_PAT_NR_23:
            case MMT_PAT_NR_24:
            case MMT_PAT_NR_25:
            case MMT_PAT_NR_26:
            case MMT_PAT_NR_27:
            case MMT_PAT_NR_28:
            case MMT_PAT_NR_29:
            case MMT_PAT_NR_30:
            case MMT_PAT_NR_31:
            case MMT_PAT_NR_32:
            case MMT_PAT_NR_33:
            case MMT_PAT_NR_34:
            case MMT_PAT_NR_35:
               selectPatternByIdx(int(boundEv.bound_target.target_name.replace("MMT_PAT_NR_", "")) - 1);
               return true;

            case MMT_PAT_NEW:
               handlePatternAlloc(false/*bSub*/);
               return true;

            case MMT_PAT_COPY:
               handlePatternCopy();
               return true;

            case MMT_PAT_PASTE:
               handlePatternPaste();
               return true;

            case MMT_PAT_CLONE:
               handlePatternClone(false/*bSub*/);
               return true;

            case MMT_PAT_FREE:
               handlePatternFree();
               return true;


               // Play
         }
      }

      // trace "xxx NodeModMatrixEditor::mmcHandleEvent: unhandled";

      return false;
   }

   // <ui_kbd.png>
   public virtual addTabCycleOverrides(PointerArray layers) {

      switch(ts_groups.getActiveTabIndex())
      {
         case TAB_PATTERN:
            layers.joinRR(layers,
                          [
                             ts_groups,

                             cm_pattern_nr,
                             tf_pat_name,
                             bt_pat_alloc,
                             bt_pat_tools,
                             bt_pat_free
                           ]
                          );
            return layers;

         case TAB_MACROCTL:
            layers.add(ts_groups);
            layers.add(tf_m1_name);
            af_m1.addTabCycleOverrides(layers);
            layers.add(tf_m2_name);
            af_m2.addTabCycleOverrides(layers);
            layers.add(tf_m3_name);
            af_m3.addTabCycleOverrides(layers);
            layers.add(tf_m4_name);
            af_m4.addTabCycleOverrides(layers);
            return layers;

         case TAB_ENTRIES:
            layers.joinRR(layers,
                          [
                             ts_groups,
                             tv_entries,
                             bt_new,
                             bt_delete,
                             bt_moveup,
                             bt_movedown,
                             bt_copy,
                             bt_paste,
                             bt_script,
                             cb_poly,
                             cb_event,
                             fp_tickmodulo,
                             cb_show_all_args,
                             tf_en_name,
                             cb_op,
                             cm_op
                           ]
                          );

            if(null != getSelectedEntry())
            {
               boolean bShowAllArgs = cb_show_all_args.isSelected();
               int numRefArgs = getNumRefArgs();

               if(null != cm_op_arg1)
               {
                  layers.add(cm_op_arg1);
               }

               if(null != cm_op_arg2)
               {
                  layers.add(cm_op_arg2);
               }

               if(null != cm_op_arg3)
               {
                  layers.add(cm_op_arg3);
               }

               if(null != cm_op_arg4)
               {
                  layers.add(cm_op_arg4);
               }

               af_dst.addTabCycleOverrides(layers);

               if(bShowAllArgs || (numRefArgs >= 1))
               {
                  af_arg_1.addTabCycleOverrides(layers);
               }
               if(bShowAllArgs || (numRefArgs >= 2))
               {
                  af_arg_2.addTabCycleOverrides(layers);
               }

               if(bShowAllArgs || (numRefArgs >= 3))
               {
                  af_arg_3.addTabCycleOverrides(layers);
               }

               if(bShowAllArgs || (numRefArgs >= 4))
               {
                  af_arg_4.addTabCycleOverrides(layers);
               }

            }

            return layers;

         case TAB_PLAY:
            layers.joinRR(layers,
                          [
                             ts_groups,

                             cm_node_class,
                             cb_node_class_show,
                             cm_node_class_show_in,
                           ]
                          );
            f_autodev.addTabCycleOverrides(layers);
            return layers;
      }
   }

   // <ui_show.png>
   public virtual showNode(Node _modmatrix) {
      modmatrix <= _modmatrix;

      // Pattern:
      updatePatternNrComboBox();
      cm_pattern_nr.setSelectedOption(modmatrix.nodeGetCurrentEditPatternNr());

      tm_entries.parent_node <= this;

      handlePatternChanged();

      // Play:
      StringArray devAll;
      devAll.join(["*"], MIDI.out_device_names_sorted);
      IntArray bgcolorsAll;
      bgcolorsAll.join([0], MIDI.out_device_bgcolors_sorted);

      f_autodev.showNode(modmatrix, devAll, bgcolorsAll);

      cm_node_class.setOptions(STConfig.node_class_names);
      updateNodeClass();
      updateNodeClassShowIn(modmatrix);

      MIDI.AddMIDIMapEventListener(this);
   }

   // <method.png>
   protected method fixArgLayout() {
      ts_groups.relayoutActiveTab();
   }

   // <method.png>
   public virtual showNodePost() {
      // trace "xxx pn_root size="+pn_root.getSizeString()+" minSize="+pn_root.getMinimumSizeString()+" prefSize="+pn_root.getPreferredSizeString();

      handlePatternChanged();

      ta_update_args.schedule();
      ta_capture_args.schedule();

      fixArgLayout();
      redraw();

      updateBezierOverlays();

      refocusDefault();
   }

   // <ui_focus.png>
   public virtual refocusDefault() {
      if(!NodeEditor.b_lock_kbdfocus)
      {
         if(TAB_ENTRIES == ts_groups.getActiveTabIndex())
         {
            UI.SetKeyboardFocus(tv_entries);
         }
         else
         {
            UI.SetKeyboardFocus(ts_groups);
         }
      }
   }

   // <ui_update.png>
   protected method updatePatternNrComboBox() {
      local StringArray patNrOptionsShort;
      local StringArray patNrOptionsLong;
      local IntArray patNrColors;
      Node.CalcPatNrOptions(modmatrix, patNrOptionsShort, patNrOptionsLong, patNrColors);
      cm_pattern_nr.setOptions(patNrOptionsShort);
      cm_pattern_nr.setOptionsLong(patNrOptionsLong);
      cm_pattern_nr.setOptionBGColors(patNrColors);
   }

   // <method_get.png>
   public method getEditPattern() : NMM_Pattern {
      if(null != modmatrix)
      {
         NMM_Pattern pat <= modmatrix.nodeGetCurrentEditPattern();
         return pat;
      }
      return null;
   }

   // <ui_hide.png>
   public virtual leaveNode() {
      MIDI.RemoveMIDIMapEventListener(this);
      stopAllMIDILearnExcept(null);
      ta_update_args.cancel();
      ta_capture_args.cancel();
      removeBezierOverlays();

      int curveIdx = 0;
      loop(NMM_Pattern.NUM_CURVES)
      {
         CurveForm curveForm <= f_curves.get(curveIdx++);
         curveForm.stopEditing();
      }
   }

   // <ui_hide.png>
   public virtual unsetNode() {
      modmatrix <= null;
   }

   // <midi_mmt.png>
   public virtual mmtHandleGlobalValue(float _val) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();
      return false;
   }

   // <midi_mmt.png>
   public virtual mmtHandleGlobalValueDelta(int _delta) : boolean {
      Layer kbdLayer <= UI.GetKeyboardFocus();
      return false;
   }

   // <midi_mml.png>
   public virtual mmlHandleEventUI(MIDIMapEvent _ev) : boolean {

      if(_ev.isReservedEvent())
         return false;

      MIDIMapEvent evXForm = _ev;
      MIDIMorphScene.TransformEvent(evXForm);
      if(evXForm.isValid())
      {
         evXForm.echoTransformForced();

         if(af_m1.mmlHandleEventUI(evXForm))
            return true;

         if(af_m2.mmlHandleEventUI(evXForm))
            return true;

         if(af_m3.mmlHandleEventUI(evXForm))
            return true;

         if(af_m4.mmlHandleEventUI(evXForm))
            return true;

         if(af_dst.mmlHandleEventUI(evXForm))
            return true;

         if(af_arg_1.mmlHandleEventUI(evXForm))
            return true;

         if(af_arg_2.mmlHandleEventUI(evXForm))
            return true;

         if(af_arg_3.mmlHandleEventUI(evXForm))
            return true;

         if(af_arg_4.mmlHandleEventUI(evXForm))
            return true;
      }

      return false;
   }

   // <method_get.png>
   protected method getSelectedEntry() : NMM_Entry {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         int idx = tm_entries.getCursorIndex();

         if(-1 != idx)
         {
            return pat.getEntry(idx);
         }
      }

      return null;
   }

   // <method_get.png>
   protected method getNumRefArgsCMMax(int _ret, ComboBox _cm) : int {
      if(null != _cm)
      {
         int cmArg = _cm.getSelectedOption();

         if(1 <= cmArg <= 4)
         {
            _ret = mathMaxi(_ret, cmArg);
         }
      }
      return _ret;
   }

   // <method_get.png>
   protected method getNumRefArgs() : int {
      int ret = 0;

      ret = getNumRefArgsCMMax(ret, cm_op_arg1);
      ret = getNumRefArgsCMMax(ret, cm_op_arg2);
      ret = getNumRefArgsCMMax(ret, cm_op_arg3);
      ret = getNumRefArgsCMMax(ret, cm_op_arg4);

      return ret;
   }

   // <method.png>
   protected method setOpArgsEditable(boolean _bEditable) {
      cm_op_copy_src.setEditable(_bEditable);
      cm_op_test_src.setEditable(_bEditable);
      cm_op_not_src.setEditable(_bEditable);

      cm_op_add_src1.setEditable(_bEditable);
      cm_op_add_src2.setEditable(_bEditable);

      cm_op_sub_src1.setEditable(_bEditable);
      cm_op_sub_src2.setEditable(_bEditable);

      cm_op_mix_src1.setEditable(_bEditable);
      cm_op_mix_src2.setEditable(_bEditable);
      cm_op_mix_src3.setEditable(_bEditable);
      cm_op_mix_src4.setEditable(_bEditable);

      cm_op_mul_src.setEditable(_bEditable);
      cm_op_mul_mul1.setEditable(_bEditable);
      cm_op_mul_mul2.setEditable(_bEditable);

      cm_op_muldiv_src.setEditable(_bEditable);
      cm_op_muldiv_mul.setEditable(_bEditable);
      cm_op_muldiv_div.setEditable(_bEditable);

      cm_op_blend_src1.setEditable(_bEditable);
      cm_op_blend_src2.setEditable(_bEditable);
      cm_op_blend_src3.setEditable(_bEditable);
      cm_op_blend_src4.setEditable(_bEditable);

      cm_op_scalefrom_src.setEditable(_bEditable);
      cm_op_scalefrom_lo.setEditable(_bEditable);
      cm_op_scalefrom_hi.setEditable(_bEditable);

      cm_op_scaleto_src.setEditable(_bEditable);
      cm_op_scaleto_lo.setEditable(_bEditable);
      cm_op_scaleto_hi.setEditable(_bEditable);

      cm_op_and_src1.setEditable(_bEditable);
      cm_op_and_src2.setEditable(_bEditable);

      cm_op_or_src1.setEditable(_bEditable);
      cm_op_or_src2.setEditable(_bEditable);

      cm_op_eor_src1.setEditable(_bEditable);
      cm_op_eor_src2.setEditable(_bEditable);

      cm_op_mod_src1.setEditable(_bEditable);
      cm_op_mod_src2.setEditable(_bEditable);

      cm_op_moddiv_src1.setEditable(_bEditable);
      cm_op_moddiv_src2.setEditable(_bEditable);

      cm_op_step_src.setEditable(_bEditable);
      cm_op_step_num.setEditable(_bEditable);

      cm_op_sin_ang1.setEditable(_bEditable);
      cm_op_sin_ang2.setEditable(_bEditable);
      cm_op_sin_scl.setEditable(_bEditable);
      cm_op_sin_off.setEditable(_bEditable);

      cm_op_tri_ang1.setEditable(_bEditable);
      cm_op_tri_ang2.setEditable(_bEditable);
      cm_op_tri_scl.setEditable(_bEditable);
      cm_op_tri_off.setEditable(_bEditable);

      cm_op_clamp_src.setEditable(_bEditable);
      cm_op_clamp_lo.setEditable(_bEditable);
      cm_op_clamp_hi.setEditable(_bEditable);

      cm_op_wrap_src.setEditable(_bEditable);
      cm_op_wrap_lo.setEditable(_bEditable);
      cm_op_wrap_hi.setEditable(_bEditable);

      cm_op_selecteq_src1.setEditable(_bEditable);
      cm_op_selecteq_src2.setEditable(_bEditable);
      cm_op_selecteq_pass.setEditable(_bEditable);
      cm_op_selecteq_fail.setEditable(_bEditable);

      cm_op_selectne_src1.setEditable(_bEditable);
      cm_op_selectne_src2.setEditable(_bEditable);
      cm_op_selectne_pass.setEditable(_bEditable);
      cm_op_selectne_fail.setEditable(_bEditable);

      cm_op_selectlt_src1.setEditable(_bEditable);
      cm_op_selectlt_src2.setEditable(_bEditable);
      cm_op_selectlt_pass.setEditable(_bEditable);
      cm_op_selectlt_fail.setEditable(_bEditable);

      cm_op_selectle_src1.setEditable(_bEditable);
      cm_op_selectle_src2.setEditable(_bEditable);
      cm_op_selectle_pass.setEditable(_bEditable);
      cm_op_selectle_fail.setEditable(_bEditable);

      cm_op_selectgt_src1.setEditable(_bEditable);
      cm_op_selectgt_src2.setEditable(_bEditable);
      cm_op_selectgt_pass.setEditable(_bEditable);
      cm_op_selectgt_fail.setEditable(_bEditable);

      cm_op_selectge_src1.setEditable(_bEditable);
      cm_op_selectge_src2.setEditable(_bEditable);
      cm_op_selectge_pass.setEditable(_bEditable);
      cm_op_selectge_fail.setEditable(_bEditable);

      cm_op_selectand_src1.setEditable(_bEditable);
      cm_op_selectand_src2.setEditable(_bEditable);
      cm_op_selectand_pass.setEditable(_bEditable);
      cm_op_selectand_fail.setEditable(_bEditable);

      cm_op_selector_src1.setEditable(_bEditable);
      cm_op_selector_src2.setEditable(_bEditable);
      cm_op_selector_pass.setEditable(_bEditable);
      cm_op_selector_fail.setEditable(_bEditable);

      cm_op_selecteor_src1.setEditable(_bEditable);
      cm_op_selecteor_src2.setEditable(_bEditable);
      cm_op_selecteor_pass.setEditable(_bEditable);
      cm_op_selecteor_fail.setEditable(_bEditable);

      cm_op_panlinearl_min.setEditable(_bEditable);
      cm_op_panlinearl_max.setEditable(_bEditable);
      cm_op_panlinearl_pan.setEditable(_bEditable);

      cm_op_panlinearr_min.setEditable(_bEditable);
      cm_op_panlinearr_max.setEditable(_bEditable);
      cm_op_panlinearr_pan.setEditable(_bEditable);

      cm_op_panlerpl_min.setEditable(_bEditable);
      cm_op_panlerpl_max.setEditable(_bEditable);
      cm_op_panlerpl_pan.setEditable(_bEditable);

      cm_op_panlerpr_min.setEditable(_bEditable);
      cm_op_panlerpr_max.setEditable(_bEditable);
      cm_op_panlerpr_pan.setEditable(_bEditable);

      cm_op_pansqrtl_min.setEditable(_bEditable);
      cm_op_pansqrtl_max.setEditable(_bEditable);
      cm_op_pansqrtl_pan.setEditable(_bEditable);

      cm_op_pansqrtr_min.setEditable(_bEditable);
      cm_op_pansqrtr_max.setEditable(_bEditable);
      cm_op_pansqrtr_pan.setEditable(_bEditable);

      cm_op_pancosl_min.setEditable(_bEditable);
      cm_op_pancosl_max.setEditable(_bEditable);
      cm_op_pancosl_pan.setEditable(_bEditable);

      cm_op_pancosr_min.setEditable(_bEditable);
      cm_op_pancosr_max.setEditable(_bEditable);
      cm_op_pancosr_pan.setEditable(_bEditable);

      cm_op_panpowl_min.setEditable(_bEditable);
      cm_op_panpowl_max.setEditable(_bEditable);
      cm_op_panpowl_pan.setEditable(_bEditable);

      cm_op_panpowr_min.setEditable(_bEditable);
      cm_op_panpowr_max.setEditable(_bEditable);
      cm_op_panpowr_pan.setEditable(_bEditable);

      cm_op_negharmony_note.setEditable(_bEditable);
      cm_op_negharmony_key .setEditable(_bEditable);

      cm_op_curve_mode.setEditable(_bEditable);
      cm_op_curve_idx .setEditable(_bEditable);
      cm_op_curve_x   .setEditable(_bEditable);

      cm_op_slew_dval.setEditable(_bEditable);
      cm_op_slew_amtup.setEditable(_bEditable);
      cm_op_slew_amtdn.setEditable(_bEditable);
   }

   // <ui_handle.png>
   public virtual nodeHandleEditPatternChanged() {
      handlePatternChanged();
   }

   // <ui_handle.png>
   protected method handlePatternChanged() {
      NMM_Pattern pat <= getEditPattern();

      updatePatNrLabel();

      int curveIdx;
      CurveForm *curveForm;
      LayerSwitch *lsCurve;
      BezierEditState *beState;
      Envelope *beEnv;

      if(null != pat)
      {
         b_signal_tap = false;

         tf_pat_name.setText(pat.pat_name);
         tf_pat_name.setEditable(true);

         af_m1.showArg(pat.arg_m1);
         af_m2.showArg(pat.arg_m2);
         af_m3.showArg(pat.arg_m3);
         af_m4.showArg(pat.arg_m4);

         tf_m1_name.setText(pat.m1_name);
         tf_m2_name.setText(pat.m2_name);
         tf_m3_name.setText(pat.m3_name);
         tf_m4_name.setText(pat.m4_name);
         tf_m1_name.setEditable(true);
         tf_m2_name.setEditable(true);
         tf_m3_name.setEditable(true);
         tf_m4_name.setEditable(true);

         tv_entries .setEditable(true);
         bt_new     .setEditable(true);
         bt_delete  .setEditable(true);
         bt_moveup  .setEditable(true);
         bt_movedown.setEditable(true);
         bt_copy    .setEditable(true);
         bt_paste   .setEditable(true);
         bt_script  .setEditable(true);

         bt_pat_free.setEditable(true);

         bt_preset_save.setEditable(true);

         cb_poly.setSelected(pat.b_poly);
         cb_poly.setEditable(true);

         cb_event.setSelected(pat.b_event);
         cb_event.setEditable(true);

         fp_tickmodulo.setValue(pat.tick_modulo);
         fp_tickmodulo.setEditable(true);

         updateScriptButtonTint(pat);

         curveIdx = 0;
         loop(NMM_Pattern.NUM_CURVES)
         {
            curveForm <= f_curves.get(curveIdx);
            lsCurve <= ls_curves.get(curveIdx);
            lsCurve.switchToLayerNr(1);
            beState <= pat.curve_states.get(curveIdx);
            beEnv <= pat.curve_envs.get(curveIdx);
            curveForm.showCurve(curveIdx+":", beState, beEnv, "replay");

            curveIdx++;
         }
         relayout();
      }
      else
      {
         tf_pat_name.setText("");
         tf_pat_name.setEditable(false);

         af_m1.showArg(null);
         af_m2.showArg(null);
         af_m3.showArg(null);
         af_m4.showArg(null);

         tf_m1_name.setText("");
         tf_m2_name.setText("");
         tf_m3_name.setText("");
         tf_m4_name.setText("");

         tf_m1_name.setEditable(false);
         tf_m2_name.setEditable(false);
         tf_m3_name.setEditable(false);
         tf_m4_name.setEditable(false);

         tv_entries .setEditable(false);
         bt_new     .setEditable(false);
         bt_delete  .setEditable(false);
         bt_moveup  .setEditable(false);
         bt_movedown.setEditable(false);
         bt_copy    .setEditable(false);
         bt_paste   .setEditable(false);
         bt_script  .setEditable(false);
         bt_script.setBackgroundTint(0);

         bt_pat_free.setEditable(false);

         bt_preset_save.setEditable(false);

         cb_poly.setSelectedAndDisable(false);
         cb_event.setSelectedAndDisable(false);
         fp_tickmodulo.setValue(0);
         fp_tickmodulo.setEditable(false);

         // (todo) curves shouldn't be editable when there's no pattern
         curveIdx = 0;
         loop(NMM_Pattern.NUM_CURVES)
         {
            curveForm <= f_curves.get(curveIdx);
            lsCurve <= ls_curves.get(curveIdx);
            lsCurve.switchToLayerNr(1);
            beState <= CurveForm.default_env_state;
            beEnv <= CurveForm.default_env;
            curveForm.showCurve("Null Curve "+(curveIdx+1), beState, beEnv, "replay");
            curveIdx++;
         }
      }

      tv_entries.tableModelChanged();

      if(-1 == tm_entries.getCursorIndex())
      {
         tv_entries.moveCursorToFirstRow();
      }

      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         tf_en_name.setText(en.name);
         tf_en_name.setEditable(true);

         cb_op.setEditable(true);
         cb_op.setSelected(en.b_op);
         cm_op.setEditable(true);
         cm_op.setSelectedOption(en.op);
         handleOpChanged(true/*bQuiet*/, true/*bRelayout*/);

         af_dst.showArg(en.arg_dst);
         af_arg_1.showArg(en.arg_1);
         af_arg_2.showArg(en.arg_2);
         af_arg_3.showArg(en.arg_3);
         af_arg_4.showArg(en.arg_4);

         setOpArgsEditable(true);
      }
      else
      {
         cb_op.setEditable(false);
         cb_op.setSelected(false);
         cm_op.setEditable(false);
         cm_op.setSelectedOption(-1);
         tf_en_name.setEditable(false);
         tf_en_name.setText("");

         setOpArgsEditable(false);

         af_dst.showArg(null);
         af_arg_1.showArg(null);
         af_arg_2.showArg(null);
         af_arg_3.showArg(null);
         af_arg_4.showArg(null);
      }


      redraw();

      root_form.pg_node.handleEditPatternChanged();

      if(null == UI.GetKeyboardFocus())
      {
         // // UI.SetKeyboardFocus(bt_track_midilearn);
      }
   }

   // <ui_update.png>
   protected method updatePatNrLabel() {
      Integer io = modmatrix.nodeGetCurrentEditPatternNr();
      lb_pat_nr.setCaption("Pattern:\n  ("+io.printf("0x%02x")+")");
      lb_pat_nr.redraw();
   }

   // <ui_update.png>
   public method updateScriptButtonTint(NMM_Pattern _pat) {
      if(!_pat.last_script.isBlank())
         bt_script.setBackgroundTint(#1000ff00);
      else
         bt_script.setBackgroundTint(0);
   }

   // <ui_handle.png>
   protected =replay= method handlePatternAlloc(boolean _bSub) : NMM_Pattern {
      local NMM_Pattern p;

      p.patInit(modmatrix, 0/*patNr placeholder*/);

      int patIdx;

      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         if(true == _bSub)
         {
            // Find unused A..D sub pattern
            patIdx = modmatrix.nodeFindFirstUnusedPatternSub(modmatrix.nodeGetCurrentEditPatternNr());
         }
         else
         {
            // Find unused 1..32 pattern group
            patIdx = modmatrix.nodeFindFirstUnusedPatternGroup(modmatrix.nodeGetCurrentEditPatternNr());
         }

         if(-1 == patIdx)
            patIdx = modmatrix.nodeFindFirstUnusedPattern(0);
      }
      else
      {
         patIdx = modmatrix.nodeGetCurrentEditPatternNr();
      }

      if(-1 != patIdx)
      {
         p.pat_nr = patIdx;
         modmatrix.nodeSetPattern(patIdx, deref p);

         modmatrix.nodeSetCurrentEditPatternNr(patIdx);

         ////if(!replay.b_playing)
            modmatrix.nodeSetCurrentPlayPatternNr(patIdx);

         cm_pattern_nr.setSelectedOption(patIdx);

         selectPatternByIdx(patIdx);

         handlePatternChanged();

         updatePatternNrComboBox();

         Global.SuccessShort("New: Allocated pattern "+cm_pattern_nr.getSelectedOptionName()+" ("+(patIdx+1)+").");
         return p;
      }
      else
      {
         Global.Error("New: All patterns in use.");
         return null;
      }
   }

   // <ui_show.png>
   protected method showPatternToolsMenu(boolean _bFocusFirst) {

      pm_pat_tools <= PopupMenu.New(this);
      PopupMenu pm <= pm_pat_tools;
      PopupMenuButton *pmb;

      NMM_Pattern pat <= modmatrix.nodeGetCurrentEditPattern();
      boolean bHavePat = (null != pat);

      pmb <= pm.addDefaultButton("Copy pattern", "copy");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lctrl-c", "");

      pmb <= pm.addDefaultButton("Paste pattern", "paste");
      pmb.setFontByName("big6");
      pmb.setAccelerators("lctrl-v", "");

      if(bHavePat)
         pmb.setActive(null != pat.patGetClipboard());
      else
         pmb.setActive(false);

      pmb <= pm.addDefaultButton("Clone pattern", "clone");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lctrl-r", "");

      pmb <= pm.addDefaultButton("Clone pattern (sub)", "clone_sub");
      pmb.setFontByName("big6");
      pmb.setActive(bHavePat);
      pmb.setAccelerators("lshift-lctrl-r", "");

      pmb <= pm.addDefaultButton("New pattern (sub)", "new_sub");
      pmb.setFontByName("big6");
      pmb.setAccelerators("lshift-lctrl-n", "");

      pm.resizeToMinimum();
      pm.showAboveLayer(bt_pat_tools);
      if(_bFocusFirst)
         pm.focusNextMenuItem();

      Global.Print("Show pattern tools menu.");
   }

   // <ui_handle.png>
   protected method handlePatternCopy() {

      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.patCopyToClipboard();

         Global.Print("Pattern copied to clipboard.");
      }
   }

   // <ui_handle.png>
   protected method handlePatternPaste() {
      NMM_Pattern pat <= getEditPattern();

      if(null == pat)
      {
         handlePatternAlloc(false/*bSub*/);
         pat <= getEditPattern();
      }

      if(null != pat)
      {
         if(pat.patCopyFromClipboard())
         {
            handlePatternChanged();

            updatePatternNrComboBox();

            Global.SuccessShort("Clipboard pasted to pattern.");
         }
      }
   }

   // <ui_handle.png>
   protected =replay= method handlePatternClone(boolean _bSub) {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         local NMM_Pattern tmp;

         tmp.patInit(modmatrix, 0);

         tmp.patCopyFrom(pat, false/*bClear*/);

         if(null != handlePatternAlloc(_bSub))
         {
            pat <= getEditPattern();

            pat.patCopyFrom(tmp, false/*bClear*/);

            handlePatternChanged();

            updatePatternNrComboBox();

            Global.SuccessShort("Pattern cloned to "+cm_pattern_nr.getSelectedOptionName()+".");
         }
      }
   }

   // <ui_handle.png>
   protected method handlePatternFree() {

      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         modmatrix.nodeSetPattern(modmatrix.edit_pattern_nr, null);

         pat <= null;

         handlePatternChanged();

         updatePatternNrComboBox();

         Global.Print("Delete pattern");
      }
   }

   // <ui_handle.png>
   protected method handlePatternClear() {
      local String oldName = modmatrix.nodeGetCurrentEditPatternName();
      handlePatternFree();
      handlePatternAlloc(false/*bSub*/);
      modmatrix.nodeSetCurrentEditPatternName(oldName);
      handlePatternChanged();  // update tf_pattern_name
      updatePatternNrComboBox();
      Global.Print("Clear pattern");
   }

   // <ui_handle.png>
   protected method handleSelectPattern() {

      int patNr = cm_pattern_nr.getSelectedOption();

      modmatrix.nodeSetCurrentEditPatternNr(patNr);
      modmatrix.nodeSetCurrentPlayPatternNr(patNr);

      modmatrix.nodeQueuePrgChgOut(patNr);
      // // replay.handleNodeStateChangedUI(modmatrix, -1/*active*/, patNr/*pat*/);

      handlePatternChanged();

      NMM_Pattern pat <= getEditPattern();

      // trace "xxx selectscene: modmatrix.nodeGetCurrentEditPatternNr()="+modmatrix.nodeGetCurrentEditPatternNr();

      if(null != pat)
         Global.Print("Select pattern "+cm_pattern_nr.getSelectedOptionName()+" \""+pat.pat_name+"\".");
      else
         Global.Print("Select scene "+cm_pattern_nr.getSelectedOptionName()+" <empty>.");
   }

   // <method.png>
   public virtual selectPatternByIdx(int _idx) {

      cm_pattern_nr.setSelectedOption(_idx);

      handleSelectPattern();
   }

   // <method.png>
   public virtual selectPatternByUsedIdx(int _idx) {
      if(_idx >= 0)
      {
         int patNr = modmatrix.nodeGetPatternNrByUsedIdx(_idx);

         if(-1 != patNr)
            selectPatternByIdx(patNr);
      }
      else
      {
         selectPatternByIdx(127); // --/
      }
   }

   // <ui_handle.png>
   protected method handleSelectPreviousUsedPattern() {
      int patIdx = modmatrix.nodeGetCurrentEditPatternNr();
      patIdx = modmatrix.nodeFindPreviousPatternNrByUsedIdxWithOffset(patIdx-1, 0);

      if(patIdx >= 0)
         selectPatternByIdx(patIdx);
   }

   // <ui_handle.png>
   protected method handleSelectNextUsedPattern() {
      int patIdx = modmatrix.nodeGetCurrentEditPatternNr();
      patIdx = modmatrix.nodeFindNextPatternNrByUsedIdxWithOffset(patIdx+1, 0);

      if(patIdx >= 0)
         selectPatternByIdx(patIdx);
   }

   // <ui_handle.png>
   protected method handleNameChanged() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.pat_name = tf_pat_name.getText();

         Global.Print("Pattern name is \""+pat.pat_name+"\".");
      }
   }

   // <method.png>
   protected static RescanPresets() {

      preset_names.free();

      StringArray mmpFilenames <= Utils.ReadDirectory(st2::program_directory+"/modmatrix_presets");

      if(null != mmpFilenames)
      {
         String *mmpFilename;

         foreach mmpFilename in mmpFilenames
         {
            if(mmpFilename.startsWith("f"))
            {
               StringArray attr <= mmpFilename.splitSpace(true);
               String fileName <= attr.get(1);
               if(fileName.endsWith(".mmp"))
               {
                  fileName.replace(".mmp", "");
                  preset_names.add(String(fileName));
               }
            }
         }
      }

      IntArray ia;
      preset_names.sortByValue(ia, false/*bCS*/);
      preset_names.rearrange(ia);
   }

   // <ui_handle.png>
   protected method handlePresetLoad(boolean _bAllowNewPat) {
      local String pname = cm_preset.getSelectedOptionName();
      local String name = st2::program_directory+"/modmatrix_presets/"+pname+".mmp";

      local File f;
      if(f.openLocal(name, IOS_IN))
      {
         boolean bNewPat = true;
         NMM_Pattern pat <= getEditPattern();

         if(null != pat)
         {
            if(!_bAllowNewPat)
            {
               bNewPat = false;
               pat.removeEntries();
            }
            else
            {
               bNewPat = (0 != pat.getNumEntries());
            }
         }

         if(bNewPat)
         {
            pat <= handlePatternAlloc(false/*bSub*/);
         }

         if(null != pat)
         {
            if(pat.loadStateInt(f, 1/*ver(ignored)*/, null/*outDevIdxMap*/, null/*outDevUseCount*/, true/*bPreset*/))
            {
               Global.Success("Load preset \""+pname+"\"");
               pat.updateMacroEntryRefs();
               handlePatternChanged();

               ts_groups.setActiveTabIndex(TAB_MACROCTL);
            }
            else
            {
               Global.Error("Failed to load preset \""+pname+"\"");
            }
         }

         f.close();
      }
      else
      {
         Global.Error("Failed to load preset (file open)");
      }
   }

   // <ui_handle.png>
   protected method handlePresetSave() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         dlg_preset_save <= new NMM_SavePresetDialog;
         dlg_preset_save.run(this);
      }
   }

   // <ui_handle.png>
   public method handlePresetSave2(String _name) {

      last_preset_name = _name;

      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         _name.replace(":", "_");
         _name.replace("/", "_");
         _name.replace("\\", "_");
         _name.replace("=", "_");
         _name.replace("?", "_");
         _name.replace("*", "_");

         local String fname = st2::program_directory+"/modmatrix_presets/"+_name+".mmp";

         Global.Debug("saving modmatrix preset to \""+fname+"\"");

         local File f;
         if(f.openLocal(fname, IOS_OUT))
         {
            pat.patSaveState(f);

            f.close();

            Global.Success("Save preset to \""+_name+"\".");

            RescanPresets();
            cm_preset.setOptions(preset_names);
            cm_preset.setSelectedOption(preset_names.indexOfObject(last_preset_name, 0));

            queueRelayout();
         }
         else
         {
            Global.Error("Failed to save preset (error opening file)");
         }

         dlg_preset_save <= null;
      }
   }

   // <ui_handle.png>
   protected method handleM1NameChanged() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.m1_name = tf_m1_name.getText();

         af_dst.updateMacroCtlName();
         af_arg_1.updateMacroCtlName();
         af_arg_2.updateMacroCtlName();
         af_arg_3.updateMacroCtlName();
         af_arg_4.updateMacroCtlName();

         Global.Print("Macro Ctl 1 name is \""+pat.m1_name);
      }
   }

   // <ui_handle.png>
   protected method handleM2NameChanged() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.m2_name = tf_m2_name.getText();

         af_dst.updateMacroCtlName();
         af_arg_1.updateMacroCtlName();
         af_arg_2.updateMacroCtlName();
         af_arg_3.updateMacroCtlName();
         af_arg_4.updateMacroCtlName();

         Global.Print("Macro Ctl 2 name is \""+pat.m2_name);
      }
   }

   // <ui_handle.png>
   protected method handleM3NameChanged() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.m3_name = tf_m3_name.getText();

         af_dst.updateMacroCtlName();
         af_arg_1.updateMacroCtlName();
         af_arg_2.updateMacroCtlName();
         af_arg_3.updateMacroCtlName();
         af_arg_4.updateMacroCtlName();

         Global.Print("Macro Ctl 3 name is \""+pat.m3_name);
      }
   }

   // <ui_handle.png>
   protected method handleM4NameChanged() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.m4_name = tf_m4_name.getText();

         af_dst.updateMacroCtlName();
         af_arg_1.updateMacroCtlName();
         af_arg_2.updateMacroCtlName();
         af_arg_3.updateMacroCtlName();
         af_arg_4.updateMacroCtlName();

         Global.Print("Macro Ctl 4 name is \""+pat.m4_name);
      }
   }

   // <ui_handle.png>
   protected method handleMacroCtlChanged() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         pat.updateMacroEntryRefs();
      }
   }

   // <ui_handle.png>
   protected method handleEntryNew() : NMM_Entry {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         int idx = -1;

         NMM_Entry en <= getSelectedEntry();

         if(null != en)
         {
            idx = pat.entries.indexOfPointer(en, 0);
         }

         en <= pat.createNewEntry(idx + 1);

         handlePatternChanged();

         tv_entries.tableModelChanged();
         tv_entries.moveCursorToRow(idx + 1);
         tv_entries.redraw();

         Global.Print("Create new entry");

         return en;
      }
      return null;
   }

   // <ui_handle.png>
   protected method handleEntryClone() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         int idx = -1;

         NMM_Entry en <= getSelectedEntry();

         if(null != en)
         {
            handleEntryCopy();
            handleEntryNew();
            handleEntryPaste();
         }

         Global.Print("Clone entry");
      }
   }

   // <ui_handle.png>
   protected method handleEntryDelete() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         NMM_Entry en <= getSelectedEntry();

         if(null != en)
         {
            int idx = pat.entries.indexOfPointer(en, 0);

            pat.deleteEntry(idx);

            handlePatternChanged();

            tv_entries.tableModelChanged();
            tv_entries.moveCursorToRow(idx);
            tv_entries.redraw();

            Global.Print("Delete entry");
         }
      }
   }

   // <ui_handle.png>
   protected method handleEntryMoveUp() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         NMM_Entry en <= getSelectedEntry();

         if(null != en)
         {
            int idx = pat.entries.indexOfPointer(en, 0);

            if(-1 != idx)
            {
               int rowIdx = tm_entries.getCursorIndex();

               if(pat.moveEntryUp(idx))
               {
                  tv_entries.tableModelChanged();
                  tv_entries.redraw();
                  tv_entries.moveCursorToPreviousRow();

                  Global.Print("Move entry up");
               }
            }
         }
      }
   }

   // <ui_handle.png>
   protected method handleEntryMoveDown() {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         NMM_Entry en <= getSelectedEntry();

         if(null != en)
         {
            int idx = pat.entries.indexOfPointer(en, 0);

            if(-1 != idx)
            {
               int rowIdx = tm_entries.getCursorIndex();

               if(pat.moveEntryDown(idx))
               {
                  tv_entries.tableModelChanged();
                  tv_entries.redraw();
                  tv_entries.moveCursorToNextRow();

                  Global.Print("Move entry down");
               }
            }
         }
      }
   }

   // <ui_handle.png>
   protected method handleEntryCopy() {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en_clipboard.copyFrom(en);

         Global.Print("Copy entry to clipboard");
      }
   }

   // <ui_handle.png>
   protected method handleEntryPaste() {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.copyFrom(en_clipboard);

         NMM_Pattern pat <= getEditPattern();
         pat.updateMacroEntryRefs();

         handlePatternChanged();

         Global.Print("Paste entry from clipboard");
      }
   }

   // <ui_handle.png>
   protected =replay= method pasteCtlClipboardRandA() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NMM_Entry en <= handleEntryNew();
         if(null != en)
         {
            en.name = "sum a+b";
            en.setOp(NMM_Entry.OP_ADD);

            NMM_Arg a <= mmarg_clipboard_a;

            NMM_Arg argDst <= en.arg_dst;
            argDst.copyTypeFrom(a);
            argDst.copyDevChFrom(a);

            NMM_Arg arg1 <= en.arg_1;
            arg1.copyTypeFrom(a);
            arg1.copyDevChFrom(a);

            NMM_Arg arg2 <= en.arg_2;
            arg2.setDispType(NMM_Arg.TYPE_RANDOM);
            arg2.setRandValRange(NMM_Arg.VAL_RANGE_0_127);
            arg2.setEnableRandValSigned(true);
            arg2.setRandMin(-32.0f);
            arg2.setRandMax( 32.0f);
            arg2.setRandMinTime(0.0f);
            arg2.setRandMaxTime(0.0f);

            fixArgLayout();
            handlePatternChanged(); // (todo) optimize, just update current entry
         }
      }
   }

   // <ui_handle.png>
   protected =replay= method pasteCtlClipboardAddAB(boolean _bSigned) {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NMM_Entry en <= handleEntryNew();
         if(null != en)
         {
            en.name = "sum a+b signed";
            en.setOp(NMM_Entry.OP_ADD);

            NMM_Arg a <= mmarg_clipboard_a;
            NMM_Arg b <= mmarg_clipboard_b;

            NMM_Arg argDst <= en.arg_dst;
            argDst.copyTypeFrom(a);
            argDst.copyDevChFrom(a);

            NMM_Arg arg1 <= en.arg_1;
            arg1.copyTypeFrom(a);
            arg1.copyDevChFrom(a);
            arg1.setSH(NMM_Arg.SH_INF);

            NMM_Arg arg2 <= en.arg_2;
            arg2.copyTypeFrom(b);
            arg2.copyDevChFrom(b);
            arg2.setSH(NMM_Arg.SH_INF);
            if(_bSigned)
               arg2.setModifier(NMM_Arg.MOD_M64);

            fixArgLayout();
            handlePatternChanged(); // (todo) optimize, just update current entry
         }
      }
   }

   // <ui_handle.png>
   protected =replay= method pasteCtlClipboardDeltaAB() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NMM_Entry en <= handleEntryNew();
         if(null != en)
         {
            // arg1=a + (arg2=b - arg3) * arg4
            en.name = "delta-modulate";
            en.setOp(NMM_Entry.OP_BLEND);
            en.setOpArg1(1);
            en.setOpArg2(2);
            en.setOpArg3(3);
            en.setOpArg4(4);

            NMM_Arg a <= mmarg_clipboard_a;
            NMM_Arg b <= mmarg_clipboard_b;

            NMM_Arg argDst <= en.arg_dst;
            argDst.copyTypeFrom(a);
            argDst.copyDevChFrom(a);

            NMM_Arg arg1 <= en.arg_1;
            arg1.copyTypeFrom(a);
            arg1.copyDevChFrom(a);
            arg1.setSH(NMM_Arg.SH_INF);

            NMM_Arg arg2 <= en.arg_2;
            arg2.copyTypeFrom(b);
            arg2.copyDevChFrom(b);
            arg2.setSH(NMM_Arg.SH_INF);

            NMM_Arg arg3 <= en.arg_3;
            arg3.setDispType(NMM_Arg.TYPE_CONST);
            arg3.setConstValRange(NMM_Arg.VAL_RANGE_0_127);
            arg3.setEnableConstValSigned(false);
            arg3.setConstVal(64.0);

            NMM_Arg arg4 <= en.arg_4;
            arg4.setDispType(NMM_Arg.TYPE_CONST);
            arg4.setConstValRange(NMM_Arg.VAL_RANGE_0_127);
            arg4.setEnableConstValSigned(false);
            arg4.setConstVal(127.0);
            arg4.setModifier(NMM_Arg.MOD_N7);

            fixArgLayout();
            handlePatternChanged(); // (todo) optimize, just update current entry
         }
      }
   }

   // <ui_handle.png>
   protected =replay= method pasteCtlClipboardScaleAB() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NMM_Entry en <= handleEntryNew();
         if(null != en)
         {
            en.name = "scale a by b";
            en.setOp(NMM_Entry.OP_MUL);

            NMM_Arg a <= mmarg_clipboard_a;
            NMM_Arg b <= mmarg_clipboard_b;

            NMM_Arg argDst <= en.arg_dst;
            argDst.copyTypeFrom(a);
            argDst.copyDevChFrom(a);

            NMM_Arg arg1 <= en.arg_1;
            arg1.copyTypeFrom(a);
            arg1.copyDevChFrom(a);
            arg1.setSH(NMM_Arg.SH_INF);

            NMM_Arg arg2 <= en.arg_2;
            arg2.copyTypeFrom(b);
            arg2.copyDevChFrom(b);
            arg2.setSH(NMM_Arg.SH_INF);
            arg2.setModifier(NMM_Arg.MOD_N7);

            NMM_Arg arg3 <= en.arg_3;
            arg3.setDispType(NMM_Arg.TYPE_CONST);
            arg3.setConstValRange(NMM_Arg.VAL_RANGE_0_10);
            arg3.setConstValType(NMM_Arg.CONST_TYPE_FLOAT);
            arg3.setEnableConstValSigned(false);
            arg3.setConstVal(1.0);

            fixArgLayout();
            handlePatternChanged(); // (todo) optimize, just update current entry
         }
      }
   }

   // <ui_handle.png>
   protected =replay= method pasteCtlClipboardSlewA() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NMM_Entry en <= handleEntryNew();
         if(null != en)
         {
            en.name = "slew a";
            en.setOp(NMM_Entry.OP_SLEW);

            NMM_Arg a <= mmarg_clipboard_a;

            NMM_Arg argDst <= en.arg_dst;
            argDst.copyTypeFrom(a);
            argDst.copyDevChFrom(a);

            NMM_Arg arg1 <= en.arg_1;
            arg1.copyTypeFrom(a);
            arg1.copyDevChFrom(a);

            NMM_Arg arg2 <= en.arg_2;
            arg2.setDispType(NMM_Arg.TYPE_CONST);
            arg2.setConstValRange(NMM_Arg.VAL_RANGE_0_1);
            arg2.setConstValType(NMM_Arg.CONST_TYPE_FLOAT);
            arg2.setEnableConstValSigned(false);
            arg2.setConstVal(0.3);

            NMM_Arg arg3 <= en.arg_3;
            arg3.setDispType(NMM_Arg.TYPE_CONST);
            arg3.setConstValRange(NMM_Arg.VAL_RANGE_0_1);
            arg3.setConstValType(NMM_Arg.CONST_TYPE_FLOAT);
            arg3.setEnableConstValSigned(false);
            arg3.setConstVal(0.3);

            fixArgLayout();
            handlePatternChanged(); // (todo) optimize, just update current entry
         }
      }
   }

   // <ui_handle.png>
   protected =replay= method pasteCtlClipboardSlewAB() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NMM_Entry en <= handleEntryNew();
         if(null != en)
         {
            en.name = "quantized slew a=>b";
            en.setOp(NMM_Entry.OP_SLEW);

            NMM_Arg a <= mmarg_clipboard_a;
            NMM_Arg b <= mmarg_clipboard_b;

            NMM_Arg argDst <= en.arg_dst;
            argDst.copyTypeFrom(b);
            argDst.copyDevChFrom(b);
            argDst.setSH(NMM_Arg.SH_Q32);

            NMM_Arg arg1 <= en.arg_1;
            arg1.copyTypeFrom(a);
            arg1.copyDevChFrom(a);

            NMM_Arg arg2 <= en.arg_2;
            arg2.setDispType(NMM_Arg.TYPE_CONST);
            arg2.setConstValRange(NMM_Arg.VAL_RANGE_0_1);
            arg2.setConstValType(NMM_Arg.CONST_TYPE_FLOAT);
            arg2.setEnableConstValSigned(false);
            arg2.setConstVal(0.3);

            NMM_Arg arg3 <= en.arg_3;
            arg3.setDispType(NMM_Arg.TYPE_CONST);
            arg3.setConstValRange(NMM_Arg.VAL_RANGE_0_1);
            arg3.setConstValType(NMM_Arg.CONST_TYPE_FLOAT);
            arg3.setEnableConstValSigned(false);
            arg3.setConstVal(0.3);

            fixArgLayout();
            handlePatternChanged(); // (todo) optimize, just update current entry
         }
      }
   }

   // <ui_handle.png>
   protected =replay= method pasteCtlClipboardCurveA() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         NMM_Entry en <= handleEntryNew();
         if(null != en)
         {
            en.name = "curve lut";
            en.setOp(NMM_Entry.OP_ADD);

            NMM_Arg a <= mmarg_clipboard_a;
            NMM_Arg b <= mmarg_clipboard_b;

            NMM_Arg argDst <= en.arg_dst;
            argDst.copyTypeFrom(a);
            argDst.copyDevChFrom(a);

            NMM_Arg arg1 <= en.arg_1;
            arg1.setDispType(NMM_Arg.TYPE_CONST);
            arg1.setConstValRange(NMM_Arg.VAL_RANGE_0_10);
            arg1.setEnableConstValSigned(false);
            arg1.setConstVal(0);  // 0=clamp

            NMM_Arg arg2 <= en.arg_2;
            arg2.setDispType(NMM_Arg.TYPE_CONST);
            arg2.setConstValRange(NMM_Arg.VAL_RANGE_0_10);
            arg2.setEnableConstValSigned(false);
            arg2.setConstVal(0);  // curveIdx 0

            NMM_Arg arg3 <= en.arg_3;
            arg3.copyTypeFrom(a);
            arg3.copyDevChFrom(a);
            arg3.setModifier(NMM_Arg.MOD_N7);

            fixArgLayout();
            handlePatternChanged(); // (todo) optimize, just update current entry
         }
      }
   }

   // <ui_show.png>
   protected method showPasteMenu(boolean _bFocusFirst, boolean _bNearMouse) {

      pm_paste <= PopupMenu.New(this);
      PopupMenu pm <= pm_paste;
      PopupMenuButton *pmb;

      NMM_Pattern pat <= modmatrix.nodeGetCurrentEditPattern();
      boolean bHavePat = (null != pat);
      boolean bValidA = mmarg_clipboard_a.isValidClipboardArg();
      boolean bValidB = mmarg_clipboard_b.isValidClipboardArg();
      boolean bValidAB = bValidA && bValidB;

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: Randomize A", "rand_a");
      pmb.setActive(bHavePat && bValidA);
      pmb.setToolTipCaption("A = A + rand");

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: A + B", "add_ab");
      pmb.setActive(bHavePat && bValidAB);
      pmb.setToolTipCaption("A = A + B");

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: A + (signed)B", "add_ab_signed");
      pmb.setActive(bHavePat && bValidAB);
      pmb.setToolTipCaption("A = A + (B - 64)");

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: Delta-Modulate A by B", "delta_ab");
      pmb.setActive(bHavePat && bValidAB);
      pmb.setToolTipCaption("A = A + (B - arg3[64]) * arg4[127]");

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: Scale A by B", "scale_ab");
      pmb.setActive(bHavePat && bValidAB);
      pmb.setToolTipCaption("A = A * B");

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: Slew A (each tick)", "slew_a");
      pmb.setActive(bHavePat && bValidA);
      pmb.setToolTipCaption("A = slew(A) [up=0.3, down=0.3]");

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: Quantized Slew (read A, write B)", "slew_ab");
      pmb.setActive(bHavePat && bValidAB);
      pmb.setToolTipCaption("B = slew(A) [up=0.3, down=0.3] [quant=1/32]");

      pmb <= pm.addDefaultButton("Paste Ctl.Clipboard: Curve Table LookUp", "curve_a");
      pmb.setActive(bHavePat && bValidA);
      pmb.setToolTipCaption("A = curve(A) [curveIdx=0, mode=clamp]");

      pm.resizeToMinimum();
      if(_bNearMouse)
         pm.showNearMouse(0, 0);
      else
         pm.showAboveLayer(bt_paste);
      if(_bFocusFirst)
         pm.focusNextMenuItem();

      Global.Print("Show paste menu");
   }

   // <ui_handle.png>
   protected method handleScript1() {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         local String s;
         en.appendToScript(s);
         last_script = s;

         dlg_entry_script <= NMM_ScriptEntryDialog.NewHold("Init entry from script",
                                                           "\nEnter entry initialization / update script:\n\n (note) e.g. \"r1 = r2\" or  \"r1 + r2 r3\"\n (note) enter only op to keep current dst+args, e.g. \"+\"\n (note) start with op to keep current dst, e.g. \"+ r1 r2\"\n (note) prefix with \".\" to keep current op+dst (e.g. \". r1 r2\")\n (note) enter single expr to update dst only, e.g. \"r1\"\n (note) prefix arg expr with optional modifiers, e.g. \"r1 * r2 n7:r3 1\", or \"r1 + r2 neg:r3\", or \"r1 = 127-:r2\", or \"r1 = neg:low:reset:r2\"\n (note) arguments must be unique (see op \"Arg\" comboboxes), e.g. \"r1 blend r2 r3 r4\"\n (note) use \".\" to keep current arg, e.g. \"r1 + . r3\"\n (note) const can be int (e.g. 42, -99, 0xcd, $cd, -0xcd, 0b1110, ..)\n (note) .. or float (e.g. 3.1415, -0.1, ..)\n (note) .. or key name (e.g. c, d#, ..)\n (note) .. or mode name / substring (e.g. chro, chromatic, minorpenta)\n (note) .. or note name (e.g. c-5, d#6, ..)\n (note) .. or pattern nr (e.g. 01a, 23d, --/, ..)\n (note) when no type is specified, const is assumed, e.g. \"r1 + 42 64\", or \"m1 sclidxrep m1 d egy\"\n (note) dev and CC/RPN/NRPN names can be substrings, e.g. \"r1 = cc(master mod)\", or \"r1 = rpn(play_a reset)\"\n (note) op names: = test ! + mix * */ blend from to & | ^ % stepsin tri clamp wrap == != < <= > >= && || ^^ pow sqrt log range i/*\n (note) op names (cont.): sclidxoct whiteidx sclidxrep sclntup sclntdown sclntdrop\n (note) SH type names: none q1/64 q1/32 q1/16 q1/8 q1/4 q1/2 q1/1 h1/64 h1/32 h1/16 h1/8 h1/4 h1/2 h1/1 hinf reset\n (note) type names: none const rand note note+ noteon noteon+ noteoff noteoff+ vel vel+ dur dur+ polyat polyat+ cc pc chat pb rpn nrpn\n (note) type names (cont.): r1 r2 r3 r4 r5 r6 r7 r8 m1 m2 m3 m4\n (note) the entire pattern can be initialized from a script (hold-click \"Script\"). Take a look at the modmatrix_scripts/ directory!\n\n",
                                                           "Parse", "Cancel",
                                                           last_script, 500, 50, this
                                                           );

         dlg_entry_script.setButtonFontByName("big8");
         dlg_entry_script.setTextFontByName("big7");
         dlg_entry_script.invalidateSizeCaches();
         dlg_entry_script.resizeToMinimum();
         dlg_entry_script.showCentered();

         Global.Print("Show entry script dialog");
      }
   }

   // <ui_show.png>
   protected method showScriptEntryDialogPrev() {
      if(null != dlg_entry_script)
         dlg_entry_script.hide();
      tv_entries.moveCursorToPreviousRow();
      handleScript1();
   }

   // <ui_show.png>
   protected method showScriptEntryDialogNext() {
      if(null != dlg_entry_script)
         dlg_entry_script.hide();
      tv_entries.moveCursorToNextRow();
      handleScript1();
   }

   // <method_parse.png>
   protected method getScriptWord(StringArray _words, int _idx, int _lastIdx) : String {
      if(_idx <= _lastIdx)
         return _words.get(_idx);
      else
         throw NMM_Arg::ParseError("Parse: word idx="+_idx+" out of bounds (lastIdx="+_lastIdx+")");
   }

   // <method_parse.png>
   protected method getNextScriptWord() : String {
      return getScriptWord(script_words, script_word_idx++, script_word_last_idx);
   }

   // <method_parse.png>
   protected method expectScriptWord(String _s) {
      String n <= getNextScriptWord();
      if(n != _s)
         throw NMM_Arg::ParseError("Parse: expected \""+_s+"\", have \""+n+"\"");
   }

   // <method.png>
   protected method scriptExpandSourceDelimiters(String _s) {

      StringArray a <= _s.splitSpace(true);

      if(null != a)
      {
         _s.empty();

         String *s;
         int idx = 0;
         foreach s in a
         {
            if(!s.wasQuoted())
            {
               s.replace("(", " ( ");
               s.replace(")", " ) ");
               s.replace(":", " : ");
            }
            if(idx++ > 0)
               _s.append(" ");
            if(s.wasQuoted())
            {
               _s.append("\""+s+"\"");
            }
            else
            {
               _s.append(s);
            }
         }
      }

   }

   // <method_parse.png>
   protected method parseEntry(NMM_Entry en, String _script, boolean _bMulti) {
      last_script = _script;

      if(NodeModMatrixEditor.b_script_debug)
         trace "xxx parse \""+_script+"\"";

      scriptExpandSourceDelimiters(_script);
      script_words <= _script.splitSpace(true/*bConsiderQuotes*/);

      if(null != script_words)
      {
         if(script_words.numElements > 0)
         {
            String *w;
            foreach w in script_words
               w.toLower();

            if(NodeModMatrixEditor.b_script_debug)
               trace "xxx script words="+#(script_words);

            script_word_idx = 0;
            script_word_last_idx = script_words.numElements -1;

            String *opName;
            int opIdx = 0;
            int opWordIdx = 0;
            boolean bHaveOp = false;
            int opNumArgs = 0;
            IntArray opArgs <= null;

            if(NodeModMatrixEditor.b_script_debug)
               trace "xxx parseEntry: find op \""+script_words.get(opWordIdx)+"\"";

            loop(script_words.numElements)
            {
               opIdx = 0;
               foreach opName in NMM_Entry.script_op_names
               {
                  if(opName == script_words.get(opWordIdx))
                  {
                     opArgs <= en.op_args.get(opIdx);
                     opNumArgs = opArgs.numElements;
                     bHaveOp = true;
                     break;
                  }
                  opIdx++;
               }

               if(bHaveOp)
                  break;

               opWordIdx++;
            }

            boolean bKeepOpAndDest = false;

            if(!bHaveOp)
            {
               if("." == script_words.get(0))
               {
                  // keep dst and op, e.g. ". r1 r2"
                  bKeepOpAndDest = true;
                  script_word_idx = 1;
                  opArgs <= en.op_args.get(en.op);
                  opNumArgs = opArgs.numElements;
               }
            }

            if(!bHaveOp && !bKeepOpAndDest)
            {
               // Parse only dest
               //
               en.arg_dst.parseScript(script_words, 0, script_words.numElements);
            }
            else
            {
               if(NodeModMatrixEditor.b_script_debug)
                  trace "xxx script opNumArgs="+opNumArgs+" opArgs="+#(opArgs);

               if(!bKeepOpAndDest)
               {
                  en.setOp(opIdx);

                  if(0 != opWordIdx)
                  {
                     // Parse dest
                     en.arg_dst.parseScript(script_words, 0, opWordIdx - 1);
                     script_word_idx = opWordIdx + 1;
                  }
                  else
                  {
                     // Skip/keep dest
                     script_word_idx = 1; // skip op
                  }
               }

               // Parse args
               if(script_word_idx <= script_word_last_idx) // only set op ?
               {
                  if(opNumArgs >= 1)
                  {
                     NMM_Arg *arg;
                     PointerArray uniqueArgs;
                     uniqueArgs.empty();
                     uniqueArgs.add(en.arg_dst);
                     int argIdx = 0;

                     loop(opNumArgs)
                     {
                        arg <= en.getIndexedArg(argIdx);
                        if(!uniqueArgs.containsPointer(arg))
                           uniqueArgs.add(arg);
                        argIdx++;
                     }

                     uniqueArgs.delete(0); // Remove dst

                     if(uniqueArgs.numElements >= 1)
                     {
                        if(NodeModMatrixEditor.b_script_debug)
                           trace "xxx script parse arg1: wordIdx="+script_word_idx;
                        if(script_word_idx <= script_word_last_idx)
                        {
                           // Parse arg1
                           if("." != script_words.get(script_word_idx))
                           {
                              arg <= uniqueArgs.get(0);
                              script_word_idx = arg.parseScript(script_words, script_word_idx, script_word_last_idx);
                           }
                           else
                           {
                              script_word_idx++;
                           }

                           if(uniqueArgs.numElements >= 2)
                           {
                              if(NodeModMatrixEditor.b_script_debug)
                                 trace "xxx script parse arg2: wordIdx="+script_word_idx;
                              if(script_word_idx <= script_word_last_idx)
                              {
                                 // Parse arg2
                                 if("." != script_words.get(script_word_idx))
                                 {
                                    arg <= uniqueArgs.get(1);
                                    script_word_idx = arg.parseScript(script_words, script_word_idx, script_word_last_idx);
                                 }
                                 else
                                 {
                                    script_word_idx++;
                                 }

                                 if(uniqueArgs.numElements >= 3)
                                 {
                                    if(NodeModMatrixEditor.b_script_debug)
                                       trace "xxx script parse arg3: wordIdx="+script_word_idx;
                                    if(script_word_idx <= script_word_last_idx)
                                    {
                                       // Parse arg3
                                       if("." != script_words.get(script_word_idx))
                                       {
                                          arg <= uniqueArgs.get(2);
                                          script_word_idx = arg.parseScript(script_words, script_word_idx, script_word_last_idx);
                                       }
                                       else
                                       {
                                          script_word_idx++;
                                       }

                                       if(uniqueArgs.numElements >= 4)
                                       {
                                          if(NodeModMatrixEditor.b_script_debug)
                                             trace "xxx script parse arg4: wordIdx="+script_word_idx;
                                          if(script_word_idx <= script_word_last_idx)
                                          {
                                             // Parse arg4
                                             if("." != script_words.get(script_word_idx))
                                             {
                                                arg <= uniqueArgs.get(3);
                                                script_word_idx = arg.parseScript(script_words, script_word_idx, script_word_last_idx);
                                             }
                                             else
                                             {
                                                script_word_idx++;
                                             }
                                          }
                                          else
                                          {
                                             throw NMM_Arg::ParseError("Parse: missing arg4");
                                          }
                                       }
                                    }
                                    else
                                    {
                                       throw NMM_Arg::ParseError("Parse: missing arg3");
                                    }
                                 }
                              }
                              else
                              {
                                 throw NMM_Arg::ParseError("Parse: missing arg2");
                              }
                           }
                        }
                        else
                        {
                           throw NMM_Arg::ParseError("Parse: missing arg1");
                        }
                     }
                  } // if 1 arg
               } // only set op ?
            }
         }
      }
   }

   // <ui_handle.png>
   protected method handleScript2(String _script) {

      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         NMM_Entry en <= getSelectedEntry();

         last_script = _script;

         if(null != en)
         {
            try
            {
               parseEntry(en, _script, false/*bMulti*/);

               Global.SuccessShort("Script parsing succeeded");
            }
            catch(NMM_Arg::ParseError e)
            {
               Global.Error(e.message);
            }

            pat.updateMacroEntryRefs();
            handlePatternChanged();
         }
      }

      UI.SetKeyboardFocus(tv_entries);
   }

   // <ui_handle.png>
   protected method parseMacroArgWords(NMM_Arg _macroArg, StringArray _words) {
      // trace "xxx parse macro script \""+_script+"\"";
      // _script.replace("(", " ( ");
      // _script.replace(")", " ) ");
      // _script.replace(":", " : ");
      // // // script_words <= _script.splitSpace(true/*bConsiderQuotes*/);
      // // // script_words <= _script.splitCharset(" :()");
      // script_words <= _script.splitSpace(true/*bConsiderQuotes*/);
      script_words <= _words;

      if(null != script_words)
      {
         if(script_words.numElements > 0)
         {
            String *w;
            foreach w in script_words
               w.toLower();

            if(NodeModMatrixEditor.b_script_debug)
               trace "xxx macro script words="+#(script_words);

            script_word_idx = 0;
            script_word_last_idx = script_words.numElements -1;

            _macroArg.parseScript(script_words, script_word_idx, script_word_last_idx);
         }
      }
   }

   // <ui_handle.png>
   public method parseMultiScript(String _script, boolean _bThrow, boolean _bGen) {

      if(_bGen)
      {
         handlePatternClear();
      }

      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         StringArray lines <= _script.splitChar('\n');

         if(null != lines)
         {
            if(lines.numElements >= 1)
            {
               script_line_idx = 0;

               String *line;

               try
               {
                  HashTable defs;
                  defs.free();
                  String *defName;
                  String nextEntryName = "";
                  int entryIdx = 0;

                  foreach line in lines
                  {
                     if(NodeModMatrixEditor.b_script_debug)
                        trace "xxx parse line \""+line+"\"";
                     line.trim();
                     line.replace("\r", "");
                     if(!line.isBlank())
                     {
                        if(line <= "#")
                        {
                        }
                        else if(line <= ";")
                        {
                           foreach defName in defs
                           {
                              line.replace(defName, defs[defName]);
                           }

                           line.substring(1, line.length-1) => nextEntryName;
                           nextEntryName.trim();
                        }
                        else if(line <= "poly")
                        {
                           pat.b_poly = true;
                        }
                        else if(line <= "mono")
                        {
                           pat.b_poly = false;
                        }
                        else if(line <= "event")
                        {
                           pat.b_event = true;
                        }
                        else if(line <= "idle")
                        {
                           pat.b_event = false;
                        }
                        else if(line <= "def")
                        {
                           StringArray defWords <= line.splitSpace(true);
                           if(3 == defWords.numElements)
                           {
                              defs[defWords.get(1)] = Object(defWords.get(2));
                           }
                           else
                           {
                              throw NMM_Arg::ParseError("Parse: invalid def");
                           }
                        }
                        else if(line <= "macro")
                        {
                           scriptExpandSourceDelimiters(line);
                           StringArray macroWords <= line.splitSpace(true);

                           if(NodeModMatrixEditor.b_script_debug)
                              trace "xxx macroWords="+#(macroWords);

                           if(macroWords.numElements >= 4)
                           {
                              int macroNr = macroWords.get(1);

                              if(1 <= macroNr <= 4)
                              {
                                 NMM_Arg *macroArg;

                                 switch(macroNr)
                                 {
                                    case 1:
                                       if(NodeModMatrixEditor.b_script_debug)
                                          trace "xxx pat="+#(pat);
                                       macroArg <= pat.arg_m1;
                                       pat.m1_name = macroWords.get(2);
                                       break;

                                    case 2:
                                       macroArg <= pat.arg_m2;
                                       pat.m2_name = macroWords.get(2);
                                       break;

                                    case 3:
                                       macroArg <= pat.arg_m3;
                                       pat.m3_name = macroWords.get(2);
                                       break;

                                    case 4:
                                       macroArg <= pat.arg_m4;
                                       pat.m4_name = macroWords.get(2);
                                       break;
                                 }

                                 macroWords.delete(0);
                                 macroWords.delete(0);
                                 macroWords.delete(0);

                                 parseMacroArgWords(macroArg, macroWords);
                              }
                              else
                              {
                                 throw NMM_Arg::ParseError("Parse: invalid macro nr "+macroNr);
                              }
                           }
                           else
                           {
                              throw NMM_Arg::ParseError("Parse: invalid macro");
                           }
                        }
                        else
                        {
                           NMM_Entry en <= pat.createNewEntry(entryIdx++);

                           if(null != en)
                           {
                              en.name = nextEntryName;

                              // // nextEntryName = "";
                              foreach defName in defs
                              {
                                 line.replace(defName, defs[defName]);
                              }

                              parseEntry(en, line, true/*bMulti*/);
                           }
                           else
                              throw NMM_Arg::ParseError("Parse: failed to alloc entry");
                        }
                     }

                     script_line_idx++;
                  }

                  if(_bGen)
                  {
                     Global.SuccessShort("Parsed "+script_line_idx+" script lines");
                  }
               }
               catch(NMM_Arg::ParseError e)
               {
                  String emsg = e.message;
                  script_error_line_idx = script_line_idx;
                  emsg.replace("Parse:", "Parse:"+(script_line_idx+1)+":");

                  if(_bGen)
                  {
                     Global.Error(emsg);
                  }

                  if(_bThrow)
                  {
                     throw e;
                  }
               }

               if(_bGen)
               {
                  if(NodeModMatrixEditor.b_script_debug)
                     trace "xxx parse multi: done";

                  pat.updateMacroEntryRefs();
                  handlePatternChanged();
               }

            } // if lines.numElements >= 1
         } // if lines
      } // if pat
   }

   // <method.png>
   public method genMultiScriptFromPattern(String _script) {
      NMM_Pattern pat <= getEditPattern();

      if(null != pat)
      {
         _script.append("# ModMatrix MultiScript Pattern: \""+pat.pat_name+"\"\n\n");

         _script.append("# Settings:\n");

         if(pat.b_poly)
         {
            _script.append("poly\n\n");
         }
         else
         {
            _script.append("mono\n\n");
         }

         if(pat.b_event)
         {
            _script.append("event\n\n");
         }
         else
         {
            _script.append("idle\n\n");
         }

         _script.append("# Macros:\n");
         _script.append("macro 1 \"" + pat.m1_name + "\" ");
         pat.arg_m1.appendToScript(_script);
         _script.append("\n");

         _script.append("macro 2 \"" + pat.m2_name + "\" ");
         pat.arg_m2.appendToScript(_script);
         _script.append("\n");

         _script.append("macro 3 \"" + pat.m3_name + "\" ");
         pat.arg_m3.appendToScript(_script);
         _script.append("\n");

         _script.append("macro 4 \"" + pat.m4_name + "\" ");
         pat.arg_m4.appendToScript(_script);
         _script.append("\n");

         _script.append("\n");
         _script.append("# Entries:\n");

         NMM_Entry *en;
         int enNr = 1;
         int numEn = pat.entries.numElements;
         foreach en in pat.entries
         {
            // _script.append("\n# entry "+enNr+"/"+numEn+":\n");
            _script.append("\n");
            if(!(en.name.isBlank()))
               _script.append("; "+en.name+"\n");
            if(!en.b_op)
               _script.append("# ");
            en.appendToScript(_script);
            _script.append("\n");
            enNr++;
         }
      }
   }

   // <ui_show.png>
   protected method showScriptEditor(boolean _bInitFromPattern) {
      dlg_script.showCentered();
      if(_bInitFromPattern)
         dlg_script.handleFromPattern();
      Global.Print("Show script editor"+(_bInitFromPattern?" (init from pattern)":""));
   }

   // <ui_handle.png>
   protected method handleEnNameChanged() {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.name = tf_en_name.getText();

         tv_entries.tableModelChanged();
      }
   }

   // <ui_update.png>
   public method updateOpEnable() {
      NMM_Entry en <= getSelectedEntry();
      if(null != en)
         cb_op.setSelected(en.b_op);
   }

   // <ui_handle.png>
   protected method handleOpEnableChanged(boolean _bQuiet) {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.setEnableOp(cb_op.isSelected());

         tv_entries.tableModelChanged();

         if(!_bQuiet)
            Global.Print("Op is "+Utils.GetEnableString(en.b_op));
      }
   }

   // <ui_handle.png>
   protected method handleOpChanged(boolean _bQuiet, boolean _bRelayout) {
      NMM_Entry en <= getSelectedEntry();

      stopAllMIDILearnExcept(null);

      if(null != en)
      {
         en.setOp(cm_op.getSelectedOption());

         ls_op.switchToLayerNr(en.op);

         switch(en.op)
         {
            default:
            case NMM_Entry.OP_COPY:
               cm_op_arg1 <= cm_op_copy_src;
               cm_op_arg2 <= null;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_TEST:
               cm_op_arg1 <= cm_op_test_src;
               cm_op_arg2 <= null;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_NOT:
               cm_op_arg1 <= cm_op_not_src;
               cm_op_arg2 <= null;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_ADD:
               cm_op_arg1 <= cm_op_add_src1;
               cm_op_arg2 <= cm_op_add_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SUB:
               cm_op_arg1 <= cm_op_sub_src1;
               cm_op_arg2 <= cm_op_sub_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_MIX:
               cm_op_arg1 <= cm_op_mix_src1;
               cm_op_arg2 <= cm_op_mix_src2;
               cm_op_arg3 <= cm_op_mix_src3;
               cm_op_arg4 <= cm_op_mix_src4;
               break;

            case NMM_Entry.OP_MUL:
               cm_op_arg1 <= cm_op_mul_src;
               cm_op_arg2 <= cm_op_mul_mul1;
               cm_op_arg3 <= cm_op_mul_mul2;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_MUL_DIV:
               cm_op_arg1 <= cm_op_muldiv_src;
               cm_op_arg2 <= cm_op_muldiv_mul;
               cm_op_arg3 <= cm_op_muldiv_div;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_BLEND:
               cm_op_arg1 <= cm_op_blend_src1;
               cm_op_arg2 <= cm_op_blend_src2;
               cm_op_arg3 <= cm_op_blend_src3;
               cm_op_arg4 <= cm_op_blend_src4;
               break;

            case NMM_Entry.OP_SCALE_FROM:
               cm_op_arg1 <= cm_op_scalefrom_src;
               cm_op_arg2 <= cm_op_scalefrom_lo;
               cm_op_arg3 <= cm_op_scalefrom_hi;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SCALE_TO:
               cm_op_arg1 <= cm_op_scaleto_src;
               cm_op_arg2 <= cm_op_scaleto_lo;
               cm_op_arg3 <= cm_op_scaleto_hi;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_AND:
               cm_op_arg1 <= cm_op_and_src1;
               cm_op_arg2 <= cm_op_and_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_OR:
               cm_op_arg1 <= cm_op_or_src1;
               cm_op_arg2 <= cm_op_or_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_EOR:
               cm_op_arg1 <= cm_op_eor_src1;
               cm_op_arg2 <= cm_op_eor_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_MOD:
               cm_op_arg1 <= cm_op_mod_src1;
               cm_op_arg2 <= cm_op_mod_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_MOD_DIV:
               cm_op_arg1 <= cm_op_moddiv_src1;
               cm_op_arg2 <= cm_op_moddiv_src2;
               cm_op_arg3 <= cm_op_moddiv_src3;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_STEP:
               cm_op_arg1 <= cm_op_step_src;
               cm_op_arg2 <= cm_op_step_num;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SIN:
               cm_op_arg1 <= cm_op_sin_ang1;
               cm_op_arg2 <= cm_op_sin_ang2;
               cm_op_arg3 <= cm_op_sin_scl;
               cm_op_arg4 <= cm_op_sin_off;
               break;

            case NMM_Entry.OP_TRI:
               cm_op_arg1 <= cm_op_tri_ang1;
               cm_op_arg2 <= cm_op_tri_ang2;
               cm_op_arg3 <= cm_op_tri_scl;
               cm_op_arg4 <= cm_op_tri_off;
               break;

            case NMM_Entry.OP_CLAMP:
               cm_op_arg1 <= cm_op_clamp_src;
               cm_op_arg2 <= cm_op_clamp_lo;
               cm_op_arg3 <= cm_op_clamp_hi;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_WRAP:
               cm_op_arg1 <= cm_op_wrap_src;
               cm_op_arg2 <= cm_op_wrap_lo;
               cm_op_arg3 <= cm_op_wrap_hi;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SELECT_EQ:
               cm_op_arg1 <= cm_op_selecteq_src1;
               cm_op_arg2 <= cm_op_selecteq_src2;
               cm_op_arg3 <= cm_op_selecteq_pass;
               cm_op_arg4 <= cm_op_selecteq_fail;
               break;

            case NMM_Entry.OP_SELECT_NE:
               cm_op_arg1 <= cm_op_selectne_src1;
               cm_op_arg2 <= cm_op_selectne_src2;
               cm_op_arg3 <= cm_op_selectne_pass;
               cm_op_arg4 <= cm_op_selectne_fail;
               break;

            case NMM_Entry.OP_SELECT_LT:
               cm_op_arg1 <= cm_op_selectlt_src1;
               cm_op_arg2 <= cm_op_selectlt_src2;
               cm_op_arg3 <= cm_op_selectlt_pass;
               cm_op_arg4 <= cm_op_selectlt_fail;
               break;

            case NMM_Entry.OP_SELECT_LE:
               cm_op_arg1 <= cm_op_selectle_src1;
               cm_op_arg2 <= cm_op_selectle_src2;
               cm_op_arg3 <= cm_op_selectle_pass;
               cm_op_arg4 <= cm_op_selectle_fail;
               break;

            case NMM_Entry.OP_SELECT_GT:
               cm_op_arg1 <= cm_op_selectgt_src1;
               cm_op_arg2 <= cm_op_selectgt_src2;
               cm_op_arg3 <= cm_op_selectgt_pass;
               cm_op_arg4 <= cm_op_selectgt_fail;
               break;

            case NMM_Entry.OP_SELECT_GE:
               cm_op_arg1 <= cm_op_selectge_src1;
               cm_op_arg2 <= cm_op_selectge_src2;
               cm_op_arg3 <= cm_op_selectge_pass;
               cm_op_arg4 <= cm_op_selectge_fail;
               break;

            case NMM_Entry.OP_SELECT_AND:
               cm_op_arg1 <= cm_op_selectand_src1;
               cm_op_arg2 <= cm_op_selectand_src2;
               cm_op_arg3 <= cm_op_selectand_pass;
               cm_op_arg4 <= cm_op_selectand_fail;
               break;

            case NMM_Entry.OP_SELECT_OR:
               cm_op_arg1 <= cm_op_selector_src1;
               cm_op_arg2 <= cm_op_selector_src2;
               cm_op_arg3 <= cm_op_selector_pass;
               cm_op_arg4 <= cm_op_selector_fail;
               break;

            case NMM_Entry.OP_SELECT_EOR:
               cm_op_arg1 <= cm_op_selecteor_src1;
               cm_op_arg2 <= cm_op_selecteor_src2;
               cm_op_arg3 <= cm_op_selecteor_pass;
               cm_op_arg4 <= cm_op_selecteor_fail;
               break;

            case NMM_Entry.OP_POW:
               cm_op_arg1 <= cm_op_pow_src1;
               cm_op_arg2 <= cm_op_pow_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SQRT:
               cm_op_arg1 <= cm_op_sqrt_src1;
               cm_op_arg2 <= null;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_LOG:
               cm_op_arg1 <= cm_op_log_src1;
               cm_op_arg2 <= cm_op_log_src2;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_RANGE_OUT:
               cm_op_arg1 <= cm_op_rangeout_min;
               cm_op_arg2 <= cm_op_rangeout_in;
               cm_op_arg3 <= cm_op_rangeout_max;
               cm_op_arg4 <= cm_op_rangeout_fail;
               break;

            case NMM_Entry.OP_RANGE_IN:
               cm_op_arg1 <= cm_op_rangein_min;
               cm_op_arg2 <= cm_op_rangein_in;
               cm_op_arg3 <= cm_op_rangein_max;
               cm_op_arg4 <= cm_op_rangein_fail;
               break;

            case NMM_Entry.OP_IDIV_MUL:
               cm_op_arg1 <= cm_op_idivmul_src;
               cm_op_arg2 <= cm_op_idivmul_div;
               cm_op_arg3 <= cm_op_idivmul_mul;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SCALE_IDX_OCT:
               cm_op_arg1 <= cm_op_scaleidxoct_idx;
               cm_op_arg2 <= cm_op_scaleidxoct_key;
               cm_op_arg3 <= cm_op_scaleidxoct_mode;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_WHITE_TO_IDX:
               cm_op_arg1 <= cm_op_whitetoidx_note;
               cm_op_arg2 <= cm_op_whitetoidx_base;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SCALE_IDX_REP:
               cm_op_arg1 <= cm_op_scaleidxrep_idx;
               cm_op_arg2 <= cm_op_scaleidxrep_key;
               cm_op_arg3 <= cm_op_scaleidxrep_mode;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SCALE_NOTE_UP:
               cm_op_arg1 <= cm_op_scalenoteup_idx;
               cm_op_arg2 <= cm_op_scalenoteup_key;
               cm_op_arg3 <= cm_op_scalenoteup_mode;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SCALE_NOTE_DOWN:
               cm_op_arg1 <= cm_op_scalenotedown_idx;
               cm_op_arg2 <= cm_op_scalenotedown_key;
               cm_op_arg3 <= cm_op_scalenotedown_mode;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SCALE_NOTE_DROP:
               cm_op_arg1 <= cm_op_scalenotedrop_idx;
               cm_op_arg2 <= cm_op_scalenotedrop_key;
               cm_op_arg3 <= cm_op_scalenotedrop_mode;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_LINEAR_L:
               cm_op_arg1 <= cm_op_panlinearl_min;
               cm_op_arg2 <= cm_op_panlinearl_max;
               cm_op_arg3 <= cm_op_panlinearl_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_LINEAR_R:
               cm_op_arg1 <= cm_op_panlinearr_min;
               cm_op_arg2 <= cm_op_panlinearr_max;
               cm_op_arg3 <= cm_op_panlinearr_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_LERP_L:
               cm_op_arg1 <= cm_op_panlerpl_min;
               cm_op_arg2 <= cm_op_panlerpl_max;
               cm_op_arg3 <= cm_op_panlerpl_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_LERP_R:
               cm_op_arg1 <= cm_op_panlerpr_min;
               cm_op_arg2 <= cm_op_panlerpr_max;
               cm_op_arg3 <= cm_op_panlerpr_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_SQRT_L:
               cm_op_arg1 <= cm_op_pansqrtl_min;
               cm_op_arg2 <= cm_op_pansqrtl_max;
               cm_op_arg3 <= cm_op_pansqrtl_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_SQRT_R:
               cm_op_arg1 <= cm_op_pansqrtr_min;
               cm_op_arg2 <= cm_op_pansqrtr_max;
               cm_op_arg3 <= cm_op_pansqrtr_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_COS_L:
               cm_op_arg1 <= cm_op_pancosl_min;
               cm_op_arg2 <= cm_op_pancosl_max;
               cm_op_arg3 <= cm_op_pancosl_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_COS_R:
               cm_op_arg1 <= cm_op_pancosr_min;
               cm_op_arg2 <= cm_op_pancosr_max;
               cm_op_arg3 <= cm_op_pancosr_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_POW_L:
               cm_op_arg1 <= cm_op_panpowl_min;
               cm_op_arg2 <= cm_op_panpowl_max;
               cm_op_arg3 <= cm_op_panpowl_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_PAN_POW_R:
               cm_op_arg1 <= cm_op_panpowr_min;
               cm_op_arg2 <= cm_op_panpowr_max;
               cm_op_arg3 <= cm_op_panpowr_pan;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_NEG_HARMONY:
               cm_op_arg1 <= cm_op_negharmony_note;
               cm_op_arg2 <= cm_op_negharmony_key;
               cm_op_arg3 <= null;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_CURVE:
               cm_op_arg1 <= cm_op_curve_mode;
               cm_op_arg2 <= cm_op_curve_idx;
               cm_op_arg3 <= cm_op_curve_x;
               cm_op_arg4 <= null;
               break;

            case NMM_Entry.OP_SLEW:
               cm_op_arg1 <= cm_op_slew_dval;
               cm_op_arg2 <= cm_op_slew_amtup;
               cm_op_arg3 <= cm_op_slew_amtdn;
               cm_op_arg4 <= null;
               break;
         }

         boolean bShowAllArgs = cb_show_all_args.isSelected();

         if(null != cm_op_arg1)
            cm_op_arg1.setSelectedOption(en.getOpArg1());

         if(null != cm_op_arg2)
            cm_op_arg2.setSelectedOption(en.getOpArg2());

         if(null != cm_op_arg3)
            cm_op_arg3.setSelectedOption(en.getOpArg3());

         if(null != cm_op_arg4)
            cm_op_arg4.setSelectedOption(en.getOpArg4());

         int numRefArgs = getNumRefArgs();

         // trace "xxx numRefArgs="+numRefArgs;

         ls_arg_1.switchToLayerNr((bShowAllArgs || (numRefArgs >= 1)) ? 1 : 0);
         ls_arg_2.switchToLayerNr((bShowAllArgs || (numRefArgs >= 2)) ? 1 : 0);
         ls_arg_3.switchToLayerNr((bShowAllArgs || (numRefArgs >= 3)) ? 1 : 0);
         ls_arg_4.switchToLayerNr((bShowAllArgs || (numRefArgs >= 4)) ? 1 : 0);

         tv_entries.tableModelChanged();

         if(_bRelayout)
         {
            // trace "xxx queuerelayout";
            fixArgLayout();
         }

         if(!_bQuiet)
         {
            Global.Print("Op is "+cm_op.getSelectedOptionName());
         }
      }

   }

   // <ui_handle.png>
   protected method handlePolyChanged() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         pat.setEnablePoly(cb_poly.isSelected());

         Global.Print("Poly mode is "+Utils.GetEnableString(pat.b_poly));
      }
   }

   // <ui_handle.png>
   protected method handleEventChanged() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         pat.setEnableEvent(cb_event.isSelected());

         Global.Print("Event mode is "+Utils.GetEnableString(pat.b_event));
      }
   }

   // <ui_handle.png>
   protected method handleTickModuloChanged() {
      NMM_Pattern pat <= getEditPattern();
      if(null != pat)
      {
         pat.setTickModulo(fp_tickmodulo.getFloatValue());

         float num = (pat.tick_modulo *4.0 / current_song.ppq);
         float len = 16;
         if(num < 1)
         {
            len *= int(1.0 / num);
            num *= (1.0 / num);
         }

         Global.Print("Tick Modulo is "+pat.tick_modulo+" ("+num+" "+len+"th"+((1 != num)?"s":"")+")");
      }
   }

   // <ui_handle.png>
   protected method handleToggleEnableEntry() {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.setEnableOp(!en.b_op);

         tv_entries.tableModelChanged();

         Global.Print("Op is "+Utils.GetEnableString(en.b_op));
      }
   }


   // <ui_handle.png>
   protected method handleOpArg1Changed(boolean _bQuiet) {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.setOpArg1(cm_op_arg1.getSelectedOption());

         handleOpChanged(true/*bQuiet*/, false/*bRelayout*/); // update arg

         if(!_bQuiet)
         {
            fixArgLayout();

            Global.Print("Op arg 1 is "+cm_op_arg1.getSelectedOptionName());
         }
      }
   }

   // <ui_handle.png>
   protected method handleOpArg2Changed(boolean _bQuiet) {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.setOpArg2(cm_op_arg2.getSelectedOption());

         handleOpChanged(true/*bQuiet*/, false/*bRelayout*/); // update arg

         if(!_bQuiet)
         {
            fixArgLayout();

            Global.Print("Op arg 2 is "+cm_op_arg2.getSelectedOptionName());
         }
      }
   }

   // <ui_handle.png>
   protected method handleOpArg3Changed(boolean _bQuiet) {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.setOpArg3(cm_op_arg3.getSelectedOption());

         handleOpChanged(true/*bQuiet*/, false/*bRelayout*/); // update arg

         if(!_bQuiet)
         {
            fixArgLayout();

            Global.Print("Op arg 3 is "+cm_op_arg3.getSelectedOptionName());
         }
      }
   }

   // <ui_handle.png>
   protected method handleOpArg4Changed(boolean _bQuiet) {
      NMM_Entry en <= getSelectedEntry();

      if(null != en)
      {
         en.setOpArg4(cm_op_arg4.getSelectedOption());

         handleOpChanged(true/*bQuiet*/, false/*bRelayout*/); // update arg

         if(!_bQuiet)
         {
            fixArgLayout();

            Global.Print("Op arg 4 is "+cm_op_arg4.getSelectedOptionName());
         }
      }
   }

   // <ui_update.png>
   protected method updateNodeClass() {
      cm_node_class.setSelectedOption(modmatrix.getNodeClassId());
      cb_node_class_show.setSelected(modmatrix.getEnableNodeClassShow());
   }

   // <ui_handle.png>
   protected method handleNodeClassChanged() {
      modmatrix.setNodeClassId(cm_node_class.getSelectedOption());

      f_autodev.handleNodeClassChanged();

      Global.Print("Node class is \""+modmatrix.getNodeClassString()+"\"");
   }

   // <ui_handle.png>
   protected method handleNodeClassShowChanged() {
      modmatrix.setEnableNodeClassShow(cb_node_class_show.isSelected());

      f_autodev.handleNodeClassShowChanged();

      Global.Print("Node class show is "+Utils.GetEnableString(modmatrix.getEnableNodeClassShow()));
   }

   // <method.png>
   protected method removeBezierOverlays() {
      CurveForm *curveForm;
      foreach curveForm in f_curves
      {
         curveForm.removeBezierOverlay(root_form);
      }
   }

   // <method.png>
   protected method updateBezierOverlays() {
      CurveForm *curveForm;

      // Remove all overlays
      foreach curveForm in f_curves
         curveForm.removeBezierOverlay(root_form);

      // Add overlays for visible curves
      if(TAB_CURVES == ts_groups.getActiveTabIndex())
      {
         for(int curveIdx = 0; curveIdx < 4; curveIdx++)
         {
            LayerSwitch lsCurve <= ls_curves.get(curveIdx);
            if(1 == lsCurve.getCurrentChildNr())  // visible ?
            {
               curveForm <= f_curves.get(curveIdx);
               curveForm.addBezierOverlay(root_form);
            }
         }
      }
   }

   // <method_handle.png>
   public virtual handleStartPlaying() {

      Global.Debug3("NodeModMatrixEditor::handleStartPlaying");

      // // // modmatrix.nodeCopyLastPatternStartSongOffsetFromEditor();
   }

   // <method_handle.png>
   public virtual handleStopPlaying(boolean _bAllowBookmark) {

      Global.Debug3("NodeModMatrixEditor::handleStopPlaying");

      // // // modmatrix.nodeCopyLastPatternStartSongOffsetFromEditor();
   }

   // <method_handle.png>
   public virtual handleSongPosSelected() {

      Global.Debug3("NodeModMatrixEditor::handleSongPosSelected");

      // called from UI thread while =replay= is locked
      modmatrix.nodeSetLastPatternStartEditorSongOffset(current_song.song_offset);
   }

   // <method_handle.png>
   public virtual handlePlayPatChanged() {
      Global.Debug3("NodeModMatrixEditor::handlePlayPatChanged");
   }

   // <method.png>
   protected method stopAllMIDILearnExcept(NMM_ArgForm _cur) {
      if(@(_cur) != @(af_m1))
         af_m1.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_m2))
         af_m2.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_m3))
         af_m3.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_m4))
         af_m4.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_dst))
         af_dst.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_arg_1))
         af_arg_1.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_arg_2))
         af_arg_2.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_arg_3))
         af_arg_3.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
      if(@(_cur) != @(af_arg_4))
         af_arg_4.setLearnMode(NMM_ArgForm.LEARN_NONE, true/*bQuiet*/);
   }

   // <ui_timer.png>
   public virtual handleReplayTimer() {

      if(replay.b_playing)
      {
         if(modmatrix.checkResetNodePatternChanged())
         {
            cm_pattern_nr.setSelectedOption(modmatrix.nodeGetCurrentEditPatternNr());
            handlePatternChanged();
         }

      }

      if(modmatrix instanceof NodeModMatrix)
         if(modmatrix.checkResetQueuedRedrawOverlays())
            UI.CompositeAll();
   }

   // <ui.png>
   public virtual onResize() {
      NodeEditor::onResize();
      relayout();
   }

   // <ui_mouse.png>
   public virtual onMouse(MouseEvent _ev) : boolean {
      //trace "xxx onMouse: _ev.changed_state="+_ev.changed_state+" _ev.current_state="+_ev.current_state;

      return NodeEditor::onMouse(_ev);
   }

   // <ui_kbd.png>
   protected method handlePatternKeyHome(int _kMod) {
      if((VMOD_LSHIFT|VMOD_LCTRL) == _kMod)
      {
         handleSelectNextUsedPattern();
      }
      else
      {
         if(VMOD_LCTRL == _kMod)
         {
            MMTListener.MMTHandleLayerInc(cm_pattern_nr);
            MMTListener.MMTHandleLayerInc(cm_pattern_nr);
            MMTListener.MMTHandleLayerInc(cm_pattern_nr);
         }
         MMTListener.MMTHandleLayerInc(cm_pattern_nr); //selectNextPattern();
      }
   }

   // <ui_kbd.png>
   protected method handlePatternKeyEnd(int _kMod) {
      if((VMOD_LSHIFT|VMOD_LCTRL) == _kMod)
      {
         handleSelectPreviousUsedPattern();
      }
      else
      {
         if(VMOD_LCTRL == _kMod)
         {
            MMTListener.MMTHandleLayerDec(cm_pattern_nr);
            MMTListener.MMTHandleLayerDec(cm_pattern_nr);
            MMTListener.MMTHandleLayerDec(cm_pattern_nr);
         }
         MMTListener.MMTHandleLayerDec(cm_pattern_nr); //selectPrevPattern();
      }
   }

   // <method.png>
   protected method selectPlayTab() {
      ts_groups.setActiveTabIndex(TAB_PLAY);
      removeBezierOverlays();
      refocusDefault();
   }

   // <ui_cmd.png>
   public virtual cmdExec(StringArray _argv) : boolean {
      Global.Debug("PagePipeMap::cmdExec: argv="+#(_argv));
      switch(_argv.get(0))
      {
         case "layout":
            UI.LayoutRootLayer();
            return true;
      }
   }

   // <ui_kbd.png>
   public virtual onBeginTriadKeyMode() : boolean {
      Global.Print("lctrl-x - ");
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKeyTimeout() {
      Dialogs.ShowTriadKeyHelpDialog("lctrl-x ..",
"
          d         :   Toggle pattern manager
          u         :   Focus node name widget
          z         :   Switch between pipenodes A/B
          F3        :   Delete current pattern
          TAB       :   Select Play tab
"
                                    ,
                                    this);
      return true;
   }

   // <ui_kbd.png>
   public virtual onTriadKey(Key _k) : boolean {
      // No unicode events generated if lctrl- is still pressed
      int key = _k.pressed;
      boolean r = false;
      loop(2) // first pass for raw keycode, second pass for unicode
      {
         // US (reference) keyboard layout (raw keycodes)
         switch(key)
         {
            case VKEY_F3:
               handlePatternFree();
               return true;

            case VKEY_TAB:
               selectPlayTab();
               return true;
         }

         // see above
         key = _k.unicode;
      }

      return false;
   }

   // <ui_kbd.png>
   public virtual onKey(Key _k) : boolean {
      // trace "xxx NodeModMatrixEditor::onKey: k.name="+_k.name+" k.pressed="+_k.pressed;

      switch(_k.pressed)
      {
         // case 'q':
         // case VKEY_ESCAPE:
         //    break;

         case VKEY_ESCAPE:
            if(TAB_ENTRIES != ts_groups.getActiveTabIndex())
            {
               ts_groups.setActiveTabIndex(TAB_ENTRIES);
               return true;
            }
            // let PageNode handle it
            break;

         case VKEY_TAB:
            if(_k.modCtrlOnly())
            {
               if(TAB_ENTRIES != ts_groups.getActiveTabIndex())
                  ts_groups.setActiveTabIndex(TAB_ENTRIES);
               else
                  ts_groups.setActiveTabIndex(TAB_CURVES);
               updateBezierOverlays();
               refocusDefault();
               return true;
            }
            break;

         case '1':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               removeBezierOverlays();
               refocusDefault();
               return true;
            }
            break;

         case '2':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_MACROCTL);
               removeBezierOverlays();
               refocusDefault();
               return true;
            }
            break;

         case '3':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_ENTRIES);
               removeBezierOverlays();
               refocusDefault();
               return true;
            }
            break;

         case '4':
            if(_k.modCtrlOnly())
            {
               ts_groups.setActiveTabIndex(TAB_CURVES);
               updateBezierOverlays();
               refocusDefault();
               return true;
            }
            break;

         case '5':
            if(_k.modCtrlOnly())
            {
               selectPlayTab();
               return true;
            }
            break;

         case VKEY_HOME:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyEnd(_k.mod);
            else
               handlePatternKeyHome(_k.mod);
            return true;

         case VKEY_END:
            if(STConfig.b_key_swap_pattern_home_end)
               handlePatternKeyHome(_k.mod);
            else
               handlePatternKeyEnd(_k.mod);
            return true;

         case VKEY_INSERT:
            if(_k.modShift())
            {
               handleEntryClone();
            }
            else if(_k.modCtrl())
            {
               showPasteMenu(true/*bFocusFirst*/, false/*bNearMouse*/);
            }
            else
            {
               handleEntryNew();
            }
            return true;

         case VKEY_DELETE:
            handleEntryDelete();
            return true;

         case VKEY_UP:
            if(_k.modCtrlOnly())
            {
               handleEntryMoveUp();
               return true;
            }
            break;

         case VKEY_DOWN:
            if(_k.modCtrlOnly())
            {
               handleEntryMoveDown();
               return true;
            }
            break;

         case 'a':
            if(_k.modNone())
            {
               if(TAB_PATTERN == ts_groups.getActiveTabIndex())
                  showPatternToolsMenu(true/*bFocusFirst*/);
               return true;
            }
            break;

         case 'e':
            showScriptEditor(_k.modShift()/*bInitFromPattern*/);
            return true;

         case 'p':
            showScriptEditor(true);
            return true;

         case 'f':
            if(_k.modCtrl())
            {
               if(_k.modShift())
                  showScriptEditor(false/*bInitFromPattern*/);
               else
                  handleScript1();
               return true;
            }
            break;

         case 'n':
            if(_k.modCtrl())
            {
               if(_k.modShift())
                  handlePatternAlloc(true/*bSub*/);
               else
                  handlePatternAlloc(false/*bSub*/);
               return true;
            }
            else
            {
               ts_groups.setActiveTabIndex(TAB_PATTERN);
               // handleViewEnter();
               tf_pat_name.onTabFocus();
               return true;
            }
            break;

         case 'r':
            if(_k.modCtrl())
            {
               if(_k.modShift())
                  handlePatternClone(true/*bSub*/);
               else
                  handlePatternClone(false/*bSub*/);
               return true;
            }
            break;

         case 'c':
            if( _k.modCtrlOnly() || (_k.modCmdOnly() && UI.b_key_cmd_copy_paste) )
            {
               handlePatternCopy();
               return true;
            }
            else if(_k.modShiftOnly())
            {
               handleEntryCopy();
               return true;
            }
            break;

         case 'v':
            if( _k.modCtrlOnly() || (_k.modCmdOnly() && UI.b_key_cmd_copy_paste) )
            {
               handlePatternPaste();
               return true;
            }
            else if(_k.modShiftOnly())
            {
               handleEntryPaste();
               return true;
            }
            break;

         case 'q':
            if(_k.modCtrl())
            {
               handleToggleEnableEntry();
               handlePatternChanged();
               return true;
            }
            break;

         case VKEY_BACKSPACE:
            if(_k.modShift())
            {
               handlePatternClear();
               return true;
            }
            break;
      }

      switch(ts_groups.getActiveTabIndex())
      {
         case TAB_PATTERN:
            switch(_k.pressed)
            {
            }
            break;

         case TAB_PLAY:
            break;
      }

      if(trySelectPatternByUsedIdx(_k))
         return true;

      if(_k.modShift())
      {
         switch(_k.pressed)
         {
         }
      }

      return false;
   }

   // <ui_consume.png>
   public virtual consumeAction(Action _action) : boolean {
      ActionProvider ap <= _action.getActionProvider();
      String acName <= _action.getActionName();

      StringAction *sac;
      NMM_Pattern pat <= getEditPattern();

      int curveIdx;
      CurveForm *curveForm;

      if(NMM_ArgForm.ACTION_ARG_CHANGED == acName)
      {
         // // trace "xxx ACTION_ARG_CHANGED";

         switch(@(ap))
         {
            case @(af_m1):
            case @(af_m2):
            case @(af_m3):
            case @(af_m4):
               // trace "xxx handleMacroCtlChanged";
               handleMacroCtlChanged();
               return true;
         }

         if(null != pat)
            pat.updateMacroEntryRefs();

         tv_entries.tableModelChanged();
         return true;
      }
      else if(NMM_ArgForm.ACTION_MIDI_LEARN_START == acName)
      {
         // New MIDI learn started, stop all others
         stopAllMIDILearnExcept(ap);
         return true;
      }
      else if(TA_UPDATE_ARGS == acName)
      {
         // trace "xxx TA_UPDATE_ARGS called";

         af_m1.updateValue();
         af_m2.updateValue();
         af_m3.updateValue();
         af_m4.updateValue();

         af_dst.updateValue();
         af_arg_1.updateValue();
         af_arg_2.updateValue();
         af_arg_3.updateValue();
         af_arg_4.updateValue();

         b_signal_tap =
            af_m1.hasSignalTap() ||
            af_m2.hasSignalTap() ||
            af_m3.hasSignalTap() ||
            af_m4.hasSignalTap() ||
            af_dst.hasSignalTap() ||
            af_arg_1.hasSignalTap() ||
            af_arg_2.hasSignalTap() ||
            af_arg_3.hasSignalTap() ||
            af_arg_4.hasSignalTap() ;

         ta_update_args.scheduleTicks(b_signal_tap ? UPDATE_ARGS_TAP_MS : UPDATE_ARGS_NOTAP_MS);
      }
      else if(TA_CAPTURE_ARGS == acName)
      {
         // trace "xxx TA_CAPTURE_ARGS called";

         af_m1.captureSignalTapValue();
         af_m2.captureSignalTapValue();
         af_m3.captureSignalTapValue();
         af_m4.captureSignalTapValue();

         af_dst.captureSignalTapValue();
         af_arg_1.captureSignalTapValue();
         af_arg_2.captureSignalTapValue();
         af_arg_3.captureSignalTapValue();
         af_arg_4.captureSignalTapValue();

         b_signal_tap =
            af_m1.hasSignalTap() ||
            af_m2.hasSignalTap() ||
            af_m3.hasSignalTap() ||
            af_m4.hasSignalTap() ||
            af_dst.hasSignalTap() ||
            af_arg_1.hasSignalTap() ||
            af_arg_2.hasSignalTap() ||
            af_arg_3.hasSignalTap() ||
            af_arg_4.hasSignalTap() ;

         ta_capture_args.reschedule();
      }
      else if(CurveForm.ACTION_CURVE_EDITED == acName)
      {
         curveIdx = f_curves.indexOfPointer(ap, 0);
         if(-1 != curveIdx)
         {
            // trace "xxx ACTION_CURVE_EDITED, curveIdx="+curveIdx;
            // // if(null != pat)
            // // {
               // // pat.markCurveAsModified(curveIdx);
            // // }
            return true;
         }
      }
      else if(CurveForm.ACTION_CURVE_SAVED == acName)
      {
         foreach curveForm in f_curves
            curveForm.scanCurvePresets(true/*bForce*/);
         return true;
      }
      else if((CurveForm.ACTION_CURVE_MAXIMIZE == acName) || (CurveForm.ACTION_CURVE_MINIMIZE == acName))
      {
         curveIdx = f_curves.indexOfPointer(ap, 0);
         if(-1 != curveIdx)
         {
            for(int hideCurveIdx = 0; hideCurveIdx < 4; hideCurveIdx++)
            {
               LayerSwitch lsCurve <= ls_curves.get(hideCurveIdx);
               lsCurve.switchToLayerNr((CurveForm.ACTION_CURVE_MINIMIZE == acName) || (curveIdx == hideCurveIdx));
            }
         }
         relayout();
         ts_groups.setActiveTabIndex(TAB_ENTRIES);
         ts_groups.setActiveTabIndex(TAB_CURVES);
         curveForm <= f_curves.get(curveIdx);
         curveForm.focusBezierEdit();
         updateBezierOverlays();
         redraw();
         return true;
      }

      if(@(ap) == @(dlg_entry_script))
      {
         if(NMM_ScriptEntryDialog.ACTION_TEXTINPUTDIALOGCLOSED == acName)
         {
            sac <= _action;
            handleScript2(sac.getStringValue());
            dlg_entry_script <= null;
            return true;
         }
         else if(NMM_ScriptEntryDialog.ACTION_TEXTINPUTDIALOGCANCELED == acName)
         {
            dlg_entry_script <= null;
         }
         else if(NMM_ScriptEntryDialog.ACTION_SELECTPREVIOUSENTRY == acName)
         {
            showScriptEntryDialogPrev();
            return true;
         }
         else if(NMM_ScriptEntryDialog.ACTION_SELECTNEXTENTRY == acName)
         {
            showScriptEntryDialogNext();
            return true;
         }
      }

      switch(@(ap))
      {
         default:
            break;

         case @(ts_groups):
            Global.Print("Active tab is \""+ts_groups.getActiveViewCaption()+"\".");
            updateBezierOverlays();
            return true;

         case @(bt_pat_alloc):
            if(Button.ACTION_HOLD_CLICK == acName)
            {
               handlePatternClone(false/*bSub*/);
            }
            else
            {
               handlePatternAlloc(false/*bSub*/);
            }
            return true;

         case @(bt_pat_tools):
            showPatternToolsMenu(false/*bFocusFirst*/);
            return true;

         case @(pm_pat_tools):
            Global.Debug2("nmm: pm_pat_tools acName="+acName);
            if(!PopupMenu.IsFocusAction(_action))
               refocusDefault();
            switch(acName)
            {
               case PopupMenu.ACTION_CANCEL:
               case "":
                  Global.Print("Close pattern tools menu.");
                  return true;

               default:
                  Global.Print("Select: "+acName);
                  return true;

               case "copy":
                  handlePatternCopy();
                  return true;

               case "paste":
                  handlePatternPaste();
                  return true;

               case "clone":
                  handlePatternClone(false/*bSub*/);
                  return true;

               case "clone_sub":
                  handlePatternClone(true/*bSub*/);
                  return true;

               case "new_sub":
                  handlePatternAlloc(true/*bSub*/);
                  return true;
            }
            return true;

         case @(bt_pat_free):
            handlePatternFree();
            return true;


            // Pattern:
         case @(cm_pattern_nr):
            handleSelectPattern();
            return true;

         case @(tf_pat_name):
            handleNameChanged();
            updatePatternNrComboBox();
            if(TextField.ACTION_TEXTENTERED == acName)
            {
               refocusDefault();
            }
            return true;

         case @(bt_preset_load):
            if(Button.ACTION_HOLD_CLICK == acName)
               handlePresetLoad(true/*bAllowNewPat*/);
            else
               handlePresetLoad(false/*bAllowNewPat*/);
            return true;

         case @(bt_preset_save):
            handlePresetSave();
            return true;


            // Macro Ctl:
         case @(tf_m1_name):
            handleM1NameChanged();
            if(TextField.ACTION_TEXTENTERED == acName)
               refocusDefault();
            return true;

         case @(tf_m2_name):
            handleM2NameChanged();
            if(TextField.ACTION_TEXTENTERED == acName)
               refocusDefault();
            return true;

         case @(tf_m3_name):
            handleM3NameChanged();
            if(TextField.ACTION_TEXTENTERED == acName)
               refocusDefault();
            return true;

         case @(tf_m4_name):
            handleM4NameChanged();
            if(TextField.ACTION_TEXTENTERED == acName)
               refocusDefault();
            return true;


            // Entry:
         case @(tv_entries):
            if(TableView.ACTION_ROWCLICKED == acName)
            {
            }
            else if(TableView.ACTION_ROWSELECTED == acName)
            {
               fixArgLayout();
               handlePatternChanged(); // (todo) optimize, just update current entry
            }
            else if(TableView.ACTION_SHOWCONTEXTMENU == acName)
            {
               showPasteMenu(false/*bFocusFirst*/, true/*bNearMouse*/);
            }
            return true;

         case @(bt_new):
            if(Button.ACTION_HOLD_CLICK == acName)
               handleEntryClone();
            else
               handleEntryNew();
            return true;

         case @(bt_delete):
            handleEntryDelete();
            return true;

         case @(bt_moveup):
            handleEntryMoveUp();
            return true;

         case @(bt_movedown):
            handleEntryMoveDown();
            return true;

         case @(bt_copy):
            handleEntryCopy();
            return true;

         case @(bt_paste):
            if(Button.ACTION_HOLD_CLICK == acName)
               showPasteMenu(false/*bFocusFirst*/, false/*bNearMouse*/);
            else
               handleEntryPaste();
            return true;

         case @(pm_paste):
            Global.Debug2("nmm: pm_paste acName="+acName);
            if(PopupMenu.IsFocusAction(_action))
               return true;
            switch(acName)
            {
               case PopupMenu.ACTION_CANCEL:
                  Global.Print("Close paste menu.");
                  return true;

               default:
                  Global.Print("Select: "+acName);
                  return true;

               case "rand_a":
                  pasteCtlClipboardRandA();
                  return true;

               case "add_ab":
                  pasteCtlClipboardAddAB(false/*bSigned*/);
                  return true;

               case "add_ab_signed":
                  pasteCtlClipboardAddAB(true/*bSigned*/);
                  return true;

               case "delta_ab":
                  pasteCtlClipboardDeltaAB();
                  return true;

               case "scale_ab":
                  pasteCtlClipboardScaleAB();
                  return true;

               case "slew_a":
                  pasteCtlClipboardSlewA();
                  return true;

               case "slew_ab":
                  pasteCtlClipboardSlewAB();
                  return true;

               case "curve_a":
                  pasteCtlClipboardCurveA();
                  return true;
            }
            return true;

         case @(bt_script):
            if(Button.ACTION_HOLD_CLICK == acName)
               showScriptEditor(false/*bInitFromPattern*/);
            else
               handleScript1();
            return true;

         case @(cb_show_all_args):
            handleOpChanged(true/*bQuiet*/, true/*bRelayout*/); // refresh args
            Global.Print("Show all args is "+Utils.GetEnableString(cb_show_all_args.isSelected()));
            return true;

         case @(cb_poly):
            handlePolyChanged();
            return true;

         case @(cb_event):
            handleEventChanged();
            return true;

         case @(fp_tickmodulo):
            handleTickModuloChanged();
            return true;

         case @(tf_en_name):
            handleEnNameChanged();
            if(TextField.ACTION_TEXTENTERED == acName)
               refocusDefault();
            return true;

         case @(cb_op):
            handleOpEnableChanged(false/*bQuiet*/);
            return true;

         case @(cm_op):
            handleOpChanged(false/*bQuiet*/, true/*bRelayout*/);
            return true;

         case @(cm_op_arg1):
            handleOpArg1Changed(false/*bQuiet*/);
            return true;

         case @(cm_op_arg2):
            handleOpArg2Changed(false/*bQuiet*/);
            return true;

         case @(cm_op_arg3):
            handleOpArg3Changed(false/*bQuiet*/);
            return true;

         case @(cm_op_arg4):
            handleOpArg4Changed(false/*bQuiet*/);
            return true;


            // Play:
         case @(cm_node_class):
            handleNodeClassChanged();
            return true;

         case @(cb_node_class_show):
            handleNodeClassShowChanged();
            return true;

         case @(cm_node_class_show_in):
            handleNodeClassShowInChanged(modmatrix);
            f_autodev.handleNodeClassShowChanged();
            return true;
      }

      return XMLForm::consumeAction(_action);
   }

}
