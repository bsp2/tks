
// created: 14May2008
// changed: 20Sep2021

module Main;

use tksdl;
use tkopengl;
use tkchipmunk;

#define VSX 400
#define VSY 300

CpSpace *space;
CpBody *staticBody;
CpVect cpvzero <= cpv(0, 0);
boolean b_boost = false;


#define SHIP_POWER_NORMAL 1840 // without rope/weight
#define SHIP_POWER_ROPE 3640 // with rope/weight


boolean b_attach_weight = 1;

float ship_power = SHIP_POWER_ROPE;


// CpVect ship_verts[] = {
//    cpv( -12, -8),
//    cpv(  -1,  8),
//    cpv(   1,  8),
//    cpv(  12, -8)
// };

CpVect ship_verts[] = {

   cpv(   1, 18),
   cpv(   7,  2)
   cpv(  12,  2)
   cpv(   6, -8)
   cpv(   2, -5)

   cpv(  -2, -5)
   cpv(  -6, -8)
   cpv( -12,  2)
   cpv(  -7,  2)
   cpv(  -1, 18),

};


CpBody *ship_body;


function eachBody(CpBody body)
{
	if(body.p.y < -260 || abs(body.p.x) > 340){
		float x = rand(640.0) - 320;
		body.p = cpv(x, 260);
	}
}


int ship_vdir = 0;
int ship_rdir = 0;
float ship_rotspd = 0;

function create_ship() {

   CpShape *shape;

   float shipWeight = 8;//5.5;
   float moment = cpMomentForPoly(shipWeight, ship_verts, cpvzero, 0.0f/*radius*/);

   ship_body <= CpBody.New(shipWeight, moment);
   trace "xxx ship_body="+#(ship_body);
   ship_body.p = cpv(0, 0);
   space.addBody(#(deref ship_body));
   shape <= CpPolyShape.New(ship_body, ship_verts, cpvzero, 0.0f/*radius*/);
   shape.elasticity = 0.2;
   shape.friction = 1.0;
   shape.filterCategories = (1 << 1);
   shape.filterMask = ~((1 << 1));
   space.addShape(#(deref shape));

   if(b_attach_weight)
   {
      int numSeg = 16;//16;
      float segH = -90.0/numSeg;

      CpVect va[] = [
         cpv(-1, -segH*0.5),
         cpv( 1, -segH*0.5),
         cpv( 1, segH*0.5),
         cpv(-1, segH*0.5)
                     ];

      float cx = 0;
      float cy = 0;

      CpBody parentBody <= ship_body;
      // CpVect parentAnchor <= cpv(0, -9);
      CpVect parentAnchor <= cpv(0, 0);

      // float segWeight = (1.54 / numSeg) * 1.2 * 0.75*1; // normal
      // float segWeight = (1.54 / numSeg) * 1.2 * 0.75*0.37; // flummy
      float segWeight = (1.54 / numSeg) * 1.2 * 0.75*1.37;  // heavy

      float polyMoment = cpMomentForPoly(segWeight, va, cpvzero, 0.0f/*radius*/);

      CpBody *body;
      CpJoint *joint;

      loop(numSeg)
      {
         trace "cy="+cy;
         body <= CpBody.New(segWeight, polyMoment);
         space.addBody(#(deref body));
         body.p = cpv(0, cy+segH*0.5);
         shape <= CpPolyShape.New(body, va, cpvzero, 0.0f/*radius*/);
         shape.elasticity = 0.3*0.5*2*0.1;
         shape.friction = 1.0;
         shape.filterCategories = (1 << 2);
         if((cy > -12) || (cy < (segH * (numSeg-4))))
            shape.filterMask = (1 << 2);//0;//~0 & (1 << 2);
         else
            shape.filterMask = ~0 & ~(1 << 2);
         space.addShape(#(deref shape));
         // joint <= CpSlideJoint.New(parentBody, body, parentAnchor, cpv(0, -segH*0.5), 1, -segH*0.5*1.2);
         // joint <= CpSlideJoint.New(parentBody, body, parentAnchor, cpv(0, -segH*0.5), -segH*0.5, -segH*0.5);
         // joint <= CpPinJoint.New(parentBody, body, parentAnchor, cpv(0, -segH*0.5));
         joint <= CpPinJoint.New(parentBody, body, parentAnchor, cpv(0, -segH*0.5));
         space.addJoint(#(deref joint));

         parentAnchor <= cpv(0, segH*0.5);
         // parentAnchor <= cpv(0, 0);
         parentBody <= body;
         cy += segH;
      }

      // Create weight at the end of the chain
//    CpVect weight_verts[];
//    calc_circle_verts(weight_verts, 6, 10);

      // //body <= CpBody.New(2.0, cpMomentForPoly(2.0, weight_verts, cpvzero));
      // body <= CpBody.New(2.0*0.1, cpMomentForCircle(2.0/*m*/, 0.0/*rInner*/, 10.0/*rOuter*/, cpvzero));
      body <= CpBody.New(8, cpMomentForCircle(8.0/*m*/, 0.0/*rInner*/, 10.0/*rOuter*/, cpvzero));
      body.p = cpv(0, cy);
      space.addBody(#(deref body));

//    shape <= CpPolyShape.New(body, weight_verts, cpvzero);
//    shape.e = 0.2; shape.u = 0.9;
//    space.addShape(#(deref shape));

      shape <= CpCircleShape.New(body, 10, cpv(0,0));
      space.addShape(#(deref shape));
      shape.filterCategories = (1 << 3);
      shape.filterMask       = ~0;//1 | (1 << 1) | (1 << 2);
      shape.elasticity = 0.4;
      shape.friction   = 1.0;

      parentAnchor <= cpv(0, segH*0.5);

      // joint <= CpSlideJoint.New(parentBody, body, parentAnchor, cpv(0, 0.0), 1, 14);
      // joint <= CpSlideJoint.New(parentBody, body, parentAnchor, cpv(0, -5.0), 1, 14);
      joint <= CpPinJoint.New(parentBody, body, parentAnchor, cpv(0, 0));
      space.addJoint(#(deref joint));

   } // if b_attach_weight

}


// function calc_circle_verts(CpVect va[], int numSeg, float r) {
//    va.alloc(numSeg);
//    float a = 0.0f;
//    float w = 2PI/numSeg;
//    int i = 0;
//    loop(numSeg)
//    {
//       CpVect v;
//       v.x = r * cos(a);
//       v.y = r * sin(a);
//       va[i++] = v;
//       a += w;
//    }
// }


function demo_init()
{
   int i;

	// // cpResetShapeIdCounter();
 	space <= CpSpace.New();
	space.iterations = 10;
	space.gravity = cpv(0, -150);
   space.damping = 0.5865f;

	staticBody <= cpSpaceGetStaticBody(space);////CpBody.New(0, 0);


	// space.resizeStaticHash(4.0, 3999);
	// space.resizeActiveHash(3.0, 18999);
	
	CpBody *body;
	CpShape *shape;
   CpJoint *joint;

	// Add screen borders
	shape <= CpSegmentShape.New(staticBody, cpv(-VSX,-VSY), cpv(-VSX,VSY), 0.0f);
	shape.e = 1.0; shape.u = 1.0;
   shape.filterCategories = (1 << 0);
   shape.filterMask = ~0;
	// // space.addStaticShape(#(deref shape));
	space.addShape(#(deref shape));

	shape <= CpSegmentShape.New(staticBody, cpv(VSX,-VSY), cpv(VSX,VSY), 0.0f);
	shape.e = 1.0; shape.u = 1.0;
   shape.filterCategories = (1 << 0);
   shape.filterMask = ~0;
	// // space.addStaticShape(#(deref shape));
	space.addShape(#(deref shape));

	shape <= CpSegmentShape.New(staticBody,cpv(-VSX,-VSY), cpv(VSX,-VSY), 0.0f);
	shape.e = 1.0; shape.u = 1.0;
   shape.filterCategories = (1 << 0);
   shape.filterMask = ~0;
	// // space.addStaticShape(#(deref shape));
	space.addShape(#(deref shape));

	shape <= CpSegmentShape.New(staticBody,cpv(-VSX, VSY), cpv(VSX, VSY), 0.0f);
	shape.e = 1.0; shape.u = 1.0;
   shape.filterCategories = (1 << 0);
   shape.filterMask = ~0;
	// // space.addStaticShape(#(deref shape));
	space.addShape(#(deref shape));

   // Add circle obstacles
//    shape <= CpCircleShape.New(staticBody, 80, cpv(0, 0));
//    space.addStaticShape(#(deref shape));
  
   // body <= CpBody.New(0.01, cpMomentForCircle(0.01/*m*/, 0.0/*rInner*/, 30.0/*rOuter*/, cpvzero));
   // space.addBody(#(deref body));
   // // space.addStaticShape(#(deref shape));
   shape <= CpCircleShape.New(staticBody, 30, cpv(-200,  100));
   shape.filterCategories = (1 << 0);
   shape.filterMask = ~0;
   space.addShape(#(deref shape));

   shape <= CpCircleShape.New(staticBody, 20, cpv(-200, -100));
   shape.filterCategories = (1 << 0);
   shape.filterMask = ~0;
   space.addShape(#(deref shape));

   shape <= CpCircleShape.New(staticBody, 20, cpv(140, 100));
   shape.filterCategories = (1 << 0);
   shape.filterMask = ~0;
   space.addShape(#(deref shape));

//    shape <= CpCircleShape.New(staticBody, 20, cpv( 200, -100));
//    space.addStaticShape(#(deref shape));

//    shape <= CpCircleShape.New(staticBody, 20, cpv( 200,  100));
//    space.addStaticShape(#(deref shape));

//    shape <= CpCircleShape.New(staticBody, 10, cpv(140,  70));
//    space.addStaticShape(#(deref shape));

	
   create_ship();

   space.reindexStatic();
}

function demo_update(float _dt)
{
	int steps = 30;
	// float dt = 1.0/60.0/steps;
	float dt = (_dt * (1.0/60)) / steps;
	
	loop(steps)
   {
      CpVect im;

      if(ship_rdir > 0)
      {
         ship_rotspd = -1;
      }
      else if(ship_rdir < 0)
      {
         ship_rotspd = 1;
      }

      if(ship_rotspd != 0)
      {
         ship_body.a = ship_body.a + ship_rotspd * dt*6;
         ship_body.w = 0;
         ship_rotspd = ship_rotspd * 0.87;
      }

      if((ship_vdir > 0) || b_boost)
      {
         // cpvperp(ship_body.rot)  => im;
         CpVect shipRot <= ship_body.rotation;
         // trace "shipRot="+shipRot.string;
         cpvperp(ship_body.rotation)  => im;  // perpendicular to ship rotation
         // trace "xxx im="+im.string;
         // im = shipRot;
         cpvmult(im, dt*ship_power*(1+0.6*b_boost)) => im;
         zglColorARGB(#ffff0000);
         glBegin(GL_LINES);
         glVertex2f(ship_body.p.x, ship_body.p.y);
         // glVertex2f(ship_body.p.x + shipRot.x*20, ship_body.p.y + shipRot.y*20);
         glVertex2f(ship_body.p.x + im.x*20, ship_body.p.y + im.y*20);
         glEnd();

         // im.x = im.x * 0.7;
         // if(im.y < 0)
         // {
         //    im.y = im.y * 0.7;
         // }
         // ship_body.applyImpulse(im, cpvzero);
         im.x *= 2300.5*1.25;  // tweaked so horizontal movement at same altitude is possible via boost-rotation
         im.y *= 2300.5*1.25;
         ship_body.applyForce(im, cpvzero);
         // // ship_body.applyImpulseAtWorldPoint(im, ship_body.p);
      }

      

      space.step(dt);
	}
}




int numframesrendered=0;


function demo_destroy() {
   space.freeChildren();
   space <= null;
   staticBody <= null;
}

function drawCircle(float x, float y, float r, float a) 
{
	int segs = 15;
	float coef = 2PI / segs;
	
	glBegin(GL_LINE_STRIP); 
   for(int n = 0; n <= segs; n++)
   {
      float rads = n*coef;
      glVertex2f(r*cos(rads + a) + x, r*sin(rads + a) + y);
   }
   glVertex2f(x,y);
   glEnd();
}

function drawCircleShape(CpCircleShape circle)
{
	CpBody body <= circle.body;
	CpVect c <= cpvadd(body.p, cpvrotate(circle.c, body.rot));
	drawCircle(c.x, c.y, circle.r, body.a);
}

function drawSegmentShape(CpSegmentShape seg)
{
	CpBody body <= seg.body;
   CpVect t;

	CpVect a;
   cpvrotate(seg.a, body.rot) => t;
   cpvadd(body.p, t) => a;

	CpVect b;
   cpvrotate(seg.b, body.rot) => t;
   cpvadd(body.p, t) => b;
	
	glBegin(GL_LINES);
   glVertex2f(a.x, a.y);
   glVertex2f(b.x, b.y);
   glEnd();
}

function drawPolyShape(CpPolyShape poly)
{
	CpBody body <= poly.body;

   PointerArray verts <= poly.verts;
	int num = verts.numElements;
	
	glBegin(GL_LINE_LOOP);
	for(int i=0; i<num; i++)
   {
      CpVect t;
      cpvrotate(verts[i], body.rot) => t;
		CpVect v;
      cpvadd(body.p, t) => v;
		glVertex2f(v.x, v.y);
	} 
   glEnd();
}

function drawObject(CpShape shape)
{
   // trace "xxx drawObject: shape="+#(shape)+" shape.type="+shape.type;
	switch(shape.type)
   {
		case CP_CIRCLE_SHAPE:
			drawCircleShape(shape);
			break;
		case CP_SEGMENT_SHAPE:
			drawSegmentShape(shape);
			break;
		case CP_POLY_SHAPE:
			drawPolyShape(shape);
			break;
		default:
			print("Bad enumeration in drawObject().\n");
	}
}

function drawCollisions() {
   // TODO..
}

function display(float _dt) {

   // int t = milliSeconds();

	glClear(GL_COLOR_BUFFER_BIT);
	
	glColor3f(0.0, 0.0, 0.0);
   CpShape *shape;
   foreach shape in space.shapes {
      drawObject(shape);
   }
		
	glBegin(GL_POINTS); 
   glColor3f(0.0, 0.0, 1.0);
   CpBody *body;
   foreach body in space.bodies {
      glVertex2f(body.p.x, body.p.y);
   }
		
   //glColor3f(1.0, 0.0, 0.0);
   //cpArrayEach(space->arbiters, &drawCollisions, NULL);
	glEnd();
	
   demo_update(1.0);//_dt);

   // t = milliSeconds() - t;
   // trace "t="+t; // => 0..1
}



function initGL() {
	glClearColor(1.0, 1.0, 1.0, 0.0);

	glPointSize(3.0);
	
   glEnable(GL_LINE_SMOOTH);
	glEnable(GL_POINT_SMOOTH);
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glHint(GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
   glHint(GL_POINT_SMOOTH_HINT, GL_DONT_CARE);
   glLineWidth(2.5f);
   
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-VSX, VSX, -VSY, VSY, -1.0, 1.0);
	glTranslatef(0.5, 0.5, 0.0);
}

function onDraw() {
   // trace "xxx ----------------------------------------------- onDraw";
   display(FPS.precision);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   //print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
}

function onReopen() {
   initGL();
}

function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_UP:
         ship_vdir = 1;
         break;

      case VKEY_LEFT:
         ship_rdir = -1;
         break;

      case VKEY_RIGHT:
         ship_rdir = 1;
         break;

      case VKEY_LCTRL:
         b_boost = true;
         break;
   }

   switch(_k.released)
   {
      case VKEY_LEFT:
         if(-1 == ship_rdir)
         {
            ship_rdir = 0;
         }
         break;

      case VKEY_RIGHT:
         if(1 == ship_rdir)
         {
            ship_rdir = 0;
         }
         break;

      case VKEY_UP:
         ship_vdir = 0;
         break;

      case VKEY_SPACE:
         demo_destroy();
         demo_init();
         break;

      case VKEY_LCTRL:
         b_boost = false;
         break;

      case 'w':
         demo_destroy();
         b_attach_weight = !b_attach_weight;
         if(b_attach_weight)
         {
            ship_power = SHIP_POWER_ROPE;
         }
         else
         {
            ship_power = SHIP_POWER_NORMAL;
         }
         demo_init();
         break;
           
   }
}

function main() {
    Viewport.openWindow(1024, 768);
    Viewport.caption = "Press 1-7 to switch demos";
    use callbacks;
    FPS.tickInterval=1000.0/60;
    FPS.limit = 0;
    Viewport.swapInterval(1);

    initGL();

    demo_init();

    SDL.eventLoop();
}

