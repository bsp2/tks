
use tkmidi;

// String DEV_NAME = "Xkey37";
String DEV_NAME = "Peak";

// copied from Synergy:
class MIDIMapDefs {
   define int TYPE_NOTE_OFF              =  0;  // 0x8x note-off
   define int TYPE_NOTE_ON               =  1;  // 0x9x note-on
   define int TYPE_POLY_PRESSURE         =  2;  // 0xAx polyphonic key pressure
   define int TYPE_CC                    =  3;  // 0xBx continuous controller (7bit or 14bit) (or channel mode msg (local on/off, poly on/off, ..)
   define int TYPE_PROGRAM_CHANGE        =  4;  // 0xCx program change
   define int TYPE_CHANNEL_PRESSURE      =  5;  // 0xDx channel pressure
   define int TYPE_PITCHBEND             =  6;  // 0xEx pitch bend
   define int TYPE_SYSEX                 =  7;  // 0xF0 sys ex (see MIDIMapEvent.sysex_buffer)
   define int TYPE_SYSCOM_TIMECODE       =  8;  // 0xF1 MIDI quarter frame time code
   define int TYPE_SYSCOM_SONG_POSITION  =  9;  // 0xF2 song position pointer
   define int TYPE_SYSCOM_SONG_SELECT    = 10;  // 0xF3 song select
   define int TYPE_SYSCOM_F4             = 11;  // 0xF4 (undefined)
   define int TYPE_SYSCOM_F5             = 12;  // 0xF5 (undefined)
   define int TYPE_SYSCOM_TUNE_REQUEST   = 13;  // 0xF6 tune request
   define int TYPE_SYSRT_TIMING_CLOCK    = 14;  // 0xF8 timing clock (24ppq)
   define int TYPE_SYSRT_F9              = 15;  // 0xF9 (undefined)
   define int TYPE_SYSRT_START           = 16;  // 0xFA start
   define int TYPE_SYSRT_CONTINUE        = 17;  // 0xFB continue
   define int TYPE_SYSRT_STOP            = 18;  // 0xFC stop
   define int TYPE_SYSRT_FD              = 19;  // 0xFD (undefined)
   define int TYPE_SYSRT_ACTIVE_SENSING  = 20;  // 0xFE active sensing
   define int TYPE_SYSRT_SYSTEM_RESET    = 21;  // 0xFF system reset
   define int TYPE_RPN                   = 22;  // registered parameter number (7bit or 14bit)
   define int TYPE_NRPN                  = 23;  // (non-)registered parameter number (7bit or 14bit)
}


int inDevIdx = -1;
MIDIIn midiin;

// open by name
if(midiin.openByName(DEV_NAME))
{
   inDevIdx = midiin.deviceIdx;
   trace "ok, MIDI input device \""+midiin.deviceName+"\" opened (deviceIdx="+inDevIdx+")";
   midiin.close();
}
else
{
   trace "failed to open MIDI input device \""+midiin.deviceName+"\"";
   exit(10);
}

// open by idx
if(midiin.openByIdx(inDevIdx))
{
   trace "ok, MIDI input device idx="+midiin.deviceIdx+" opened (deviceName=\""+midiin.deviceName+"\")";
}
else
{
   trace "failed to open MIDI input device idx="+inDevIdx;
   exit(10);
}

midiin.start();
midiin.setDataEntryMode(0, MIDI_DATAENTRYMODE_MSB);

// read events
Buffer b;
b.size = 32768;
Integer evIdx = 0;
for(;;)
{
   RecordedMIDIEvent ev <= midiin.nextEvent;
   if(null != ev)
   {
      trace "["+evIdx.printf("%6d")+"] read ev size="+ev.size+" type="+TKS.scriptClassConstantToString(#(ev.midiMapEventType), MIDIMapDefs, "TYPE_")+"("+ev.midiMapEventType+")";
      evIdx++;
      if(ev.isLongMessage())
      {
         // SysEx
         b.offset = 0;
         ev.copyToStream(b);
         trace "         ev.longMessage sz="+b.offset;
      }
      else
      {
         // 1..3 byte event
         Integer io = ev.shortMessage;
         if(MIDIMapDefs.TYPE_NRPN == ev.midiMapEventType)
            trace "         nrpn="+ev.nrpnId+" val="+ev.dataEntry;
         else
            trace "         ev.shortMessage=0x"+io.printf("%08x");
      }
   }
   else
      TKS.sleep(1);
}
