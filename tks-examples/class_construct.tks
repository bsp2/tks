
// ---- 
// ---- file: class_construct.tks
// ---- date: 24-Mar-2005
// ---- 
// ---- info: Example on how to write class constructors.
// ---- 
// ---- 

class MyVector {
   // ----
   // ---- the x,y,z private fields are only visible within this class.
   // ----
   private float x,y,z;

   // ----
   // ---- The regular constructor ("MyVector") resp. destructor "~MyClass"
   // ---- is just a method which takes no arguments.
   // ----
   // ---- The non-strict type interpretation makes it very difficult
   // ---- to add method/function overloading - The type system basically 
   // ---- only differentiates between numbers (int/float) and objects (Object).
   // ---- 
   // ---- The return type of a function is variable by default (and there
   // ---- is currently no way to specify a return type, although -this- is 
   // ---- very likely going to be subject to change in future releases.
   // ----
   // ---- Object class type information is currently stored in an object itself.
   // ---- 
   // ---- Maybe I'll add a qualified/unique string signature which includes the
   // ---- function/method name as well as the parameter and return type information.
   // ---- (something like fun$ifo(String)O(MyClass), e.g. _new$3f()).
   // ---- It might not easy to decide which function to select if e.g. X("42")
   // ---- is called and there are X(int) and X(float) functions declared.
   // ---- Also (some/many?) functions could not be selected at "compile-time" since the
   // ---- actual argument list would have influence on the function selection
   // ---- (Think of dynamically typed variables ("var")).
   // ----
   // ---- The current suggested way to workaround the missing constructor/method
   // ---- overloading feature is to select the appropriate constructor manually,
   // ---- i.e. by using unique constructor names which for example encode the argument
   // ---- types or a short reminder of the functions purpose in the name.
   // ----
   public function _new3f(float _x, float _y, float _z) {
      local MyVector v;  // make sure a new object is allocated when this function is called (local)
      v.x=_x;            // initialize fields from arguments
      v.y=_y;            //
      v.z=_z;            //
      return deref v;    // remove pointer ownership from v and return "volatile" object
   }

   public function _new2f(float _x, float _y) {
      // ---- alternative "constructor" which takes only 2 arguments
      local MyVector v;
      v.x=_x;
      v.y=_y;
      v.z=0;
      return deref v;
   }

   public method toString() {
      // ----
      // ---- return string representation of the MyVector class.
      // ----
      return "("+x+";"+y+";"+z+")";
   }
}

function MyVector(float _x, float _y, float _z) {
   // ----
   // ---- The global "MyVector" function is used to define the default
   // ---- constructor (with argument list) for the "MyVector" class. 
   // ----
   // ---- It just delegates the task to the "_new3f" function in
   // ---- the "MyVector" namespace (which is allowed to see the 
   // ---- private fields of the MyVector class).
   // ----
   return MyVector._new3f(_x, _y, _z);
}

// ----
// ---- Test the MyVector class constructors.
// ----
MyVector mc<=MyVector(-1,-2,-3);
print mc.toString();

print "MyVector._new2f(2,3)  .toString()="+(MyVector._new2f(2,3)  .toString());
print "MyVector._new3f(4,5,6).toString()="+(MyVector._new3f(4,5,6).toString());
print "MyVector(7,8,9)       .toString()="+(MyVector(7,8,9)       .toString());

// ----
// ---- outputs:
// ----
// ---- Administrator@delta /cygdrive/f/Projects/tks-examples
// ---- $ tks class_construct.tks
// ---- (1;2;3)
// ---- MyVector._new2f(2,3)  .toString()=(2;3;0)
// ---- MyVector._new3f(4,5,6).toString()=(4;5;6)
// ---- MyVector(7,8,9)       .toString()=(7;8;9)
// ----
