use tksdl;
use tkopengl;

float vp_zoom = 1;

float frot = 0;
boolean b_rot = true;
int numframesrendered = 0;
int read_x = -1;
int read_y;
boolean b_queued_screenshot;


function SaveScreenShotPNG(String _pathName) : boolean {
   local Texture tex;
   boolean ret = false;
   if(tex.alloc(Viewport.width, Viewport.height, 4))
   {
      glReadBuffer(GL_BACK);
      int off = 0;
      int y = Viewport.height - 1;
      loop(Viewport.height)
      {
         zglReadColorPixelsX(tex, off, 0/*x*/, y, Viewport.width);
         y--;
         off += Viewport.width;
      }
      ret = tex.saveImage(_pathName);
   }
   return ret;
}

function onDraw() {
   // trace "[...] onDraw";

   float dt=FPS.precision;
   glClearColor(0,0,0.2,1);
   glClearStencil(0);
   // glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
   glClear(GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
   glDisable(GL_DEPTH_TEST);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   zglInitOrtho(2, 2);
   // glRotatef(frot, 0,0,1);
   glColor3f(0.9,0.9,0.9);

   FloatArray va = [
      -1.0, -0.87,
      -0.8,  0.9,
       0.2,  1.2,
      -0.5, -0.5,
      // -1.0, -1.5,
       1.0,  1.0,
       1.3, -1.0,
       0.4, -0.1,
       0.9, -1.2,
      -1.0, -0.87,  // first
                    ];

   zglVertexPointer2f(va);
   glEnableClientState(GL_VERTEX_ARRAY);

   if(1)
   {
      glEnable(GL_STENCIL_TEST);

      glStencilMask(1);
      glStencilFunc(GL_ALWAYS, 0/*ref*/, 1/*mask*/);
      glStencilOp(GL_INCR, GL_INCR, GL_INCR);
      glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
      // glDrawArrays(GL_POLYGON, 0, 8);
      glDrawArrays(GL_TRIANGLE_FAN, 0, 8);

      glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
      glStencilFunc(GL_EQUAL, 1/*ref*/, 1/*mask*/);
      glStencilOp(GL_ZERO, GL_ZERO, GL_ZERO);
      // glDrawArrays(GL_POLYGON, 0, 8);
      glDrawArrays(GL_TRIANGLE_FAN, 0, 8);

      glDisable(GL_STENCIL_TEST);
   }
   else
   {
      glDrawArrays(GL_POLYGON, 0, 8);
   }

   glDisableClientState(GL_VERTEX_ARRAY);


   if(-1 != read_x)
   {
      glReadBuffer(GL_BACK);
      // glReadBuffer(GL_COLOR_ATTACHMENT0);
      glFinish();
      Integer c32 = zglReadColorPixel(read_x, read_y);
      trace "ReadPixel ("+read_x+";"+read_y+") = ABGR(#"+c32.printf("%08x")+")";
      read_x = -1;
   }

   if(b_queued_screenshot)
   {
      b_queued_screenshot = false;
      SaveScreenShotPNG("screenshots/fpslimit.png");
   }

   if(b_rot)
   {
      frot += dt * 0.1;
      wrap frot 0 360;
   }

   // SDL.exitEventLoop();
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
   read_x = _x;
   read_y = _y;

   // if(_cbs & MOUSE_LBUTTON)
   //    Mouse.grab();
   // else if(_nbs & MOUSE_LBUTTON)
   //    Mouse.ungrab();
}

function onKeyboard(Key _k) {
   trace "[...] fpslimit:onKeyboard: k.code="+_k.code+" ("+TKS.constantToString(_k.code, "VKEY_")+") mod="+_k.mod+" pressed="+_k.pressed+" released="+_k.released+" unicode="+_k.unicode+" "+tcchar(_k.unicode);
   switch(_k.pressed)
   {
      case 'f':
         Viewport.toggleFullScreen();
         break;

      case 'p':
         b_queued_screenshot = true;
         trace "[...] queue screenshot";
         break;

      case VKEY_SPACE:
         b_rot = !b_rot;
         trace "[...] b_rot="+b_rot;
         break;

      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;
   }
}

function main() {
   use callbacks;

   FPS.tickInterval = 1000.0f / 60;
   FPS.limit = 0;

   // SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   // SDL.timerInterval = 20;

   SDL.dpiAwareness = true;  // no OS scaling
   // SDL.dpiAwareness = false;  // assume 96dpi and let OS scale window to actual DPI

   SDL.touchInput = true;  // enable WM_POINTER* messages

   // Viewport.multisampleSamples = 4;
   // Viewport.multisampleBuffers = 1;
   Viewport.stencilBits = 8;
   // Viewport.setScreenResolution(1920, 1200, 32);
   trace "xxx call Viewport.openWindow";
   Viewport.openWindow(640*vp_zoom, 480*vp_zoom);
   trace "xxx Viewport.openWindow RETURNED";
   // Viewport.openScreen(640, 480, 32);
   Viewport.swapInterval(1);

   // // trace "xxx #texunits: "+zglGetInteger(GL_MAX_TEXTURE_UNITS);
   // trace "[dbg] GL extensions: "+glGetString(GL_EXTENSIONS);
   // trace "[dbg] #texunits: "+zglGetInteger(GL_MAX_TEXTURE_IMAGE_UNITS);
   // trace "[dbg] max_texture_size: "+zglGetInteger(GL_MAX_TEXTURE_SIZE);
   // trace "[dbg] max_samples: "+zglGetInteger(GL_MAX_SAMPLES);  // (note) 4 on macOS 14 (m2pro)
   // trace "[dbg] version = "+zglGetInteger(GL_MAJOR_VERSION)+"."+zglGetInteger(GL_MINOR_VERSION);  // GL3.x+

   SDL.enableUNICODE(true);
   SDL.enableKeyRepeat(0,0);

   trace "[dbg] Viewport.dpi="+Viewport.dpi;
   trace "[...] entering eventloop";

   SDL.eventLoop();
}
