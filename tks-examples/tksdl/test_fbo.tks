
// adapted from <http://www.opengl.org/wiki/GL_EXT_framebuffer_object>

use tksdl;
use tkopengl;

float frot=0;
int numframesrendered=0;

boolean b_fbo = true;

#define TEX_SX 256
#define TEX_SY 256

int color_tex; // texture handle
int depth_rb;  // depth renderbuffer handle
int fb;        // framebuffer handle


function RenderToTexture() {
   // and now you can render to GL_TEXTURE_2D
   if(b_fbo)
   {
      glBindFramebuffer(GL_FRAMEBUFFER, fb);
   }
   glClearColor(0.0, 0.0, 0.0, 1.0);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

   glViewport(0, 0, TEX_SX, TEX_SY);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glOrtho(0.0, TEX_SX, 0.0, TEX_SY, -1.0, 1.0); 

   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glTranslatef(TEX_SX*0.5, TEX_SY*0.5, 0);
   glRotatef(frot, 0,0,1);

   glDisable(GL_TEXTURE_2D);
   glDisable(GL_BLEND);
   glEnable(GL_DEPTH_TEST);

   // Render a triangle
   float tsx = TEX_SX * 0.275;
   float tsy = TEX_SY * 0.275;
   glShadeModel(GL_SMOOTH);

   glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
   glEnable(GL_POLYGON_SMOOTH);
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

   glBegin(GL_TRIANGLES);

   zglColorARGB(#FFFF0000);
   glVertex2f(-tsx , -tsy);

   zglColorARGB(#FF00FF00);
   glVertex2f(0   ,  tsy);

   zglColorARGB(#FF0000FF);
   glVertex2f( tsx , -tsy);
   glEnd();


   // Render a triangle line loop
   float lsx = TEX_SX * 0.275*1.2;
   float lsy = TEX_SY * 0.275*1.2;
   glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
   glEnable(GL_LINE_SMOOTH);
   glLineWidth(1.5);
   glBegin(GL_LINE_LOOP);

   zglColorARGB(#FFFF0000);
   glVertex2f(-lsx , -lsy);

   zglColorARGB(#FF00FF00);
   glVertex2f(0   ,  lsy);

   zglColorARGB(#FF0000FF);
   glVertex2f( lsx , -lsy);
   glEnd();

   glDisable(GL_BLEND);

   //Bind 0, which means render to back buffer
   if(b_fbo)
   {
      glBindFramebuffer(GL_FRAMEBUFFER, 0);
   }
}

function RenderTexturedQuads() {
   // Render texture 4 times
   glClearColor(0,1,0,1);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

   //glClear(GL_DEPTH_BUFFER_BIT);
   glViewport(0, 0, Viewport.width, Viewport.height);
   zglInit2D(TEX_SX*2, TEX_SY*2);
   glLoadIdentity();

   glBindTexture(GL_TEXTURE_2D, color_tex);
   glEnable(GL_TEXTURE_2D);
   zglColorARGB(#ffffffff);

   float cy = 0;
   glBegin(GL_QUADS);
   loop(2)
   {
      float cx = 0;
      loop(2)
      {
         // Note: need to flip texture upsidedown after render-to-texture
         //       since the projection matrix was set up to let (0;0) be the upper/left corner.
         glTexCoord2f(0, 1);
         glVertex2f(cx, cy);

         glTexCoord2f(1, 1);
         glVertex2f(cx+TEX_SX, cy);

         glTexCoord2f(1, 0);
         glVertex2f(cx+TEX_SX, cy+TEX_SY);

         glTexCoord2f(0, 0);
         glVertex2f(cx, cy+TEX_SY);

         cx += TEX_SX;
      }

      cy += TEX_SY;
   }
   glEnd();

   glDisable(GL_TEXTURE_2D);
}

function onDraw() {
   float dt = FPS.precision;
   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   RenderToTexture();

   if(b_fbo)
   {
      RenderTexturedQuads();
   }

   // Rotate triangle
   frot += dt;
   wrap frot 0 360;
}

function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_SPACE:
         b_fbo = ! b_fbo;
         trace "[...] b_fbo is now "+b_fbo;
         break;
   }
}

function Init() {
   // Create RGBA8 2D texture, 24 bit depth texture, TEX_SX x TEX_SY
   color_tex = zglGenTexture();
   glBindTexture(GL_TEXTURE_2D, color_tex);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   // null means reserve texture memory, but texels are undefined
   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, TEX_SX, TEX_SY, 0, GL_BGRA, GL_UNSIGNED_BYTE, null);

   // Create framebuffer and attach texture (renderbuffer) to it
   fb = zglGenFramebuffer();
   glBindFramebuffer(GL_FRAMEBUFFER, fb);
   // Attach 2D texture to this FBO
   glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, color_tex, 0);

   // Create depth renderbuffer
   depth_rb = zglGenRenderbuffer();
   glBindRenderbuffer(GL_RENDERBUFFER, depth_rb);
   glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, TEX_SX, TEX_SY);
   //Attach depth buffer to FBO
   glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depth_rb);

   //Does the GPU support current FBO configuration?
   int status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
   switch(status)
   {
      case GL_FRAMEBUFFER_COMPLETE:
         trace "[...] GL_FRAMEBUFFER_COMPLETE (OK)";
         break;

      default:
         die "[---] glCheckFramebufferStatus returned error code "+status;
         break;
   }
}

function Exit() {
   //Delete resources
   zglDeleteTexture(color_tex);
   zglDeleteRenderbuffer(depth_rb);

   //Bind 0, which means render to back buffer, as a result, fb is unbound
   glBindFramebuffer(GL_FRAMEBUFFER, 0);
   zglDeleteFramebuffer(fb);
}


function main() {
   //Viewport.multisampleSamples = 2;
   //Viewport.multisampleBuffers = 1;

   Viewport.openWindow(TEX_SX*2, TEX_SY*2);
   Viewport.swapInterval(1);
   zglLoadExtensions();
   use callbacks;
   FPS.tickInterval=1000.0/60;

   Init();

   trace "xxx entering eventloop";
   SDL.eventLoop();

   Exit();
}
