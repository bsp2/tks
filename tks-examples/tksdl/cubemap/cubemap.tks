//
// Simple OpenGL cube mapping example
//
// Textures taken from http://wiki.delphigl.com/index.php/Tutorial_Cubemap
// (the author says he took them from the Nvidia CG SDK)
//


use tksdl;
use tkopengl;
use tkfreeglut;

Texture tex_px;
Texture tex_py;
Texture tex_pz;
Texture tex_nx;
Texture tex_ny;
Texture tex_nz;

int frame_nr;
float rotx, roty, rotz;

boolean b_normalize = true;
boolean b_polygon_smooth = true;
boolean b_rotate = true;
boolean b_texfilter = false;

enum {
   GEO_CUBE = 0,
   GEO_SPHERE,
   GEO_CONE,
   GEO_CYLINDER,
   GEO_TORUS,
   GEO_DODECAHEDRON,
   GEO_OCTAHEDRON,
   GEO_TETRAHEDRON,
   GEO_ICOSAHEDRON,
   GEO_RHOMBICDODECAHEDRON,
   GEO_SIERPINSKISPONGE,

   NUM_GEOMETRIES
}

int geo_nr = GEO_CUBE;



function onOpen() {

   // (Re-) load textures
   trace "xxx loading cube map textures.";

   if(!tex_px.loadImage("cm_positive_x.png", 0, 0, 3))
      die "failed to load texture \"cm_positive_x.png\".";
   //tex_px.flipY();

   if(!tex_py.loadImage("cm_positive_y.png", 0, 0, 3))
      die "failed to load texture \"cm_positive_y.png\".";
   //tex_py.flipY();

   if(!tex_pz.loadImage("cm_positive_z.png", 0, 0, 3))
      die "failed to load texture \"cm_positive_z.png\".";
   //tex_pz.flipY();

   if(!tex_nx.loadImage("cm_negative_x.png", 0, 0, 3))
      die "failed to load texture \"cm_negative_x.png\".";
   //tex_nx.flipY();

   if(!tex_ny.loadImage("cm_negative_y.png", 0, 0, 3))
      die "failed to load texture \"cm_negative_y.png\".";
   //tex_ny.flipY();

   if(!tex_nz.loadImage("cm_negative_z.png", 0, 0, 3))
      die "failed to load texture \"cm_negative_z.png\".";
   //tex_nz.flipY();

   int flags = TEX_CLAMPTOEDGE_S | TEX_CLAMPTOEDGE_T;
   if(b_texfilter)
   {
      flags |= TEX_MAGFILTERLINEAR | TEX_MINFILTERLINEAR;
   }

   tex_px.target = GL_TEXTURE_CUBE_MAP_POSITIVE_X;
   tex_px.flags = flags;
   tex_px.unload(); // Invalidate texture id
   tex_px.upload(); // Create new texture id and upload cube map face

   tex_py.target = GL_TEXTURE_CUBE_MAP_POSITIVE_Y;
   tex_py.flags = flags;
   tex_py.id = tex_px.id; // Share the texture id
   tex_py.upload();

   tex_pz.target = GL_TEXTURE_CUBE_MAP_POSITIVE_Z;
   tex_pz.flags = flags;
   tex_pz.id = tex_px.id; // Share the texture id
   tex_pz.upload();

   tex_nx.target = GL_TEXTURE_CUBE_MAP_NEGATIVE_X;
   tex_nx.flags = flags;
   tex_nx.id = tex_px.id; // Share the texture id
   tex_nx.upload();

   tex_ny.target = GL_TEXTURE_CUBE_MAP_NEGATIVE_Y;
   tex_ny.flags = flags;
   tex_ny.id = tex_px.id; // Share the texture id
   tex_ny.upload();

   tex_nz.target = GL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
   tex_nz.flags = flags;
   tex_nz.id = tex_px.id; // Share the texture id
   tex_nz.upload();

}



function onDraw() {
    float dt=FPS.precision;

    if( !(++frame_nr&127) )
      trace "FPS.real="+FPS.real;

    zglInitPerspective(1.3, 45.0, 0.1, 100.0);
    glCullFace(GL_BACK);
    glEnable(GL_CULL_FACE);
    glFrontFace(GL_CCW);
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1,0.1,0.1,1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer

    glTranslatef(0,0, -5);

    glRotatef(rotx, 1, 0, 0);
    glRotatef(roty, 0, 1, 0);
    glRotatef(rotz, 0, 0, 1);

    glDisable(GL_TEXTURE_2D);
    zglColorARGB(#FFFFFFFF);
    tex_px.bind();
    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP);
    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP);
    glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP);
    glEnable(GL_TEXTURE_GEN_S);
    glEnable(GL_TEXTURE_GEN_T);
    glEnable(GL_TEXTURE_GEN_R);
    glEnable(GL_TEXTURE_CUBE_MAP );

    if(b_polygon_smooth)
    {
       glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
       glEnable(GL_POLYGON_SMOOTH);
    }
    else
    {
       glDisable(GL_POLYGON_SMOOTH);
    }

    if(b_normalize)
    {
       glEnable(GL_NORMALIZE);
    }
    else
    {
       glDisable(GL_NORMALIZE);
    }

    switch(geo_nr)
    {
       case GEO_CUBE:
          glutSolidCube(2);
          break;

       case GEO_SPHERE:
          glutSolidSphere(1.7, 64, 64);
          break;

       case GEO_CONE:
          glutSolidCone(-1.5, 1.5, 16, 16);
          break;
          
       case GEO_CYLINDER:
          glutSolidCylinder(-1, 1, 64, 16);
          break;

       case GEO_TORUS:
          glutSolidTorus(0.4, 1.3, 16, 32);
          break;

       case GEO_DODECAHEDRON:
          glutSolidDodecahedron();
          break;

       case GEO_OCTAHEDRON:
          glScalef(1.8, 1.8, 1.8);
          glutSolidOctahedron();
          break;

       case GEO_TETRAHEDRON:
          glScalef(1.8, 1.8, 1.8);
          glutSolidTetrahedron();
          break;

       case GEO_ICOSAHEDRON:
          glScalef(1.8, 1.8, 1.8);
          glutSolidIcosahedron();
          break;

       case GEO_RHOMBICDODECAHEDRON:
          glScalef(1.8, 1.8, 1.8);
          glutSolidRhombicDodecahedron();
          break;

       case GEO_SIERPINSKISPONGE:
          glutSolidSierpinskiSponge(4, [0.0, 0.0, 0.0], 1.8);
          break;

    }

    if(b_rotate)
    {
       rotx += dt*0.31;
       roty += dt*0.113;
       rotz += dt*0.5157;
       
       wrap rotx 0 360;
       wrap roty 0 360;
       wrap rotz 0 360;
    }
}

function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_SPACE:
         geo_nr ++;
         if(geo_nr >= NUM_GEOMETRIES)
            geo_nr = 0;
         trace "Selected geometry \""+TKS.constantToString(geo_nr, "GEO_")+"\".";
         break;

      case 'n':
         b_normalize = !b_normalize;
         trace "b_normalize set to "+b_normalize;
         break;

      case 'p':
         b_polygon_smooth  = !b_polygon_smooth;
         trace "b_polygon_smooth set to "+b_polygon_smooth;
         break;

      case 'r':
         b_rotate = !b_rotate;
         trace "b_rotate set to "+b_rotate;
         break;

      case 'f':
         b_texfilter = !b_texfilter;
         trace "b_texfilter set to "+b_texfilter;
         onOpen();
         break;
   }
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   ////print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
}

function main() {
    use callbacks;

    FPS.tickInterval=1000.0/60;
    FPS.limit=60;

    Viewport.openWindow(640, 480);

    print 
       "\n-------------------------------------------\n"
       "\n"
       "      Press space to change the geometry!"
       "\n"
       "      Press r to toggle rotation.\n"
       "      Press n to enable GL_NORMALIZE.\n"
       "      Press p to toggle GL_POLYGON_SMOOTH.\n"
       "      Press f to toggle texture filter.\n"
       "\n"
       "\n-------------------------------------------";

    SDL.eventLoop();
}
