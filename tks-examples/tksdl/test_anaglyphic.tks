
use tksdl;
use tkopengl;

float frot=0;
int numframesrendered=0;

float cam_z = -18.7;

float eye_col_r;
float eye_col_g;
float eye_col_b;

function SetColor(float gs) {
   glColor4f(eye_col_r * gs,
             eye_col_g * gs,
             eye_col_b * gs,
             1.0
             );
             
}

float eye_dist = 1.0;//0.25;


function LoadCameraMatrix() {
   //glRotatef(frot, 0,1,0);
}

float xxx_rot;

function render_cube(float eyeDist, float tx, float ty, float tz) compile {
   int N = 4;
   float a = 2.0 / N;
   float c;

   glLoadIdentity();
   glTranslatef(eyeDist,0,0);
   glTranslatef(0,0,cam_z);

   glRotatef(frot, 1,1,1);

   glTranslatef(tx, ty, tz);

   glRotatef(xxx_rot, 1,1,1);

   glLineWidth(1.3);
   //SetColor((tz + 8) / 16.0);
   SetColor(1);
   glBegin(GL_LINES);


   // Front
   c = -1;
   loop(N)
   {
      glVertex3f(-1, c, 1);
      glVertex3f( 1, c, 1);
      c += a;
   }

   // Back
   c = -1;
   loop(N)
   {
      glVertex3f(-1, c, -1);
      glVertex3f( 1, c, -1);
      c += a;
   }

   // Left
   c = -1;
   loop(N)
   {
      glVertex3f(-1, c, 1);
      glVertex3f(-1, c, -1);
      c += a;
   }

   // Right
   c = -1;
   loop(N)
   {
      glVertex3f(1, c, 1);
      glVertex3f(1, c, -1);
      c += a;
   }

   // Top
   c = -1;
   loop(N)
   {
      glVertex3f(c, 1, 1);
      glVertex3f(c, 1, -1);
      c += a;
   }

   // Bottom
   c = -1;
   loop(N)
   {
      glVertex3f(c, -1, 1);
      glVertex3f(c, -1, -1);
      c += a;
   }


   glEnd();
}

function render(float eyeDist) {

   zglInitPerspective(float(Viewport.width)/Viewport.height, 100.0, 0.2, 50);

   //glRotatef(13, 1,1,0);

   float oldRot = xxx_rot;

   int N = 4;
   float cx = -8;
   float a = 4;
   loop(N+1)
   {
      float cy = -8;
      loop(N+1)
      {
         float cz = -8;
         loop(N+1)
         {
            render_cube(eyeDist, cx, cy, cz);
            xxx_rot = mathWrapf(xxx_rot+1.3, 0, 360);
            cz += a;
         }
         cy += a;
      }
      cx += a;
   }

   xxx_rot = mathWrapf(oldRot + 0.3, 0, 360);

}

function onDraw() {
    float dt=FPS.precision;
    glClearColor(0,0,0,1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
    if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

    //glEnable(GL_DEPTH_TEST);
    
    glEnable(GL_BLEND);
    //glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    //glBlendFunc(GL_SRC_ALPHA, GL_ONE);
    glBlendFunc(GL_ONE, GL_ONE);

    //zglFogMode(GL_LINEAR);
    zglFogMode(GL_EXP2);
    zglFogDensity(0.05);
    zglFogStart(0);
    zglFogEnd(24);
    glEnable(GL_FOG);
    zglFogColor4f(0,0,0,0);
    //glFogColor4f(1,1,1,1);

    eye_col_r = 0.85;
    eye_col_g = 0;
    eye_col_b = 0;
    render(eye_dist);

    eye_col_r = 0.0;
    eye_col_g = 0.1;
    eye_col_b = 1;
    render(-eye_dist);

    frot+=dt;
    wrap frot 0 360;
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   //print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
}

function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_LEFT:
         eye_dist = mathClampf(eye_dist-0.01, 0.001, 10);
         trace "eye_dist is now "+eye_dist;
         break;

      case VKEY_RIGHT:
         eye_dist = mathClampf(eye_dist+0.01, 0.001, 10);
         trace "eye_dist is now "+eye_dist;
         break;
   }
}

function main() {
   use callbacks;

   FPS.tickInterval=1000.0/60;

   Viewport.openWindow(1024, 768);
   Viewport.setScreenResolution(1024, 768, 32);
   //Viewport.toggleFullScreen();
   Viewport.swapInterval(1);

   trace "xxx entering eventloop";
   SDL.eventLoop();
}
