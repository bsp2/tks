// 02Aug2025, 03Aug2025, 05Aug2025, 06Aug2025, 07Aug2025

use tksdl;
use tkopengl;
use tkmath;

putenv("TKSDL_GLERROR=1");

float VP_W = 640.0;
float VP_H = 480.0;

float vp_scale = 2.0;

boolean b_anim      = 0;    // SPACE
boolean b_slomo     = 0;    // lctrl-SPACE
boolean b_aa        = 1;    // 'a'
float   aa_range    = 2.5 / vp_scale;  // UP/DOWN
float   aa_exp      = 1.0;  // 'k', 'l'
float   stroke_w    = 1.5;  // LEFT/RIGHT   half width
float   alpha       = 1.0;  // 'r', 't'
float   radius_sclx = 1.0;  // 'f', 'g'
float   radius_scly = 1.0;  // 'h', 'j'
boolean b_vsync     = 1;    // 'v'

int test_idx = 0;  // '1', '2', ..

float ang_x = 0;
float ang_y = 0;

float ang_w = 0;
float ang_h = 0;

int numframesrendered = 0;

RoundRectStroke g;
g.init();

int SCRATCH_BUFFER_SZ = 65536;
// int SCRATCH_BUFFER_SZ = (4*2*4);  // debug: auto-flush after each quad
int scratch_vbo_id;


// ---------------------------------------------------------------------------- SaveScreenShotPNG
boolean b_queued_screenshot;
function SaveScreenShotPNG(String _pathName) : boolean {
   local Texture tex;
   boolean ret = false;
   if(tex.alloc(Viewport.width, Viewport.height, 4))
   {
      glReadBuffer(GL_BACK);
      int off = 0;
      int y = Viewport.height - 1;
      loop(Viewport.height)
      {
         zglReadColorPixelsX(tex, off, 0/*x*/, y, Viewport.width);
         y--;
         off += Viewport.width;
      }
      ret = tex.saveImage(_pathName);
   }
   return ret;
}

// ---------------------------------------------------------------------------- RoundRectStroke
class RoundRectStroke {

   ZGLShader border_shader;
   int border_a_vtx;
   // // int border_vao_id;
   int border_u_transform;
   int border_u_aa_range;
   int border_u_aa_exp;
   int border_u_center;
   int border_u_size_i;
   int border_u_size_o;
   int border_u_radius;
   int border_u_color;
   int border_u_debug;

   boolean b_debug;


   public method init() {
   }

   // ------------ border vertex shader --------------
   static String border_vs_src = "#version 120
uniform mat4 u_transform;
attribute vec2 a_vtx;
varying vec2 v_p;

void main(void) {
   v_p = a_vtx;
   gl_Position = u_transform * vec4(a_vtx,0,1);
}
      ";

   // ------------ border fragment shader ------------
   static String border_fs_src = "#version 120

uniform vec2  u_center;
uniform vec2  u_size_i;
uniform vec2  u_size_o;
uniform vec2  u_radius;
uniform float u_aa_range;
uniform float u_aa_exp;
uniform vec4  u_color;
uniform float u_debug;

varying vec2 v_p;

void main(void) {
   float aRectI = 0.0;
   float aRectO = 0.0;
   float aRoundI = 1.0;
   float aRoundO = 1.0;
   vec4 colorO = vec4(0,0,0,0);

   // outer
   vec2 vd = abs(v_p - u_center);
   // // if(vd.x < u_size_o.x && vd.y < u_size_o.y)
   {
      aRectO  = 1.0 - smoothstep(u_size_o.x-u_aa_range, u_size_o.x, vd.x);
      aRectO *= 1.0 - smoothstep(u_size_o.y-u_aa_range, u_size_o.y, vd.y);
      colorO = u_color;

      vd = vd - (u_size_o - u_radius);

      if(vd.x > 0.0 && vd.y > 0.0)
      {
         vec2 vdn = vd * (vec2(1.0, 1.0) / u_radius);
         float as = asin(vdn.x) * (1.0 / 3.14159265359);
         float r = mix(u_radius.y, u_radius.x, as);
         float rmax = max(u_radius.y, u_radius.x);
         float r2 = (r / rmax);
         float aaR = u_aa_range * r2;
         aRoundO = 1.0 - smoothstep( (rmax - aaR) / rmax, 1.0, length(vdn));
      }
   }

   // inner
   vd = abs(v_p - u_center);
   if(vd.x < u_size_i.x && vd.y < u_size_i.y)
   {
      aRectI  = 1.0 - smoothstep(u_size_i.x - u_aa_range, u_size_i.x, vd.x);
      aRectI *= 1.0 - smoothstep(u_size_i.y - u_aa_range, u_size_i.y, vd.y);

      vd = vd - (u_size_i - u_radius);

      if(vd.x > 0.0 && vd.y > 0.0)
      {
         vec2 vdn = vd * (vec2(1.0, 1.0) / u_radius);
         float as = asin(vdn.x) * (1.0 / 3.14159265359);
         float r = mix(u_radius.y, u_radius.x, as);
         float rmax = max(u_radius.y, u_radius.x);
         float r2 = (r / rmax);
         float aaR = u_aa_range * r2;
         aRoundI = 1.0 - smoothstep( (rmax - aaR) / rmax, 1.0, length(vdn) );
      }
   }

   float aI = 1.0 - (aRectI * aRoundI);
   float aO = aRectO * aRoundO;

#if 1
   aI = pow(aI, u_aa_exp);
#endif
   // vec4 color = mix(colorO, colorI, aI);
   vec4 color = vec4(colorO.xyz, colorO.a * aI);

   // a = smoothstep(0.0, 1.0, a);
#if 1
   aO = pow(aO, u_aa_exp);
#endif

   gl_FragColor = vec4(color.xyz, color.a*aO);
   if(u_debug > 0.0)
      gl_FragColor = vec4(1,0,0,1);

   // vec2 pn = v_p / vec2(640.0, 480.0);
   // gl_FragColor = vec4(pn,v_p.x,1);

}
   ";

   protected method createBorderShader() : boolean {
      border_shader.vertexSource = border_vs_src;
      border_shader.fragmentSource = border_fs_src;

      if(!border_shader.create())
      {
         trace "[---] RoundRectStroke::onOpen: failed to create border_shader";
         return false;
      }

      border_a_vtx = border_shader.getAttribLocation("a_vtx");

      border_u_transform = border_shader.getUniformLocation("u_transform");
      border_u_aa_range  = border_shader.getUniformLocation("u_aa_range");
      border_u_aa_exp    = border_shader.getUniformLocation("u_aa_exp");
      border_u_center    = border_shader.getUniformLocation("u_center");
      border_u_size_i    = border_shader.getUniformLocation("u_size_i");
      border_u_size_o    = border_shader.getUniformLocation("u_size_o");
      border_u_radius    = border_shader.getUniformLocation("u_radius");
      border_u_color     = border_shader.getUniformLocation("u_color");
      border_u_debug     = border_shader.getUniformLocation("u_debug");

      // trace "xxx border_a_vtx="+border_a_vtx;
      // trace "xxx border_u_transform="+border_u_transform;

      return true;
   }

   public method onOpen() : boolean {
      if(createBorderShader())
      {
         // (note) VAO only works in Core profile or GLES3+
         // // border_vao_id = zglGenVertexArray();
         // // trace "xxx border_vao_id="+border_vao_id;
         // // glBindVertexArray(border_vao_id);
         // // glBindBuffer(GL_ARRAY_BUFFER, vbo_id);
         // // zglVertexAttribOffset(border_a_vtx, 2/*size*/, GL_FLOAT, GL_FALSE/*normalize*/, 0/*stride*/, 0/*offset*/);
         // // glBindBuffer(GL_ARRAY_BUFFER, 0);
         // // glBindVertexArray(0);

         return true;
      }
      return false;
   }

   protected method setQuadVertices(Buffer _scratchBuf,
                                    int _aVertex,
                                    float _x, float _y, float _w, float _h
                                    ) {
      if(_scratchBuf.offset + (4*2/*xy*/*4/*float*/) > _scratchBuf.size)
      {
         glUnmapBuffer(GL_ARRAY_BUFFER);
         glFlush();
         zglMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY, _scratchBuf, _scratchBuf.size);
         _scratchBuf.offset = 0;
      }
      zglVertexAttribOffset(_aVertex, 2/*size*/, GL_FLOAT, GL_FALSE/*normalize*/, 0/*stride*/, _scratchBuf.offset);
      _scratchBuf.f32 = _x;        _scratchBuf.f32 = _y;
      _scratchBuf.f32 = _x + _w;   _scratchBuf.f32 = _y;
      _scratchBuf.f32 = _x + _w;   _scratchBuf.f32 = _y + _h;
      _scratchBuf.f32 = _x;        _scratchBuf.f32 = _y + _h;
   }

   public method drawRoundRectStroke(Buffer _scratchBuf,
                                     Matrix4f _projMatrix,
                                     float _centerX, float _centerY,
                                     float _sizeX,   float _sizeY,
                                     float _radiusX, float _radiusY,
                                     float _strokeR, float _strokeG, float _strokeB, float _strokeA,
                                     float _strokeW,
                                     float _aaRange,
                                     float _aaExp
                                     ) {

      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      glEnable(GL_BLEND);

      if(_radiusX > _sizeX)
         _radiusX = _sizeX;

      if(_radiusY > _sizeY)
         _radiusY = _sizeY;

      boolean bSingle = ((_sizeX*_sizeY) <= 256);

      // Outer corners
      border_shader.bind();

      glUniformMatrix4fv(border_u_transform, 1/*count*/, GL_TRUE/*transpose*/, _projMatrix);
      glUniform2f(border_u_center,   _centerX, _centerY);
      glUniform2f(border_u_size_i,   _sizeX - _strokeW, _sizeY - _strokeW);
      glUniform2f(border_u_size_o,   _sizeX + _strokeW, _sizeY + _strokeW);
      glUniform2f(border_u_radius,   _radiusX, _radiusY);
      glUniform1f(border_u_aa_range, _aaRange);
      glUniform1f(border_u_aa_exp,   _aaExp);
      glUniform4f(border_u_color,    _strokeR, _strokeG, _strokeB, _strokeA);
      glUniform1f(border_u_debug,    b_debug ? 1.0f : 0.0f);
   
      // trace "xxx programId="+shader.programId+" a_uv="+a_uv+" #attribs="+shader.getNumActiveAttributes();
      glEnableVertexAttribArray(border_a_vtx);

      if(bSingle)
      {
         trace "xxx single";
         setQuadVertices(_scratchBuf, border_a_vtx,
                         _centerX - _sizeX - _strokeW,
                         _centerY - _sizeY - _strokeW,
                         (_sizeX + _strokeW) * 2.0f,
                         (_sizeY + _strokeW) * 2.0f
                         );
         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
      }
      else
      {
         // T
         setQuadVertices(_scratchBuf, border_a_vtx,
                         _centerX - _sizeX - _strokeW,
                         _centerY - _sizeY - _strokeW,
                         (_sizeX + _strokeW) * 2.0f,
                         _radiusY + _strokeW
                         );
         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

         // L
         setQuadVertices(_scratchBuf, border_a_vtx,
                         _centerX - _sizeX - _strokeW,
                         _centerY - _sizeY + _radiusY,
                         _radiusX + _strokeW,
                         (_sizeY - _radiusY) * 2.0
                         );
         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

         // R
         setQuadVertices(_scratchBuf, border_a_vtx,
                         _centerX + _sizeX - _radiusX,
                         _centerY - _sizeY + _radiusY,
                         _radiusX + _strokeW,
                         (_sizeY - _radiusY) * 2.0
                         );
         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

         // B
         setQuadVertices(_scratchBuf, border_a_vtx,
                         _centerX - _sizeX - _strokeW,
                         _centerY + _sizeY - _radiusY,
                         (_sizeX + _strokeW) * 2.0f,
                         _radiusY + _strokeW
                         );
         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
      }

      glDisableVertexAttribArray(border_a_vtx);

      border_shader.unbind();

      glDisable(GL_BLEND);
   }

}

// ---------------------------------------------------------------------------- onDraw
function onDraw() {

   float dt = FPS.precision;

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   glClearColor(0.1,0.15,0.3,1.0);
   glClear(GL_COLOR_BUFFER_BIT);

   Buffer scratch_buf;  // mapped VBO (valid during onDraw())
   glBindBuffer(GL_ARRAY_BUFFER, scratch_vbo_id);
   zglMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY, scratch_buf, SCRATCH_BUFFER_SZ);

   float centerX;
   float centerY;
   float sizeX;
   float sizeY;
   float radiusX;
   float radiusY;

   Matrix4f projMatrix;
   projMatrix.initIdentity();
   {
      float projR = VP_W;
      float projB = VP_H;
      projMatrix.ortho(0.0f/*left*/,    projR/*right*/,
                       projB/*bottom*/,  0.0f/*top*/,
                       0.0f/*znear*/,   10.0f/*zfar*/
                       );
   }

   switch(test_idx)
   {
      case 0:
      default:
         centerX = VP_W * 0.5;
         centerY = VP_H * 0.5;
         if(0)
         {
            sizeX = VP_W*0.25;
            sizeY = VP_H*0.25;
            // radiusX = VP_W*0.0625;  radiusY = VP_H*0.0625;
            // radiusX = 40.0f;  radiusY = 40.0f;
            radiusX = 40.0f;  radiusY = 30.0f;
            // radiusX = 30.0f;  radiusY = 40.0f;
            // radiusX = 50.0f;  radiusY = 20.0f;
            // radiusX = 20.0f;  radiusY = 50.0f;
         }
         else
         {
            sizeX = VP_W*0.25 + 70*sin(ang_w);
            sizeY = VP_H*0.25 + 70*sin(ang_h);
            radiusX = 80.0f + sin(ang_x)*40.0;
            radiusY = 80.0f + sin(ang_y)*40.0;
         }
         g.drawRoundRectStroke(scratch_buf,
                               projMatrix,
                               centerX, centerY,
                               sizeX, sizeY,
                               radiusX * radius_sclx, radiusY * radius_scly,
                               1.0f, 1.0f, 1.0f,  alpha, // stroke color
                               stroke_w,
                               b_aa ? aa_range : 0.01f,
                               aa_exp
                               );
         break;

      case 1:
         centerX = VP_W*0.5;
         centerY = VP_H*0.5;
         sizeX = 240.0;
         sizeY = 200.0;
         radiusX = 8.0;
         radiusY = 6.0;
         g.drawRoundRectStroke(scratch_buf,
                               projMatrix,
                               centerX, centerY,
                               sizeX, sizeY,
                               radiusX * radius_sclx, radiusY * radius_scly,
                               1.0f, 1.0f, 1.0f,  alpha, // stroke color
                               stroke_w,
                               b_aa ? aa_range : 0.01f,
                               aa_exp
                               );
         break;

      case 2:
         centerX = VP_W*0.5;
         centerY = VP_H*0.5;
         sizeX = 60.0;
         sizeY =  7.5;
         radiusX = 3.0;
         radiusY = 3.0;
         g.drawRoundRectStroke(scratch_buf,
                               projMatrix,
                               centerX, centerY,
                               sizeX, sizeY,
                               radiusX * radius_sclx, radiusY * radius_scly,
                               1.0f, 1.0f, 1.0f,  alpha, // stroke color
                               stroke_w,
                               b_aa ? aa_range : 0.01f,
                               aa_exp
                               );
         break;
   }
                   
   glUnmapBuffer(GL_ARRAY_BUFFER);
   glBindBuffer(GL_ARRAY_BUFFER, 0);

   float spd = b_anim ? b_slomo ? 0.1 : 1.0 : 0.0;
   ang_x += dt * spd * 0.03;
   ang_y += dt * spd * 0.02634;
   ang_w += dt * spd * 0.0054112634;
   ang_h += dt * spd * 0.0031312634;
   wrap ang_x 0 2PI;
   wrap ang_y 0 2PI;
   wrap ang_w 0 2PI;
   wrap ang_h 0 2PI;

   if(b_queued_screenshot)
   {
      b_queued_screenshot = false;
      SaveScreenShotPNG("../screenshots/roundrect_stroke.png");
   }
}

// ---------------------------------------------------------------------------- onKeyboard
function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_RETURN:
         aa_range  = 2.5 / vp_scale;
         aa_exp    = 1.0;
         stroke_w  = 1.5;
         alpha     = 1.0;
         radius_sclx = 1.0;
         radius_scly = 1.0;
         trace "[...] reset";
         if(2 == test_idx)
         {
            stroke_w = 0.375;
            aa_range = 0.75;
         }
         break;

      case VKEY_SPACE:
         if(_k.mod)
         {
            b_slomo = !b_slomo;
            trace "[...] b_slomo is "+b_slomo;
         }
         else
         {
            b_anim = !b_anim;
            trace "[...] b_anim is "+b_anim;
         }
         break;

      case VKEY_UP:
         aa_range = mathMinf(aa_range + 0.125f, 4.0f);
         trace "[...] aa_range is "+aa_range;
         break;

      case VKEY_DOWN:
         aa_range = mathMaxf(aa_range - 0.125f, 0.125f);
         trace "[...] aa_range is "+aa_range;
         break;

      case VKEY_RIGHT:
         stroke_w = mathMinf(stroke_w + 0.125f, 4.0f);
         trace "[...] stroke_w is "+stroke_w;
         break;

      case VKEY_LEFT:
         stroke_w = mathMaxf(stroke_w - 0.125f, 0.125f);
         trace "[...] stroke_w is "+stroke_w;
         break;

      case '1':
         test_idx = 0;
         trace "[...] test_idx is "+test_idx;
         break;

      case '2':
         test_idx = 1;
         trace "[...] test_idx is "+test_idx;
         break;

      case '3':
         test_idx = 2;
         stroke_w = 0.375;
         aa_range = 0.75;
         trace "[...] test_idx is "+test_idx;
         break;

      case 'a':
         b_aa = !b_aa;
         trace "[...] b_aa is "+b_aa;
         break;

      case 'd':
         g.b_debug = !g.b_debug;
         trace "[...] g.b_debug is "+g.b_debug;
         break;

      case 'f':
         radius_sclx = mathMaxf(radius_sclx - 0.0625f, 0.0625f);
         if(_k.mod)
            radius_scly = radius_sclx;
         trace "[...] radius_sclx is "+radius_sclx;
         break;

      case 'g':
         radius_sclx = mathMinf(radius_sclx + 0.0625f, 8.0f);
         if(_k.mod)
            radius_scly = radius_sclx;
         trace "[...] radius_scl is "+radius_sclx;
         break;

      case 'h':
         radius_scly = mathMaxf(radius_scly - 0.0625f, 0.0625f);
         if(_k.mod)
            radius_sclx = radius_scly;
         trace "[...] radius_scly is "+radius_scly;
         break;

      case 'j':
         radius_scly = mathMinf(radius_scly + 0.0625f, 8.0f);
         if(_k.mod)
            radius_sclx = radius_scly;
         trace "[...] radius_scly is "+radius_scly;
         break;

      case 'k':
         aa_exp = mathMaxf(aa_exp - 0.03125f, 0.03125f);
         if(_k.mod)
            radius_sclx = aa_exp;
         trace "[...] aa_exp is "+aa_exp;
         break;

      case 'l':
         aa_exp = mathMinf(aa_exp + 0.03125f, 3.0f);
         if(_k.mod)
            radius_sclx = aa_exp;
         trace "[...] aa_exp is "+aa_exp;
         break;

      case 'p':
         b_queued_screenshot = true;
         trace "[...] queue screenshot";
         break;

      case 't':
         alpha = mathMinf(alpha + 0.0625f, 1.0f);
         trace "[...] alpha is "+alpha;
         break;

      case 'r':
         alpha = mathMaxf(alpha - 0.0625f, 0.0625f);
         trace "[...] alpha is "+alpha;
         break;

      case 'v':
         b_vsync = !b_vsync;
         trace "[...] b_vsync is "+b_vsync;
         Viewport.swapInterval(b_vsync);
         break;
   }
}

// ---------------------------------------------------------------------------- onOpen
function onOpen() {
   trace "[dbg] onOpen";

   scratch_vbo_id = zglGenBuffer();
   glBindBuffer(GL_ARRAY_BUFFER, scratch_vbo_id);
   zglBufferData(GL_ARRAY_BUFFER, SCRATCH_BUFFER_SZ, null, GL_STATIC_DRAW);
   glBindBuffer(GL_ARRAY_BUFFER, 0);

   if(!g.onOpen())
      die "g.onOpen() failed";
}

// ---------------------------------------------------------------------------- main
function main() {
   use callbacks;

   FPS.tickInterval=1000.0/60;
   FPS.limit=0;

   Viewport.openWindow(640*vp_scale, 480*vp_scale);
   Viewport.swapInterval(b_vsync);

   trace "[...] entering eventloop";

   SDL.eventLoop();
}
