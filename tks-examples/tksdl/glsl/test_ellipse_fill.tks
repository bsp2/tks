// 02Aug2025, 03Aug2025, 05Aug2025, 06Aug2025, 07Aug2025

use tksdl;
use tkopengl;
use tkmath;

putenv("TKSDL_GLERROR=1");

float VP_W = 640.0;
float VP_H = 480.0;

float vp_scale = 2.0;

boolean b_anim      = 0;    // SPACE
boolean b_slomo     = 0;    // lctrl-SPACE
boolean b_aa        = 1;    // 'a'
float   aa_range    = 2.5 / vp_scale;  // UP/DOWN
float   aa_exp      = 1.0;  // 'k', 'l'
float   alpha       = 1.0;  // 'r', 't'
float   radius_sclx = 1.0;  // 'f', 'g'
float   radius_scly = 1.0;  // 'h', 'j'
boolean b_vsync     = 1;    // 'v'

int test_idx = 0;  // '1', '2', ..

float ang_x = 0;
float ang_y = 0;

float ang_w = 0;
float ang_h = 0;

int numframesrendered = 0;

EllipseFill g;
g.init();

int SCRATCH_BUFFER_SZ = 65536;
// int SCRATCH_BUFFER_SZ = (2*3*2*4);  // debug: auto-flush after each quad
int scratch_vbo_id;


// ---------------------------------------------------------------------------- SaveScreenShotPNG
boolean b_queued_screenshot;
function SaveScreenShotPNG(String _pathName) : boolean {
   local Texture tex;
   boolean ret = false;
   if(tex.alloc(Viewport.width, Viewport.height, 4))
   {
      glReadBuffer(GL_BACK);
      int off = 0;
      int y = Viewport.height - 1;
      loop(Viewport.height)
      {
         zglReadColorPixelsX(tex, off, 0/*x*/, y, Viewport.width);
         y--;
         off += Viewport.width;
      }
      ret = tex.saveImage(_pathName);
   }
   return ret;
}

// ---------------------------------------------------------------------------- EllipseFill
class EllipseFill {

   ZGLShader border_shader;
   int border_a_vtx;
   // // int border_vao_id;
   int border_u_transform;
   int border_u_aa_range;
   int border_u_aa_exp;
   int border_u_center;
   int border_u_radius;
   int border_u_color;
   int border_u_debug;

   ZGLShader inner_shader;
   // // int inner_vao_id;
   int inner_a_vtx;
   int inner_vao_id;
   int inner_u_transform;
   int inner_u_color;

   // debug:
   boolean b_draw_inner;
   boolean b_draw_border;

   boolean b_debug;


   public method init() {
      b_draw_inner  = 1;
      b_draw_border = 1;
   }

   // ------------ border vertex shader --------------
   static String border_vs_src = "#version 120
uniform mat4 u_transform;
attribute vec2 a_vtx;
varying vec2 v_p;

void main(void) {
   v_p = a_vtx;
   gl_Position = u_transform * vec4(a_vtx,0,1);
}
      ";

   // ------------ border fragment shader ------------
   static String border_fs_src = "#version 120

uniform vec2  u_center;
uniform vec2  u_radius;
uniform float u_aa_range;
uniform float u_aa_exp;
uniform vec4  u_color;
uniform float u_debug;

varying vec2 v_p;

void main(void) {
   float aRect = 0.0;
   float aRound = 1.0;
   vec4 color = vec4(0,0,0,0);

   // outer
   vec2 vd = abs(v_p - u_center);
   if(vd.x < u_radius.x && vd.y < u_radius.y)
   {
      aRect  = 1.0 - smoothstep(u_radius.x-u_aa_range, u_radius.x, vd.x);
      aRect *= 1.0 - smoothstep(u_radius.y-u_aa_range, u_radius.y, vd.y);
      color = u_color;
      aRect = 1.0;

      // // if(vd.x > 0.0 && vd.y > 0.0)
      {
         vec2 vdn = vd * (vec2(1.0, 1.0) / u_radius);
         float as = asin(vdn.x) * (1.0 / 3.14159265359);
         float r = mix(u_radius.y, u_radius.x, as);
         float rmax = max(u_radius.y, u_radius.x);
         float r2 = (r / rmax);
         float aaR = u_aa_range * r2;
         aRound = 1.0 - smoothstep( (rmax - aaR) / rmax, 1.0, length(vdn));
      }
   }

   float a = aRect * aRound;

   // a = smoothstep(0.0, 1.0, a);
#if 1
   a = pow(a, u_aa_exp);
#endif

   gl_FragColor = vec4(color.xyz, color.a*a);
   if(u_debug > 0.0)
      gl_FragColor = vec4(1,0,0,1);

   // vec2 pn = v_p / vec2(640.0, 480.0);
   // gl_FragColor = vec4(pn,v_p.x,1);

}
   ";

   // ------------ inner vertex shader --------------
   static String inner_vs_src = "#version 120
uniform mat4 u_transform;
attribute vec2 a_vtx;

void main(void) {
   gl_Position = u_transform * vec4(a_vtx,0,1);
}
      ";

   // ------------ inner fragment shader ------------
   static String inner_fs_src = "#version 120
uniform vec4 u_color;
void main(void) {
   gl_FragColor = u_color;
}
   ";

   protected method createBorderShader() : boolean {
      border_shader.vertexSource = border_vs_src;
      border_shader.fragmentSource = border_fs_src;

      if(!border_shader.create())
      {
         trace "[---] EllipseFill::onOpen: failed to create border_shader";
         return false;
      }

      border_a_vtx = border_shader.getAttribLocation("a_vtx");

      border_u_transform = border_shader.getUniformLocation("u_transform");
      border_u_aa_range  = border_shader.getUniformLocation("u_aa_range");
      border_u_aa_exp    = border_shader.getUniformLocation("u_aa_exp");
      border_u_center    = border_shader.getUniformLocation("u_center");
      border_u_radius    = border_shader.getUniformLocation("u_radius");
      border_u_color     = border_shader.getUniformLocation("u_color");
      border_u_debug     = border_shader.getUniformLocation("u_debug");

      // trace "xxx border_a_vtx="+border_a_vtx;
      // trace "xxx border_u_transform="+border_u_transform;
      // trace "xxx border_u_radius="+border_u_radius;

      return true;
   }

   protected method createInnerShader() : boolean {
      inner_shader.vertexSource = inner_vs_src;
      inner_shader.fragmentSource = inner_fs_src;

      if(!inner_shader.create())
      {
         trace "[---] EllipseFill::onOpen: failed to create inner_shader";
         return false;
      }

      inner_a_vtx = inner_shader.getAttribLocation("a_vtx");

      inner_u_transform = inner_shader.getUniformLocation("u_transform");
      inner_u_color     = inner_shader.getUniformLocation("u_color");

      // trace "xxx inner_a_vtx="+inner_a_vtx;
      // trace "xxx inner_u_transform="+inner_u_transform;

      return true;
   }

   public method onOpen() : boolean {
      if(createBorderShader())
      {
         // (note) VAO only works in Core profile or GLES3+
         // // border_vao_id = zglGenVertexArray();
         // // trace "xxx border_vao_id="+border_vao_id;
         // // glBindVertexArray(border_vao_id);
         // // glBindBuffer(GL_ARRAY_BUFFER, vbo_id);
         // // zglVertexAttribOffset(border_a_vtx, 2/*size*/, GL_FLOAT, GL_FALSE/*normalize*/, 0/*stride*/, 0/*offset*/);
         // // glBindBuffer(GL_ARRAY_BUFFER, 0);
         // // glBindVertexArray(0);

         if(createInnerShader())
         {
            // (note) VAO only works in Core profile or GLES3+
            // // inner_vao_id = zglGenVertexArray();
            // // trace "xxx inner_vao_id="+inner_vao_id;
            // // glBindVertexArray(inner_vao_id);
            // // glBindBuffer(GL_ARRAY_BUFFER, vbo_id);
            // // zglVertexAttribOffset(inner_a_vtx, 2/*size*/, GL_FLOAT, GL_FALSE/*normalize*/, 0/*stride*/, 0/*offset*/);
            // // glBindBuffer(GL_ARRAY_BUFFER, 0);
            // // glBindVertexArray(0);

            return true;
         }
      }
      return false;
   }

   protected method allocScratchBuf(int _aVertex, Buffer _scratchBuf, int _numBytes) {
      if(_scratchBuf.offset + _numBytes > _scratchBuf.size)
      {
         glUnmapBuffer(GL_ARRAY_BUFFER);
         glFlush();
         zglMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY, _scratchBuf, _scratchBuf.size);
         _scratchBuf.offset = 0;
      }
      zglVertexAttribOffset(_aVertex, 2/*size*/, GL_FLOAT, GL_FALSE/*normalize*/, 0/*stride*/, _scratchBuf.offset);
   }

   public method drawEllipseFill(Buffer _scratchBuf,
                                 Matrix4f _projMatrix,
                                 float _centerX, float _centerY,
                                 float _radiusX, float _radiusY,
                                 float _fillR,   float _fillG,   float _fillB,   float _fillA,
                                 float _aaRange,
                                 float _aaExp
                                 ) {

      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      glEnable(GL_BLEND);

      int numSeg = 16;
      float extrude = 4.0;
      float rxI = _radiusX - extrude;
      float rxO = _radiusX + extrude;
      float ryI = _radiusY - extrude;
      float ryO = _radiusY + extrude;
      float aStep = 2PI / numSeg;
      float a;
      int numVerts;
      int allocSz;

      boolean bSingle = (_radiusX < 10.0) || (_radiusY < 10.0);
      if(bSingle)
         trace "xxx bSingle";
      // bSingle = true; //xxxxxxxxxx

      // Inner
      if(!bSingle && b_draw_inner)
      {
         inner_shader.bind();

         glUniformMatrix4fv(inner_u_transform, 1/*count*/, GL_TRUE/*transpose*/, _projMatrix);
         glUniform4f(inner_u_color,  _fillR, _fillG, _fillB, _fillA);

         glEnableVertexAttribArray(inner_a_vtx);

         // Calc inner mesh
         a = aStep;
         numVerts = (2 + numSeg);
         allocSz = numVerts * 2/*xy*/ * 4/*float*/;
         allocScratchBuf(border_a_vtx, _scratchBuf, allocSz);
         _scratchBuf.f32 = _centerX;
         _scratchBuf.f32 = _centerY;
         _scratchBuf.f32 = _centerX + rxI;
         _scratchBuf.f32 = _centerY;
         loop(numSeg)
         {
            _scratchBuf.f32 = _centerX + rxI * cos(a);
            _scratchBuf.f32 = _centerY + ryI * sin(a);
            a += aStep;
         }
         // trace "xxx _scratchBuf.offset="+_scratchBuf.offset+" allocSz="+allocSz;
         glDrawArrays(GL_TRIANGLE_FAN, 0, numVerts);

         glDisableVertexAttribArray(inner_a_vtx);

         inner_shader.unbind();
      }

      // Outer border
      border_shader.bind();

      glUniformMatrix4fv(border_u_transform, 1/*count*/, GL_TRUE/*transpose*/, _projMatrix);
      glUniform2f(border_u_center,   _centerX, _centerY);
      glUniform2f(border_u_radius,   _radiusX, _radiusY);
      glUniform1f(border_u_aa_range, _aaRange);
      glUniform1f(border_u_aa_exp,   _aaExp);
      glUniform4f(border_u_color,    _fillR, _fillG, _fillB, _fillA);
      glUniform1f(border_u_debug,    b_debug ? 1.0f : 0.0f);
   
      // trace "xxx programId="+shader.programId+" a_uv="+a_uv+" #attribs="+shader.getNumActiveAttributes();
      glEnableVertexAttribArray(border_a_vtx);

      // Calc border mesh
      if(b_draw_border || bSingle)
      {
         if(bSingle)
         {
            numVerts = 4;
            allocSz = numVerts * 2/*xy*/ * 4/*float*/;
            allocScratchBuf(border_a_vtx, _scratchBuf, allocSz);

            float x = _centerX - _radiusX;
            float y = _centerY - _radiusY;
            float w = _radiusX * 2.0;
            float h = _radiusY * 2.0;

            _scratchBuf.f32 = x;       _scratchBuf.f32 = y;
            _scratchBuf.f32 = x + w;   _scratchBuf.f32 = y;
            _scratchBuf.f32 = x + w;   _scratchBuf.f32 = y + h;
            _scratchBuf.f32 = x;       _scratchBuf.f32 = y + h;

            glDrawArrays(GL_TRIANGLE_FAN, 0, numVerts);
         }
         else
         {
            a = aStep;
            numVerts = (2 + numSeg*2);
            allocSz = numVerts * 2/*xy*/ * 4/*float*/;
            allocScratchBuf(border_a_vtx, _scratchBuf, allocSz);
            _scratchBuf.f32 = _centerX + rxI;
            _scratchBuf.f32 = _centerY +   0;
            _scratchBuf.f32 = _centerX + rxO;
            _scratchBuf.f32 = _centerY +   0;
            loop(numSeg)
            {
               _scratchBuf.f32 = _centerX + rxI * cos(a);
               _scratchBuf.f32 = _centerY + ryI * sin(a);
               _scratchBuf.f32 = _centerX + rxO * cos(a);
               _scratchBuf.f32 = _centerY + ryO * sin(a);
               a += aStep;
            }
            // trace "xxx _scratchBuf.offset="+_scratchBuf.offset+" allocSz="+allocSz;

            glDrawArrays(GL_TRIANGLE_STRIP, 0, numVerts);
         }
      }
     
      glDisableVertexAttribArray(border_a_vtx);

      border_shader.unbind();

      glDisable(GL_BLEND);
   }

}

// ---------------------------------------------------------------------------- onDraw
function onDraw() {

   float dt = FPS.precision;

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   glClearColor(0.1,0.15,0.3,1.0);
   glClear(GL_COLOR_BUFFER_BIT);

   Buffer scratch_buf;  // mapped VBO (valid during onDraw())
   glBindBuffer(GL_ARRAY_BUFFER, scratch_vbo_id);
   zglMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY, scratch_buf, SCRATCH_BUFFER_SZ);

   float centerX;
   float centerY;
   float radiusX;
   float radiusY;

   Matrix4f projMatrix;
   projMatrix.initIdentity();
   {
      float projR = VP_W;
      float projB = VP_H;
      projMatrix.ortho(0.0f/*left*/,    projR/*right*/,
                       projB/*bottom*/,  0.0f/*top*/,
                       0.0f/*znear*/,   10.0f/*zfar*/
                       );
   }

   switch(test_idx)
   {
      case 0:
      default:
         centerX = VP_W * 0.5;
         centerY = VP_H * 0.5;
         if(0)
         {
            // radiusX = VP_W*0.0625;  radiusY = VP_H*0.0625;
            // radiusX = 40.0f;  radiusY = 40.0f;
            radiusX = 40.0f;  radiusY = 30.0f;
            // radiusX = 30.0f;  radiusY = 40.0f;
            // radiusX = 50.0f;  radiusY = 20.0f;
            // radiusX = 20.0f;  radiusY = 50.0f;
         }
         else
         {
            radiusX = 120.0f + sin(ang_x)*80.0;
            radiusY = 120.0f + sin(ang_y)*80.0;
         }
         g.drawEllipseFill(scratch_buf,
                           projMatrix,
                           centerX, centerY,
                           radiusX * radius_sclx, radiusY * radius_scly,
                           1.0f, 1.0f, 1.0f, alpha,  // fill color
                           b_aa ? aa_range : 0.01f,
                           aa_exp
                           );
         break;

      case 1:
         centerX = VP_W*0.5;
         centerY = VP_H*0.5;
         radiusX = 240.0;
         radiusY = 200.0;
         g.drawEllipseFill(scratch_buf,
                           projMatrix,
                           centerX, centerY,
                           radiusX * radius_sclx, radiusY * radius_scly,
                           1.0f, 1.0f, 1.0f, alpha,  // fill color
                           b_aa ? aa_range : 0.01f,
                           aa_exp
                           );
         break;

      case 2:
         centerX = VP_W*0.5;
         centerY = VP_H*0.5;
         radiusX = 60.0;
         radiusY =  7.5;
         g.drawEllipseFill(scratch_buf,
                           projMatrix,
                           centerX, centerY,
                           radiusX * radius_sclx, radiusY * radius_scly,
                           1.0f, 1.0f, 1.0f, alpha,  // fill color
                           b_aa ? aa_range : 0.01f,
                           aa_exp
                           );
         break;
   }
                   
   glUnmapBuffer(GL_ARRAY_BUFFER);
   glBindBuffer(GL_ARRAY_BUFFER, 0);

   float spd = b_anim ? b_slomo ? 0.1 : 1.0 : 0.0;
   ang_x += dt * spd * 0.03;
   ang_y += dt * spd * 0.02634;
   ang_w += dt * spd * 0.0054112634;
   ang_h += dt * spd * 0.0031312634;
   wrap ang_x 0 2PI;
   wrap ang_y 0 2PI;
   wrap ang_w 0 2PI;
   wrap ang_h 0 2PI;

   if(b_queued_screenshot)
   {
      b_queued_screenshot = false;
      SaveScreenShotPNG("../screenshots/ellipse_fill.png");
   }
}

// ---------------------------------------------------------------------------- onKeyboard
function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_RETURN:
         aa_range  = 2.5 / vp_scale;
         aa_exp    = 1.0;
         alpha     = 1.0;
         radius_sclx = 1.0;
         radius_scly = 1.0;
         trace "[...] reset";
         if(2 == test_idx)
         {
            aa_range = 0.75;
         }
         break;

      case VKEY_SPACE:
         if(_k.mod)
         {
            b_slomo = !b_slomo;
            trace "[...] b_slomo is "+b_slomo;
         }
         else
         {
            b_anim = !b_anim;
            trace "[...] b_anim is "+b_anim;
         }
         break;

      case VKEY_UP:
         aa_range = mathMinf(aa_range + 0.125f, 4.0f);
         trace "[...] aa_range is "+aa_range;
         break;

      case VKEY_DOWN:
         aa_range = mathMaxf(aa_range - 0.125f, 0.125f);
         trace "[...] aa_range is "+aa_range;
         break;

      case '1':
         test_idx = 0;
         trace "[...] test_idx is "+test_idx;
         break;

      case '2':
         test_idx = 1;
         trace "[...] test_idx is "+test_idx;
         break;

      case '3':
         test_idx = 2;
         aa_range = 0.75;
         trace "[...] test_idx is "+test_idx;
         break;

      case 'a':
         b_aa = !b_aa;
         trace "[...] b_aa is "+b_aa;
         break;

      case 'd':
         g.b_debug = !g.b_debug;
         trace "[...] g.b_debug is "+g.b_debug;
         break;

      case 'f':
         radius_sclx = mathMaxf(radius_sclx - 0.0625f, 0.0625f);
         if(_k.mod)
            radius_scly = radius_sclx;
         trace "[...] radius_sclx is "+radius_sclx;
         break;

      case 'g':
         radius_sclx = mathMinf(radius_sclx + 0.0625f, 8.0f);
         if(_k.mod)
            radius_scly = radius_sclx;
         trace "[...] radius_scl is "+radius_sclx;
         break;

      case 'h':
         radius_scly = mathMaxf(radius_scly - 0.0625f, 0.0625f);
         if(_k.mod)
            radius_sclx = radius_scly;
         trace "[...] radius_scly is "+radius_scly;
         break;

      case 'j':
         radius_scly = mathMinf(radius_scly + 0.0625f, 8.0f);
         if(_k.mod)
            radius_sclx = radius_scly;
         trace "[...] radius_scly is "+radius_scly;
         break;

      case 'k':
         aa_exp = mathMaxf(aa_exp - 0.03125f, 0.03125f);
         if(_k.mod)
            radius_sclx = aa_exp;
         trace "[...] aa_exp is "+aa_exp;
         break;

      case 'l':
         aa_exp = mathMinf(aa_exp + 0.03125f, 3.0f);
         if(_k.mod)
            radius_sclx = aa_exp;
         trace "[...] aa_exp is "+aa_exp;
         break;

      case 'i':
         g.b_draw_inner = !g.b_draw_inner;
         trace "[...] g.b_draw_inner is "+g.b_draw_inner;
         break;

      case 'o':
         g.b_draw_border = !g.b_draw_border;
         trace "[...] g.b_draw_border is "+g.b_draw_border;
         break;

      case 'p':
         b_queued_screenshot = true;
         trace "[...] queue screenshot";
         break;

      case 't':
         alpha = mathMinf(alpha + 0.0625f, 1.0f);
         trace "[...] alpha is "+alpha;
         break;

      case 'r':
         alpha = mathMaxf(alpha - 0.0625f, 0.0625f);
         trace "[...] alpha is "+alpha;
         break;

      case 'v':
         b_vsync = !b_vsync;
         trace "[...] b_vsync is "+b_vsync;
         Viewport.swapInterval(b_vsync);
         break;
   }
}

// ---------------------------------------------------------------------------- onOpen
function onOpen() {
   trace "[dbg] onOpen";

   scratch_vbo_id = zglGenBuffer();
   glBindBuffer(GL_ARRAY_BUFFER, scratch_vbo_id);
   zglBufferData(GL_ARRAY_BUFFER, SCRATCH_BUFFER_SZ, null, GL_STATIC_DRAW);
   glBindBuffer(GL_ARRAY_BUFFER, 0);

   if(!g.onOpen())
      die "g.onOpen() failed";
}

// ---------------------------------------------------------------------------- main
function main() {
   use callbacks;

   FPS.tickInterval=1000.0/60;
   FPS.limit=0;

   Viewport.openWindow(640*vp_scale, 480*vp_scale);
   Viewport.swapInterval(b_vsync);

   trace "[...] entering eventloop";

   SDL.eventLoop();
}
