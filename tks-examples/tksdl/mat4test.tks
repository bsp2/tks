use tksdl;
use tkopengl;
use tkmath;

float vp_zoom = 1;

float frot = 0;
boolean b_rot = true;
int numframesrendered = 0;
int read_x = -1;
int read_y;
boolean b_queued_screenshot;


function SaveScreenShotPNG(String _pathName) : boolean {
   local Texture tex;
   boolean ret = false;
   if(tex.alloc(Viewport.width, Viewport.height, 4))
   {
      glReadBuffer(GL_BACK);
      int off = 0;
      int y = Viewport.height - 1;
      loop(Viewport.height)
      {
         zglReadColorPixelsX(tex, off, 0/*x*/, y, Viewport.width);
         y--;
         off += Viewport.width;
      }
      ret = tex.saveImage(_pathName);
   }
   return ret;
}

function onDraw() {
   // trace "[...] onDraw";

   float dt=FPS.precision;
   glClearColor(0,0,0.2,1);
   // glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
   glClear(GL_COLOR_BUFFER_BIT);
   glDisable(GL_DEPTH_TEST);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   zglInitOrtho(Viewport.width/float(Viewport.height)*2, -2);

   // T*R*S => first scale, then rotate, then translate
   Matrix4f m;
   m.initIdentity();
   m.translatef(0.5,0,0);
   m.rotatef(0,0,frot);
   m.scalef(1.25,1.5,1);
   zglLoadMatrixTransposef(m);  // load GL_MODELVIEW matrix (transpose to convert from row to GL column major)

   glColor3f(0.9,0.9,0.9);

   if(1)
   {
      glBegin(GL_QUADS);
      glVertex2f(-0.5,-0.5);
      glVertex2f( 0.5,-0.5);
      glVertex2f( 0.5, 0.5);
      glVertex2f(-0.5, 0.5);
      glEnd();
   }
   else
   {
      FloatArray va = [
         -1, -1,
          1, -1,
          1,  1,
         -1,  1
                       ];
      zglVertexPointer2f(va);
      glEnableClientState(GL_VERTEX_ARRAY);
      glDrawArrays(GL_QUADS, 0, 4);
      glDisableClientState(GL_VERTEX_ARRAY);
   }

   if(-1 != read_x)
   {
      glReadBuffer(GL_BACK);
      // glReadBuffer(GL_COLOR_ATTACHMENT0);
      glFinish();
      Integer c32 = zglReadColorPixel(read_x, read_y);
      trace "ReadPixel ("+read_x+";"+read_y+") = ABGR(#"+c32.printf("%08x")+")";
      read_x = -1;
   }

   if(b_queued_screenshot)
   {
      b_queued_screenshot = false;
      SaveScreenShotPNG("screenshots/fpslimit.png");
   }

   if(b_rot)
   {
      frot += dt * 0.01;
      wrap frot 0 2PI;
   }

   // SDL.exitEventLoop();
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
   read_x = _x;
   read_y = _y;

   // if(_cbs & MOUSE_LBUTTON)
   //    Mouse.grab();
   // else if(_nbs & MOUSE_LBUTTON)
   //    Mouse.ungrab();
}

function onKeyboard(Key _k) {
   trace "[...] fpslimit:onKeyboard: k.code="+_k.code+" ("+TKS.constantToString(_k.code, "VKEY_")+") mod="+_k.mod+" pressed="+_k.pressed+" released="+_k.released+" unicode="+_k.unicode+" "+tcchar(_k.unicode);
   switch(_k.pressed)
   {
      case 'f':
         Viewport.toggleFullScreen();
         break;

      case 'p':
         b_queued_screenshot = true;
         trace "[...] queue screenshot";
         break;

      case VKEY_SPACE:
         b_rot = !b_rot;
         trace "[...] b_rot="+b_rot;
         break;

      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;
   }
}

int tim_count = 0;
function onTimer() {
   // trace "[...] onTimer";
   // if(++tim_count > 100)
   //    SDL.exitEventLoop();
}

function main() {
   use callbacks;

   FPS.tickInterval = 1000.0f / 60;
   FPS.limit = 60;

   SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   SDL.timerInterval = 20;

   SDL.dpiAwareness = true;  // no OS scaling
   // SDL.dpiAwareness = false;  // assume 96dpi and let OS scale window to actual DPI

   SDL.touchInput = true;  // enable WM_POINTER* messages

   // Viewport.multisampleSamples = 4;
   // Viewport.multisampleBuffers = 1;
   // Viewport.stencilBits = 8;
   // Viewport.setScreenResolution(1920, 1200, 32);
   trace "xxx call Viewport.openWindow";
   Viewport.openWindow(640*vp_zoom, 480*vp_zoom);
   trace "xxx Viewport.openWindow RETURNED";
   // Viewport.openScreen(640, 480, 32);
   // Viewport.swapInterval(1);

   // trace "xxx #texunits: "+zglGetInteger(GL_MAX_TEXTURE_UNITS);
   trace "[dbg] GL extensions: "+glGetString(GL_EXTENSIONS);
   trace "[dbg] #texunits: "+zglGetInteger(GL_MAX_TEXTURE_IMAGE_UNITS);
   trace "[dbg] max_texture_size: "+zglGetInteger(GL_MAX_TEXTURE_SIZE);
   trace "[dbg] max_samples: "+zglGetInteger(GL_MAX_SAMPLES);  // (note) 4 on macOS 14 (m2pro)
   trace "[dbg] version = "+zglGetInteger(GL_MAJOR_VERSION)+"."+zglGetInteger(GL_MINOR_VERSION);  // GL3.x+

   SDL.enableUNICODE(true);
   SDL.enableKeyRepeat(0,0);

   trace "[dbg] Viewport.dpi="+Viewport.dpi;
   trace "[...] entering eventloop";

   SDL.eventLoop();
}
