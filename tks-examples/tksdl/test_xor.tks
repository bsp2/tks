
use tksdl;
use tkopengl;


int numframesrendered=0;

#define REINIT_TIMEOUT 256.0
float reinit_countdown = REINIT_TIMEOUT;


class Rings {
   float ang_ctrx;
   float ang_ctry;
   float ang_step;
   float ang_stepoff;
   float ang_sx;
   float ang_sy;
   float ang_crw;

   float angspd_ctrx;
   float angspd_ctry;
   float angspd_step;
   float angspd_stepoff;
   float angspd_sx;
   float angspd_sy;
   float angspd_crw;

   int c32;

   static DrawCircle(float ctrX, ctrY, irx, iry, orx, ory, int segments) {
      glBegin(GL_TRIANGLE_STRIP);
      float w = 2PI / (2*segments);
      float a = 0;
      compile loop( (2*segments) +1)
      {
         float ax = irx * sin(a);
         float ay = iry * cos(a);

         float bx = orx * sin(a);
         float by = ory * cos(a);

         a += w;

         glVertex2f(ax + ctrX, ay + ctrY);
         glVertex2f(bx + ctrX, by + ctrY);
      }

      glEnd();
   }

   init() {
      angspd_ctrx    = rnd(0.01);
      angspd_ctry    = rnd(0.01);
      angspd_step    = rnd(0.01);
      angspd_stepoff = rnd(0.01);
      angspd_sx      = rnd(0.01);
      angspd_sy      = rnd(0.01);
      angspd_crw     = rnd(0.01);

      ang_ctrx    = rnd(2PI);
      ang_ctry    = rnd(2PI);
      ang_step    = rnd(2PI);
      ang_stepoff = rnd(2PI);
      ang_sx      = rnd(2PI);
      ang_sy      = rnd(2PI);
      ang_crw     = rnd(2PI);

      int c8= rnd(5)*32 + 128;

      c32 = argb(255, c8, c8, c8);
   }

   drawRings(float ctrX, ctrY, crstep, sx, sy, crw) {
      int numSteps = 16;
      float cirx = 0.01;
      float ciry = 0.01;
      float corx = 0.01 + crw;
      float cory = 0.012 + crw;
      crstep *= 1*(0.05+3*crw*(0.6+0.5*sin(ang_stepoff)));

      loop(numSteps)
      {
         cirx += crstep;
         ciry += crstep;
         corx += crstep;
         cory += crstep;
         DrawCircle(ctrX, ctrY, cirx * sx, ciry * sy, corx * sx, cory * sy, 32);
      }
   }

   draw(float dt) {
      float ctrX, ctrY, crstep, sx, sy, crw;

      zglColorARGB(c32);

      ctrX = sin(ang_ctrx) * 0.45;
      ctrY = cos(ang_ctry) * 0.45;
      crstep = 0.15 + 0.0123710082845*sin(ang_stepoff) + sin(ang_step)*0.01;
      sx = 1.05 + 0.15 * sin(ang_sx);
      sy = 1.05 + 0.15 * sin(ang_sy);
      crw = 0.04 + (0.5 + sin(ang_crw)*0.5) * 0.08;
      drawRings(ctrX, ctrY, crstep, sx, sy, crw);

      ang_ctrx += angspd_ctrx * dt * 3.631;
      if(ang_ctrx >= 2PI)
         ang_ctrx -= 2PI;

      ang_ctry += angspd_ctry * dt * 3.631;
      if(ang_ctry >= 2PI)
         ang_ctry -= 2PI;

      ang_step += angspd_step * dt * 0.05;
      if(ang_step >= 2PI)
         ang_step -= 2PI;

      ang_stepoff += angspd_stepoff * dt * 0.1;
      if(ang_stepoff >= 2PI)
         ang_stepoff -= 2PI;

      ang_sx += angspd_sx * dt;
      if(ang_sx >= 2PI)
         ang_sx -= 2PI;

      ang_sy += angspd_sx * dt;
      if(ang_sy >= 2PI)
         ang_sy -= 2PI;

      ang_crw += angspd_crw * dt * 3;
      if(ang_crw >= 2PI)
         ang_crw -= 2PI;
   }
}


class TestXOR {

   Rings rings1;
   Rings rings2;
   Rings rings3;
   Rings rings4;
   Rings rings5;
   Rings rings6;
   Rings rings7;
   Rings rings8;

   public method init() {
      rings1.init();
      rings2.init();
      rings3.init();
      rings4.init();
      rings5.init();
      rings6.init();
      rings7.init();
      rings8.init();
   }
 
   public method draw(float dt) {

      reinit_countdown -= dt;
      if(reinit_countdown < 0)
      {
         init();
         reinit_countdown = REINIT_TIMEOUT;
      }


      dt*=0.3;

      zglInitOrtho(1, -1);
      glColor3f(1,1,1);

      glEnable(GL_COLOR_LOGIC_OP);
      glLogicOp(GL_XOR);
      //glLogicOp(GL_COPY);

      rings1.draw(dt);
      rings2.draw(dt);
      rings3.draw(dt);
      rings4.draw(dt);
      rings5.draw(dt);
      rings6.draw(dt);
      rings7.draw(dt);
      rings8.draw(dt);

      glDisable(GL_COLOR_LOGIC_OP);
      glLogicOp(GL_COPY);
   }
}


TestXOR testxor;

function onDraw() {

    float dt=FPS.precision;

    if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

    glClearColor(0.1, 0.1, 0.1, 1.0);
    glClear(GL_COLOR_BUFFER_BIT);

    testxor.draw(dt);
}

function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;
      case VKEY_SPACE:
         testxor.init();
         break;
   }
}

function main() {

   testxor.init();
   
   Viewport.multisampleSamples = 2;
   Viewport.multisampleBuffers = 1;
   Viewport.openWindow(640, 480);
   use callbacks;
   FPS.tickInterval=1000.0/60;
   Viewport.swapInterval(1);
   trace "xxx entering eventloop";
   SDL.eventLoop();
}

