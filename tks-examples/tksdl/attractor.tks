
// 23Nov2021

// http://www.3d-meier.de/tut19/Seite52.html

use tksdl;
use tkopengl;

int NUM_STEPS = 10;

Double attractor_x = 0.1;
Double attractor_y = 0.1;
Double attractor_z = 1.0;

int num_steps = NUM_STEPS;


abstract class Attractor {
   define int ATTR_RAYLEIGH              = 0;
   define int ATTR_BUCKLINGCOLUMN_BROKEN = 1;  // not an attractor. looks interesting, though.
   define int ATTR_BUCKLINGCOLUMN        = 2;
   define int ATTR_CATHALA               = 3;
   define int ATTR_CHENCELIKOVSKY        = 4;
   define int ATTR_SHIMIZUMORIOKA        = 5;
   define int ATTR_LORENZMOD2            = 6;
   define int ATTR_LORENZ                = 7;
   define int ATTR_NUM                   = 8;

   Double a;
   Double b;
   Double c;
   Double d;

   Double x;
   Double y;
   Double z;

   Double delta_t = 0.01;

   Double scale_x = 0.5;
   Double scale_y = 0.5;
   Double scale_z = 1.0;

   init() {
   }

   protected stepInt() {
   }

   step() {
      x = attractor_x;
      y = attractor_y;
      z = attractor_z;

      stepInt();

      attractor_x = x;
      attractor_y = y;
      attractor_z = z;
   }

   leave() {
      delta_t     = 0.01;
      attractor_z = 1.0;
      num_steps   = NUM_STEPS;
   }

   static NewById(int _attrId) : Attractor {
      switch(_attrId)
      {
         default:
         case ATTR_RAYLEIGH:
            return new Rayleigh;

         case ATTR_BUCKLINGCOLUMN_BROKEN:
            return new BucklingColumnBroken;

         case ATTR_BUCKLINGCOLUMN:
            return new BucklingColumn;

         case ATTR_CATHALA:
            return new Cathala;

         case ATTR_CHENCELIKOVSKY:
            return new ChenCelikovsky;

         case ATTR_SHIMIZUMORIOKA:
            return new ShimizuMorioka;

         case ATTR_LORENZMOD2:
            return new LorenzMod2;

         case ATTR_LORENZ:
            return new Lorenz;
      }
   }
}

class Rayleigh : Attractor {

   init() {
      a = 1.0;
      b = 1.0;
      c = 1.0;
      d = 1.0;

      // x = 0.1;
      // y = 0.1;

      scale_x = 0.5;
      scale_y = 0.5;
      scale_z = 1.0;

      delta_t = 0.01;
   }

   stepInt() {
      x += delta_t * y;
      y += delta_t * (-(x + b*y*y*y - a*y) / (c * d));
   }
}

class BucklingColumnBroken : Attractor {

   init() {
      a = 20.0;
      b = -10.0;
      c = 5.0;
      d = 10.0;

      attractor_x = 1.61;
      attractor_y = 0.1;

      scale_x = 0.015;
      scale_y = 0.015;
      scale_z = 1.0;

      delta_t = 0.01;
   }

   stepInt() {
      x += delta_t * y;
      // y += delta_t * -((a*x*x*x + b*x + c*y)/d);
      y += delta_t * ((-a*x*x*x + b*x + c*y)/d);
   }

   leave() {
      Attractor::leave();
      attractor_x = 0.1;
      attractor_y = 0.1;
      attractor_z = 1.0;
   }
}

class BucklingColumn : Attractor {

   init() {
      a = 20.0;
      b = -10.0;
      c = 5.0;
      d = 10.0;

      // x = 1.61;
      // y = 0.1;

      scale_x = 0.5;
      scale_y = 0.5;
      scale_z = 1.0;

      delta_t = 0.01;
   }

   stepInt() {
      float dx = y;
      float dy = -((a*x*x*x + b*x + c*y)/d);
      x += delta_t * dx;
      y += delta_t * dy;
   }
}

class Cathala : Attractor {

   init() {
      a = 0.7;
      b = -0.82;

      // a = 0.3;
      // b = -0.82;

      x = 0.5;
      y = 0.5;
      attractor_x = x;
      attractor_y = y;

      scale_x = 0.5;
      scale_y = 0.5;

      // delta_t = 0.9985;
      // delta_t = 0.892985;  // race track :-)
      delta_t = 1.0;

      num_steps = 1000;
   }

   stepInt() {
      float dx = (a*x + y);
      float dy = (b + x*x);
      x +=  delta_t * (dx - x);
      y +=  delta_t * (dy - y);
      // trace "xxx p=("+x+";"+y+")";
   }
}

class ChenCelikovsky : Attractor {

   init() {
      a = 36;
      b = 3;
      c = 20;

      x = 1;
      y = 1;
      z = 1;

      scale_x = 0.04;
      scale_y = 0.035;
      scale_z = 0.035;

      delta_t = 0.001;

      num_steps = 50;
   }

   stepInt() {
      float dx = a*(y - x)    - x;
      float dy = (-x*z + c*y) - y;
      float dz = (x*y - b*z)  - z;
      x +=  delta_t * dx;
      y +=  delta_t * dy;
      z +=  delta_t * dz;
   }
}

class ShimizuMorioka : Attractor {
   init() {
      a = 0.75;
      b = 0.45;

      x = 0.1;
      y = 0;
      z = 0;

      attractor_x = x;
      attractor_y = y;
      attractor_z = z;

      scale_x = 0.7;
      scale_y = 0.92;
      scale_z = 0.75;

      delta_t = 0.005;

      num_steps = 200;
   }

   stepInt() {
      float dx = y;
      float dy = (1 - z)*x - a*y;
      float dz = x*x - b*z;
      // x +=  delta_t * (dx - x);
      // y +=  delta_t * (dy - y);
      // z +=  delta_t * (dz - z);
      x +=  delta_t * dx;
      y +=  delta_t * dy;
      z +=  delta_t * dz;

      // trace "xxx p=("+x+";"+y+";"+z+")";
   }
}

class LorenzMod2 : Attractor {
   init() {
      a = 0.9;
      b = 5;
      c = 9.9;
      d = 1.0;

      x = 1;
      y = 1;
      z = 1;

      attractor_x = x;
      attractor_y = y;
      attractor_z = z;

      scale_x = 0.12;
      scale_y = 0.085;
      scale_z = 0.09;

      delta_t = 0.001;

      num_steps = 100;
   }

   stepInt() {

      Double dx = -a*x + y*y - z*z + a*c;
      Double dy = x*(y - b*z) + d;
      Double dz = -z + x*(b*y + z);

      // // dx = (dx - x);
      // // dy = (dy - y);
      // // dz = (dz - z);

      x +=  delta_t * dx;
      y +=  delta_t * dy;
      z +=  delta_t * dz;

      // trace "xxx 2 p=("+x+";"+y+";"+z+")";
   }
}

class Lorenz : Attractor {
   init() {
      a = 10;
      b = 8.0/3;
      c = 28;

      x = 1;
      y = 1;
      z = 1;

      attractor_x = x;
      attractor_y = y;
      attractor_z = z;

      scale_x = 0.05;
      scale_y = 0.035;
      scale_z = 0.03;

      delta_t = 0.001;

      num_steps = 100;
   }

   stepInt() {
      // trace "xxx 1 p=("+x+";"+y+";"+z+")";

      Double dx = a*(y - x);
      Double dy = x*(c - z) - y;
      Double dz = x*y - b*z;

      // // dx = (dx - x);
      // // dy = (dy - y);
      // // dz = (dz - z);

      // // x +=  delta_t * dx;
      // // y +=  delta_t * dy;
      // // z +=  delta_t * dz;

      // // x = x + (dx - x) * delta_t;
      // // y = y + (dy - y) * delta_t;
      // // z = z + (dz - z) * delta_t;

      x = x + dx * delta_t;
      y = y + dy * delta_t;
      z = z + dz * delta_t;

      // // x = dx;
      // // y = dy;
      // // z = dz;

      // trace "xxx 2 p=("+x+";"+y+";"+z+")";
   }
}

int attr_id = 0;
Attractor attractor <= Attractor.NewById(attr_id);
attractor.init();

int numframesrendered=0;

function onDraw() {

   float dt=FPS.precision;

   zglInitOrtho(1, 1);
   glDisable(GL_DEPTH_TEST);

   if(0 == numframesrendered)
   {
      glClearColor(0,0,0.2,1);
      // glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
      glClear(GL_COLOR_BUFFER_BIT);
   }
   else
   {
      // fade last frame
      glEnable(GL_BLEND);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      glColor4f(0,0,0.2,0.03);
      glBegin(GL_QUADS);
      glVertex2f(-1,-1);
      glVertex2f( 1,-1);
      glVertex2f( 1, 1);
      glVertex2f(-1, 1);
      glEnd();
   }

   // draw current position
   glPointSize(3.0f);

   glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
   glEnable(GL_POINT_SMOOTH);
   glBegin(GL_POINTS);
   loop(num_steps)
   {
      glColor4f(attractor_z * attractor.scale_z,1,1,1);
      // glColor4f(1,1,1,1);
      glVertex2f(attractor_x * attractor.scale_x, attractor_y * attractor.scale_y);     
      attractor.step();
   }
   glEnd();

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   // print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
}

function SelectAttractor(int _attrId) {
   attractor.leave();
   attractor <= Attractor.NewById(_attrId);
   attractor.init();
}

function onKeyboard(Key _k) {
   // trace "xxx onKeyboard: k.code="+_k.code+" mod="+_k.mod+" unicode="+_k.unicode+" "+tcchar(_k.unicode);
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case '1':
         SelectAttractor(Attractor.ATTR_RAYLEIGH);
         break;

      case '2':
         SelectAttractor(Attractor.ATTR_BUCKLINGCOLUMN_BROKEN);
         break;

      case '3':
         SelectAttractor(Attractor.ATTR_BUCKLINGCOLUMN);
         break;

      case '4':
         SelectAttractor(Attractor.ATTR_CATHALA);
         break;

      case '5':
         SelectAttractor(Attractor.ATTR_CHENCELIKOVSKY);
         break;

      case '6':
         SelectAttractor(Attractor.ATTR_SHIMIZUMORIOKA);
         break;

      case '7':
         SelectAttractor(Attractor.ATTR_LORENZMOD2);
         break;

      case '8':
         SelectAttractor(Attractor.ATTR_LORENZ);
         break;
   }
}

int tim_count = 0;
function onTimer() {
   // trace "xxx onTimer";
   // if(++tim_count > 100)
   //    SDL.exitEventLoop();
}

function main() {
   use callbacks;

   FPS.tickInterval=1000.0/60;
   //FPS.limit=30;
   FPS.limit=60;

   // SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   // SDL.timerInterval = 20;

   SDL.dpiAwareness = true;  // no OS scaling
   // SDL.dpiAwareness = false;  // assume 96dpi and let OS scale window to actual DPI

   // SDL.touchInput = true;  // enable WM_POINTER* messages

   Viewport.caption = "Attractors (keys 1..9)";
   // Viewport.multisampleSamples = 4;
   // Viewport.multisampleBuffers = 1;
   // Viewport.stencilBits = 8;
   Viewport.doubleBuffer = false;
   Viewport.openWindow(640, 480);
   //Viewport.openScreen(640, 480, 32);
   //Viewport.swapInterval(1);

   // SDL.enableUNICODE(true);

   trace "xxx Viewport.dpi="+Viewport.dpi;
   trace "xxx entering eventloop";

   SDL.eventLoop();
}
