
// tests GL_QUAD_STRIP and glPolygonMode() via glDrawElements()

use tksdl;
use tkopengl;

int numframesrendered=0;

FloatArray verts = [
   -0.6, 0.6,
   -0.6, -0.6,
   -0.5, 0.6,
   -0.5, -0.6,

   -0.4, 0.5,
   -0.4, -0.5,

   -0.3, 0.7,
   -0.3, -0.7,

   -0.2, 0.4,
   -0.2, -0.4,

   -0.1, 0.9,
   -0.1, -0.9,

   // mirrored
    0.1, 0.9,
    0.1, -0.9,

    0.2, 0.4,
    0.2, -0.4,

    0.3, 0.7,
    0.3, -0.7,

    0.4, 0.5,
    0.4, -0.5,

    0.5, 0.6,
    0.5, -0.6,

    0.6, 0.6,
    0.6, -0.6

                         ];

int offset = 0;
int num = verts.numElements/2;

boolean b_color_array = false;

// gen colors
FloatArray colors;
colors.alloc(4* num);
loop(num/4)
{
   colors.addArray([0.0, 1.0, 1.0, 1.0], 0, -1);
   colors.addArray([0.0, 1.0, 1.0, 1.0], 0, -1);

   colors.addArray([0.0, 0.6, 0.6, 1.0], 0, -1);
   colors.addArray([0.0, 0.6, 0.6, 1.0], 0, -1);
}

IntArray indices;
indices.alloc(verts.numElements/2);
indices.identity(indices.maxElements);

function RemapArrays() {

   indices.reverse();

   FloatArray nverts;
   nverts.alloc(verts.numElements);
   FloatArray ncolors;
   nverts.alloc(colors.numElements);

   int idx = 0;
   loop(num)
   {
      int k = indices[idx];
      nverts[2*idx +0] = verts[2*k +0];
      nverts[2*idx +1] = verts[2*k +1];
      ncolors[4*idx +0] = colors[4*k +0];
      ncolors[4*idx +1] = colors[4*k +1];
      ncolors[4*idx +2] = colors[4*k +2];
      ncolors[4*idx +3] = colors[4*k +3];
      idx++;
   }

   verts = nverts;
   colors = ncolors;
}

RemapArrays();


function DrawQuadStrip(boolean _bAllowColorArray) {
   int n = num;

   if((offset + n) > (verts.numElements/2))
   {
      n = (verts.numElements/2) - offset;
   }

   zglVertexPointer2f(verts);
   glEnableClientState(GL_VERTEX_ARRAY);

   if(b_color_array && _bAllowColorArray)
   {
      zglColorPointer4f(colors);
      glEnableClientState(GL_COLOR_ARRAY);
   }

   IntArray indexArray;
   indexArray.visit(indices, offset, n);
   glDrawElements(GL_QUAD_STRIP, indexArray);

   if(b_color_array && _bAllowColorArray)
   {
      glDisableClientState(GL_COLOR_ARRAY);
   }

   glDisableClientState(GL_VERTEX_ARRAY);
}

function onDraw() {

   float dt=FPS.precision;
   glClearColor(0,0,0.2,1);
   glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   zglInitOrtho(1, 1);

   glLineWidth(2);
   glPointSize(4);

   zglColorARGB(#ff00ffff);
   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
   DrawQuadStrip(true);

   zglColorARGB(#ffff0000);
   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
   DrawQuadStrip(false);

   zglColorARGB(#ffffffff);
   glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
   DrawQuadStrip(false);
}

function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_LEFT:
         if(offset > 0)
            offset -= 2;
         trace "[...] offset is now "+offset;
         break;

      case VKEY_RIGHT:
         if(offset < ((verts.numElements/2) -2))
            offset += 2;
         trace "[...] offset is now "+offset;
         break;

      case VKEY_DOWN:
         if(num > 0)
            num -= 2;
         trace "[...] num is now "+num;
         break;

      case VKEY_UP:
         if(num < (verts.numElements/2))
            num += 2;
         trace "[...] num is now "+num;
         break;

      case VKEY_SPACE:
         b_color_array = !b_color_array;
         trace "[...] b_color_array is now "+b_color_array;
         break;
   }
}

function main() {
   use callbacks;

   FPS.tickInterval=1000.0/60;
   FPS.limit=60;

   Viewport.openWindow(640, 480);
   Viewport.swapInterval(1);

   SDL.enableKeyRepeat(150, 50);

   trace "xxx entering eventloop";
   SDL.eventLoop();
}
