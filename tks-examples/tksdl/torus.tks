/// file : torus.tks  by Bastian Spiegel <fli@tkscript.de>
/// note : another simple demonstration for display lists
///        also see the procmeshtorus* examples
///

use tksdl;

// ---- ATI rage mobility m1
//#define RESI 32
//#define RESO 48

// ---- NVIDIA geforce2gts
#define RESI 32
#define RESO 128
#define LIGHTNR GL_LIGHT0

enum { RD_POINTS, RD_LINES, RD_WIREFRAME, RD_TRIS, RD_PAD };

float cam_z=-18.49666;
float cam_fov=10.0;
float cam_zadd=0;
Vector points[RESI*(RESO+2)];
Vector points_lines[RESI*(RESO+2)]; // could use polygonoffset but did not work on my gfx board ...
Vector normals[RESI*(RESO+2)];
WrappedFloat ctick; // counter that is used to calculate the current clearColor.
WrappedFloat xrot;
WrappedFloat yrot;
WrappedFloat zrot;
WrappedFloat lightxrot;
WrappedFloat lightyrot;
WrappedFloat lightzrot;
int render_mode=RD_TRIS;
int stop_anim=0;
int vsync=0;
int light_enabled=1;
int draw_normals=1;
DisplayList dl;
DisplayList ndl;
int have_dl;
int have_ndl=0;
int use_dl=1;

function init_points() compile {
   int o;
   int i;
   Matrix rm;
   Matrix orm;
   Vector pv;
   Vector cv;
   Vector sv;
   sv.init(1.0, 1.0, 0.75);
   for(o=0; o<RESO; o++)
	{
      orm.init( 0,0, (o*2PI)/RESO);
      for(i=0; i<RESI; i++)
		{
         rm.init( 0, -(i*2PI)/RESI, 0);

         cv<=points.nextFree;
         cv.init(0.125, 0, 0);
         cv.rotate(rm);
         cv.scalev(sv);
         cv.x+=1.0;
         cv.rotate(orm);
         cv.scalef(10.0);

         cv<=normals.nextFree;
         cv.init(1.0, 0.0, 0.0);
         cv.rotate(rm);
         cv.rotate(orm);
         cv.unit();

         cv<=points_lines.nextFree;
         cv.init(0.16, 0, 0);
         cv.rotate(rm);
         cv.scalev(sv);
         cv.x+=1.0;
         cv.rotate(orm);
         cv.scalef(10.0);
		}
	}
   for(i=0; i<RESI*2; i++)
	{
      cv<=points.nextFree;
      cv=points[i];
      cv<=normals.nextFree;
      cv=normals[i];
      cv<=points_lines.nextFree;
      cv=points_lines[i];
	}
}

function draw_torus() {
   Vector lightpos;
   Matrix lightrm;
   int i;
   int j;
   int k;
   int n=RESI*RESO;
   Vector nv;
   Vector v1;
   Vector v2;
   Vector v3;
   glFrontFace(GL_CW);
   glCullFace(GL_BACK);
   glEnable(GL_CULL_FACE);
   glEnable(GL_DEPTH_TEST);
   if(light_enabled&&(render_mode>RD_WIREFRAME))
	{
      glLoadIdentity();
      glEnable(LIGHTNR);
      glEnable(GL_LIGHTING);
      zglLightModelAmbient4f(0.44, 0.44, 0.44, 1);
      zglLightModelTwoSide(false);
      zglLightModelLocalViewer(false);
      zglLightDiffuse4f(LIGHTNR, 0.125, 0.125, 0.125, 1);
      zglLightSpecular4f(LIGHTNR, 1,1,1,1);
      lightpos.init(1.0, 0.0, 0.0);
      lightrm.init(lightxrot.value, lightyrot.value, lightzrot.value);
      lightpos.rotate(lightrm);
      lightpos.x=0.0;
      lightpos.y=0.0;
      lightpos.z=2.0;
      zglLightPositionv(LIGHTNR, lightpos, 0.0);
      zglLightSpotDirectionf(LIGHTNR, 0.0, 0.0, -1.0);
      zglLightSpotCutOff(LIGHTNR, 180);
      zglLightSpotExponent(LIGHTNR, 0);
      zglLightConstantAttenuation(LIGHTNR, 1.0);
      zglLightLinearAttenuation(LIGHTNR, 0.0);
      zglLightQuadraticAttenuation(LIGHTNR, 0.0);
      zglLightMaterialShininess(GL_FRONT_AND_BACK, 90);
      zglLightMaterialAmbientAndDiffuse4f(GL_FRONT_AND_BACK, 0.25,0.25,0.25,0.25);
      zglLightMaterialSpecular4f(GL_FRONT_AND_BACK, 1,1,1,1);
      zglLightMaterialEmission4f(GL_FRONT_AND_BACK, 0.125,0.125,0.125,0.125);
	}
   else
	{
      glDisable(LIGHTNR);
      glDisable(GL_LIGHTING);
	}
   if(have_dl&&use_dl)
	{
      glLoadIdentity();
      glScalef(1.0/10.0, 1.0/10.0, 1.0);
      glTranslatef(0, 0, cam_z);
      //zglRotate3f(xrot.value,yrot.value,zrot.value);
      glRotatef(yrot.value, 1,0,0);
      glRotatef(zrot.value, 0,0,1);
      glRotatef(xrot.value, 0,1,0);
      dl.draw();
	}
   else
      compile {
	    
         glLoadIdentity();
         glScalef(1.0/10.0, 1.0/10.0, 1.0);
         glTranslatef(0, 0, cam_z);
         zglRotate3f(xrot.value,yrot.value,zrot.value);
         if(use_dl)
         {
            dl.free();
            dl.alloc();
            dl.begin();
         }
         glDisable(GL_TEXTURE_2D);
         glDisable(GL_BLEND);
         zglColorARGB(#ffff0000);
         switch(render_mode)
         {
            case RD_LINES:
               zglColorARGB(#ff00ff00);
               for(j=0; j<RESO; j++)
               {
                  glBegin(GL_LINE_LOOP);
                  for(i=0; i<RESI; i++)
                  {
                     zglVertexv(points[j*RESI+i]);
                  }
                  glEnd();
               }
               break;
            case RD_POINTS:
               zglColorARGB(#ff00ff00);
               glBegin(GL_POINTS);
               for(i=0; i<n; i++)
               {
                  zglVertexv(points[i]);
               }
               glEnd();
               break;
            case RD_WIREFRAME:
               zglColorARGB(#ff4f0000);
               glBegin(GL_TRIANGLES);
               k=0;
               for(j=0; j<RESO; j++)
               {
                  for(i=0; i<RESI; i++)
                  {
                     // draw first tri
                     v1<=points[k+i];
                     v2<=points[k+((i+1)%RESI)];
                     v3<=points[k+((i+1)%RESI)+RESI];
                     zglVertexv(v1);
                     zglVertexv(v2);
                     zglVertexv(v3);

                     // draw second tri
                     v1<=points[k+((i+1)%RESI)+RESI];
                     v2<=points[k+i+RESI];
                     v3<=points[k+i];
                     zglVertexv(v1);
                     zglVertexv(v2);
                     zglVertexv(v3);
                  }
                  k+=RESI;
               }
               glEnd();

               zglColorARGB(#ff00ff00);
               k=0;
               for(j=0; j<RESO; j++)
               {
                  for(i=0; i<RESI; i++)
                  {
                     // draw first tri
                     v1<=points_lines[k+i];
                     v2<=points_lines[k+((i+1)%RESI)];
                     v3<=points_lines[k+((i+1)%RESI)+RESI];
                     glBegin(GL_LINE_LOOP);
                     zglVertexv(v1);
                     zglVertexv(v2);
                     zglVertexv(v3);
                     glEnd();

                     // draw second tri
                     v1<=points_lines[k+((i+1)%RESI)+RESI];
                     v2<=points_lines[k+i+RESI];
                     v3<=points_lines[k+i];
                     glBegin(GL_LINE_LOOP);
                     zglVertexv(v1);
                     zglVertexv(v2);
                     zglVertexv(v3);
                     glEnd();
                  }
                  k+=RESI;
               }
               break;

            case RD_TRIS:
               glBegin(GL_TRIANGLES);
               k=0;
               for(j=0; j<RESO; j++)
               {
                  for(i=0; i<RESI; i++)
                  {
                     // draw first tri
                     v1<=points[k+i];
                     v2<=points[k+((i+1)%RESI)];
                     v3<=points[k+((i+1)%RESI)+RESI];
                     if(light_enabled)
                     {
                        zglLightMaterialSpecular4f(GL_FRONT_AND_BACK, 0.71, 0.71, 0.71, 0.7);
                        zglLightMaterialAmbientAndDiffuse4f(GL_FRONT_AND_BACK, 1, 0, 0, 0.5);
                     }
                     else
                        zglColorARGB(#ff777711);
                     zglNormalv(normals[k+i  ]);
                     zglVertexv(v1);
                     zglNormalv(normals[k+((i+1)%RESI)]);
                     zglVertexv(v2);
                     zglNormalv(normals[k+((i+1)%RESI)+RESI]);
                     zglVertexv(v3);

                     // draw second tri
                     v1<=points[k+((i+1)%RESI)+RESI];
                     v2<=points[k+i+RESI];
                     v3<=points[k+i];
                     if(light_enabled)
                     {
                        zglLightMaterialSpecular4f(GL_FRONT_AND_BACK, 1, 1, 1, 1);
                        zglLightMaterialAmbientAndDiffuse4f(GL_FRONT_AND_BACK, 0.5, 0, 0, 0.5);
                     }
                     else
                        zglColorARGB(#ff112277);
                     zglNormalv(normals[k+((i+1)%RESI)+RESI]);
                     zglVertexv(v1);
                     zglNormalv(normals[k+i+RESI]);
                     zglVertexv(v2);
                     zglNormalv(normals[k+i]);
                     zglVertexv(v3);
                  }
                  k+=RESI;
               }
               glEnd();
               break;
         }
         if(use_dl)
         {
            dl.end();
            have_dl=1;
         }
      }

   if(draw_normals)
	{
      glDisable(GL_LIGHTING);
      glDisable(GL_TEXTURE_2D);
      glEnable(GL_BLEND);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE);
//  	    zglColorARGB(#4fffff00);
      zglColorARGB(#ffff0000);
      if(have_ndl)
         ndl.draw();
      else
		{
         ndl.alloc();
         ndl.begin();
         Vector tnormalv;
         glBegin(GL_LINES);
         for(j=0; j<RESO*RESI; j++)
			{
            zglVertexv(points[j]);
            tnormalv=points[j];
            tnormalv.addScale(normals[j], 0.46);
            zglVertexv(tnormalv);
			}
         glEnd();
         ndl.end();
         have_ndl=1;
		}
      glDisable(GL_BLEND);
	}
}


function onDraw {
   zglInitPerspective(4.0/3.0, cam_fov, 0.1, 35.0);
   glClearColor(0,0.26,0.26,1);
   glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
   draw_torus();
   Debug.Draw();
   if(vsync) Viewport.waitVBlank();
   float dt=FPS.precision;
   if(!stop_anim)
	{
      ctick.tickPrecise(dt);
      xrot.tickPrecise(dt);
      yrot.tickPrecise(dt);
      zrot.tickPrecise(dt);
	}
   lightxrot.tickPrecise(dt);
   lightyrot.tickPrecise(dt);
   lightzrot.tickPrecise(dt);
   cam_z+=cam_zadd*dt;
}

function ChangeRenderMode() {
   render_mode=(render_mode+1)%RD_PAD;
   trace "rendermode set to "+render_mode;
   have_dl=0;
}

function ToggleUseDisplayLists() {
   use_dl=1-use_dl;
   have_dl=0;
   trace "use_dl to "+use_dl;
}

function ToggleLighting() {
   light_enabled=1-light_enabled;
   have_dl=0;
   trace "light_enabled set to "+light_enabled;
}

function ToggleNormals() {
   draw_normals=1-draw_normals;
   trace "draw_normals set to "+draw_normals;
}

function ToggleVSync() {
   vsync=1-vsync;
   trace "vsync set to "+vsync;
}

function onOpen {
   // ...upload textures...
   have_dl=0;
   have_ndl=0;
   Debug.Init();
}

function onKeyboard(Key _k) {
   switch(_k.released) {
      case VKEY_LCTRL: stop_anim=0; break; 
      case VKEY_SPACE: cam_fov=10.0; cam_z=2.49666; break;
      case VKEY_UP: if(cam_zadd==0.1)cam_zadd=0; break;
      case VKEY_DOWN: if(cam_zadd==-0.1)cam_zadd=0; break;
      default:
         switch(_k.pressed) {
            default: Debug.OnKeyboard(_k); break;
            case VKEY_LCTRL: stop_anim=1; break;
            case VKEY_SPACE: cam_fov=20.0; cam_z=-14.5; break;
            case 'r': ChangeRenderMode(); break;
            case 'l': ToggleLighting(); break;
            case 'c': ToggleUseDisplayLists(); break;
            case 'n': ToggleNormals(); break;
            case 'v': ToggleVSync(); break;
            case VKEY_UP: cam_zadd=0.1; break;
            case VKEY_DOWN: cam_zadd=-0.1; break;
         } break;
   }
}

function main {
   use callbacks;      // bind event callbacks

   trace("-------- a simple example that demonstrates OpenGL lighting and the use of DisplayLists. --------");

   ctick.init(0.0, 0.01, 0.0, 1.0);
   xrot.init(0.0, 0.019710, 0.0, 360.0);
   yrot.init(0.0, 0.2832975, 0.0, 360.0);
   zrot.init(0.0, 0.24, 0.0, 360.0);
   lightxrot.init(0.0, 0.015, 0.0, 2PI);
   lightyrot.init(0.0, 0.0275, 0.0, 2PI);
   lightzrot.init(0.0, 0.0123, 0.0, 2PI);
   lightxrot.init(0.0, 0.0, 0.0, 2PI);
   lightyrot.init(0.0, 0.0, 0.0, 2PI);
   lightzrot.init(0.0, 0.0, 0.0, 2PI);
   init_points();
   have_dl=0;

   trace("torus mesh has "+RESI*RESO+" vertices.");
   trace "----------------------------------------";
   trace "   c : toggle displaylists";
   trace "   n : toggle normals";
   trace "   l : toggle lighting";
   trace "   v : toggle vsync";
   trace "   r : change rendermode";
   trace "space: stop rotation";
   trace "esc  : exit";
   trace "\n\n";

   FPS.tickInterval=1000/60.0;

   Viewport.openWindow(512, 384);
   vsync = ! Viewport.swapInterval(1);
   Viewport.caption="torus | [escape] to exit | r: rendermode | l:lights | n:normals | c:displaylist";

   SDL.eventLoop(); // start application event loop
}

