
use tksdl;
use tkopengl;

int numframesrendered=0;
float g_exp = 0;
int mode = 5;

function softclip(float x) {
   // == a version of smoothstep that uses a division (and inputs in the range of -1..1 instead of 0..1)
   return x < -1 ? -1 : x > 1 ? 1 : 1.5*(1 - x*x/3)*x;
}

function sinsw(float x) {
   float bend = 0.8;

   float xexp = 0.05f + (1.0f - bend) * 0.9f;
   x = x*0.5 + 0.5;  // -1..1 => 0..1

   x = x + 0.5;
   if(x >= 1.0)
      x -= 1.0;

   float ph = frac(x);
   ph = (ph - 0.5f) * 2.0f;
   ph = mathPowerf(ph, xexp);
   ph = ph * 0.5f + 0.5f;

   return sin(ph * 2PI);
}

function sinbend(float x) {
   float xexp = 3.8;

   x = x*0.5 + 0.5;  // -1..1 => 0..1
   float ph = mathPowerf(x, xexp);

   return sin(ph * 2PI);
}

function onDraw() {

   float dt=FPS.precision;
   glClearColor(0,0,0.2,1);
   // glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
   glClear(GL_COLOR_BUFFER_BIT);
   glDisable(GL_DEPTH_TEST);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   zglInitOrtho(1, 1);

   if(1)
   {
      glColor3f(0.15,0.15,0.35);
      glBegin(GL_LINES);
      glVertex2f(-1.0f, 0.0f);
      glVertex2f( 1.0f, 0.0f);
      glVertex2f( 0.0f, -1.0f);
      glVertex2f( 0.0f,  1.0f);
      glEnd();

      float lx = -1.0;
      float ly = 0.0;
      float cx = -1;
      float cy;
      float xStep = 2.0f / (Viewport.width-1);
      glColor3f(0.5,0.5,0.5);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      glEnable(GL_BLEND);
      glBegin(GL_LINES);
      boolean bFirst = true;
      float t;
      float fExp;

      loop(Viewport.width)
      {
         t = cx;
         switch(mode)
         {
            case 0:
               cy = softclip(t);
               break;

            case 1:
               t = t*0.5 + 0.5;
               cy = mathSmoothStepf(-1, 1, t);
               break;

            case 2:
               t = t*0.5 + 0.5;
               cy = abs(frac(t + 0.5) - 0.5) * 4 - 1;
               break;

            case 3:
               float norm = 1.0 / (sin(g_exp*2PI)/mathPowerf(2, g_exp));
               t = t*0.5 + 0.5;
               cy = norm*t*sin(g_exp*t*2PI)/mathPowerf(t+1, g_exp);
               if(cy > 1.0)
                  cy = 1.0;
               else if(cy < -1.0)
                  cy = -1.0;
               break;

            case 4:
               cy = sinsw(cx);
               break;

            case 5:
               cy = sinbend(cx);
               break;
         }

         if(bFirst)
         {
            glVertex2f(cx, cy);
            bFirst = false;
         }
         else
            glVertex2f(lx, ly);
         glVertex2f(cx, cy);

         if((lx < 0.0) && (cx >= 0.0))
         {
            glEnd();
            glColor3f(0.9,0.9,0.9);
            glBegin(GL_LINES);
         }
         lx = cx;
         ly = cy;
         cx += xStep;
      }

      glEnd();
      glDisable(GL_BLEND);
   }

}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   // print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
   if(_cbs&1)
   {
      g_exp = ((2.0*_y / Viewport.height) - 1.0) * 7.0;
      trace "g_exp="+g_exp;
   }
}

function onKeyboard(Key _k) {
   // trace "xxx onKeyboard: k.code="+_k.code+" mod="+_k.mod+" unicode="+_k.unicode+" "+tcchar(_k.unicode);
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_SPACE:
         mode = (mode + 1) % 4;
         trace "mode="+mode;
         break;
   }
}

int tim_count = 0;
function onTimer() {
   // trace "xxx onTimer";
   // if(++tim_count > 100)
   //    SDL.exitEventLoop();
}

function main() {
   use callbacks;

   FPS.tickInterval=1000.0/60;
   //FPS.limit=30;
   FPS.limit=60;

   SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   SDL.timerInterval = 20;

   SDL.dpiAwareness = true;  // no OS scaling

   Viewport.multisampleSamples = 4;
   Viewport.multisampleBuffers = 1;
   // Viewport.stencilBits = 8;
   Viewport.openWindow(800, 800);
   Viewport.swapInterval(1);

   SDL.eventLoop();
}


