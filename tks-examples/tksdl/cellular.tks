
// adapted from <http://iquilezles.org/www/articles/cellularffx/cellularffx.htm>
//
//  quote: "The idea is very imaginative, but also very simple: use the zbuffer of the graphics card to track the closest distance from any pixel to any of the features. Each feature expands a distance field around it."


use tksdl;
use tkopengl;

int numframesrendered=0;
float time;
boolean b_zbuf = true;

function renderCellularEffect(float time)
{
   if(b_zbuf)
   {
      glEnable(GL_DEPTH_TEST);
   }
   else
   {
      glDisable(GL_DEPTH_TEST);
   }

   glShadeModel(GL_SMOOTH);
   glDepthFunc(GL_LEQUAL);
   //glShadeModel(GL_FLAT);

    // render the cells
    int numCells = 200;
    srand(0x12345678);
    int j;
    float gammac = 0.15;
    float gammao = 0.817;
    compile for( j=0; j < numCells; j++ )
    {
        // move the cell on the screen
        float x = cos( rand(PI) + rand(time) );
        float y = cos( rand(PI) + rand(time) );

        // render cone (can be optimized of course)
        glBegin( GL_TRIANGLE_FAN );
        float r = rand(0.2);
        float g = rand(0.2);
        float b = rand(0.4);

        glColor4f(gammac - r * rand(0.55), 
                  gammac - g * rand(0.55), 
                  gammac - b * rand(0.55),
                  1.0f
                  );
        glVertex3f( x, y, 1.0f );

        glColor4f(gammao - rand(r), 
                  gammao - rand(g), 
                  gammao - rand(b), 
                  1.0f
                  );
        int i;
        float rx = 1.5 * (0.45 + 0.15 * cos(rand(2PI*0.01*time)));
        float ry = 1.5 * (0.45 + 0.15 * cos(rand(2PI*0.01*time)));
        //float rx = 0.25;
        //float ry = 0.25;
        for( i=0; i < 32; i++ )
        {
           float an = (2PI/31.0f) * i;
           glVertex3f( x + rx*cos(an), y + ry*sin(an), -1.0f );
        }
        glEnd();
    }
}

function onDraw() {
   float dt=FPS.precision;
   glClearColor(0,0,0.2,1);
   glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;
   zglInitOrtho(-1,1);

   renderCellularEffect(time);

   time += 0.001 * dt;

}

function ToggleZBuf() {
   b_zbuf = !b_zbuf;
   trace "[...] b_zbuf is now "+ b_zbuf;
}

function onKeyboard(Key _k) {
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;

      case VKEY_SPACE:
         ToggleZBuf();
         break;
   }
}

function main() {
   Viewport.multisampleSamples = 2;
   Viewport.multisampleBuffers = 1;
   Viewport.openWindow(640, 480);
   use callbacks;
   Viewport.swapInterval(1);
   FPS.tickInterval=1000.0/60;
   trace "xxx entering eventloop";
   SDL.eventLoop();
}


