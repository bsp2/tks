
use tksdl;
use tkopengl;

float frot=0;
int numframesrendered=0;
int num_verts;

function drawEllipse_triangles() {
   int NUM_VERTS = 10;
   float a = 0;
   float w = 2PI / (NUM_VERTS-1);
   float cx = 0;
   float cy = 0;
   float r = 0.5;
   float px;
   float py;
   glBegin(GL_TRIANGLES);
   loop(NUM_VERTS)
   {
      px = sin(a) * r;
      py = cos(a) * r;

      glVertex2f(cx, cy);
      glVertex2f(px, py);

      a += w;

      px = sin(a) * r;
      py = cos(a) * r;
      glVertex2f(px, py);

      num_verts += 3;
   }
   glEnd();
}

function drawEllipse_triangle_strip() {
   int NUM_VERTS = 10;
   float a = 0;
   float w = 2PI / (NUM_VERTS-1);
   float cx = 0;
   float cy = 0;
   float r = 0.5;
   float px;
   float py;
   glBegin(GL_TRIANGLE_STRIP);
   loop(NUM_VERTS)
   {
      glVertex2f(cx, cy);
      px = sin(a) * r;
      py = cos(a) * r;
      glVertex2f(px, py);

      num_verts += 2;
      a += w;
   }
   glEnd();
}

function drawTwoEllipses_triangle_strip() {
   int NUM_VERTS = 10;
   float a = 0;
   float w = 2PI / (NUM_VERTS-1);
   float cx = -0.5;
   float cy = -0.5;
   float r = 0.25;
   float px;
   float py;
   int i;
    // glPolygonMode(GL_FRONT, GL_LINE);
    // glPolygonMode(GL_BACK, GL_LINE);
   glBegin(GL_TRIANGLE_STRIP);
   loop(NUM_VERTS)
   {
      glVertex2f(cx, cy);
      px = sin(a) * r + cx;
      py = cos(a) * r + cy;
      glVertex2f(px, py);
      num_verts += 2;
      a += w;
      i++;
   }

   cx = 0.5;
   cy = 0.5;
   a = 0;

   glVertex2f(px, py);
   glVertex2f(cx, cy);
   num_verts += 2;

   loop(NUM_VERTS)
   {
      glVertex2f(cx, cy);
      px = sin(a) * r + cx;
      py = cos(a) * r + cy;
      glVertex2f(px, py);
      a += w;
      num_verts += 2;
   }

   glEnd();
}

function drawTwoEllipses_triangle_strip_debug() {
   int NUM_VERTS = 10;
   float a = 0;
   float w = 2PI / (NUM_VERTS-1);
   float cx = -0.5;
   float cy = -0.5;
   float r = 0.25;
   float px;
   float py;
   int i;
    // glPolygonMode(GL_FRONT, GL_LINE);
    // glPolygonMode(GL_BACK, GL_LINE);
   glBegin(GL_TRIANGLE_STRIP);
   i = 0;
   int num = NUM_VERTS/2 - 1;

   // First vertex
   px = sin(a) * r + cx;
   py = cos(a) * r + cy;
   glVertex2f(px, py);
   a += w;
   num_verts++;

   // 8 vertices
   loop(num)
   {
      px = sin(a) * r + cx;
      py = cos(a) * r + cy;
      glVertex2f(px, py);

      px = sin(-a) * r + cx;
      py = cos(-a) * r + cy;
      glVertex2f(px, py);

      num_verts += 2;
      a += w;
      i++;
   }

   // Last vertex
   px = sin(a) * r + cx;
   py = cos(a) * r + cy;
   glVertex2f(px, py);
   num_verts++;

   cx = 0.5;
   cy = 0.5;
   a = 0;

   // Degenerate "connector" triangle
   a = 0;
   px = sin(a) * r + cx;
   py = cos(a) * r + cy;
   glVertex2f(px, py);
   glVertex2f(px, py);
   a += w;
   num_verts += 2;

   loop(num)
   {
      px = sin(a) * r + cx;
      py = cos(a) * r + cy;
      glVertex2f(px, py);

      px = sin(-a) * r + cx;
      py = cos(-a) * r + cy;
      glVertex2f(px, py);

      num_verts += 2;
      a += w;
      i++;
   }

   px = sin(a) * r + cx;
   py = cos(a) * r + cy;
   glVertex2f(px, py);
   num_verts++;

   glEnd();
}

function onDraw() {

   float dt=FPS.precision;
   glClearColor(0,0,0.2,1);
   // glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
   glClear(GL_COLOR_BUFFER_BIT);
   glDisable(GL_DEPTH_TEST);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   zglInitOrtho(1, 1);
   // glRotatef(frot, 0,0,1);
   glColor4f(0.7,0.7,0.7,0.7);

   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_BLEND);
   glDisable(GL_CULL_FACE);
   
   num_verts = 0;
   // drawEllipse_triangles();  // 30 vertices
   // drawEllipse_triangle_strip();  // 20 vertices
   // drawTwoEllipses_triangle_strip();  // 2*20+2 = 42 vertices
   drawTwoEllipses_triangle_strip_debug();
   if(1 == numframesrendered)
      trace "num_verts="+num_verts;

   frot+=dt;
   wrap frot 0 360;
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   // print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
}

function onKeyboard(Key _k) {
   // trace "xxx onKeyboard: k.code="+_k.code+" mod="+_k.mod+" unicode="+_k.unicode+" "+tcchar(_k.unicode);
   switch(_k.pressed)
   {
      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;
   }
}

int tim_count = 0;
function onTimer() {
   // trace "xxx onTimer";
   // if(++tim_count > 100)
   //    SDL.exitEventLoop();
}

function main() {
   use callbacks;

   FPS.tickInterval=1000.0/60;
   //FPS.limit=30;
   FPS.limit=60;

   SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   SDL.timerInterval = 20;

   SDL.dpiAwareness = true;  // no OS scaling
   // SDL.dpiAwareness = false;  // assume 96dpi and let OS scale window to actual DPI

   SDL.touchInput = true;  // enable WM_POINTER* messages

   Viewport.multisampleSamples = 4;
   Viewport.multisampleBuffers = 1;
   // Viewport.stencilBits = 8;
   Viewport.openWindow(640, 480);
   //Viewport.openScreen(640, 480, 32);
   //Viewport.swapInterval(1);

   SDL.enableUNICODE(true);

   trace "xxx Viewport.dpi="+Viewport.dpi;
   trace "xxx entering eventloop";

   SDL.eventLoop();
}
