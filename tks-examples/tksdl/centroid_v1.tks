
use tksdl;
use tkopengl;
use tkmath;

float vp_zoom = 1;

float frot = 0;
boolean b_rot = true;
int numframesrendered = 0;
int read_x = -1;
int read_y;
boolean b_queued_screenshot;

float ang_ax;
float ang_ay;
float ang_bx;
float ang_by;
float ang_cx;
float ang_cy;


function SaveScreenShotPNG(String _pathName) : boolean {
   local Texture tex;
   boolean ret = false;
   if(tex.alloc(Viewport.width, Viewport.height, 4))
   {
      glReadBuffer(GL_BACK);
      int off = 0;
      int y = Viewport.height - 1;
      loop(Viewport.height)
      {
         zglReadColorPixelsX(tex, off, 0/*x*/, y, Viewport.width);
         y--;
         off += Viewport.width;
      }
      ret = tex.saveImage(_pathName);
   }
   return ret;
}

function onDraw() {
   // trace "[...] onDraw";

   float dt=FPS.precision;
   glClearColor(0,0,0.2,1);
   // glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
   glClear(GL_COLOR_BUFFER_BIT);
   glDisable(GL_DEPTH_TEST);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   zglInitOrtho(100, 100);
   // glRotatef(frot, 0,0,1);

   Vector2f vA; vA.init(-80, -10);
   Vector2f vB; vB.init( 60,  90);
   Vector2f vC; vC.init( 90, -70);

   float modr = 30.0;

   vA.x += sin(ang_ax) * modr;
   vA.y += sin(ang_ay) * modr;

   vB.x += sin(ang_bx) * modr;
   vB.y += sin(ang_by) * modr;

   vC.x += sin(ang_cx) * modr;
   vC.y += sin(ang_cy) * modr;

   if(1)
   {
      glColor3f(0.6,0.6,0.6);
      glBegin(GL_TRIANGLES);
      glVertex2f(vA.x, vA.y);
      glVertex2f(vB.x, vB.y);
      glVertex2f(vC.x, vC.y);
      glEnd();
   }

   if(1)
   {
      Vector2f vG;
      vG.x = (vA.x + vB.x + vC.x) / 3.0;
      vG.y = (vA.y + vB.y + vC.y) / 3.0;
      glColor3f(0.1,0.9,0.1);
      glLineWidth(1.0);
      glBegin(GL_LINES);
      glVertex2f(vG.x, vG.y);
      glVertex2f(vA.x, vA.y);

      glVertex2f(vG.x, vG.y);
      glVertex2f(vB.x, vB.y);

      glVertex2f(vG.x, vG.y);
      glVertex2f(vC.x, vC.y);
      glEnd();

      if(1)
      {
         Vector2f vD;
         float border = 10.0;
         vD = vA - vG;
         Vector2f vAScl = vG + vD.unitScale(vD.abs + border);
         vD = vB - vG;
         Vector2f vBScl = vG + vD.unitScale(vD.abs + border);
         vD = vC - vG;
         Vector2f vCScl = vG + vD.unitScale(vD.abs + border);
         trace "xxx vAScl="+vAScl;
         trace "xxx vBScl="+vBScl;
         trace "xxx vCScl="+vCScl;
         glColor4f(0.8,0.8,0.8, 0.5);
         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
         glEnable(GL_BLEND);
         glLineWidth(1.0);
         glBegin(GL_TRIANGLES);
         glVertex2f(vAScl.x, vAScl.y);
         glVertex2f(vBScl.x, vBScl.y);
         glVertex2f(vCScl.x, vCScl.y);
         glEnd();
         glDisable(GL_BLEND);
      }
   }

   if(-1 != read_x)
   {
      glReadBuffer(GL_BACK);
      // glReadBuffer(GL_COLOR_ATTACHMENT0);
      glFinish();
      Integer c32 = zglReadColorPixel(read_x, read_y);
      trace "ReadPixel ("+read_x+";"+read_y+") = ABGR(#"+c32.printf("%08x")+")";
      read_x = -1;
   }

   if(b_queued_screenshot)
   {
      b_queued_screenshot = false;
      SaveScreenShotPNG("screenshots/fpslimit.png");
   }

   if(b_rot)
   {
      frot += dt;
      wrap frot 0 360;

      ang_ax += dt * 0.012344;
      ang_ay += dt * 0.034324;

      ang_bx += dt * 0.023875;
      ang_by += dt * 0.020123;

      ang_cx += dt * 0.034321;
      ang_cy += dt * 0.012954;

      wrap ang_ax 0 2PI;
      wrap ang_ay 0 2PI;
      wrap ang_bx 0 2PI;
      wrap ang_by 0 2PI;
      wrap ang_cx 0 2PI;
      wrap ang_cy 0 2PI;
   }
}

function onMouse(int _x, int _y, int _cbs, int _nbs) {
   print "x="+_x+" y="+_y+" cbs="+_cbs+" nbs="+_nbs;
   read_x = _x;
   read_y = _y;

   // if(_cbs & MOUSE_LBUTTON)
   //    Mouse.grab();
   // else if(_nbs & MOUSE_LBUTTON)
   //    Mouse.ungrab();
}

function onKeyboard(Key _k) {
   trace "[...] fpslimit:onKeyboard: k.code="+_k.code+" ("+TKS.constantToString(_k.code, "VKEY_")+") mod="+_k.mod+" pressed="+_k.pressed+" released="+_k.released+" unicode="+_k.unicode+" "+tcchar(_k.unicode);
   switch(_k.pressed)
   {
      case 'f':
         Viewport.toggleFullScreen();
         break;

      case 'p':
         b_queued_screenshot = true;
         trace "[...] queue screenshot";
         break;

      case VKEY_SPACE:
         b_rot = !b_rot;
         trace "[...] b_rot="+b_rot;
         break;

      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;
   }
}

int tim_count = 0;
function onTimer() {
   // trace "[...] onTimer";
   // if(++tim_count > 100)
   //    SDL.exitEventLoop();
}

function main() {
   use callbacks;

   FPS.tickInterval = 1000.0f / 60;
   FPS.limit = 60;

   SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   SDL.timerInterval = 20;

   SDL.dpiAwareness = true;  // no OS scaling
   // SDL.dpiAwareness = false;  // assume 96dpi and let OS scale window to actual DPI

   SDL.touchInput = true;  // enable WM_POINTER* messages

   // Viewport.multisampleSamples = 4;
   // Viewport.multisampleBuffers = 1;
   // Viewport.stencilBits = 8;
   // Viewport.setScreenResolution(1920, 1200, 32);
   Viewport.openWindow(640*vp_zoom, 480*vp_zoom);
   // Viewport.openScreen(640, 480, 32);
   // Viewport.swapInterval(1);

   // trace "xxx #texunits: "+zglGetInteger(GL_MAX_TEXTURE_UNITS);
   trace "[dbg] GL extensions: "+glGetString(GL_EXTENSIONS);
   trace "[dbg] #texunits: "+zglGetInteger(GL_MAX_TEXTURE_IMAGE_UNITS);
   trace "[dbg] max_texture_size: "+zglGetInteger(GL_MAX_TEXTURE_SIZE);
   trace "[dbg] max_samples: "+zglGetInteger(GL_MAX_SAMPLES);  // (note) 4 on macOS 14 (m2pro)

   SDL.enableUNICODE(true);
   SDL.enableKeyRepeat(0,0);

   trace "[dbg] Viewport.dpi="+Viewport.dpi;
   trace "[...] entering eventloop";

   SDL.eventLoop();
}
