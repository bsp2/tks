use tksdl;
use tkopengl;
use tkminnie;
use tkmath;

float vp_zoom = 1;

float frot = 0;
boolean b_rot = true;
int numframesrendered = 0;

putenv("TKSDL_GLCORE=1");   // select 4.1 core profile on macOS

int vbo_vertex;
// int vbo_index;

String vs_src =
   "uniform mat4 u_transform; \n"
   " \n"
   "ATTRIBUTE vec2 a_vertex; \n"
   // "ATTRIBUTE float a_index; \n"
   " \n"
   "void main(void) { \n"
   // "  float index = float(a_index); \n"
   "  float index = float(gl_VertexID); \n"
   "  vec2 v; \n"
   "  float w = 64.0; \n"
   "  float h = 64.0; \n"
   " \n"
   "  if(index > 4.9) { \n"
   "    v = vec2(a_vertex.x, a_vertex.y + h); \n"
   "  } \n"
   "  else if(index > 3.9) { \n"
   "    v = vec2(a_vertex.x + w, a_vertex.y + h); \n"
   "  } \n"
   "  else if(index > 2.9) { \n"
   "    v = a_vertex; \n"
   "  } \n"
   "  else if(index > 1.9) { \n"
   "    v = vec2(a_vertex.x + w, a_vertex.y + h); \n"
   "  } \n"
   "  else if(index > 0.9) { \n"
   "    v = vec2(a_vertex.x + w, a_vertex.y); \n"
   "  } \n"
   "  else { \n"
   "    v = a_vertex; \n"
   "  } \n"
   "  gl_Position = u_transform * vec4(v,0,1); \n"
   // "  gl_Position = u_transform * vec4(a_vertex,0,1); \n"
   "} \n"
   ;

String fs_src =
   "uniform vec4 u_color_fill; \n"
   " \n"
   "void main(void) { \n"
   "  FRAGCOLOR = u_color_fill; \n"
   "  FRAGCOLOR = vec4(1,1,1,1); \n"
   "} \n"
   ;

int shader_idx;


function onDraw() {
   // trace "[...] onDraw";

   sdvg_BeginFrame();

   float dt=FPS.precision;
   sdvg_ClearARGB(#ff000033);
   // glDisable(GL_DEPTH_TEST);

   if( !(++numframesrendered&127) )
      trace "FPS.real="+FPS.real;

   sdvg_SetViewport(0, 0, Viewport.width, Viewport.height);
   Matrix4f mProj; mProj.initOrtho(0, Viewport.width,
                                   Viewport.height, 0,
                                   -10, 10
                                   );
   sdvg_SetTransform(mProj);
   sdvg_SetScissor(0, 0, Viewport.width, Viewport.height);

   sdvg_SetFillColorARGB(#ffffffff);

   sdvg_BindShader(shader_idx);
   sdvg_UniformMatrix4("u_transform", mProj);
   sdvg_Uniform4f("u_color_fill", 1,1,1,1);
   int aVertex = sdvg_GetAttribLocation("a_vertex");
   // int aIndex  = sdvg_GetAttribLocation("a_index");
   sdvg_BindVBO(vbo_vertex);
   zglVertexAttribOffset(aVertex, 2/*size*/, GL_FLOAT,          GL_FALSE/*normalize*/, 8/*stride*/, 0);
   // sdvg_BindVBO(vbo_index);
   // zglVertexAttribOffset(aIndex,  1/*size*/, GL_UNSIGNED_SHORT, GL_FALSE/*normalize*/, 2/*stride*/, 0);
   sdvg_BindVBO(0);
   glEnableVertexAttribArray(aVertex);
   // glEnableVertexAttribArray(aIndex);
   glVertexAttribDivisor(aVertex, 1);
   // glVertexAttribDivisor(aIndex, 0);
   glDrawArraysInstanced(GL_TRIANGLES, 0, 2*3, 3);
   glDisableVertexAttribArray(aVertex);
   // glDisableVertexAttribArray(aIndex);

   if(b_rot)
   {
      frot+=dt;
      wrap frot 0 360;
   }

   sdvg_EndFrame();

   // SDL.exitEventLoop();
}


function onKeyboard(Key _k) {
   // trace "[...] onKeyboard: k.code="+_k.code+" ("+TKS.constantToString(_k.code, "VKEY_")+") mod="+_k.mod+" pressed="+_k.pressed+" released="+_k.released+" unicode="+_k.unicode+" "+tcchar(_k.unicode);
   switch(_k.pressed)
   {
      case 'f':
         Viewport.toggleFullScreen();
         break;

      case VKEY_SPACE:
         b_rot = !b_rot;
         trace "[...] b_rot="+b_rot;
         break;

      case VKEY_ESCAPE:
         SDL.exitEventLoop();
         break;
   }
}

int tim_count = 0;
function onTimer() {
   // trace "[...] onTimer";
   // if(++tim_count > 100)
   //    SDL.exitEventLoop();
}

function onOpen() {
   trace "[...] onOpen";
   zglEnableGLCore(true);

   sdvg_OnOpen();

   vbo_vertex = sdvg_CreateVBO(3 * 2*4);
   float x = 20;
   float y = 20;
   float w = 64;
   float h = 64;
   sdvg_MapVBO(vbo_vertex);
   if(sdvg_BeginVBO(3, 2*4))
   {
      // // 1
      // sdvg_Vertex2f(x,   y);
      // sdvg_Vertex2f(x+w, y);
      // sdvg_Vertex2f(x+w, y+h);

      // // 2
      // sdvg_Vertex2f(x,   y);
      // sdvg_Vertex2f(x+w, y+h);
      // sdvg_Vertex2f(x,   y+h);

      sdvg_Vertex2f(x,       y);
      sdvg_Vertex2f(x + 100, y);
      sdvg_Vertex2f(x + 200, y);

      // loop(2*3)
      //    sdvg_Vertex2f(x, y);

      sdvg_End();
   }
   trace "[dbg] onOpen: sdvg_GetMappedVBOOffset()="+sdvg_GetMappedVBOOffset();
   sdvg_UnmapVBO();

   // vbo_index = sdvg_CreateVBO(2*3 * 2*4);
   // int idx = 0;
   // sdvg_MapVBO(vbo_index);
   // if(sdvg_BeginVBO(2*3, 2))
   // {
   //    loop(2*3)
   //       sdvg_Attribi16(idx++);

   //    sdvg_End();
   // }
   // trace "[dbg] onOpen: index sdvg_GetMappedVBOOffset()="+sdvg_GetMappedVBOOffset();
   // sdvg_UnmapVBO();

   shader_idx = sdvg_CreateShader(vs_src, fs_src);
   trace "[dbg] onOpen: shader_id="+shader_idx;
}

function main() {
   use callbacks;

   FPS.tickInterval = 1000.0f / 60;
   FPS.limit = 60;

   sdvg_SetScratchBufferSize(4096*1024);
   sdvg_SetGLSLVersion(1/*b_glcore*//*bV3*/, false/*bGLES*/, null/*sVersionStringOrNull*/);
   sdvg_Init(1/*b_glcore*/);
   

   SDL.eventPolling = false; // tksdl default is "true" (do not block while waiting for an SDL event)
   SDL.timerInterval = 20;

   SDL.dpiAwareness = true;  // no OS scaling
   // SDL.dpiAwareness = false;  // assume 96dpi and let OS scale window to actual DPI

   SDL.touchInput = true;  // enable WM_POINTER* messages

   // Viewport.multisampleSamples = 4;
   // Viewport.multisampleBuffers = 1;
   // Viewport.stencilBits = 8;
   // Viewport.setScreenResolution(1920, 1200, 32);
   Viewport.openWindow(640*vp_zoom, 480*vp_zoom);
   // Viewport.openScreen(640, 480, 32);
   // Viewport.swapInterval(1);

   // // trace "xxx #texunits: "+zglGetInteger(GL_MAX_TEXTURE_UNITS);
   trace "[dbg] GL extensions: "+glGetString(GL_EXTENSIONS);
   trace "[dbg] #texunits: "+zglGetInteger(GL_MAX_TEXTURE_IMAGE_UNITS);
   trace "[dbg] max_texture_size: "+zglGetInteger(GL_MAX_TEXTURE_SIZE);
   trace "[dbg] max_samples: "+zglGetInteger(GL_MAX_SAMPLES);  // (note) 4 on macOS 14 (m2pro)
   trace "[dbg] version = "+zglGetInteger(GL_MAJOR_VERSION)+"."+zglGetInteger(GL_MINOR_VERSION);  // GL3.x+

   SDL.enableUNICODE(true);
   SDL.enableKeyRepeat(0,0);

   trace "[dbg] Viewport.dpi="+Viewport.dpi;
   trace "[...] entering eventloop";

   SDL.eventLoop();

   sdvg_Exit();
}
