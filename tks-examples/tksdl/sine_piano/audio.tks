// demonstrates how to output a pitch-modulated sinus signal using the audio device
// the current note is controlled by a shared memory region
use tksdl;

/*
song
  track         ; jeder track spielt hat eine pattern playlist
    generator   ; voice verwaltung/mixer
       voice#1   ; 
       voice#2
       voice#3
       voice#4
*/


class ST_Voice {
   explain "interface for a Syntracker voice generator class.

 The interface methods are prefixed with \"st\" to avoid a name clash between an internal voice method
 and a future extension of this interface.
";
   
   // Parameter types: (also see stGetParamType())
   define int ST_NONE   = 0; // unused parameter
   define int ST_BOOL   = 1; // either 0 or 1
   define int ST_SNORM  = 2; // -1..1
   define int ST_UNORM  = 3; // 0..1
   define int ST_SBYTE  = 4; // -127..127
   define int ST_UBYTE  = 5; // 0..255
   define int ST_SWORD  = 6; // -32767..32767
   define int ST_UWORD  = 7; // 0..65535
   define int ST_NOTE   = 8; // midi note (c-0..g-9 (0..127))
   define int ST_FREQ   = 9; // frequency (0..n Hz)

   // Additional Array types: (also see stGetArrayType())
   define int ST_STEREO = 10; // left/right stereo sample pairs (-1..1 range)

   // Set amplification / volume (0..1)
   public method stSetAmp (float _amp) {}

   // Set midi note (0..127) (does not trigger new note)
   public method stSetFreq (float _note) { }

   // Set panning (-1..1)
   public method stSetPan (float _pan) { }

   // Query number of parameters
   public method stSetNumParams() : int { }

   // Query voice parameter
   public method stGetParam (int _paramNr) : float { }

   // Query parameter type (gui hint) (one of ST_PT_NONE, ST_PT_BOOL ... ST_PT_FREQ)
   public method stGetParamType (int _paramNr) : float { }

   // Query parameter name (gui hint)
   public method stGetParamName (int _paramNr) : String { }
   
   // Set generic voice parameter
   public method stSetParam (int _paramNr, float _value) { }

   // Query number of assignable arrays (0..n)
   public method stGetNumArrays () : int { }

   // Query the array type (gui hint) (one of ST_xxx)
   public method stGetArrayType () : int { }

   // Query the array name (gui hint)
   public method stGetArrayName () : String { }

   // Assign an array; the voice may convert the array to an internal format
   public method stSetArray (int _arrayNr, FloatArray _array) { } 

   // Trigger note
   public method stNoteOn (float _note, float _vel) { }

   // Release note
   public method stNoteOff (float _note, float _vel) { }

   // Cancel all playing notes
   public method stAllNotesOff () { } 

   // Load voice parameters (e.g. instrument change)
   public method stLoad (Buffer _source) { } 

   // Store voice parameters
   public method stSave (Buffer _dest) { } 

   // Initialize voice (called once at startup)
   public method stInit () { } 

   // Reset to default parameters
   public method stReset () { } 

   // Clean up allocated resources (called once during shutdown)
   public method stExit () { } 

   // Render _dst.numElements/2 stereo samples
   public method stRender (FloatArray _dst) { } 

   // Update state, call freq. depends on ppq/bpm
   public method stTick () { } 
}


float curr_pitch;
float pitch;
float sine_phase=0;
// float pitch_phase=0;

float note = 81;
float amp = 1;
float curr_amp = 1;

// float base_note=69.0;
float total_sec=0;

int framenr=0;

#define SHM_KEY "sine_piano__audioslave"
enum {
   SHM_UNREAD = 0
   SHM_NOTEON = 1
   SHM_NOTE = 2
};

SharedBuffer sh;
if(sh.allocSharedMemoryByKey(SHM_KEY, 256))
{
   print "shared memory created.";
   sh.pokeI8(SHM_UNREAD, false);
   sh.pokeI8(SHM_NOTEON, 0); // 1=noteon, 0=noteoff
   sh.pokeF32(SHM_NOTE, 0); // new midi note or 0
}
else
{
   die "failed to create shared memory.";
}


enum {
   ADSR_ATTACK  = 0
   ADSR_DECAY   = 1
   ADSR_SUSTAIN = 2
   ADSR_RELEASE = 3
};
#define ADSR_ATTACK_SPD 1.0
#define ADSR_DECAY_SPD 0.01
#define ADSR_SUSTAIN_LVL 0.15
#define ADSR_RELEASE_SPD 0.001
int adsr_step = ADSR_RELEASE;

FloatArray lut_interpol_amp;
lut_interpol_amp.alloc(256); 
lut_interpol_amp.numElements = lut_interpol_amp.maxElements;
int off_interpol_amp;

function setAmp(float _amp) {
   amp = _amp;
   lut_interpol_amp.fill( ((amp-curr_amp) / 256.0) );
   off_interpol_amp = 0;
}

function onAudioFrame() {
   if(sh.peekI8(SHM_UNREAD))
   {
      if(sh.peekI8(SHM_NOTEON))
      {
         note = sh.peekF32(SHM_NOTE);
         setAmp(0);
         adsr_step = ADSR_ATTACK;
         /// causes clicks sine_phase = 0;

         float freq=MIDINoteToFrequency(note);//base_note+12*(0.5+0.5*sin(pitch_phase)));
         total_sec+=(60.0/125.0)/96.0;
         if( ! ((++framenr)&1023) )
         {
            print "time= "+tcint(total_sec/60.0)+"m:"+(tcint(total_sec)%60)+"s.";
            print "freq="+freq;
         }
         pitch= (freq/(44100.0*0.5));
//          pitch_phase+=0.01;
//          wrap pitch_phase 0 2PI;
      }
      else
      {
         if(note==sh.peekF32(SHM_NOTE))
         {
            setAmp(ADSR_SUSTAIN_LVL);
            adsr_step = ADSR_RELEASE;
         }
      }
      sh.pokeI8(SHM_UNREAD, false);
   }
   else
   {
      switch(adsr_step)
      {
         case ADSR_ATTACK:
            amp += ADSR_ATTACK_SPD;
            if(amp>=1)
            {
               amp = 1;
               adsr_step = ADSR_DECAY;
            }
            setAmp(amp);
            break;
         case ADSR_DECAY:
            amp -= ADSR_DECAY_SPD;
            if(amp<=ADSR_SUSTAIN_LVL)
            {
               amp = ADSR_SUSTAIN_LVL;
               adsr_step = ADSR_SUSTAIN;
            }
            setAmp(amp);
            break;
         case ADSR_SUSTAIN:
            break;
         case ADSR_RELEASE:
            amp -= ADSR_RELEASE_SPD;
            if(amp<0)
            {
               amp = 0;
            }
            setAmp(amp);
            break;
      }
   }

}

function onAudioBeginBlock(FloatArray _fa) {
   AudioDevice.processTimeFrames();
   AudioDevice.finishBlock();
}


function onAudioRender(FloatArray _fa) {
   int i=0;
   float cval;

   compile loop(_fa.numElements>>1) {
      cval=sin(sine_phase) * curr_amp;
      _fa[i++]=cval;
      _fa[i++]=cval;

      curr_amp += lut_interpol_amp[off_interpol_amp];
      lut_interpol_amp[off_interpol_amp] = 0.0;
      off_interpol_amp = (off_interpol_amp+1) & 255;

      sine_phase+=curr_pitch;
      ////curr_amp += (amp-curr_amp)*0.01; // interpolate amplification 
      curr_pitch += (pitch-curr_pitch)*0.08; // interpol pitch
   }
   wrap sine_phase 0 2PI;
}

function main() {
   use callbacks;
   AudioDevice.openDSP(44100, 1024);
   AudioDevice.ppq=192;
   AudioDevice.bpm=125;
   AudioDevice.volume=0.9;
   AudioDevice.start();
   SDL.eventLoop();
   AudioDevice.stop();
}

