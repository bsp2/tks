/// ----
/// ---- file: heapsort.tks
/// ----
/// ---- This is the "great computer language shootout"s "heapsort" benchmark ported
/// ---- from the "c" language to tkscript by Bastian Spiegel <bs@tkscript.de>
/// ---- on 11-Apr-2005.
/// ---- Please notice that this source includes 3 different variants of the benchmark;
/// ---- the first one uses "Double" C++ number objects (without JIT), the second variant uses
/// ---- the builtin "float" datatype (32bit) (without JIT) and the third one uses the
/// ---- (mini-) JIT compiler to speed up the sorting loop (23,5 times faster than the 1st variant).
/// -----
/// ---- Also see <http://shootout.alioth.debian.org/benchmark.php?test=heapsort&lang=all&sort=fullcpu>
/// ---- [tgclso].
/// ----
/// ---- Results:
/// ---- (N=100,000)
///                 perl5.8.0: ~3,5s    (cygwin)
/// ----    java1.4.2_04<jit>: ~78ms
/// ----  java1.4.2_04<nojit>: ~562ms   (using the -Xint option)
/// ----
/// ----
/// ---- Program output:
/// ---- $ tks heapsort_oo.tks 100000
/// ---- [...] HeapSort::RunTest_Double: N=100000
/// ---- [...] HeapSort::RunTest_Double: t(ms)=2218
/// ---- [...] HeapSort::RunTest_Double: ary[N=100000]=0.99999285550983086
/// ---- [...] HeapSort::RunTest_float:  N=100000
/// ---- [...] HeapSort::RunTest_float:  t(ms)=1734
/// ---- [...] HeapSort::RunTest_float:  ary[N=100000]=0.999993
/// ---- [...] HeapSort::RunTest_float_JIT:      N=100000
/// ---- [...] HeapSort::RunTest_float_JIT:      t(ms)   =94
/// ---- [...] HeapSort::RunTest_float_JIT:      ary[N=100000]=0.999993

module Main;


class HeapSort {

   // ----
   // ---- default array size
   // ----
   define int DEFAULT_N= 100000;

   define int IM= 139968;
   define int IA=   3877;
   define int IC=  29573;

   // ----
   // ---- helper methods which are called by HeapSort_Double(), HeapSort_float()
   // ----
   private static Long last=42;
   private static method GenRandom_Double(Double _max) {
      last = (last * IA + IC) % IM;
      return (_max *  last) / IM;
   }
   private static method GenRandom_float(float _max) {
      last = (last * IA + IC) % IM;
      return (_max *  last) / IM;
   }

   // ----
   // ---- this variant uses the builtin (c++) Double number *object* datatype.
   // ----
   private static method HeapSort_Double(int n, Double ra[]) {
      int i, j;
      int ir = n;
      int l = (n >> 1) + 1;
      Double rra;
      
      while(true) {
         if (l > 1) {
            rra = ra[--l];
         } else {
            rra = ra[ir];
            ra[ir] = ra[1];
            if (--ir == 1) {
               ra[1] = rra;
               return;
            }
         }
         i = l;
         j = l << 1;
         while (j <= ir)  {
            if(j<ir)
               if(ra[j] < ra[j+1])
                  j++;
            if (rra < ra[j]) {
               ra[i] = ra[j];
               i=j;
               j += i;
            } else {
               j = ir + 1;
            }
         }
         ra[i] = rra;
      }
   }

   // ----
   // ---- this variant uses the builtin 32bit float datatype.
   // ---- It is slightly faster than using (c++) number objects
   // ---- (~30%)
   // ----
   private static method HeapSort_float(int n, float ra[]) {
      int i, j;
      int ir = n;
      int l = (n >> 1) + 1;
      float rra;
      
      while(true) {
         if (l > 1) {
            rra = ra[--l];
         } else {
            rra = ra[ir];
            ra[ir] = ra[1];
            if (--ir == 1) {
               ra[1] = rra;
               return;
            }
         }
         i = l;
         j = l << 1;
         while (j <= ir)  {
            if(j<ir)
               if(ra[j] < ra[j+1])
                  j++;
            if (rra < ra[j]) {
               ra[i] = ra[j];
               i=j;
               j += i;
            } else {
               j = ir + 1;
            }
         }
         ra[i] = rra;
      }
   }

   // ----
   // ---- this variant uses the builtin 32bit float datatype
   // ---- and compiles the function body to native code (x86,68k)
   // ---- uses the tkscript JIT compiler.
   // ---- Please notice that this variant emulates the "return"
   // ---- behaviour using the "b_cont" boolean flag variable.
   // ---- (this is because the JIT does not (yet) support the
   // ----  return statement (all return values are currently "variant"))
   // ----
   private static method HeapSort_float_JIT(int n, float ra[]) compile {
      int i, j;
      int ir = n;
      int l = (n >> 1) + 1;
      float rra;
      
      boolean b_cont=true;
      while(b_cont) {
         if (l > 1) {
            rra = ra[--l];
         } else {
            rra = ra[ir];
            ra[ir] = ra[1];
            if (--ir == 1) {
               ra[1] = rra;
               b_cont=false;
            }
         }
         if(b_cont)
         {
            i = l;
            j = l << 1;
            while (j <= ir)  {
               if(j<ir)
                  if(ra[j] < ra[j+1])
                     j++;
               if (rra < ra[j]) {
                  ra[i] = ra[j];
                  i=j;
                  j += i;
               } else {
                  j = ir + 1;
               }
            }
            ra[i] = rra;
         }
      }
   }

   // ---- 
   // ---- runs the benchmark in Double mode (using number objects, no JIT)
   // ---- 
   static module method RunTest_Double(int _N) {
      print "[...] HeapSort::RunTest_Double:\tN="+_N;
      
      /* create an array of N random doubles */
      Double ary[]; ary.alloc(_N+1);

      int t=milliSeconds();

      // ----
      // ---- since function/method overloading is not supported 
      // ---- in tkscript we need to assign to a variable first
      // ---- (tcobject(1.0) would give you a Float object)
      // ----
      Double dmax=1.0; 
      
      ary[0]=0; // elements start at index 1
      int i=1;
      loop(_N)
         ary[i++]=GenRandom_Double(dmax);
      
      HeapSort_Double(_N, ary);
      
      t=milliSeconds()-t;
      print "[...] HeapSort::RunTest_Double:\tt(ms)="+t;
      print "[...] HeapSort::RunTest_Double:\tary[N="+_N+"]="+ary[_N];
   }

   // ---- 
   // ---- runs the benchmark in float mode (using native 32bit floats, no JIT)
   // ---- 
   static module method RunTest_float(int _N) {
      print "[...] HeapSort::RunTest_float:\tN="+_N;
      
      /* create an array of N random doubles */
      float ary[]; ary.alloc(_N+1);

      ary.add(0); // elements start at index 1
      loop(_N)
         ary.add(GenRandom_float(1));
      
      int t=milliSeconds();

      HeapSort_float(_N, ary);
      
      t=milliSeconds()-t;
      print "[...] HeapSort::RunTest_float:\tt(ms)="+t;
      print "[...] HeapSort::RunTest_float:\tary[N="+_N+"]="+ary[_N];
   }

   // ----
   // ---- runs the benchmark in float mode just-in-time compiled to native code (using native 32bit floats)
   // ----
   static module method RunTest_float_JIT(int _N) {
      print "[...] HeapSort::RunTest_float_JIT:\tN="+_N;

      /* create an array of N random doubles */
      float ary[]; ary.alloc(_N+1);

      
      // ---- 
      // ---- please notice that the JIT variant does not
      // ---- use a GenRandom_float_JIT() function since
      // ---- script function calls are not supported by 
      // ---- the JIT compiler, yet.
      // ---- 

      int t=milliSeconds();

      compile {
          ary.add(0); // elements start at index 1
          int gen_random_last=42;
          loop(_N)
          {
             gen_random_last = (gen_random_last * IA + IC) % IM;
             ary.add( (1.0 * gen_random_last) / IM );
          }
      }

      HeapSort_float_JIT(_N, ary);

      t=milliSeconds()-t;
      print "[...] HeapSort::RunTest_float_JIT:\tt(ms)\t="+t;
      print "[...] HeapSort::RunTest_float_JIT:\tary[N="+_N+"]="+ary[_N];
   }
}

function main() {
   int N = Arguments.numElements? Arguments[0] : HeapSort.DEFAULT_N;

   HeapSort.RunTest_Double   (N);
   HeapSort.RunTest_float    (N);
   HeapSort.RunTest_float_JIT(N);
}
