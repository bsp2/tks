// ---- 
// ---- file: fasta.tks
// ---- 
// ---- Originally written in the "C" language for the 
// ---- "Great Computer Language Shootout" (tgclso)
// ---- <http://shootout.alioth.debian.org/>
// ---- by Paul Hsieh 
// ---- TkScript port by Bastian Spiegel <bs@tkscript.de>
// ---- 
// ---- From the current tgclso homepage: 
// ---- "Each program should
// ---- ""
// ---- "    * encode the expected cumulative probabilities for 2 alphabets"
// ---- "    * generate DNA sequences, by weighted random selection from the alphabets"
// ---- "      (using the pseudo-random number generator from the random benchmark)"
// ---- "    * generate DNA sequences, by copying from a given sequence"
// ---- "    * write 3 sequences line-by-line in FASTA format"
// ---- ""
// ---- 
// ---- Also see:
// ---- <http://en.wikipedia.org/wiki/Fasta_format>
// ---- <http://shootout.alioth.debian.org/benchmark.php?test=fasta&lang=all&sort=fullcpu>
// ---- 
// ---- Results:   
// ----           perl5.8.0: ~13s
// ----         tks0.9.0.60: ~4968ms
// ---- 
// ---- Results <intel q9900@2.83Ghz vista32, NUM=100000 (limited by IO???)
// ----   tks v0.9.10.72:
// ----      1170ms (JIT, --quiet)
// ----      1591ms (interpreted, --quiet)
// ----      1872ms (JIT)
// ----      2340ms (interpreted)
// ---- 
// ----   lua 0.5.1.4.23:
// ----     26332ms (interpreted)
// ---- 
// ----   python 2.5.1:
// ----      9438ms (interpreted)
// ---- 

class random { // linear congruential random generator 
   define int IM = 139968;
   define int IA = 3877;
   define int IC = 29573;
  
   static Long last = 42;
   static public method gen_random (Double max) {
      last = (last * IA + IC) % IM;
      return (max * last) / IM;
   }
}

class Aminoacids { char c; Double p; }

/* Weighted selection from alphabet */

function makeCumulative (Aminoacids genelist[]) {
    Double cp = 0.0;
    Aminoacids a;
    foreach a in genelist {
       cp += a.p;
       a.p = cp;
    }
}

Double double_one=1;
function selectRandom (Aminoacids genelist[]) {
   Double r = random.gen_random (double_one);
   Aminoacids a<=genelist[0];
   if (r < a.p) 
      return a.c;
   else compile { // this could be replaced by a LUT (0..100) if we would optimize for the given dataset
      int i, lo=0, hi=genelist.numElements-1; // but then we could also optimize using a generative if..else loop :)
      while (hi > (lo+1)) {
         i = (hi + lo)>>1;
         a<=genelist[i]; // if(r<genelist[i].p) is slower in "interpreted" mode (~5%) but faster in JIT (25%)
         if (r<a.p) hi = i; else lo = i;
      }
   }
   return genelist[hi].c;
}

/* Generate and write FASTA format */

#define LINE_LENGTH 60

function makeRepeatFasta (String id, String desc, String s, int n) {
   int k = 0, kn = s.length-1, m;
   print ">"+id+" "+desc;
   
   compile while(n) // JIT doubles loop execution speed (if n gets bigger than 200,000)
   {
      int done=n<LINE_LENGTH?n:LINE_LENGTH;  //int done=mathMini(n, LINE_LENGTH);
      m=done; 
      while (m >= (kn - k)) {
         StdOutStream.writeString(s, k, kn-k); // write substring [k..kn] of s to standard output
         m -= kn - k;
         k = 0;
      }
      StdOutStream.writeString(s, k, m);
      StdOutStream.i8='\n'; 
      k += m;
      n -= done;
   }
 }

function makeRandomFasta (String id, String desc, Aminoacids genelist[], int n) {
   int todo = n;
   int i, m;
   
   print ">"+id+" "+desc;
   
   String pick; pick.alloc(LINE_LENGTH+1);
   compile while(todo>0) 
   { // the JIT is almost useless for this loop since the loop body is a "hybrid statement"
      m=mathMini(todo, LINE_LENGTH);
      i=0; // 90% of the loop execution time is spent in selectRandom()
      loop(m) pick[i++] = selectRandom (genelist); // the function call itself eats 3% cpu time (38% if the function would just return ' ')
      pick[m] = 0; // please notice that writing to String chars is not JITed. 
      print pick; // This could eventually be replaced by  "s.fromArray(pick); print s;" (if pick was a "char pick[LINE_LENGTH+1];") 
      todo -= LINE_LENGTH;
   }
}

/* Main -- define alphabets, make 3 fragments */

function Doublef   (float _f)  { local Double d=_f; return deref d; }
function DoubleS   (String _s) { local Double d=_s; return deref d; }
function Aminoacids(char _c, Double _p) { local Aminoacids a; a.c=_c; a.p=_p; return deref a; }

Aminoacids iub[] = [
    Aminoacids('a', Doublef(0.27))
    Aminoacids('c', Doublef(0.12))
    Aminoacids('g', Doublef(0.12))
    Aminoacids('t', Doublef(0.27))

    Aminoacids('B', Doublef(0.02))
    Aminoacids('D', Doublef(0.02))
    Aminoacids('H', Doublef(0.02))
    Aminoacids('K', Doublef(0.02))
    Aminoacids('M', Doublef(0.02))
    Aminoacids('N', Doublef(0.02))
    Aminoacids('R', Doublef(0.02))
    Aminoacids('S', Doublef(0.02))
    Aminoacids('V', Doublef(0.02))
    Aminoacids('W', Doublef(0.02))
    Aminoacids('Y', Doublef(0.02))
 ];

Aminoacids homosapiens[] = [
   Aminoacids('a', DoubleS("0.3029549426680"))
   Aminoacids('c', DoubleS("0.1979883004921"))
   Aminoacids('g', DoubleS("0.1975473066391"))
   Aminoacids('t', DoubleS("0.3015094502008"))
];


String alu =
"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"
"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"
"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"
"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"
"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"
"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"
"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

function main() {
   int n=Arguments.numElements?Arguments[0]:1000;
   
   int t=milliSeconds();

   makeCumulative (iub);
   makeCumulative (homosapiens);
   
   makeRepeatFasta ("ONE", "Homo sapiens alu", alu, n*2);
   makeRandomFasta ("TWO", "IUB ambiguity codes", iub, n*3);
   makeRandomFasta ("THREE", "Homo sapiens frequency", homosapiens, n*5);

   t=milliSeconds()-t; stderr "t(ms)="+t+"\n";
}
