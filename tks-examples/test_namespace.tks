//
//   file: test_namespace.tks
// author: Bastian Spiegel <bs@tkscript.de>
//   date: 06-Apr-2008, 07-Apr-2008, 08-Apr-2008, 09-May-2008
//

// General note on namespaces in TkScript:
//
//    - each module has its own namespace for variables and functions
//    - functions are always located in the namespace of the module, no matter what "namespace" is selected
//    - the "default" namespace is special:
//       - variables declared when the default namespace is "current" are placed in the namespace of the current module
//       - when any other namespace than "default" is current, variables are placed in that namespace
//    - classes are always placed in the current namespace
//

// ---------------------------------------------------------------------------- namespace "test"
namespace test;

int i = 64;

class Test { }
trace "hello, world.";

String s = "hello, world.";



// ---------------------------------------------------------------------------- default namespace
namespace default;

int i = 23;

test::i = 42;

trace "test::i="+test::i;

// Test C++ property
trace test::s.length;

// Test C++ method call
trace test::s.getLength();

// Test pointer assignment
test::s <= null;

// Test pre/post inc/dec statements
++::i;
trace "st: ++::i = "+ ::i;
--::i;
trace "st: --::i = "+ ::i;
::i++;
trace "st: ::i++ = "+ ::i;
::i--;
trace "st: ::i-- = "+ ::i;

// Test pre/post inc/dec expr.
trace "expr: ++::i = "+ ++::i;
trace "expr: --::i = "+ --::i;
trace "expr: ::i++ = "+ ::i++;
trace "expr: ::i-- = "+ ::i--;
trace "expr: ::i = "+ ::i;

trace "test::i = "+ (test::i); // -> 42

test::Test test_test;

Object o <= new test::Test();

class Test {
   Object o;
   test::Test t2;

   define exception MyException;

   public method test_returns_default_Test() returns Test { return true; }
   public method test_returns_test_Test() returns test::Test { return true; }
   public static method MyStaticMethod() { }
}

Test default_test;
if(! (default_test.test_returns_default_Test() instanceof Test))
{
   die("default_test.test() does not return Test type");
}

if(! (default_test.test_returns_test_Test() instanceof test::Test))
{
   die("default_test.test() does not return test::Test type");
}



class TestDerive extends test::Test {}

function FTest(test::Test _t) {}

function FTest2(yac::ListNode _t) {}

function FTest3(::Test _t) {}

class Test2 extends Test {
   public method test2() { }
}

trace "hello, world.";


// ---------------------------------------------------------------------------- namespace "two"
namespace two;

int i = 128;

class ClassTwo { 
   public method test_arglist(test::Test _arg1, ::Test _arg2) { }

   public static method MyStaticMethod() { }
}


// ---------------------------------------------------------------------------- namespace "three"
namespace three;

class Test {

   define exception MyError;

   ::Test default_test;
   test::Test test_test;

   test() {
   }
}

try {
   throw three::Test::MyError("d'oh");
}
catch(three::Test::MyError e) {
   trace "caught exception three::Test::MyError. msg=\""+e.message+"\".";
}

class TestDerive extends ::Test {}

int i = 64;

trace "::i="+ ::i;
trace "test::i="+ test::i;
trace "three::i="+ three::i;
trace "i="+ i; // three::i



// ---------------------------------------------------------------------------- search test
use namespace default;

use namespace two;

ClassTwo classtwo;

two::ClassTwo.MyStaticMethod(); // Note: *NOT* two::ClassTwo::MyStaticMethod!

::Test.MyStaticMethod();


// ---------------------------------------------------------------------------- exception define madness
namespace default;


define exception MyBaseError;
define exception MyOtherBaseError;

class MyClass {
   define exception MyBaseError : ::MyBaseError;
}

namespace one;

class MyClass {
   define exception MyBaseError;
}

namespace test;

class ExceptionTest {
   define exception MyOtherBaseError;
   define exception MyError : ::MyBaseError;
   define exception MyError2 : ::MyClass::MyBaseError;
   define exception MyError3 : one::MyClass::MyBaseError;
   define exception MyError4 : ::MyOtherBaseError;
   define exception MyError5 : MyOtherBaseError;
}

define exception MyGlobalException : ::MyClass::MyBaseError;
define exception MyGlobalException2 : one::MyClass::MyBaseError;
define exception MyGlobalException3 : MyBaseError;


try {
   throw ::Test::MyException("d'oh");
} catch(::Test::MyException e) {
   trace "caught ::Test::MyException msg=\""+e.message+"\".";
}

try {
   throw test::ExceptionTest::MyError("d'oh");
} catch(test::ExceptionTest::MyError e) {
   trace "caught test::Test::MyError msg=\""+e.message+"\".";
}


