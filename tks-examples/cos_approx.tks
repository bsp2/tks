
// https://stackoverflow.com/questions/18662261/fastest-implementation-of-sine-cosine-and-square-root-in-c-doesnt-need-to-b

   // inline T cos(T x) noexcept
   // {
   //     constexpr T tp = 1./(2.*M_PI);
   //     x *= tp;
   //     x -= T(.25) + std::floor(x + T(.25));
   //     x *= T(16.) * (std::abs(x) - T(.5));
   //     #if EXTRA_PRECISION
   //     x += T(.225) * x * (std::abs(x) - T(1.));
   //     #endif
   //     return x;
   // }

function myfloor(float x) {
   return int(x);
}

function cos_approx(float x) {
   x *= (1.0f / 2PI);
   // trace "float: x="+x+" myfloor(x + 0.25f)="+myfloor(x + 0.25f);
   // trace "float: 0.25f + myfloor(x + 0.25f)="+(0.25f + myfloor(x + 0.25f));
   x -= 0.25f + myfloor(x + 0.25f);
   // trace "float: x="+x;
   // trace "float: (abs(x) - 0.5f)="+((abs(x) - 0.5f));
   x *= 16.0f * (abs(x) - 0.5f);
   x += 0.225f * x * (abs(x) - 1.0f);
   return x;
}

function cos_approx_fix(float _x) {
   int bits = 16;
   int one  = (1 << bits);
   int mask = one - 1;
   int x = _x * (one / 2PI);
   // trace "fix: x="+(x/2048.0)+" myfloor(x + 0.25)="+(((x + 512)&~2047)/2048.0);
   // trace "fix: 512 + ((x + 512)&~2047)="+((512 + ((x + 512)&~2047))/2048.0);
   x -= int(one * 0.25 + 0.5) + ((x + int(one * 0.25 + 0.5))&~mask);
   // trace "fix: x="+(x/2048.0);
   // trace "fix: ((x<0?-x:x) - 1024)="+(((x<0?-x:x) - 1024)/2048.0);
   x = 16 * ((x * ((x<0?-x:x) - int(one * 0.5 + 0.5))) >> bits);
   x += (((int(one * 0.225 + 0.5) * x)>>bits) * ((x<0?-x:x) - one)) >> bits;
   return x / float(one);
}

float a = 0;
float aStep = PI2/64.0;
float maxErrF = 0;
float maxErrI = 0;
loop(64)
{
   float c = cos(a);
   float caf = cos_approx(a);
   float cai = cos_approx_fix(a);
   float err = abs(caf - c);
   if(err > maxErrF)
      maxErrF = err;
   err = abs(cai - c);
   if(err > maxErrI)
      maxErrI = err;
   trace "a="+a+" cos="+c+" cos_approx_float="+caf+" cos_approx_int="+cai;
   a += aStep;
}
trace "maxErrF="+maxErrF+" maxErrI="+maxErrI;
