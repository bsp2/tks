LFSR lfsr;
lfsr.init(0xfb912345, 0/*numPre*/);
float min = 9999999;
float max = -9999999;
loop(10000)
{
   float r = lfsr.randf(1.0f);
   min = mathMinf(min, r);
   max = mathMaxf(max, r);
}
trace "lfsr min="+min+" max="+max;



// non-repeating:
LFSR_NR lfsrNR;
int len = (0 == Arguments.numElements) ? 32 : int(Arguments[0]);
int rep = (Arguments.numElements < 2) ? 10000 : int(Arguments[1]);
int i = 0;
trace "@(lfsrNR)="+@(lfsrNR);
lfsrNR.init(0/*0=addr of this as seed*/, len, 0/*numPre*/);

// validate w/o time measurement:
IntArray lastRand; lastRand.alloc(len);
int repIdx = 0;
loop(rep)
{
   lastRand.empty();
   i = 0;
   loop(len)
   {
      int ri = lfsrNR.next;
      // trace "lfsr_nr["+i+"]="+ri;
      if(lastRand.contains(ri))
         die "LFSR_NR failed (duplicate rand). repIdx="+repIdx;
      lastRand.add(ri);
      i++;
   }
   repIdx++;
}

trace "lfsr_nr validated OK, starting benchmark..";

// repeat with time measurement:
lfsrNR.init(0/*0=addr of this as seed*/, len, 8/*numPre*/);
repIdx = 0;
int t = milliSeconds();
loop(rep * len)
   lfsrNR.getNext();
t = milliSeconds() - t;
float randPerSec = 1000.0 / (float(t) / (rep * len));
trace "lfsr_nr randPerSec: rep="+rep+" len="+len+" => "+(rep*len)+" rands, t="+t+" ms => "+float(randPerSec/1000000.0)+" mrand/sec";

trace "done.";
