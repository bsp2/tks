// test.tks

use yingtest;

int t,t1,t2;

MyClass c;

// ---- test some functions ----
Say_Hello();
Say_Hello2(); // test mangled name (calls _Say_Hello2() )

// ---- test simple C++ object ----
MyVector mv;
mv.x=11.1; mv.y=22.2; mv.z=33.3;
print "mv.abs = "+mv.abs;
printMyVector(mv);
print mv.yacMethodGetNames();

// ---- test object setter/getter
print new MyClass().string;
MyClass mc;
mc.myString="myString value";
print "mc.myString=\""+mc.myString+"\"";
print "mc.a="+mc.a; // property from base class
String vs<=new String; vs="test-value";
mc.myStringValue=#(deref vs);
mc.i = 1; mc.j = 2; mc.k = 3;
print "mc.getMyString()="+mc.getMyString();
print "mc.myString="+mc.myString;
print "mc.getString()="+mc.getString();
print "mc.string="+mc.string;
print "mc="+mc;

// ---- test C++ object array ----
MyVector mva[32];
MyVector tmv;
loop(mva.maxElements)
{
    tmv<=mva.nextFree;
       //trace "tmv="+tmv;
    tmv.x=1;
}

trace "Fun_ReturnI(2, 3)="+Fun_ReturnI(2, 3);
trace "Fun_ReturnF(2.2, 3.3)="+Fun_ReturnF(2.2, 3.3);

trace (#(Fun_ReturnNewMyClass())).string;


// ---- benchmark call speed ----
int i_r;
int t_ccall_iret_cpp=milliSeconds();
i_r=Fun_ReturnI_CPP();
t_ccall_iret_cpp=(milliSeconds()-t_ccall_iret_cpp);
float t_ccall_iret_cpp_sec=10000000*(1000.0/t_ccall_iret_cpp);
trace "t_ccall_iret_cpp="+t_ccall_iret_cpp+" ("+t_ccall_iret_cpp_sec+" calls/sec) (ir="+i_r+")";

float f_r;
int t_ccall_fret_cpp=milliSeconds();
f_r=Fun_ReturnF_CPP();
t_ccall_fret_cpp=(milliSeconds()-t_ccall_fret_cpp);
float t_ccall_fret_cpp_sec=10000000*(1000.0/t_ccall_fret_cpp);
trace "t_ccall_fret_cpp="+t_ccall_fret_cpp+" ("+t_ccall_fret_cpp_sec+" calls/sec) (fr="+f_r+")";

int t_ccall_iret=milliSeconds();
compile {
    printMyVector(mv);
    i_r=1;
    loop(1000000)
  	{
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
	    i_r=i_r+Fun_ReturnI(i_r, i_r);
  	}
}
t_ccall_iret=(milliSeconds()-t_ccall_iret);
float t_ccall_iret_sec=10000000*(1000.0/t_ccall_iret);
trace "t_ccall_iret_tks="+t_ccall_iret+" ("+t_ccall_iret_sec+" calls/sec) (ir="+i_r+")";

int t_ccall_fret=milliSeconds();
compile {
    f_r=0.9;
    loop(1000000)
	{
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	    f_r=f_r+Fun_ReturnF(f_r, f_r);
	}
}
t_ccall_fret=(milliSeconds()-t_ccall_fret);
float t_ccall_fret_sec=10000000*(1000.0/t_ccall_fret);
trace "t_ccall_fret_tks="+t_ccall_fret+" ("+t_ccall_fret_sec+" calls/sec) (fr="+f_r+")";


c.test1();


// ---- test constants ----
trace "test constants: XXXPI="+XXXPI+" XXXA="+XXXA+" XXXB="+XXXB;

c.setA(42);
trace "c.getA()="+c.getA();

c.a=77;
trace "c.a="+c.a;


c.manyargs(42,2PI,"mystring",c);

trace "hello, world."+c;





MyClass c2;
int i,j,k;
float f;

compile {
    
  c.test1();
  c.test2(42);
  i=c.test4(3);
  j=c.test3();
  f=c.test8("hello");
  c2<=c.test10();

  c.i=77;
  k=c.i;
  c.calcState(42.42, 1);

  //c.manyargs(42,2PI,"mystring",c);
  t1=milliSeconds();
  loop(10000000)
      {
	  j=c.a;
	  j=c.a;
	  j=c.a;
	  j=c.a;
	  j=c.a;
	  j=c.a;
	  j=c.a;
	  j=c.a;
	  j=c.a;
	  j=c.a;
      }
  t1=milliSeconds()-t1;
}

trace "t1="+t1;
trace "i="+i;
trace "j="+j;
trace "k="+k;
trace "c2="+c2;

print TestVarRetMangled("hello TestVarRetMangled");

// Test Exception
try {
   Raise_InvalidPointer();
}
catch(InvalidPointer e)
{
   trace "\nOK: caught InvalidPointer exception thrown in C++ plugin.";
}


//
//
// Test =>, <=> return object assignments
//
//
class C_ReturnAssignment {
   MyClass mc;

   test() {
      Float f;
      Double d;
      
      // Test => return object assignment
      mc.testObjRet0() => f;
      trace "C_ReturnAssignment::test: f="+f;
      trace "C_ReturnAssignment::test: d="+(mc.testObjRet1(64) <=> d); // => 64
      
      // Test "RVAL" variant
      f <= mc.testObjRet1(23);
      trace "C_ReturnAssignment::test: f="+#(deref f); // => 23

      // Modify self using "RARG" variant:
      mc.i = -1;
      mc.testObjRet1(42) => mc;
      trace "C_ReturnAssignment::test: RARG mc.i="+mc.i; // => 42
      
      // Modify self using "RSELF" variant:
      mc.i = -1;
      mc.testObjRet1(128) => *;
      trace "C_ReturnAssignment::test: RSELF mc.i="+mc.i; // => 128

      // Modify self using "RSELF" variant and return self:
      mc.i = -1;
      trace "C_ReturnAssignment::test: RSELF ="+ (mc.testObjRet1(256)<=>*); // => 256
      
      // Modify self using fallback to RARG variant (since no "RSELF" variant is available for testObjRet0()):
      mc.i = -1;
      mc.testObjRet0() => *;
      trace "C_ReturnAssignment::test: RSELF_emul mc.i="+mc.i; // => 42

      // Modify self using fallback to RARG variant (since no "RSELF" variant is available for testObjRet0()) and return self:
      mc.i = -1;
      trace "C_ReturnAssignment::test: RSELF_emul mc.i="+(mc.testObjRet0()<=>*); // => 42
   }
}

function Test_Method_ReturnAssignment_Member() {
   // "mc" is a classmember in this testcase
   C_ReturnAssignment ra;
   ra.test();
}

function Test_Method_ReturnAssignment_Direct() {
   // "mc" is a simple variable in this testcase
   Float f;
   Double d;
   MyClass mc;
   
   // Test => return object assignment
   mc.testObjRet0() => f;
   trace "Test_Method_ReturnAssignment_Direct: f="+f;
   trace "Test_Method_ReturnAssignment_Direct: d="+(mc.testObjRet1(64) <=> d); // => 64
      
   // Test "RVAL" variant
   f <= mc.testObjRet1(23);
   trace "Test_Method_ReturnAssignment_Direct: f="+#(deref f); // => 23

   // Modify self using "RARG" variant:
   mc.i = -1;
   mc.testObjRet1(42) => mc;
   trace "Test_Method_ReturnAssignment_Direct: RARG mc.i="+mc.i; // => 42

   // Modify self using "RSELF" variant:
   mc.i = -1;
   mc.testObjRet1(128) => *;
   trace "Test_Method_ReturnAssignment_Direct: RSELF mc.i="+mc.i; // => 128

   // Modify self using "RSELF" variant and return self:
   mc.i = -1;
   trace "Test_Method_ReturnAssignment_Direct: RSELF ="+ (mc.testObjRet1(256)<=>*); // => 256

   // Modify self using fallback to RARG variant (since no "RSELF" variant is available for testObjRet0()):
   mc.i = -1;
   mc.testObjRet0() => *;
   trace "Test_Method_ReturnAssignment_Direct: RSELF_emul mc.i="+mc.i; // => 42

   // Modify self using fallback to RARG variant (since no "RSELF" variant is available for testObjRet0()) and return self:
   mc.i = -1;
   trace "Test_Method_ReturnAssignment_Direct: RSELF_emul mc.i="+(mc.testObjRet0()<=>*); // => 42

}


function Test_Function_ReturnAssignment() {
   Float f;
   Double d;

   // Test => return object assignment
   TestObjRet0() => f;
   trace "Test_Function_ReturnAssignment: f="+f;
   trace "Test_Function_ReturnAssignment: d="+(TestObjRet1(64) <=> d);

   // Test "RVAL" variant
   f <= TestObjRet1(23);
   trace "Test_Function_ReturnAssignment: f="+#(deref f);

}

// Run =>, <=> tests
Test_Function_ReturnAssignment();
Test_Method_ReturnAssignment_Direct();
Test_Method_ReturnAssignment_Member();
